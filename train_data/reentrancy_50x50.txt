1 0x1c8c70478e92abc44843245bd6d88035236b4ed9.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address[] private VAR3;
address[] private VAR4;
address private VAR5;
mapping(address => uint) private VAR6;
uint private VAR7 = 38;
uint private VAR8 = 0;
modifier FUN1() {
require(msg.sender == VAR5);
VAR9;
}
constructor () public {
VAR5 = msg.sender;
}
function FUN2 (uint VAR10, uint VAR11, string VAR12, address VAR13) public adminOnly payable {
VAR7 ++;
address VAR14 = VAR15 FUN3(VAR7, VAR10, VAR11, VAR12, VAR13);
VAR3.FUN4(VAR14);
VAR6[VAR14] = VAR3.VAR16;
FUN5(VAR14, msg.value);
}
function FUN6() public view returns (address[]) {
return VAR3;
}
function FUN7() public view returns (address[]) {
return VAR4;
}
function FUN5(address VAR17, uint VAR18) adminOnly public {
if (VAR18 > 0) {
MajorityGame VAR19 = FUN3(VAR17);
VAR19.VAR20.value(VAR18)();
}
}
function FUN8(address VAR17) public {
uint VAR21 = VAR6[address(VAR17)];
VAR8++;
VAR4.FUN4(VAR17);
VAR3[VAR21-1] = VAR3[VAR3.VAR16-1];
VAR6[VAR3[VAR3.VAR16-1]] = VAR21;
delete VAR3[VAR3.VAR16-1];
VAR3.VAR16--;
MajorityGame VAR19 = FUN3(address(VAR17));
VAR19.FUN8();
}
function FUN9(address VAR17) public VAR22 {
uint VAR21 = VAR6[address(VAR17)];
VAR8++;
VAR4.FUN4(VAR17);
VAR3[VAR21-1] = VAR3[VAR3.VAR16-1];
VAR6[VAR3[VAR3.VAR16-1]] = VAR21;
delete VAR3[VAR3.VAR16-1];
VAR3.VAR16--;
MajorityGame VAR19 = FUN3(address(VAR17));
VAR19.FUN9();
}
}
contract VAR23 {
uint private VAR24;
uint private VAR25;
uint private VAR26;
address private VAR5;
address private VAR27;
uint private VAR28;
uint private VAR29;
string private VAR30;
mapping(address => bool) private VAR31;
mapping(address => bool) private VAR32;
address[] private VAR33;
address[] private VAR34;
uint private VAR35;
address[] private VAR36;
address private VAR37;
uint private VAR38;
uint private VAR39;
uint private VAR40;
modifier FUN1() {
require(msg.sender == VAR5);
VAR9;
}
modifier FUN10() {
require(VAR41 >= VAR28);
require(VAR41 <= VAR29);
VAR9;
}
modifier FUN11() {
require(VAR41 > VAR29);
VAR9;
}
modifier FUN12() {
require(VAR38 == 0);
VAR9;
}
modifier FUN13() {
require(VAR38 > 0);
VAR9;
}
modifier FUN14() {
require((VAR33.VAR16 + VAR34.VAR16) < 500);
VAR9;
}
constructor(uint VAR42, uint VAR10, uint VAR11, string VAR12, address VAR13) public {
VAR24 = VAR42;
VAR5 = msg.sender;
VAR26 = VAR10;
VAR28 = VAR11 - 25*60*60;
VAR29 = VAR11;
VAR30 = VAR12;
VAR38 = 0;
VAR40 = 0;
VAR27 = VAR13;
}
function FUN5() public payable adminOnly returns (bool) {
if (msg.value > 0) {
VAR25 += msg.value;
return true;
}
return false;
}
function FUN15() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) {
return (
VAR24,
VAR28,
VAR29,
VAR33.VAR16 + VAR34.VAR16,
address(this).VAR43,
VAR30,
VAR25,
VAR38,
VAR26
);
}
function FUN16(uint VAR44) public payable notEnded VAR45 {
require(!VAR31[msg.sender] && !VAR32[msg.sender]);
require(msg.value == VAR26);
if (VAR44 == 1) {
VAR31[msg.sender] = true;
VAR33.FUN4(msg.sender);
} else if (VAR44 == 2) {
VAR32[msg.sender] = true;
VAR34.FUN4(msg.sender);
}
if(VAR33.VAR16 + VAR34.VAR16 <= 6){
VAR36.FUN4(msg.sender);
}
VAR37 = msg.sender;
}
function FUN8() public VAR46 {
require(VAR38 == 0);
VAR39 = address(this).VAR43;
uint VAR47 = VAR39 * 9 / 10;
uint VAR48 = uint(VAR33.VAR16);
uint VAR49 = uint(VAR34.VAR16);
uint VAR50 = VAR48 + VAR49;
if(VAR50 == 0 ){
VAR40 = 0;
VAR35 = 0;
if(VAR24 % 2 == 1){
VAR38 = 1;
}else{
VAR38 = 2;
}
return;
}else{
if (VAR48 != 0 && VAR50 / VAR48 > 10) {
VAR38 = 1;
} else if (VAR49 != 0 && VAR50 / VAR49 > 10) {
VAR38 = 2;
} else if (VAR48 > VAR49 || (VAR48 == VAR49 && VAR24 % 2 == 1)) {
VAR38 = 1;
} else {
VAR38 = 2;
}
}
if (VAR38 == 1) {
VAR40 = uint(VAR47 / VAR48);
VAR35 = VAR48;
} else {
VAR40 = uint(VAR47 / VAR49);
VAR35 = VAR49;
}
}
function FUN9() public VAR22 {
require(VAR38 == 0);
VAR39 = address(this).VAR43;
uint VAR47 = VAR39 * 9 / 10;
uint VAR48 = uint(VAR33.VAR16);
uint VAR49 = uint(VAR34.VAR16);
uint VAR50 = VAR48 + VAR49;
if(VAR50 == 0 ){
VAR40 = 0;
VAR35 = 0;
if(VAR24 % 2 == 1){
VAR38 = 1;
}else{
VAR38 = 2;
}
return;
}
if (VAR48 != 0 && VAR50 / VAR48 > 10) {
VAR38 = 1;
} else if (VAR49 != 0 && VAR50 / VAR49 > 10) {
VAR38 = 2;
} else if (VAR48 > VAR49 || (VAR48 == VAR49 && VAR24 % 2 == 1)) {
VAR38 = 1;
} else {
VAR38 = 2;
}
if (VAR38 == 1) {
VAR40 = uint(VAR47 / VAR48);
VAR35 = VAR48;
} else {
VAR40 = uint(VAR47 / VAR49);
VAR35 = VAR49;
}
}
function FUN17() public VAR51 {
require(VAR35 > 0);
uint VAR52 = VAR35;
if (VAR35 > 400) {
for (uint VAR53 = 0; VAR53 < 400; VAR53++) {
this.FUN18();
}
} else {
for (uint VAR54 = 0; VAR54 < VAR52; VAR54++) {
this.FUN18();
}
}
}
function FUN18() public VAR51 {
require(VAR35 > 0);
if(VAR38 == 1){
address(VAR33[VAR35 - 1]).transfer(VAR40);
}else{
address(VAR34[VAR35 - 1]).transfer(VAR40);
}
VAR35--;
if(VAR35 == 0){
if(VAR33.VAR16 + VAR34.VAR16 >= 7){
uint VAR55 = uint(VAR39 / 200);
for (uint VAR56 = 0; VAR56 < 6; VAR56++) {
address(VAR36[VAR56]).transfer(VAR55);
}
address(VAR37).transfer(uint(VAR39 / 50));
}
address(VAR27).transfer(address(this).VAR43);
}
}
function FUN19() public isEnded view returns (uint, uint, uint, uint, uint) {
return (
VAR38,
VAR33.VAR16,
VAR34.VAR16,
VAR39,
VAR40
);
}
function FUN20() public view returns (uint) {
if (VAR31[msg.sender]) {
return 1;
} else if (VAR32[msg.sender]) {
return 2;
} else {
return 0;
}
}
function FUN21() public isEnded view returns (address[]) {
if (VAR38 == 1) {
return VAR33;
}else {
return VAR34;
}
}
function FUN22() public isEnded view returns (address[]) {
if (VAR38 == 1) {
return VAR34;
}else {
return VAR33;
}
}
}
1
---------------------------------
2 0x1cbadc277dea8d4e4d017dad65617591bd3f60e8.sol
pragma VAR1 ^0.4.8;
contract VAR2 {
address VAR3;
modifier onlyOwner {
if (msg.sender != VAR3) {
throw;
}
VAR4;
}
function FUN1() {
VAR3 = msg.sender;
}
function FUN2(address VAR5) onlyOwner {
VAR3 = VAR5;
}
function FUN3() onlyOwner {
FUN4(VAR3);
}
function FUN5() onlyOwner {
if (!VAR3.FUN6(this.VAR6)) {
throw;
}
}
}
contract VAR7 {
string public VAR8;
function FUN2(address VAR5);
}
contract LotteryRoundFactoryInterfaceV1 is VAR7 {
function FUN7(bytes32 VAR9, bytes32 VAR10) payable returns(address);
}
contract VAR11 {
bool public VAR12;
uint256 public VAR13;
function FUN8(bytes4 VAR14) payable;
function FUN9() payable;
function FUN10(bytes32 VAR15, uint8 VAR16) constant returns(bool);
function FUN11(bytes32 VAR15, uint8 VAR16);
function FUN12(address VAR17);
function FUN5();
function FUN3();
function FUN13();
function FUN14();
function FUN15() constant returns(bool);
function FUN2(address VAR5);
}
contract VAR18 {
address public VAR19;
function FUN16() returns(address);
function FUN17() constant returns(bool);
function FUN2(address VAR5);
}
contract LotteryGameLogicInterfaceV1 is VAR18 {
function FUN18() payable;
function FUN19(address VAR20);
}
contract LotteryGameLogic is VAR21, VAR2 {
LotteryRoundFactoryInterfaceV1 public VAR22;
address public VAR23;
LotteryRoundInterface public VAR19;
modifier VAR24 {
if (VAR19 != FUN20(0)) {
throw;
}
VAR4;
}
modifier VAR25 {
if (
VAR19 == FUN20(0) ||
VAR26.VAR27 <= VAR19.FUN21() ||
VAR19.FUN22() == true
) {
throw;
}
VAR4;
}
modifier VAR28 {
if (
VAR19 == FUN20(0) ||
VAR19.FUN22() == false
) {
throw;
}
VAR4;
}
modifier VAR29 {
if (msg.sender != VAR23) {
throw;
}
VAR4;
}
modifier VAR30 {
if (msg.sender != address(VAR19)) {
throw;
}
VAR4;
}
function FUN23(address VAR31, address VAR32) {
VAR22 = FUN24(VAR31);
VAR23 = VAR32;
}
function FUN19(address VAR20) onlyCurator VAR24 {
VAR23 = VAR20;
}
function FUN17() constant returns(bool) {
return VAR19 == FUN20(0) && this.VAR6 < 1 VAR33;
}
function FUN25(bytes32 VAR34, bytes32 VAR35) onlyCurator VAR24 {
if (this.VAR6 > 0) {
VAR19 = FUN20(
VAR22.VAR36.value(this.VAR6)(VAR34, VAR35)
);
} else {
VAR19 = FUN20(VAR22.FUN7(VAR34, VAR35));
}
}
function FUN26(bytes32 VAR15, uint8 VAR16) onlyCurator VAR25 {
VAR19.FUN11(VAR15, VAR16);
}
function FUN16() onlyOwner VAR28 returns(address) {
address VAR37 = address(VAR19);
if (!VAR19.FUN15()) {
VAR19.FUN13();
VAR19.FUN12(VAR23);
} else if (VAR19.VAR6 > 0) {
VAR19.FUN5();
}
VAR19.FUN2(VAR23);
delete VAR19;
return VAR37;
}
function FUN18() payable onlyOwner VAR24 {
}
function () payable VAR30 {
}
}
1
---------------------------------
3 0x1e8ffb58526e804137b136f94b785f9017724b62.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 value) public returns (bool);
event Transfer(address indexed VAR5, address indexed VAR4, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR6, address VAR7)
public view returns (uint256);
function FUN4(address VAR5, address VAR4, uint256 value)
public returns (bool);
function FUN5(address VAR7, uint256 value) public returns (bool);
event FUN6(
address indexed VAR6,
address indexed VAR7,
uint256 value
);
}
contract IBasicMultiToken is VAR8 {
event FUN7(address indexed VAR3, address indexed VAR9, uint256 value);
event FUN8(address indexed VAR3, address indexed VAR9, uint256 value);
function FUN9() public view returns(uint256);
function FUN10(uint256 VAR10) public view returns(VAR8);
function FUN11() public view returns(VAR8[]);
function FUN12() public view returns(uint8[]);
function FUN13() public view returns(uint256[]);
function FUN14() public view returns(VAR8[], uint8[], uint256[]);
function FUN15(address VAR11, uint256 VAR12, uint256[] VAR13) public;
function FUN16(address VAR11, uint256 VAR12) public;
function FUN17(address VAR11, uint256 VAR14) public;
function FUN18(address VAR11, uint256 VAR14, VAR8[] VAR15) public;
function FUN19() public;
function FUN20() public;
}
contract IMultiToken is VAR16 {
event FUN21();
event FUN22(address indexed VAR17, address indexed VAR18, address indexed VAR19, uint256 VAR12, uint256 VAR20);
function FUN23(address VAR17, address VAR18, uint256 VAR12) public view returns (uint256 VAR21);
function FUN24(address VAR17, address VAR18, uint256 VAR12, uint256 VAR22) public returns (uint256 VAR21);
function FUN25() public view returns(uint256[] VAR23);
function FUN26() public view returns(VAR8[] VAR15, uint8[] VAR24, uint256[] VAR25, uint256[] VAR23);
function FUN27() public;
}
library VAR26 {
function FUN28(uint256 VAR27, uint256 VAR28) internal pure returns (uint256 VAR29) {
if (VAR27 == 0) {
return 0;
}
VAR29 = VAR27 * VAR28;
assert(VAR29 / VAR27 == VAR28);
return VAR29;
}
function FUN29(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
return VAR27 / VAR28;
}
function FUN30(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
assert(VAR28 <= VAR27);
return VAR27 - VAR28;
}
function FUN31(uint256 VAR27, uint256 VAR28) internal pure returns (uint256 VAR29) {
VAR29 = VAR27 + VAR28;
assert(VAR29 >= VAR27);
return VAR29;
}
}
contract VAR30 {
address public VAR6;
event FUN32(address indexed VAR31);
event FUN33(
address indexed VAR31,
address indexed VAR32
);
constructor() public {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR33;
}
function FUN34() public onlyOwner {
emit FUN32(VAR6);
VAR6 = address(0);
}
function FUN35(address VAR34) public onlyOwner {
FUN36(VAR34);
}
function FUN36(address VAR34) internal {
require(VAR34 != address(0));
emit FUN33(VAR6, VAR34);
VAR6 = VAR34;
}
}
library VAR35 {
function FUN37(ERC20Basic VAR36, address VAR4, uint256 value) internal {
require(VAR36.transfer(VAR4, value));
}
function FUN38(
ERC20 VAR36,
address VAR5,
address VAR4,
uint256 value
)
internal
{
require(VAR36.FUN4(VAR5, VAR4, value));
}
function FUN39(ERC20 VAR36, address VAR7, uint256 value) internal {
require(VAR36.FUN5(VAR7, value));
}
}
contract CanReclaimToken is VAR30 {
using SafeERC20 for VAR2;
function FUN40(ERC20Basic VAR36) external onlyOwner {
uint256 VAR37 = VAR36.FUN2(this);
VAR36.FUN37(VAR6, VAR37);
}
}
contract VAR38 {
function FUN41(
address[] VAR39,
uint256 VAR12,
uint256 VAR22
)
public
payable
returns(uint256);
function FUN42(
address[] VAR39,
uint256 VAR12,
uint256 VAR22
)
public
payable
returns(uint256);
}
contract VAR40 {
function FUN43(
address VAR41,
uint VAR42,
address VAR43,
address VAR44,
uint VAR45,
uint VAR46,
address VAR47
)
public
payable
returns(uint);
}
contract MultiChanger is VAR48 {
using SafeMath for uint256;
function FUN44(address VAR49, uint value, bytes VAR50, uint VAR51, uint VAR52) internal returns (bool VAR53) {
VAR54 {
let VAR55 := FUN45(0x40)
let VAR56 := FUN31(VAR50, 32)
VAR53 := call(
FUN30(VAR57, 34710),
VAR49,
value,
FUN31(VAR56, VAR51),
VAR52,
VAR55,
0
)
}
}
function FUN24(
bytes VAR58,
uint[] VAR59
)
internal
{
for (uint VAR60 = 0; VAR60 < VAR59.VAR61 - 1; VAR60++) {
require(FUN44(this, 0, VAR58, VAR59[VAR60], VAR59[VAR60 + 1] - VAR59[VAR60]));
}
}
function FUN46(address VAR62, bytes VAR63, uint256 VAR14) external {
require(VAR62.call.value(VAR14)(VAR63));
}
function FUN47(address VAR62, bytes VAR63, uint256 VAR64, uint256 VAR65) external {
uint256 value = address(this).VAR37.FUN28(VAR64).FUN29(VAR65);
require(VAR62.call.value(value)(VAR63));
}
function FUN48(address VAR62, bytes VAR63, ERC20 VAR17, uint256 VAR12) external {
if (VAR17.FUN3(this, VAR62) != 0) {
VAR17.FUN5(VAR62, 0);
}
VAR17.FUN5(VAR62, VAR12);
require(VAR62.call(VAR63));
}
function FUN49(address VAR62, bytes VAR63, ERC20 VAR17, uint256 VAR64, uint256 VAR65) external {
uint256 VAR66 = VAR17.FUN2(this).FUN28(VAR64).FUN29(VAR65);
if (VAR17.FUN3(this, VAR62) != 0) {
VAR17.FUN5(VAR62, 0);
}
VAR17.FUN5(VAR62, VAR66);
require(VAR62.call(VAR63));
}
function FUN50(address VAR62, bytes VAR63, ERC20 VAR17, uint256 VAR12) external {
VAR17.transfer(VAR62, VAR12);
require(VAR62.call(VAR63));
}
function FUN51(address VAR62, bytes VAR63, ERC20 VAR17, uint256 VAR64, uint256 VAR65) external {
uint256 VAR66 = VAR17.FUN2(this).FUN28(VAR64).FUN29(VAR65);
VAR17.transfer(VAR62, VAR66);
require(VAR62.call(VAR63));
}
function FUN52(IBancorNetwork VAR67, address[] VAR39, uint256 VAR14) external {
VAR67.VAR68.value(VAR14)(VAR39, VAR14, 1);
}
function FUN53(IBancorNetwork VAR67, address[] VAR39, uint256 VAR64, uint256 VAR65) external {
uint256 value = address(this).VAR37.FUN28(VAR64).FUN29(VAR65);
VAR67.VAR68.value(value)(VAR39, value, 1);
}
function FUN54(IBancorNetwork VAR67, address[] VAR39, uint256 VAR12) external {
if (FUN55(VAR39[0]).FUN3(this, VAR67) == 0) {
FUN55(VAR39[0]).FUN5(VAR67, uint256(-1));
}
VAR67.FUN42(VAR39, VAR12, 1);
}
function FUN56(IBancorNetwork VAR67, address[] VAR39, uint256 VAR64, uint256 VAR65) external {
uint256 VAR66 = FUN55(VAR39[0]).FUN2(this).FUN28(VAR64).FUN29(VAR65);
if (FUN55(VAR39[0]).FUN3(this, VAR67) == 0) {
FUN55(VAR39[0]).FUN5(VAR67, uint256(-1));
}
VAR67.FUN42(VAR39, VAR66, 1);
}
function FUN57(IBancorNetwork VAR67, address[] VAR39, uint256 VAR12) external {
FUN55(VAR39[0]).transfer(VAR67, VAR12);
VAR67.FUN41(VAR39, VAR12, 1);
}
function FUN58(IBancorNetwork VAR67, address[] VAR39, uint256 VAR64, uint256 VAR65) external {
uint256 VAR66 = FUN55(VAR39[0]).FUN2(this).FUN28(VAR64).FUN29(VAR65);
FUN55(VAR39[0]).transfer(VAR67, VAR66);
VAR67.FUN41(VAR39, VAR66, 1);
}
function FUN59(IBancorNetwork VAR67, address[] VAR39, uint256 VAR12) external {
VAR67.FUN41(VAR39, VAR12, 1);
}
function FUN60(IBancorNetwork VAR67, address[] VAR39, uint256 VAR64, uint256 VAR65) external {
uint256 VAR66 = FUN55(VAR39[0]).FUN2(VAR67).FUN28(VAR64).FUN29(VAR65);
VAR67.FUN41(VAR39, VAR66, 1);
}
function FUN61(IKyberNetworkProxy VAR69, ERC20 VAR17, address VAR18, uint256 VAR64, uint256 VAR65) external {
uint256 value = address(this).VAR37.FUN28(VAR64).FUN29(VAR65);
VAR69.VAR70.value(value)(
VAR17,
value,
VAR18,
this,
1 << 255,
0,
0
);
}
function FUN62(IKyberNetworkProxy VAR69, ERC20 VAR17, address VAR18, uint256 VAR12) external {
if (VAR17.FUN3(this, VAR69) == 0) {
VAR17.FUN5(VAR69, uint256(-1));
}
VAR69.FUN43(
VAR17,
VAR12,
VAR18,
this,
1 << 255,
0,
0
);
}
function FUN63(IKyberNetworkProxy VAR69, ERC20 VAR17, address VAR18, uint256 VAR64, uint256 VAR65) external {
uint256 VAR66 = VAR17.FUN2(this).FUN28(VAR64).FUN29(VAR65);
this.FUN62(VAR69, VAR17, VAR18, VAR66);
}
}
contract MultiBuyer is VAR71 {
function FUN64(
IMultiToken VAR72,
uint256 VAR73,
bytes VAR58,
uint[] VAR59
)
public
payable
{
FUN24(VAR58, VAR59);
uint VAR74 = VAR72.FUN1();
uint256 VAR75 = uint256(-1);
for (uint VAR60 = VAR72.FUN9(); VAR60 > 0; VAR60--) {
ERC20 VAR36 = VAR72.FUN10(VAR60 - 1);
if (VAR36.FUN3(this, VAR72) == 0) {
VAR36.FUN5(VAR72, uint256(-1));
}
uint256 VAR66 = VAR74.FUN28(VAR36.FUN2(this)).FUN29(VAR36.FUN2(VAR72));
if (VAR66 < VAR75) {
VAR75 = VAR66;
}
}
require(VAR75 >= VAR73, "");
VAR72.FUN16(msg.sender, VAR75);
if (address(this).VAR37 > 0) {
msg.sender.transfer(address(this).VAR37);
}
for (VAR60 = VAR72.FUN9(); VAR60 > 0; VAR60--) {
VAR36 = VAR72.FUN10(VAR60 - 1);
VAR36.transfer(msg.sender, VAR36.FUN2(this));
}
}
function FUN65(
IMultiToken VAR72,
bytes VAR58,
uint[] VAR59
)
public
payable
{
FUN24(VAR58, VAR59);
uint VAR76 = VAR72.FUN9();
uint256[] memory VAR77 = new uint256[](VAR76);
for (uint VAR60 = 0; VAR60 < VAR76; VAR60++) {
ERC20 VAR36 = VAR72.FUN10(VAR60);
VAR77[VAR60] = VAR36.FUN2(this);
if (VAR36.FUN3(this, VAR72) == 0) {
VAR36.FUN5(VAR72, uint256(-1));
}
}
VAR72.FUN15(msg.sender, msg.value.FUN28(1000), VAR77);
if (address(this).VAR37 > 0) {
msg.sender.transfer(address(this).VAR37);
}
for (VAR60 = VAR72.FUN9(); VAR60 > 0; VAR60--) {
VAR36 = VAR72.FUN10(VAR60 - 1);
VAR36.transfer(msg.sender, VAR36.FUN2(this));
}
}
}
1
---------------------------------
4 0x1f4a9567c1f98a8c9d7f026827f099b41a2e54d6.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 != 0);
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR10);
constructor() public {
VAR7 = msg.sender;
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR11;
}
modifier FUN6() {
require(msg.sender == VAR7 || msg.sender == VAR8);
VAR11;
}
function FUN7(address VAR12) public onlyOwner {
require(VAR12 != address(0));
VAR8 = VAR12;
}
function FUN8(address VAR13) public onlyOwner {
require(VAR13 != address(0));
emit FUN5(VAR7, VAR13);
VAR7 = VAR13;
}
}
contract VAR14 {
function FUN9(address VAR15) public view returns (uint);
function transfer(address VAR16, uint VAR17) public returns (bool);
function FUN10(address VAR18, address VAR16, uint VAR17) public returns (bool);
function FUN11(address VAR15, address VAR19) public view returns (uint);
function FUN12(address VAR19, uint VAR17) public returns (bool);
event Transfer(address indexed VAR20, address indexed VAR21, uint VAR22);
event FUN13(address indexed VAR23, address indexed VAR24, uint VAR22);
}
contract DreamcatcherToken is VAR14, VAR6 {
using SafeMath for uint256;
uint256 public constant VAR25 = 2500000000000;
string public constant VAR26 = "";
string public constant VAR27 = "";
uint8 public constant VAR28 = 6;
bool public VAR29 = false;
bool public VAR30 = false;
mapping(address => uint256) internal VAR31;
mapping(address => mapping(address => uint256)) internal VAR32;
mapping(address => bool) internal VAR33;
constructor() public {
VAR31[msg.sender] = VAR25;
}
modifier FUN14() {
require(VAR30 == false);
VAR11;
}
function () public payable {
if(VAR29 == false || VAR30 == true) {
revert();
}
}
function FUN15(address VAR34, uint256 VAR17) external payable VAR35 returns(bool) {
if (VAR29 == false) {
revert();
}
return VAR34.call.value(VAR17)();
}
function FUN16(bool VAR36) external VAR35 {
VAR29 = VAR36;
}
function FUN17(bool VAR37) external onlyOwner {
VAR30 = VAR37;
}
function FUN18(address VAR38, bool VAR39) external VAR35 {
VAR33[VAR38] = VAR39;
}
function FUN9(address VAR15) public view returns (uint) {
return VAR31[VAR15];
}
function transfer(address VAR16, uint VAR17) public checkHalted returns (bool) {
if(msg.sender != VAR7) {
require(VAR33[msg.sender] == false && VAR33[VAR16] == false);
}
VAR31[msg.sender] = VAR31[msg.sender].FUN3(VAR17);
VAR31[VAR16] = VAR31[VAR16].FUN4(VAR17);
emit Transfer(msg.sender, VAR16, VAR17);
return true;
}
function FUN10(address VAR18, address VAR16, uint VAR17) public checkHalted returns (bool) {
if(msg.sender != VAR7) {
require(VAR33[msg.sender] == false && VAR33[VAR18] == false && VAR33[VAR16] == false);
}
require(VAR17 <= VAR31[VAR18]);
if(VAR18 != msg.sender) {
require(VAR17 <= VAR32[VAR18][msg.sender]);
VAR32[VAR18][msg.sender] = VAR32[VAR18][msg.sender].FUN3(VAR17);
}
VAR31[VAR18] = VAR31[VAR18].FUN3(VAR17);
VAR31[VAR16] = VAR31[VAR16].FUN4(VAR17);
emit Transfer(VAR18, VAR16, VAR17);
return true;
}
function FUN11(address VAR15, address VAR19) public view returns (uint) {
return VAR32[VAR15][VAR19];
}
function FUN12(address VAR19, uint VAR17) public checkHalted returns (bool) {
require(VAR33[VAR19] == false && VAR33[msg.sender] == false);
VAR32[msg.sender][VAR19] = VAR17;
emit FUN13(msg.sender, VAR19, VAR17);
return true;
}
}
1
---------------------------------
5 0x201dcb47a936db8d0c6358783a7d24b37d5fd1cd.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
bool private VAR3 = false;
modifier FUN1() {
require(!VAR3);
VAR3 = true;
VAR4;
VAR3 = false;
}
}
library VAR5 {
function FUN2(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
if (VAR6 == 0) {
return 0;
}
uint256 VAR8 = VAR6 * VAR7;
assert(VAR8 / VAR6 == VAR7);
return VAR8;
}
function FUN3(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
uint256 VAR8 = VAR6 / VAR7;
return VAR8;
}
function FUN4(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
assert(VAR7 <= VAR6);
return VAR6 - VAR7;
}
function FUN5(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
uint256 VAR8 = VAR6 + VAR7;
assert(VAR8 >= VAR6);
return VAR8;
}
}
contract VAR9 {
address public VAR10;
event FUN6(address indexed VAR11, address indexed VAR12);
function FUN7() public {
VAR10 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR4;
}
function FUN8(address VAR12) public onlyOwner {
require(VAR12 != address(0));
FUN6(VAR10, VAR12);
VAR10 = VAR12;
}
}
contract RefundVault is VAR9 {
using SafeMath for uint256;
enum VAR13 { VAR14, VAR15, VAR16 }
mapping (address => uint256) public VAR17;
address public VAR18;
State public VAR19;
event FUN9();
event FUN10();
event FUN11(address indexed VAR20, uint256 VAR21);
function FUN12(address VAR22) public {
require(VAR22 != address(0));
VAR18 = VAR22;
VAR19 = VAR13.VAR14;
}
function FUN13(address VAR23) onlyOwner public payable {
require(VAR19 == VAR13.VAR14);
VAR17[VAR23] = VAR17[VAR23].FUN5(msg.value);
}
function FUN14() onlyOwner public {
require(VAR19 == VAR13.VAR14);
VAR19 = VAR13.VAR16;
FUN9();
VAR18.transfer(this.VAR24);
}
function FUN15() onlyOwner public {
require(VAR19 == VAR13.VAR14);
VAR19 = VAR13.VAR15;
FUN10();
}
function FUN16(address VAR23) public {
require(VAR19 == VAR13.VAR15);
uint256 VAR25 = VAR17[VAR23];
VAR17[VAR23] = 0;
VAR23.transfer(VAR25);
FUN11(VAR23, VAR25);
}
}
contract Pausable is VAR9 {
event FUN17();
event FUN18();
bool public VAR26 = false;
modifier FUN19() {
require(!VAR26);
VAR4;
}
modifier FUN20() {
require(VAR26);
VAR4;
}
function FUN21() onlyOwner whenNotPaused public {
VAR26 = true;
FUN17();
}
function FUN22() onlyOwner whenPaused public {
VAR26 = false;
FUN18();
}
}
contract VAR27 {
uint256 public VAR28;
function FUN23(address VAR29) public view returns (uint256);
function transfer(address VAR30, uint256 value) public returns (bool);
event Transfer(address indexed VAR31, address indexed VAR30, uint256 value);
}
contract BasicToken is VAR27 {
using SafeMath for uint256;
mapping(address => uint256) VAR32;
function transfer(address VAR33, uint256 VAR34) public returns (bool) {
require(VAR33 != address(0));
require(VAR34 <= VAR32[msg.sender]);
VAR32[msg.sender] = VAR32[msg.sender].FUN4(VAR34);
VAR32[VAR33] = VAR32[VAR33].FUN5(VAR34);
Transfer(msg.sender, VAR33, VAR34);
return true;
}
function FUN23(address VAR35) public view returns (uint256 VAR24) {
return VAR32[VAR35];
}
}
contract BurnableToken is VAR36 {
event FUN24(address indexed VAR37, uint256 value);
function FUN25(uint256 VAR34) public {
require(VAR34 <= VAR32[msg.sender]);
address VAR37 = msg.sender;
VAR32[VAR37] = VAR32[VAR37].FUN4(VAR34);
VAR28 = VAR28.FUN4(VAR34);
FUN24(VAR37, VAR34);
}
}
contract ERC20 is VAR27 {
function FUN26(address VAR10, address VAR38) public view returns (uint256);
function FUN27(address VAR31, address VAR30, uint256 value) public returns (bool);
function FUN28(address VAR38, uint256 value) public returns (bool);
event FUN29(address indexed VAR10, address indexed VAR38, uint256 value);
}
contract StandardToken is VAR39, VAR36 {
mapping (address => mapping (address => uint256)) internal VAR40;
function FUN27(address VAR41, address VAR33, uint256 VAR34) public returns (bool) {
require(VAR33 != address(0));
require(VAR34 <= VAR32[VAR41]);
require(VAR34 <= VAR40[VAR41][msg.sender]);
VAR32[VAR41] = VAR32[VAR41].FUN4(VAR34);
VAR32[VAR33] = VAR32[VAR33].FUN5(VAR34);
VAR40[VAR41][msg.sender] = VAR40[VAR41][msg.sender].FUN4(VAR34);
Transfer(VAR41, VAR33, VAR34);
return true;
}
function FUN28(address VAR42, uint256 VAR34) public returns (bool) {
VAR40[msg.sender][VAR42] = VAR34;
FUN29(msg.sender, VAR42, VAR34);
return true;
}
function FUN26(address VAR35, address VAR42) public view returns (uint256) {
return VAR40[VAR35][VAR42];
}
function FUN30(address VAR42, uint VAR43) public returns (bool) {
VAR40[msg.sender][VAR42] = VAR40[msg.sender][VAR42].FUN5(VAR43);
FUN29(msg.sender, VAR42, VAR40[msg.sender][VAR42]);
return true;
}
function FUN31(address VAR42, uint VAR44) public returns (bool) {
uint VAR45 = VAR40[msg.sender][VAR42];
if (VAR44 > VAR45) {
VAR40[msg.sender][VAR42] = 0;
} else {
VAR40[msg.sender][VAR42] = VAR45.FUN4(VAR44);
}
FUN29(msg.sender, VAR42, VAR40[msg.sender][VAR42]);
return true;
}
}
contract PausableToken is VAR46, VAR47 {
function transfer(address VAR33, uint256 VAR34) public whenNotPaused returns (bool) {
return super.transfer(VAR33, VAR34);
}
function FUN27(address VAR41, address VAR33, uint256 VAR34) public whenNotPaused returns (bool) {
return super.FUN27(VAR41, VAR33, VAR34);
}
function FUN28(address VAR42, uint256 VAR34) public whenNotPaused returns (bool) {
return super.FUN28(VAR42, VAR34);
}
function FUN30(address VAR42, uint VAR43) public whenNotPaused returns (bool VAR48) {
return super.FUN30(VAR42, VAR43);
}
function FUN31(address VAR42, uint VAR44) public whenNotPaused returns (bool VAR48) {
return super.FUN31(VAR42, VAR44);
}
}
contract DataWalletCrowdsale is VAR9, VAR2 {
using SafeMath for uint256;
uint256 public VAR49;
uint256 public VAR50;
uint256 public VAR51;
uint256 public VAR52;
uint256 public constant VAR53 = 10**uint256(10);
RefundVault public VAR54;
DataWalletToken public VAR55;
uint256 public VAR56;
uint256 public VAR57;
uint256 public VAR58;
bool public VAR59 = false;
uint256 public VAR60;
mapping(address => bool) public VAR61;
mapping(address => uint256) public VAR62;
event FUN32(address indexed VAR63, bool VAR64);
event FUN33(address indexed VAR20, uint256 value, uint256 VAR65);
event FUN34(address indexed VAR66, uint256 VAR65);
event FUN35();
function FUN36(
address VAR67,
address VAR22,
uint256 VAR68,
uint256 VAR69,
uint256 VAR70,
uint256 VAR71,
uint256 VAR72,
uint256 VAR73
) {
require(VAR68 >= FUN37());
require(VAR69 >= VAR68);
require(VAR70 > 0);
require(VAR73 > 0);
require(VAR71 > 0);
require(VAR22 != 0x0);
VAR54 = VAR74 FUN12(VAR22);
VAR55 = FUN38(VAR67);
VAR56 = VAR68;
VAR57 = VAR69;
VAR58 = VAR56 + 1 * 1 VAR75;
VAR49 = VAR72;
VAR52 = VAR70;
VAR51 = VAR73;
VAR50 = VAR71;
}
function () external payable {
FUN39(msg.sender);
}
function FUN39(address VAR20) internal {
require(VAR20 != 0x0);
require(VAR61[VAR20]);
require(FUN40());
uint256 VAR21 = msg.value;
if (FUN37() <= VAR58) {
require((VAR62[VAR20].FUN5(VAR21)) <= VAR49);
}
uint256 VAR76 = VAR50.FUN4(VAR60);
if (VAR21 > VAR76) {
VAR21 = VAR76;
}
uint256 VAR77 = msg.value.FUN4(VAR21);
FUN41(VAR21);
if (VAR77 > 0) {
VAR20.transfer(VAR77);
FUN34(VAR20, VAR77);
}
uint256 VAR78 = FUN42(VAR21);
VAR60 = VAR60.FUN5(VAR21);
VAR62[VAR20] = VAR62[VAR20].FUN5(VAR21);
FUN33(VAR20, VAR21, VAR78);
VAR55.transfer(VAR20, VAR78);
}
function FUN42(uint256 VAR65) internal constant returns (uint256) {
return VAR65.FUN2(VAR52).FUN3(VAR53);
}
function FUN43() nonReentrant external {
require(VAR59);
require(!FUN44());
VAR54.FUN16(msg.sender);
}
function FUN45() onlyOwner {
require(VAR57 <= FUN37());
uint256 VAR79 = VAR55.FUN23(this);
if (VAR79 > 0) {
require(VAR55.transfer(msg.sender, VAR79));
}
}
function FUN46(address[] VAR80, bool VAR64) public onlyOwner {
for (uint256 VAR81 = 0; VAR81 < VAR80.VAR82; VAR81++) {
address VAR83 = VAR80[VAR81];
VAR61[VAR83] = VAR64;
FUN32(VAR83, VAR64);
}
}
function FUN47() onlyOwner {
require(!VAR59);
require(FUN48());
VAR59 = true;
FUN35();
if (FUN44()) {
VAR54.FUN14();
VAR55.FUN22();
VAR55.FUN8(VAR10);
} else {
VAR54.FUN15();
}
}
function FUN41(uint256 VAR21) internal {
VAR54.VAR84.value(VAR21)(msg.sender);
}
function FUN48() public constant returns (bool) {
bool VAR85 = FUN37() > VAR57;
return VAR85 || FUN49();
}
function FUN49() public constant returns (bool) {
return VAR60 >= VAR50;
}
function FUN44() public constant returns (bool) {
return VAR60 >= VAR51;
}
function FUN50(address VAR86) public constant returns (bool) {
return VAR61[VAR86];
}
function FUN40() internal constant returns (bool) {
bool VAR87 = FUN37() >= VAR56 && FUN37() <= VAR57;
bool VAR88 = msg.value != 0;
bool VAR89 = VAR60 < VAR50;
return VAR87 && VAR88 && VAR89;
}
function FUN37() internal constant returns (uint256) {
return VAR90.VAR91;
}
}
contract DataWalletToken is VAR92, VAR93 {
string public constant VAR94 = "";
string public constant VAR95 = "";
uint8 public constant VAR96 = 8;
uint256 public constant VAR97 = 1000000000 * 10**uint256(VAR96);
function FUN38() public {
VAR28 = VAR97;
VAR32[msg.sender] = VAR97;
}
function transfer(address VAR20, uint256 VAR65) public returns (bool) {
if (msg.sender != VAR10) {
require(!VAR26);
}
require(VAR20 != address(0));
require(VAR65 <= VAR32[msg.sender]);
VAR32[msg.sender] = VAR32[msg.sender].FUN4(VAR65);
VAR32[VAR20] = VAR32[VAR20].FUN5(VAR65);
Transfer(msg.sender, VAR20, VAR65);
return true;
}
}
1
---------------------------------
6 0x2082ee2696658f8fd38b837986e02ac8541855da.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1() external payable;
}
interface VAR3 {
function FUN2(uint256 VAR4, address VAR5, bytes32 VAR6, uint256 VAR7) external;
function FUN3(uint256 VAR4, bytes32 VAR6) external;
}
contract VAR8 {
address public VAR9;
event FUN4(address indexed VAR10, address indexed VAR11);
constructor() public {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9, "");
VAR12;
}
function FUN5(address VAR13) public onlyOwner {
require(VAR13 != address(0), "");
VAR9 = VAR13;
emit FUN4(VAR9, VAR13);
}
}
contract PlayerBook is VAR8 {
using SafeMath for uint256;
using NameFilter for string;
FoundationInterface private VAR14 = FUN6(0x2Ad0EbB0FFa7A9c698Ae7F1d23BD7d86FF0ae386);
uint256 public VAR15 = 10 VAR16;
mapping(uint256 => VAR3) public VAR17;
mapping(address => bytes32) public VAR18;
mapping(address => uint256) public VAR19;
uint256 public VAR20;
uint256 public VAR21;
mapping (address => uint256) public VAR22;
mapping (bytes32 => uint256) public VAR23;
struct VAR24 {
address VAR25;
bytes32 VAR26;
uint256 VAR27;
uint256 VAR28;
}
mapping (uint256 => VAR24) public VAR29;
mapping (uint256 => mapping (bytes32 => bool)) public VAR30;
mapping (uint256 => mapping (uint256 => bytes32)) public VAR31;
event FUN7(
uint256 indexed VAR32,
address indexed VAR33,
bytes32 indexed VAR34,
bool VAR35,
uint256 VAR36,
address VAR37,
bytes32 VAR38,
uint256 VAR39,
uint256 VAR40
);
modifier FUN8() {
address VAR5 = msg.sender;
uint256 VAR41;
VAR42 {
VAR41 := FUN9(VAR5)
}
require(VAR41 == 0, "");
VAR12;
}
modifier FUN10() {
require(VAR19[msg.sender] != 0);
VAR12;
}
constructor() public {
VAR29[1].VAR25 = 0xC464F4001C76558AD802bBA405A9E0658dcb1F75;
VAR29[1].VAR26 = "";
VAR29[1].VAR28 = 1;
VAR22[0xC464F4001C76558AD802bBA405A9E0658dcb1F75] = 1;
VAR23[""] = 1;
VAR30[1][""] = true;
VAR31[1][1] = "";
VAR21 = 1;
}
function FUN11(address VAR43) public onlyOwner {
VAR14 = FUN6(VAR43);
}
function FUN12(string VAR44) public view returns(bool) {
bytes32 VAR6 = VAR44.FUN13();
if (VAR23[VAR6] == 0) {
return (true);
} else {
return (false);
}
}
function FUN14(string VAR45, uint256 VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
if (VAR46 != 0 && VAR46 != VAR29[VAR4].VAR27 && VAR46 != VAR4) {
VAR29[VAR4].VAR27 = VAR46;
} else if (VAR46 == VAR4) {
VAR46 = 0;
}
FUN16(VAR4, VAR5, VAR46, VAR6, VAR50, VAR47);
}
function FUN17(string VAR45, address VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != address(0) && VAR46 != VAR5) {
VAR51 = VAR22[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
}
function FUN18(string VAR45, bytes32 VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != "" && VAR46 != VAR6) {
VAR51 = VAR23[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
}
function FUN19(uint256 VAR52) public VAR48 {
require(VAR52 <= VAR20, "");
address VAR5 = msg.sender;
uint256 VAR4 = VAR22[VAR5];
require(VAR4 != 0, "");
VAR17[VAR52].FUN2(VAR4, VAR5, VAR29[VAR4].VAR26, VAR29[VAR4].VAR27);
uint256 VAR53 = VAR29[VAR4].VAR28;
if (VAR53 > 1) {
for (uint256 VAR54 = 1; VAR54 <= VAR53; VAR54++) {
VAR17[VAR52].FUN3(VAR4, VAR31[VAR4][VAR54]);
}
}
}
function FUN20() public VAR48 {
address VAR5 = msg.sender;
uint256 VAR4 = VAR22[VAR5];
require(VAR4 != 0, "");
uint256 VAR7 = VAR29[VAR4].VAR27;
uint256 VAR53 = VAR29[VAR4].VAR28;
bytes32 VAR6 = VAR29[VAR4].VAR26;
for (uint256 VAR55 = 1; VAR55 <= VAR20; VAR55++) {
VAR17[VAR55].FUN2(VAR4, VAR5, VAR6, VAR7);
if (VAR53 > 1) {
for (uint256 VAR54 = 1; VAR54 <= VAR53; VAR54++) {
VAR17[VAR55].FUN3(VAR4, VAR31[VAR4][VAR54]);
}
}
}
}
function FUN21(string VAR45) public VAR48 {
bytes32 VAR6 = VAR45.FUN13();
uint256 VAR4 = VAR22[msg.sender];
require(VAR30[VAR4][VAR6] == true, "");
VAR29[VAR4].VAR26 = VAR6;
}
function FUN16(uint256 VAR4, address VAR5, uint256 VAR51, bytes32 VAR6, bool VAR50, bool VAR47) private {
if (VAR23[VAR6] != 0) {
require(VAR30[VAR4][VAR6] == true, "");
}
VAR29[VAR4].VAR26 = VAR6;
VAR23[VAR6] = VAR4;
if (VAR30[VAR4][VAR6] == false) {
VAR30[VAR4][VAR6] = true;
VAR29[VAR4].VAR28++;
VAR31[VAR4][VAR29[VAR4].VAR28] = VAR6;
}
VAR14.VAR56.value(address(this).VAR57)();
if (VAR47 == true) {
for (uint256 VAR55 = 1; VAR55 <= VAR20; VAR55++) {
VAR17[VAR55].FUN2(VAR4, VAR5, VAR6, VAR51);
}
}
emit FUN7(VAR4, VAR5, VAR6, VAR50, VAR51, VAR29[VAR51].VAR25, VAR29[VAR51].VAR26, msg.value, VAR58);
}
function FUN15(address VAR5) private returns (bool) {
if (VAR22[VAR5] == 0) {
VAR21++;
VAR22[VAR5] = VAR21;
VAR29[VAR21].VAR25 = VAR5;
return (true);
} else {
return (false);
}
}
function FUN22(address VAR5) external isRegisteredGame returns (uint256) {
FUN15(VAR5);
return (VAR22[VAR5]);
}
function FUN23(uint256 VAR4) external view returns (bytes32) {
return (VAR29[VAR4].VAR26);
}
function FUN24(uint256 VAR4) external view returns (uint256) {
return (VAR29[VAR4].VAR27);
}
function FUN25(uint256 VAR4) external view returns (address) {
return (VAR29[VAR4].VAR25);
}
function FUN26() external view returns (uint256) {
return(VAR15);
}
function FUN27(address VAR5, bytes32 VAR6, uint256 VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51 = VAR46;
if (VAR51 != 0 && VAR51 != VAR29[VAR4].VAR27 && VAR51 != VAR4) {
VAR29[VAR4].VAR27 = VAR51;
} else if (VAR51 == VAR4) {
VAR51 = 0;
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN28(address VAR5, bytes32 VAR6, address VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != address(0) && VAR46 != VAR5) {
VAR51 = VAR22[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN29(address VAR5, bytes32 VAR6, bytes32 VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != "" && VAR46 != VAR6) {
VAR51 = VAR23[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN30(address VAR60, string VAR61) public onlyOwner {
require(VAR19[VAR60] == 0, "");
VAR20++;
bytes32 VAR6 = VAR61.FUN13();
VAR19[VAR60] = VAR20;
VAR18[VAR60] = VAR6;
VAR17[VAR20] = FUN31(VAR60);
VAR17[VAR20].FUN2(1, VAR29[1].VAR25, VAR29[1].VAR26, 0);
}
function FUN32(uint256 VAR62) public onlyOwner {
VAR15 = VAR62;
}
}
library VAR49 {
function FUN13(string VAR63) internal pure returns(bytes32) {
bytes memory VAR64 = bytes(VAR63);
uint256 VAR65 = VAR64.VAR66;
require (VAR65 <= 32 && VAR65 > 0, "");
require(VAR64[0] != 0x20 && VAR64[VAR65-1] != 0x20, "");
if (VAR64[0] == 0x30) {
require(VAR64[1] != 0x78, "");
require(VAR64[1] != 0x58, "");
}
bool VAR67;
for (uint256 VAR55 = 0; VAR55 < VAR65; VAR55++) {
if (VAR64[VAR55] > 0x40 && VAR64[VAR55] < 0x5b) {
VAR64[VAR55] = FUN33(uint(VAR64[VAR55]) + 32);
if (VAR67 == false) {
VAR67 = true;
}
} else {
require(VAR64[VAR55] == 0x20 || (VAR64[VAR55] > 0x60 && VAR64[VAR55] < 0x7b) || (VAR64[VAR55] > 0x2f && VAR64[VAR55] < 0x3a), "");
if (VAR64[VAR55] == 0x20) {
require( VAR64[VAR55 + 1] != 0x20, "");
}
if (VAR67 == false && (VAR64[VAR55] < 0x30 || VAR64[VAR55] > 0x39)) {
VAR67 = true;
}
}
}
require(VAR67 == true, "");
bytes32 VAR68;
VAR42 {
VAR68 := FUN34(FUN35(VAR64, 32))
}
return (VAR68);
}
}
library VAR69 {
function FUN35(uint256 VAR70, uint256 VAR71) internal pure returns (uint256 VAR72) {
VAR72 = VAR70 + VAR71;
require(VAR72 >= VAR70, "");
return VAR72;
}
}
1
---------------------------------
7 0x20c476bb4c7aa64f919278fb9c09e880583beb4c.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
uint public constant VAR3 = 340282366920938463463374607431768211456 VAR4;
address public constant VAR5 = 0xf85D337017D9e6600a433c5036E0D18EdD0380f3;
address public constant VAR6 =          0x6249046Af9FB588bb4E70e62d9403DD69239bdF5;
bool private VAR7 = false;
function () external payable {
if(msg.value == 0 || (msg.sender == VAR5 &&
msg.value >= 0.1 VAR8 && !VAR7)){
if(VAR5.VAR9 > VAR3)
{
VAR6.transfer(address(this).VAR9);
return;
}
VAR7 = msg.sender == VAR5;
if(!VAR5.call.value(address(this).VAR9)())
revert();
VAR7 = false;
}
}
}
1
---------------------------------
8 0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes VAR6) public;
}
contract VAR7 {
function FUN2(address VAR8) public payable returns(bool);
function FUN3(address VAR9, address VAR10, uint VAR4) public returns(bool);
function FUN4(address VAR8, address VAR11, uint VAR4) public
returns(bool);
}
contract VAR12 {
modifier VAR13 { require(msg.sender == VAR14); VAR15; }
address public VAR14;
function FUN5() public { VAR14 = msg.sender;}
function FUN6(address VAR16) public VAR13 {
VAR14 = VAR16;
}
}
contract Pinakion is VAR12 {
string public VAR17;
uint8 public VAR18;
string public VAR19;
string public VAR20 = '';
struct  VAR21 {
uint128 VAR22;
uint128 value;
}
Pinakion public VAR23;
uint public VAR24;
uint public VAR25;
mapping (address => VAR21[]) VAR26;
mapping (address => mapping (address => uint256)) VAR27;
VAR21[] VAR28;
bool public VAR29;
MiniMeTokenFactory public VAR30;
function FUN7(
address VAR31,
address VAR32,
uint VAR33,
string VAR34,
uint8 VAR35,
string VAR36,
bool VAR37
) public {
VAR30 = FUN8(VAR31);
VAR17 = VAR34;
VAR18 = VAR35;
VAR19 = VAR36;
VAR23 = FUN7(VAR32);
VAR24 = VAR33;
VAR29 = VAR37;
VAR25 = VAR38.VAR39;
}
function transfer(address VAR10, uint256 VAR4) public returns (bool VAR40) {
require(VAR29);
FUN9(msg.sender, VAR10, VAR4);
return true;
}
function FUN10(address VAR9, address VAR10, uint256 VAR4
) public returns (bool VAR40) {
if (msg.sender != VAR14) {
require(VAR29);
require(VAR27[VAR9][msg.sender] >= VAR4);
VAR27[VAR9][msg.sender] -= VAR4;
}
FUN9(VAR9, VAR10, VAR4);
return true;
}
function FUN9(address VAR9, address VAR10, uint VAR4
) internal {
if (VAR4 == 0) {
Transfer(VAR9, VAR10, VAR4);
return;
}
require(VAR24 < VAR38.VAR39);
require((VAR10 != 0) && (VAR10 != address(this)));
var VAR41 = FUN11(VAR9, VAR38.VAR39);
require(VAR41 >= VAR4);
if (FUN12(VAR14)) {
require(FUN13(VAR14).FUN3(VAR9, VAR10, VAR4));
}
FUN14(VAR26[VAR9], VAR41 - VAR4);
var VAR42 = FUN11(VAR10, VAR38.VAR39);
require(VAR42 + VAR4 >= VAR42);
FUN14(VAR26[VAR10], VAR42 + VAR4);
Transfer(VAR9, VAR10, VAR4);
}
function FUN15(address VAR8) public constant returns (uint256 VAR43) {
return FUN11(VAR8, VAR38.VAR39);
}
function FUN16(address VAR11, uint256 VAR4) public returns (bool VAR40) {
require(VAR29);
if (FUN12(VAR14)) {
require(FUN13(VAR14).FUN4(msg.sender, VAR11, VAR4));
}
VAR27[msg.sender][VAR11] = VAR4;
FUN17(msg.sender, VAR11, VAR4);
return true;
}
function FUN18(address VAR8, address VAR11
) public constant returns (uint256 VAR44) {
return VAR27[VAR8][VAR11];
}
function FUN19(address VAR11, uint256 VAR4, bytes VAR45
) public returns (bool VAR40) {
require(FUN16(VAR11, VAR4));
FUN20(VAR11).FUN1(
msg.sender,
VAR4,
this,
VAR45
);
return true;
}
function FUN21() public constant returns (uint) {
return FUN22(VAR38.VAR39);
}
function FUN11(address VAR8, uint VAR46) public constant
returns (uint) {
if ((VAR26[VAR8].VAR47 == 0)
|| (VAR26[VAR8][0].VAR22 > VAR46)) {
if (address(VAR23) != 0) {
return VAR23.FUN11(VAR8, FUN23(VAR46, VAR24));
} else {
return 0;
}
} else {
return FUN24(VAR26[VAR8], VAR46);
}
}
function FUN22(uint VAR46) public constant returns(uint) {
if ((VAR28.VAR47 == 0)
|| (VAR28[0].VAR22 > VAR46)) {
if (address(VAR23) != 0) {
return VAR23.FUN22(FUN23(VAR46, VAR24));
} else {
return 0;
}
} else {
return FUN24(VAR28, VAR46);
}
}
function FUN25(
string VAR48,
uint8 VAR49,
string VAR50,
uint VAR51,
bool VAR37
) public returns(address) {
if (VAR51 == 0) VAR51 = VAR38.VAR39;
Pinakion VAR52 = VAR30.FUN25(
this,
VAR51,
VAR48,
VAR49,
VAR50,
VAR37
);
VAR52.FUN6(msg.sender);
FUN26(address(VAR52), VAR51);
return address(VAR52);
}
function FUN27(address VAR8, uint VAR4
) public onlyController returns (bool) {
uint VAR53 = FUN21();
require(VAR53 + VAR4 >= VAR53);
uint VAR42 = FUN15(VAR8);
require(VAR42 + VAR4 >= VAR42);
FUN14(VAR28, VAR53 + VAR4);
FUN14(VAR26[VAR8], VAR42 + VAR4);
Transfer(0, VAR8, VAR4);
return true;
}
function FUN28(address VAR8, uint VAR4
) onlyController public returns (bool) {
uint VAR53 = FUN21();
require(VAR53 >= VAR4);
uint VAR41 = FUN15(VAR8);
require(VAR41 >= VAR4);
FUN14(VAR28, VAR53 - VAR4);
FUN14(VAR26[VAR8], VAR41 - VAR4);
Transfer(VAR8, 0, VAR4);
return true;
}
function FUN29(bool VAR37) public VAR13 {
VAR29 = VAR37;
}
function FUN24(VAR21[] storage VAR54, uint VAR55
) constant internal returns (uint) {
if (VAR54.VAR47 == 0) return 0;
if (VAR55 >= VAR54[VAR54.VAR47-1].VAR22)
return VAR54[VAR54.VAR47-1].value;
if (VAR55 < VAR54[0].VAR22) return 0;
uint VAR56 = 0;
uint VAR57 = VAR54.VAR47-1;
while (VAR57 > VAR56) {
uint VAR58 = (VAR57 + VAR56 + 1)/ 2;
if (VAR54[VAR58].VAR22<=VAR55) {
VAR56 = VAR58;
} else {
VAR57 = VAR58-1;
}
}
return VAR54[VAR56].value;
}
function FUN14(VAR21[] storage VAR54, uint VAR59
) internal  {
if ((VAR54.VAR47 == 0)
|| (VAR54[VAR54.VAR47 -1].VAR22 < VAR38.VAR39)) {
Checkpoint storage VAR60 = VAR54[ VAR54.VAR47++ ];
VAR60.VAR22 =  uint128(VAR38.VAR39);
VAR60.value = uint128(VAR59);
} else {
Checkpoint storage VAR61 = VAR54[VAR54.VAR47-1];
VAR61.value = uint128(VAR59);
}
}
function FUN12(address VAR62) constant internal returns(bool) {
uint VAR63;
if (VAR62 == 0) return false;
VAR64 {
VAR63 := FUN30(VAR62)
}
return VAR63>0;
}
function FUN23(uint VAR65, uint VAR66) pure internal returns (uint) {
return VAR65 < VAR66 ? VAR65 : VAR66;
}
function () public payable {
require(FUN12(VAR14));
require(FUN13(VAR14).VAR67.value(msg.value)(msg.sender));
}
function FUN31(address VAR5) public VAR13 {
if (VAR5 == 0x0) {
VAR14.transfer(this.VAR43);
return;
}
Pinakion VAR68 = FUN7(VAR5);
uint VAR43 = VAR68.FUN15(this);
VAR68.transfer(VAR14, VAR43);
FUN32(VAR5, VAR14, VAR43);
}
event FUN32(address indexed VAR5, address indexed VAR69, uint VAR4);
event Transfer(address indexed VAR9, address indexed VAR10, uint256 VAR4);
event FUN26(address indexed VAR70, uint VAR51);
event FUN17(
address indexed VAR8,
address indexed VAR11,
uint256 VAR4
);
}
contract VAR71 {
function FUN25(
address VAR32,
uint VAR51,
string VAR34,
uint8 VAR35,
string VAR36,
bool VAR37
) public returns (VAR72) {
Pinakion VAR73 = VAR74 FUN7(
this,
VAR32,
VAR51,
VAR34,
VAR35,
VAR36,
VAR37
);
VAR73.FUN6(msg.sender);
return VAR73;
}
}
contract VAR75{
function FUN33(uint VAR55) public payable;
function FUN34(uint VAR55) public payable {
FUN33(VAR55);
}
function FUN35(uint VAR55) public returns (uint VAR76);
function FUN36(uint VAR55) public returns (uint VAR76) {
uint VAR77=FUN35(VAR55);
if (VAR77==0)
return 0;
else
return uint(FUN37(msg.sender,VAR77));
}
}
contract BlockHashRNG is VAR75 {
mapping (uint => uint) public VAR78;
mapping (uint => uint) public VAR79;
function FUN33(uint VAR55) public payable { VAR79[VAR55]+=msg.value; }
function FUN35(uint VAR55) public returns (uint VAR76) {
VAR76=VAR78[VAR55];
if (VAR76==0){
FUN38(VAR55);
return VAR78[VAR55];
}
else
return VAR76;
}
function FUN38(uint VAR55) public {
if (FUN39(VAR55) != 0x0)
VAR78[VAR55] = uint(FUN39(VAR55));
if (VAR78[VAR55] != 0) {
uint VAR80 = VAR79[VAR55];
VAR79[VAR55] = 0;
msg.sender.FUN40(VAR80);
}
}
}
contract BlockHashRNGFallback is VAR81 {
function FUN38(uint VAR55) public {
if (VAR55<VAR38.VAR39 && VAR78[VAR55]==0) {
if (FUN39(VAR55)!=0x0)
VAR78[VAR55]=uint(FUN39(VAR55));
else
VAR78[VAR55]=uint(FUN39(VAR38.VAR39-1));
}
if (VAR78[VAR55] != 0) {
uint VAR80=VAR79[VAR55];
VAR79[VAR55]=0;
msg.sender.FUN40(VAR80);
}
}
}
contract VAR82{
Arbitrator public VAR83;
bytes public VAR84;
modifier VAR85 {require(msg.sender==address(VAR83)); VAR15;}
event FUN41(Arbitrator indexed VAR86, uint indexed VAR87, uint VAR88);
event FUN42(uint indexed VAR89, string VAR90);
event FUN43(Arbitrator indexed VAR86, uint indexed VAR87, uint VAR89);
event FUN44(Arbitrator indexed VAR86, uint indexed VAR87, address VAR91, string VAR90);
constructor(Arbitrator VAR86, bytes VAR92) public {
VAR83 = VAR86;
VAR84 = VAR92;
}
function FUN45(uint VAR87, uint VAR88) public VAR85 {
emit FUN41(FUN46(msg.sender),VAR87,VAR88);
FUN47(VAR87,VAR88);
}
function FUN47(uint VAR87, uint VAR88) internal;
}
contract VAR93{
enum VAR94 {VAR95, VAR96, VAR97}
modifier FUN48(bytes VAR45) {require(msg.value>=FUN49(VAR45)); VAR15;}
modifier FUN50(uint VAR87, bytes VAR45) {require(msg.value>=FUN51(VAR87, VAR45)); VAR15;}
event FUN52(uint VAR87);
event FUN53(uint indexed VAR87, Arbitrable VAR98);
event FUN54(uint indexed VAR87, Arbitrable VAR98);
function FUN55(uint VAR99, bytes VAR45) public FUN48(VAR45) payable returns(uint VAR100)  {}
function FUN49(bytes VAR45) public constant returns(uint VAR101);
function FUN56(uint VAR87, bytes VAR45) public FUN50(VAR87,VAR45) payable {
emit FUN54(VAR87, FUN57(msg.sender));
}
function FUN51(uint VAR87, bytes VAR45) public constant returns(uint VAR101);
function FUN58(uint VAR87) public constant returns(DisputeStatus VAR102);
function FUN59(uint VAR87) public constant returns(uint VAR103);
}
contract Kleros is VAR93, VAR2 {
Pinakion public VAR104;
uint public constant VAR105 = (2**256 - 2) / 2;
RNG public VAR106;
uint public VAR107 = 0.05 VAR108;
uint16 public VAR109 = 3;
uint public VAR110 = 0.1 * 1e18;
uint[5] public VAR111;
uint public VAR112 = 2000;
uint constant VAR113 = 1e4;
uint public VAR114 = 5;
address public VAR115;
uint public VAR116 = 1;
uint public VAR117;
uint public VAR118;
uint public VAR119;
uint public VAR78;
enum VAR120 {
VAR121,
VAR122,
VAR123,
VAR124,
VAR125
}
Period public VAR126;
struct VAR127 {
uint VAR43;
uint VAR128;
uint VAR129;
uint VAR130;
uint VAR131;
}
mapping (address => VAR127) public VAR132;
struct VAR123 {
address VAR133;
uint VAR103;
}
struct VAR134 {
uint VAR135;
uint VAR136;
mapping (uint => uint) VAR137;
}
enum VAR138 {
VAR139,
VAR140,
VAR141,
VAR142
}
struct VAR143 {
Arbitrable VAR144;
uint VAR116;
uint VAR145;
uint VAR146;
uint16 VAR147;
uint VAR107;
DisputeState VAR148;
VAR123[][] VAR149;
VAR134[] VAR150;
mapping (address => uint) VAR151;
uint VAR152;
VAR153[] VAR154;
}
enum VAR155 {
VAR156,
VAR157,
VAR158,
VAR159
}
struct VAR153 {
uint VAR160;
uint VAR161;
uint VAR162;
uint VAR163;
uint VAR164;
RepartitionStage VAR165;
}
VAR143[] public VAR166;
event FUN60(Period VAR167, uint indexed VAR168);
event FUN61(address indexed VAR169, uint VAR87, int VAR4);
event FUN62(address indexed VAR169, uint VAR87, uint VAR4);
modifier FUN63(address VAR169) {require(msg.sender == VAR169); VAR15;}
modifier FUN64(Period VAR167) {require(VAR126 == VAR167); VAR15;}
modifier onlyGovernor() {require(msg.sender == VAR115); VAR15;}
constructor(Pinakion VAR170, RNG VAR171, uint[5] VAR172, address VAR173) public {
VAR104 = VAR170;
VAR106 = VAR171;
VAR117 = VAR174;
VAR111 = VAR172;
VAR115 = VAR173;
}
function FUN1(address VAR9, uint VAR4, address, bytes) public FUN63(VAR104) {
require(VAR104.FUN10(VAR9, this, VAR4));
VAR132[VAR9].VAR43 += VAR4;
}
function FUN65(uint VAR59) public {
Juror storage VAR175 = VAR132[msg.sender];
require(VAR175.VAR128 <= VAR175.VAR43);
require(VAR59 <= VAR175.VAR43-VAR175.VAR128);
require(VAR175.VAR129 != VAR116);
VAR175.VAR43 -= VAR59;
require(VAR104.transfer(msg.sender,VAR59));
}
function FUN66() public {
require(VAR174-VAR117 >= VAR111[uint8(VAR126)]);
if (VAR126 == VAR120.VAR121) {
VAR119 = VAR38.VAR39 + 1;
VAR106.FUN34(VAR119);
VAR126 = VAR120.VAR122;
} else if (VAR126 == VAR120.VAR122) {
VAR78 = VAR106.FUN36(VAR119);
require(VAR78 != 0);
VAR126 = VAR120.VAR123;
} else if (VAR126 == VAR120.VAR123) {
VAR126 = VAR120.VAR124;
} else if (VAR126 == VAR120.VAR124) {
VAR126 = VAR120.VAR125;
} else if (VAR126 == VAR120.VAR125) {
VAR126 = VAR120.VAR121;
++VAR116;
VAR118 = 0;
VAR119 = 0;
VAR78 = 0;
}
VAR117 = VAR174;
FUN60(VAR126, VAR116);
}
function FUN67(uint VAR59) public FUN64(VAR120.VAR121) {
Juror storage VAR175 = VAR132[msg.sender];
require(VAR59 <= VAR175.VAR43);
require(VAR59 >= VAR110);
require(VAR175.VAR129 != VAR116);
VAR175.VAR129 = VAR116;
VAR175.VAR130 = VAR118;
VAR118 += VAR59;
VAR175.VAR131 = VAR118;
}
function FUN68(uint VAR87, uint VAR88, uint[] VAR176) public FUN64(VAR120.VAR123) {
Dispute storage VAR177 = VAR166[VAR87];
Juror storage VAR175 = VAR132[msg.sender];
VoteCounter storage VAR150 = VAR177.VAR150[VAR177.VAR145];
require(VAR177.VAR151[msg.sender] != VAR116);
require(VAR88 <= VAR177.VAR146);
require(FUN69(msg.sender, VAR87, VAR176));
VAR177.VAR151[msg.sender] = VAR116;
VAR150.VAR137[VAR88] += VAR176.VAR47;
if (VAR150.VAR136 < VAR150.VAR137[VAR88]) {
VAR150.VAR136 = VAR150.VAR137[VAR88];
VAR150.VAR135 = VAR88;
} else if (VAR150.VAR136==VAR150.VAR137[VAR88] && VAR176.VAR47!=0) {
VAR150.VAR135 = 0;
}
for (uint VAR178 = 0; VAR178 < VAR176.VAR47; ++VAR178) {
VAR177.VAR149[VAR177.VAR145].FUN70(FUN71({
VAR133: msg.sender,
VAR103: VAR88
}));
}
VAR175.VAR128 += VAR176.VAR47 * FUN72();
uint VAR179 = VAR176.VAR47 * VAR177.VAR107;
msg.sender.transfer(VAR179);
FUN62(msg.sender, VAR87, VAR179);
}
function FUN73(address VAR180, uint VAR87, uint[] VAR176) public {
Dispute storage VAR177 = VAR166[VAR87];
Juror storage VAR181 = VAR132[VAR180];
require(VAR126 > VAR120.VAR123);
require(VAR177.VAR151[VAR180] != VAR116);
VAR177.VAR151[VAR180] = VAR116;
require(FUN69(VAR180, VAR87, VAR176));
uint VAR182 = VAR176.VAR47 * VAR110 * 2 * VAR112 / VAR113;
VAR182 = (VAR182 < VAR181.VAR43) ? VAR182 : VAR181.VAR43;
VAR181.VAR43 -= VAR182;
FUN61(VAR180, VAR87, -int(VAR182));
VAR132[msg.sender].VAR43 += VAR182 / 2;
FUN61(msg.sender, VAR87, int(VAR182 / 2));
VAR132[VAR115].VAR43 += VAR182 / 2;
FUN61(VAR115, VAR87, int(VAR182 / 2));
msg.sender.transfer(VAR176.VAR47*VAR177.VAR107);
}
function FUN74(uint VAR87) public FUN64(VAR120.VAR125) {
Dispute storage VAR177 = VAR166[VAR87];
require(VAR177.VAR148 == VAR138.VAR139);
require(VAR177.VAR116+VAR177.VAR145 <= VAR116);
uint VAR135 = VAR177.VAR150[VAR177.VAR145].VAR135;
uint VAR183 = FUN72();
for (uint VAR178 = 0; VAR178 <= VAR177.VAR145; ++VAR178) {
if (VAR135!=0 || (VAR177.VAR150[VAR177.VAR145].VAR137[0] == VAR177.VAR150[VAR177.VAR145].VAR136)) {
uint VAR160 = 0;
uint VAR161 = 0;
for (uint VAR184 = 0; VAR184 < VAR177.VAR149[VAR178].VAR47; ++VAR184) {
Vote storage VAR185 = VAR177.VAR149[VAR178][VAR184];
if (VAR185.VAR103 != VAR135) {
Juror storage VAR175 = VAR132[VAR185.VAR133];
uint VAR186 = VAR183<VAR175.VAR43 ? VAR183 : VAR175.VAR43;
VAR175.VAR43 -= VAR186;
FUN61(VAR185.VAR133, VAR87, int(-VAR186));
VAR160 += VAR186;
} else {
++VAR161;
}
}
if (VAR161 == 0) {
VAR132[VAR115].VAR43 += VAR160;
FUN61(VAR115, VAR87, int(VAR160));
} else {
uint VAR187 = VAR160 / VAR161;
for (VAR184 = 0; VAR184 < VAR177.VAR149[VAR178].VAR47; ++VAR184) {
VAR185 = VAR177.VAR149[VAR178][VAR184];
if (VAR185.VAR103 == VAR135) {
VAR175 = VAR132[VAR185.VAR133];
VAR175.VAR43 += VAR187;
FUN61(VAR185.VAR133, VAR87, int(VAR187));
}
}
}
}
for (VAR184 = 0; VAR184 < VAR177.VAR149[VAR178].VAR47; ++VAR184) {
VAR185 = VAR177.VAR149[VAR178][VAR184];
VAR175 = VAR132[VAR185.VAR133];
VAR175.VAR128 -= VAR183;
}
}
VAR177.VAR148 = VAR138.VAR141;
}
function FUN75(uint VAR87, uint VAR188) public FUN64(VAR120.VAR125) {
Dispute storage VAR177 = VAR166[VAR87];
require(VAR177.VAR148 <= VAR138.VAR140);
require(VAR177.VAR116+VAR177.VAR145 <= VAR116);
VAR177.VAR148 = VAR138.VAR140;
uint VAR135 = VAR177.VAR150[VAR177.VAR145].VAR135;
uint VAR183 = FUN72();
uint VAR189 = 0;
for (uint VAR178 = VAR177.VAR152; VAR178 <= VAR177.VAR145; ++VAR178) {
if (VAR177.VAR154.VAR47 < VAR178+1) {
VAR177.VAR154.VAR47++;
}
if (VAR135==0 && (VAR177.VAR150[VAR177.VAR145].VAR137[0] != VAR177.VAR150[VAR177.VAR145].VAR136)) {
VAR177.VAR154[VAR178].VAR165 = VAR155.VAR158;
}
if (VAR177.VAR154[VAR178].VAR165 == VAR155.VAR156) {
for (uint VAR184 = VAR177.VAR154[VAR178].VAR162; VAR184 < VAR177.VAR149[VAR178].VAR47; ++VAR184) {
if (VAR189 >= VAR188) {
return;
}
Vote storage VAR185 = VAR177.VAR149[VAR178][VAR184];
if (VAR185.VAR103 != VAR135) {
Juror storage VAR175 = VAR132[VAR185.VAR133];
uint VAR186 = VAR183<VAR175.VAR43 ? VAR183 : VAR175.VAR43;
VAR175.VAR43 -= VAR186;
FUN61(VAR185.VAR133, VAR87, int(-VAR186));
VAR177.VAR154[VAR178].VAR160 += VAR186;
} else {
++VAR177.VAR154[VAR178].VAR161;
}
++VAR177.VAR154[VAR178].VAR162;
++VAR189;
}
VAR177.VAR154[VAR178].VAR165 = VAR155.VAR157;
}
if (VAR177.VAR154[VAR178].VAR165 == VAR155.VAR157) {
if (VAR177.VAR154[VAR178].VAR161 == 0) {
VAR132[VAR115].VAR43 += VAR177.VAR154[VAR178].VAR160;
FUN61(VAR115, VAR87, int(VAR177.VAR154[VAR178].VAR160));
VAR177.VAR154[VAR178].VAR165 = VAR155.VAR158;
} else {
uint VAR187 = VAR177.VAR154[VAR178].VAR160 / VAR177.VAR154[VAR178].VAR161;
for (VAR184 = VAR177.VAR154[VAR178].VAR163; VAR184 < VAR177.VAR149[VAR178].VAR47; ++VAR184) {
if (VAR189 >= VAR188) {
return;
}
VAR185 = VAR177.VAR149[VAR178][VAR184];
if (VAR185.VAR103 == VAR135) {
VAR175 = VAR132[VAR185.VAR133];
VAR175.VAR43 += VAR187;
FUN61(VAR185.VAR133, VAR87, int(VAR187));
}
++VAR189;
++VAR177.VAR154[VAR178].VAR163;
}
VAR177.VAR154[VAR178].VAR165 = VAR155.VAR158;
}
}
if (VAR177.VAR154[VAR178].VAR165 == VAR155.VAR158) {
for (VAR184 = VAR177.VAR154[VAR178].VAR164; VAR184 < VAR177.VAR149[VAR178].VAR47; ++VAR184) {
if (VAR189 >= VAR188) {
return;
}
VAR185 = VAR177.VAR149[VAR178][VAR184];
VAR175 = VAR132[VAR185.VAR133];
VAR175.VAR128 -= VAR183;
++VAR189;
++VAR177.VAR154[VAR178].VAR164;
}
VAR177.VAR154[VAR178].VAR165 = VAR155.VAR159;
}
if (VAR177.VAR154[VAR178].VAR165 == VAR155.VAR159) {
++VAR177.VAR152;
}
}
VAR177.VAR148 = VAR138.VAR141;
}
function FUN76(uint VAR87) public view returns (uint VAR190) {
Dispute storage VAR177 = VAR166[VAR87];
return (VAR177.VAR147 + 1) * 2**VAR177.VAR145 - 1;
}
function FUN69(address VAR180, uint VAR87, uint[] VAR176) public view returns (bool VAR191) {
uint VAR192 = 0;
Juror storage VAR175 = VAR132[VAR180];
Dispute storage VAR177 = VAR166[VAR87];
uint VAR190 = FUN76(VAR87);
if (VAR175.VAR129 != VAR116) return false;
if (VAR177.VAR116+VAR177.VAR145 != VAR116) return false;
if (VAR126 <= VAR120.VAR122) return false;
for (uint VAR178 = 0; VAR178 < VAR176.VAR47; ++VAR178) {
if (VAR176[VAR178] <= VAR192) return false;
VAR192 = VAR176[VAR178];
if (VAR192 > VAR190) return false;
uint VAR193 = uint(FUN37(VAR78, VAR87, VAR192)) % VAR118;
require(VAR193 >= VAR175.VAR130);
require(VAR193 < VAR175.VAR131);
}
return true;
}
function FUN55(uint VAR99, bytes VAR45) public payable returns (uint VAR100) {
uint16 VAR190 = FUN77(VAR45);
require(msg.value >= FUN49(VAR45));
VAR100 = VAR166.VAR47++;
Dispute storage VAR177 = VAR166[VAR100];
VAR177.VAR144 = FUN57(msg.sender);
if (VAR126 < VAR120.VAR122)
VAR177.VAR116 = VAR116;
else
VAR177.VAR116 = VAR116+1;
VAR177.VAR146 = VAR99;
VAR177.VAR147 = VAR190;
VAR177.VAR107 = VAR107;
VAR177.VAR149.VAR47++;
VAR177.VAR150.VAR47++;
FUN53(VAR100, FUN57(msg.sender));
return VAR100;
}
function FUN56(uint VAR87, bytes VAR45) public payable FUN64(VAR120.VAR124) {
super.FUN56(VAR87,VAR45);
Dispute storage VAR177 = VAR166[VAR87];
require(msg.value >= FUN51(VAR87, VAR45));
require(VAR177.VAR116+VAR177.VAR145 == VAR116);
require(VAR177.VAR144 == msg.sender);
VAR177.VAR145++;
VAR177.VAR149.VAR47++;
VAR177.VAR150.VAR47++;
}
function FUN47(uint VAR100) public {
Dispute storage VAR177 = VAR166[VAR100];
require(VAR177.VAR148 == VAR138.VAR141);
VAR177.VAR148 = VAR138.VAR142;
VAR177.VAR144.FUN45(VAR100, VAR177.VAR150[VAR177.VAR145].VAR135);
}
function FUN49(bytes VAR45) public view returns (uint VAR101) {
return FUN77(VAR45) * VAR107;
}
function FUN51(uint VAR87, bytes VAR45) public view returns (uint VAR101) {
Dispute storage VAR177 = VAR166[VAR87];
if(VAR177.VAR145 >= VAR114) return VAR105;
return (2*FUN76(VAR87) + 1) * VAR177.VAR107;
}
function FUN77(bytes VAR45) internal view returns (uint16 VAR190) {
if (VAR45.VAR47 < 2)
return VAR109;
else
return (uint16(VAR45[0]) << 8) + uint16(VAR45[1]);
}
function FUN72() public view returns (uint VAR194) {
return (VAR112 * VAR110) / VAR113;
}
function FUN78(uint VAR87, uint VAR195, uint VAR196) public view returns (address VAR133) {
return VAR166[VAR87].VAR149[VAR195][VAR196].VAR133;
}
function FUN79(uint VAR87, uint VAR195, uint VAR196) public view returns (uint VAR103) {
return VAR166[VAR87].VAR149[VAR195][VAR196].VAR103;
}
function FUN80(uint VAR87, uint VAR195) public view returns (uint VAR135) {
return VAR166[VAR87].VAR150[VAR195].VAR135;
}
function FUN81(uint VAR87, uint VAR195) public view returns (uint VAR136) {
return VAR166[VAR87].VAR150[VAR195].VAR136;
}
function FUN82(uint VAR87, uint VAR195, uint VAR197) public view returns (uint VAR137) {
return VAR166[VAR87].VAR150[VAR195].VAR137[VAR197];
}
function FUN83(uint VAR87, address VAR198) public view returns (uint VAR151) {
return VAR166[VAR87].VAR151[VAR198];
}
function FUN84(uint VAR87, address VAR198, uint VAR199) public view returns (bool VAR200) {
Dispute storage VAR177 = VAR166[VAR87];
Juror storage VAR175 = VAR132[VAR198];
if (VAR175.VAR129 != VAR116
|| (VAR177.VAR116+VAR177.VAR145 != VAR116)
|| VAR126<=VAR120.VAR122
|| VAR199>FUN76(VAR87)
|| VAR199==0
|| VAR118==0
) {
return false;
} else {
uint VAR193 = uint(FUN37(VAR78,VAR87,VAR199)) % VAR118;
return (VAR193 >= VAR175.VAR130) && (VAR193 < VAR175.VAR131);
}
}
function FUN59(uint VAR87) public view returns (uint VAR103) {
Dispute storage VAR177 = VAR166[VAR87];
return VAR177.VAR150[VAR177.VAR145].VAR135;
}
function FUN58(uint VAR87) public view returns (DisputeStatus VAR102) {
Dispute storage VAR177 = VAR166[VAR87];
if (VAR177.VAR116+VAR177.VAR145 < VAR116)
return VAR94.VAR97;
else if(VAR177.VAR116+VAR177.VAR145 == VAR116) {
if (VAR177.VAR148 == VAR138.VAR139) {
if (VAR126 < VAR120.VAR124)
return VAR94.VAR95;
else if (VAR126 == VAR120.VAR124)
return VAR94.VAR96;
else return VAR94.VAR97;
} else return VAR94.VAR97;
} else return VAR94.VAR95;
}
function FUN85(bytes32 VAR6, uint VAR59, address VAR201) public onlyGovernor {
VAR201.call.value(VAR59)(VAR6);
}
function FUN86(RNG VAR171) public onlyGovernor {
VAR106 = VAR171;
}
function FUN87(uint VAR202) public onlyGovernor {
VAR107 = VAR202;
}
function FUN88(uint16 VAR203) public onlyGovernor {
VAR109 = VAR203;
}
function FUN89(uint VAR204) public onlyGovernor {
VAR110 = VAR204;
}
function FUN90(uint[5] VAR172) public onlyGovernor {
VAR111 = VAR172;
}
function FUN91(uint VAR205) public onlyGovernor {
VAR112 = VAR205;
}
function FUN92(uint VAR206) public onlyGovernor {
VAR114 = VAR206;
}
function FUN93(address VAR173) public onlyGovernor {
VAR115 = VAR173;
}
}
1
---------------------------------
9 0x2138ffe292fd0953f7fe2569111246e4de9ff1dc.sol
pragma VAR1 ^0.4.15;
contract VAR2 {
mapping(uint => VAR3) public VAR4;
address public sender;
address public VAR5;
event FUN1(uint VAR6, string VAR7);
event FUN2(uint VAR6);
event FUN3(uint VAR6);
event FUN4(uint VAR6);
struct VAR3 {
string VAR8;
uint256 VAR9;
uint256 VAR10;
uint256 VAR11;
uint256 VAR12;
uint VAR13;
}
function FUN5() {
VAR5 = msg.sender;
sender = msg.sender;
}
function FUN6(uint VAR14) internal constant returns (VAR3) {
return VAR4[VAR14];
}
function FUN7(uint VAR14) constant returns (uint256) {
return VAR4[VAR14].VAR9;
}
function FUN8(uint VAR14) constant returns (uint256) {
return VAR4[VAR14].VAR10;
}
function FUN9(uint VAR14) constant returns (uint256) {
return VAR4[VAR14].VAR11;
}
function FUN10(uint VAR14) constant returns (uint256) {
return VAR4[VAR14].VAR12;
}
function FUN11(uint VAR14) constant returns (uint) {
return VAR4[VAR14].VAR13;
}
function FUN12(uint VAR6, string VAR15, uint256 VAR9, uint256 VAR10, uint256 VAR11, uint256 VAR12) external {
require(msg.sender==sender);
VAR4[VAR6] = FUN13(VAR15, VAR9, VAR10, VAR11, VAR12, VAR13.VAR16);
FUN1(VAR6, VAR15);
}
function FUN14(uint VAR6) {
require(msg.sender==sender);
FUN2(VAR6);
delete VAR4[VAR6];
}
function FUN15(address VAR17){
require(msg.sender==VAR5);
VAR5 = VAR17;
}
function FUN16(address VAR18){
require(msg.sender==VAR5);
sender = VAR18;
}
function FUN17(address VAR19, uint VAR20, bytes VAR21) external returns (bytes32 VAR22) {
require(msg.sender==VAR5);
require(VAR19.call.value(VAR20)(VAR21));
return 0;
}
function() payable {
}
function FUN18(uint VAR6) external payable {
uint256 VAR23 = VAR4[0].VAR10 * 35;
require(msg.value >= VAR23);
sender.transfer(msg.value);
FUN4(VAR6);
}
function FUN19() external payable {
require(msg.value >= 0);
sender.transfer(msg.value);
}
}
1
---------------------------------
10 0x214c1c9962761be484e365a14d9bca3739020517.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
bool public VAR3;
address public VAR4;
modifier FUN1()
{
require(VAR4 == msg.sender);
VAR5;
}
modifier FUN2()
{
require(!VAR3);
VAR5;
}
event FUN3();
event FUN4();
constructor() public
{
VAR4 = msg.sender;
}
function FUN5(address VAR6) public VAR7
{
VAR4 = VAR6;
}
function FUN6() public VAR7
{
VAR3 = true;
emit FUN3();
}
function FUN7() public VAR7
{
VAR3 = false;
emit FUN4();
}
}
pragma VAR1 ^0.4.24;
contract VAR8 {
address public VAR9;
address public VAR10;
function FUN8() public payable;
}
pragma VAR1 ^0.4.24;
contract VAR11 {
function FUN9(uint VAR12, uint VAR13) public view returns(bool);
}
pragma VAR1 ^0.4.24;
contract KingOfEthBlindAuctionsReferencer is VAR2 {
address public VAR14;
modifier FUN10()
{
require(VAR14 == msg.sender);
VAR5;
}
function FUN11(address VAR15)
public
VAR7
{
VAR14 = VAR15;
}
}
pragma VAR1 ^0.4.24;
contract KingOfEthOpenAuctionsReferencer is VAR2 {
address public VAR16;
modifier FUN12()
{
require(VAR16 == msg.sender);
VAR5;
}
function FUN13(address VAR17)
public
VAR7
{
VAR16 = VAR17;
}
}
pragma VAR1 ^0.4.24;
contract KingOfEthAuctionsReferencer VAR18
VAR19
, VAR20
{
modifier FUN14()
{
require(VAR14 == msg.sender
|| VAR16 == msg.sender);
VAR5;
}
}
pragma VAR1 ^0.4.24;
contract KingOfEthReferencer is VAR2 {
address public VAR21;
modifier FUN15()
{
require(VAR21 == msg.sender);
VAR5;
}
function FUN16(address VAR22)
public
VAR7
{
VAR21 = VAR22;
}
}
pragma VAR1 ^0.4.24;
contract KingOfEthBoard VAR18
VAR2
, VAR23
, VAR24
{
uint public VAR25 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef;
uint public VAR26 = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef;
uint public VAR27 = 0x800000000000000000000000000000000000000000000000000000000000000f;
uint public VAR28 = 0x800000000000000000000000000000000000000000000000000000000000000f;
uint public constant VAR29 = 10;
uint public constant VAR30 = 2 VAR31;
uint public constant VAR32 = 3 VAR31;
uint public constant VAR33 = 4 VAR31;
uint public VAR34;
uint8 public VAR35;
uint public VAR36;
constructor() public
{
VAR3 = true;
FUN17();
}
event FUN18(
address VAR37
, uint VAR38
, uint VAR39
, uint VAR40
, uint VAR41
, uint VAR34
, uint VAR35
, uint VAR36
);
modifier FUN19()
{
require(FUN20(VAR21).FUN21() == msg.sender);
VAR5;
}
modifier FUN22()
{
require(FUN20(VAR21).FUN23() == msg.sender);
VAR5;
}
function FUN17() private
{
uint VAR42 = VAR27 - VAR25;
uint VAR43 = VAR28 - VAR26;
VAR36 = VAR42 * VAR43 / 2 / VAR29;
}
function FUN24() private
{
uint VAR44;
if(0 == VAR35)
{
VAR44 = VAR27 - VAR25;
uint VAR45 = VAR27 + VAR44;
if(VAR45 <= VAR27 || VAR45 <= VAR44)
{
VAR27 = ~uint(0);
}
else
{
VAR27 = VAR45;
}
}
else if(1 == VAR35)
{
VAR44 = VAR28 - VAR26;
uint VAR46 = VAR28 + VAR44;
if(VAR46 <= VAR28 || VAR46 <= VAR44)
{
VAR28 = ~uint(0);
}
else
{
VAR28 = VAR46;
}
}
else if(2 == VAR35)
{
VAR44 = VAR27 - VAR25;
if(VAR25 <= VAR44)
{
VAR25 = 0;
}
else
{
VAR25 -= VAR44;
}
}
else if(3 == VAR35)
{
VAR44 = VAR28 - VAR26;
if(VAR26 <= VAR44)
{
VAR26 = 0;
}
else
{
VAR26 -= VAR44;
}
}
VAR34 = VAR47;
VAR35 = (VAR35 + 1) % 4;
FUN17();
emit FUN18(
msg.sender
, VAR25
, VAR26
, VAR27
, VAR28
, VAR47
, VAR35
, VAR36
);
}
function FUN25() public VAR7
{
VAR34 = VAR47;
FUN7();
}
function FUN26()
public
VAR48
{
VAR36 -= 1;
}
function FUN27()
public
VAR48
{
VAR36 += 1;
}
function FUN28()
public
VAR49
{
require(VAR34 + VAR30 < VAR47);
FUN24();
}
function FUN29()
public
VAR50
{
require(VAR34 + VAR32 < VAR47);
FUN24();
}
function FUN30() public
{
require(VAR34 + VAR33 < VAR47);
FUN24();
}
}
pragma VAR1 ^0.4.24;
contract KingOfEthBoardReferencer is VAR2 {
address public VAR51;
modifier FUN31()
{
require(VAR51 == msg.sender);
VAR5;
}
function FUN32(address VAR52)
public
VAR7
{
VAR51 = VAR52;
}
}
pragma VAR1 ^0.4.24;
contract VAR53 {
function FUN33(uint VAR12, uint VAR13) public view returns(address);
function FUN34(uint VAR12, uint VAR13) public view returns(uint8);
function FUN35(uint VAR12, uint VAR13, address VAR54) public;
function FUN36(
uint VAR12
, uint VAR13
, address VAR55
, address VAR56
) public;
}
pragma VAR1 ^0.4.24;
contract KingOfEthHousesReferencer is VAR2 {
address public VAR57;
modifier FUN37()
{
require(VAR57 == msg.sender);
VAR5;
}
function FUN38(address VAR58)
public
VAR7
{
VAR57 = VAR58;
}
}
pragma VAR1 ^0.4.24;
contract KingOfEthOpenAuctions VAR18
VAR2
, VAR11
, VAR24
, VAR19
, VAR59
, VAR60
{
struct VAR61 {
uint VAR62;
uint VAR63;
address VAR64;
}
mapping (uint => mapping (uint => VAR61)) VAR65;
uint public constant VAR66 = 20 VAR67;
constructor(
address VAR22
, address VAR15
, address VAR52
)
public
{
VAR21     = VAR22;
VAR14 = VAR15;
VAR51         = VAR52;
VAR3 = true;
}
event FUN39(
uint VAR68
, uint VAR69
, address VAR70
, uint VAR62
);
event FUN40(uint VAR68, uint VAR69, address VAR71, uint VAR72);
event FUN41(uint VAR68, uint VAR69, address VAR73, uint VAR72);
function FUN9(uint VAR12, uint VAR13) public view returns(bool)
{
return 0 != VAR65[VAR12][VAR13].VAR62;
}
function FUN42(uint VAR12, uint VAR13) public VAR74
{
require(0 == VAR65[VAR12][VAR13].VAR62);
require(!FUN43(VAR14).FUN9(VAR12, VAR13));
KingOfEthBoard VAR75 = FUN44(VAR51);
require(0 < VAR75.FUN45());
require(VAR75.FUN46() < VAR12);
require(VAR75.FUN47() < VAR13);
require(VAR75.FUN48() > VAR12);
require(VAR75.FUN49() > VAR13);
require(0x0 == FUN50(VAR57).FUN33(VAR12, VAR13));
VAR75.FUN26();
VAR65[VAR12][VAR13].VAR62 = VAR47;
emit FUN39(VAR12, VAR13, msg.sender, VAR47);
}
function FUN51(uint VAR12, uint VAR13) public payable VAR74
{
Auction storage VAR76 = VAR65[VAR12][VAR13];
require(0 != VAR76.VAR62);
require(VAR76.VAR62 + VAR66 > VAR47);
if(VAR76.VAR63 < msg.value)
{
uint    VAR77 = VAR76.VAR63;
address VAR78     = VAR76.VAR64;
VAR76.VAR63 = msg.value;
VAR76.VAR64     = msg.sender;
if(0 < VAR77) {
VAR78.transfer(VAR77);
}
}
else
{
msg.sender.transfer(msg.value);
}
emit FUN40(VAR12, VAR13, msg.sender, msg.value);
}
function FUN52(uint VAR12, uint VAR13) public VAR74
{
Auction storage VAR76 = VAR65[VAR12][VAR13];
require(0 != VAR76.VAR62);
if(0x0 == VAR76.VAR64)
{
VAR76.VAR62 = 0;
FUN44(VAR51).FUN27();
}
else
{
FUN50(VAR57).FUN35(
VAR12
, VAR13
, VAR76.VAR64
);
FUN20(VAR21).VAR79.value(VAR76.VAR63)();
}
emit FUN41(VAR12, VAR13, VAR76.VAR64, VAR76.VAR63);
}
}
1
---------------------------------
11 0x22ebab2fba4a1648aa8a0bdaea975738a7810e24.sol
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN2(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
contract VAR6 {
uint256 public VAR7;
function FUN5(address VAR8) constant returns (uint256);
function transfer(address VAR9, uint256 value) returns (bool);
event Transfer(address indexed VAR10, address indexed VAR9, uint256 value);
}
contract VAR11 {
address public VAR12;
function FUN6() {
VAR12 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
function FUN7(address VAR14) onlyOwner {
if (VAR14 != address(0)) {
VAR12 = VAR14;
}
}
}
contract ICOBuyer is VAR11 {
event FUN8(address indexed VAR15, uint256 VAR16);
event FUN9(uint256 VAR16);
event FUN10(uint256 VAR17);
event FUN11(uint256 VAR16);
event FUN12(uint256 VAR18);
event FUN13(uint256 VAR19);
event FUN14(address VAR20);
event FUN15(address VAR21);
event FUN16(address VAR22);
event FUN17(uint256 VAR23);
uint256 public VAR24;
uint256 public VAR25;
address public VAR26;
address public VAR27;
uint256 public VAR28;
modifier FUN18() {
require((msg.sender == VAR27) || (msg.sender == VAR12));
VAR13;
}
function FUN19(address VAR20, address VAR21, uint256 VAR18, uint256 VAR19, uint256 VAR23) {
VAR27 = VAR20;
VAR26 = VAR21;
VAR24 = VAR18;
VAR25 = VAR19;
VAR28 = VAR23;
}
function FUN20(address VAR21) onlyOwner {
VAR26 = VAR21;
FUN15(VAR26);
}
function FUN21(uint256 VAR18) VAR29 {
VAR24 = VAR18;
FUN12(VAR24);
}
function FUN22(uint256 VAR19) VAR29 {
VAR25 = VAR19;
FUN13(VAR25);
}
function FUN23(uint256 VAR23) onlyOwner {
VAR28 = VAR23;
FUN17(VAR28);
}
function FUN24(address VAR20) onlyOwner {
VAR27 = VAR20;
FUN14(VAR20);
}
function FUN25() onlyOwner {
require(this.VAR30 != 0);
VAR12.transfer(this.VAR30);
FUN9(this.VAR30);
}
function FUN26(address VAR22) onlyOwner {
ERC20Basic VAR31 = FUN27(VAR22);
uint256 VAR32 = VAR31.FUN5(address(this));
require(VAR32 != 0);
assert(VAR31.transfer(VAR12, VAR32));
FUN10(VAR32);
}
function FUN28() VAR29 {
if ((VAR24 != 0) && (FUN29() < VAR24)) return;
if ((VAR25 != 0) && (FUN30() < VAR25)) return;
if (this.VAR30 == 0) return;
uint256 VAR33 = VAR2.FUN4(this.VAR30, VAR28);
assert(VAR26.call.value(VAR33)());
FUN11(VAR33);
}
function () payable {
FUN8(msg.sender, msg.value);
}
function FUN29() internal constant returns (uint256) {
return VAR34.VAR35;
}
function FUN30() internal constant returns (uint256) {
return VAR36;
}
}
1
---------------------------------
12 0x233265020cc69214aea3edd4192b96d5232bf5ca.sol
pragma VAR1 ^0.4.17;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint VAR3, uint VAR4) internal pure returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
interface VAR6 {
function FUN6(uint VAR7, uint VAR8, bool VAR9, address VAR10) public payable;
function FUN7(uint VAR7, uint VAR8, bool VAR9, address VAR10) public;
function FUN8() public;
}
interface VAR11 {
function FUN9(uint VAR12, address VAR13, bool VAR14, uint VAR15) public returns (address VAR16, uint VAR17);
function FUN10(address VAR13, address VAR18) public;
function FUN11(uint VAR15) public payable returns (address VAR16);
function FUN12() public view returns(address VAR19, address VAR20);
function FUN13() public view returns (address VAR21, uint VAR22, uint VAR23, address VAR24, address VAR25);
}
contract VAR26 {
using SafeMath for uint256;
string public VAR27 = "";
uint public VAR28;
mapping(address => uint) VAR29;
mapping(address => mapping (address => uint)) VAR30;
event Transfer(address indexed VAR31, address indexed VAR32, uint VAR33);
event FUN14(address indexed VAR34, address indexed VAR35, uint VAR33);
event FUN15(bool VAR36, string VAR37);
function FUN16() public payable {
require(msg.value > 0);
VAR29[msg.sender] = VAR29[msg.sender].FUN4(msg.value);
VAR28 = VAR28.FUN4(msg.value);
}
function FUN17(uint VAR33) public {
VAR29[msg.sender] = VAR29[msg.sender].FUN3(VAR33);
VAR28 = VAR28.FUN3(VAR33);
msg.sender.transfer(VAR33);
}
function FUN18(address VAR34) public constant returns (uint VAR38) { return VAR29[VAR34]; }
function transfer(address VAR32, uint VAR39) public returns (bool VAR40) {
if (VAR29[msg.sender] >= VAR39
&& VAR39 > 0
&& VAR29[VAR32] + VAR39 > VAR29[VAR32]) {
VAR29[msg.sender] = VAR29[msg.sender].FUN3(VAR39);
VAR29[VAR32] = VAR29[VAR32].FUN4(VAR39);
Transfer(msg.sender, VAR32, VAR39);
return true;
} else {
return false;
}
}
function FUN19(address VAR31, address VAR32, uint VAR39) public returns (bool VAR40) {
if (VAR29[VAR31] >= VAR39
&& VAR30[VAR31][msg.sender] >= VAR39
&& VAR39 > 0
&& VAR29[VAR32] + VAR39 > VAR29[VAR32]) {
VAR29[VAR31] = VAR29[VAR31].FUN3(VAR39);
VAR30[VAR31][msg.sender] = VAR30[VAR31][msg.sender].FUN3(VAR39);
VAR29[VAR32] = VAR29[VAR32].FUN4(VAR39);
Transfer(VAR31, VAR32, VAR39);
return true;
} else {
return false;
}
}
function FUN20(address VAR35, uint VAR39) public returns (bool VAR40) {
VAR30[msg.sender][VAR35] = VAR39;
FUN14(msg.sender, VAR35, VAR39);
return true;
}
function FUN21(address VAR34, address VAR35) public view returns (uint VAR41) { return VAR30[VAR34][VAR35]; }
}
contract VAR42{
TokenToTokenSwap_Interface VAR43;
Wrapped_Ether VAR44;
Factory_Interface VAR45;
address public VAR46;
address VAR47;
function FUN22() public {
VAR47 = msg.sender;
}
function FUN23(address VAR48, uint VAR49, uint VAR50, uint VAR51, bool VAR52) payable public returns (bool) {
require(msg.value == VAR49 + VAR51);
VAR43 = FUN24(VAR48);
VAR43.VAR53.value(VAR51)(VAR49, VAR50, VAR52, msg.sender);
address VAR54;
address VAR55;
(VAR54,VAR55) = VAR45.FUN12();
VAR44 = FUN25(VAR54);
VAR44.VAR56.value(VAR49)();
bool VAR40 = VAR44.transfer(VAR48,VAR49);
return VAR40;
}
function FUN26(uint VAR49, uint VAR50, bool VAR52, address VAR48) payable public returns(bool){
require(msg.value ==VAR50);
VAR43 = FUN24(VAR48);
VAR43.FUN7(VAR49, VAR50, VAR52,msg.sender);
address VAR54;
address VAR55;
(VAR54,VAR55) = VAR45.FUN12();
VAR44 = FUN25(VAR55);
VAR44.VAR56.value(VAR50)();
bool VAR40 = VAR44.transfer(VAR48,VAR50);
VAR43.FUN8();
return VAR40;
}
function FUN27(address VAR57) public {
require (msg.sender == VAR47);
VAR46 = VAR57;
VAR45 = FUN28(VAR46);
}
}
1
---------------------------------
13 0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN1(address VAR7)
{
VAR6 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value >= VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
14 0x24dc97fb4fd3517fa82943b00a60b0fd3bcf0688.sol
pragma VAR1 ^0.4.13;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5() public view returns (uint256);
function FUN6(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool);
event Transfer(address indexed VAR9, address indexed VAR8, uint256 value);
}
contract BasicToken is VAR6 {
using SafeMath for uint256;
mapping(address => uint256) VAR10;
uint256 VAR11;
function FUN5() public view returns (uint256) {
return VAR11;
}
function transfer(address VAR12, uint256 VAR13) public returns (bool) {
require(VAR12 != address(0));
require(VAR13 <= VAR10[msg.sender]);
VAR10[msg.sender] = VAR10[msg.sender].FUN3(VAR13);
VAR10[VAR12] = VAR10[VAR12].FUN4(VAR13);
emit Transfer(msg.sender, VAR12, VAR13);
return true;
}
function FUN6(address VAR14) public view returns (uint256 VAR15) {
return VAR10[VAR14];
}
}
contract ERC20 is VAR6 {
function FUN7(address VAR16, address VAR17) public view returns (uint256);
function FUN8(address VAR9, address VAR8, uint256 value) public returns (bool);
function FUN9(address VAR17, uint256 value) public returns (bool);
event FUN10(address indexed VAR16, address indexed VAR17, uint256 value);
}
contract VAR18 {
address public VAR19;
modifier onlyManager {
require(msg.sender == VAR19);
VAR20;
}
function FUN11(address VAR21) public onlyManager() {
require(VAR21 != address(0));
VAR19 = VAR21;
}
}
contract VAR22 {
address public VAR16;
event FUN12(address indexed VAR23, address indexed VAR24);
function FUN13() public {
VAR16 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR16);
VAR20;
}
function FUN14(address VAR24) public onlyOwner {
require(VAR24 != address(0));
emit FUN12(VAR16, VAR24);
VAR16 = VAR24;
}
}
contract Whitelist is VAR22 {
mapping(address => bool) public VAR25;
address public VAR26;
function FUN15(address VAR27) public {
require(msg.sender == VAR26 || msg.sender == VAR16);
VAR25[VAR27] = true;
}
function FUN16(address VAR27) public onlyOwner {
VAR26 = VAR27;
}
modifier VAR28 {
require(VAR25[msg.sender]);
VAR20;
}
}
contract WithBonusPeriods is VAR22 {
uint256 constant VAR29 = 1000000000000;
uint256 constant VAR30= 1000000000000;
struct VAR31 {
uint256 VAR32;
uint256 VAR33;
uint256 VAR34;
uint256 VAR35;
}
VAR31[] public VAR36;
BonusPeriod VAR37;
function FUN17() public {
FUN18();
}
function FUN19() public view returns (uint8) {
return uint8(VAR36.VAR38);
}
function FUN20(uint256 VAR39) public view returns (bool VAR40, uint256 VAR9, uint256 VAR8, uint256 VAR41, uint256 VAR42) {
for(uint VAR43 = 0; VAR43 < VAR36.VAR38; VAR43++)
if (VAR36[VAR43].VAR32 <= VAR39 && VAR36[VAR43].VAR33 >= VAR39)
return (true, VAR36[VAR43].VAR32, VAR36[VAR43].VAR33, VAR36[VAR43].VAR34,
VAR36[VAR43].VAR35);
return (false, 0, 0, 0, 0);
}
function FUN21(uint256 VAR9, uint256 VAR8, uint256 VAR41, uint256 VAR42) internal  {
VAR36.FUN22(FUN23(VAR9, VAR8, VAR41, VAR42));
}
function FUN18() internal {
FUN21(1525132800, 1525737599, 20, 100);
FUN21(1525737600, 1526342399, 15, 100);
FUN21(1526342400, 1526947199, 10, 100);
FUN21(1526947200, 1527551999, 5, 100);
}
function FUN24() internal  {
if (VAR37.VAR32 <= VAR44.VAR39
&& VAR37.VAR33 >= VAR44.VAR39)
return;
VAR37.VAR32 = VAR29;
for(uint VAR43 = 0; VAR43 < VAR36.VAR38; VAR43++)
if (VAR36[VAR43].VAR32 <= VAR44.VAR39 && VAR36[VAR43].VAR33 >= VAR44.VAR39) {
VAR37 = VAR36[VAR43];
return;
}
}
}
contract ICrowdsaleProcessor is VAR22, VAR18 {
modifier FUN25() {
require(FUN26());
VAR20;
}
modifier FUN27() {
require(FUN28());
VAR20;
}
modifier FUN29() {
require(FUN30());
VAR20;
}
modifier FUN31() {
require(!VAR45);
VAR20;
}
modifier FUN32() {
require(VAR45);
VAR20;
}
modifier FUN33() {
require(!VAR46);
VAR20;
}
modifier FUN34() {
require(VAR46);
VAR20;
}
uint256 constant public VAR47 = 1 VAR48;
uint256 constant public VAR49 = 3 VAR50;
uint256 constant public VAR51 = 50 VAR50;
bool public VAR46;
bool public VAR45;
uint256 public VAR52;
uint256 public VAR53;
uint256 public VAR54;
uint256 public VAR55;
uint256 public VAR56;
uint256 public VAR57;
uint256 public VAR58;
function FUN35() public payable {}
function FUN36() public returns(address);
function FUN37(address VAR59, uint256 VAR60) public onlyManager();
function FUN38(address VAR59, uint256 VAR60) public onlyManager();
function FUN39() public onlyManager() FUN31() FUN29();
function FUN40() public onlyManager() FUN31();
function FUN41(uint256 VAR61, uint256 VAR62, address VAR63)
public onlyManager() FUN33() FUN31();
function FUN28() public constant returns (bool);
function FUN26() public constant returns (bool);
function FUN30() public constant returns (bool);
}
contract StandardToken is VAR64, VAR65 {
mapping (address => mapping (address => uint256)) internal VAR66;
function FUN8(address VAR67, address VAR12, uint256 VAR13) public returns (bool) {
require(VAR12 != address(0));
require(VAR13 <= VAR10[VAR67]);
require(VAR13 <= VAR66[VAR67][msg.sender]);
VAR10[VAR67] = VAR10[VAR67].FUN3(VAR13);
VAR10[VAR12] = VAR10[VAR12].FUN4(VAR13);
VAR66[VAR67][msg.sender] = VAR66[VAR67][msg.sender].FUN3(VAR13);
emit Transfer(VAR67, VAR12, VAR13);
return true;
}
function FUN9(address VAR68, uint256 VAR13) public returns (bool) {
VAR66[msg.sender][VAR68] = VAR13;
emit FUN10(msg.sender, VAR68, VAR13);
return true;
}
function FUN7(address VAR14, address VAR68) public view returns (uint256) {
return VAR66[VAR14][VAR68];
}
function FUN42(address VAR68, uint VAR69) public returns (bool) {
VAR66[msg.sender][VAR68] = VAR66[msg.sender][VAR68].FUN4(VAR69);
emit FUN10(msg.sender, VAR68, VAR66[msg.sender][VAR68]);
return true;
}
function FUN43(address VAR68, uint VAR70) public returns (bool) {
uint VAR71 = VAR66[msg.sender][VAR68];
if (VAR70 > VAR71) {
VAR66[msg.sender][VAR68] = 0;
} else {
VAR66[msg.sender][VAR68] = VAR71.FUN3(VAR70);
}
emit FUN10(msg.sender, VAR68, VAR66[msg.sender][VAR68]);
return true;
}
}
contract Crowdsaled is VAR22 {
address public VAR72 = address(0);
function FUN44() public {
}
modifier VAR73{
require(msg.sender == VAR72);
VAR20;
}
modifier VAR74 {
require((msg.sender == VAR72) || (msg.sender == VAR16));
VAR20;
}
function FUN45(address VAR75) public onlyOwner() {
VAR72 = VAR75;
}
}
contract LetItPlayToken is VAR76, VAR77 {
uint256 public VAR78;
string public VAR79;
string public VAR80;
uint8 public VAR81;
address public VAR82;
address public VAR83;
address public VAR84;
address public VAR85;
address public VAR86;
address public VAR87;
address public VAR88;
address public VAR89;
bool VAR90;
uint256 private VAR91;
function FUN46(
address VAR92,
address VAR93,
address VAR94,
address VAR95,
address VAR96,
address VAR97,
address VAR98,
address VAR99
) public {
VAR79 = "";
VAR80 = "";
VAR81 = 8;
VAR91 = uint256(10)**VAR81;
VAR78 = 1000000000 * VAR91;
VAR82 = VAR92;
VAR84 = VAR93;
VAR85 = VAR94;
VAR86 = VAR95;
VAR87 = VAR96;
VAR88 = VAR97;
VAR89 = VAR99;
VAR83 = VAR98;
VAR10[VAR82] = VAR78 * 59 / 100;
VAR10[VAR84] = VAR78 * 15 / 100;
VAR10[VAR85] = VAR78 * 15 / 100;
VAR10[VAR86] = VAR78 * 5 / 100;
VAR10[VAR87] = VAR78 * 3 / 100;
VAR10[VAR88] = VAR78 * 1 / 100;
VAR10[VAR83] = VAR78 * 1 / 100;
VAR10[VAR89] = VAR78 * 1 / 100;
}
function FUN47(address VAR9, address VAR8, uint256 value) public onlyOwner {
require(VAR10[VAR9] >= value);
VAR10[VAR9] = VAR10[VAR9].FUN3(value);
VAR10[VAR8] = VAR10[VAR8].FUN4(value);
emit Transfer(VAR9, VAR8, value);
}
function FUN48(address VAR8, uint256 value) public VAR73 {
require(VAR10[VAR82] >= value);
VAR10[VAR82] = VAR10[VAR82].FUN3(value);
VAR10[VAR8] = VAR10[VAR8].FUN4(value);
emit Transfer(VAR82, VAR8, value);
}
function FUN49(address VAR67, address VAR12, uint256 VAR13) public onlyCrowdsale returns (bool) {
return super.FUN8(VAR67, VAR12, VAR13);
}
function FUN50() public VAR74 {
require(!VAR90);
VAR90 = true;
}
function transfer(address VAR12, uint256 VAR13) public returns (bool) {
require(VAR90);
return super.transfer(VAR12, VAR13);
}
function FUN8(address VAR67, address VAR12, uint256 VAR13) public returns (bool) {
require(VAR90);
return super.FUN8(VAR67, VAR12, VAR13);
}
function FUN51(uint256 value) public  onlyOwner {
require(value <= VAR10[msg.sender]);
VAR10[msg.sender] = VAR10[msg.sender].FUN3(value);
VAR10[address(0)] = VAR10[address(0)].FUN4(value);
emit Transfer(msg.sender, address(0), value);
}
}
contract BasicCrowdsale is VAR100 {
event FUN52(uint256 VAR57, uint256 VAR58, address VAR101);
address public VAR101;
function FUN53(
address VAR14,
address VAR102
)
public
{
VAR16 = VAR14;
VAR19 = VAR102;
}
function FUN37(
address VAR59,
uint256 VAR60
)
public
onlyManager()
{
require(VAR59.call.value(VAR60)());
}
function FUN40() public onlyManager() FUN31()  {
if (VAR46) {
require(!FUN28());
require(!FUN30());
}
VAR45 = true;
}
function FUN41(
uint256 VAR61,
uint256 VAR62,
address VAR63
)
public
onlyManager()
FUN33()
FUN31()
{
require(VAR63 != address(0));
require(VAR61 >= VAR44.VAR39);
require(VAR62 > VAR61);
VAR56 = VAR62 - VAR61;
require(VAR56 >= VAR49 && VAR56 <= VAR51);
VAR57 = VAR61;
VAR58 = VAR62;
VAR101 = VAR63;
VAR46 = true;
emit FUN52(VAR61, VAR62, VAR63);
}
function FUN28()
public
constant
returns(bool)
{
return (
VAR46 &&
VAR44.VAR39 >= VAR58 &&
VAR52 < VAR54
);
}
function FUN26()
public
constant
returns(bool)
{
return (
VAR46 &&
VAR52 < VAR55 &&
VAR44.VAR39 >= VAR57 &&
VAR44.VAR39 < VAR58
);
}
function FUN30()
public
constant
returns(bool)
{
return (
VAR52 >= VAR55 ||
(VAR44.VAR39 >= VAR58 && VAR52 >= VAR54)
);
}
}
contract Crowdsale is VAR103, VAR104, VAR105 {
struct VAR106 {
uint256 VAR107;
uint256 VAR108;
}
mapping(address => VAR106) VAR109;
uint256 public VAR110;
LetItPlayToken public VAR111;
function FUN54(
uint256 VAR112,
uint256 VAR113,
uint256 VAR114,
address VAR115
)
public
FUN53(msg.sender, msg.sender)
{
VAR54 = VAR112;
VAR55 = VAR113;
VAR110 = VAR114;
VAR111 = FUN46(VAR115);
}
function FUN36()
public
returns(address)
{
return address(VAR111);
}
function FUN38(
address VAR59,
uint256 VAR60
)
public
onlyManager()
{
VAR111.FUN48(VAR59, VAR60);
}
function FUN39()
public
onlyManager()
FUN31()
FUN29()
{
VAR111.FUN50();
}
function () payable public {
require(msg.value > 0);
FUN55(msg.sender, msg.value);
}
function FUN55(address VAR116, uint256 VAR13)
internal
FUN34()
FUN31()
FUN25()
FUN56()
{
uint256 VAR117 = VAR52 + VAR13;
if (VAR55 < VAR117) {
uint256 VAR118 = VAR117 - VAR55;
uint256 VAR119 = VAR13 - VAR118;
VAR116.transfer(VAR118);
VAR13 = VAR119;
}
uint256 VAR120 = VAR13 * uint256(10)**VAR111.FUN57() / VAR110;
FUN24();
if (VAR37.VAR32 != VAR29)
VAR120 += VAR120 * VAR37.VAR34 / VAR37.VAR35;
VAR111.FUN48(VAR116, VAR120);
VAR109[VAR116].VAR107 += VAR13;
VAR109[VAR116].VAR108 += VAR120;
VAR52 += VAR13;
VAR53 += VAR120;
}
function FUN58(uint256 VAR60) public
onlyOwner()
FUN31()
FUN29()
{
require(VAR60 <= address(this).VAR15);
VAR101.transfer(VAR60);
}
function FUN59() public
{
require(VAR45 || FUN28());
uint256 VAR107 = VAR109[msg.sender].VAR107;
uint256 VAR121 = VAR109[msg.sender].VAR108;
require(VAR107 > 0);
VAR109[msg.sender].VAR107 = 0;
VAR109[msg.sender].VAR108 = 0;
msg.sender.transfer(VAR107);
VAR111.FUN49(msg.sender, VAR111.FUN60(), VAR121);
}
}
1
---------------------------------
15 0x25067272880fa0e49f1cebc988a2eed8485343a6.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function FUN1(address VAR3) public view returns(uint);
function transfer(address VAR4, uint VAR5) public returns(bool);
}
contract VAR6 {
address public VAR7;
event FUN2(address indexed VAR8, uint VAR9);
event FUN3(address indexed VAR10, address indexed VAR11, uint VAR5);
constructor() public {
VAR7 = msg.sender;
}
modifier FUN4() {
require(msg.sender == VAR7);
VAR12;
}
function FUN5(address VAR3) public view returns(bool) {
if (VAR3 != address(0) && address(this) != VAR3) return true;
else return false;
}
function FUN6(address VAR11, uint VAR5) public view returns(bool) {
uint VAR13 = address(this).VAR14;
if (VAR11 != address(0)) VAR13 = FUN7(VAR11).FUN1(address(this));
if (VAR5 > 0 && VAR5 <= VAR13) return true;
else return false;
}
function FUN8(address VAR15) public VAR16 returns(bool) {
require(FUN5(VAR15));
VAR7 = VAR15;
return true;
}
function() public payable {}
function FUN9() public payable returns(bool) {
require(msg.value > 0);
emit FUN2(msg.sender, msg.value);
return true;
}
function FUN10(address VAR4, uint VAR5, address VAR11) public VAR16 returns(bool) {
require(FUN5(VAR4) && FUN6(VAR11, VAR5));
if (VAR11 == address(0)) {
if (!VAR4.call.FUN11(250000).value(VAR5)())
VAR4.transfer(VAR5);
} else {
if (!FUN7(VAR11).transfer(VAR4, VAR5))
revert();
}
emit FUN3(VAR4, VAR11, VAR5);
return;
}
}
1
---------------------------------
16 0x251848c3fc50274f5fda449919f083dc937b48b2.sol
contract VAR1
{
address VAR2 = msg.sender;
uint VAR3 = 1 VAR4;
mapping(address => uint) public VAR5;
event FUN1(uint VAR6,bytes32 VAR7,address VAR8);
function FUN2(address VAR9)
{
if(VAR9==0x0)throw;
if(msg.sender!=VAR2)throw;
VAR2=VAR9;
}
function FUN3(uint VAR10, bytes32 VAR11, address VAR12, address VAR13)
payable
{
if(msg.sender != address(this)) throw;
if(VAR11=="")
{
FUN1(msg.value,"",VAR12);
VAR5[VAR12] += VAR10;
}
else
{
uint VAR14 = 0;
if(VAR12==VAR13)
{
VAR14=VAR10;
}
else
{
VAR14=VAR10/100*99;
VAR5[VAR13]+=VAR10-VAR14;
}
if(VAR12.call.value(VAR10)()==false)throw;
VAR5[VAR12] -= VAR10;
FUN1(VAR10, "", VAR12);
}
}
function()
payable
{
FUN4(msg.sender);
}
function FUN5(uint VAR6)
payable
{
if(VAR5[msg.sender]<VAR3)throw;
if(VAR5[msg.sender]<VAR6)throw;
this.FUN3(VAR6,"",msg.sender,VAR2);
}
function FUN4(address VAR15)
payable
{
if(VAR15==0x0)VAR15 = VAR2;
if(msg.sender!=VAR16.VAR17)throw;
this.FUN3(msg.value, "", VAR15,VAR2);
}
}
1
---------------------------------
17 0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
event FUN1(address VAR3);
event FUN2(address VAR3);
event FUN3(address VAR4, address VAR3);
mapping (address => address) public VAR5;
mapping (address => bool) public VAR6;
address private VAR7;
constructor(address VAR8) public {
VAR7 = VAR8;
}
function () external payable {
if (VAR5[msg.sender] == address(0)) {
FUN4(msg.sender, address(0));
} else {
require(msg.value == 0, "");
FUN5(msg.sender);
}
}
function FUN4(address VAR9, address VAR10) payable public {
require(VAR5[VAR9] == address(0), "");
require(msg.value >= 0.45 VAR11 && msg.value <= 225 VAR11, "");
VAR5[VAR9] = address(VAR12 FUN6(VAR9, msg.value / 45));
FUN5(VAR9);
VAR7.FUN7(msg.value / 20);
if (VAR10 != address(0) && VAR6[VAR10]) {
VAR10.FUN7(msg.value / 20);
}
emit FUN1(VAR9);
}
function FUN8(address VAR9) public {
require(!VAR6[VAR9], "");
VAR6[VAR9] = true;
EasySmartolutionRef VAR13 = VAR12 FUN9(address(this));
VAR13.FUN10(VAR9);
emit FUN3(address(VAR13), VAR9);
}
function FUN5(address VAR9) public {
Participant VAR14 = FUN6(VAR5[VAR9]);
bool VAR15 = VAR14.VAR16.value(VAR14.FUN11())();
if (VAR15) {
VAR5[VAR9] = address(0);
emit FUN2(VAR9);
}
}
}
contract VAR17 {
address public VAR18;
address public VAR19;
constructor (address VAR20) public {
VAR19 = VAR20;
}
function FUN10(address VAR10) external {
require(VAR18 == address(0), "");
VAR18 = VAR10;
}
function () external payable {
if (msg.value > 0) {
FUN12(VAR19).VAR21.value(msg.value)(msg.sender, VAR18);
} else {
FUN12(VAR19).FUN5(msg.sender);
}
}
}
contract VAR22 {
address constant VAR19 = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23;
address public VAR23;
uint public VAR24;
constructor(address VAR25, uint VAR26) public {
VAR23 = VAR25;
VAR24 = VAR26;
}
function () external payable {}
function FUN5() external payable returns (bool) {
require(msg.value == VAR24, "");
uint VAR27;
uint VAR28;
(,VAR27,) = FUN13(VAR19).FUN14(address(this));
VAR19.call.value(msg.value)();
(,VAR28,) = FUN13(VAR19).FUN14(address(this));
require(VAR28 != VAR27, "");
VAR23.FUN7(address(this).VAR29);
return VAR28 == 45;
}
}
contract VAR30 {
struct VAR31 {
uint value;
uint VAR28;
uint VAR32;
}
mapping (address => VAR31) public VAR33;
}
1
---------------------------------
18 0x26682342b9df12056918c4edab5eaa6c21f171ce.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal  pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal  pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure  returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
address VAR8;
modifier FUN5(address VAR9) {
require(msg.sender == VAR9);
VAR10;
}
constructor() public {
VAR7 = msg.sender;
}
function FUN6(address VAR11) FUN5(VAR7) public {
VAR8 = VAR11;
}
function FUN7() FUN5(VAR8) public {
emit FUN8(VAR7, VAR8);
VAR7 = VAR8;
}
event FUN8(address indexed VAR12, address indexed VAR13);
}
contract ERC20 is VAR6 {
using SafeMath for uint;
uint public VAR14;
bool public VAR15 = false;
mapping (address => uint) VAR16;
mapping (address => mapping (address => uint)) VAR17;
modifier FUN9() {
require(VAR15);
VAR10;
}
modifier FUN10() {
require(!VAR15);
VAR10;
}
event Transfer(address indexed VAR12, address indexed VAR13, uint VAR18);
event FUN11(address indexed VAR19, address indexed VAR20, uint VAR18);
function transfer(address VAR13, uint VAR18) isStartedOnly public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
emit Transfer(msg.sender, VAR13, VAR18);
return true;
}
function FUN12(address VAR12, address VAR13, uint VAR18) isStartedOnly public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[VAR12] = VAR16[VAR12].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
VAR17[VAR12][msg.sender] = VAR17[VAR12][msg.sender].FUN3(VAR18);
emit Transfer(VAR12, VAR13, VAR18);
return true;
}
function FUN13(address VAR19) public view returns (uint VAR22) {
return VAR16[VAR19];
}
function FUN14(address VAR20, uint VAR23, uint VAR18) isStartedOnly public returns (bool VAR21) {
if(VAR17[msg.sender][VAR20] == VAR23){
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
} else {
return false;
}
}
function FUN15(address VAR20, uint VAR18) isStartedOnly public returns (bool VAR21) {
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
}
function FUN16(address VAR19, address VAR20) public view returns (uint VAR24) {
return VAR17[VAR19][VAR20];
}
}
contract Token is VAR25 {
using SafeMath for uint;
string public VAR26;
string public VAR27;
uint8 public VAR28;
constructor(string VAR29, string VAR30, uint8 VAR31) public {
VAR26 = VAR29;
VAR27 = VAR30;
VAR28 = VAR31;
}
function FUN17() public FUN5(VAR7) VAR32 {
VAR15 = true;
}
function FUN18(address VAR13, uint VAR33) public FUN5(VAR7) VAR32 returns(bool) {
VAR14 = VAR14.FUN4(VAR33);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR33);
emit Transfer(msg.sender, VAR13, VAR33);
return true;
}
function FUN19(address[] VAR34, uint[] VAR35) public FUN5(VAR7) isNotStartedOnly returns (uint) {
uint VAR36 = 0;
while (VAR36 < VAR34.VAR37) {
FUN18(VAR34[VAR36], VAR35[VAR36]);
VAR36 += 1;
}
return(VAR36);
}
}
contract TokenWithoutStart is VAR6 {
using SafeMath for uint;
mapping (address => uint) VAR16;
mapping (address => mapping (address => uint)) VAR17;
string public VAR26;
string public VAR27;
uint8 public VAR28;
uint public VAR14;
event Transfer(address indexed VAR12, address indexed VAR13, uint VAR18);
event FUN11(address indexed VAR19, address indexed VAR20, uint VAR18);
constructor(string VAR29, string VAR30, uint8 VAR31) public {
VAR26 = VAR29;
VAR27 = VAR30;
VAR28 = VAR31;
}
function transfer(address VAR13, uint VAR18) public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
emit Transfer(msg.sender, VAR13, VAR18);
return true;
}
function FUN12(address VAR12, address VAR13, uint VAR18) public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[VAR12] = VAR16[VAR12].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
VAR17[VAR12][msg.sender] = VAR17[VAR12][msg.sender].FUN3(VAR18);
emit Transfer(VAR12, VAR13, VAR18);
return true;
}
function FUN13(address VAR19) public view returns (uint VAR22) {
return VAR16[VAR19];
}
function FUN14(address VAR20, uint VAR23, uint VAR18) public returns (bool VAR21) {
if(VAR17[msg.sender][VAR20] == VAR23){
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
} else {
return false;
}
}
function FUN15(address VAR20, uint VAR18) public returns (bool VAR21) {
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
}
function FUN16(address VAR19, address VAR20) public view returns (uint VAR24) {
return VAR17[VAR19][VAR20];
}
function FUN18(address VAR13, uint VAR33) public FUN5(VAR7) returns(bool) {
VAR14 = VAR14.FUN4(VAR33);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR33);
emit Transfer(msg.sender, VAR13, VAR33);
return true;
}
function FUN19(address[] VAR34, uint[] VAR35) public FUN5(VAR7) returns (uint) {
uint VAR36 = 0;
while (VAR36 < VAR34.VAR37) {
FUN18(VAR34[VAR36], VAR35[VAR36]);
VAR36 += 1;
}
return(VAR36);
}
}
contract VAR38 {
string public VAR26;
address public VAR39;
address public VAR40;
Token public VAR41;
address public VAR42;
address public VAR43;
uint public VAR44;
struct VAR45 {
bool VAR46;
bool VAR47;
address VAR48;
}
mapping(uint => VAR45) public VAR49;
constructor(string VAR29, address VAR50, address VAR51, address VAR52, address VAR53, address VAR54) public {
VAR26 = VAR29;
VAR39 = VAR50;
VAR40 = VAR51;
VAR41 = FUN20(VAR52);
VAR43 = VAR53;
VAR42 = VAR54;
}
function FUN21() public {
VAR49[VAR44].VAR46 = true;
VAR49[VAR44].VAR48 = msg.sender;
}
function FUN22(address VAR55) public {
require(msg.sender == VAR39);
require(VAR49[VAR44].VAR48 == VAR55);
VAR44 +=1;
}
}
contract VAR56 {
using SafeMath for uint;
address public VAR57;
address public VAR39;
address public VAR58;
address public VAR42;
address public VAR40;
address public VAR43;
Token public VAR41;
address public VAR59;
bool public VAR60;
struct VAR61 {
uint VAR62;
uint VAR63;
uint VAR64;
uint VAR65;
uint VAR66;
string VAR67;
string VAR68;
}
VAR61[] public VAR69;
uint public VAR70;
uint public VAR71;
uint public VAR72;
uint public VAR73;
struct VAR74 {
bool VAR75;
uint VAR76;
uint VAR77;
uint VAR78;
uint VAR79;
bool VAR80;
bool VAR81;
uint VAR82;
}
struct VAR83 {
address VAR84;
uint VAR62;
uint VAR63;
bool VAR85;
}
mapping(address => VAR74) public VAR86;
address[] public VAR87;
mapping(address => mapping(uint => VAR83)) public VAR88;
uint[] public VAR89;
uint[] public VAR90;
uint public VAR91;
uint public VAR92;
uint public VAR93;
uint public VAR94;
uint public VAR95;
uint public VAR96;
uint public VAR97;
bool public VAR98;
uint public VAR99;
bool public VAR100;
mapping(address => uint[]) public VAR101;
mapping(address => uint[]) public VAR102;
struct VAR103 {
uint VAR64;
uint VAR104;
uint VAR97;
bool VAR105;
}
VAR103[] public VAR106;
mapping(uint => mapping(address => bool)) public VAR107;
modifier FUN23() {
require(msg.sender == VAR39 || msg.sender == VAR57);
VAR10;
}
modifier onlyAdmin() {
require(msg.sender == VAR39 || msg.sender == VAR57);
VAR10;
}
modifier FUN24() {
require(VAR71 != 0);
VAR10;
}
modifier FUN25() {
require(VAR71 == 0);
VAR10;
}
constructor( address VAR108, address VAR50, uint VAR109, address VAR110, uint[] VAR111, uint[] VAR112) public {
require(VAR111.VAR37 == VAR112.VAR37);
VAR57 = msg.sender;
VAR58 = VAR108;
VAR39 = VAR50;
VAR97 = VAR109;
VAR59 = VAR110;
VAR89 = VAR111;
VAR90 = VAR112;
VAR106.FUN26(FUN27(0,0,0,false));
VAR98 = true;
}
function FUN28(address VAR110) public {
require(msg.sender == VAR57);
VAR59 = VAR110;
}
function FUN29() onlyAdmin notSealed public {
ICOContractX VAR113 = FUN30(VAR58);
require(VAR113.FUN31() == VAR39);
VAR42 = VAR113.FUN32();
VAR40 = VAR113.FUN33();
VAR43 = VAR113.FUN34();
VAR41 = VAR113.FUN35();
VAR113.FUN21();
}
function FUN36() public {
if (VAR100 == true) {
require(msg.sender.FUN37(VAR86[msg.sender].VAR78));
}
if (msg.sender == VAR39) {
require(VAR40.FUN37(VAR72+VAR73));
VAR72 = 0;
VAR73 = 0;
}
if (msg.sender == VAR42) {
require(VAR42.FUN37(VAR91));
require(VAR59.call.value(VAR92)(VAR114.FUN38("")));
VAR91 = 0;
VAR92 = 0;
}
if (VAR86[msg.sender].VAR81 == true) {
require(msg.sender.FUN37(VAR86[msg.sender].VAR78 - VAR86[msg.sender].VAR77));
}
}
function FUN39() public {
require(VAR41.transfer(msg.sender,VAR86[msg.sender].VAR76));
VAR86[msg.sender].VAR76 = 0;
}
function FUN40(uint VAR115,uint VAR116, uint VAR117, address[] VAR118) public VAR119 {
if (VAR118.VAR37 == 0) {
VAR106.FUN26(FUN27(VAR115, VAR116,VAR117,false));
} else {
for (uint VAR36=0 ; VAR36 < VAR118.VAR37 ; VAR36++ ) {
VAR107[VAR106.VAR37][VAR118[VAR36]] = true;
}
VAR106.FUN26(FUN27(VAR115, VAR116,VAR117,true));
}
}
function FUN41(uint VAR109) onlyOperator public {
VAR97 = VAR109;
}
function FUN42(uint VAR120) public VAR119 {
require(VAR106.VAR37 > VAR120);
VAR99 = VAR120;
}
function () public payable {
require(msg.value > 0);
if (VAR106[VAR99].VAR105 == true) {
require(VAR107[VAR99][msg.sender] == true);
}
uint VAR121 = VAR86[msg.sender].VAR82;
VAR88[msg.sender][VAR121].VAR84 = msg.sender;
VAR88[msg.sender][VAR121].VAR62 = msg.value;
VAR86[msg.sender].VAR82 += 1;
}
function FUN43(uint256 VAR122) constant public returns (uint256) {
uint256 VAR123 = VAR122.FUN1(VAR97).FUN1(100).FUN2(75).FUN2(100 VAR124);
if(VAR123.FUN2(100000000) < 5000)
return VAR122.FUN1(VAR97).FUN1(100).FUN2(80).FUN2(100 VAR124);
VAR123 = VAR122.FUN1(VAR97).FUN1(100).FUN2(73).FUN2(100 VAR124);
if(VAR123.FUN2(100000000) < 25000)
return VAR122.FUN1(VAR97).FUN1(100).FUN2(75).FUN2(100 VAR124);
VAR123 = VAR122.FUN1(VAR97).FUN1(100).FUN2(70).FUN2(100 VAR124);
if(VAR123.FUN2(100000000) < 50000)
return VAR122.FUN1(VAR97).FUN1(100).FUN2(73).FUN2(100 VAR124);
VAR123 = VAR122.FUN1(VAR97).FUN1(100).FUN2(65).FUN2(100 VAR124);
if(VAR123.FUN2(100000000) < 250000)
return VAR122.FUN1(VAR97).FUN1(100).FUN2(70).FUN2(100 VAR124);
VAR123 = VAR122.FUN1(VAR97).FUN1(100).FUN2(60).FUN2(100 VAR124);
if(VAR123.FUN2(100000000) < 500000)
return VAR122.FUN1(VAR97).FUN1(100).FUN2(65).FUN2(100 VAR124);
return VAR122.FUN1(VAR97).FUN1(100).FUN2(60).FUN2(100 VAR124);
}
function FUN44(uint VAR125) public {
require(VAR88[msg.sender][VAR125].VAR85 == false);
require(msg.sender.FUN37(VAR88[msg.sender][VAR125].VAR62));
VAR88[msg.sender][VAR125].VAR62 = 0;
}
function FUN45(address VAR126) public {
require(msg.sender == VAR43);
VAR86[VAR126].VAR75 = true;
}
function FUN46(address VAR126, bool VAR127,uint VAR128) public {
require(msg.sender == VAR43);
require(VAR86[VAR126].VAR75 == true);
if (VAR127) {
VAR86[VAR126].VAR81 = true;
} else {
VAR86[VAR126].VAR80 = true;
for (uint VAR36 = VAR128; VAR36 < VAR70; VAR36++) {
VAR73 += VAR101[VAR126][VAR36];
VAR86[VAR126].VAR77 += VAR101[VAR126][VAR36];
}
}
VAR86[VAR126].VAR75 = false;
}
function FUN47(uint VAR129, uint VAR130, uint VAR115, uint VAR131, string VAR132) public notSealed VAR119 returns(uint) {
VAR93 = VAR93.FUN4(VAR129);
VAR94 = VAR94.FUN4(VAR130);
return VAR69.FUN26(FUN48(VAR129, VAR130, VAR115, 0, VAR131, VAR132, ""));
}
function FUN49() public notSealed VAR119 {
require(VAR69.VAR37 > 0);
require(VAR41.FUN13(address(this)) >= VAR94);
VAR71 = VAR133;
}
function FUN50(address VAR126, uint VAR125) public sealed VAR119 {
require(VAR88[VAR126][VAR125].VAR62 > 0);
require(VAR88[VAR126][VAR125].VAR85 != true);
VAR88[VAR126][VAR125].VAR85 = true;
uint  VAR129 = VAR88[VAR126][VAR125].VAR62;
uint VAR130 = FUN43(VAR129);
VAR88[VAR126][VAR125].VAR63 = VAR130;
if (VAR89.VAR37 == 1) {
uint VAR134 = VAR129.FUN1(VAR89[0]).FUN2(100);
uint VAR135 = VAR129.FUN1(VAR90[0]).FUN2(100);
VAR129 = VAR129.FUN3(VAR134).FUN3(VAR135);
VAR88[VAR126][VAR125].VAR62 = VAR129;
VAR91 += VAR134;
VAR92 += VAR135;
}
FUN51(VAR126, VAR129, VAR130);
if (!(VAR86[VAR126].VAR78 > 0)) VAR87.FUN26(VAR126);
if (VAR98 == true) {
VAR86[VAR126].VAR76 = VAR130;
}
VAR86[VAR126].VAR78 += VAR129;
VAR86[VAR126].VAR79 += VAR130;
}
function FUN52() public sealed VAR119 {
if (VAR70 != 0 ) {require(VAR69[VAR70-1].VAR65 > 0);}
for (uint VAR36=0; VAR36 < VAR87.VAR37 ; VAR36++) {
address VAR84 = VAR87[VAR36];
if (VAR86[VAR84].VAR75 == false) {
if (VAR86[VAR84].VAR81 != true) {
VAR72 += VAR101[VAR84][VAR70];
VAR86[VAR84].VAR77 += VAR101[VAR84][VAR70];
if (VAR98 == false) {
VAR86[VAR84].VAR76 += VAR102[VAR84][VAR70];
}
}
}
}
VAR69[VAR70].VAR64 = VAR133;
VAR70 +=1;
}
function FUN53(string VAR136) public VAR119 {
require(VAR69[VAR70-1].VAR65 == 0);
uint VAR137 = VAR133 - VAR69[VAR70-1].VAR64;
require(VAR137 > 1 VAR138);
VAR69[VAR70-1].VAR65 = VAR133;
VAR69[VAR70-1].VAR68 = VAR136;
}
//
function FUN54() public onlyAdmin {
if (msg.sender == VAR39) {
VAR60 = true;
}
if (msg.sender == VAR57) {
require(VAR60 == true);
require(VAR57.FUN37(address(this).VAR22));
uint VAR139 = VAR41.FUN13(this);
require(VAR41.transfer(VAR57,VAR139));
}
}
function FUN55() public view returns(uint) {
return VAR69.VAR37;
}
function FUN51(address VAR126, uint VAR129, uint VAR130) internal {
uint VAR140;
uint VAR141;
uint VAR142;
uint VAR143;
uint VAR144;
uint VAR145;
for(uint VAR36=VAR70; VAR36<VAR69.VAR37; VAR36++) {
VAR142 = VAR69[VAR36].VAR62;
VAR143 = VAR69[VAR36].VAR63;
VAR140 = VAR129.FUN1(VAR142).FUN2(VAR93);
VAR141 = VAR130.FUN1(VAR143).FUN2(VAR94);
VAR144 = VAR144.FUN4(VAR140);
VAR145 = VAR145.FUN4(VAR141);
if (VAR86[VAR126].VAR78 > 0) {
VAR101[VAR126][VAR36] += VAR140;
VAR102[VAR126][VAR36] += VAR141;
} else {
VAR101[VAR126].FUN26(VAR140);
VAR102[VAR126].FUN26(VAR141);
}
}
VAR101[VAR126][VAR70] += VAR129 - VAR144;
VAR102[VAR126][VAR70] += VAR130 - VAR145;
}
function FUN56(address VAR126) public view returns(bool) {
return VAR86[VAR126].VAR75;
}
function FUN57(address VAR126) public view returns(bool) {
if (VAR86[VAR126].VAR78 > 0) return true;
else return false;
}
}
contract ArbitrationX is VAR6 {
address public VAR39;
uint public VAR146 = 3;
struct VAR147 {
address VAR48;
address VAR148;
bool VAR149;
uint VAR150;
uint VAR151;
string VAR152;
uint VAR153;
uint VAR154;
mapping(address => bool) VAR155;
}
mapping(uint => VAR147) public VAR156;
uint public VAR157;
mapping(address => mapping(address => bool)) public VAR158;
modifier FUN5(address VAR9) {
require(msg.sender == VAR9);
VAR10;
}
constructor() public {
VAR39 = msg.sender;
}
function FUN58(address VAR55, address[] VAR159) FUN5(VAR7) public {
for (uint VAR36 = 0; VAR36 < VAR159.VAR37 ; VAR36++) {
VAR158[VAR55][VAR159[VAR36]] = true;
}
}
function FUN59(uint VAR160, bool VAR161) public {
require(VAR156[VAR160].VAR149 == true);
require(VAR158[VAR156[VAR160].VAR48][msg.sender] == true);
require(VAR156[VAR160].VAR155[msg.sender] != true);
if (VAR161 == true) { VAR156[VAR160].VAR154 += 1; }
else { VAR156[VAR160].VAR153 += 1; }
if (VAR156[VAR160].VAR154 == VAR146) {
FUN60(VAR160,true);
}
if (VAR156[VAR160].VAR153 == VAR146) {
FUN60(VAR160,false);
}
VAR156[VAR160].VAR155[msg.sender] == true;
}
function FUN61(address VAR55, string VAR162) public {
ICOCycle VAR163 = FUN62(VAR55);
uint VAR164 = VAR163.FUN63();
require(VAR164 > 0);
require(VAR163.FUN57(msg.sender) == true);
VAR156[VAR157].VAR151 = VAR164;
VAR156[VAR157].VAR48 = VAR55;
VAR156[VAR157].VAR148 = msg.sender;
VAR156[VAR157].VAR150 = VAR133;
VAR156[VAR157].VAR152 = VAR162;
VAR156[VAR157].VAR149 = true;
VAR163.FUN45(msg.sender);
VAR157 +=1;
}
function FUN60(uint VAR160, bool VAR127) internal {
VAR156[VAR160].VAR149 = false;
uint VAR164 = VAR156[VAR160].VAR151;
ICOCycle VAR163 = FUN62(VAR156[VAR160].VAR48);
VAR163.FUN46(VAR156[VAR160].VAR148,VAR127,VAR164);
}
function FUN64(uint VAR165) public view returns(bool) {
return VAR156[VAR165].VAR149;
}
}
contract VAR166 {
Token public VAR41;
uint public VAR167 = 2443;
address public VAR7;
constructor(address VAR168) public {
VAR7 = msg.sender;
VAR41 = FUN20(VAR168);
}
function FUN65() public payable {
uint VAR169 = msg.value * VAR167;
require(VAR41.transfer(VAR7,VAR169));
}
function FUN66(uint VAR170) public {
require(msg.sender == VAR7);
VAR167 = VAR170;
}
}
contract VAR171 {
Token public VAR172;
Token public VAR41;
address public VAR7;
struct VAR173 {
address VAR12;
uint VAR33;
}
VAR173[] public VAR174;
constructor(address VAR52, address VAR175) public {
VAR7 = msg.sender;
VAR41 = FUN20(VAR52);
VAR172 = FUN20(VAR175);
}
function FUN65() public {
uint VAR176 = VAR172.FUN16(msg.sender,address(this));
require(VAR41.FUN13(address(this)) >= VAR176);
require(VAR41.transfer(msg.sender, VAR176));
require(VAR172.FUN12(msg.sender,address(this),VAR176));
VAR174.FUN26(FUN67(msg.sender,VAR176));
}
function FUN68() public {
uint VAR176 = VAR172.FUN16(msg.sender,address(this));
require(VAR172.FUN12(msg.sender,address(this),VAR176));
require(VAR172.transfer(msg.sender, VAR176));
}
}
1
---------------------------------
19 0x273dc4c0b19669f9c53f48d170b3f2e18167dad4.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract ChilliZTokenPurchase is VAR2 {
address public VAR13 = 0xd64671135E7e01A1e3AB384691374FdDA0641Ed6;
address public VAR14 = 0x212286e36Ae998FAd27b627EB326107B3aF1FeD4;
address public VAR15 = 0x515962688858eD980EB2Db2b6fA2802D9f620C6d;
uint public VAR16 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR17) internal {
uint VAR18 = VAR17 * 25 / 1050;
uint VAR19 = VAR17 * 25 / 1050;
FUN9(VAR14, VAR18);
FUN9(VAR15, VAR19);
uint VAR20 = VAR17 - VAR18 - VAR19;
FUN9(VAR13, VAR20);
}
function FUN9(address VAR21, uint VAR17) internal {
require(VAR21.call.FUN10(VAR16).value(VAR17)());
}
function FUN11(uint VAR22) public onlyOwner {
VAR16 = VAR22;
}
function FUN12(EIP20Token VAR23, address VAR24, uint value) public onlyOwner {
VAR23.FUN5(VAR24, value);
}
function FUN13() public onlyOwner {
FUN9(msg.sender, address(this).VAR25);
}
}
1
---------------------------------
20 0x277baa753022e827d8e240e2fc8cdb53ddbff7ad.sol
pragma VAR1 ^0.4.15;
pragma VAR1 ^0.4.14;
library VAR2 {
struct VAR3 {
uint VAR4;
uint VAR5;
}
function FUN1(uint VAR6, uint VAR7, uint VAR8) private pure {
for(; VAR8 >= 32; VAR8 -= 32) {
VAR9 {
FUN2(VAR6, FUN3(VAR7))
}
VAR6 += 32;
VAR7 += 32;
}
uint VAR10 = 256 ** (32 - VAR8) - 1;
VAR9 {
let VAR11 := FUN4(FUN3(VAR7), FUN5(VAR10))
let VAR12 := FUN4(FUN3(VAR6), VAR10)
FUN2(VAR6, or(VAR12, VAR11))
}
}
function FUN6(string VAR13) internal pure returns (VAR3) {
uint VAR14;
VAR9 {
VAR14 := FUN7(VAR13, 0x20)
}
return FUN8(bytes(VAR13).VAR15, VAR14);
}
function FUN9(bytes32 VAR13) internal pure returns (uint) {
uint VAR16;
if (VAR13 == 0)
return 0;
if (VAR13 & 0xffffffffffffffffffffffffffffffff == 0) {
VAR16 += 16;
VAR13 = bytes32(uint(VAR13) / 0x100000000000000000000000000000000);
}
if (VAR13 & 0xffffffffffffffff == 0) {
VAR16 += 8;
VAR13 = bytes32(uint(VAR13) / 0x10000000000000000);
}
if (VAR13 & 0xffffffff == 0) {
VAR16 += 4;
VAR13 = bytes32(uint(VAR13) / 0x100000000);
}
if (VAR13 & 0xffff == 0) {
VAR16 += 2;
VAR13 = bytes32(uint(VAR13) / 0x10000);
}
if (VAR13 & 0xff == 0) {
VAR16 += 1;
}
return 32 - VAR16;
}
function FUN10(bytes32 VAR13) internal pure returns (slice VAR16) {
VAR9 {
let VAR14 := FUN3(0x40)
FUN2(0x40, FUN7(VAR14, 0x20))
FUN2(VAR14, VAR13)
FUN2(FUN7(VAR16, 0x20), VAR14)
}
VAR16.VAR4 = FUN9(VAR13);
}
function FUN11(slice VAR13) internal pure returns (VAR3) {
return FUN8(VAR13.VAR4, VAR13.VAR5);
}
function FUN12(slice VAR13) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
return VAR16;
}
function FUN9(slice VAR13) internal pure returns (uint VAR19) {
uint VAR14 = VAR13.VAR5 - 31;
uint VAR20 = VAR14 + VAR13.VAR4;
for (VAR19 = 0; VAR14 < VAR20; VAR19++) {
uint8 VAR21;
VAR9 { VAR21 := FUN4(FUN3(VAR14), 0xFF) }
if (VAR21 < 0x80) {
VAR14 += 1;
} else if(VAR21 < 0xE0) {
VAR14 += 2;
} else if(VAR21 < 0xF0) {
VAR14 += 3;
} else if(VAR21 < 0xF8) {
VAR14 += 4;
} else if(VAR21 < 0xFC) {
VAR14 += 5;
} else {
VAR14 += 6;
}
}
}
function FUN13(slice VAR13) internal pure returns (bool) {
return VAR13.VAR4 == 0;
}
function FUN14(slice VAR13, slice VAR22) internal pure returns (int) {
uint VAR23 = VAR13.VAR4;
if (VAR22.VAR4 < VAR13.VAR4)
VAR23 = VAR22.VAR4;
uint VAR24 = VAR13.VAR5;
uint VAR25 = VAR22.VAR5;
for (uint VAR26 = 0; VAR26 < VAR23; VAR26 += 32) {
uint VAR27;
uint VAR21;
VAR9 {
VAR27 := FUN3(VAR24)
VAR21 := FUN3(VAR25)
}
if (VAR27 != VAR21) {
uint256 VAR10 = uint256(-1);
if(VAR23 < 32) {
VAR10 = ~(2 ** (8 * (32 - VAR23 + VAR26)) - 1);
}
uint256 VAR28 = (VAR27 & VAR10) - (VAR21 & VAR10);
if (VAR28 != 0)
return int(VAR28);
}
VAR24 += 32;
VAR25 += 32;
}
return int(VAR13.VAR4) - int(VAR22.VAR4);
}
function FUN15(slice VAR13, slice VAR22) internal pure returns (bool) {
return FUN14(VAR13, VAR22) == 0;
}
function FUN16(slice VAR13, slice VAR29) internal pure returns (VAR3) {
VAR29.VAR5 = VAR13.VAR5;
if (VAR13.VAR4 == 0) {
VAR29.VAR4 = 0;
return VAR29;
}
uint VAR19;
uint VAR21;
VAR9 { VAR21 := FUN4(FUN3(FUN17(FUN3(FUN7(VAR13, 32)), 31)), 0xFF) }
if (VAR21 < 0x80) {
VAR19 = 1;
} else if(VAR21 < 0xE0) {
VAR19 = 2;
} else if(VAR21 < 0xF0) {
VAR19 = 3;
} else {
VAR19 = 4;
}
if (VAR19 > VAR13.VAR4) {
VAR29.VAR4 = VAR13.VAR4;
VAR13.VAR5 += VAR13.VAR4;
VAR13.VAR4 = 0;
return VAR29;
}
VAR13.VAR5 += VAR19;
VAR13.VAR4 -= VAR19;
VAR29.VAR4 = VAR19;
return VAR29;
}
function FUN16(slice VAR13) internal pure returns (slice VAR16) {
FUN16(VAR13, VAR16);
}
function FUN18(slice VAR13) internal pure returns (uint VAR16) {
if (VAR13.VAR4 == 0) {
return 0;
}
uint VAR30;
uint VAR15;
uint VAR31 = 2 ** 248;
VAR9 { VAR30:= FUN3(FUN3(FUN7(VAR13, 32))) }
uint VAR21 = VAR30 / VAR31;
if (VAR21 < 0x80) {
VAR16 = VAR21;
VAR15 = 1;
} else if(VAR21 < 0xE0) {
VAR16 = VAR21 & 0x1F;
VAR15 = 2;
} else if(VAR21 < 0xF0) {
VAR16 = VAR21 & 0x0F;
VAR15 = 3;
} else {
VAR16 = VAR21 & 0x07;
VAR15 = 4;
}
if (VAR15 > VAR13.VAR4) {
return 0;
}
for (uint VAR32 = 1; VAR32 < VAR15; VAR32++) {
VAR31 = VAR31 / 256;
VAR21 = (VAR30 / VAR31) & 0xFF;
if (VAR21 & 0xC0 != 0x80) {
return 0;
}
VAR16 = (VAR16 * 64) | (VAR21 & 0x3F);
}
return VAR16;
}
function FUN19(slice VAR13) internal pure returns (bytes32 VAR16) {
VAR9 {
VAR16 := FUN20(FUN3(FUN7(VAR13, 32)), FUN3(VAR13))
}
}
function FUN21(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
if (VAR13.VAR5 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN23(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
bool VAR34 = true;
if (VAR13.VAR5 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN24(VAR24, VAR15), FUN24(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
VAR13.VAR5 += VAR33.VAR4;
}
return VAR13;
}
function FUN25(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
if (VAR24 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN26(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
bool VAR34 = true;
if (VAR24 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
}
return VAR13;
}
event FUN27(bytes32 VAR10);
function FUN28(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14 = VAR24;
uint VAR26;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
uint VAR20 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 >= VAR20)
return VAR24 + VAR36;
VAR14++;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
for (VAR26 = 0; VAR26 <= VAR36 - VAR37; VAR26++) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14;
VAR14 += 1;
}
}
}
return VAR24 + VAR36;
}
function FUN29(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
VAR14 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 <= VAR24)
return VAR24;
VAR14--;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14 + VAR37;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
VAR14 = VAR24 + (VAR36 - VAR37);
while (VAR14 >= VAR24) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14 + VAR37;
VAR14 -= 1;
}
}
}
return VAR24;
}
function FUN30(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 -= VAR14 - VAR13.VAR5;
VAR13.VAR5 = VAR14;
return VAR13;
}
function FUN31(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 = VAR14 - VAR13.VAR5;
return VAR13;
}
function FUN32(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR13.VAR5;
VAR42.VAR4 = VAR14 - VAR13.VAR5;
if (VAR14 == VAR13.VAR5 + VAR13.VAR4) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
VAR13.VAR5 = VAR14 + VAR33.VAR4;
}
return VAR42;
}
function FUN32(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN32(VAR13, VAR33, VAR42);
}
function FUN33(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR14;
VAR42.VAR4 = VAR13.VAR4 - (VAR14 - VAR13.VAR5);
if (VAR14 == VAR13.VAR5) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
}
return VAR42;
}
function FUN33(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN33(VAR13, VAR33, VAR42);
}
function FUN34(slice VAR13, slice VAR33) internal pure returns (uint VAR43) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
while (VAR14 <= VAR13.VAR5 + VAR13.VAR4) {
VAR43++;
VAR14 = FUN28(VAR13.VAR4 - (VAR14 - VAR13.VAR5), VAR14, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
}
}
function FUN35(slice VAR13, slice VAR33) internal pure returns (bool) {
return FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) != VAR13.VAR5;
}
function FUN36(slice VAR13, slice VAR22) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4 + VAR22.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
FUN1(VAR18 + VAR13.VAR4, VAR22.VAR5, VAR22.VAR4);
return VAR16;
}
function FUN37(slice VAR13, VAR3[] VAR44) internal pure returns (string) {
if (VAR44.VAR15 == 0)
return "";
uint VAR15 = VAR13.VAR4 * (VAR44.VAR15 - 1);
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++)
VAR15 += VAR44[VAR32].VAR4;
string memory VAR16 = VAR17 string(VAR15);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
for(VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
FUN1(VAR18, VAR44[VAR32].VAR5, VAR44[VAR32].VAR4);
VAR18 += VAR44[VAR32].VAR4;
if (VAR32 < VAR44.VAR15 - 1) {
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
VAR18 += VAR13.VAR4;
}
}
return VAR16;
}
}
address sender;
address VAR45;
uint256 VAR46;
uint256 VAR47;
address VAR48;
string VAR49;
string VAR50;
string VAR51;
mapping (string => bool) VAR52;
enum VAR53 {VAR54, VAR55, VAR56, VAR57}
Status VAR58;
event FUN38(address VAR59, uint value);
event FUN39(address VAR48, uint value, address VAR60, bytes VAR61);
function FUN40 () {
sender = msg.sender;
VAR58 = VAR53.VAR57;
}
function FUN41(address VAR62, string VAR63, string VAR64, string VAR65, address VAR66, uint256 VAR67, uint256 VAR68) onlySender VAR69 {
VAR58 = VAR53.VAR54;
VAR45 = VAR66;
VAR48 = VAR62;
VAR46 = VAR67;
VAR47 = VAR68;
VAR50 = VAR63;
VAR51 = VAR64;
VAR49 = VAR65;
var VAR70 = VAR64.FUN6().FUN11();
var VAR71 = "".FUN6();
var VAR44 = new uint256[](VAR70.FUN34(VAR71) + 1);
uint256 VAR72;
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
VAR72 = VAR72 + FUN42(VAR70.FUN32(VAR71).FUN12());
}
require(VAR72 == 100000);
}
modifier onlyOwner() {
require(msg.sender == VAR48);
VAR73;
}
modifier FUN43() {
require(msg.sender == sender);
VAR73;
}
modifier FUN44() {
require(VAR58 == VAR53.VAR57);
VAR73;
}
modifier FUN45() {
require(VAR58 == VAR53.VAR55 || VAR58 == VAR53.VAR54);
VAR73;
}
modifier FUN46() {
require(VAR58 == VAR53.VAR56);
VAR73;
}
modifier FUN47() {
var VAR70 = VAR50.FUN6().FUN11();
var VAR71 = "".FUN6();
string[] memory VAR74 = new string[](VAR70.FUN34(VAR71) + 1);
bool VAR75 = false;
string memory VAR76 = FUN48(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR74.VAR15; VAR32++) {
if(FUN20(VAR76) == FUN20(VAR70.FUN32(VAR71).FUN12())){
VAR75 = true;
break;
}
}
require(VAR75);
VAR73;
}
modifier FUN49() {
var VAR70 = VAR49.FUN6().FUN11();
var VAR71 = "".FUN6();
string[] memory VAR77 = new string[](VAR70.FUN34(VAR71) + 1);
bool VAR78 = false;
string memory VAR76 = FUN48(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR77.VAR15; VAR32++) {
if(FUN20(VAR76) == FUN20(VAR70.FUN32(VAR71).FUN12())){
VAR78 = true;
break;
}
}
require(VAR78);
VAR73;
}
function () payable VAR79 {
if (VAR58 == VAR53.VAR54) {
var VAR80 = VAR49.FUN6().FUN11();
var VAR81 = VAR80.FUN34("".FUN6()) + 1;
var VAR82 = FUN50() * VAR81 + FUN51();
require(msg.value > VAR82);
VAR45.transfer(FUN51());
for (uint VAR32 = 0; VAR32 < VAR81; VAR32++) {
var VAR83 = FUN52(VAR80.FUN32("".FUN6()).FUN12());
VAR83.transfer(FUN50());
}
VAR58 = VAR53.VAR55;
FUN38(msg.sender, msg.value);
} else {
FUN38(msg.sender, msg.value);
}
}
function FUN53() onlyWitness VAR79 {
require (this.VAR84 > 0);
VAR52[FUN48(msg.sender)] = true;
var VAR85 = VAR49.FUN6().FUN11();
uint256 VAR86 = VAR85.FUN34("".FUN6()) + 1;
uint8 VAR87 = 0;
for(uint VAR32 = 0; VAR32 < VAR86; VAR32++) {
if(VAR52[VAR85.FUN32("".FUN6()).FUN12()] == true){
VAR87 = VAR87 + 1;
}
}
if(VAR87 == VAR86){
VAR85 = VAR50.FUN6().FUN11();
var  VAR88 = VAR51.FUN6().FUN11();
VAR86 = VAR85.FUN34("".FUN6()) + 1;
for(VAR32 = 0; VAR32 < VAR86 - 1; VAR32++) {
FUN52(VAR85.FUN32("".FUN6()).FUN12()).transfer(((this.VAR84 * FUN42(VAR88.FUN32("".FUN6()).FUN12())) / 100000));
}
FUN52(VAR85.FUN32("".FUN6()).FUN12()).transfer(this.VAR84);
VAR58 = VAR53.VAR56;
}
}
function FUN54(address VAR89, uint VAR90, bytes VAR91) external onlyOwner {
FUN39(msg.sender, VAR90, VAR89, VAR91);
VAR89.call.value(VAR90)(VAR91);
}
function FUN55() returns (bool){
return msg.sender == VAR48;
}
function FUN56() returns (VAR53){
return VAR58;
}
function FUN51() returns (uint256) {
return VAR46 * VAR47;
}
function FUN50() returns (uint256) {
return (1000000 * VAR46);
}
function FUN57() returns (string, string) {
return (VAR50, VAR51);
}
function FUN58() returns (string) {
return VAR49;
}
function FUN59() returns (uint) {
return VAR49.FUN6().FUN11().FUN34("".FUN6()) + 1;
}
function FUN60() constant returns (uint) {
return  address(this).VAR84;
}
function FUN61() returns (bool){
return VAR52[FUN48(msg.sender)];
}
function FUN42(string VAR70) constant private returns (uint VAR92) {
bytes memory VAR21 = bytes(VAR70);
uint VAR32;
VAR92 = 0;
for (VAR32 = 0; VAR32 < VAR21.VAR15; VAR32++) {
uint VAR93 = uint(VAR21[VAR32]);
if (VAR93 >= 48 && VAR93 <= 57) {
VAR92 = VAR92 * 10 + (VAR93 - 48);
}
}
}
function FUN48(address VAR94) private returns (string) {
bytes memory VAR70 = VAR17 bytes(42);
VAR70[0] = "";
VAR70[1] = "";
for (uint VAR32 = 0; VAR32 < 20; VAR32++) {
byte VAR21 = FUN62(uint8(uint(VAR94) / (2**(8*(19 - VAR32)))));
byte VAR95 = FUN62(uint8(VAR21) / 16);
byte VAR96 = FUN62(uint8(VAR21) - 16 * uint8(VAR95));
VAR70[2+2*VAR32] = FUN63(VAR95);
VAR70[2+2*VAR32+1] = FUN63(VAR96);
}
return string(VAR70);
}
function FUN63(byte VAR21) private returns (byte VAR93) {
if (VAR21 < 10) return FUN62(uint8(VAR21) + 0x30);
else return FUN62(uint8(VAR21) + 0x57);
}
function FUN52(string VAR97) internal returns (address){
bytes memory VAR98 = bytes(VAR97);
uint160 VAR99 = 0;
uint160 VAR100;
uint160 VAR101;
for (uint VAR32=2; VAR32<2+2*20; VAR32+=2){
VAR99 *= 256;
VAR100 = FUN64(VAR98[VAR32]);
VAR101 = FUN64(VAR98[VAR32+1]);
if ((VAR100 >= 97)&&(VAR100 <= 102)) VAR100 -= 87;
else if ((VAR100 >= 48)&&(VAR100 <= 57)) VAR100 -= 48;
if ((VAR101 >= 97)&&(VAR101 <= 102)) VAR101 -= 87;
else if ((VAR101 >= 48)&&(VAR101 <= 57)) VAR101 -= 48;
VAR99 += (VAR100*16+VAR101);
}
return address(VAR99);
}
}
1
---------------------------------
21 0x27b836d5697ea4413faaafef483ce033ec846e06.sol
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) payable;
}
contract VAR8 {
address public VAR9;
function FUN6() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9);
VAR10;
}
function FUN7(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Preallocation is VAR8 {
using SafeMath for uint;
address public VAR12;
uint public VAR13;
enum VAR14 { VAR15, VAR16, VAR17 }
States public VAR18 = VAR14.VAR15;
event FUN8(address VAR19, address VAR20);
event FUN9(uint value, address VAR19);
event FUN10(uint VAR21);
event FUN11(uint value);
event FUN12();
function FUN13(address VAR22, uint VAR23) {
VAR12 = VAR22;
VAR13 = VAR23;
}
function () payable {
if (this.VAR21 > VAR13) {
throw;
}
FUN9(msg.value, msg.sender);
}
function FUN14() onlyOwner FUN15(VAR14.VAR16) {
uint VAR24 = this.VAR21;
if (!VAR12.FUN16(VAR24)) {
throw;
}
FUN10(VAR24);
}
function FUN17(address VAR22) onlyOwner {
FUN8(VAR12, VAR22);
VAR12 = VAR22;
}
function FUN5(Crowdsale VAR25) onlyOwner {
uint VAR24 = VAR26.FUN18(this.VAR21, VAR13);
VAR25.VAR27.value(VAR24)(VAR12);
VAR18 = VAR14.VAR16;
FUN11(VAR24);
}
function FUN19() onlyOwner {
VAR18 = VAR14.VAR17;
FUN12();
}
function FUN20(States VAR28) constant returns (bool) {
return VAR18 == VAR28;
}
modifier FUN21(States VAR28) {
require (VAR18 == VAR28);
VAR10;
}
modifier FUN15(States VAR28) {
require (VAR18 != VAR28);
VAR10;
}
}
library VAR26 {
function FUN22(uint64 VAR3, uint64 VAR4) internal constant returns (VAR29) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN23(uint64 VAR3, uint64 VAR4) internal constant returns (VAR29) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN24(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN18(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
1
---------------------------------
22 0x29fe0248fe903e7cb6d7b71161e6d7233ae460e3.sol
pragma VAR1 ^0.4.24;
contract VAR2{
address VAR3 = address(0);
bool VAR4 = false;
function FUN1() payable
{
if ((FUN2()%2==1) && (msg.value == 1 VAR5) && (!VAR4))
{
if (!msg.sender.call.value(2 VAR5)())
throw;
}
}
function FUN3()
{
if (VAR3==msg.sender)
{
VAR4 = true;
}
}
function FUN4()
{
if (VAR3==msg.sender)
{
VAR4 = false;
}
}
function FUN5(address VAR6)
{
if ((VAR3 == address(0)) || (VAR3 == msg.sender))
{
VAR3 = VAR6;
}
}
function FUN6(uint VAR7)
{
if (VAR3==msg.sender)
{
if (!msg.sender.call.value( VAR7 * (1 VAR5))())
throw;
}
}
function FUN2() view returns (uint8) {
return uint8(uint256(FUN7(VAR8.VAR9, VAR8.VAR10))%256);
}
function () public  payable
{
FUN1();
}
}
1
---------------------------------
23 0x2c101930fcccc867141bf653b962aced709aa8cf.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
constructor() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR8;
}
}
contract VAR9 {
uint8 public VAR10;
modifier FUN5(uint8 VAR11) {
require(VAR10 == VAR11);
VAR8;
}
}
contract Fighter is VAR6, VAR9 {
using SafeMath for uint256;
uint256 public VAR12 = 0;
string VAR13;
constructor(string VAR14, uint256 VAR15) public {
VAR13 = VAR14;
VAR12 = VAR15;
VAR10 = 0;
}
function FUN6(uint8 VAR11) public onlyOwner {
VAR10 = VAR11;
}
function FUN7() public view returns (address) {
return address(this);
}
function() public payable FUN5(0) {
require(msg.value >= VAR12);
FUN8(address(VAR7)).FUN9(msg.value, msg.sender);
}
function FUN10() public onlyOwner FUN5(1) {
if (address(this).VAR16 > 0) {
FUN8(address(VAR7)).VAR17.value(address(this).VAR16)();
}
}
}
contract MasterFighter is VAR6, VAR9 {
using SafeMath for uint256;
uint256 public VAR18 = 5;
uint256 public constant VAR12 = 0.01 VAR19;
bool public VAR20 = false;
address VAR21;
address[] public VAR22;
struct VAR23 {
uint256 VAR24;
bool VAR25;
}
mapping(address => mapping(address => VAR23)) public VAR26;
mapping(address => address[]) public VAR27;
mapping(address => uint256) public VAR28;
uint256 public VAR29;
event FUN11(uint8 VAR11);
event FUN12(address VAR30, address VAR31, uint256 VAR32);
function FUN13() public payable FUN5(1) {
}
constructor() public {
VAR10 = 0;
FUN14(VAR33 FUN15("", VAR12));
FUN14(VAR33 FUN15("", VAR12));
}
function FUN16(address VAR34) external view returns (uint256) {
return VAR27[VAR34].VAR35;
}
function FUN17() external onlyOwner FUN5(0) {
VAR10 = 1;
for (uint8 VAR36 = 0; VAR36 < VAR22.VAR35; VAR36++) {
FUN15(VAR22[VAR36]).FUN6(VAR10);
FUN15(VAR22[VAR36]).FUN10();
}
emit FUN11(VAR10);
}
function FUN18() external onlyOwner FUN5(1) {
VAR10 = 3;
emit FUN11(VAR10);
}
function FUN14(address VAR34) private FUN5(0) {
VAR22.FUN19(FUN15(VAR34));
}
function FUN20(address VAR34) private view returns (bool) {
for (uint8 VAR36 = 0; VAR36 < VAR22.VAR35; VAR36++) {
if (VAR34 == VAR22[VAR36]) {
return true;
}
}
return false;
}
function FUN9(uint256 VAR32, address VAR30) external {
require(FUN20(msg.sender));
if (VAR26[msg.sender][VAR30].VAR24 > 0) {
VAR26[msg.sender][VAR30].VAR24 = VAR26[msg.sender][VAR30].VAR24.FUN4(VAR32);
} else {
VAR27[msg.sender].FUN19(VAR30);
VAR26[msg.sender][VAR30] = FUN21(VAR32, false);
}
VAR29 = VAR29.FUN4(VAR32);
VAR28[msg.sender] = VAR28[msg.sender].FUN4(VAR32);
emit FUN12(VAR30, msg.sender, VAR32);
}
function FUN22() public constant returns (uint256) {
return VAR29;
}
function FUN23() public constant returns (uint256) {
return FUN22().FUN1(VAR18).FUN2(100);
}
function FUN24() public constant returns (uint256) {
return FUN22().FUN3(FUN23());
}
function FUN25(address VAR31) external onlyOwner FUN5(1) {
require(FUN20(VAR31));
VAR10 = 2;
VAR21 = VAR31;
emit FUN11(VAR10);
}
function FUN26() external onlyOwner FUN5(2) {
require(!VAR20);
VAR20 = true;
VAR7.transfer(FUN23());
}
function FUN27(address VAR30) public FUN5(2) {
require(VAR26[VAR21][VAR30].VAR24 > 0);
require(!VAR26[VAR21][VAR30].VAR25);
address(VAR30).transfer(FUN24().FUN1(VAR26[VAR21][VAR30].VAR24).FUN2(VAR28[VAR21]));
VAR26[VAR21][VAR30].VAR25 = true;
}
function FUN28(address VAR30) external FUN5(3) {
uint256 VAR24 = 0;
for (uint8 VAR36 = 0; VAR36 < VAR22.VAR35; VAR36++) {
if (VAR26[VAR22[VAR36]][VAR30].VAR24 > 0 && !VAR26[VAR22[VAR36]][VAR30].VAR25) {
VAR26[VAR22[VAR36]][VAR30].VAR25 = true;
VAR24 = VAR24.FUN4(VAR26[VAR22[VAR36]][VAR30].VAR24);
}
}
if (VAR24 > 0) {
address(VAR30).transfer(VAR24);
}
}
}
1
---------------------------------
24 0x2d51eef741d906084ce3bacaa0e66e4d261fdccf.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
function FUN1(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) internal returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5>=VAR3 && VAR5>=VAR4);
return VAR5;
}
function assert(bool VAR6) internal {
if (!VAR6) throw;
}
}
contract VAR7 {
function FUN4() constant returns (uint256 VAR8) {}
function FUN5(address VAR9) constant returns (uint256 VAR10) {}
function transfer(address VAR11, uint256 VAR12) returns (bool VAR13) {}
function FUN6(address VAR14, address VAR11, uint256 VAR12) returns (bool VAR13) {}
function FUN7(address VAR15, uint256 VAR12) returns (bool VAR13) {}
function FUN8(address VAR9, address VAR15) constant returns (uint256 VAR16) {}
event Transfer(address indexed VAR14, address indexed VAR11, uint256 VAR12);
event FUN9(address indexed VAR9, address indexed VAR15, uint256 VAR12);
}
contract StandardToken is VAR7 {
function transfer(address VAR11, uint256 VAR12) returns (bool VAR13) {
if (VAR17[msg.sender] >= VAR12 && VAR17[VAR11] + VAR12 > VAR17[VAR11]) {
VAR17[msg.sender] -= VAR12;
VAR17[VAR11] += VAR12;
Transfer(msg.sender, VAR11, VAR12);
return true;
} else { return false; }
}
function FUN6(address VAR14, address VAR11, uint256 VAR12) returns (bool VAR13) {
if (VAR17[VAR14] >= VAR12 && VAR18[VAR14][msg.sender] >= VAR12 && VAR17[VAR11] + VAR12 > VAR17[VAR11]) {
VAR17[VAR11] += VAR12;
VAR17[VAR14] -= VAR12;
VAR18[VAR14][msg.sender] -= VAR12;
Transfer(VAR14, VAR11, VAR12);
return true;
} else { return false; }
}
function FUN5(address VAR9) constant returns (uint256 VAR10) {
return VAR17[VAR9];
}
function FUN7(address VAR15, uint256 VAR12) returns (bool VAR13) {
VAR18[msg.sender][VAR15] = VAR12;
FUN9(msg.sender, VAR15, VAR12);
return true;
}
function FUN8(address VAR9, address VAR15) constant returns (uint256 VAR16) {
return VAR18[VAR9][VAR15];
}
mapping(address => uint256) VAR17;
mapping (address => mapping (address => uint256)) VAR18;
uint256 public VAR19;
}
contract AutomobileCyberchainToken is VAR20, VAR2 {
string public VAR21 = "";
string public VAR22 = "";
uint public VAR23 = 18;
uint VAR24  = 32000;
uint VAR25 = 20000;
uint VAR26 = 256 * 24 * 30;
uint VAR27 = 256 * 24 * 95;
uint public VAR28 = 5455280;
uint public VAR29 = VAR28 + VAR27;
address public VAR30 = 0xfD16CDC79382F86303E2eE8693C7f50A4d8b937F;
uint256 public VAR31 = 15625 * 10**18;
uint256 public VAR32 =    88125 * 10**18;
uint256 public VAR33 = 1050000000 * 10**18;
uint256 public VAR34 = 3000000000 * 10**18;
uint256 public VAR35 = 0;
uint256 public VAR36 = 0;
bool public VAR37 = false;
event FUN10(address indexed sender, uint VAR38, uint VAR39);
function FUN11() {
VAR17[VAR30] = VAR33;
VAR19 = VAR33;
Transfer(address(0), VAR30, VAR33);
}
function FUN12() constant returns(uint) {
if (VAR40.VAR41<VAR28 || VAR40.VAR41 > VAR29) return 0;
else if (VAR40.VAR41>=VAR28 && VAR40.VAR41<VAR28+VAR26) return VAR24;
else  return VAR25;
}
function() public payable  {
FUN13(msg.sender, msg.value);
}
function FUN14(address VAR42, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
}
FUN13(VAR42, value);
}
function FUN13(address VAR42, uint256 value) internal {
if (VAR40.VAR41<VAR28 || VAR40.VAR41>VAR29 || FUN3(VAR36,value)>VAR32 || VAR37) throw;
if (VAR40.VAR41>=VAR28 && VAR40.VAR41<=VAR28+VAR26 && FUN3(VAR36,value) > VAR31) throw;
uint VAR43 = FUN1(value, FUN12());
VAR17[VAR42] = FUN3(VAR17[VAR42], VAR43);
VAR19 = FUN3(VAR19, VAR43);
VAR36 = FUN3(VAR36, value);
if (VAR40.VAR41<=VAR28+VAR26) {
VAR35 = FUN3(VAR35, VAR43);
}
Transfer(address(0), VAR42, VAR43);
if (!VAR30.call.value(value)()) throw;
FUN10(VAR42, value, VAR43);
}
function FUN15() {
if (msg.sender!=VAR30) throw;
VAR37 = true;
}
function FUN16() {
if (msg.sender!=VAR30) throw;
VAR37 = false;
}
function FUN17(address VAR44) {
if (msg.sender!=VAR30) throw;
VAR30 = VAR44;
}
function FUN18(address VAR42) public {
require(msg.sender == VAR30 && VAR40.VAR41 > VAR29 && VAR19 < VAR34);
uint256 VAR45 = FUN2(VAR34, VAR19);
VAR17[VAR42] = FUN3(VAR17[VAR42], VAR45);
VAR19 = VAR34;
Transfer(address(0), VAR42, VAR45);
}
}
1
---------------------------------
25 0x2df3941ef151b310de7d7cb8494534a56997f264.sol
pragma VAR1 ^0.4.25;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
require(VAR7 != 0);
return VAR6 % VAR7;
}
}
contract VAR8 {
address public VAR9;
event FUN6(address indexed VAR10);
event FUN7(
address indexed VAR10,
address indexed VAR11
);
constructor() public {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9);
VAR12;
}
function FUN8() public onlyOwner {
emit FUN6(VAR9);
VAR9 = address(0);
}
function FUN9(address VAR13) public onlyOwner {
FUN10(VAR13);
}
function FUN10(address VAR13) internal {
require(VAR13 != address(0));
emit FUN7(VAR9, VAR13);
VAR9 = VAR13;
}
}
contract Wallet is VAR8 {
using SafeMath for uint256;
LotteryData public VAR14;
uint256 public VAR15 = 10**16;
function FUN11(uint256 value) public onlyOwner {
VAR15 = value;
}
constructor() public {
VAR14 = FUN12(msg.sender);
}
function() payable external {
require(msg.value >= VAR15);
VAR14.FUN13(msg.sender, msg.value);
}
function FUN14() external returns(uint256) {
require(msg.sender == address(VAR14));
uint256 VAR16 = address(this).VAR16;
if (VAR16 >= VAR15) {
VAR14.VAR17.value(VAR16)();
return VAR16;
}
else {
return 0;
}
}
}
contract LotteryData is VAR8 {
using SafeMath for uint256;
event FUN15(address indexed VAR18, uint256 VAR19);
event FUN16(address indexed VAR18, uint256 VAR19);
event FUN17(address indexed VAR20, uint256 VAR21);
Wallet public VAR22 = VAR23 FUN18();
Wallet public VAR24 = VAR23 FUN18();
Wallet public VAR25 = VAR23 FUN18();
uint256 public VAR26;
uint256 constant VAR27 = 86400;
uint internal VAR28;
uint internal VAR29 = 100;
uint internal VAR30;
uint internal VAR31 = 19;
uint internal VAR32;
uint internal VAR33;
uint internal VAR34;
uint256 internal VAR35;
uint256 internal VAR36;
uint256 internal VAR37;
mapping(uint => address) public VAR38;
mapping(address => mapping (address => uint256)) public VAR39;
mapping(address => mapping (uint => address)) public VAR40;
mapping(address => uint256) public VAR41;
mapping(address => uint) public VAR42;
mapping(address => uint256) private VAR43;
uint public VAR44;
struct VAR45{
address VAR32;
uint256 VAR46;
}
mapping(uint => VAR45) public VAR47;
constructor() public {
VAR38[0] = address(VAR22);
VAR38[1] = address(VAR24);
VAR38[2] = address(VAR25);
VAR26 = VAR48.FUN4(VAR27);
}
modifier FUN19() {
require(
msg.sender == address(VAR22) ||
msg.sender == address(VAR24) ||
msg.sender == address(VAR25)
);
VAR12;
}
function FUN20(address VAR18) public view returns (uint256) {
return VAR43[VAR18];
}
function FUN21(address VAR18, uint256 VAR49) internal {
VAR43[VAR18] = VAR43[VAR18].FUN4(VAR49);
emit FUN16(VAR18, VAR49);
}
function FUN22() public payable VAR50 {}
function FUN23() public view returns(address) {
return VAR47[VAR44].VAR32;
}
function FUN24() internal returns(uint) {
uint VAR51 = uint(FUN25(VAR52.FUN26(VAR48, VAR31, FUN27(VAR53.VAR54 - 1)))) % 3;
VAR31 = VAR31.FUN4(VAR51.FUN4(2));
return VAR51;
}
function FUN28() internal returns(uint256) {
VAR35 = VAR35.FUN4(VAR22.FUN14());
VAR35 = VAR35.FUN4(VAR24.FUN14());
return VAR35.FUN4(VAR25.FUN14());
}
function FUN29() internal returns(uint) {
VAR32 = FUN24();
if(VAR42[VAR38[VAR32]] == 0) {
VAR28 = uint(FUN25(VAR52.FUN26(VAR48, VAR32, FUN27(VAR53.VAR54 - 1)))) % 2;
if(VAR32 == 0) {
if(VAR28 == 1) {
VAR33 = 2;
VAR34 = 1;
} else {
VAR33 = 1;
VAR34 = 2;
}
}
if(VAR32 == 1) {
if(VAR28 == 1) {
VAR33 = 2;
VAR34 = 0;
} else {
VAR33 = 0;
VAR34 = 2;
}
}
if(VAR32 == 2) {
if(VAR28 == 1) {
VAR33 = 1;
VAR34 = 0;
} else {
VAR33 = 0;
VAR34 = 1;
}
}
VAR32 = (VAR42[VAR38[VAR33]] == 0) ? VAR34 : VAR33;
}
return VAR32;
}
function FUN30() internal {
VAR36 = VAR35.FUN1(15).FUN2(100);
VAR37 = VAR35.FUN3(VAR36);
FUN21(VAR9, VAR36);
for (uint VAR55 = 0; VAR55 < VAR42[VAR38[VAR32]]; VAR55++) {
uint VAR56 = VAR39[VAR38[VAR32]][VAR40[VAR38[VAR32]][VAR55]].FUN1(10000).FUN2(VAR41[VAR38[VAR32]]);
FUN21(VAR40[VAR38[VAR32]][VAR55], VAR37.FUN1(VAR56).FUN2(10000));
}
}
function FUN31() internal {
VAR35 = 0;
VAR30 = 0;
VAR41[VAR38[0]] = 0;
for (uint VAR57 = 0; VAR57 < 3; VAR57++) {
for (uint VAR58 = 0; VAR58 < VAR42[VAR38[VAR57]]; VAR58++) {
VAR39[VAR38[VAR57]][VAR40[VAR38[VAR57]][VAR58]] = 0;
VAR40[VAR38[VAR57]][VAR58] = address(0x0);
}
VAR41[VAR38[VAR57]] = 0;
VAR42[VAR38[VAR57]] = 0;
}
}
function FUN32(address VAR59, uint256 VAR60) internal {
VAR44 = VAR44 + 1;
VAR47[VAR44].VAR32 =VAR59;
VAR47[VAR44].VAR46 = VAR48;
emit FUN17(VAR59, VAR60);
}
function FUN13(address VAR61, uint256 VAR49) external VAR50 {
if (VAR48 >= VAR26 || VAR30 >= VAR29) {
VAR35 = FUN28();
if(VAR35 > 0) {
VAR32 = FUN29();
FUN30();
FUN31();
FUN32(VAR38[VAR32], VAR35);
}
VAR26 = VAR26.FUN4(VAR27);
}
if (VAR39[msg.sender][VAR61] == 0) {
VAR40[msg.sender][VAR42[msg.sender]] = VAR61;
VAR42[msg.sender] = VAR42[msg.sender].FUN4(1);
VAR30 = VAR30.FUN4(1);
}
VAR39[msg.sender][VAR61] = VAR39[msg.sender][VAR61].FUN4(VAR49);
VAR41[msg.sender] = VAR41[msg.sender].FUN4(VAR49);
}
function FUN33() public {
uint256 VAR62 = VAR43[msg.sender];
VAR43[msg.sender] = 0;
msg.sender.transfer(VAR62);
emit FUN15(msg.sender, VAR62);
}
function FUN34(address VAR63, uint256 VAR64) internal {
if(VAR63 != address(VAR22) &&
VAR63 != address(VAR24) &&
VAR63 != address(VAR25))
{
if(VAR64 == uint(0)) {
if(FUN20(VAR63) != uint(0)) {
FUN33();
} else {
revert("");
}
} else {
revert("");
}
}
}
function() external payable {
FUN34(msg.sender, msg.value);
}
}
1
---------------------------------
26 0x318e210b32830f0ea4ccc453426e8efac931df6c.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract PeaqPurchase is VAR2 {
address public VAR13 = 0x24e57d774b9E2Aa4A4fbeC08C66817DcF1dAd2CF;
uint public VAR14 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR15) internal {
FUN9(VAR13, VAR15);
}
function FUN9(address VAR16, uint VAR15) internal {
require(VAR16.call.FUN10(VAR14).value(VAR15)());
}
function FUN11(uint VAR17) public onlyOwner {
VAR14 = VAR17;
}
function FUN12(EIP20Token VAR18, address VAR19, uint value) public onlyOwner {
VAR18.FUN5(VAR19, value);
}
function FUN13() public onlyOwner {
FUN9(msg.sender, address(this).VAR20);
}
}
1
---------------------------------
27 0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol
pragma VAR1 ^0.4.25;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR10);
constructor() public {
VAR7 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR11;
}
function FUN6(address VAR12) public onlyOwner {
VAR8 = VAR12;
}
function FUN7() public {
require(msg.sender == VAR8);
emit FUN5(VAR7, VAR8);
VAR7 = VAR8;
VAR8 = address(0);
}
}
contract Snip3D is  VAR6 {
using SafeMath for uint;
uint public VAR13;
mapping(address => uint256)public  VAR14;
mapping(address => uint256)public  VAR15;
mapping(address => uint256)public  VAR16;
mapping(uint256 => address)public  VAR17;
uint256 public VAR18;
mapping(address => uint256)public VAR19;
mapping(uint256 => address) public VAR20;
uint256 public  VAR21;
uint256 public  VAR22;
uint256 public VAR23;
uint256 public VAR24 = 200;
uint256 public VAR25 = 800;
uint256 public VAR26;
uint256 public VAR27;
event FUN8(address indexed VAR28 , uint256 indexed VAR17);
event FUN9(address indexed VAR28);
event FUN10(address indexed VAR28);
event FUN11(address indexed VAR28 , uint256 indexed VAR29, uint256 indexed VAR17);
constructor()
public
{
VAR26 = VAR30.FUN12();
VAR27 = 2784;
}
modifier FUN13()
{
require(VAR14[msg.sender] > 0);
VAR11;
}
HourglassInterface constant VAR31 = FUN14(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
SPASMInterface constant VAR32 = FUN15(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
Snip3dInterface public VAR30 = FUN16(0x6D534b48835701312ebc904d4b37e54D4f7D039f);
function FUN17()
view
public
returns(uint256)
{
return (VAR31.FUN18(true))  ;
}
function FUN19()
public
view
returns(address)
{
return (VAR20[VAR21]);
}
function FUN20(address VAR33)
public
view
returns( string )
{
return (VAR34[VAR33]);
}
function FUN21(address VAR33)
public
view
returns( uint256 )
{
uint256 VAR35;
if(VAR36.VAR35 - VAR19[VAR33] < VAR24)
{VAR35 = VAR24 -(VAR36.VAR35 - VAR19[VAR33]);}
return (VAR35);
}
function FUN22(address VAR33)
public
view
returns( uint256 )
{
uint256 VAR35;
if(VAR36.VAR35 - VAR19[VAR33] < VAR25)
{VAR35 = VAR25 -(VAR36.VAR35 - VAR19[VAR33]);}
return (VAR35);
}
function FUN23() external view returns(uint256){
return ( VAR31.FUN24(address(this)))  ;
}
uint256 public VAR37 = 10e18;
struct VAR38 {
uint VAR39;
uint VAR40;
}
mapping(address=>VAR38) VAR41;
mapping(address => string) public VAR34;
uint public VAR42;
uint public VAR43;
uint public VAR44;
function FUN25(address VAR45) public view returns(uint256) {
uint256 VAR46 = VAR43.FUN2(VAR41[VAR45].VAR40);
return (VAR14[VAR45] * VAR46) / VAR37;
}
modifier FUN26(address VAR45) {
uint256 VAR47 = FUN25(VAR45);
if(VAR47 > 0) {
VAR44 = VAR44.FUN2(VAR47);
VAR16[VAR45] = VAR16[VAR45].FUN1(VAR47);
}
VAR41[VAR45].VAR40 = VAR43;
VAR11;
}
function () external payable{}
function FUN27(address VAR48) public FUN26(VAR48){}
function FUN28(address VAR49, uint256 VAR29) public FUN26(msg.sender)  payable{
uint256 value = msg.value;
require(value >=  VAR29.FUN3(100 VAR50));
address sender = msg.sender;
VAR14[sender]=  VAR14[sender].FUN1(VAR29);
VAR13= VAR13.FUN1(VAR29);
VAR15[sender] = VAR15[sender].FUN1(VAR29).FUN1(VAR29);
for(uint VAR51=0; VAR51< VAR29; VAR51++)
{
uint256 VAR52 = VAR18.FUN1(VAR51);
VAR17[VAR52] = sender;
}
VAR18 += VAR51;
VAR19[sender] = VAR36.VAR35;
uint256 VAR53 = VAR29.FUN3( 5 VAR50);
VAR31.VAR54.value(VAR53)(VAR49);
if(value > VAR29.FUN3(100 VAR50)){VAR23 += value.FUN2(VAR29.FUN3(100 VAR50)) ;}
VAR23 += VAR29.FUN3(5 VAR50);
uint256 VAR55 = VAR29.FUN3(2 VAR50);
VAR32.VAR56.value(VAR55)();
emit FUN11(sender, VAR29, VAR18);
}
function FUN29(address VAR49, address VAR57, uint256 VAR29) public FUN26(msg.sender)  payable{
uint256 value = msg.value;
require(value >=  VAR29.FUN3(100 VAR50));
address sender = msg.sender;
VAR14[sender]=  VAR14[sender].FUN1(VAR29);
VAR13= VAR13.FUN1(VAR29);
VAR15[sender] = VAR15[sender].FUN1(VAR29).FUN1(VAR29);
for(uint VAR51=0; VAR51< VAR29; VAR51++)
{
uint256 VAR52 = VAR18.FUN1(VAR51);
VAR17[VAR52] = sender;
}
VAR18 += VAR51;
VAR19[sender] = VAR36.VAR35;
uint256 VAR53 = VAR29.FUN3( 5 VAR50);
VAR31.VAR54.value(VAR53)(VAR49);
if(value > VAR29.FUN3(100 VAR50)){VAR23 += value.FUN2(VAR29.FUN3(100 VAR50)) ;}
VAR23 += VAR29.FUN3(5 VAR50);
uint256 VAR55 = VAR29.FUN3(1 VAR50);
VAR32.VAR56.value(VAR55)();
VAR16[VAR57] = VAR16[VAR57].FUN1(VAR29.FUN3(1 VAR50));
emit FUN11(sender, VAR29, VAR18);
}
function FUN30() public FUN13() {
address sender = msg.sender;
require(VAR36.VAR35 > VAR19[sender] + VAR24);
require(VAR15[sender] > 0);
uint256 VAR58 = (VAR36.VAR35.FUN2(VAR19[sender])) % 200;
uint256 VAR59 = uint256 (FUN31(VAR36.VAR35.FUN2(VAR58))) % VAR18;
address VAR60 = VAR17[VAR59];
if(sender == VAR60)
{
VAR59 = uint256 (FUN31(VAR36.VAR35.FUN2(VAR58).FUN1(1))) % VAR18;
VAR60 = VAR17[VAR59];
}
FUN27(VAR60);
VAR14[VAR60]--;
VAR13--;
VAR15[sender]--;
uint256 VAR61 = VAR18.FUN2(1);
VAR17[VAR59] = VAR17[VAR61];
VAR18--;
VAR19[sender] = VAR36.VAR35;
FUN32(VAR60);
VAR62[VAR60] += 0.1 VAR63;
uint256 VAR29 = 88 VAR50;
VAR43 = VAR43.FUN1(VAR29.FUN3(VAR37).FUN4(VAR13));
VAR44 = VAR44.FUN1(VAR29);
emit FUN9(sender);
emit FUN8(VAR60, VAR59);
}
function FUN33(uint256 VAR64) public FUN13() {
address sender = msg.sender;
require(VAR64 <= VAR18 && VAR64 > 0);
require(VAR36.VAR35 > VAR19[sender] + VAR25);
require(VAR15[sender] > 0);
if(VAR64 == VAR18){VAR64 = 0;}
address VAR60 = VAR17[VAR64];
FUN27(VAR60);
VAR14[VAR60]--;
VAR13--;
VAR15[sender]--;
uint256 VAR61 = VAR18.FUN2(1);
VAR17[VAR64] = VAR17[VAR61];
VAR18--;
VAR19[sender] = VAR36.VAR35;
FUN32(VAR60);
VAR62[VAR60] += 0.1 VAR63;
uint256 VAR29 = 88 VAR50;
VAR43 = VAR43.FUN1(VAR29.FUN3(VAR37).FUN4(VAR13));
VAR44 = VAR44.FUN1(VAR29);
emit FUN10(sender);
emit FUN8(VAR60, VAR64);
}
function FUN34 ()public
{
require(VAR23 > 0.00001 VAR63);
uint256 VAR29 = VAR23;
VAR23 = 0;
VAR65 = VAR65.FUN1(VAR29.FUN3(VAR37).FUN4(VAR66));
VAR67 = VAR67.FUN1(VAR29);
}
function FUN35() public  payable {
uint256 VAR29 = msg.value;
uint256 VAR68 = VAR29.FUN4(100);
uint256 VAR69 = VAR29.FUN2(VAR68);
VAR43 = VAR43.FUN1(VAR69.FUN3(VAR37).FUN4(VAR13));
VAR44 = VAR44.FUN1(VAR69);
}
function FUN36(address VAR70) public {
require(VAR16[VAR70] > 0);
uint256 value = VAR16[VAR70];
VAR16[VAR70] = 0;
VAR70.transfer(value);
}
function FUN37(string VAR71) public payable{
require(msg.value >= 1  VAR50);
VAR34[msg.sender] = VAR71;
VAR23 += msg.value;
}
function FUN38() public{
uint256 VAR72 = FUN17();
require(VAR72 > 0);
VAR31.FUN39();
uint256 VAR68 = VAR72.FUN4(100);
uint256 VAR69 = VAR72.FUN2(VAR68);
VAR32.VAR56.value(VAR68)();
VAR23 = VAR23.FUN1(VAR69);
}
function FUN40(uint256 VAR73) onlyOwner public{
uint256 VAR74 = VAR26;
for(uint VAR51=0; VAR51< VAR73; VAR51++)
{
address VAR75 = VAR30.FUN41(VAR74 + VAR51);
VAR51++;
VAR62[VAR75] = VAR62[VAR75].FUN1(0.1 VAR63);
}
VAR26 += VAR51;
VAR66 = VAR66.FUN1(VAR51.FUN3(0.1 VAR63));
}
mapping(address => uint256) public VAR62;
uint256 public VAR66;
mapping(address=>VAR38) public VAR76;
uint public VAR77;
uint public VAR65;
uint public VAR67;
function FUN42(address VAR45) public view returns(uint256) {
uint256 VAR78 = VAR65.FUN2(VAR76[VAR45].VAR40);
return (VAR62[VAR45] * VAR78) / VAR37;
}
modifier FUN43(address VAR45) {
uint256 VAR47 = FUN42(VAR45);
if(VAR47 > VAR62[VAR45]){VAR62[VAR45] = VAR47;}
if(VAR47 > 0 ) {
VAR67 = VAR67.FUN2(VAR47);
VAR16[VAR45] = VAR16[VAR45].FUN1(VAR47);
VAR62[VAR45] = VAR62[VAR45].FUN2(VAR47);
VAR66 = VAR66.FUN2(VAR47);
}
VAR76[VAR45].VAR40 = VAR65;
VAR11;
}
function FUN32(address VAR79) public FUN43(VAR79){}
function FUN44() public  payable {
uint256 VAR29 = msg.value;
VAR65 = VAR65.FUN1(VAR29.FUN3(VAR37).FUN4(VAR66));
VAR67 = VAR67.FUN1(VAR29);
}
function FUN45 ()public
{
uint256 VAR80 = VAR31.FUN18(true);
require(VAR80 > 0);
uint256 VAR68 = VAR80.FUN4(100);
VAR31.FUN39();
VAR32.VAR56.value(VAR68.FUN3(5))();
VAR23 = VAR23.FUN1(VAR68.FUN3(95));
}
}
interface VAR81  {
function() payable external;
function FUN46(address VAR82) payable external returns(uint256);
function FUN47(uint256 VAR83) external;
function FUN48() external;
function FUN39() external;
function FUN49() external;
function FUN18(bool VAR84) external view returns(uint256);
function FUN50(address VAR82) external view returns(uint256);
function FUN24(address VAR82) external view returns(uint256);
function transfer(address VAR85, uint256 VAR83) external returns(bool);
function FUN51() external view returns(uint256);
}
interface VAR86 {
function FUN41(uint256 VAR87) external view returns(address);
function FUN12() external view returns(uint256);
function FUN52() external view returns(uint256);
}
interface VAR88  {
function() payable external;
function FUN35() external  payable;
}
1
---------------------------------
28 0x31fac99f7a2740e98a0cc0ef2d24a83c4276c7bd.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
//
//
struct VAR3 {
address VAR4;
uint64 VAR5;
uint32 VAR6;
uint32 VAR7;
uint32 VAR8;
bool VAR9;
bytes23 VAR10;
}
struct VAR11 {
address VAR12;
uint64 VAR13;
uint64 VAR14;
int64 VAR15;
uint32 VAR16;
}
Vars VAR17;
Settings VAR18;
uint constant VAR19 = 1;
event FUN1(uint VAR20, string msg);
event FUN2(uint VAR20, uint VAR21);
event FUN3(uint VAR20, address indexed VAR22, bytes23 VAR10, address indexed VAR23, uint VAR24);
event FUN4(uint VAR20, string msg, address indexed VAR25, uint VAR26);
event FUN5(uint VAR20, string msg, address indexed VAR25, uint VAR26);
event FUN6(uint VAR20, address indexed VAR27, address indexed VAR25, uint VAR26, uint VAR28);
event FUN7(uint VAR20, address indexed VAR27, address indexed VAR25, uint VAR26, uint VAR28);
event FUN8(uint VAR20, address indexed VAR12, uint VAR26);
constructor(
address VAR29,
uint VAR30,
uint VAR31,
int VAR32,
uint VAR33,
uint VAR34
)
public
payable
{
require(VAR30 >= 1e9);
require(VAR30 < 1e6 * 1e18);
require(VAR30 % 1e9 == 0);
require(VAR31 >= 1e6);
require(VAR31 < 1e6 * 1e18);
require(VAR31 % 1e9 == 0);
require(VAR32 <= int(VAR31));
require(VAR32 >= -1*int(VAR30));
require(VAR32 % 1e9 == 0);
require(VAR33 >= 1);
require(VAR34 >= 1);
require(msg.value == VAR30);
VAR18.VAR12 = VAR29;
VAR18.VAR13 = FUN9(VAR30 / 1e9);
VAR18.VAR14 = FUN9(VAR31 / 1e9);
VAR18.VAR15 = FUN10(VAR32 / 1e9);
VAR18.VAR16 = FUN11(VAR33);
VAR17.VAR5 = VAR18.VAR13;
VAR17.VAR4 = VAR29;
VAR17.VAR8 = FUN11(VAR35.VAR36);
VAR17.VAR7 = FUN11(VAR35.VAR36 + VAR34);
emit FUN2(VAR37, VAR34);
}
//
//
function()
public
payable
{
FUN12(0);
}
function FUN12(bytes23 VAR38)
public
payable
{
if (FUN13())
return FUN14("");
if (msg.sender == VAR17.VAR4)
return FUN14("");
if (msg.value != FUN15())
return FUN14("");
int VAR39 = int(VAR17.VAR5) + VAR18.VAR15;
uint32 VAR40 = FUN11(VAR35.VAR36) + VAR18.VAR16;
uint32 VAR41 = VAR17.VAR6 + 1;
address VAR42 = VAR17.VAR4;
bool VAR43 = (VAR35.VAR36 != VAR17.VAR8);
if (VAR39 < 0)
return FUN14("");
bool VAR44;
if (!VAR43) {
VAR44 = VAR42.FUN16(msg.value);
}
if (VAR43) {
VAR17.VAR4 = msg.sender;
VAR17.VAR6 = VAR41;
VAR17.VAR5 = FUN9(VAR39);
VAR17.VAR7 = VAR40;
VAR17.VAR8 = FUN11(VAR35.VAR36);
VAR17.VAR10 = VAR38;
}
if (!VAR43 && VAR44){
VAR17.VAR4 = msg.sender;
VAR17.VAR10 = VAR38;
}
if (!VAR43 && !VAR44){
VAR17.VAR4 = msg.sender;
VAR17.VAR5 = FUN9(VAR39);
VAR17.VAR6 = VAR41;
VAR17.VAR10 = VAR38;
}
if (!VAR43){
if (VAR44)
emit FUN4(VAR37, "", VAR42, msg.value);
else
emit FUN5(VAR37, "", VAR42, msg.value);
}
emit FUN3(VAR37, msg.sender, VAR38, VAR42, msg.value);
}
function FUN14(string VAR45)
private
{
require(msg.sender.call.value(msg.value)());
emit FUN4(VAR37, VAR45, msg.sender, msg.value);
}
function FUN17(uint VAR46)
public
returns (bool VAR47, uint VAR48)
{
if (!FUN13()) {
emit FUN1(VAR37, "");
return (false, 0);
}
if (VAR17.VAR9) {
emit FUN1(VAR37, "");
return (false, 0);
}
address VAR49 = VAR17.VAR4;
uint VAR50 = FUN18();
bool VAR51 = false;
VAR17.VAR9 = true;
if (VAR46 == 0) {
VAR51 = VAR49.call.value(VAR50)();
} else {
VAR51 = VAR49.call.value(VAR50).FUN19(VAR46)();
}
if (VAR51) {
emit FUN6({
VAR20: VAR37,
VAR27: msg.sender,
VAR25: VAR49,
VAR26: VAR50,
VAR28: VAR46
});
return (true, VAR50);
} else {
VAR17.VAR9 = false;
emit FUN7({
VAR20: VAR37,
VAR27: msg.sender,
VAR25: VAR49,
VAR26: VAR50,
VAR28: VAR46
});
return (false, 0);
}
}
function FUN20()
public
returns (uint VAR52)
{
VAR52 = FUN21();
if (VAR52 == 0) return;
require(VAR18.VAR12.call.value(VAR52)());
emit FUN8(VAR37, VAR18.VAR12, VAR52);
}
function FUN22() public view returns (address) {
return VAR17.VAR4;
}
function FUN18() public view returns (uint) {
return uint(VAR17.VAR5) * 1e9;
}
function FUN23() public view returns (uint) {
return VAR17.VAR6;
}
function FUN24() public view returns (uint) {
return VAR17.VAR7;
}
function FUN25() public view returns (uint) {
return VAR17.VAR8;
}
function FUN26() public view returns (bool) {
return VAR17.VAR9;
}
function FUN27() public view returns (VAR53) {
return VAR17.VAR10;
}
function FUN28() public view returns (address) {
return VAR18.VAR12;
}
function FUN29() public view returns (uint){
return uint(VAR18.VAR13) * 1e9;
}
function FUN15() public view returns (uint) {
return uint(VAR18.VAR14) * 1e9;
}
function FUN30() public view returns (int) {
return int(VAR18.VAR15) * 1e9;
}
function FUN31() public view returns (uint) {
return VAR18.VAR16;
}
function FUN13() public view returns (bool) {
return VAR35.VAR36 > VAR17.VAR7;
}
function FUN32() public view returns (uint) {
if (FUN13()) return 0;
return (VAR17.VAR7 - VAR35.VAR36) + 1;
}
function FUN21() public view returns (uint) {
uint VAR54 = address(this).VAR55;
return VAR17.VAR9 ? VAR54 : VAR54 - FUN18();
}
function FUN33() public view returns (uint) {
int VAR56 = int(VAR18.VAR14) - VAR18.VAR15;
return uint(VAR56 * VAR17.VAR6 * 1e9);
}
}
1
---------------------------------
29 0x325f89386b72087530440e0bceb8490d78b47f21.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
function FUN1(address VAR3) public constant returns (uint256 VAR4);
function transfer(address VAR5, uint256 VAR6) public returns (bool VAR7);
function FUN2(address VAR8, address VAR5, uint256 VAR6) public returns (bool VAR7);
function FUN3(address VAR9, uint256 VAR6) public returns (bool VAR7);
function FUN4(address VAR3, address VAR9) public constant returns (uint256 VAR10);
event Transfer(address indexed VAR8, address indexed VAR5, uint256 VAR6);
event FUN5(address indexed VAR3, address indexed VAR9, uint256 VAR6);
uint public VAR11;
string public VAR12;
}
contract nonNativeToken_Interface is VAR2 {
function FUN6(address VAR13, uint256 VAR14) public returns (bool VAR7);
function FUN7(address VAR15, uint256 VAR14) public returns (bool VAR7);
}
contract EthWrapper_Interface is VAR16 {
function FUN8() public payable;
}
library VAR17 {
function FUN9(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
uint256 VAR20 = VAR18 * VAR19;
assert(VAR18 == 0 || VAR20 / VAR18 == VAR19);
return VAR20;
}
function FUN10(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
assert(VAR19 > 0);
uint256 VAR20 = VAR18 / VAR19;
return VAR20;
}
function FUN11(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
assert(VAR19 <= VAR18);
return VAR18 - VAR19;
}
function FUN12(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
uint256 VAR20 = VAR18 + VAR19;
assert(VAR20 >= VAR18);
return VAR20;
}
}
contract ERC20_Token is VAR2{
using SafeMath for uint256;
mapping(address => uint256) VAR21;
mapping (address => mapping (address => uint256)) VAR22;
uint256 public VAR23;
uint256 public VAR11;
string public VAR12;
string public VAR24;
function FUN13(string VAR25,string VAR26,uint256 VAR27) public{
VAR12=VAR25;
VAR24=VAR26;
VAR11=VAR27;
}
function transfer(address VAR5, uint256 VAR6) public returns (bool VAR7) {
if (VAR21[msg.sender] >= VAR6) {
VAR21[msg.sender] = VAR21[msg.sender].FUN11(VAR6);
VAR21[VAR5] = VAR21[VAR5].FUN12(VAR6);
return true;
}else return false;
}
function FUN2(address VAR8, address VAR5, uint256 VAR6) public returns (bool VAR7) {
if (VAR21[VAR8] >= VAR6 && VAR22[VAR8][msg.sender] >= VAR6) {
VAR21[VAR8] = VAR21[VAR8].FUN11(VAR6);
VAR21[VAR5] = VAR21[VAR5].FUN12(VAR6);
VAR22[VAR8][msg.sender] = VAR22[VAR8][msg.sender].FUN11(VAR6);
Transfer(VAR8, VAR5, VAR6);
return true;
}else return false;
}
function FUN1(address VAR3) public view returns (uint256 VAR4) {
return VAR21[VAR3];
}
function FUN3(address VAR9, uint256 VAR6) public returns (bool VAR7) {
VAR22[msg.sender][VAR9] = VAR6;
FUN5(msg.sender, VAR9, VAR6);
return true;
}
function FUN4(address VAR3, address VAR9) public view returns (uint256 VAR10) {
return VAR22[VAR3][VAR9];
}
}
contract nonNativeToken is VAR28, VAR16{
address public VAR29;
modifier VAR30{
require(msg.sender==VAR29);
VAR31;
}
function FUN14(string VAR25, string VAR26, uint256 VAR27) FUN13(VAR25, VAR26, VAR27) public{
VAR29=msg.sender;
}
function FUN6(address VAR13, uint256 VAR14) public onlyExchange returns (bool VAR7){
VAR21[VAR13] = VAR21[VAR13].FUN12(VAR14);
VAR23 = VAR23.FUN12(VAR14);
return true;
}
function FUN7(address VAR15, uint256 VAR14) public onlyExchange returns (bool VAR7){
if(VAR21[VAR15]>=VAR14) {
VAR21[VAR15] = VAR21[VAR15].FUN11(VAR14);
VAR23 = VAR23.FUN11(VAR14);
return true;
}
return false;
}
function FUN2(address VAR8, address VAR5, uint256 VAR6) public returns (bool VAR7) {
if(VAR21[VAR8] >= VAR6) {
if(msg.sender == VAR29) {
VAR21[VAR8] = VAR21[VAR8].FUN11(VAR6);
VAR21[VAR5] = VAR21[VAR5].FUN12(VAR6);
Transfer(VAR8, VAR5, VAR6);
return true;
}else if(VAR22[VAR8][msg.sender] >= VAR6) {
VAR21[VAR8] = VAR21[VAR8].FUN11(VAR6);
VAR21[VAR5] = VAR21[VAR5].FUN12(VAR6);
VAR22[VAR8][msg.sender] = VAR22[VAR8][msg.sender].FUN11(VAR6);
Transfer(VAR8, VAR5, VAR6);
return true;
}
}
return false;
}
function FUN4(address VAR3, address VAR9) public view returns (uint256 VAR10) {
if(VAR9==VAR29){
return VAR21[VAR3];
}else{
return VAR22[VAR3][VAR9];
}
}
}
contract EthWrapper is VAR32, VAR33{
bool VAR34;
function FUN15(string VAR25, string VAR26, uint256 VAR27) FUN14(VAR25, VAR26, VAR27) public{
VAR34=false;
}
modifier FUN16(){
require(VAR34);
VAR31;
}
function FUN8() public payable VAR30{
require(!VAR34);
VAR34=true;
}
function FUN17(uint VAR35) public VAR36{
require(VAR21[msg.sender]>=VAR35);
VAR21[msg.sender]=VAR21[msg.sender].FUN11(VAR35);
msg.sender.transfer(VAR35);
}
}
contract VAR37 {
mapping(address => uint8) public VAR38;
event FUN18(address VAR39,uint8 VAR40);
event FUN19(address VAR39, uint8 VAR41, uint8 VAR42);
event FUN20(address VAR39);
modifier onlyAdmin(uint8 VAR43){
require(VAR38[msg.sender]>=VAR43);
VAR31;
}
function FUN21() public{
VAR38[msg.sender]=2;
}
function FUN22(address VAR44, uint8 VAR45) public onlyAdmin(2) {
require(VAR38[VAR44] == 0);
require(VAR45 > 0);
FUN18(VAR44,VAR45);
VAR38[VAR44]=VAR45;
}
function FUN23(address VAR44, uint8 VAR45) public onlyAdmin(2) {
require(VAR38[VAR44] > 0);
require(VAR45 > 0);
FUN19(VAR44, VAR38[VAR44], VAR45);
VAR38[VAR44]=VAR45;
}
function FUN24(address VAR44) public onlyAdmin(2) {
require(VAR38[VAR44] > 0);
FUN20(VAR44);
VAR38[VAR44]=0;
}
}
contract Managable is VAR37 {
uint public VAR46;
address public VAR47;
mapping (string => address) VAR48;
event FUN25(uint256 VAR8, uint256 VAR5);
event FUN26(address VAR8, address VAR5);
event FUN27(address VAR49, string VAR25, string VAR26);
event FUN28(string VAR50,address VAR5,uint256 VAR35);
event FUN29(string VAR50,address VAR8,uint256 VAR35);
function FUN30() FUN21() public {
VAR46=10;
VAR47=msg.sender;
}
function FUN31(address VAR51) public onlyAdmin(2) {
FUN26(VAR47, VAR51);
VAR47=VAR51;
}
function FUN32(uint VAR51) public onlyAdmin(2) {
require(VAR51 < 100);
FUN25(VAR46, VAR51);
VAR46=VAR51;
}
function FUN33(string VAR25,string VAR26,uint256 VAR27) public onlyAdmin(2) returns(address VAR52){
address VAR53 = VAR54 FUN14(VAR25, VAR26, VAR27);
VAR48[VAR26]=VAR53;
FUN27(VAR53, VAR25, VAR26);
return VAR53;
}
function FUN34(string VAR26,address VAR5,uint256 VAR35) public onlyAdmin(2){
require(VAR48[VAR26] != address(0));
FUN35(VAR48[VAR26]).FUN6(VAR5, VAR35);
FUN28(VAR26, VAR5, VAR35);
}
function FUN36(string VAR26,address VAR8,uint256 VAR35) public onlyAdmin(2){
require(VAR48[VAR26] != address(0));
FUN35(VAR48[VAR26]).FUN7(VAR8, VAR35);
FUN29(VAR26, VAR8, VAR35);
}
function FUN37(string VAR26) public constant returns(address VAR52){
return VAR48[VAR26];
}
}
contract EtherStore is VAR55{
bool public VAR56;
address public VAR57;
modifier VAR58{
require(VAR56);
VAR31;
}
modifier VAR59{
require(!VAR56);
VAR31;
FUN38(VAR57);
VAR56=true;
}
event FUN38(address VAR60);
event FUN39(address VAR8, address VAR5);
event FUN40(address VAR5, uint256 VAR35);
event FUN41(address VAR8, uint256 VAR35);
function FUN42() FUN30() public {
VAR56=false;
}
function FUN43(address VAR60) public onlyAdmin(2) VAR59{
VAR57=VAR60;
}
function FUN44() public onlyAdmin(2) VAR59{
VAR57 = VAR54 FUN15('', '', 18);
}
function FUN45(address VAR60) public onlyAdmin(2) VAR58{
FUN46(VAR57).VAR61.value(this.VAR4)();
FUN39(VAR57, VAR60);
VAR57 = VAR60;
}
function FUN47() public payable VAR58{
require(FUN46(VAR57).FUN6(msg.sender, msg.value));
FUN40(msg.sender,msg.value);
}
function FUN48(address VAR5) public payable VAR58{
require(FUN46(VAR57).FUN6(VAR5, msg.value));
FUN40(VAR5,msg.value);
}
function () public payable {
FUN47();
}
function FUN49(uint VAR35) public VAR58{
require(FUN46(VAR57).FUN1(msg.sender) >= VAR35);
require(FUN46(VAR57).FUN7(msg.sender, VAR35));
msg.sender.transfer(VAR35);
FUN41(msg.sender, VAR35);
}
function FUN50(address VAR5,uint256 VAR35) public VAR58{
require(FUN46(VAR57).FUN1(msg.sender) >= VAR35);
require(FUN46(VAR57).FUN7(msg.sender, VAR35));
VAR5.transfer(VAR35);
FUN41(VAR5, VAR35);
}
}
contract Mergex is VAR62{
using SafeMath for uint256;
mapping(address => mapping(bytes32 => uint256)) public VAR63;
event FUN51(bytes32 VAR64, address VAR65, address VAR66, uint VAR67, uint VAR68);
event FUN52(bytes32 VAR64);
event FUN53(bytes32 VAR64);
function FUN54() FUN42() public {
}
function FUN55(address VAR69, address VAR70, uint256 VAR14) internal constant returns (bool VAR22){
return FUN56(VAR69).FUN4(VAR70,address(this)) >= VAR14;
}
function FUN57(address VAR70, bytes32 VAR64) public view returns (uint VAR71){
return VAR63[VAR70][VAR64];
}
function FUN58(address VAR70, address VAR65, address VAR66, uint VAR72, uint VAR67, uint VAR68, uint VAR73, uint VAR74, uint8 VAR75, bytes32 VAR76, bytes32 VAR77) public{
bytes32 VAR64=FUN59('',VAR70,VAR65,VAR66,VAR67,VAR68,VAR73,VAR74);
if(FUN60(VAR70,VAR64,VAR73,VAR72,VAR67,VAR75,VAR76,VAR77)){
if(!FUN61(VAR64, msg.sender, VAR70, VAR65, VAR66, VAR72, VAR67, VAR68)){
revert();
}
VAR63[VAR70][VAR64]=VAR63[VAR70][VAR64].FUN12(VAR72);
if(VAR63[VAR70][VAR64] == VAR67){
FUN52(VAR64);
}
}
}
function FUN60(address VAR70, bytes32 VAR64, uint VAR73, uint VAR72, uint VAR78, uint8 VAR75, bytes32 VAR76, bytes32 VAR77) internal constant returns(bool VAR7){
require(VAR63[VAR70][VAR64].FUN12(VAR72) <= VAR78);
require(VAR79.VAR80<=VAR73);
require(FUN62(FUN63("",VAR64),VAR75,VAR76,VAR77)==VAR70);
return true;
}
function FUN64(address VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR73, uint VAR74, uint8 VAR75, bytes32 VAR76, bytes32 VAR77) public{
bytes32 VAR64=FUN59('', msg.sender, VAR65, VAR66, VAR67, VAR68, VAR73, VAR74);
require(VAR79.VAR80<=VAR73);
require(FUN62(FUN63("",VAR64),VAR75,VAR76,VAR77)==msg.sender);
FUN53(VAR64);
VAR63[msg.sender][VAR64]=VAR67;
}
function FUN61(bytes32 VAR64, address VAR81,address VAR82,address VAR65,address VAR66,uint VAR83,uint VAR67,uint VAR68) internal returns(bool VAR7){
uint VAR84=VAR68.FUN9(VAR83).FUN10(VAR67);
require(FUN56(VAR65).FUN1(VAR81)>=VAR83);
require(FUN56(VAR66).FUN1(VAR82)>=VAR84);
if(!FUN55(VAR65, VAR81, VAR83))return false;
if(!FUN55(VAR66, VAR82, VAR84))return false;
uint VAR85=VAR83.FUN9(VAR46).FUN10(10000);
uint VAR86=VAR84.FUN9(VAR46).FUN10(10000);
uint VAR87=VAR83.FUN11(VAR85);
uint VAR88=VAR84.FUN11(VAR86);
if(!FUN56(VAR65).FUN2(VAR81,VAR82,VAR87))return false;
if(!FUN56(VAR66).FUN2(VAR82,VAR81,VAR88))return false;
if(!FUN56(VAR65).FUN2(VAR81,VAR47,VAR85))return false;
if(!FUN56(VAR66).FUN2(VAR82,VAR47,VAR86))return false;
FUN51(VAR64, VAR65, VAR66, VAR83, VAR84);
return true;
}
}
1
---------------------------------
30 0x32c4ed7b88cfb37cb96b9239d8f9307eb11e85bc.sol
pragma VAR1 ^0.4.20;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) payable returns (bytes32 VAR7);
function FUN7(string VAR5) returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) returns (uint VAR12);
function FUN8(string VAR14);
function FUN9(byte VAR15);
function FUN10(bytes32 VAR16);
function FUN11(uint VAR17);
function FUN12() returns(bytes32);
}
contract VAR18 {
function FUN13() returns (address VAR19);
}
contract VAR20 {
uint constant VAR21 = 60*60*24;
uint constant VAR22 = 60*60*24*7;
uint constant VAR23 = 60*60*24*30;
byte constant VAR24 = 0x00;
byte constant VAR25 = 0x10;
byte constant VAR26 = 0x20;
byte constant VAR27 = 0x30;
byte constant VAR28 = 0xF0;
byte constant VAR29 = 0x01;
uint8 constant VAR30 = 0;
uint8 constant VAR31 = 1;
uint8 constant VAR32 = 2;
uint8 constant VAR33 = 2;
uint8 constant VAR34 = 161;
OraclizeAddrResolverI VAR35;
OraclizeI VAR36;
modifier VAR37 {
if((address(VAR35)==0)||(FUN14(address(VAR35))==0)) FUN15(VAR30);
VAR36 = FUN16(VAR35.FUN13());
VAR38;
}
modifier FUN17(string VAR39){
VAR36 = FUN16(VAR35.FUN13());
VAR36.FUN8(VAR39);
VAR38;
}
function FUN15(uint8 VAR40) internal returns(bool){
if (FUN14(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR35 = FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN19("");
return true;
}
if (FUN14(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR35 = FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN19("");
return true;
}
if (FUN14(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR35 = FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN19("");
return true;
}
if (FUN14(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR35 = FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN19("");
return true;
}
if (FUN14(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR35 = FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN14(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR35 = FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN14(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR35 = FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN20(bytes32 VAR41, string VAR42) {
FUN20(VAR41, VAR42, VAR43 bytes(0));
}
function FUN20(bytes32 VAR41, string VAR42, bytes VAR44) {
}
function FUN21(string VAR39) oraclizeAPI internal {
VAR36.FUN8(VAR39);
}
function FUN22(string VAR45) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45);
}
function FUN22(string VAR45, uint VAR13) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45, VAR13);
}
function FUN23(string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(0, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(VAR53, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(VAR53, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(0, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(0, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(VAR53, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(VAR53, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(0, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN26() oraclizeAPI internal returns (address){
return VAR36.FUN27();
}
function FUN28(byte VAR64) oraclizeAPI internal {
return VAR36.FUN9(VAR64);
}
function FUN29(uint VAR65) oraclizeAPI internal {
return VAR36.FUN11(VAR65);
}
function FUN30(bytes32 VAR66) oraclizeAPI internal {
return VAR36.FUN10(VAR66);
}
function FUN31() oraclizeAPI internal returns (bytes32){
return VAR36.FUN12();
}
function FUN14(address VAR19) constant internal returns(uint VAR67) {
VAR68 {
VAR67 := FUN32(VAR19)
}
}
function FUN33(string VAR69) internal returns (address){
bytes memory VAR70 = bytes(VAR69);
uint160 VAR71 = 0;
uint160 VAR72;
uint160 VAR73;
for (uint VAR74=2; VAR74<2+2*20; VAR74+=2){
VAR71 *= 256;
VAR72 = FUN34(VAR70[VAR74]);
VAR73 = FUN34(VAR70[VAR74+1]);
if ((VAR72 >= 97)&&(VAR72 <= 102)) VAR72 -= 87;
else if ((VAR72 >= 65)&&(VAR72 <= 70)) VAR72 -= 55;
else if ((VAR72 >= 48)&&(VAR72 <= 57)) VAR72 -= 48;
if ((VAR73 >= 97)&&(VAR73 <= 102)) VAR73 -= 87;
else if ((VAR73 >= 65)&&(VAR73 <= 70)) VAR73 -= 55;
else if ((VAR73 >= 48)&&(VAR73 <= 57)) VAR73 -= 48;
VAR71 += (VAR72*16+VAR73);
}
return address(VAR71);
}
function FUN35(string VAR69, string VAR75) internal returns (int) {
bytes memory VAR76 = bytes(VAR69);
bytes memory VAR77 = bytes(VAR75);
uint VAR78 = VAR76.VAR79;
if (VAR77.VAR79 < VAR78) VAR78 = VAR77.VAR79;
for (uint VAR74 = 0; VAR74 < VAR78; VAR74 ++)
if (VAR76[VAR74] < VAR77[VAR74])
return -1;
else if (VAR76[VAR74] > VAR77[VAR74])
return 1;
if (VAR76.VAR79 < VAR77.VAR79)
return -1;
else if (VAR76.VAR79 > VAR77.VAR79)
return 1;
else
return 0;
}
function FUN36(string VAR80, string VAR81) internal returns (int) {
bytes memory VAR82 = bytes(VAR80);
bytes memory VAR83 = bytes(VAR81);
if(VAR82.VAR79 < 1 || VAR83.VAR79 < 1 || (VAR83.VAR79 > VAR82.VAR79))
return -1;
else if(VAR82.VAR79 > (2**128 -1))
return -1;
else
{
uint VAR84 = 0;
for (uint VAR74 = 0; VAR74 < VAR82.VAR79; VAR74 ++)
{
if (VAR82[VAR74] == VAR83[0])
{
VAR84 = 1;
while(VAR84 < VAR83.VAR79 && (VAR74 + VAR84) < VAR82.VAR79 && VAR82[VAR74 + VAR84] == VAR83[VAR84])
{
VAR84++;
}
if(VAR84 == VAR83.VAR79)
return int(VAR74);
}
}
return -1;
}
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86, string VAR87) internal returns (string) {
bytes memory VAR88 = bytes(VAR69);
bytes memory VAR89 = bytes(VAR75);
bytes memory VAR90 = bytes(VAR85);
bytes memory VAR91 = bytes(VAR86);
bytes memory VAR92 = bytes(VAR87);
string memory VAR93 = VAR43 string(VAR88.VAR79 + VAR89.VAR79 + VAR90.VAR79 + VAR91.VAR79 + VAR92.VAR79);
bytes memory VAR94 = bytes(VAR93);
uint VAR95 = 0;
for (uint VAR74 = 0; VAR74 < VAR88.VAR79; VAR74++) VAR94[VAR95++] = VAR88[VAR74];
for (VAR74 = 0; VAR74 < VAR89.VAR79; VAR74++) VAR94[VAR95++] = VAR89[VAR74];
for (VAR74 = 0; VAR74 < VAR90.VAR79; VAR74++) VAR94[VAR95++] = VAR90[VAR74];
for (VAR74 = 0; VAR74 < VAR91.VAR79; VAR74++) VAR94[VAR95++] = VAR91[VAR74];
for (VAR74 = 0; VAR74 < VAR92.VAR79; VAR74++) VAR94[VAR95++] = VAR92[VAR74];
return string(VAR94);
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, VAR86, "");
}
function FUN37(string VAR69, string VAR75, string VAR85) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, "", "");
}
function FUN37(string VAR69, string VAR75) internal returns (string) {
return FUN37(VAR69, VAR75, "", "", "");
}
function FUN38(string VAR69) internal returns (uint) {
return FUN38(VAR69, 0);
}
function FUN38(string VAR69, uint VAR75) internal returns (uint) {
bytes memory VAR96 = bytes(VAR69);
uint VAR97 = 0;
bool VAR98 = false;
for (uint VAR74=0; VAR74<VAR96.VAR79; VAR74++){
if ((VAR96[VAR74] >= 48)&&(VAR96[VAR74] <= 57)){
if (VAR98){
if (VAR75 == 0) break;
else VAR75--;
}
VAR97 *= 10;
VAR97 += uint(VAR96[VAR74]) - 48;
} else if (VAR96[VAR74] == 46) VAR98 = true;
}
if (VAR75 > 0) VAR97 *= 10**VAR75;
return VAR97;
}
function FUN39(uint VAR74) internal returns (string){
if (VAR74 == 0) return "";
uint VAR99 = VAR74;
uint VAR100;
while (VAR99 != 0){
VAR100++;
VAR99 /= 10;
}
bytes memory VAR101 = VAR43 bytes(VAR100);
uint VAR95 = VAR100 - 1;
while (VAR74 != 0){
VAR101[VAR95--] = FUN40(48 + VAR74 % 10);
VAR74 /= 10;
}
return string(VAR101);
}
function FUN24(string[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
function FUN25(bytes[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
string VAR112;
function FUN19(string VAR113) internal {
VAR112 = VAR113;
}
function FUN41() internal returns (string) {
return VAR112;
}
function FUN42(uint VAR114, uint VAR115, uint VAR116) internal returns (bytes32){
if ((VAR115 == 0)||(VAR115 > 32)) throw;
bytes memory VAR117 = VAR43 bytes(1);
VAR117[0] = FUN40(VAR115);
bytes memory VAR118 = VAR43 bytes(32);
bytes memory VAR119 = VAR43 bytes(32);
bytes32 VAR120 = FUN31();
VAR68 {
FUN43(VAR118, 0x20)
FUN43(FUN44(VAR118, 0x20), FUN45(FUN46(FUN47(VAR121, 1)), FUN45(VAR122, VAR53)))
FUN43(VAR119, 0x20)
FUN43(FUN44(VAR119, 0x20), VAR120)
}
bytes[3] memory VAR60 = [VAR118, VAR117, VAR119];
bytes32 VAR123 = FUN23(VAR114, "", VAR60, VAR116);
FUN48(VAR123, FUN49(FUN50(VAR114), VAR60[1], FUN51(VAR60[0]), VAR60[2]));
return VAR123;
}
function FUN48(bytes32 VAR123, bytes32 VAR124) internal {
VAR125[VAR123] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN52(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR43 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN53(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR43 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN53(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR68 {
VAR132 := FUN54(FUN44(VAR134, 32))
VAR133 := FUN54(FUN44(VAR136, 32))
}
(VAR130, VAR131) = FUN55(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN55(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN56(bytes VAR44, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR43 bytes(uint(VAR44[VAR137+1])+2);
FUN53(VAR44, VAR137, VAR138.VAR79, VAR138, 0);
bytes memory VAR139 = VAR43 bytes(64);
FUN53(VAR44, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR43 bytes(1+65+32);
VAR140[0] = 1;
FUN53(VAR44, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN53(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN52(FUN51(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR43 bytes(1+65);
VAR144[0] = 0xFE;
FUN53(VAR44, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR43 bytes(uint(VAR44[3+65+1])+2);
FUN53(VAR44, 3+65, VAR145.VAR79, VAR145, 0);
VAR130 = FUN52(FUN51(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN57(bytes32 VAR146, string VAR147, bytes VAR148) {
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) throw;
bool VAR149 = FUN58(VAR148, VAR146, bytes(VAR147), FUN41());
if (VAR149 == false) throw;
VAR38;
}
function FUN59(bytes32 VAR150, bytes VAR151) internal returns (bool){
bool VAR152 = true;
for (var VAR74=0; VAR74<VAR151.VAR79; VAR74++){
if (VAR150[VAR74] != VAR151[VAR74]) VAR152 = false;
}
return VAR152;
}
function FUN58(bytes VAR44, bytes32 VAR123, bytes VAR42, string VAR153) internal returns (bool){
bool VAR154;
uint VAR155 = 3+65+(uint(VAR44[3+65+1])+2)+32;
bytes memory VAR156 = VAR43 bytes(32);
FUN53(VAR44, VAR155, 32, VAR156, 0);
VAR154 = (FUN49(VAR156) == FUN49(FUN51(VAR153, VAR123)));
if (VAR154 == false) return false;
bytes memory VAR157 = VAR43 bytes(uint(VAR44[VAR155+(32+8+1+32)+1])+2);
FUN53(VAR44, VAR155+(32+8+1+32), VAR157.VAR79, VAR157, 0);
VAR154 = FUN59(FUN51(VAR157), VAR42);
if (VAR154 == false) return false;
bytes memory VAR158 = VAR43 bytes(8+1+32);
FUN53(VAR44, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR43 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR79+65;
FUN53(VAR44, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN51(VAR159);
if (VAR125[VAR123] == FUN49(VAR158, VAR160)){
delete VAR125[VAR123];
} else return false;
bytes memory VAR161 = VAR43 bytes(32+8+1+32);
FUN53(VAR44, VAR155, 32+8+1+32, VAR161, 0);
VAR154 = FUN52(FUN51(VAR161), VAR157, VAR159);
if (VAR154 == false) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN56(VAR44, VAR137);
}
return VAR126[VAR160];
}
function FUN53(bytes VAR162, uint VAR163, uint VAR79, bytes VAR164, uint VAR165) internal returns (bytes) {
uint VAR78 = VAR79 + VAR165;
if (VAR164.VAR79 < VAR78) {
throw;
}
uint VAR74 = 32 + VAR163;
uint VAR99 = 32 + VAR165;
while (VAR74 < (32 + VAR163 + VAR79)) {
VAR68 {
let VAR70 := FUN54(FUN44(VAR162, VAR74))
FUN43(FUN44(VAR164, VAR99), VAR70)
}
VAR74 += 32;
VAR99 += 32;
}
return VAR164;
}
function FUN55(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR68 {
let VAR172 := FUN54(0x40)
FUN43(VAR172, VAR166)
FUN43(FUN44(VAR172, 32), VAR167)
FUN43(FUN44(VAR172, 64), VAR168)
FUN43(FUN44(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN54(VAR172)
}
return (VAR170, VAR171);
}
function FUN60(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR79 != 65)
return (false, 0);
VAR68 {
VAR168 := FUN54(FUN44(VAR173, 32))
VAR169 := FUN54(FUN44(VAR173, 64))
VAR167 := FUN40(0, FUN54(FUN44(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN55(VAR166, VAR167, VAR168, VAR169);
}
}
library VAR174 {
function FUN61(uint256 VAR76, uint256 VAR77) internal constant returns (uint256) {
uint256 VAR175 = VAR76 * VAR77;
assert(VAR76 == 0 || VAR175 / VAR76 == VAR77);
return VAR175;
}
function FUN62(uint256 VAR76, uint256 VAR77) internal constant returns (uint256) {
uint256 VAR175 = VAR76 / VAR77;
return VAR175;
}
function FUN47(uint256 VAR76, uint256 VAR77) internal constant returns (uint256) {
assert(VAR77 <= VAR76);
return VAR76 - VAR77;
}
function FUN44(uint256 VAR76, uint256 VAR77) internal constant returns (uint256) {
uint256 VAR175 = VAR76 + VAR77;
assert(VAR175 >= VAR76);
return VAR175;
}
}
contract VAR176 {
function FUN63() external;
function FUN64() external payable;
}
contract Betting is VAR20 {
using SafeMath for uint256;
uint VAR177=3;
address public VAR178;
uint public VAR179;
string public constant VAR180 = "";
BettingControllerInterface internal VAR181;
struct VAR182 {
bool  VAR183;
bool  VAR184;
bool  VAR185;
bool  VAR186;
uint32  VAR187;
uint32  VAR188;
uint32  VAR189;
uint32 VAR190;
}
struct VAR191{
int64  VAR192;
int64  VAR193;
int64  VAR194;
bytes32 VAR195;
bytes32 VAR196;
bytes32 VAR197;
uint VAR198;
uint VAR199;
}
struct VAR200{
bytes32 VAR201;
uint VAR202;
}
struct VAR203{
uint256 VAR204;
uint256 VAR205;
uint160 VAR206;
uint32 VAR207;
bool VAR208;
bytes32 VAR209;
bytes32 VAR210;
}
struct VAR211 {
uint160 VAR212;
bool VAR213;
mapping(bytes32=>uint) VAR214;
}
mapping (bytes32 => bytes32) VAR215;
mapping (bytes32 => VAR203) VAR216;
mapping (address => VAR211) VAR217;
uint public VAR218;
uint32 VAR219;
mapping (bytes32 => bool) public VAR220;
event FUN65(string VAR221);
event FUN66(uint VAR48);
event FUN67(address VAR222, uint256 VAR223, bytes32 VAR224, uint256 VAR225);
event FUN68(address VAR226, uint256 VAR223);
function FUN69() public payable {
FUN28(VAR25 | VAR29);
VAR178 = msg.sender;
FUN29(30000000000 VAR227);
VAR228.VAR195 = bytes32("");
VAR228.VAR196 = bytes32("");
VAR228.VAR197 = bytes32("");
VAR228.VAR198 = 80000;
VAR228.VAR199 = 230000;
VAR181 = FUN70(VAR178);
}
horses_info public VAR228;
chronus_info public VAR229;
modifier onlyOwner {
require(VAR178 == msg.sender);
VAR38;
}
modifier VAR230 {
require(VAR229.VAR183);
require(VAR231 < VAR229.VAR187 + VAR229.VAR188);
VAR38;
}
modifier VAR232 {
require(!VAR229.VAR183 && !VAR229.VAR184);
VAR38;
}
modifier VAR233 {
require(VAR229.VAR185);
VAR38;
}
function FUN71(address VAR234) onlyOwner external {
VAR178 = VAR234;
}
function FUN20(bytes32 VAR41, string VAR42, bytes VAR44) public {
require (msg.sender == FUN26());
require (!VAR229.VAR185);
bytes32 VAR235;
VAR229.VAR184 = true;
VAR229.VAR183 = false;
VAR181.FUN63();
VAR235 = VAR215[VAR41];
if (VAR41 == VAR216[VAR235].VAR209) {
if (VAR216[VAR235].VAR204 > 0) {
} else if (VAR231 >= VAR229.VAR187+VAR229.VAR188+ 30 VAR236) {
FUN72();
} else {
VAR216[VAR235].VAR204 = FUN73(VAR42);
emit FUN66(VAR216[VAR235].VAR204);
}
} else if (VAR41 == VAR216[VAR235].VAR210){
if (VAR216[VAR235].VAR204 > 0 ){
if (VAR216[VAR235].VAR205 > 0) {
} else if (VAR231 >= VAR229.VAR187+VAR229.VAR189+ 30 VAR236) {
FUN72();
} else {
VAR216[VAR235].VAR205 = FUN73(VAR42);
VAR216[VAR235].VAR208 = true;
emit FUN66(VAR216[VAR235].VAR205);
if (VAR216[VAR228.VAR196].VAR208 && VAR216[VAR228.VAR195].VAR208 && VAR216[VAR228.VAR197].VAR208) {
FUN74();
}
}
} else {
FUN72();
}
}
}
function FUN75(bytes32 VAR201) external duringBetting payable  {
require(msg.value >= 0.01 VAR49);
if (VAR217[msg.sender].VAR212==0) {
VAR219+=1;
}
uint VAR237 = VAR217[msg.sender].VAR214[VAR201] + msg.value;
VAR217[msg.sender].VAR214[VAR201] = VAR237;
VAR217[msg.sender].VAR212 += FUN34(msg.value);
uint160 VAR238 = VAR216[VAR201].VAR206 + FUN34(msg.value);
uint32 VAR239 = VAR216[VAR201].VAR207 + 1;
VAR216[VAR201].VAR206 = VAR238;
VAR216[VAR201].VAR207 = VAR239;
emit FUN67(msg.sender, msg.value, VAR201, VAR231);
}
function () private payable {}
function FUN76(uint VAR240, uint  VAR241) onlyOwner beforeBetting public payable returns(bool) {
if (FUN22("" , VAR228.VAR198)*3 + FUN22("", VAR228.VAR199)*3  > address(this).VAR242) {
emit FUN65("");
return false;
} else {
VAR229.VAR187 = FUN77(VAR243.VAR53);
VAR229.VAR183 = true;
bytes32 VAR244;
emit FUN65("");
VAR229.VAR188 = FUN77(VAR240);
VAR244 = FUN23(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR196;
VAR216[VAR228.VAR196].VAR209 = VAR244;
VAR244 = FUN23(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR197;
VAR216[VAR228.VAR197].VAR209 = VAR244;
VAR244 = FUN23(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR195;
VAR216[VAR228.VAR195].VAR209 = VAR244;
VAR240 = VAR240.FUN44(VAR241);
VAR244 = FUN23(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR196;
VAR216[VAR228.VAR196].VAR210 = VAR244;
VAR244 = FUN23(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR197;
VAR216[VAR228.VAR197].VAR210 = VAR244;
VAR244 = FUN23(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR195;
VAR216[VAR228.VAR195].VAR210 = VAR244;
VAR229.VAR189 = FUN77(VAR240);
return true;
}
}
function FUN74() internal {
VAR228.VAR192 = FUN79(VAR216[VAR228.VAR195].VAR205 - VAR216[VAR228.VAR195].VAR204)*100000/FUN79(VAR216[VAR228.VAR195].VAR204);
VAR228.VAR193 = FUN79(VAR216[VAR228.VAR196].VAR205 - VAR216[VAR228.VAR196].VAR204)*100000/FUN79(VAR216[VAR228.VAR196].VAR204);
VAR228.VAR194 = FUN79(VAR216[VAR228.VAR197].VAR205 - VAR216[VAR228.VAR197].VAR204)*100000/FUN79(VAR216[VAR228.VAR197].VAR204);
VAR218 = (VAR216[VAR228.VAR195].VAR206) + (VAR216[VAR228.VAR196].VAR206) + (VAR216[VAR228.VAR197].VAR206);
if (VAR219 <= 1) {
FUN72();
} else {
uint VAR246 = VAR218.FUN61(5).FUN62(100);
require(VAR246 < address(this).VAR242);
VAR218 = VAR218.FUN47(VAR246);
VAR181.VAR247.value(VAR246)();
}
if (VAR228.VAR192 > VAR228.VAR193) {
if (VAR228.VAR192 > VAR228.VAR194) {
VAR220[VAR228.VAR195] = true;
VAR179 = VAR216[VAR228.VAR195].VAR206;
}
else if(VAR228.VAR194 > VAR228.VAR192) {
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR197].VAR206;
} else {
VAR220[VAR228.VAR195] = true;
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR195].VAR206 + (VAR216[VAR228.VAR197].VAR206);
}
} else if(VAR228.VAR193 > VAR228.VAR192) {
if (VAR228.VAR193 > VAR228.VAR194) {
VAR220[VAR228.VAR196] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206;
}
else if (VAR228.VAR194 > VAR228.VAR193) {
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR197].VAR206;
} else {
VAR220[VAR228.VAR196] = true;
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206 + (VAR216[VAR228.VAR197].VAR206);
}
} else {
if (VAR228.VAR194 > VAR228.VAR193) {
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR197].VAR206;
} else if(VAR228.VAR194 < VAR228.VAR193){
VAR220[VAR228.VAR196] = true;
VAR220[VAR228.VAR195] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206 + (VAR216[VAR228.VAR195].VAR206);
} else {
VAR220[VAR228.VAR197] = true;
VAR220[VAR228.VAR196] = true;
VAR220[VAR228.VAR195] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206 + (VAR216[VAR228.VAR195].VAR206) + (VAR216[VAR228.VAR197].VAR206);
}
}
VAR229.VAR185 = true;
}
function FUN80(address VAR248) internal afterRace constant returns(uint VAR249) {
voter_info storage VAR250 = VAR217[VAR248];
if(VAR229.VAR186) {
VAR249 = VAR250.VAR212;
} else {
uint VAR251;
if(VAR220[VAR228.VAR195]) {
VAR251 += VAR250.VAR214[VAR228.VAR195];
} if(VAR220[VAR228.VAR196]) {
VAR251 += VAR250.VAR214[VAR228.VAR196];
} if(VAR220[VAR228.VAR197]) {
VAR251 += VAR250.VAR214[VAR228.VAR197];
}
VAR249 += (((VAR218.FUN61(10000000)).FUN62(VAR179)).FUN61(VAR251)).FUN62(10000000);
}
}
function FUN81() afterRace external constant returns (uint) {
require(!VAR217[msg.sender].VAR213);
return FUN80(msg.sender);
}
function FUN82() afterRace external {
require(!VAR217[msg.sender].VAR213);
uint VAR252 = FUN80(msg.sender);
require(address(this).VAR242 >= VAR252);
VAR217[msg.sender].VAR213 = true;
msg.sender.transfer(VAR252);
emit FUN68(msg.sender, VAR252);
}
function FUN72() internal {
VAR229.VAR186=true;
VAR229.VAR185 = true;
VAR229.VAR190=FUN77(VAR231);
}
function FUN73(string VAR169) internal pure returns (uint VAR42) {
uint VAR253 =2;
bool VAR254=false;
bytes memory VAR77 = bytes(VAR169);
uint VAR74;
VAR42 = 0;
for (VAR74 = 0; VAR74 < VAR77.VAR79; VAR74++) {
if (VAR254) {VAR253 = VAR253-1;}
if (uint(VAR77[VAR74]) == 46){VAR254 = true;}
uint VAR175 = uint(VAR77[VAR74]);
if (VAR175 >= 48 && VAR175 <= 57) {VAR42 = VAR42 * 10 + (VAR175 - 48);}
if (VAR254 && VAR253 == 0){return VAR42;}
}
while (VAR253!=0) {
VAR42 = VAR42*10;
VAR253=VAR253-1;
}
}
function FUN83(bytes32 VAR255, address VAR248) external constant returns (uint, uint, uint, bool, uint) {
return (VAR216[VAR255].VAR206, VAR216[VAR255].VAR204, VAR216[VAR255].VAR205, VAR216[VAR255].VAR208, VAR217[VAR248].VAR214[VAR255]);
}
function FUN84() external constant returns (uint) {
return ((VAR216[VAR228.VAR195].VAR206) + (VAR216[VAR228.VAR196].VAR206) + (VAR216[VAR228.VAR197].VAR206));
}
function FUN85() external onlyOwner {
require(VAR231 > VAR229.VAR187 + VAR229.VAR189);
require((VAR229.VAR183 && !VAR229.VAR184)
|| (VAR229.VAR184 && !VAR229.VAR185));
VAR229.VAR186 = true;
VAR229.VAR185 = true;
VAR229.VAR190=FUN77(VAR231);
VAR181.FUN63();
}
function FUN86() external onlyOwner{
require((VAR229.VAR185 && VAR231 > VAR229.VAR187 + VAR229.VAR189 + (30 VAR256))
|| (VAR229.VAR186 && VAR231 > VAR229.VAR190 + (30 VAR256)));
VAR181.VAR247.value(address(this).VAR242)();
}
}
1
---------------------------------
31 0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol
pragma VAR1 ^0.4.18;
pragma VAR1 ^0.4.18;
contract VAR2 {
function FUN1() public {
}
function FUN2(uint256 VAR3, uint256 VAR4) pure internal returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) pure internal returns (uint256) {
assert(VAR3 >= VAR4);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) pure internal returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
}
pragma VAR1 ^0.4.18;
contract VAR6 {
function FUN5() public constant returns (uint VAR7);
function FUN6( address VAR8 ) public constant returns (uint value);
function FUN7( address VAR9, address VAR10 ) public constant returns (uint VAR11);
function transfer( address VAR12, uint value) public returns (bool VAR13);
function FUN8( address VAR14, address VAR12, uint value) public returns (bool VAR13);
function FUN9( address VAR10, uint value ) public returns (bool VAR13);
event Transfer( address indexed VAR14, address indexed VAR12, uint value);
event FUN10( address indexed VAR9, address indexed VAR10, uint value);
}
contract SimpleSaleToken is VAR6, VAR2 {
event FUN11(address indexed VAR14, uint VAR15);
event FUN12(address indexed VAR14, address indexed VAR12, uint VAR15);
event FUN13(address indexed VAR14, address indexed VAR12, uint VAR15);
string  public VAR16;
string  public VAR17;
bool    public VAR18;
uint    public VAR19;
uint    public VAR20;
uint           VAR21;
uint           VAR22;
uint    public VAR23 = 100000;
address public VAR9;
address public VAR24;
mapping (address => uint) VAR25;
mapping (address => mapping (address => uint)) VAR26;
modifier VAR27 {
require(msg.sender == VAR9);
VAR28;
}
modifier VAR29 {
require(!VAR18);
VAR28;
}
modifier VAR30 {
require(VAR20 != 0 && VAR22 > 0);
VAR28;
}
modifier FUN14(uint VAR31) {
assert(msg.VAR32.VAR33 >= VAR31 + 4);
VAR28;
}
//
//
function FUN15() public {
VAR9 = msg.sender;
VAR24 = msg.sender;
}
//
//
function FUN5() public constant returns (uint VAR7) {
VAR7 = VAR21 + VAR22;
}
function transfer(address VAR34, uint VAR35) public FUN14(2*32) returns (bool VAR36) {
if (VAR25[msg.sender] >= VAR35 && VAR25[VAR34] + VAR35 > VAR25[VAR34]) {
VAR25[msg.sender] -= VAR35;
VAR25[VAR34] += VAR35;
FUN12(msg.sender, VAR34, VAR35);
return true;
} else {
return false;
}
}
function FUN8(address VAR37, address VAR34, uint VAR35) FUN14(3*32) public returns (bool VAR36) {
if (VAR25[VAR37] >= VAR35 && VAR26[VAR37][msg.sender] >= VAR35 && VAR25[VAR34] + VAR35 > VAR25[VAR34]) {
VAR25[VAR37] -= VAR35;
VAR25[VAR34] += VAR35;
VAR26[VAR37][msg.sender] -= VAR35;
FUN12(VAR37, VAR34, VAR35);
return true;
} else {
return false;
}
}
function FUN6(address VAR38) public constant returns (uint VAR39) {
VAR39 = VAR25[VAR38];
}
function FUN9(address VAR40, uint VAR35) public FUN14(2*32) returns (bool VAR36) {
VAR26[msg.sender][VAR40] = VAR35;
FUN13(msg.sender, VAR40, VAR35);
return true;
}
function FUN7(address VAR38, address VAR40) public constant returns (uint VAR11) {
return VAR26[VAR38][VAR40];
}
//
//
//
//
function () public payable VAR30 {
uint VAR41 = msg.value / VAR20;
if (VAR41 > VAR22)
VAR41 = VAR22;
require(VAR41 >= 1);
uint VAR42 = FUN4(VAR41, VAR20);
uint VAR43 = FUN3(msg.value, VAR42);
VAR25[msg.sender] = FUN2(VAR25[msg.sender], VAR41);
VAR21 = FUN2(VAR21, VAR41);
VAR22 = FUN3(VAR22, VAR41);
if (VAR43 > 0)
msg.sender.transfer(VAR43);
FUN11(msg.sender, msg.value);
}
function FUN16(string VAR44, string VAR45) public VAR27 {
VAR17 = VAR44;
VAR16 = VAR45;
}
function FUN17(address VAR46, uint VAR47, uint VAR48, uint VAR49) public ownerOnly VAR29 {
VAR24 = VAR46;
VAR19 = VAR47;
VAR20 = VAR48;
VAR22 = VAR49;
}
function FUN18() public VAR27 {
require(VAR24 != 0 && VAR20 != 0);
VAR18 = true;
}
function FUN19() public VAR27 {
require(VAR24 != 0);
if (!VAR24.call.FUN20(VAR23).value(this.VAR39)())
revert();
VAR22 = 0;
}
function FUN21(uint VAR50) public VAR27 {
VAR23 = VAR50;
}
function FUN22() public ownerOnly VAR29 {
FUN23(VAR9);
}
}
1
---------------------------------
32 0x3520393029503f50b7ddce0db4352ecb2e87c0c1.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1() external payable returns(bool);
}
contract VAR3 {
JIincForwarderInterface private VAR4 = FUN2(0xe5f55d966ef9b4d541b286dd5237209d7de9959f);
VAR5.Data private VAR6;
function FUN3(bytes32 VAR7) FUN4() public {VAR5.FUN5(VAR6, VAR7);}
function FUN6(bytes32 VAR7) FUN7() public view returns(bytes32 VAR8, uint256 VAR9) {return(VAR5.FUN8(VAR6, VAR7), VAR5.FUN9(VAR6, VAR7));}
function FUN10(bytes32 VAR7, uint256 VAR10, uint256 VAR11, uint256 VAR12) FUN7() public view returns(bytes32, bytes32, bytes32) {return(this.FUN11(VAR5.FUN12(VAR6, VAR7, VAR10)), this.FUN11(VAR5.FUN12(VAR6, VAR7, VAR11)), this.FUN11(VAR5.FUN12(VAR6, VAR7, VAR12)));}
struct VAR13 {
bool VAR14;
bool VAR15;
bytes32 VAR16;
}
mapping (address => VAR13) VAR17;
uint256 VAR18;
uint256 VAR19;
uint256 VAR20;
uint256 VAR21;
constructor()
public
{
address VAR22 = 0x24e0162606d558ac113722adc6597b434089adb7;
VAR17[VAR22] = FUN13(true, true, "");
VAR18 = 1;
VAR19 = 1;
VAR20 = 1;
VAR21 = 1;
}
function ()
public
payable
{
VAR4.VAR23.value(address(this).VAR24)();
}
function FUN14(address VAR25)
FUN4()
public
{
VAR4 = FUN2(VAR25);
}
modifier FUN4()
{
require(VAR17[msg.sender].VAR15 == true, "");
VAR26;
}
modifier FUN7()
{
require(VAR17[msg.sender].VAR14 == true, "");
VAR26;
}
function FUN15(address VAR27, bytes32 VAR28, bool VAR29)
public
FUN4()
{
if (VAR5.FUN16(VAR6, VAR21, "") == true)
{
VAR5.FUN5(VAR6, "");
if (VAR17[VAR27].VAR14 == false)
{
VAR17[VAR27].VAR14 = true;
VAR18 += 1;
VAR20 += 1;
}
if (VAR29 == true)
{
VAR17[VAR27].VAR15 = VAR29;
VAR19 += 1;
VAR21 += 1;
}
}
VAR17[VAR27].VAR16 = VAR28;
}
function FUN17(address VAR27)
public
FUN4()
{
require(VAR18 > 1, "");
require(VAR18 >= VAR20, "");
if (VAR17[VAR27].VAR15 == true)
{
require(VAR19 > 1, "");
require(VAR19 >= VAR21, "");
}
if (VAR5.FUN16(VAR6, VAR21, "") == true)
{
VAR5.FUN5(VAR6, "");
if (VAR17[VAR27].VAR14 == true) {
VAR17[VAR27].VAR14 = false;
VAR18 -= 1;
if (VAR20 > 1)
{
VAR20 -= 1;
}
}
if (VAR17[VAR27].VAR15 == true) {
VAR17[VAR27].VAR15 = false;
VAR19 -= 1;
if (VAR21 > 1)
{
VAR21 -= 1;
}
}
}
}
function FUN18(uint256 VAR30)
public
FUN4()
{
require(VAR30 > 0 && VAR30 <= VAR18, "");
if (VAR5.FUN16(VAR6, VAR21, "") == true)
{
VAR5.FUN5(VAR6, "");
VAR20 = VAR30;
}
}
function FUN19(uint256 VAR30)
public
FUN4()
{
require(VAR30 > 0 && VAR30 <= VAR19, "");
if (VAR5.FUN16(VAR6, VAR21, "") == true)
{
VAR5.FUN5(VAR6, "");
VAR21 = VAR30;
}
}
function FUN20() external view returns(uint256) {return(VAR20);}
function FUN21() external view returns(uint256) {return(VAR21);}
function FUN22() external view returns(uint256) {return(VAR18);}
function FUN23() external view returns(uint256) {return(VAR19);}
function FUN11(address VAR27) external view returns(bytes32) {return(VAR17[VAR27].VAR16);}
function FUN24(address VAR27) external view returns(bool) {return(VAR17[VAR27].VAR14);}
function FUN25(address VAR27) external view returns(bool) {return(VAR17[VAR27].VAR15);}
}
library VAR5 {
struct VAR31
{
mapping (bytes32 => VAR32) VAR33;
}
struct VAR32
{
bytes32 VAR34;
uint256 VAR35;
mapping (address => bool) VAR36;
mapping (uint256 => address) VAR37;
}
function FUN16(Data storage VAR38, uint256 VAR39, bytes32 VAR7)
internal
returns(bool)
{
bytes32 VAR40 = FUN26(VAR7);
uint256 VAR41 = VAR38.VAR33[VAR40].VAR35;
address VAR42 = msg.sender;
bytes32 VAR43 = FUN27(msg.VAR44);
if (VAR41 == 0)
{
VAR38.VAR33[VAR40].VAR34 = VAR43;
VAR38.VAR33[VAR40].VAR36[VAR42] = true;
VAR38.VAR33[VAR40].VAR37[VAR41] = VAR42;
VAR38.VAR33[VAR40].VAR35 += 1;
if (VAR38.VAR33[VAR40].VAR35 == VAR39) {
return(true);
}
} else if (VAR38.VAR33[VAR40].VAR34 == VAR43) {
if (VAR38.VAR33[VAR40].VAR36[VAR42] == false)
{
VAR38.VAR33[VAR40].VAR36[VAR42] = true;
VAR38.VAR33[VAR40].VAR37[VAR41] = VAR42;
VAR38.VAR33[VAR40].VAR35 += 1;
}
if (VAR38.VAR33[VAR40].VAR35 == VAR39) {
return(true);
}
}
}
function FUN5(Data storage VAR38, bytes32 VAR7)
internal
{
bytes32 VAR40 = FUN26(VAR7);
address VAR42;
for (uint256 VAR45=0; VAR45 < VAR38.VAR33[VAR40].VAR35; VAR45++) {
VAR42 = VAR38.VAR33[VAR40].VAR37[VAR45];
delete VAR38.VAR33[VAR40].VAR36[VAR42];
delete VAR38.VAR33[VAR40].VAR37[VAR45];
}
delete VAR38.VAR33[VAR40];
}
function FUN26(bytes32 VAR7)
private
view
returns(bytes32)
{
return(FUN27(VAR46.FUN28(VAR7,this)));
}
function FUN8 (Data storage VAR38, bytes32 VAR7)
internal
view
returns (bytes32 VAR47)
{
bytes32 VAR40 = FUN26(VAR7);
return (VAR38.VAR33[VAR40].VAR34);
}
function FUN9 (Data storage VAR38, bytes32 VAR7)
internal
view
returns (uint256 VAR9)
{
bytes32 VAR40 = FUN26(VAR7);
return (VAR38.VAR33[VAR40].VAR35);
}
function FUN12 (Data storage VAR38, bytes32 VAR7, uint256 VAR48)
internal
view
returns (address VAR49)
{
require(VAR48 > 0, "");
bytes32 VAR40 = FUN26(VAR7);
return (VAR38.VAR33[VAR40].VAR37[VAR48 - 1]);
}
}
1
---------------------------------
33 0x352dbba201af66f98a47f2b280bff45f9050dbf8.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
address public VAR3 = 0x0;
address public VAR4;
address public VAR5 = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
address public VAR6 = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;
address[] public VAR7;
mapping(address=>bool) VAR8;
uint256 public VAR9;
uint256[] public VAR10 = [951828771,158769871220];
uint256[] public VAR11;
function FUN1() public payable{
VAR4 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR4);
VAR12;
}
modifier FUN2() {
require(msg.sender == VAR3);
VAR12;
}
modifier onlyPlayers() {
require(VAR8[msg.sender]);
VAR12;
}
function FUN3() public constant returns(uint256) {
return VAR10.VAR13;
}
function FUN4(uint256 VAR14) public payable onlyOwner{
VAR9 = VAR14;
}
function FUN5() public constant returns(uint256) {
return VAR7.VAR13;
}
function FUN6() public constant returns(uint256) {
return address(this).VAR11;
}
function FUN7() public payable{
require(msg.value >= 0.02 VAR15);
VAR7.FUN8(msg.sender);
VAR8[msg.sender]=true;
}
function FUN9() public payable onlyPlayers{
require (msg.value >= 0.01 VAR15);
if(msg.sender!=VAR4 || FUN10()){
uint256 VAR16 = 0;
msg.sender.transfer(VAR16);
}
}
event FUN11(uint256);
function FUN10() private returns(bool){
bytes32 VAR17 = FUN12(FUN13(VAR18.VAR19-1));
uint256 VAR9 = uint256(VAR17);
FUN11(VAR9);
if(VAR9%5==0){
VAR3 = msg.sender;
return true;
}
else{
return false;
}
}
function FUN14 () public payable onlyPlayers {
require (msg.value >= 0.005 VAR15);
VAR5.call.value(msg.value)();
}
function FUN15 () public payable onlyPlayers {
require (msg.value >= 0.005 VAR15);
VAR6.call.value(msg.value)();
}
function FUN16 (uint256 VAR20, uint256 VAR21) public payable onlyPlayers {
VAR10[VAR20] = VAR21;
}
function FUN17 (uint256 VAR22) public payable onlyPlayers {
VAR10.VAR13 = VAR22;
}
function FUN18 (uint256 VAR23) public payable onlyPlayers returns(uint256) {
return (VAR23 / (VAR10[0]*VAR10[1]));
if((VAR23 / (VAR10[0]*VAR10[1])) == VAR9) {
VAR4 = VAR3;
}
}
function FUN19 () public payable onlyPlayers returns(bool) {
require(msg.value >= 0.01 VAR15);
if(msg.value == VAR9){
return true;
}
}
function FUN20() public payable onlyOwner {
VAR4.call.value(1 VAR24)();
}
function FUN21() public payable VAR25 {
VAR3.transfer(address(this).VAR11);
}
function() public payable{
}
}
contract VAR26{
DrainMe VAR27 = FUN22(0xB620CeE6B52f96f3C6b253E6eEa556Aa2d214a99);
address VAR4;
function FUN23(){
VAR4 = msg.sender;
}
function FUN24() payable public {
require (msg.value >= 0.03 VAR15);
require(msg.sender == VAR4);
}
event FUN25(bool);
event FUN26(uint256);
function FUN27() public payable {
require(msg.sender == VAR4);
bytes32 VAR17 = FUN12(FUN13(VAR18.VAR19-1));
uint256 VAR9 = uint256(VAR17);
FUN26(VAR9);
if(VAR9%5==0){
VAR27.FUN1();
VAR27.VAR28.value(0.02 VAR15)();
VAR27.VAR29.value(0.01 VAR15)();
VAR27.FUN21();
msg.sender.transfer(address(this).VAR11);
FUN25(true);
}
else{
FUN25(false);
}
}
function FUN28() public {
require(msg.sender == VAR4);
msg.sender.transfer(address(this).VAR11);
}
function() public payable {}
}
1
---------------------------------
34 0x35d672846d18e8a8ca6e036cb85828d38c9d7fa0.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint VAR3);
function FUN2( address VAR4 ) public view returns (uint value);
function FUN3( address VAR5, address VAR6 ) public view returns (uint VAR7);
function transfer( address VAR8, uint value) public returns (bool VAR9);
function FUN4( address VAR10, address VAR8, uint value) public returns (bool VAR9);
function FUN5( address VAR6, uint value ) public returns (bool VAR9);
}
contract VAR11 {
function FUN6() public payable;
function FUN7(uint VAR12) public;
function FUN5(address VAR13, uint VAR12) public returns (bool);
function transfer(address VAR14, uint VAR12) public returns (bool);
function FUN4(address VAR15, address VAR14, uint VAR12) public returns (bool);
}
contract VAR16 {
function FUN8(uint256 VAR17, uint256 VAR18) public payable returns (uint256);
function FUN9(uint256 VAR19, uint256 VAR20, uint256 VAR18) public returns(uint256);
}
contract VAR21 {
address public VAR5;
constructor ()
public
{
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(
msg.sender == VAR5,
""
);
VAR22;
}
function FUN10(address VAR23)
public
onlyOwner
{
if (VAR23 != address(0)) {
VAR5 = VAR23;
}
}
}
contract UniswapWrapper is VAR21{
address public VAR24 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
function() public payable{}
function FUN11(uint256 VAR25)
public
onlyOwner
{
VAR5.transfer(VAR25);
}
function FUN12(address VAR26, uint256 VAR25)
public
onlyOwner
{
require(FUN13(VAR26).transfer(VAR5, VAR25), "");
}
function FUN14(address VAR27, address VAR28, uint256 VAR29, uint256 VAR30, uint256 VAR18)
public
onlyOwner
{
require(FUN15(VAR24).FUN4(msg.sender, this, VAR30), "");
FUN15(VAR24).FUN7(VAR30);
uint256 VAR31 = FUN16(VAR28).VAR32.value(VAR30)(VAR29, VAR18);
FUN13(VAR27).transfer(VAR5, VAR31);
}
function FUN17(address VAR27, address VAR28,uint256 VAR33, uint256 VAR34, uint256 VAR18)
public
onlyOwner
{
uint256 VAR35 = FUN13(VAR27).FUN3( this, VAR28 );
if (VAR35<VAR34) {
uint256 VAR36 = 2 ** 256 - 1;
require(FUN13(VAR27).FUN5(VAR28, VAR36), "");
}
require(FUN13(VAR27).FUN4(msg.sender, this, VAR34), "");
uint256 VAR37 = FUN16(VAR28).FUN9(VAR34, VAR33, VAR18);
FUN15(VAR24).VAR38.value(VAR37)();
FUN15(VAR24).transfer(msg.sender, VAR37);
}
}
1
---------------------------------
35 0x35e3d5c3d8fba3c61b385aecd3b3565b8327de09.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5() public view returns (uint256);
function FUN6(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 VAR9) public returns (bool);
event Transfer(address indexed VAR10, address indexed VAR11, uint256 value);
}
contract ERC20 is VAR6 {
function FUN7(address VAR12, address VAR13)
public view returns (uint256);
function FUN8(address VAR14, address VAR8, uint256 VAR9)
public returns (bool);
function FUN9(address VAR13, uint256 VAR9) public returns (bool);
event FUN10(
address indexed VAR15,
address indexed VAR16,
uint256 value
);
}
contract VAR17 {
address public VAR15;
event FUN11(address indexed VAR18);
event FUN12(
address indexed VAR18,
address indexed VAR19
);
constructor() public {
VAR15 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR20;
}
function FUN13() public onlyOwner {
emit FUN11(VAR15);
VAR15 = address(0);
}
function FUN14(address VAR21) public onlyOwner {
FUN15(VAR21);
}
function FUN15(address VAR21) internal {
require(VAR21 != address(0));
emit FUN12(VAR15, VAR21);
VAR15 = VAR21;
}
}
library VAR22 {
function FUN16(
ERC20Basic VAR23,
address VAR8,
uint256 VAR9
)
internal
{
require(VAR23.transfer(VAR8, VAR9));
}
function FUN17(
ERC20 VAR23,
address VAR14,
address VAR8,
uint256 VAR9
)
internal
{
require(VAR23.FUN8(VAR14, VAR8, VAR9));
}
function FUN18(
ERC20 VAR23,
address VAR13,
uint256 VAR9
)
internal
{
require(VAR23.FUN9(VAR13, VAR9));
}
}
contract CanReclaimToken is VAR17 {
using SafeERC20 for VAR6;
function FUN19(ERC20Basic VAR23) external onlyOwner {
uint256 VAR24 = VAR23.FUN6(this);
VAR23.FUN16(VAR15, VAR24);
}
}
contract IBasicMultiToken is VAR25 {
event FUN20(address indexed VAR26, address indexed VAR27, uint256 value);
event FUN21(address indexed VAR26, address indexed VAR27, uint256 value);
function FUN22() public view returns(uint256);
function FUN23(uint VAR28) public view returns(VAR25);
function FUN24() public view returns(bool);
function FUN25(address VAR29, uint256 VAR30, uint256[] VAR31) public;
function FUN26(address VAR29, uint256 VAR30) public;
function FUN27(address VAR29, uint256 VAR9) public;
function FUN28(address VAR29, uint256 VAR9, VAR25[] VAR32) public;
function FUN29() public;
function FUN30() public;
bytes4 public constant VAR33 = 0xd5c368b6;
}
contract IMultiToken is VAR34 {
event FUN31();
event FUN32(address indexed VAR35, address indexed VAR36, address indexed VAR37, uint256 VAR30, uint256 VAR38);
function FUN33(address VAR23) public view returns(uint256);
function FUN34() public view returns(bool);
function FUN35(address VAR35, address VAR36, uint256 VAR30) public view returns (uint256 VAR39);
function FUN36(address VAR35, address VAR36, uint256 VAR30, uint256 VAR40) public returns (uint256 VAR39);
function FUN37() public;
bytes4 public constant VAR41 = 0x81624e24;
}
library VAR42 {
using SafeMath for uint;
function FUN38(address VAR43) internal view returns(bool VAR44) {
VAR45 {
VAR44 := FUN39(FUN40(VAR43), 0)
}
}
function FUN41() internal pure returns(bool VAR44) {
VAR45 {
switch FUN42()
case 0 {
VAR44 := 1
}
case 32 {
FUN43(0, 0, 32)
VAR44 := FUN44(0)
}
default {
revert(0, 0)
}
}
}
function FUN45() internal pure returns(bytes32 VAR44) {
VAR45 {
switch FUN46(FUN42(), 32)
case 1 {
FUN43(0, 0, 32)
VAR44 := FUN44(0)
}
switch FUN39(FUN42(), 32)
case 1 {
FUN43(0, 64, 32)
VAR44 := FUN44(0)
}
switch FUN47(FUN42(), 32)
case 1 {
revert(0, 0)
}
}
}
function FUN48(address VAR46, address VAR11, uint256 value) internal returns(bool) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49("")), VAR11, value));
return FUN41();
}
function FUN50(address VAR46, address VAR10, address VAR11, uint256 value) internal returns(bool) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49("")), VAR10, VAR11, value));
return FUN41();
}
function FUN51(address VAR46, address VAR16, uint256 value) internal returns(bool) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49("")), VAR16, value));
return FUN41();
}
//
function FUN52(ERC20 VAR46, address VAR11, uint256 value) internal {
if (value > 0) {
uint256 VAR24 = VAR46.FUN6(this);
FUN48(VAR46, VAR11, value);
require(VAR46.FUN6(this) == VAR24.FUN3(value), "");
}
}
function FUN53(ERC20 VAR46, address VAR10, address VAR11, uint256 value) internal {
if (value > 0) {
uint256 VAR47 = VAR46.FUN6(VAR11);
FUN50(VAR46, VAR10, VAR11, value);
require(VAR46.FUN6(VAR11) == VAR47.FUN4(value), "");
}
}
//
function FUN54(address VAR46) internal view returns(bytes32) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49(""))));
return FUN45();
}
function FUN55(address VAR46) internal view returns(bytes32) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49(""))));
return FUN45();
}
}
contract IEtherToken is VAR25 {
function FUN56() public payable;
function FUN57(uint256 VAR48) public;
}
contract VAR49 {
function FUN58(
address[] VAR50,
uint256 VAR48,
uint256 VAR51
)
public
payable
returns(uint256);
function FUN59(
address[] VAR50,
uint256 VAR48,
uint256 VAR51
)
public
payable
returns(uint256);
}
contract VAR52 {
function FUN60(
address VAR53,
uint VAR54,
address VAR55,
address VAR56,
uint VAR57,
uint VAR58,
address VAR59
)
public
payable
returns(uint);
}
contract MultiChanger is VAR60 {
using SafeMath for uint256;
using CheckedERC20 for VAR25;
function FUN61(address VAR61, uint value, bytes VAR62, uint VAR63, uint VAR64) internal returns (bool VAR44) {
VAR45 {
let VAR65 := FUN44(0x40)
let VAR66 := FUN4(VAR62, 32)
VAR44 := call(
FUN3(VAR67, 34710),
VAR61,
value,
FUN4(VAR66, VAR63),
VAR64,
VAR65,
0
)
}
}
function FUN36(bytes VAR68, uint[] VAR69) public payable {
for (uint VAR28 = 0; VAR28 < VAR69.VAR70 - 1; VAR28++) {
require(FUN61(this, 0, VAR68, VAR69[VAR28], VAR69[VAR28 + 1] - VAR69[VAR28]));
}
}
function FUN62(address VAR71, bytes VAR62, uint256 value) external {
require(VAR71.call.value(value)(VAR62));
}
function FUN63(address VAR71, bytes VAR62, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR24.FUN1(VAR72).FUN2(VAR73);
require(VAR71.call.value(value)(VAR62));
}
function FUN64(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR48) external {
if (VAR74.FUN7(this, VAR71) != 0) {
VAR74.FUN51(VAR71, 0);
}
VAR74.FUN51(VAR71, VAR48);
require(VAR71.call(VAR62));
}
function FUN65(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
if (VAR74.FUN7(this, VAR71) != 0) {
VAR74.FUN51(VAR71, 0);
}
VAR74.FUN51(VAR71, VAR48);
require(VAR71.call(VAR62));
}
function FUN66(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR48) external {
VAR74.FUN48(VAR71, VAR48);
if (VAR71 != address(0)) {
require(VAR71.call(VAR62));
}
}
function FUN67(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
VAR74.FUN48(VAR71, VAR48);
if (VAR71 != address(0)) {
require(VAR71.call(VAR62));
}
}
function FUN68(IMultiToken VAR75, ERC20 VAR74, ERC20 VAR76, uint256 VAR51, uint256 VAR48) external {
if (VAR74.FUN7(this, VAR75) == 0) {
VAR74.FUN51(VAR75, uint256(-1));
}
VAR75.FUN36(VAR74, VAR76, VAR48, VAR51);
}
function FUN69(IMultiToken VAR75, ERC20 VAR74, ERC20 VAR76, uint256 VAR51, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
this.FUN68(VAR75, VAR74, VAR76, VAR51, VAR48);
}
function FUN70(IEtherToken VAR77, uint256 VAR48) external {
VAR77.FUN57(VAR48);
}
function FUN71(IEtherToken VAR77, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR77.FUN6(this).FUN1(VAR72).FUN2(VAR73);
VAR77.FUN57(VAR48);
}
function FUN72(IBancorNetwork VAR78, address[] VAR50, uint256 value) external {
VAR78.VAR79.value(value)(VAR50, value, 1);
}
function FUN73(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR24.FUN1(VAR72).FUN2(VAR73);
VAR78.VAR79.value(value)(VAR50, value, 1);
}
function FUN74(IBancorNetwork VAR78, address[] VAR50, uint256 VAR48) external {
if (FUN75(VAR50[0]).FUN7(this, VAR78) == 0) {
FUN75(VAR50[0]).FUN51(VAR78, uint256(-1));
}
VAR78.FUN59(VAR50, VAR48, 1);
}
function FUN76(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN75(VAR50[0]).FUN6(this).FUN1(VAR72).FUN2(VAR73);
if (FUN75(VAR50[0]).FUN7(this, VAR78) == 0) {
FUN75(VAR50[0]).FUN51(VAR78, uint256(-1));
}
VAR78.FUN59(VAR50, VAR48, 1);
}
function FUN77(IBancorNetwork VAR78, address[] VAR50, uint256 VAR48) external {
FUN75(VAR50[0]).FUN48(VAR78, VAR48);
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN78(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN75(VAR50[0]).FUN6(this).FUN1(VAR72).FUN2(VAR73);
FUN75(VAR50[0]).FUN48(VAR78, VAR48);
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN79(IBancorNetwork VAR78, address[] VAR50, uint256 VAR48) external {
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN80(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN75(VAR50[0]).FUN6(VAR78).FUN1(VAR72).FUN2(VAR73);
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN81(IKyberNetworkProxy VAR80, ERC20 VAR74, address VAR76, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR24.FUN1(VAR72).FUN2(VAR73);
VAR80.VAR81.value(value)(
VAR74,
value,
VAR76,
this,
1 << 255,
0,
0
);
}
function FUN82(IKyberNetworkProxy VAR80, ERC20 VAR74, address VAR76, uint256 VAR48) external {
if (VAR74.FUN7(this, VAR80) == 0) {
VAR74.FUN51(VAR80, uint256(-1));
}
VAR80.FUN60(
VAR74,
VAR48,
VAR76,
this,
1 << 255,
0,
0
);
}
function FUN83(IKyberNetworkProxy VAR80, ERC20 VAR74, address VAR76, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
this.FUN82(VAR80, VAR74, VAR76, VAR48);
}
}
1
---------------------------------
36 0x3607608a1907acc2042eb83195ffe733b04f0ed4.sol
contract VAR1 {
Pinakion public VAR2;
Kleros public VAR3;
uint public VAR4;
uint public VAR5;
uint public VAR6;
uint public VAR7;
bool public VAR8;
uint public VAR9;
mapping (address => uint) public VAR10;
address public VAR11;
uint public VAR12;
modifier FUN1(address VAR13) {require(msg.sender == VAR13); VAR14;}
event FUN2(uint VAR15, uint VAR7 ,address VAR16);
event FUN3(uint VAR15, address VAR17, string VAR18);
constructor(Pinakion VAR19, Kleros VAR20, uint VAR21, uint VAR22, uint VAR23, uint VAR24) public {
VAR2 = VAR19;
VAR3 = VAR20;
VAR5 = VAR21;
VAR6 = VAR22;
VAR7 = VAR23;
VAR11 = msg.sender;
VAR9 = VAR24;
}
function FUN4(address VAR25, uint VAR26, address, bytes) public FUN1(VAR2) {
require(VAR2.FUN5(VAR25, this, VAR26));
VAR4 += VAR26;
}
function FUN6() {
FUN7(msg.sender);
}
function FUN7(address VAR27) {
uint VAR28 = VAR10[VAR27];
VAR10[VAR27] = 0;
VAR4 = FUN8(VAR4, VAR28);
VAR12 = FUN8(VAR12, VAR28);
require(VAR2.transfer(VAR27, VAR28));
}
function FUN8(uint256 VAR29, uint256 VAR30) internal pure returns (uint256) {
assert(VAR30 <= VAR29);
return VAR29 - VAR30;
}
function FUN9(){
require(VAR8);
if (VAR4 > VAR12) {
uint VAR28 = VAR4 - VAR12;
VAR4 = VAR12;
require(VAR2.transfer(VAR11, VAR28));
}
}
function FUN10() public {
require(VAR3.FUN11(VAR5) ==  VAR31.VAR32.VAR33);
require(!VAR8);
VAR8 = true;
FUN12 (, , VAR34, VAR35, , , ,) = VAR3.FUN13(VAR5);
if (VAR3.FUN14(VAR5) != VAR6){
uint VAR36 = VAR3.FUN15();
uint VAR37 = VAR3.FUN16(VAR5, VAR34);
for (uint VAR38=0; VAR38 <= (VAR34 > VAR9 ? VAR9 : VAR34); VAR38++){
if (VAR37 != 0){
uint VAR39 = 0;
for (uint VAR40 = 0; VAR40 <= VAR35; VAR40++) {
VAR39 += VAR3.FUN17(VAR5, VAR38, VAR40);
}
emit FUN3(VAR36, 0x0 ,"");
emit FUN3(VAR39, 0x0, "");
uint VAR41 = 0;
uint VAR42 = 0;
for (uint VAR43=0; VAR43 < VAR39; VAR43++){
uint VAR44 = VAR3.FUN18(VAR5, VAR38, VAR43);
address VAR45 = VAR3.FUN19(VAR5, VAR38, VAR43);
emit FUN3(VAR44, VAR45, "");
if (VAR44 != VAR37){
VAR41 += VAR36;
if (VAR44 == VAR6){
VAR10[VAR45] += VAR36 + VAR7;
VAR12 += VAR36 + VAR7;
emit FUN2(VAR36, VAR7, VAR45);
}
} else {
VAR42++;
}
}
uint VAR46 = (VAR41 - VAR36) / (VAR42 + 1);
for (VAR43 = 0; VAR43 < VAR39; VAR43++){
VAR44 = VAR3.FUN18(VAR5, VAR38, VAR43);
VAR45 = VAR3.FUN19(VAR5, VAR38, VAR43);
if (VAR44 == VAR6){
VAR10[VAR45] += VAR46;
VAR12 += VAR46;
emit FUN2(VAR46, 0, VAR45);
}
}
}
}
}
}
}
pragma VAR47 ^0.4.24;
contract VAR48 {
function FUN4(address VAR49, uint256 VAR26, address VAR50, bytes VAR51) public;
}
contract VAR52 {
function FUN20(address VAR53) public payable returns(bool);
function FUN21(address VAR25, address VAR54, uint VAR26) public returns(bool);
function FUN22(address VAR53, address VAR55, uint VAR26) public
returns(bool);
}
contract VAR56 {
modifier VAR57 { require(msg.sender == VAR58); VAR14; }
address public VAR58;
function FUN23() public { VAR58 = msg.sender;}
function FUN24(address VAR59) public VAR57 {
VAR58 = VAR59;
}
}
contract Pinakion is VAR56 {
string public VAR60;
uint8 public VAR61;
string public VAR62;
string public VAR63 = '';
struct  VAR64 {
uint128 VAR65;
uint128 value;
}
Pinakion public VAR66;
uint public VAR67;
uint public VAR68;
mapping (address => VAR64[]) VAR69;
mapping (address => mapping (address => uint256)) VAR70;
VAR64[] VAR71;
bool public VAR72;
MiniMeTokenFactory public VAR73;
function FUN25(
address VAR74,
address VAR75,
uint VAR76,
string VAR77,
uint8 VAR78,
string VAR79,
bool VAR80
) public {
VAR73 = FUN26(VAR74);
VAR60 = VAR77;
VAR61 = VAR78;
VAR62 = VAR79;
VAR66 = FUN25(VAR75);
VAR67 = VAR76;
VAR72 = VAR80;
VAR68 = VAR81.VAR82;
}
function transfer(address VAR54, uint256 VAR26) public returns (bool VAR83) {
require(VAR72);
FUN27(msg.sender, VAR54, VAR26);
return true;
}
function FUN5(address VAR25, address VAR54, uint256 VAR26
) public returns (bool VAR83) {
if (msg.sender != VAR58) {
require(VAR72);
require(VAR70[VAR25][msg.sender] >= VAR26);
VAR70[VAR25][msg.sender] -= VAR26;
}
FUN27(VAR25, VAR54, VAR26);
return true;
}
function FUN27(address VAR25, address VAR54, uint VAR26
) internal {
if (VAR26 == 0) {
Transfer(VAR25, VAR54, VAR26);
return;
}
require(VAR67 < VAR81.VAR82);
require((VAR54 != 0) && (VAR54 != address(this)));
var VAR84 = FUN28(VAR25, VAR81.VAR82);
require(VAR84 >= VAR26);
if (FUN29(VAR58)) {
require(FUN30(VAR58).FUN21(VAR25, VAR54, VAR26));
}
FUN31(VAR69[VAR25], VAR84 - VAR26);
var VAR85 = FUN28(VAR54, VAR81.VAR82);
require(VAR85 + VAR26 >= VAR85);
FUN31(VAR69[VAR54], VAR85 + VAR26);
Transfer(VAR25, VAR54, VAR26);
}
function FUN32(address VAR53) public constant returns (uint256 VAR4) {
return FUN28(VAR53, VAR81.VAR82);
}
function FUN33(address VAR55, uint256 VAR26) public returns (bool VAR83) {
require(VAR72);
if (FUN29(VAR58)) {
require(FUN30(VAR58).FUN22(msg.sender, VAR55, VAR26));
}
VAR70[msg.sender][VAR55] = VAR26;
FUN34(msg.sender, VAR55, VAR26);
return true;
}
function FUN35(address VAR53, address VAR55
) public constant returns (uint256 VAR86) {
return VAR70[VAR53][VAR55];
}
function FUN36(address VAR55, uint256 VAR26, bytes VAR87
) public returns (bool VAR83) {
require(FUN33(VAR55, VAR26));
FUN37(VAR55).FUN4(
msg.sender,
VAR26,
this,
VAR87
);
return true;
}
function FUN38() public constant returns (uint) {
return FUN39(VAR81.VAR82);
}
function FUN28(address VAR53, uint VAR88) public constant
returns (uint) {
if ((VAR69[VAR53].VAR89 == 0)
|| (VAR69[VAR53][0].VAR65 > VAR88)) {
if (address(VAR66) != 0) {
return VAR66.FUN28(VAR53, FUN40(VAR88, VAR67));
} else {
return 0;
}
} else {
return FUN41(VAR69[VAR53], VAR88);
}
}
function FUN39(uint VAR88) public constant returns(uint) {
if ((VAR71.VAR89 == 0)
|| (VAR71[0].VAR65 > VAR88)) {
if (address(VAR66) != 0) {
return VAR66.FUN39(FUN40(VAR88, VAR67));
} else {
return 0;
}
} else {
return FUN41(VAR71, VAR88);
}
}
function FUN42(
string VAR90,
uint8 VAR91,
string VAR92,
uint VAR93,
bool VAR80
) public returns(address) {
if (VAR93 == 0) VAR93 = VAR81.VAR82;
Pinakion VAR94 = VAR73.FUN42(
this,
VAR93,
VAR90,
VAR91,
VAR92,
VAR80
);
VAR94.FUN24(msg.sender);
FUN43(address(VAR94), VAR93);
return address(VAR94);
}
function FUN44(address VAR53, uint VAR26
) public onlyController returns (bool) {
uint VAR95 = FUN38();
require(VAR95 + VAR26 >= VAR95);
uint VAR85 = FUN32(VAR53);
require(VAR85 + VAR26 >= VAR85);
FUN31(VAR71, VAR95 + VAR26);
FUN31(VAR69[VAR53], VAR85 + VAR26);
Transfer(0, VAR53, VAR26);
return true;
}
function FUN45(address VAR53, uint VAR26
) onlyController public returns (bool) {
uint VAR95 = FUN38();
require(VAR95 >= VAR26);
uint VAR84 = FUN32(VAR53);
require(VAR84 >= VAR26);
FUN31(VAR71, VAR95 - VAR26);
FUN31(VAR69[VAR53], VAR84 - VAR26);
Transfer(VAR53, 0, VAR26);
return true;
}
function FUN46(bool VAR80) public VAR57 {
VAR72 = VAR80;
}
function FUN41(VAR64[] storage VAR96, uint VAR97
) constant internal returns (uint) {
if (VAR96.VAR89 == 0) return 0;
if (VAR97 >= VAR96[VAR96.VAR89-1].VAR65)
return VAR96[VAR96.VAR89-1].value;
if (VAR97 < VAR96[0].VAR65) return 0;
uint VAR98 = 0;
uint VAR99 = VAR96.VAR89-1;
while (VAR99 > VAR98) {
uint VAR100 = (VAR99 + VAR98 + 1)/ 2;
if (VAR96[VAR100].VAR65<=VAR97) {
VAR98 = VAR100;
} else {
VAR99 = VAR100-1;
}
}
return VAR96[VAR98].value;
}
function FUN31(VAR64[] storage VAR96, uint VAR101
) internal  {
if ((VAR96.VAR89 == 0)
|| (VAR96[VAR96.VAR89 -1].VAR65 < VAR81.VAR82)) {
Checkpoint storage VAR102 = VAR96[ VAR96.VAR89++ ];
VAR102.VAR65 =  uint128(VAR81.VAR82);
VAR102.value = uint128(VAR101);
} else {
Checkpoint storage VAR103 = VAR96[VAR96.VAR89-1];
VAR103.value = uint128(VAR101);
}
}
function FUN29(address VAR104) constant internal returns(bool) {
uint VAR105;
if (VAR104 == 0) return false;
VAR106 {
VAR105 := FUN47(VAR104)
}
return VAR105>0;
}
function FUN40(uint VAR107, uint VAR108) pure internal returns (uint) {
return VAR107 < VAR108 ? VAR107 : VAR108;
}
function () public payable {
require(FUN29(VAR58));
require(FUN30(VAR58).VAR109.value(msg.value)(msg.sender));
}
function FUN48(address VAR50) public VAR57 {
if (VAR50 == 0x0) {
VAR58.transfer(this.VAR4);
return;
}
Pinakion VAR110 = FUN25(VAR50);
uint VAR4 = VAR110.FUN32(this);
VAR110.transfer(VAR58, VAR4);
FUN49(VAR50, VAR58, VAR4);
}
event FUN49(address indexed VAR50, address indexed VAR111, uint VAR26);
event Transfer(address indexed VAR25, address indexed VAR54, uint256 VAR26);
event FUN43(address indexed VAR112, uint VAR93);
event FUN34(
address indexed VAR53,
address indexed VAR55,
uint256 VAR26
);
}
contract VAR113 {
function FUN42(
address VAR75,
uint VAR93,
string VAR77,
uint8 VAR78,
string VAR79,
bool VAR80
) public returns (VAR114) {
Pinakion VAR115 = VAR116 FUN25(
this,
VAR75,
VAR93,
VAR77,
VAR78,
VAR79,
VAR80
);
VAR115.FUN24(msg.sender);
return VAR115;
}
}
contract VAR117{
function FUN50(uint VAR97) public payable;
function FUN51(uint VAR97) public payable {
FUN50(VAR97);
}
function FUN52(uint VAR97) public returns (uint VAR118);
function FUN53(uint VAR97) public returns (uint VAR118) {
uint VAR119=FUN52(VAR97);
if (VAR119==0)
return 0;
else
return uint(FUN54(msg.sender,VAR119));
}
}
contract BlockHashRNG is VAR117 {
mapping (uint => uint) public VAR120;
mapping (uint => uint) public VAR121;
function FUN50(uint VAR97) public payable { VAR121[VAR97]+=msg.value; }
function FUN52(uint VAR97) public returns (uint VAR118) {
VAR118=VAR120[VAR97];
if (VAR118==0){
FUN55(VAR97);
return VAR120[VAR97];
}
else
return VAR118;
}
function FUN55(uint VAR97) public {
if (FUN56(VAR97) != 0x0)
VAR120[VAR97] = uint(FUN56(VAR97));
if (VAR120[VAR97] != 0) {
uint VAR122 = VAR121[VAR97];
VAR121[VAR97] = 0;
msg.sender.FUN57(VAR122);
}
}
}
contract BlockHashRNGFallback is VAR123 {
function FUN55(uint VAR97) public {
if (VAR97<VAR81.VAR82 && VAR120[VAR97]==0) {
if (FUN56(VAR97)!=0x0)
VAR120[VAR97]=uint(FUN56(VAR97));
else
VAR120[VAR97]=uint(FUN56(VAR81.VAR82-1));
}
if (VAR120[VAR97] != 0) {
uint VAR122=VAR121[VAR97];
VAR121[VAR97]=0;
msg.sender.FUN57(VAR122);
}
}
}
contract VAR124{
Arbitrator public VAR125;
bytes public VAR126;
modifier VAR127 {require(msg.sender==address(VAR125)); VAR14;}
event FUN58(Arbitrator indexed VAR128, uint indexed VAR21, uint VAR129);
event FUN59(uint indexed VAR130, string VAR131);
event FUN60(Arbitrator indexed VAR128, uint indexed VAR21, uint VAR130);
event FUN61(Arbitrator indexed VAR128, uint indexed VAR21, address VAR132, string VAR131);
constructor(Arbitrator VAR128, bytes VAR133) public {
VAR125 = VAR128;
VAR126 = VAR133;
}
function FUN62(uint VAR21, uint VAR129) public VAR127 {
emit FUN58(FUN63(msg.sender),VAR21,VAR129);
FUN64(VAR21,VAR129);
}
function FUN64(uint VAR21, uint VAR129) internal;
}
contract VAR31{
enum VAR32 {VAR134, VAR135, VAR33}
modifier FUN65(bytes VAR87) {require(msg.value>=FUN66(VAR87)); VAR14;}
modifier FUN67(uint VAR21, bytes VAR87) {require(msg.value>=FUN68(VAR21, VAR87)); VAR14;}
event FUN69(uint VAR21);
event FUN70(uint indexed VAR21, Arbitrable VAR136);
event FUN71(uint indexed VAR21, Arbitrable VAR136);
function FUN72(uint VAR137, bytes VAR87) public FUN65(VAR87) payable returns(uint VAR5)  {}
function FUN66(bytes VAR87) public constant returns(uint VAR138);
function FUN73(uint VAR21, bytes VAR87) public FUN67(VAR21,VAR87) payable {
emit FUN71(VAR21, FUN74(msg.sender));
}
function FUN68(uint VAR21, bytes VAR87) public constant returns(uint VAR138);
function FUN11(uint VAR21) public constant returns(DisputeStatus VAR139);
function FUN14(uint VAR21) public constant returns(uint VAR140);
}
contract Kleros is VAR31, VAR48 {
Pinakion public VAR2;
uint public constant VAR141 = (2**256 - 2) / 2;
RNG public VAR142;
uint public VAR143 = 0.05 VAR144;
uint16 public VAR145 = 3;
uint public VAR146 = 0.1 * 1e18;
uint[5] public VAR147;
uint public VAR148 = 2000;
uint constant VAR149 = 1e4;
uint public VAR9 = 5;
address public VAR150;
uint public VAR151 = 1;
uint public VAR152;
uint public VAR153;
uint public VAR154;
uint public VAR120;
enum VAR155 {
VAR156,
VAR157,
VAR158,
VAR159,
VAR160
}
Period public VAR161;
struct VAR162 {
uint VAR4;
uint VAR163;
uint VAR164;
uint VAR165;
uint VAR166;
}
mapping (address => VAR162) public VAR167;
struct VAR158 {
address VAR168;
uint VAR140;
}
struct VAR169 {
uint VAR37;
uint VAR170;
mapping (uint => uint) VAR171;
}
enum VAR172 {
VAR173,
VAR174,
VAR175,
VAR176
}
struct VAR177 {
Arbitrable VAR178;
uint VAR151;
uint VAR34;
uint VAR35;
uint16 VAR179;
uint VAR143;
DisputeState VAR180;
VAR158[][] VAR181;
VAR169[] VAR182;
mapping (address => uint) VAR183;
uint VAR184;
VAR185[] VAR186;
}
enum VAR187 {
VAR188,
VAR189,
VAR190,
VAR191
}
struct VAR185 {
uint VAR41;
uint VAR42;
uint VAR192;
uint VAR193;
uint VAR194;
RepartitionStage VAR195;
}
VAR177[] public VAR196;
event FUN75(Period VAR197, uint indexed VAR198);
event FUN76(address indexed VAR13, uint VAR21, int VAR26);
event FUN77(address indexed VAR13, uint VAR21, uint VAR26);
modifier FUN1(address VAR13) {require(msg.sender == VAR13); VAR14;}
modifier FUN78(Period VAR197) {require(VAR161 == VAR197); VAR14;}
modifier onlyGovernor() {require(msg.sender == VAR150); VAR14;}
constructor(Pinakion VAR19, RNG VAR199, uint[5] VAR200, address VAR201) public {
VAR2 = VAR19;
VAR142 = VAR199;
VAR152 = VAR202;
VAR147 = VAR200;
VAR150 = VAR201;
}
function FUN4(address VAR25, uint VAR26, address, bytes) public FUN1(VAR2) {
require(VAR2.FUN5(VAR25, this, VAR26));
VAR167[VAR25].VAR4 += VAR26;
}
function FUN79(uint VAR101) public {
Juror storage VAR16 = VAR167[msg.sender];
require(VAR16.VAR163 <= VAR16.VAR4);
require(VAR101 <= VAR16.VAR4-VAR16.VAR163);
require(VAR16.VAR164 != VAR151);
VAR16.VAR4 -= VAR101;
require(VAR2.transfer(msg.sender,VAR101));
}
function FUN80() public {
require(VAR202-VAR152 >= VAR147[uint8(VAR161)]);
if (VAR161 == VAR155.VAR156) {
VAR154 = VAR81.VAR82 + 1;
VAR142.FUN51(VAR154);
VAR161 = VAR155.VAR157;
} else if (VAR161 == VAR155.VAR157) {
VAR120 = VAR142.FUN53(VAR154);
require(VAR120 != 0);
VAR161 = VAR155.VAR158;
} else if (VAR161 == VAR155.VAR158) {
VAR161 = VAR155.VAR159;
} else if (VAR161 == VAR155.VAR159) {
VAR161 = VAR155.VAR160;
} else if (VAR161 == VAR155.VAR160) {
VAR161 = VAR155.VAR156;
++VAR151;
VAR153 = 0;
VAR154 = 0;
VAR120 = 0;
}
VAR152 = VAR202;
FUN75(VAR161, VAR151);
}
function FUN81(uint VAR101) public FUN78(VAR155.VAR156) {
Juror storage VAR16 = VAR167[msg.sender];
require(VAR101 <= VAR16.VAR4);
require(VAR101 >= VAR146);
require(VAR16.VAR164 != VAR151);
VAR16.VAR164 = VAR151;
VAR16.VAR165 = VAR153;
VAR153 += VAR101;
VAR16.VAR166 = VAR153;
}
function FUN82(uint VAR21, uint VAR129, uint[] VAR203) public FUN78(VAR155.VAR158) {
Dispute storage VAR204 = VAR196[VAR21];
Juror storage VAR16 = VAR167[msg.sender];
VoteCounter storage VAR182 = VAR204.VAR182[VAR204.VAR34];
require(VAR204.VAR183[msg.sender] != VAR151);
require(VAR129 <= VAR204.VAR35);
require(FUN83(msg.sender, VAR21, VAR203));
VAR204.VAR183[msg.sender] = VAR151;
VAR182.VAR171[VAR129] += VAR203.VAR89;
if (VAR182.VAR170 < VAR182.VAR171[VAR129]) {
VAR182.VAR170 = VAR182.VAR171[VAR129];
VAR182.VAR37 = VAR129;
} else if (VAR182.VAR170==VAR182.VAR171[VAR129] && VAR203.VAR89!=0) {
VAR182.VAR37 = 0;
}
for (uint VAR38 = 0; VAR38 < VAR203.VAR89; ++VAR38) {
VAR204.VAR181[VAR204.VAR34].FUN84(FUN85({
VAR168: msg.sender,
VAR140: VAR129
}));
}
VAR16.VAR163 += VAR203.VAR89 * FUN15();
uint VAR205 = VAR203.VAR89 * VAR204.VAR143;
msg.sender.transfer(VAR205);
FUN77(msg.sender, VAR21, VAR205);
}
function FUN86(address VAR206, uint VAR21, uint[] VAR203) public {
Dispute storage VAR204 = VAR196[VAR21];
Juror storage VAR207 = VAR167[VAR206];
require(VAR161 > VAR155.VAR158);
require(VAR204.VAR183[VAR206] != VAR151);
VAR204.VAR183[VAR206] = VAR151;
require(FUN83(VAR206, VAR21, VAR203));
uint VAR208 = VAR203.VAR89 * VAR146 * 2 * VAR148 / VAR149;
VAR208 = (VAR208 < VAR207.VAR4) ? VAR208 : VAR207.VAR4;
VAR207.VAR4 -= VAR208;
FUN76(VAR206, VAR21, -int(VAR208));
VAR167[msg.sender].VAR4 += VAR208 / 2;
FUN76(msg.sender, VAR21, int(VAR208 / 2));
VAR167[VAR150].VAR4 += VAR208 / 2;
FUN76(VAR150, VAR21, int(VAR208 / 2));
msg.sender.transfer(VAR203.VAR89*VAR204.VAR143);
}
function FUN87(uint VAR21) public FUN78(VAR155.VAR160) {
Dispute storage VAR204 = VAR196[VAR21];
require(VAR204.VAR180 == VAR172.VAR173);
require(VAR204.VAR151+VAR204.VAR34 <= VAR151);
uint VAR37 = VAR204.VAR182[VAR204.VAR34].VAR37;
uint VAR36 = FUN15();
for (uint VAR38 = 0; VAR38 <= VAR204.VAR34; ++VAR38) {
if (VAR37!=0 || (VAR204.VAR182[VAR204.VAR34].VAR171[0] == VAR204.VAR182[VAR204.VAR34].VAR170)) {
uint VAR41 = 0;
uint VAR42 = 0;
for (uint VAR43 = 0; VAR43 < VAR204.VAR181[VAR38].VAR89; ++VAR43) {
Vote storage VAR209 = VAR204.VAR181[VAR38][VAR43];
if (VAR209.VAR140 != VAR37) {
Juror storage VAR16 = VAR167[VAR209.VAR168];
uint VAR210 = VAR36<VAR16.VAR4 ? VAR36 : VAR16.VAR4;
VAR16.VAR4 -= VAR210;
FUN76(VAR209.VAR168, VAR21, int(-VAR210));
VAR41 += VAR210;
} else {
++VAR42;
}
}
if (VAR42 == 0) {
VAR167[VAR150].VAR4 += VAR41;
FUN76(VAR150, VAR21, int(VAR41));
} else {
uint VAR46 = VAR41 / VAR42;
for (VAR43 = 0; VAR43 < VAR204.VAR181[VAR38].VAR89; ++VAR43) {
VAR209 = VAR204.VAR181[VAR38][VAR43];
if (VAR209.VAR140 == VAR37) {
VAR16 = VAR167[VAR209.VAR168];
VAR16.VAR4 += VAR46;
FUN76(VAR209.VAR168, VAR21, int(VAR46));
}
}
}
}
for (VAR43 = 0; VAR43 < VAR204.VAR181[VAR38].VAR89; ++VAR43) {
VAR209 = VAR204.VAR181[VAR38][VAR43];
VAR16 = VAR167[VAR209.VAR168];
VAR16.VAR163 -= VAR36;
}
}
VAR204.VAR180 = VAR172.VAR175;
}
function FUN88(uint VAR21, uint VAR211) public FUN78(VAR155.VAR160) {
Dispute storage VAR204 = VAR196[VAR21];
require(VAR204.VAR180 <= VAR172.VAR174);
require(VAR204.VAR151+VAR204.VAR34 <= VAR151);
VAR204.VAR180 = VAR172.VAR174;
uint VAR37 = VAR204.VAR182[VAR204.VAR34].VAR37;
uint VAR36 = FUN15();
uint VAR212 = 0;
for (uint VAR38 = VAR204.VAR184; VAR38 <= VAR204.VAR34; ++VAR38) {
if (VAR204.VAR186.VAR89 < VAR38+1) {
VAR204.VAR186.VAR89++;
}
if (VAR37==0 && (VAR204.VAR182[VAR204.VAR34].VAR171[0] != VAR204.VAR182[VAR204.VAR34].VAR170)) {
VAR204.VAR186[VAR38].VAR195 = VAR187.VAR190;
}
if (VAR204.VAR186[VAR38].VAR195 == VAR187.VAR188) {
for (uint VAR43 = VAR204.VAR186[VAR38].VAR192; VAR43 < VAR204.VAR181[VAR38].VAR89; ++VAR43) {
if (VAR212 >= VAR211) {
return;
}
Vote storage VAR209 = VAR204.VAR181[VAR38][VAR43];
if (VAR209.VAR140 != VAR37) {
Juror storage VAR16 = VAR167[VAR209.VAR168];
uint VAR210 = VAR36<VAR16.VAR4 ? VAR36 : VAR16.VAR4;
VAR16.VAR4 -= VAR210;
FUN76(VAR209.VAR168, VAR21, int(-VAR210));
VAR204.VAR186[VAR38].VAR41 += VAR210;
} else {
++VAR204.VAR186[VAR38].VAR42;
}
++VAR204.VAR186[VAR38].VAR192;
++VAR212;
}
VAR204.VAR186[VAR38].VAR195 = VAR187.VAR189;
}
if (VAR204.VAR186[VAR38].VAR195 == VAR187.VAR189) {
if (VAR204.VAR186[VAR38].VAR42 == 0) {
VAR167[VAR150].VAR4 += VAR204.VAR186[VAR38].VAR41;
FUN76(VAR150, VAR21, int(VAR204.VAR186[VAR38].VAR41));
VAR204.VAR186[VAR38].VAR195 = VAR187.VAR190;
} else {
uint VAR46 = VAR204.VAR186[VAR38].VAR41 / VAR204.VAR186[VAR38].VAR42;
for (VAR43 = VAR204.VAR186[VAR38].VAR193; VAR43 < VAR204.VAR181[VAR38].VAR89; ++VAR43) {
if (VAR212 >= VAR211) {
return;
}
VAR209 = VAR204.VAR181[VAR38][VAR43];
if (VAR209.VAR140 == VAR37) {
VAR16 = VAR167[VAR209.VAR168];
VAR16.VAR4 += VAR46;
FUN76(VAR209.VAR168, VAR21, int(VAR46));
}
++VAR212;
++VAR204.VAR186[VAR38].VAR193;
}
VAR204.VAR186[VAR38].VAR195 = VAR187.VAR190;
}
}
if (VAR204.VAR186[VAR38].VAR195 == VAR187.VAR190) {
for (VAR43 = VAR204.VAR186[VAR38].VAR194; VAR43 < VAR204.VAR181[VAR38].VAR89; ++VAR43) {
if (VAR212 >= VAR211) {
return;
}
VAR209 = VAR204.VAR181[VAR38][VAR43];
VAR16 = VAR167[VAR209.VAR168];
VAR16.VAR163 -= VAR36;
++VAR212;
++VAR204.VAR186[VAR38].VAR194;
}
VAR204.VAR186[VAR38].VAR195 = VAR187.VAR191;
}
if (VAR204.VAR186[VAR38].VAR195 == VAR187.VAR191) {
++VAR204.VAR184;
}
}
VAR204.VAR180 = VAR172.VAR175;
}
function FUN89(uint VAR21) public view returns (uint VAR213) {
Dispute storage VAR204 = VAR196[VAR21];
return (VAR204.VAR179 + 1) * 2**VAR204.VAR34 - 1;
}
function FUN83(address VAR206, uint VAR21, uint[] VAR203) public view returns (bool VAR214) {
uint VAR215 = 0;
Juror storage VAR16 = VAR167[VAR206];
Dispute storage VAR204 = VAR196[VAR21];
uint VAR213 = FUN89(VAR21);
if (VAR16.VAR164 != VAR151) return false;
if (VAR204.VAR151+VAR204.VAR34 != VAR151) return false;
if (VAR161 <= VAR155.VAR157) return false;
for (uint VAR38 = 0; VAR38 < VAR203.VAR89; ++VAR38) {
if (VAR203[VAR38] <= VAR215) return false;
VAR215 = VAR203[VAR38];
if (VAR215 > VAR213) return false;
uint VAR216 = uint(FUN54(VAR120, VAR21, VAR215)) % VAR153;
require(VAR216 >= VAR16.VAR165);
require(VAR216 < VAR16.VAR166);
}
return true;
}
function FUN72(uint VAR137, bytes VAR87) public payable returns (uint VAR5) {
uint16 VAR213 = FUN90(VAR87);
require(msg.value >= FUN66(VAR87));
VAR5 = VAR196.VAR89++;
Dispute storage VAR204 = VAR196[VAR5];
VAR204.VAR178 = FUN74(msg.sender);
if (VAR161 < VAR155.VAR157)
VAR204.VAR151 = VAR151;
else
VAR204.VAR151 = VAR151+1;
VAR204.VAR35 = VAR137;
VAR204.VAR179 = VAR213;
VAR204.VAR143 = VAR143;
VAR204.VAR181.VAR89++;
VAR204.VAR182.VAR89++;
FUN70(VAR5, FUN74(msg.sender));
return VAR5;
}
function FUN73(uint VAR21, bytes VAR87) public payable FUN78(VAR155.VAR159) {
super.FUN73(VAR21,VAR87);
Dispute storage VAR204 = VAR196[VAR21];
require(msg.value >= FUN68(VAR21, VAR87));
require(VAR204.VAR151+VAR204.VAR34 == VAR151);
require(VAR204.VAR178 == msg.sender);
VAR204.VAR34++;
VAR204.VAR181.VAR89++;
VAR204.VAR182.VAR89++;
}
function FUN64(uint VAR5) public {
Dispute storage VAR204 = VAR196[VAR5];
require(VAR204.VAR180 == VAR172.VAR175);
VAR204.VAR180 = VAR172.VAR176;
VAR204.VAR178.FUN62(VAR5, VAR204.VAR182[VAR204.VAR34].VAR37);
}
function FUN66(bytes VAR87) public view returns (uint VAR138) {
return FUN90(VAR87) * VAR143;
}
function FUN68(uint VAR21, bytes VAR87) public view returns (uint VAR138) {
Dispute storage VAR204 = VAR196[VAR21];
if(VAR204.VAR34 >= VAR9) return VAR141;
return (2*FUN89(VAR21) + 1) * VAR204.VAR143;
}
function FUN90(bytes VAR87) internal view returns (uint16 VAR213) {
if (VAR87.VAR89 < 2)
return VAR145;
else
return (uint16(VAR87[0]) << 8) + uint16(VAR87[1]);
}
function FUN15() public view returns (uint VAR217) {
return (VAR148 * VAR146) / VAR149;
}
function FUN19(uint VAR21, uint VAR218, uint VAR219) public view returns (address VAR168) {
return VAR196[VAR21].VAR181[VAR218][VAR219].VAR168;
}
function FUN18(uint VAR21, uint VAR218, uint VAR219) public view returns (uint VAR140) {
return VAR196[VAR21].VAR181[VAR218][VAR219].VAR140;
}
function FUN16(uint VAR21, uint VAR218) public view returns (uint VAR37) {
return VAR196[VAR21].VAR182[VAR218].VAR37;
}
function FUN91(uint VAR21, uint VAR218) public view returns (uint VAR170) {
return VAR196[VAR21].VAR182[VAR218].VAR170;
}
function FUN17(uint VAR21, uint VAR218, uint VAR220) public view returns (uint VAR171) {
return VAR196[VAR21].VAR182[VAR218].VAR171[VAR220];
}
function FUN92(uint VAR21, address VAR27) public view returns (uint VAR183) {
return VAR196[VAR21].VAR183[VAR27];
}
function FUN93(uint VAR21, address VAR27, uint VAR221) public view returns (bool VAR222) {
Dispute storage VAR204 = VAR196[VAR21];
Juror storage VAR16 = VAR167[VAR27];
if (VAR16.VAR164 != VAR151
|| (VAR204.VAR151+VAR204.VAR34 != VAR151)
|| VAR161<=VAR155.VAR157
|| VAR221>FUN89(VAR21)
|| VAR221==0
|| VAR153==0
) {
return false;
} else {
uint VAR216 = uint(FUN54(VAR120,VAR21,VAR221)) % VAR153;
return (VAR216 >= VAR16.VAR165) && (VAR216 < VAR16.VAR166);
}
}
function FUN14(uint VAR21) public view returns (uint VAR140) {
Dispute storage VAR204 = VAR196[VAR21];
return VAR204.VAR182[VAR204.VAR34].VAR37;
}
function FUN11(uint VAR21) public view returns (DisputeStatus VAR139) {
Dispute storage VAR204 = VAR196[VAR21];
if (VAR204.VAR151+VAR204.VAR34 < VAR151)
return VAR32.VAR33;
else if(VAR204.VAR151+VAR204.VAR34 == VAR151) {
if (VAR204.VAR180 == VAR172.VAR173) {
if (VAR161 < VAR155.VAR159)
return VAR32.VAR134;
else if (VAR161 == VAR155.VAR159)
return VAR32.VAR135;
else return VAR32.VAR33;
} else return VAR32.VAR33;
} else return VAR32.VAR134;
}
function FUN94(bytes32 VAR51, uint VAR101, address VAR223) public onlyGovernor {
VAR223.call.value(VAR101)(VAR51);
}
function FUN95(RNG VAR199) public onlyGovernor {
VAR142 = VAR199;
}
function FUN96(uint VAR224) public onlyGovernor {
VAR143 = VAR224;
}
function FUN97(uint16 VAR225) public onlyGovernor {
VAR145 = VAR225;
}
function FUN98(uint VAR226) public onlyGovernor {
VAR146 = VAR226;
}
function FUN99(uint[5] VAR200) public onlyGovernor {
VAR147 = VAR200;
}
function FUN100(uint VAR227) public onlyGovernor {
VAR148 = VAR227;
}
function FUN101(uint VAR24) public onlyGovernor {
VAR9 = VAR24;
}
function FUN102(address VAR201) public onlyGovernor {
VAR150 = VAR201;
}
}
1
---------------------------------
37 0x37dad2f4f477b085c5e91a10d6a5eab6dab6a445.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
bool public VAR42;
bool public VAR43;
bool public VAR44;
address public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => uint256) public VAR47;
mapping (address => bool) public VAR48;
uint public VAR49;
enum VAR50{VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57, VAR58}
event FUN26(address VAR59, uint VAR60, uint VAR21, uint128 VAR61);
event FUN27(address VAR59, uint VAR60);
event FUN28(bool VAR43, bool VAR44, address VAR45);
event FUN29(address VAR62, bool VAR63);
event FUN30(uint VAR38);
function FUN31(address VAR64, PricingStrategy VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR69) {
VAR9 = msg.sender;
VAR32 = FUN32(VAR64);
FUN33(VAR65);
VAR35 = VAR66;
if(VAR35 == 0) {
throw;
}
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR68 == 0) {
throw;
}
VAR38 = VAR68;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR69;
}
function() payable {
throw;
}
function FUN34(address VAR70, uint128 VAR61) stopInEmergency private {
if(FUN35() == VAR50.VAR53) {
if(!VAR48[VAR70]) {
throw;
}
} else if(FUN35() == VAR50.VAR54) {
} else {
throw;
}
uint VAR60 = msg.value;
uint VAR21 = VAR33.FUN18(VAR60, VAR17, VAR18, msg.sender, VAR32.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR46[VAR70] == 0) {
VAR39++;
}
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR60, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR70, VAR21);
if(!VAR35.FUN39(VAR60)) throw;
FUN26(VAR70, VAR60, VAR21, VAR61);
}
function FUN40(address VAR70, uint VAR71, uint VAR72) public onlyOwner {
uint VAR21 = VAR71 * 10**VAR32.FUN36();
uint VAR60 = VAR72 * VAR71;
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
FUN38(VAR70, VAR21);
FUN26(VAR70, VAR60, VAR21, 0);
}
function FUN41(address VAR62, uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
bytes32 VAR76 = FUN42(VAR62);
if (FUN43(VAR76, VAR73, VAR74, VAR75) != VAR45) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN44(address VAR62, uint128 VAR61) public payable {
if(VAR44) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN45(address VAR62) public payable {
if(VAR43) throw;
if(VAR44) throw;
FUN34(VAR62, 0);
}
function FUN46(uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
FUN41(msg.sender, VAR61, VAR73, VAR74, VAR75);
}
function FUN47(uint128 VAR61) public payable {
FUN44(msg.sender, VAR61);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR50.VAR55) onlyOwner VAR13 {
if(VAR42) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN20();
}
VAR42 = true;
}
function FUN51(FinalizeAgent VAR62) onlyOwner {
VAR34 = VAR62;
if(!VAR34.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR43 = value;
FUN28(VAR43, VAR44, VAR45);
}
function FUN53(bool value, address VAR77) onlyOwner {
VAR44 = value;
VAR45 = VAR77;
FUN28(VAR43, VAR44, VAR45);
}
function FUN54(address VAR62, bool VAR63) onlyOwner {
VAR48[VAR62] = VAR63;
FUN29(VAR62, VAR63);
}
function FUN55(uint VAR78) onlyOwner {
if(VAR79 > VAR78) {
throw;
}
VAR38 = VAR78;
FUN30(VAR38);
}
function FUN33(PricingStrategy VAR65) onlyOwner {
VAR33 = VAR65;
if(!VAR33.FUN16()) {
throw;
}
}
function FUN56(address VAR62) public onlyOwner {
if(VAR39 > VAR31) {
throw;
}
VAR35 = VAR62;
}
function FUN57() public payable FUN50(VAR50.VAR56) {
if(msg.value == 0) throw;
VAR40 = VAR40.FUN11(msg.value);
}
function FUN58() public FUN50(VAR50.VAR58) {
uint256 VAR80 = VAR46[msg.sender];
if (VAR80 == 0) throw;
VAR46[msg.sender] = 0;
VAR41 = VAR41.FUN11(VAR80);
FUN27(msg.sender, VAR80);
if (!msg.sender.FUN39(VAR80)) throw;
}
function FUN59() public constant returns (bool VAR81) {
return VAR17 >= VAR36;
}
function FUN60() public constant returns (bool VAR82) {
return VAR34.FUN17();
}
function FUN61() public constant returns (bool VAR82) {
return VAR33.FUN17(address(this));
}
function FUN35() public constant returns (VAR50) {
if(VAR42) return VAR50.VAR57;
else if (address(VAR34) == 0) return VAR50.VAR52;
else if (!VAR34.FUN17()) return VAR50.VAR52;
else if (!VAR33.FUN17(address(this))) return VAR50.VAR52;
else if (VAR83.VAR84 < VAR37) return VAR50.VAR53;
else if (VAR83.VAR84 <= VAR38 && !FUN62()) return VAR50.VAR54;
else if (FUN59()) return VAR50.VAR55;
else if (!FUN59() && VAR17 > 0 && VAR40 >= VAR17) return VAR50.VAR58;
else return VAR50.VAR56;
}
function FUN63(uint VAR85) onlyOwner {
VAR49 = VAR85;
}
function FUN64() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR86) {
if(FUN35() != VAR86) throw;
VAR10;
}
//
//
function FUN37(uint VAR60, uint VAR21, uint VAR87, uint VAR88) constant returns (bool VAR89);
function FUN62() public constant returns (bool);
function FUN38(address VAR70, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN65(address VAR70, uint VAR90);
mapping(address => uint) VAR91;
mapping (address => mapping (address => uint)) VAR92;
function FUN66() public constant returns (bool VAR93) {
return true;
}
function transfer(address VAR94, uint VAR95) returns (bool VAR96) {
VAR91[msg.sender] = FUN3(VAR91[msg.sender], VAR95);
VAR91[VAR94] = FUN4(VAR91[VAR94], VAR95);
Transfer(msg.sender, VAR94, VAR95);
return true;
}
function FUN23(address VAR97, address VAR94, uint VAR95) returns (bool VAR96) {
uint VAR98 = VAR92[VAR97][msg.sender];
VAR91[VAR94] = FUN4(VAR91[VAR94], VAR95);
VAR91[VAR97] = FUN3(VAR91[VAR97], VAR95);
VAR92[VAR97][msg.sender] = FUN3(VAR98, VAR95);
Transfer(VAR97, VAR94, VAR95);
return true;
}
function FUN21(address VAR99) constant returns (uint VAR100) {
return VAR91[VAR99];
}
function FUN24(address VAR101, uint VAR95) returns (bool VAR96) {
if ((VAR95 != 0) && (VAR92[msg.sender][VAR101] != 0)) throw;
VAR92[msg.sender][VAR101] = VAR95;
FUN25(msg.sender, VAR101, VAR95);
return true;
}
function FUN22(address VAR99, address VAR101) constant returns (uint VAR102) {
return VAR92[VAR99][VAR101];
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR39;
uint public VAR87;
address[] public VAR103;
mapping(address => uint) public VAR91;
mapping(address => uint) public VAR104;
uint public VAR105;
uint public VAR106;
uint public VAR107;
uint public VAR108;
uint public VAR109;
uint public VAR110;
uint public VAR111;
Crowdsale public VAR16;
enum VAR50{VAR51, VAR54, VAR112, VAR58}
event FUN26(address VAR59, uint value, uint128 VAR61);
event FUN67(address VAR59, uint value);
event FUN68(uint VAR113);
event FUN69(address VAR103, uint VAR113);
function FUN70(address VAR99, uint VAR114, uint VAR115, uint VAR116, uint VAR117) {
VAR9 = VAR99;
if(VAR114 == 0) {
throw;
}
if(VAR115 == 0) {
throw;
}
if(VAR116 == 0) {
throw;
}
VAR106 = VAR115;
VAR107 = VAR116;
VAR108 = VAR117;
VAR105 = VAR114;
}
function FUN71() public constant returns(VAR118) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN72();
}
function FUN45(uint128 VAR61) private {
if(FUN35() != VAR50.VAR54) throw;
if(msg.value == 0) throw;
address VAR59 = msg.sender;
bool VAR119 = VAR91[VAR59] > 0;
VAR91[VAR59] = FUN4(VAR91[VAR59], msg.value);
if(VAR91[VAR59] < VAR106 || VAR91[VAR59] > VAR107) {
throw;
}
if(!VAR119) {
VAR103.FUN73(VAR59);
VAR39++;
}
VAR87 = FUN4(VAR87, msg.value);
if(VAR87 > VAR108) {
throw;
}
FUN26(VAR59, msg.value, VAR61);
}
function FUN74(uint128 VAR61) public stopInEmergency payable {
FUN45(VAR61);
}
function FUN75() public stopInEmergency payable {
FUN45(0x0);
}
function FUN76() stopInEmergency public {
if(FUN35() != VAR50.VAR54) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR120.value(VAR87)(address(this));
VAR109 = FUN71().FUN21(address(this));
if(VAR109 == 0) {
throw;
}
FUN68(VAR109);
}
function FUN77(address VAR59) public constant returns (uint) {
if(FUN35() != VAR50.VAR112) {
throw;
}
return FUN1(VAR91[VAR59], VAR109) / VAR87;
}
function FUN78(address VAR59) public constant returns (uint) {
return FUN3(FUN77(VAR59), VAR104[VAR59]);
}
function FUN79() {
FUN80(FUN78(msg.sender));
}
function FUN80(uint VAR90) VAR13 {
address VAR59 = msg.sender;
if(VAR90 == 0) {
throw;
}
if(FUN78(VAR59) < VAR90) {
throw;
}
if(VAR104[VAR59] == 0) {
VAR110++;
}
VAR104[VAR59] = FUN4(VAR104[VAR59], VAR90);
VAR111 = FUN4(VAR111, VAR90);
FUN71().transfer(VAR59, VAR90);
FUN69(VAR59, VAR90);
}
function FUN58() VAR13 {
if(FUN35() != VAR50.VAR58) throw;
address VAR59 = msg.sender;
if(VAR91[VAR59] == 0) throw;
uint VAR90 = VAR91[VAR59];
delete VAR91[VAR59];
if(!(VAR59.call.value(VAR90)())) throw;
FUN67(VAR59, VAR90);
}
function FUN81(Crowdsale VAR121) public onlyOwner {
VAR16 = VAR121;
if(!VAR16.FUN64()) true;
}
function FUN35() public returns(VAR50) {
if(VAR109 == 0) {
if(VAR79 >= VAR105) {
return VAR50.VAR58;
} else {
return VAR50.VAR54;
}
} else {
return VAR50.VAR112;
}
}
function() payable {
throw;
}
}
1
---------------------------------
38 0x380e0f015c0a830dc5d25e5f99570ad0be275350.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
event FUN1(address indexed VAR3, uint256 VAR4);
event FUN2(address VAR5, uint256 VAR6);
event FUN3(address VAR7, uint256 VAR8);
address public VAR9 = msg.sender;
uint64 public VAR10;
uint64 public VAR11;
uint64 public VAR12;
uint64 public VAR13;
uint64 public VAR14;
address public VAR15;
uint64 public VAR4;
struct VAR16 {
uint64 VAR17;
uint64 VAR18;
}
mapping (address => VAR16) public VAR19;
address public VAR20;
uint256 public VAR21;
constructor (
uint64 VAR22,
uint64 VAR23,
uint64 VAR24,
uint64 VAR25,
uint64 VAR26,
address VAR27
) public payable {
VAR10 = VAR22;
VAR11 = VAR23;
VAR12 = VAR24;
VAR13 = VAR25;
VAR14 = VAR26;
VAR15 = VAR27;
VAR20 = VAR27;
VAR4 = FUN4(VAR28.VAR29 + VAR10);
}
function FUN5() public view returns(
VAR30,
VAR30,
VAR30,
VAR30,
VAR30,
address,
VAR30,
VAR30,
VAR30,
uint256
) {
Presser VAR31 = VAR19[msg.sender];
return (
VAR10,
VAR11,
VAR12,
VAR13,
VAR14,
VAR15,
VAR4,
VAR31.VAR17,
VAR31.VAR18,
address(this).VAR32-VAR21
);
}
function FUN6() public payable {
require(VAR28.VAR29 <= VAR4);
Presser storage VAR31 = VAR19[msg.sender];
require(VAR31.VAR18 < VAR28.VAR29);
uint256 VAR33 = msg.value-VAR13;
if (VAR31.VAR17 == 0) {
uint128 VAR34 = FUN7(address(this).VAR32 - VAR21 - msg.value);
VAR33 -= VAR34;
VAR21 += VAR34;
}
require(VAR33 <= msg.value);
VAR15 = msg.sender;
uint64 VAR35 = VAR10 - (VAR31.VAR17*VAR11);
if (VAR35 < 10 || VAR35 > VAR10) {
VAR35 = 10;
}
VAR4 = FUN4(VAR28.VAR29 + VAR35);
VAR31.VAR17++;
VAR31.VAR18 = FUN4(VAR28.VAR29 + (VAR31.VAR17*VAR12));
if (VAR33 > 0) {
msg.sender.transfer(VAR33);
}
emit FUN1(msg.sender, VAR4);
}
function FUN8() public {
require(VAR28.VAR29 > VAR4);
ButtonFactory VAR36 = FUN9(VAR9);
if (!VAR20.FUN10(3*VAR21/4)){
VAR36.VAR37.value(VAR21)(VAR15, address(this).VAR32);
} else {
VAR36.VAR37.value(VAR21/4)(VAR15, address(this).VAR32);
}
emit FUN2(VAR15, address(this).VAR32);
FUN11(VAR15);
}
function FUN12() public view returns (uint128) {
return FUN7(address(this).VAR32-VAR21);
}
function FUN7(uint256 VAR38) private view returns (uint128) {
return uint128((VAR38 * VAR14) / 10000);
}
function() payable public {
emit FUN3(msg.sender, msg.value);
}
}
contract VAR39 {
event FUN13(address indexed VAR40, address indexed VAR41, uint64 VAR10, uint64 VAR42, uint64 VAR43, uint64 VAR13, uint64 VAR14);
event FUN14(address indexed VAR40, address indexed VAR5, uint256 VAR44);
address public VAR20 = msg.sender;
uint256 public VAR45;
mapping (address => bool) VAR46;
function FUN15(uint256 VAR47) public {
require(msg.sender == VAR20);
VAR45 = VAR47;
}
function FUN16(
uint64 VAR22,
uint64 VAR23,
uint64 VAR24,
uint64 VAR25,
uint64 VAR26
) public payable returns (address) {
uint256 VAR48 = ((VAR22 / 1441) + 1) * VAR45;
require(msg.value >= VAR48);
address VAR49 = VAR50 FUN17(VAR22, VAR23, VAR24, VAR25, VAR26, msg.sender);
VAR46[VAR49] = true;
emit FUN13(VAR49, msg.sender, VAR22, VAR23, VAR24, VAR25, VAR26);
return VAR49;
}
function FUN18(address VAR51, uint256 VAR52) public payable {
require(VAR46[msg.sender]);
delete VAR46[msg.sender];
emit FUN14(msg.sender, VAR51, VAR52);
}
function FUN19() public {
require(msg.sender == VAR20);
msg.sender.transfer(address(this).VAR32);
}
}
1
---------------------------------
39 0x38926c81bf68130fffc6972f7b5dbc550272eb4e.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4, "");
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3, "");
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3, "");
return VAR5;
}
}
library VAR6 {
function FUN5(string VAR7) internal pure returns(bytes32) {
bytes memory VAR8 = bytes(VAR7);
uint256 VAR9 = VAR8.VAR10;
require (VAR9 <= 32 && VAR9 > 0, "");
require(VAR8[0] != 0x20 && VAR8[VAR9-1] != 0x20, "");
if (VAR8[0] == 0x30) {
require(VAR8[1] != 0x78, "");
require(VAR8[1] != 0x58, "");
}
bool VAR11;
for (uint256 VAR12 = 0; VAR12 < VAR9; VAR12++) {
if (VAR8[VAR12] > 0x40 && VAR8[VAR12] < 0x5b) {
VAR8[VAR12] = FUN6(uint(VAR8[VAR12]) + 32);
if (VAR11 == false) {
VAR11 = true;
}
} else {
require(VAR8[VAR12] == 0x20 || (VAR8[VAR12] > 0x60 && VAR8[VAR12] < 0x7b) || (VAR8[VAR12] > 0x2f && VAR8[VAR12] < 0x3a), "");
if (VAR8[VAR12] == 0x20) {
require( VAR8[VAR12+1] != 0x20, "");
}
if (VAR11 == false && (VAR8[VAR12] < 0x30 || VAR8[VAR12] > 0x39)) {
VAR11 = true;
}
}
}
require(VAR11 == true, "");
bytes32 VAR13;
VAR14 {
VAR13 := FUN7(FUN4(VAR8, 32))
}
return (VAR13);
}
}
interface VAR15 {
function FUN8() external payable returns(bool);
}
interface VAR16 {
function FUN9(uint256 VAR17, address VAR18, bytes32 VAR19, uint256 VAR20) external;
function FUN10(uint256 VAR17, bytes32 VAR19) external;
}
contract VAR21 {
address public VAR22;
event FUN11(address indexed VAR23, address indexed VAR24);
constructor() public {
VAR22 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR22, "");
VAR25;
}
function FUN12(address VAR26) public onlyOwner {
require(VAR26 != address(0), "");
VAR22 = VAR26;
emit FUN11(VAR22, VAR26);
}
}
contract PlayerBook is VAR21 {
using SafeMath for uint256;
using NameFilter for string;
PartnershipInterface constant private VAR27 = FUN13(0x59Ff25C4E2550bc9E2115dbcD28b949d7670d134);
uint256 public VAR28 = 10 VAR29;
mapping(uint256 => VAR16) public VAR30;
mapping(address => bytes32) public VAR31;
mapping(address => uint256) public VAR32;
uint256 public VAR33;
uint256 public VAR34;
mapping (address => uint256) public VAR35;
mapping (bytes32 => uint256) public VAR36;
struct VAR37 {
address VAR38;
bytes32 VAR39;
uint256 VAR40;
uint256 VAR41;
}
mapping (uint256 => VAR37) public VAR42;
mapping (uint256 => mapping (bytes32 => bool)) public VAR43;
mapping (uint256 => mapping (uint256 => bytes32)) public VAR44;
event FUN14(
uint256 indexed VAR45,
address indexed VAR46,
bytes32 indexed VAR47,
bool VAR48,
uint256 VAR49,
address VAR50,
bytes32 VAR51,
uint256 VAR52,
uint256 VAR53
);
constructor() public {
VAR42[1].VAR38 = 0x98EF158e8EA887AF8F2F4fecfEd25857b0A699c6;
VAR42[1].VAR39 = "";
VAR42[1].VAR41 = 1;
VAR35[0x98EF158e8EA887AF8F2F4fecfEd25857b0A699c6] = 1;
VAR36[""] = 1;
VAR43[1][""] = true;
VAR44[1][1] = "";
VAR34 = 1;
}
modifier FUN15() {
address VAR18 = msg.sender;
uint256 VAR54;
VAR14 {
VAR54 := FUN16(VAR18)
}
require(VAR54 == 0, "");
VAR25;
}
modifier FUN17() {
require(VAR32[msg.sender] != 0);
VAR25;
}
function FUN18(string VAR55) public view returns(bool) {
bytes32 VAR19 = VAR55.FUN5();
if (VAR36[VAR19] == 0) {
return true;
}
return false;
}
function FUN19(string VAR56, uint256 VAR57, bool VAR58) public payable VAR59 {
require (msg.value >= VAR28, "");
bytes32 VAR19 = VAR6.FUN5(VAR56);
address VAR18 = msg.sender;
bool VAR60 = FUN20(VAR18);
uint256 VAR17 = VAR35[VAR18];
if (VAR57 != 0 && VAR57 != VAR42[VAR17].VAR40 && VAR57 != VAR17) {
VAR42[VAR17].VAR40 = VAR57;
} else if (VAR57 == VAR17) {
VAR57 = 0;
}
FUN21(VAR17, VAR18, VAR57, VAR19, VAR60, VAR58);
}
function FUN22(string VAR56, address VAR57, bool VAR58) public payable VAR59 {
require (msg.value >= VAR28, "");
bytes32 VAR19 = VAR6.FUN5(VAR56);
address VAR18 = msg.sender;
bool VAR60 = FUN20(VAR18);
uint256 VAR17 = VAR35[VAR18];
uint256 VAR61;
if (VAR57 != address(0) && VAR57 != VAR18) {
VAR61 = VAR35[VAR57];
if (VAR61 != VAR42[VAR17].VAR40) {
VAR42[VAR17].VAR40 = VAR61;
}
}
FUN21(VAR17, VAR18, VAR61, VAR19, VAR60, VAR58);
}
function FUN23(string VAR56, bytes32 VAR57, bool VAR58) public payable VAR59 {
require (msg.value >= VAR28, "");
bytes32 VAR19 = VAR6.FUN5(VAR56);
address VAR18 = msg.sender;
bool VAR60 = FUN20(VAR18);
uint256 VAR17 = VAR35[VAR18];
uint256 VAR61;
if (VAR57 != "" && VAR57 != VAR19) {
VAR61 = VAR36[VAR57];
if (VAR61 != VAR42[VAR17].VAR40) {
VAR42[VAR17].VAR40 = VAR61;
}
}
FUN21(VAR17, VAR18, VAR61, VAR19, VAR60, VAR58);
}
function FUN24(uint256 VAR62) public VAR59 {
require(VAR62 <= VAR33, "");
address VAR18 = msg.sender;
uint256 VAR17 = VAR35[VAR18];
require(VAR17 != 0, "");
VAR30[VAR62].FUN9(VAR17, VAR18, VAR42[VAR17].VAR39, VAR42[VAR17].VAR40);
uint256 VAR63 = VAR42[VAR17].VAR41;
if (VAR63 > 1) {
for (uint256 VAR64 = 1; VAR64 <= VAR63; VAR64++) {
VAR30[VAR62].FUN10(VAR17, VAR44[VAR17][VAR64]);
}
}
}
function FUN25() public VAR59 {
address VAR18 = msg.sender;
uint256 VAR17 = VAR35[VAR18];
require(VAR17 != 0, "");
uint256 VAR20 = VAR42[VAR17].VAR40;
uint256 VAR63 = VAR42[VAR17].VAR41;
bytes32 VAR19 = VAR42[VAR17].VAR39;
for (uint256 VAR12 = 1; VAR12 <= VAR33; VAR12++) {
VAR30[VAR12].FUN9(VAR17, VAR18, VAR19, VAR20);
if (VAR63 > 1) {
for (uint256 VAR64 = 1; VAR64 <= VAR63; VAR64++) {
VAR30[VAR12].FUN10(VAR17, VAR44[VAR17][VAR64]);
}
}
}
}
function FUN26(string VAR56) isHuman public {
bytes32 VAR19 = VAR56.FUN5();
uint256 VAR17 = VAR35[msg.sender];
require(VAR43[VAR17][VAR19] == true, "");
VAR42[VAR17].VAR39 = VAR19;
}
function FUN21(uint256 VAR17, address VAR18, uint256 VAR61, bytes32 VAR19, bool VAR60, bool VAR58) private {
if (VAR36[VAR19] != 0) {
require(VAR43[VAR17][VAR19] == true, "");
}
VAR42[VAR17].VAR39 = VAR19;
VAR36[VAR19] = VAR17;
if (VAR43[VAR17][VAR19] == false) {
VAR43[VAR17][VAR19] = true;
VAR42[VAR17].VAR41++;
VAR44[VAR17][VAR42[VAR17].VAR41] = VAR19;
}
VAR27.VAR65.value(address(this).VAR66)();
if (VAR58 == true) {
for (uint256 VAR12 = 1; VAR12 <= VAR33; VAR12++) {
VAR30[VAR12].FUN9(VAR17, VAR18, VAR19, VAR61);
}
}
emit FUN14(VAR17, VAR18, VAR19, VAR60, VAR61, VAR42[VAR61].VAR38, VAR42[VAR61].VAR39, msg.value, VAR67);
}
function FUN20(address VAR18) private returns (bool) {
if (VAR35[VAR18] == 0) {
VAR34++;
VAR35[VAR18] = VAR34;
VAR42[VAR34].VAR38 = VAR18;
return true;
}
return false;
}
function FUN27(address VAR18) external isRegisteredGame returns (uint256) {
FUN20(VAR18);
return (VAR35[VAR18]);
}
function FUN28(uint256 VAR17) external view returns (bytes32) {
return (VAR42[VAR17].VAR39);
}
function FUN29(uint256 VAR17) external view returns (uint256) {
return (VAR42[VAR17].VAR40);
}
function FUN30(uint256 VAR17) external view returns (address) {
return (VAR42[VAR17].VAR38);
}
function FUN31() external view returns (uint256) {
return(VAR28);
}
function FUN32(address VAR18, bytes32 VAR19, uint256 VAR57, bool VAR58) external payable VAR68 returns(bool, uint256) {
require (msg.value >= VAR28, "");
bool VAR60 = FUN20(VAR18);
uint256 VAR17 = VAR35[VAR18];
uint256 VAR61 = VAR57;
if (VAR61 != 0 && VAR61 != VAR42[VAR17].VAR40 && VAR61 != VAR17) {
VAR42[VAR17].VAR40 = VAR61;
} else if (VAR61 == VAR17) {
VAR61 = 0;
}
FUN21(VAR17, VAR18, VAR61, VAR19, VAR60, VAR58);
return(VAR60, VAR61);
}
function FUN33(address VAR18, bytes32 VAR19, address VAR57, bool VAR58) external payable VAR68 returns(bool, uint256) {
require (msg.value >= VAR28, "");
bool VAR60 = FUN20(VAR18);
uint256 VAR17 = VAR35[VAR18];
uint256 VAR61;
if (VAR57 != address(0) && VAR57 != VAR18) {
VAR61 = VAR35[VAR57];
if (VAR61 != VAR42[VAR17].VAR40) {
VAR42[VAR17].VAR40 = VAR61;
}
}
FUN21(VAR17, VAR18, VAR61, VAR19, VAR60, VAR58);
return(VAR60, VAR61);
}
function FUN34(address VAR18, bytes32 VAR19, bytes32 VAR57, bool VAR58) external payable VAR68 returns(bool, uint256) {
require (msg.value >= VAR28, "");
bool VAR60 = FUN20(VAR18);
uint256 VAR17 = VAR35[VAR18];
uint256 VAR61;
if (VAR57 != "" && VAR57 != VAR19) {
VAR61 = VAR36[VAR57];
if (VAR61 != VAR42[VAR17].VAR40) {
VAR42[VAR17].VAR40 = VAR61;
}
}
FUN21(VAR17, VAR18, VAR61, VAR19, VAR60, VAR58);
return(VAR60, VAR61);
}
function FUN35(address VAR69, string VAR70) public onlyOwner {
require(VAR32[VAR69] == 0, "");
VAR33++;
bytes32 VAR19 = VAR70.FUN5();
VAR32[VAR69] = VAR33;
VAR31[VAR69] = VAR19;
VAR30[VAR33] = FUN36(VAR69);
VAR30[VAR33].FUN9(1, VAR42[1].VAR38, VAR42[1].VAR39, 0);
}
function FUN37(uint256 VAR71) public onlyOwner {
VAR28 = VAR71;
}
}
1
---------------------------------
40 0x38ca499bb3b405fcc4a9cfc9d1c119f0bcf05e6f.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1(address, uint, address, uint) public returns (uint);
function FUN2(address, uint, address, uint) public returns (uint);
function FUN3(address, address, uint) public constant returns (uint);
}
contract VAR3 {
function FUN4(address) public returns (uint);
function FUN5(address, address) public returns (uint);
function FUN6(address, uint) public;
function transfer(address,uint) public returns (bool);
function FUN7(address, address, uint) public returns (bool);
function FUN8() public payable;
function FUN9(uint) public;
}
contract VAR4 {
function FUN10 (uint VAR5, address VAR6) public view returns (uint VAR7, uint VAR8);
}
contract VAR9 {
function FUN11(
address VAR10, address VAR11, bytes4 VAR12
) public view returns (bool);
}
contract VAR13 {
event FUN12 (address indexed VAR14);
event FUN13     (address indexed VAR15);
}
contract DSAuth is VAR13 {
DSAuthority  public  VAR14;
address      public  VAR15;
constructor() public {
VAR15 = msg.sender;
emit FUN13(msg.sender);
}
function FUN14(address VAR16)
public
VAR17
{
VAR15 = VAR16;
emit FUN13(VAR15);
}
function FUN15(DSAuthority VAR18)
public
VAR17
{
VAR14 = VAR18;
emit FUN12(VAR14);
}
modifier VAR17 {
require(FUN16(msg.sender, msg.VAR12));
VAR19;
}
function FUN16(address VAR10, bytes4 VAR12) internal view returns (bool) {
if (VAR10 == address(this)) {
return true;
} else if (VAR10 == VAR15) {
return true;
} else if (VAR14 == FUN17(0)) {
return false;
} else {
return VAR14.FUN11(VAR10, this, VAR12);
}
}
}
contract Mortal is VAR20 {
function FUN18() public VAR17 {
FUN19(VAR15);
}
function FUN20(address VAR21) public VAR17 {
require(VAR21.call.value(address(this).VAR22)());
}
function FUN21(TokenInterface VAR6, address VAR21) public VAR17 {
require(VAR6.transfer(VAR21, VAR6.FUN4(this)));
}
}
contract VAR23 {
function FUN22(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
require((VAR26 = VAR24 + VAR25) >= VAR24);
}
function FUN23(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
require((VAR26 = VAR24 - VAR25) <= VAR24);
}
function FUN24(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
require(VAR25 == 0 || (VAR26 = VAR24 * VAR25) / VAR25 == VAR24);
}
function FUN25(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
return VAR24 <= VAR25 ? VAR24 : VAR25;
}
function FUN26(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
return VAR24 >= VAR25 ? VAR24 : VAR25;
}
function FUN27(int VAR24, int VAR25) internal pure returns (int VAR26) {
return VAR24 <= VAR25 ? VAR24 : VAR25;
}
function FUN28(int VAR24, int VAR25) internal pure returns (int VAR26) {
return VAR24 >= VAR25 ? VAR24 : VAR25;
}
uint constant VAR27 = 10 ** 18;
uint constant VAR28 = 10 ** 27;
function FUN29(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
VAR26 = FUN22(FUN24(VAR24, VAR25), VAR27 / 2) / VAR27;
}
function FUN30(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
VAR26 = FUN22(FUN24(VAR24, VAR25), VAR28 / 2) / VAR28;
}
function FUN31(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
VAR26 = FUN22(FUN24(VAR24, VAR27), VAR25 / 2) / VAR25;
}
function FUN32(uint VAR24, uint VAR25) internal pure returns (uint VAR26) {
VAR26 = FUN22(FUN24(VAR24, VAR28), VAR25 / 2) / VAR25;
}
function FUN33(uint VAR24, uint VAR29) internal pure returns (uint VAR26) {
VAR26 = VAR29 % 2 != 0 ? VAR24 : VAR28;
for (VAR29 /= 2; VAR29 != 0; VAR29 /= 2) {
VAR24 = FUN30(VAR24, VAR24);
if (VAR29 % 2 != 0) {
VAR26 = FUN30(VAR26, VAR24);
}
}
}
}
contract OasisMonetizedProxy is VAR30, VAR23 {
FeeInterface VAR31;
constructor(FeeInterface VAR32) public {
VAR31 = VAR32;
}
function FUN34(FeeInterface VAR32) public VAR17 {
VAR31 = VAR32;
}
function FUN35(TokenInterface VAR33, address VAR21, uint VAR34) internal {
VAR33.FUN9(VAR34);
require(VAR21.call.value(VAR34)());
}
function FUN1(
OtcInterface VAR35,
TokenInterface VAR36,
uint VAR37,
TokenInterface VAR38,
uint VAR39
) public returns (uint) {
require(VAR36.FUN7(msg.sender, this, VAR37));
if (VAR36.FUN5(this, VAR35) < VAR37) {
VAR36.FUN6(VAR35, uint(-1));
}
uint VAR40 = VAR35.FUN1(VAR36, VAR37, VAR38, VAR39);
(uint VAR41, uint VAR42) = VAR31.FUN10(VAR40, VAR38);
require(VAR38.transfer(VAR15, VAR41));
require(VAR38.transfer(msg.sender, VAR42));
return VAR42;
}
function FUN36(
OtcInterface VAR35,
TokenInterface VAR33,
TokenInterface VAR38,
uint VAR39
) public payable returns (uint) {
VAR33.VAR43.value(msg.value)();
if (VAR33.FUN5(this, VAR35) < msg.value) {
VAR33.FUN6(VAR35, uint(-1));
}
uint VAR40 = VAR35.FUN1(VAR33, msg.value, VAR38, VAR39);
(uint VAR41, uint VAR42) = VAR31.FUN10(VAR40, VAR38);
require(VAR38.transfer(VAR15, VAR41));
require(VAR38.transfer(msg.sender, VAR42));
return VAR42;
}
function FUN37(
OtcInterface VAR35,
TokenInterface VAR36,
uint VAR37,
TokenInterface VAR33,
uint VAR39
) public returns (uint) {
require(VAR36.FUN7(msg.sender, this, VAR37));
if (VAR36.FUN5(this, VAR35) < VAR37) {
VAR36.FUN6(VAR35, uint(-1));
}
uint VAR34 = VAR35.FUN1(VAR36, VAR37, VAR33, VAR39);
(uint VAR41, uint VAR44) = VAR31.FUN10(VAR34, VAR33);
FUN35(VAR33, VAR15, VAR41);
FUN35(VAR33, msg.sender, VAR44);
return VAR44;
}
function FUN2(
OtcInterface VAR35,
TokenInterface VAR38,
uint VAR40,
TokenInterface VAR36,
uint VAR45
) public returns (uint VAR37) {
uint VAR46 = VAR35.FUN3(VAR36, VAR38, VAR40);
require(VAR46 <= VAR45);
require(VAR36.FUN7(msg.sender, this, VAR46));
if (VAR36.FUN5(this, VAR35) < VAR46) {
VAR36.FUN6(VAR35, uint(-1));
}
VAR37 = VAR35.FUN2(VAR38, VAR40, VAR36, VAR46);
VAR40 = FUN25(VAR40, VAR38.FUN4(this));
(uint VAR41, uint VAR42) = VAR31.FUN10(VAR40, VAR38);
require(VAR38.transfer(VAR15, VAR41));
require(VAR38.transfer(msg.sender, VAR42));
}
function FUN38(
OtcInterface VAR35,
TokenInterface VAR38,
uint VAR40,
TokenInterface VAR33
) public payable returns (uint VAR34) {
VAR33.VAR43.value(msg.value)();
if (VAR33.FUN5(this, VAR35) < msg.value) {
VAR33.FUN6(VAR35, uint(-1));
}
VAR34 = VAR35.FUN2(VAR38, VAR40, VAR33, msg.value);
VAR40 = FUN25(VAR40, VAR38.FUN4(this));
(uint VAR41, uint VAR42) = VAR31.FUN10(VAR40, VAR38);
require(VAR38.transfer(VAR15, VAR41));
require(VAR38.transfer(msg.sender, VAR42));
FUN35(VAR33, msg.sender, FUN23(msg.value, VAR34));
}
function FUN39(
OtcInterface VAR35,
TokenInterface VAR33,
uint VAR34,
TokenInterface VAR36,
uint VAR45
) public returns (uint VAR37) {
uint VAR46 = VAR35.FUN3(VAR36, VAR33, VAR34);
require(VAR46 <= VAR45);
require(VAR36.FUN7(msg.sender, this, VAR46));
if (VAR36.FUN5(this, VAR35) < VAR46) {
VAR36.FUN6(VAR35, uint(-1));
}
VAR37 = VAR35.FUN2(VAR33, VAR34, VAR36, VAR46);
(uint VAR41, uint VAR44) = VAR31.FUN10(VAR34, VAR33);
FUN35(VAR33, VAR15, VAR41);
FUN35(VAR33, msg.sender, VAR44);
}
function() public payable {
revert();
}
}
1
---------------------------------
41 0x397c7f9c38e09b7024063e6879d45b58e5effdbf.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
event FUN1(uint256 VAR3);
address public VAR4;
uint256 public VAR5;
function FUN2() public {
VAR4 = msg.sender;
}
function() public payable {}
function FUN3(uint256 VAR6) external {
require(VAR6 < 10000);
VAR5 = VAR6;
emit FUN1(VAR5);
}
function FUN4() external {
VAR4.transfer(address(this).VAR7);
}
function FUN5(address VAR8) external onlyManager {
VAR4 = VAR8;
}
function FUN6(address VAR9, uint256 VAR10, uint256 VAR11, bytes VAR12)
external
payable
onlyManager
returns (bool)
{
return VAR9.call.value(VAR10).FUN7(VAR11)(VAR12);
}
modifier onlyManager
{
require(msg.sender == VAR4);
VAR13;
}
}
contract EthernameRaw is VAR2 {
event Transfer(
address indexed VAR14,
address indexed VAR15,
bytes32 indexed VAR16
);
event FUN8(
address indexed VAR17,
address indexed VAR18,
bytes32 indexed VAR16
);
event FUN9(
address indexed VAR14,
address indexed VAR15,
bytes32 sender,
bytes32 VAR19,
uint256 value
);
event FUN10(address indexed VAR17, bytes32 indexed VAR16);
event FUN11(bytes32 indexed VAR16, uint256 VAR20);
event FUN12(bytes32 indexed VAR16, address VAR21, uint256 VAR20);
event FUN13(bytes32 indexed VAR16, bytes32 VAR22);
struct VAR23 {
address VAR17;
uint256 VAR20;
mapping (bytes32 => bytes) VAR24;
}
string public constant VAR16 = "";
string public constant VAR25 = "";
mapping (address => bytes32) public VAR26;
mapping (bytes32 => VAR23) public VAR27;
mapping (bytes32 => address) public VAR28;
function FUN14(bytes32 VAR29) public payable {
FUN15(VAR29, msg.sender);
}
function FUN16(address VAR9, bytes32 VAR29)
public
onlyOwner(msg.sender, VAR29)
{
FUN17(msg.sender, VAR9, VAR29);
}
function FUN18(address VAR9, bytes32 VAR29)
public
onlyOwner(msg.sender, VAR29)
{
FUN19(msg.sender, VAR9, VAR29);
}
function FUN20(address VAR30, address VAR9, bytes32 VAR29)
public
onlyOwner(VAR30, VAR29)
FUN21(msg.sender, VAR29)
{
FUN17(VAR30, VAR9, VAR29);
}
function FUN22(bytes32 VAR29, uint256 VAR31)
public
onlyOwner(msg.sender, VAR29)
{
require(VAR31 == uint256(uint128(VAR31)));
VAR27[VAR29].VAR20 = VAR31;
emit FUN11(VAR29, VAR31);
}
function FUN23(bytes32 VAR29) public payable {
Record memory VAR32 = VAR27[VAR29];
require(VAR32.VAR20 > 0);
uint256 VAR31 = FUN24(VAR32.VAR20);
require(msg.value >= VAR31);
VAR32.VAR17.transfer(VAR32.VAR20);
FUN17(VAR32.VAR17, msg.sender, VAR29);
msg.sender.transfer(msg.value - VAR31);
emit FUN12(VAR29, msg.sender, VAR31);
}
function FUN25(bytes32 VAR29) public onlyOwner(msg.sender, VAR29) {
FUN26(msg.sender, VAR29);
}
function FUN27(bytes32 VAR29, bytes32 VAR33, bytes VAR10)
public
onlyOwner(msg.sender, VAR29)
{
VAR27[VAR29].VAR24[VAR33] = VAR10;
emit FUN13(VAR29, VAR33);
}
function FUN28(bytes32 VAR29, bytes32[] VAR34)
public
onlyOwner(msg.sender, VAR29)
{
mapping (bytes32 => bytes) VAR24 = VAR27[VAR29].VAR24;
for (uint VAR35 = 0; VAR35 < VAR34.VAR36; VAR35++) {
delete VAR24[VAR34[VAR35]];
emit FUN13(VAR29, VAR34[VAR35]);
}
}
function FUN29(bytes32 VAR29) public payable returns (bool VAR37) {
address VAR9 = VAR27[VAR29].VAR17;
VAR37 = (VAR29 != bytes32(0)) &&
(VAR9 != address(0)) &&
VAR9.FUN30(msg.value);
if (VAR37) {
emit FUN9(
msg.sender,
VAR9,
FUN31(msg.sender),
VAR29,
msg.value
);
}
}
function FUN31(address VAR38) public view returns (bytes32 VAR29) {
VAR29 = VAR26[VAR38];
}
function FUN32(bytes32 VAR29) public view returns (address VAR39) {
VAR39 = VAR27[VAR29].VAR17;
}
function FUN33(bytes32 VAR29, bytes32 VAR33)
public
view
returns (address VAR39, uint256 VAR31, bytes VAR10)
{
VAR39 = VAR27[VAR29].VAR17;
VAR31 = FUN24(VAR27[VAR29].VAR20);
VAR10 = VAR27[VAR29].VAR24[VAR33];
}
function FUN15(bytes32 VAR29, address VAR9) internal {
require(VAR27[VAR29].VAR17 == address(0));
for (uint VAR35 = 0; VAR35 < VAR29.VAR36; VAR35++) {
require((VAR29[VAR35] == 0) ||
(VAR29[VAR35] > 96 && VAR29[VAR35] < 123) ||
(VAR29[VAR35] > 47 && VAR29[VAR35] < 58));
}
FUN17(0, VAR9, VAR29);
}
function FUN17(address VAR30, address VAR9, bytes32 VAR29) internal {
address VAR40 = address(0);
if (VAR28[VAR29] != VAR40) {
FUN19(VAR30, VAR40, VAR29);
}
if (VAR26[VAR30] == VAR29) {
FUN26(VAR30, 0);
}
VAR27[VAR29] = FUN34(VAR9, 0);
if (VAR26[VAR9] == bytes32(0)) {
FUN26(VAR9, VAR29);
}
emit Transfer(VAR30, VAR9, VAR29);
}
function FUN19(address VAR39, address VAR9, bytes32 VAR29) internal {
VAR28[VAR29] = VAR9;
emit FUN8(VAR39, VAR9, VAR29);
}
function FUN26(address VAR39, bytes32 VAR29) internal {
VAR26[VAR39] = VAR29;
emit FUN10(VAR39, VAR29);
}
function FUN24(uint256 VAR31) internal view returns (uint256) {
return VAR31 * (10000 + VAR5) / 10000;
}
function FUN35(string VAR41)
internal
pure
returns (bytes32 VAR42)
{
require(bytes(VAR41).VAR36 < 33);
VAR43 {
VAR42 := FUN36(FUN37(VAR41, 0x20))
}
}
function FUN38(bytes32 VAR42)
internal
pure
returns (string VAR41)
{
VAR43 {
let VAR44 := FUN36(0x40)
FUN39(VAR44, 0x20)
FUN39(FUN37(VAR44, 0x20), VAR42)
FUN39(0x40, FUN37(VAR44, 0x40))
VAR41 := VAR44
}
}
modifier onlyOwner(address VAR45, bytes32 VAR29) {
require(VAR27[VAR29].VAR17 == VAR45);
VAR13;
}
modifier FUN21(address VAR45, bytes32 VAR29) {
require(VAR28[VAR29] == VAR45);
VAR13;
}
}
contract Ethername is VAR46 {
function FUN40() public {
VAR5 = 200;
VAR27[bytes32('')] = FUN34(this, 0);
FUN15(bytes32(''), this);
FUN15(bytes32(''), msg.sender);
}
function FUN41(string VAR29) external payable {
FUN14(FUN35(VAR29));
}
function transfer(address VAR9, string VAR29) external {
FUN16(VAR9, FUN35(VAR29));
}
function FUN42(address VAR9, string VAR29) external {
FUN18(VAR9, FUN35(VAR29));
}
function FUN43(address VAR30, address VAR9, string VAR29) external {
FUN20(VAR30, VAR9, FUN35(VAR29));
}
function FUN44(string VAR29, uint256 VAR31) external {
FUN22(FUN35(VAR29), VAR31);
}
function FUN45(string VAR29) external payable {
FUN23(FUN35(VAR29));
}
function FUN46(string VAR29) external {
FUN25(FUN35(VAR29));
}
function FUN47(string VAR29, string VAR33, bytes VAR10) external {
FUN27(FUN35(VAR29), FUN35(VAR33), VAR10);
}
function FUN48(string VAR29, bytes32[] VAR34) external {
FUN28(FUN35(VAR29), VAR34);
}
function FUN49(string VAR29) external payable returns (bool VAR37) {
VAR37 = FUN29(FUN35(VAR29));
}
function FUN50(address VAR38) external view returns (string VAR29) {
VAR29 = FUN38(FUN31(VAR38));
}
function FUN51(string VAR29) external view returns (address VAR39) {
VAR39 = FUN32(FUN35(VAR29));
}
function FUN52(string VAR29, string VAR33)
external
view
returns (address VAR39, uint256 VAR31, bytes VAR10)
{
return FUN33(FUN35(VAR29), FUN35(VAR33));
}
}
1
---------------------------------
42 0x3aca08f6fe9217b79aa00f26a1e610339361c868.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
function FUN5(uint VAR8, string VAR9, string VAR10) payable returns (bytes32 VAR11);
function FUN6(uint VAR8, string VAR9, string VAR10, uint VAR12) payable returns (bytes32 VAR11);
function FUN7(uint VAR8, string VAR9, string VAR13, string VAR14) payable returns (bytes32 VAR11);
function FUN8(uint VAR8, string VAR9, string VAR13, string VAR14, uint VAR12) payable returns (bytes32 VAR11);
function FUN9(uint VAR8, string VAR9, bytes VAR15) payable returns (bytes32 VAR11);
function FUN10(uint VAR8, string VAR9, bytes VAR15, uint VAR12) payable returns (bytes32 VAR11);
function FUN11(string VAR9) returns (uint VAR16);
function FUN11(string VAR9, uint VAR17) returns (uint VAR16);
function FUN12(string VAR18);
function FUN13(byte VAR19);
function FUN14(bytes32 VAR20);
function FUN15(uint VAR21);
function FUN16() returns(bytes32);
}
contract VAR22 {
function FUN17() returns (address VAR23);
}
contract VAR24 {
uint constant VAR25 = 60*60*24;
uint constant VAR26 = 60*60*24*7;
uint constant VAR27 = 60*60*24*30;
byte constant VAR28 = 0x00;
byte constant VAR29 = 0x10;
byte constant VAR30 = 0x20;
byte constant VAR31 = 0x30;
byte constant VAR32 = 0xF0;
byte constant VAR33 = 0x01;
uint8 constant VAR34 = 0;
uint8 constant VAR35 = 1;
uint8 constant VAR36 = 2;
uint8 constant VAR37 = 2;
uint8 constant VAR38 = 161;
OraclizeAddrResolverI VAR39;
OraclizeI VAR40;
modifier VAR41 {
if((address(VAR39)==0)||(FUN18(address(VAR39))==0)) FUN19(VAR34);
VAR40 = FUN20(VAR39.FUN17());
VAR42;
}
modifier FUN21(string VAR43){
VAR40 = FUN20(VAR39.FUN17());
VAR40.FUN12(VAR43);
VAR42;
}
function FUN19(uint8 VAR44) internal returns(bool){
if (FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR39 = FUN22(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN23("");
return true;
}
if (FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR39 = FUN22(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN23("");
return true;
}
if (FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR39 = FUN22(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN23("");
return true;
}
if (FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR39 = FUN22(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN23("");
return true;
}
if (FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR39 = FUN22(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR39 = FUN22(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR39 = FUN22(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN24(bytes32 VAR45, string VAR46) {
FUN24(VAR45, VAR46, VAR47 bytes(0));
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) {
}
function FUN25(string VAR43) oraclizeAPI internal {
VAR40.FUN12(VAR43);
}
function FUN26(string VAR49) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49);
}
function FUN26(string VAR49, uint VAR17) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49, VAR17);
}
function FUN27(string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(0, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(VAR57, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(VAR57, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(0, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(0, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(VAR57, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(VAR57, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(0, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN30() oraclizeAPI internal returns (address){
return VAR40.FUN31();
}
function FUN32(byte VAR68) oraclizeAPI internal {
return VAR40.FUN13(VAR68);
}
function FUN33(uint VAR69) oraclizeAPI internal {
return VAR40.FUN15(VAR69);
}
function FUN34(bytes32 VAR70) oraclizeAPI internal {
return VAR40.FUN14(VAR70);
}
function FUN35() oraclizeAPI internal returns (bytes32){
return VAR40.FUN16();
}
function FUN18(address VAR23) constant internal returns(uint VAR71) {
VAR72 {
VAR71 := FUN36(VAR23)
}
}
function FUN37(string VAR73) internal returns (address){
bytes memory VAR74 = bytes(VAR73);
uint160 VAR75 = 0;
uint160 VAR76;
uint160 VAR77;
for (uint VAR78=2; VAR78<2+2*20; VAR78+=2){
VAR75 *= 256;
VAR76 = FUN38(VAR74[VAR78]);
VAR77 = FUN38(VAR74[VAR78+1]);
if ((VAR76 >= 97)&&(VAR76 <= 102)) VAR76 -= 87;
else if ((VAR76 >= 65)&&(VAR76 <= 70)) VAR76 -= 55;
else if ((VAR76 >= 48)&&(VAR76 <= 57)) VAR76 -= 48;
if ((VAR77 >= 97)&&(VAR77 <= 102)) VAR77 -= 87;
else if ((VAR77 >= 65)&&(VAR77 <= 70)) VAR77 -= 55;
else if ((VAR77 >= 48)&&(VAR77 <= 57)) VAR77 -= 48;
VAR75 += (VAR76*16+VAR77);
}
return address(VAR75);
}
function FUN39(string VAR73, string VAR79) internal returns (int) {
bytes memory VAR3 = bytes(VAR73);
bytes memory VAR4 = bytes(VAR79);
uint VAR80 = VAR3.VAR81;
if (VAR4.VAR81 < VAR80) VAR80 = VAR4.VAR81;
for (uint VAR78 = 0; VAR78 < VAR80; VAR78 ++)
if (VAR3[VAR78] < VAR4[VAR78])
return -1;
else if (VAR3[VAR78] > VAR4[VAR78])
return 1;
if (VAR3.VAR81 < VAR4.VAR81)
return -1;
else if (VAR3.VAR81 > VAR4.VAR81)
return 1;
else
return 0;
}
function FUN40(string VAR82, string VAR83) internal returns (int) {
bytes memory VAR84 = bytes(VAR82);
bytes memory VAR85 = bytes(VAR83);
if(VAR84.VAR81 < 1 || VAR85.VAR81 < 1 || (VAR85.VAR81 > VAR84.VAR81))
return -1;
else if(VAR84.VAR81 > (2**128 -1))
return -1;
else
{
uint VAR86 = 0;
for (uint VAR78 = 0; VAR78 < VAR84.VAR81; VAR78 ++)
{
if (VAR84[VAR78] == VAR85[0])
{
VAR86 = 1;
while(VAR86 < VAR85.VAR81 && (VAR78 + VAR86) < VAR84.VAR81 && VAR84[VAR78 + VAR86] == VAR85[VAR86])
{
VAR86++;
}
if(VAR86 == VAR85.VAR81)
return int(VAR78);
}
}
return -1;
}
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88, string VAR89) internal returns (string) {
bytes memory VAR90 = bytes(VAR73);
bytes memory VAR91 = bytes(VAR79);
bytes memory VAR92 = bytes(VAR87);
bytes memory VAR93 = bytes(VAR88);
bytes memory VAR94 = bytes(VAR89);
string memory VAR95 = VAR47 string(VAR90.VAR81 + VAR91.VAR81 + VAR92.VAR81 + VAR93.VAR81 + VAR94.VAR81);
bytes memory VAR96 = bytes(VAR95);
uint VAR97 = 0;
for (uint VAR78 = 0; VAR78 < VAR90.VAR81; VAR78++) VAR96[VAR97++] = VAR90[VAR78];
for (VAR78 = 0; VAR78 < VAR91.VAR81; VAR78++) VAR96[VAR97++] = VAR91[VAR78];
for (VAR78 = 0; VAR78 < VAR92.VAR81; VAR78++) VAR96[VAR97++] = VAR92[VAR78];
for (VAR78 = 0; VAR78 < VAR93.VAR81; VAR78++) VAR96[VAR97++] = VAR93[VAR78];
for (VAR78 = 0; VAR78 < VAR94.VAR81; VAR78++) VAR96[VAR97++] = VAR94[VAR78];
return string(VAR96);
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, VAR88, "");
}
function FUN41(string VAR73, string VAR79, string VAR87) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, "", "");
}
function FUN41(string VAR73, string VAR79) internal returns (string) {
return FUN41(VAR73, VAR79, "", "", "");
}
function FUN42(string VAR73) internal returns (uint) {
return FUN42(VAR73, 0);
}
function FUN42(string VAR73, uint VAR79) internal returns (uint) {
bytes memory VAR98 = bytes(VAR73);
uint VAR99 = 0;
bool VAR100 = false;
for (uint VAR78=0; VAR78<VAR98.VAR81; VAR78++){
if ((VAR98[VAR78] >= 48)&&(VAR98[VAR78] <= 57)){
if (VAR100){
if (VAR79 == 0) break;
else VAR79--;
}
VAR99 *= 10;
VAR99 += uint(VAR98[VAR78]) - 48;
} else if (VAR98[VAR78] == 46) VAR100 = true;
}
if (VAR79 > 0) VAR99 *= 10**VAR79;
return VAR99;
}
function FUN43(uint VAR78) internal returns (string){
if (VAR78 == 0) return "";
uint VAR101 = VAR78;
uint VAR102;
while (VAR101 != 0){
VAR102++;
VAR101 /= 10;
}
bytes memory VAR103 = VAR47 bytes(VAR102);
uint VAR97 = VAR102 - 1;
while (VAR78 != 0){
VAR103[VAR97--] = FUN44(48 + VAR78 % 10);
VAR78 /= 10;
}
return string(VAR103);
}
function FUN28(string[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
function FUN29(bytes[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
string VAR114;
function FUN23(string VAR115) internal {
VAR114 = VAR115;
}
function FUN45() internal returns (string) {
return VAR114;
}
function FUN46(uint VAR116, uint VAR117, uint VAR118) internal returns (bytes32){
if ((VAR117 == 0)||(VAR117 > 32)) throw;
bytes memory VAR119 = VAR47 bytes(1);
VAR119[0] = FUN44(VAR117);
bytes memory VAR120 = VAR47 bytes(32);
bytes memory VAR121 = VAR47 bytes(32);
bytes32 VAR122 = FUN35();
VAR72 {
FUN47(VAR120, 0x20)
FUN47(FUN4(VAR120, 0x20), FUN48(FUN49(FUN3(VAR123, 1)), FUN48(VAR124, VAR57)))
FUN47(VAR121, 0x20)
FUN47(FUN4(VAR121, 0x20), VAR122)
}
bytes[3] memory VAR64 = [VAR120, VAR119, VAR121];
bytes32 VAR125 = FUN27(VAR116, "", VAR64, VAR118);
FUN50(VAR125, FUN51(FUN52(VAR116), VAR64[1], FUN53(VAR64[0]), VAR64[2]));
return VAR125;
}
function FUN50(bytes32 VAR125, bytes32 VAR126) internal {
VAR127[VAR125] = VAR126;
}
mapping(bytes32=>bytes32) VAR127;
mapping(bytes32=>bool) VAR128;
function FUN54(bytes32 VAR129, bytes VAR130, bytes VAR131) internal returns (bool){
bool VAR132;
address VAR133;
bytes32 VAR134;
bytes32 VAR135;
bytes memory VAR136 = VAR47 bytes(32);
uint VAR137 = 4+(uint(VAR130[3]) - 0x20);
VAR136 = FUN55(VAR130, VAR137, 32, VAR136, 0);
bytes memory VAR138 = VAR47 bytes(32);
VAR137 += 32 + 2;
VAR138 = FUN55(VAR130, VAR137+(uint(VAR130[VAR137-1]) - 0x20), 32, VAR138, 0);
VAR72 {
VAR134 := FUN56(FUN4(VAR136, 32))
VAR135 := FUN56(FUN4(VAR138, 32))
}
(VAR132, VAR133) = FUN57(VAR129, 27, VAR134, VAR135);
if (address(FUN51(VAR131)) == VAR133) return true;
else {
(VAR132, VAR133) = FUN57(VAR129, 28, VAR134, VAR135);
return (address(FUN51(VAR131)) == VAR133);
}
}
function FUN58(bytes VAR48, uint VAR139) internal returns (bool) {
bool VAR132;
bytes memory VAR140 = VAR47 bytes(uint(VAR48[VAR139+1])+2);
FUN55(VAR48, VAR139, VAR140.VAR81, VAR140, 0);
bytes memory VAR141 = VAR47 bytes(64);
FUN55(VAR48, 3+1, 64, VAR141, 0);
bytes memory VAR142 = VAR47 bytes(1+65+32);
VAR142[0] = 1;
FUN55(VAR48, VAR139-65, 65, VAR142, 1);
bytes memory VAR143 = VAR144"";
FUN55(VAR143, 0, 32, VAR142, 1+65);
VAR132 = FUN54(FUN53(VAR142), VAR140, VAR141);
if (VAR132 == false) return false;
bytes memory VAR145 = VAR144"";
bytes memory VAR146 = VAR47 bytes(1+65);
VAR146[0] = 0xFE;
FUN55(VAR48, 3, 65, VAR146, 1);
bytes memory VAR147 = VAR47 bytes(uint(VAR48[3+65+1])+2);
FUN55(VAR48, 3+65, VAR147.VAR81, VAR147, 0);
VAR132 = FUN54(FUN53(VAR146), VAR147, VAR145);
return VAR132;
}
modifier FUN59(bytes32 VAR148, string VAR149, bytes VAR150) {
if ((VAR150[0] != "")||(VAR150[1] != "")||(VAR150[2] != 1)) throw;
bool VAR151 = FUN60(VAR150, VAR148, bytes(VAR149), FUN45());
if (VAR151 == false) throw;
VAR42;
}
function FUN61(bytes32 VAR152, bytes VAR153) internal returns (bool){
bool VAR154 = true;
for (var VAR78=0; VAR78<VAR153.VAR81; VAR78++){
if (VAR152[VAR78] != VAR153[VAR78]) VAR154 = false;
}
return VAR154;
}
function FUN60(bytes VAR48, bytes32 VAR125, bytes VAR46, string VAR155) internal returns (bool){
bool VAR156;
uint VAR157 = 3+65+(uint(VAR48[3+65+1])+2)+32;
bytes memory VAR158 = VAR47 bytes(32);
FUN55(VAR48, VAR157, 32, VAR158, 0);
VAR156 = (FUN51(VAR158) == FUN51(FUN53(VAR155, VAR125)));
if (VAR156 == false) return false;
bytes memory VAR159 = VAR47 bytes(uint(VAR48[VAR157+(32+8+1+32)+1])+2);
FUN55(VAR48, VAR157+(32+8+1+32), VAR159.VAR81, VAR159, 0);
VAR156 = FUN61(FUN53(VAR159), VAR46);
if (VAR156 == false) return false;
bytes memory VAR160 = VAR47 bytes(8+1+32);
FUN55(VAR48, VAR157+32, 8+1+32, VAR160, 0);
bytes memory VAR161 = VAR47 bytes(64);
uint VAR139 = VAR157+32+(8+1+32)+VAR159.VAR81+65;
FUN55(VAR48, VAR139-64, 64, VAR161, 0);
bytes32 VAR162 = FUN53(VAR161);
if (VAR127[VAR125] == FUN51(VAR160, VAR162)){
delete VAR127[VAR125];
} else return false;
bytes memory VAR163 = VAR47 bytes(32+8+1+32);
FUN55(VAR48, VAR157, 32+8+1+32, VAR163, 0);
VAR156 = FUN54(FUN53(VAR163), VAR159, VAR161);
if (VAR156 == false) return false;
if (VAR128[VAR162] == false){
VAR128[VAR162] = FUN58(VAR48, VAR139);
}
return VAR128[VAR162];
}
function FUN55(bytes VAR164, uint VAR165, uint VAR81, bytes VAR166, uint VAR167) internal returns (bytes) {
uint VAR80 = VAR81 + VAR167;
if (VAR166.VAR81 < VAR80) {
throw;
}
uint VAR78 = 32 + VAR165;
uint VAR101 = 32 + VAR167;
while (VAR78 < (32 + VAR165 + VAR81)) {
VAR72 {
let VAR74 := FUN56(FUN4(VAR164, VAR78))
FUN47(FUN4(VAR166, VAR101), VAR74)
}
VAR78 += 32;
VAR101 += 32;
}
return VAR166;
}
function FUN57(bytes32 VAR168, uint8 VAR169, bytes32 VAR170, bytes32 VAR171) internal returns (bool, address) {
bool VAR172;
address VAR173;
VAR72 {
let VAR174 := FUN56(0x40)
FUN47(VAR174, VAR168)
FUN47(FUN4(VAR174, 32), VAR169)
FUN47(FUN4(VAR174, 64), VAR170)
FUN47(FUN4(VAR174, 96), VAR171)
VAR172 := call(3000, 1, 0, VAR174, 128, VAR174, 32)
VAR173 := FUN56(VAR174)
}
return (VAR172, VAR173);
}
function FUN62(bytes32 VAR168, bytes VAR175) internal returns (bool, address) {
bytes32 VAR170;
bytes32 VAR171;
uint8 VAR169;
if (VAR175.VAR81 != 65)
return (false, 0);
VAR72 {
VAR170 := FUN56(FUN4(VAR175, 32))
VAR171 := FUN56(FUN4(VAR175, 64))
VAR169 := FUN44(0, FUN56(FUN4(VAR175, 96)))
}
//
if (VAR169 < 27)
VAR169 += 27;
if (VAR169 != 27 && VAR169 != 28)
return (false, 0);
return FUN57(VAR168, VAR169, VAR170, VAR171);
}
}
contract VAR176 {
function FUN63() external;
function FUN64() external payable;
}
contract Betting is VAR24 {
using SafeMath for uint256;
uint VAR177=3;
address public VAR178;
uint public VAR179;
string public constant VAR180 = "";
BettingControllerInterface internal VAR181;
struct VAR182 {
bool  VAR183;
bool  VAR184;
bool  VAR185;
bool  VAR186;
uint32  VAR187;
uint32  VAR188;
uint32  VAR189;
uint32 VAR190;
}
struct VAR191{
int64  VAR192;
int64  VAR193;
int64  VAR194;
bytes32 VAR195;
bytes32 VAR196;
bytes32 VAR197;
uint VAR198;
uint VAR199;
}
struct VAR200{
bytes32 VAR201;
uint VAR202;
}
struct VAR203{
uint256 VAR204;
uint256 VAR205;
uint160 VAR206;
uint32 VAR207;
bool VAR208;
bytes32 VAR209;
bytes32 VAR210;
}
struct VAR211 {
uint160 VAR212;
bool VAR213;
mapping(bytes32=>uint) VAR214;
}
mapping (bytes32 => bytes32) VAR215;
mapping (bytes32 => VAR203) VAR216;
mapping (address => VAR211) VAR217;
uint public VAR218;
uint32 VAR219;
mapping (bytes32 => bool) public VAR220;
event FUN65(string VAR221);
event FUN66(uint VAR52);
event FUN67(address VAR222, uint256 VAR223, bytes32 VAR224, uint256 VAR225);
event FUN68(address VAR226, uint256 VAR223);
function FUN69() public payable {
FUN32(VAR29 | VAR33);
VAR178 = msg.sender;
FUN33(30000000000 VAR227);
VAR228.VAR195 = bytes32("");
VAR228.VAR196 = bytes32("");
VAR228.VAR197 = bytes32("");
VAR228.VAR198 = 80000;
VAR228.VAR199 = 230000;
VAR181 = FUN70(VAR178);
}
horses_info public VAR228;
chronus_info public VAR229;
modifier onlyOwner {
require(VAR178 == msg.sender);
VAR42;
}
modifier VAR230 {
require(VAR229.VAR183);
require(VAR231 < VAR229.VAR187 + VAR229.VAR188);
VAR42;
}
modifier VAR232 {
require(!VAR229.VAR183 && !VAR229.VAR184);
VAR42;
}
modifier VAR233 {
require(VAR229.VAR185);
VAR42;
}
function FUN71(address VAR234) onlyOwner external {
VAR178 = VAR234;
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) public {
require (msg.sender == FUN30());
require (!VAR229.VAR185);
bytes32 VAR235;
VAR229.VAR184 = true;
VAR229.VAR183 = false;
VAR181.FUN63();
VAR235 = VAR215[VAR45];
if (VAR45 == VAR216[VAR235].VAR209) {
if (VAR216[VAR235].VAR204 > 0) {
} else if (VAR231 >= VAR229.VAR187+VAR229.VAR188+ 60 VAR236) {
FUN72();
} else {
VAR216[VAR235].VAR204 = FUN73(VAR46);
emit FUN66(VAR216[VAR235].VAR204);
}
} else if (VAR45 == VAR216[VAR235].VAR210){
if (VAR216[VAR235].VAR204 > 0 ){
if (VAR216[VAR235].VAR205 > 0) {
} else if (VAR231 >= VAR229.VAR187+VAR229.VAR189+ 60 VAR236) {
FUN72();
} else {
VAR216[VAR235].VAR205 = FUN73(VAR46);
VAR216[VAR235].VAR208 = true;
emit FUN66(VAR216[VAR235].VAR205);
if (VAR216[VAR228.VAR196].VAR208 && VAR216[VAR228.VAR195].VAR208 && VAR216[VAR228.VAR197].VAR208) {
FUN74();
}
}
} else {
FUN72();
}
}
}
function FUN75(bytes32 VAR201) external duringBetting payable  {
require(msg.value >= 0.01 VAR53);
if (VAR217[msg.sender].VAR212==0) {
VAR219+=1;
}
uint VAR237 = VAR217[msg.sender].VAR214[VAR201] + msg.value;
VAR217[msg.sender].VAR214[VAR201] = VAR237;
VAR217[msg.sender].VAR212 += FUN38(msg.value);
uint160 VAR238 = VAR216[VAR201].VAR206 + FUN38(msg.value);
uint32 VAR239 = VAR216[VAR201].VAR207 + 1;
VAR216[VAR201].VAR206 = VAR238;
VAR216[VAR201].VAR207 = VAR239;
emit FUN67(msg.sender, msg.value, VAR201, VAR231);
}
function () private payable {}
function FUN76(uint VAR240, uint  VAR241) onlyOwner beforeBetting public payable returns(bool) {
if (FUN26("" , VAR228.VAR198)*3 + FUN26("", VAR228.VAR199)*3  > address(this).VAR242) {
emit FUN65("");
return false;
} else {
VAR229.VAR187 = FUN77(VAR243.VAR57);
VAR229.VAR183 = true;
bytes32 VAR244;
emit FUN65("");
VAR229.VAR188 = FUN77(VAR240);
VAR244 = FUN27(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR196;
VAR216[VAR228.VAR196].VAR209 = VAR244;
VAR244 = FUN27(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR197;
VAR216[VAR228.VAR197].VAR209 = VAR244;
VAR244 = FUN27(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR195;
VAR216[VAR228.VAR195].VAR209 = VAR244;
VAR240 = VAR240.FUN4(VAR241);
VAR244 = FUN27(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR196;
VAR216[VAR228.VAR196].VAR210 = VAR244;
VAR244 = FUN27(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR197;
VAR216[VAR228.VAR197].VAR210 = VAR244;
VAR244 = FUN27(VAR240, "", "FUN78(VAR245:
VAR215[VAR244] = VAR228.VAR195;
VAR216[VAR228.VAR195].VAR210 = VAR244;
VAR229.VAR189 = FUN77(VAR240);
return true;
}
}
function FUN74() internal {
VAR228.VAR192 = FUN79(VAR216[VAR228.VAR195].VAR205 - VAR216[VAR228.VAR195].VAR204)*100000/FUN79(VAR216[VAR228.VAR195].VAR204);
VAR228.VAR193 = FUN79(VAR216[VAR228.VAR196].VAR205 - VAR216[VAR228.VAR196].VAR204)*100000/FUN79(VAR216[VAR228.VAR196].VAR204);
VAR228.VAR194 = FUN79(VAR216[VAR228.VAR197].VAR205 - VAR216[VAR228.VAR197].VAR204)*100000/FUN79(VAR216[VAR228.VAR197].VAR204);
VAR218 = (VAR216[VAR228.VAR195].VAR206) + (VAR216[VAR228.VAR196].VAR206) + (VAR216[VAR228.VAR197].VAR206);
if (VAR219 <= 1) {
FUN72();
} else {
uint VAR246 = VAR218.FUN1(5).FUN2(100);
require(VAR246 < address(this).VAR242);
VAR218 = VAR218.FUN3(VAR246);
VAR181.VAR247.value(VAR246)();
}
if (VAR228.VAR192 > VAR228.VAR193) {
if (VAR228.VAR192 > VAR228.VAR194) {
VAR220[VAR228.VAR195] = true;
VAR179 = VAR216[VAR228.VAR195].VAR206;
}
else if(VAR228.VAR194 > VAR228.VAR192) {
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR197].VAR206;
} else {
VAR220[VAR228.VAR195] = true;
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR195].VAR206 + (VAR216[VAR228.VAR197].VAR206);
}
} else if(VAR228.VAR193 > VAR228.VAR192) {
if (VAR228.VAR193 > VAR228.VAR194) {
VAR220[VAR228.VAR196] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206;
}
else if (VAR228.VAR194 > VAR228.VAR193) {
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR197].VAR206;
} else {
VAR220[VAR228.VAR196] = true;
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206 + (VAR216[VAR228.VAR197].VAR206);
}
} else {
if (VAR228.VAR194 > VAR228.VAR193) {
VAR220[VAR228.VAR197] = true;
VAR179 = VAR216[VAR228.VAR197].VAR206;
} else if(VAR228.VAR194 < VAR228.VAR193){
VAR220[VAR228.VAR196] = true;
VAR220[VAR228.VAR195] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206 + (VAR216[VAR228.VAR195].VAR206);
} else {
VAR220[VAR228.VAR197] = true;
VAR220[VAR228.VAR196] = true;
VAR220[VAR228.VAR195] = true;
VAR179 = VAR216[VAR228.VAR196].VAR206 + (VAR216[VAR228.VAR195].VAR206) + (VAR216[VAR228.VAR197].VAR206);
}
}
VAR229.VAR185 = true;
}
function FUN80(address VAR248) internal afterRace constant returns(uint VAR249) {
voter_info storage VAR250 = VAR217[VAR248];
if(VAR229.VAR186) {
VAR249 = VAR250.VAR212;
} else {
uint VAR251;
if(VAR220[VAR228.VAR195]) {
VAR251 += VAR250.VAR214[VAR228.VAR195];
} if(VAR220[VAR228.VAR196]) {
VAR251 += VAR250.VAR214[VAR228.VAR196];
} if(VAR220[VAR228.VAR197]) {
VAR251 += VAR250.VAR214[VAR228.VAR197];
}
VAR249 += (((VAR218.FUN1(10000000)).FUN2(VAR179)).FUN1(VAR251)).FUN2(10000000);
}
}
function FUN81() afterRace external constant returns (uint) {
require(!VAR217[msg.sender].VAR213);
return FUN80(msg.sender);
}
function FUN82() afterRace external {
require(!VAR217[msg.sender].VAR213);
uint VAR252 = FUN80(msg.sender);
require(address(this).VAR242 >= VAR252);
VAR217[msg.sender].VAR213 = true;
msg.sender.transfer(VAR252);
emit FUN68(msg.sender, VAR252);
}
function FUN72() internal {
VAR229.VAR186=true;
VAR229.VAR185 = true;
VAR229.VAR190=FUN77(VAR231);
}
function FUN73(string VAR171) internal pure returns (uint VAR46) {
uint VAR253 =2;
bool VAR254=false;
bytes memory VAR4 = bytes(VAR171);
uint VAR78;
VAR46 = 0;
for (VAR78 = 0; VAR78 < VAR4.VAR81; VAR78++) {
if (VAR254) {VAR253 = VAR253-1;}
if (uint(VAR4[VAR78]) == 46){VAR254 = true;}
uint VAR5 = uint(VAR4[VAR78]);
if (VAR5 >= 48 && VAR5 <= 57) {VAR46 = VAR46 * 10 + (VAR5 - 48);}
if (VAR254 && VAR253 == 0){return VAR46;}
}
while (VAR253!=0) {
VAR46 = VAR46*10;
VAR253=VAR253-1;
}
}
function FUN83(bytes32 VAR255, address VAR248) external constant returns (uint, uint, uint, bool, uint) {
return (VAR216[VAR255].VAR206, VAR216[VAR255].VAR204, VAR216[VAR255].VAR205, VAR216[VAR255].VAR208, VAR217[VAR248].VAR214[VAR255]);
}
function FUN84() external constant returns (uint) {
return ((VAR216[VAR228.VAR195].VAR206) + (VAR216[VAR228.VAR196].VAR206) + (VAR216[VAR228.VAR197].VAR206));
}
function FUN85() external onlyOwner {
require(VAR231 > VAR229.VAR187 + VAR229.VAR189);
require((VAR229.VAR183 && !VAR229.VAR184)
|| (VAR229.VAR184 && !VAR229.VAR185));
VAR229.VAR186 = true;
VAR229.VAR185 = true;
VAR229.VAR190=FUN77(VAR231);
VAR181.FUN63();
}
function FUN86() external onlyOwner{
require((VAR229.VAR185 && VAR231 > VAR229.VAR187 + VAR229.VAR189 + (30 VAR256))
|| (VAR229.VAR186 && VAR231 > VAR229.VAR190 + (30 VAR256)));
VAR181.VAR247.value(address(this).VAR242)();
}
}
1
---------------------------------
43 0x3b3a01d42c9cd96d428eb07a708c6b2d9925ae15.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
Pinakion public VAR3;
Kleros public VAR4;
uint public VAR5;
uint public VAR6;
uint public VAR7;
uint public VAR8;
bool public VAR9;
uint public VAR10;
mapping (address => uint) public VAR11;
address public VAR12;
uint public VAR13;
modifier FUN1(address VAR14) {require(msg.sender == VAR14); VAR15;}
event FUN2(uint VAR16, uint VAR8 ,address VAR17);
event FUN3(uint VAR16, address VAR18, string VAR19);
constructor(Pinakion VAR20, Kleros VAR21, uint VAR22, uint VAR23, uint VAR24, uint VAR25) public {
VAR3 = VAR20;
VAR4 = VAR21;
VAR6 = VAR22;
VAR7 = VAR23;
VAR8 = VAR24;
VAR12 = msg.sender;
VAR10 = VAR25;
}
function FUN4(address VAR26, uint VAR27, address, bytes) public FUN1(VAR3) {
require(VAR3.FUN5(VAR26, this, VAR27));
VAR5 += VAR27;
}
function FUN6() {
FUN7(msg.sender);
}
function FUN7(address VAR28) {
uint VAR29 = VAR11[VAR28];
VAR11[VAR28] = 0;
VAR5 = FUN8(VAR5, VAR29);
VAR13 = FUN8(VAR13, VAR29);
require(VAR3.transfer(VAR28, VAR29));
}
function FUN8(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
assert(VAR31 <= VAR30);
return VAR30 - VAR31;
}
function FUN9(){
require(VAR9);
if (VAR5 > VAR13) {
uint VAR29 = VAR5 - VAR13;
VAR5 = VAR13;
require(VAR3.transfer(VAR12, VAR29));
}
}
function FUN10() public {
require(VAR4.FUN11(VAR6) ==  VAR32.VAR33.VAR34);
require(!VAR9);
VAR9 = true;
FUN12 (, , VAR35, VAR36, , , ,) = VAR4.FUN13(VAR6);
if (VAR4.FUN14(VAR6) != VAR7){
uint VAR37 = VAR4.FUN15();
uint VAR38 = VAR4.FUN16(VAR6, VAR35);
for (uint VAR39=0; VAR39 <= (VAR35 > VAR10 ? VAR10 : VAR35); VAR39++){
if (VAR38 != 0){
uint VAR40 = 0;
for (uint VAR41 = 0; VAR41 <= VAR36; VAR41++) {
VAR40 += VAR4.FUN17(VAR6, VAR39, VAR41);
}
emit FUN3(VAR37, 0x0 ,"");
emit FUN3(VAR40, 0x0, "");
uint VAR42 = 0;
uint VAR43 = 0;
for (uint VAR44=0; VAR44 < VAR40; VAR44++){
uint VAR45 = VAR4.FUN18(VAR6, VAR39, VAR44);
address VAR46 = VAR4.FUN19(VAR6, VAR39, VAR44);
emit FUN3(VAR45, VAR46, "");
if (VAR45 != VAR38){
VAR42 += VAR37;
if (VAR45 == VAR7){
VAR11[VAR46] += VAR37 + VAR8;
VAR13 += VAR37 + VAR8;
emit FUN2(VAR37, VAR8, VAR46);
}
} else {
VAR43++;
}
}
uint VAR47 = (VAR42 - VAR37) / (VAR43 + 1);
for (VAR44 = 0; VAR44 < VAR40; VAR44++){
VAR45 = VAR4.FUN18(VAR6, VAR39, VAR44);
VAR46 = VAR4.FUN19(VAR6, VAR39, VAR44);
if (VAR45 == VAR7){
VAR11[VAR46] += VAR47;
VAR13 += VAR47;
emit FUN2(VAR47, 0, VAR46);
}
}
}
}
}
}
}
pragma VAR1 ^0.4.24;
contract VAR48 {
function FUN4(address VAR49, uint256 VAR27, address VAR50, bytes VAR51) public;
}
contract VAR52 {
function FUN20(address VAR53) public payable returns(bool);
function FUN21(address VAR26, address VAR54, uint VAR27) public returns(bool);
function FUN22(address VAR53, address VAR55, uint VAR27) public
returns(bool);
}
contract VAR56 {
modifier VAR57 { require(msg.sender == VAR58); VAR15; }
address public VAR58;
function FUN23() public { VAR58 = msg.sender;}
function FUN24(address VAR59) public VAR57 {
VAR58 = VAR59;
}
}
contract Pinakion is VAR56 {
string public VAR60;
uint8 public VAR61;
string public VAR62;
string public VAR63 = '';
struct  VAR64 {
uint128 VAR65;
uint128 value;
}
Pinakion public VAR66;
uint public VAR67;
uint public VAR68;
mapping (address => VAR64[]) VAR69;
mapping (address => mapping (address => uint256)) VAR70;
VAR64[] VAR71;
bool public VAR72;
MiniMeTokenFactory public VAR73;
function FUN25(
address VAR74,
address VAR75,
uint VAR76,
string VAR77,
uint8 VAR78,
string VAR79,
bool VAR80
) public {
VAR73 = FUN26(VAR74);
VAR60 = VAR77;
VAR61 = VAR78;
VAR62 = VAR79;
VAR66 = FUN25(VAR75);
VAR67 = VAR76;
VAR72 = VAR80;
VAR68 = VAR81.VAR82;
}
function transfer(address VAR54, uint256 VAR27) public returns (bool VAR83) {
require(VAR72);
FUN27(msg.sender, VAR54, VAR27);
return true;
}
function FUN5(address VAR26, address VAR54, uint256 VAR27
) public returns (bool VAR83) {
if (msg.sender != VAR58) {
require(VAR72);
require(VAR70[VAR26][msg.sender] >= VAR27);
VAR70[VAR26][msg.sender] -= VAR27;
}
FUN27(VAR26, VAR54, VAR27);
return true;
}
function FUN27(address VAR26, address VAR54, uint VAR27
) internal {
if (VAR27 == 0) {
Transfer(VAR26, VAR54, VAR27);
return;
}
require(VAR67 < VAR81.VAR82);
require((VAR54 != 0) && (VAR54 != address(this)));
var VAR84 = FUN28(VAR26, VAR81.VAR82);
require(VAR84 >= VAR27);
if (FUN29(VAR58)) {
require(FUN30(VAR58).FUN21(VAR26, VAR54, VAR27));
}
FUN31(VAR69[VAR26], VAR84 - VAR27);
var VAR85 = FUN28(VAR54, VAR81.VAR82);
require(VAR85 + VAR27 >= VAR85);
FUN31(VAR69[VAR54], VAR85 + VAR27);
Transfer(VAR26, VAR54, VAR27);
}
function FUN32(address VAR53) public constant returns (uint256 VAR5) {
return FUN28(VAR53, VAR81.VAR82);
}
function FUN33(address VAR55, uint256 VAR27) public returns (bool VAR83) {
require(VAR72);
if (FUN29(VAR58)) {
require(FUN30(VAR58).FUN22(msg.sender, VAR55, VAR27));
}
VAR70[msg.sender][VAR55] = VAR27;
FUN34(msg.sender, VAR55, VAR27);
return true;
}
function FUN35(address VAR53, address VAR55
) public constant returns (uint256 VAR86) {
return VAR70[VAR53][VAR55];
}
function FUN36(address VAR55, uint256 VAR27, bytes VAR87
) public returns (bool VAR83) {
require(FUN33(VAR55, VAR27));
FUN37(VAR55).FUN4(
msg.sender,
VAR27,
this,
VAR87
);
return true;
}
function FUN38() public constant returns (uint) {
return FUN39(VAR81.VAR82);
}
function FUN28(address VAR53, uint VAR88) public constant
returns (uint) {
if ((VAR69[VAR53].VAR89 == 0)
|| (VAR69[VAR53][0].VAR65 > VAR88)) {
if (address(VAR66) != 0) {
return VAR66.FUN28(VAR53, FUN40(VAR88, VAR67));
} else {
return 0;
}
} else {
return FUN41(VAR69[VAR53], VAR88);
}
}
function FUN39(uint VAR88) public constant returns(uint) {
if ((VAR71.VAR89 == 0)
|| (VAR71[0].VAR65 > VAR88)) {
if (address(VAR66) != 0) {
return VAR66.FUN39(FUN40(VAR88, VAR67));
} else {
return 0;
}
} else {
return FUN41(VAR71, VAR88);
}
}
function FUN42(
string VAR90,
uint8 VAR91,
string VAR92,
uint VAR93,
bool VAR80
) public returns(address) {
if (VAR93 == 0) VAR93 = VAR81.VAR82;
Pinakion VAR94 = VAR73.FUN42(
this,
VAR93,
VAR90,
VAR91,
VAR92,
VAR80
);
VAR94.FUN24(msg.sender);
FUN43(address(VAR94), VAR93);
return address(VAR94);
}
function FUN44(address VAR53, uint VAR27
) public onlyController returns (bool) {
uint VAR95 = FUN38();
require(VAR95 + VAR27 >= VAR95);
uint VAR85 = FUN32(VAR53);
require(VAR85 + VAR27 >= VAR85);
FUN31(VAR71, VAR95 + VAR27);
FUN31(VAR69[VAR53], VAR85 + VAR27);
Transfer(0, VAR53, VAR27);
return true;
}
function FUN45(address VAR53, uint VAR27
) onlyController public returns (bool) {
uint VAR95 = FUN38();
require(VAR95 >= VAR27);
uint VAR84 = FUN32(VAR53);
require(VAR84 >= VAR27);
FUN31(VAR71, VAR95 - VAR27);
FUN31(VAR69[VAR53], VAR84 - VAR27);
Transfer(VAR53, 0, VAR27);
return true;
}
function FUN46(bool VAR80) public VAR57 {
VAR72 = VAR80;
}
function FUN41(VAR64[] storage VAR96, uint VAR97
) constant internal returns (uint) {
if (VAR96.VAR89 == 0) return 0;
if (VAR97 >= VAR96[VAR96.VAR89-1].VAR65)
return VAR96[VAR96.VAR89-1].value;
if (VAR97 < VAR96[0].VAR65) return 0;
uint VAR98 = 0;
uint VAR99 = VAR96.VAR89-1;
while (VAR99 > VAR98) {
uint VAR100 = (VAR99 + VAR98 + 1)/ 2;
if (VAR96[VAR100].VAR65<=VAR97) {
VAR98 = VAR100;
} else {
VAR99 = VAR100-1;
}
}
return VAR96[VAR98].value;
}
function FUN31(VAR64[] storage VAR96, uint VAR101
) internal  {
if ((VAR96.VAR89 == 0)
|| (VAR96[VAR96.VAR89 -1].VAR65 < VAR81.VAR82)) {
Checkpoint storage VAR102 = VAR96[ VAR96.VAR89++ ];
VAR102.VAR65 =  uint128(VAR81.VAR82);
VAR102.value = uint128(VAR101);
} else {
Checkpoint storage VAR103 = VAR96[VAR96.VAR89-1];
VAR103.value = uint128(VAR101);
}
}
function FUN29(address VAR104) constant internal returns(bool) {
uint VAR105;
if (VAR104 == 0) return false;
VAR106 {
VAR105 := FUN47(VAR104)
}
return VAR105>0;
}
function FUN40(uint VAR107, uint VAR108) pure internal returns (uint) {
return VAR107 < VAR108 ? VAR107 : VAR108;
}
function () public payable {
require(FUN29(VAR58));
require(FUN30(VAR58).VAR109.value(msg.value)(msg.sender));
}
function FUN48(address VAR50) public VAR57 {
if (VAR50 == 0x0) {
VAR58.transfer(this.VAR5);
return;
}
Pinakion VAR110 = FUN25(VAR50);
uint VAR5 = VAR110.FUN32(this);
VAR110.transfer(VAR58, VAR5);
FUN49(VAR50, VAR58, VAR5);
}
event FUN49(address indexed VAR50, address indexed VAR111, uint VAR27);
event Transfer(address indexed VAR26, address indexed VAR54, uint256 VAR27);
event FUN43(address indexed VAR112, uint VAR93);
event FUN34(
address indexed VAR53,
address indexed VAR55,
uint256 VAR27
);
}
contract VAR113 {
function FUN42(
address VAR75,
uint VAR93,
string VAR77,
uint8 VAR78,
string VAR79,
bool VAR80
) public returns (VAR114) {
Pinakion VAR115 = VAR116 FUN25(
this,
VAR75,
VAR93,
VAR77,
VAR78,
VAR79,
VAR80
);
VAR115.FUN24(msg.sender);
return VAR115;
}
}
contract VAR117{
function FUN50(uint VAR97) public payable;
function FUN51(uint VAR97) public payable {
FUN50(VAR97);
}
function FUN52(uint VAR97) public returns (uint VAR118);
function FUN53(uint VAR97) public returns (uint VAR118) {
uint VAR119=FUN52(VAR97);
if (VAR119==0)
return 0;
else
return uint(FUN54(msg.sender,VAR119));
}
}
contract BlockHashRNG is VAR117 {
mapping (uint => uint) public VAR120;
mapping (uint => uint) public VAR121;
function FUN50(uint VAR97) public payable { VAR121[VAR97]+=msg.value; }
function FUN52(uint VAR97) public returns (uint VAR118) {
VAR118=VAR120[VAR97];
if (VAR118==0){
FUN55(VAR97);
return VAR120[VAR97];
}
else
return VAR118;
}
function FUN55(uint VAR97) public {
if (FUN56(VAR97) != 0x0)
VAR120[VAR97] = uint(FUN56(VAR97));
if (VAR120[VAR97] != 0) {
uint VAR122 = VAR121[VAR97];
VAR121[VAR97] = 0;
msg.sender.FUN57(VAR122);
}
}
}
contract BlockHashRNGFallback is VAR123 {
function FUN55(uint VAR97) public {
if (VAR97<VAR81.VAR82 && VAR120[VAR97]==0) {
if (FUN56(VAR97)!=0x0)
VAR120[VAR97]=uint(FUN56(VAR97));
else
VAR120[VAR97]=uint(FUN56(VAR81.VAR82-1));
}
if (VAR120[VAR97] != 0) {
uint VAR122=VAR121[VAR97];
VAR121[VAR97]=0;
msg.sender.FUN57(VAR122);
}
}
}
contract VAR124{
Arbitrator public VAR125;
bytes public VAR126;
modifier VAR127 {require(msg.sender==address(VAR125)); VAR15;}
event FUN58(Arbitrator indexed VAR128, uint indexed VAR22, uint VAR129);
event FUN59(uint indexed VAR130, string VAR131);
event FUN60(Arbitrator indexed VAR128, uint indexed VAR22, uint VAR130);
event FUN61(Arbitrator indexed VAR128, uint indexed VAR22, address VAR132, string VAR131);
constructor(Arbitrator VAR128, bytes VAR133) public {
VAR125 = VAR128;
VAR126 = VAR133;
}
function FUN62(uint VAR22, uint VAR129) public VAR127 {
emit FUN58(FUN63(msg.sender),VAR22,VAR129);
FUN64(VAR22,VAR129);
}
function FUN64(uint VAR22, uint VAR129) internal;
}
contract VAR32{
enum VAR33 {VAR134, VAR135, VAR34}
modifier FUN65(bytes VAR87) {require(msg.value>=FUN66(VAR87)); VAR15;}
modifier FUN67(uint VAR22, bytes VAR87) {require(msg.value>=FUN68(VAR22, VAR87)); VAR15;}
event FUN69(uint VAR22);
event FUN70(uint indexed VAR22, Arbitrable VAR136);
event FUN71(uint indexed VAR22, Arbitrable VAR136);
function FUN72(uint VAR137, bytes VAR87) public FUN65(VAR87) payable returns(uint VAR6)  {}
function FUN66(bytes VAR87) public constant returns(uint VAR138);
function FUN73(uint VAR22, bytes VAR87) public FUN67(VAR22,VAR87) payable {
emit FUN71(VAR22, FUN74(msg.sender));
}
function FUN68(uint VAR22, bytes VAR87) public constant returns(uint VAR138);
function FUN11(uint VAR22) public constant returns(DisputeStatus VAR139);
function FUN14(uint VAR22) public constant returns(uint VAR140);
}
contract Kleros is VAR32, VAR48 {
Pinakion public VAR3;
uint public constant VAR141 = (2**256 - 2) / 2;
RNG public VAR142;
uint public VAR143 = 0.05 VAR144;
uint16 public VAR145 = 3;
uint public VAR146 = 0.1 * 1e18;
uint[5] public VAR147;
uint public VAR148 = 2000;
uint constant VAR149 = 1e4;
uint public VAR10 = 5;
address public VAR150;
uint public VAR151 = 1;
uint public VAR152;
uint public VAR153;
uint public VAR154;
uint public VAR120;
enum VAR155 {
VAR156,
VAR157,
VAR158,
VAR159,
VAR160
}
Period public VAR161;
struct VAR162 {
uint VAR5;
uint VAR163;
uint VAR164;
uint VAR165;
uint VAR166;
}
mapping (address => VAR162) public VAR167;
struct VAR158 {
address VAR168;
uint VAR140;
}
struct VAR169 {
uint VAR38;
uint VAR170;
mapping (uint => uint) VAR171;
}
enum VAR172 {
VAR173,
VAR174,
VAR175,
VAR176
}
struct VAR177 {
Arbitrable VAR178;
uint VAR151;
uint VAR35;
uint VAR36;
uint16 VAR179;
uint VAR143;
DisputeState VAR180;
VAR158[][] VAR181;
VAR169[] VAR182;
mapping (address => uint) VAR183;
uint VAR184;
VAR185[] VAR186;
}
enum VAR187 {
VAR188,
VAR189,
VAR190,
VAR191
}
struct VAR185 {
uint VAR42;
uint VAR43;
uint VAR192;
uint VAR193;
uint VAR194;
RepartitionStage VAR195;
}
VAR177[] public VAR196;
event FUN75(Period VAR197, uint indexed VAR198);
event FUN76(address indexed VAR14, uint VAR22, int VAR27);
event FUN77(address indexed VAR14, uint VAR22, uint VAR27);
modifier FUN1(address VAR14) {require(msg.sender == VAR14); VAR15;}
modifier FUN78(Period VAR197) {require(VAR161 == VAR197); VAR15;}
modifier onlyGovernor() {require(msg.sender == VAR150); VAR15;}
constructor(Pinakion VAR20, RNG VAR199, uint[5] VAR200, address VAR201) public {
VAR3 = VAR20;
VAR142 = VAR199;
VAR152 = VAR202;
VAR147 = VAR200;
VAR150 = VAR201;
}
function FUN4(address VAR26, uint VAR27, address, bytes) public FUN1(VAR3) {
require(VAR3.FUN5(VAR26, this, VAR27));
VAR167[VAR26].VAR5 += VAR27;
}
function FUN79(uint VAR101) public {
Juror storage VAR17 = VAR167[msg.sender];
require(VAR17.VAR163 <= VAR17.VAR5);
require(VAR101 <= VAR17.VAR5-VAR17.VAR163);
require(VAR17.VAR164 != VAR151);
VAR17.VAR5 -= VAR101;
require(VAR3.transfer(msg.sender,VAR101));
}
function FUN80() public {
require(VAR202-VAR152 >= VAR147[uint8(VAR161)]);
if (VAR161 == VAR155.VAR156) {
VAR154 = VAR81.VAR82 + 1;
VAR142.FUN51(VAR154);
VAR161 = VAR155.VAR157;
} else if (VAR161 == VAR155.VAR157) {
VAR120 = VAR142.FUN53(VAR154);
require(VAR120 != 0);
VAR161 = VAR155.VAR158;
} else if (VAR161 == VAR155.VAR158) {
VAR161 = VAR155.VAR159;
} else if (VAR161 == VAR155.VAR159) {
VAR161 = VAR155.VAR160;
} else if (VAR161 == VAR155.VAR160) {
VAR161 = VAR155.VAR156;
++VAR151;
VAR153 = 0;
VAR154 = 0;
VAR120 = 0;
}
VAR152 = VAR202;
FUN75(VAR161, VAR151);
}
function FUN81(uint VAR101) public FUN78(VAR155.VAR156) {
Juror storage VAR17 = VAR167[msg.sender];
require(VAR101 <= VAR17.VAR5);
require(VAR101 >= VAR146);
require(VAR17.VAR164 != VAR151);
VAR17.VAR164 = VAR151;
VAR17.VAR165 = VAR153;
VAR153 += VAR101;
VAR17.VAR166 = VAR153;
}
function FUN82(uint VAR22, uint VAR129, uint[] VAR203) public FUN78(VAR155.VAR158) {
Dispute storage VAR204 = VAR196[VAR22];
Juror storage VAR17 = VAR167[msg.sender];
VoteCounter storage VAR182 = VAR204.VAR182[VAR204.VAR35];
require(VAR204.VAR183[msg.sender] != VAR151);
require(VAR129 <= VAR204.VAR36);
require(FUN83(msg.sender, VAR22, VAR203));
VAR204.VAR183[msg.sender] = VAR151;
VAR182.VAR171[VAR129] += VAR203.VAR89;
if (VAR182.VAR170 < VAR182.VAR171[VAR129]) {
VAR182.VAR170 = VAR182.VAR171[VAR129];
VAR182.VAR38 = VAR129;
} else if (VAR182.VAR170==VAR182.VAR171[VAR129] && VAR203.VAR89!=0) {
VAR182.VAR38 = 0;
}
for (uint VAR39 = 0; VAR39 < VAR203.VAR89; ++VAR39) {
VAR204.VAR181[VAR204.VAR35].FUN84(FUN85({
VAR168: msg.sender,
VAR140: VAR129
}));
}
VAR17.VAR163 += VAR203.VAR89 * FUN15();
uint VAR205 = VAR203.VAR89 * VAR204.VAR143;
msg.sender.transfer(VAR205);
FUN77(msg.sender, VAR22, VAR205);
}
function FUN86(address VAR206, uint VAR22, uint[] VAR203) public {
Dispute storage VAR204 = VAR196[VAR22];
Juror storage VAR207 = VAR167[VAR206];
require(VAR161 > VAR155.VAR158);
require(VAR204.VAR183[VAR206] != VAR151);
VAR204.VAR183[VAR206] = VAR151;
require(FUN83(VAR206, VAR22, VAR203));
uint VAR208 = VAR203.VAR89 * VAR146 * 2 * VAR148 / VAR149;
VAR208 = (VAR208 < VAR207.VAR5) ? VAR208 : VAR207.VAR5;
VAR207.VAR5 -= VAR208;
FUN76(VAR206, VAR22, -int(VAR208));
VAR167[msg.sender].VAR5 += VAR208 / 2;
FUN76(msg.sender, VAR22, int(VAR208 / 2));
VAR167[VAR150].VAR5 += VAR208 / 2;
FUN76(VAR150, VAR22, int(VAR208 / 2));
msg.sender.transfer(VAR203.VAR89*VAR204.VAR143);
}
function FUN87(uint VAR22) public FUN78(VAR155.VAR160) {
Dispute storage VAR204 = VAR196[VAR22];
require(VAR204.VAR180 == VAR172.VAR173);
require(VAR204.VAR151+VAR204.VAR35 <= VAR151);
uint VAR38 = VAR204.VAR182[VAR204.VAR35].VAR38;
uint VAR37 = FUN15();
for (uint VAR39 = 0; VAR39 <= VAR204.VAR35; ++VAR39) {
if (VAR38!=0 || (VAR204.VAR182[VAR204.VAR35].VAR171[0] == VAR204.VAR182[VAR204.VAR35].VAR170)) {
uint VAR42 = 0;
uint VAR43 = 0;
for (uint VAR44 = 0; VAR44 < VAR204.VAR181[VAR39].VAR89; ++VAR44) {
Vote storage VAR209 = VAR204.VAR181[VAR39][VAR44];
if (VAR209.VAR140 != VAR38) {
Juror storage VAR17 = VAR167[VAR209.VAR168];
uint VAR210 = VAR37<VAR17.VAR5 ? VAR37 : VAR17.VAR5;
VAR17.VAR5 -= VAR210;
FUN76(VAR209.VAR168, VAR22, int(-VAR210));
VAR42 += VAR210;
} else {
++VAR43;
}
}
if (VAR43 == 0) {
VAR167[VAR150].VAR5 += VAR42;
FUN76(VAR150, VAR22, int(VAR42));
} else {
uint VAR47 = VAR42 / VAR43;
for (VAR44 = 0; VAR44 < VAR204.VAR181[VAR39].VAR89; ++VAR44) {
VAR209 = VAR204.VAR181[VAR39][VAR44];
if (VAR209.VAR140 == VAR38) {
VAR17 = VAR167[VAR209.VAR168];
VAR17.VAR5 += VAR47;
FUN76(VAR209.VAR168, VAR22, int(VAR47));
}
}
}
}
for (VAR44 = 0; VAR44 < VAR204.VAR181[VAR39].VAR89; ++VAR44) {
VAR209 = VAR204.VAR181[VAR39][VAR44];
VAR17 = VAR167[VAR209.VAR168];
VAR17.VAR163 -= VAR37;
}
}
VAR204.VAR180 = VAR172.VAR175;
}
function FUN88(uint VAR22, uint VAR211) public FUN78(VAR155.VAR160) {
Dispute storage VAR204 = VAR196[VAR22];
require(VAR204.VAR180 <= VAR172.VAR174);
require(VAR204.VAR151+VAR204.VAR35 <= VAR151);
VAR204.VAR180 = VAR172.VAR174;
uint VAR38 = VAR204.VAR182[VAR204.VAR35].VAR38;
uint VAR37 = FUN15();
uint VAR212 = 0;
for (uint VAR39 = VAR204.VAR184; VAR39 <= VAR204.VAR35; ++VAR39) {
if (VAR204.VAR186.VAR89 < VAR39+1) {
VAR204.VAR186.VAR89++;
}
if (VAR38==0 && (VAR204.VAR182[VAR204.VAR35].VAR171[0] != VAR204.VAR182[VAR204.VAR35].VAR170)) {
VAR204.VAR186[VAR39].VAR195 = VAR187.VAR190;
}
if (VAR204.VAR186[VAR39].VAR195 == VAR187.VAR188) {
for (uint VAR44 = VAR204.VAR186[VAR39].VAR192; VAR44 < VAR204.VAR181[VAR39].VAR89; ++VAR44) {
if (VAR212 >= VAR211) {
return;
}
Vote storage VAR209 = VAR204.VAR181[VAR39][VAR44];
if (VAR209.VAR140 != VAR38) {
Juror storage VAR17 = VAR167[VAR209.VAR168];
uint VAR210 = VAR37<VAR17.VAR5 ? VAR37 : VAR17.VAR5;
VAR17.VAR5 -= VAR210;
FUN76(VAR209.VAR168, VAR22, int(-VAR210));
VAR204.VAR186[VAR39].VAR42 += VAR210;
} else {
++VAR204.VAR186[VAR39].VAR43;
}
++VAR204.VAR186[VAR39].VAR192;
++VAR212;
}
VAR204.VAR186[VAR39].VAR195 = VAR187.VAR189;
}
if (VAR204.VAR186[VAR39].VAR195 == VAR187.VAR189) {
if (VAR204.VAR186[VAR39].VAR43 == 0) {
VAR167[VAR150].VAR5 += VAR204.VAR186[VAR39].VAR42;
FUN76(VAR150, VAR22, int(VAR204.VAR186[VAR39].VAR42));
VAR204.VAR186[VAR39].VAR195 = VAR187.VAR190;
} else {
uint VAR47 = VAR204.VAR186[VAR39].VAR42 / VAR204.VAR186[VAR39].VAR43;
for (VAR44 = VAR204.VAR186[VAR39].VAR193; VAR44 < VAR204.VAR181[VAR39].VAR89; ++VAR44) {
if (VAR212 >= VAR211) {
return;
}
VAR209 = VAR204.VAR181[VAR39][VAR44];
if (VAR209.VAR140 == VAR38) {
VAR17 = VAR167[VAR209.VAR168];
VAR17.VAR5 += VAR47;
FUN76(VAR209.VAR168, VAR22, int(VAR47));
}
++VAR212;
++VAR204.VAR186[VAR39].VAR193;
}
VAR204.VAR186[VAR39].VAR195 = VAR187.VAR190;
}
}
if (VAR204.VAR186[VAR39].VAR195 == VAR187.VAR190) {
for (VAR44 = VAR204.VAR186[VAR39].VAR194; VAR44 < VAR204.VAR181[VAR39].VAR89; ++VAR44) {
if (VAR212 >= VAR211) {
return;
}
VAR209 = VAR204.VAR181[VAR39][VAR44];
VAR17 = VAR167[VAR209.VAR168];
VAR17.VAR163 -= VAR37;
++VAR212;
++VAR204.VAR186[VAR39].VAR194;
}
VAR204.VAR186[VAR39].VAR195 = VAR187.VAR191;
}
if (VAR204.VAR186[VAR39].VAR195 == VAR187.VAR191) {
++VAR204.VAR184;
}
}
VAR204.VAR180 = VAR172.VAR175;
}
function FUN89(uint VAR22) public view returns (uint VAR213) {
Dispute storage VAR204 = VAR196[VAR22];
return (VAR204.VAR179 + 1) * 2**VAR204.VAR35 - 1;
}
function FUN83(address VAR206, uint VAR22, uint[] VAR203) public view returns (bool VAR214) {
uint VAR215 = 0;
Juror storage VAR17 = VAR167[VAR206];
Dispute storage VAR204 = VAR196[VAR22];
uint VAR213 = FUN89(VAR22);
if (VAR17.VAR164 != VAR151) return false;
if (VAR204.VAR151+VAR204.VAR35 != VAR151) return false;
if (VAR161 <= VAR155.VAR157) return false;
for (uint VAR39 = 0; VAR39 < VAR203.VAR89; ++VAR39) {
if (VAR203[VAR39] <= VAR215) return false;
VAR215 = VAR203[VAR39];
if (VAR215 > VAR213) return false;
uint VAR216 = uint(FUN54(VAR120, VAR22, VAR215)) % VAR153;
require(VAR216 >= VAR17.VAR165);
require(VAR216 < VAR17.VAR166);
}
return true;
}
function FUN72(uint VAR137, bytes VAR87) public payable returns (uint VAR6) {
uint16 VAR213 = FUN90(VAR87);
require(msg.value >= FUN66(VAR87));
VAR6 = VAR196.VAR89++;
Dispute storage VAR204 = VAR196[VAR6];
VAR204.VAR178 = FUN74(msg.sender);
if (VAR161 < VAR155.VAR157)
VAR204.VAR151 = VAR151;
else
VAR204.VAR151 = VAR151+1;
VAR204.VAR36 = VAR137;
VAR204.VAR179 = VAR213;
VAR204.VAR143 = VAR143;
VAR204.VAR181.VAR89++;
VAR204.VAR182.VAR89++;
FUN70(VAR6, FUN74(msg.sender));
return VAR6;
}
function FUN73(uint VAR22, bytes VAR87) public payable FUN78(VAR155.VAR159) {
super.FUN73(VAR22,VAR87);
Dispute storage VAR204 = VAR196[VAR22];
require(msg.value >= FUN68(VAR22, VAR87));
require(VAR204.VAR151+VAR204.VAR35 == VAR151);
require(VAR204.VAR178 == msg.sender);
VAR204.VAR35++;
VAR204.VAR181.VAR89++;
VAR204.VAR182.VAR89++;
}
function FUN64(uint VAR6) public {
Dispute storage VAR204 = VAR196[VAR6];
require(VAR204.VAR180 == VAR172.VAR175);
VAR204.VAR180 = VAR172.VAR176;
VAR204.VAR178.FUN62(VAR6, VAR204.VAR182[VAR204.VAR35].VAR38);
}
function FUN66(bytes VAR87) public view returns (uint VAR138) {
return FUN90(VAR87) * VAR143;
}
function FUN68(uint VAR22, bytes VAR87) public view returns (uint VAR138) {
Dispute storage VAR204 = VAR196[VAR22];
if(VAR204.VAR35 >= VAR10) return VAR141;
return (2*FUN89(VAR22) + 1) * VAR204.VAR143;
}
function FUN90(bytes VAR87) internal view returns (uint16 VAR213) {
if (VAR87.VAR89 < 2)
return VAR145;
else
return (uint16(VAR87[0]) << 8) + uint16(VAR87[1]);
}
function FUN15() public view returns (uint VAR217) {
return (VAR148 * VAR146) / VAR149;
}
function FUN19(uint VAR22, uint VAR218, uint VAR219) public view returns (address VAR168) {
return VAR196[VAR22].VAR181[VAR218][VAR219].VAR168;
}
function FUN18(uint VAR22, uint VAR218, uint VAR219) public view returns (uint VAR140) {
return VAR196[VAR22].VAR181[VAR218][VAR219].VAR140;
}
function FUN16(uint VAR22, uint VAR218) public view returns (uint VAR38) {
return VAR196[VAR22].VAR182[VAR218].VAR38;
}
function FUN91(uint VAR22, uint VAR218) public view returns (uint VAR170) {
return VAR196[VAR22].VAR182[VAR218].VAR170;
}
function FUN17(uint VAR22, uint VAR218, uint VAR220) public view returns (uint VAR171) {
return VAR196[VAR22].VAR182[VAR218].VAR171[VAR220];
}
function FUN92(uint VAR22, address VAR28) public view returns (uint VAR183) {
return VAR196[VAR22].VAR183[VAR28];
}
function FUN93(uint VAR22, address VAR28, uint VAR221) public view returns (bool VAR222) {
Dispute storage VAR204 = VAR196[VAR22];
Juror storage VAR17 = VAR167[VAR28];
if (VAR17.VAR164 != VAR151
|| (VAR204.VAR151+VAR204.VAR35 != VAR151)
|| VAR161<=VAR155.VAR157
|| VAR221>FUN89(VAR22)
|| VAR221==0
|| VAR153==0
) {
return false;
} else {
uint VAR216 = uint(FUN54(VAR120,VAR22,VAR221)) % VAR153;
return (VAR216 >= VAR17.VAR165) && (VAR216 < VAR17.VAR166);
}
}
function FUN14(uint VAR22) public view returns (uint VAR140) {
Dispute storage VAR204 = VAR196[VAR22];
return VAR204.VAR182[VAR204.VAR35].VAR38;
}
function FUN11(uint VAR22) public view returns (DisputeStatus VAR139) {
Dispute storage VAR204 = VAR196[VAR22];
if (VAR204.VAR151+VAR204.VAR35 < VAR151)
return VAR33.VAR34;
else if(VAR204.VAR151+VAR204.VAR35 == VAR151) {
if (VAR204.VAR180 == VAR172.VAR173) {
if (VAR161 < VAR155.VAR159)
return VAR33.VAR134;
else if (VAR161 == VAR155.VAR159)
return VAR33.VAR135;
else return VAR33.VAR34;
} else return VAR33.VAR34;
} else return VAR33.VAR134;
}
function FUN94(bytes32 VAR51, uint VAR101, address VAR223) public onlyGovernor {
VAR223.call.value(VAR101)(VAR51);
}
function FUN95(RNG VAR199) public onlyGovernor {
VAR142 = VAR199;
}
function FUN96(uint VAR224) public onlyGovernor {
VAR143 = VAR224;
}
function FUN97(uint16 VAR225) public onlyGovernor {
VAR145 = VAR225;
}
function FUN98(uint VAR226) public onlyGovernor {
VAR146 = VAR226;
}
function FUN99(uint[5] VAR200) public onlyGovernor {
VAR147 = VAR200;
}
function FUN100(uint VAR227) public onlyGovernor {
VAR148 = VAR227;
}
function FUN101(uint VAR25) public onlyGovernor {
VAR10 = VAR25;
}
function FUN102(address VAR201) public onlyGovernor {
VAR150 = VAR201;
}
}
1
---------------------------------
44 0x3c0cd870bb7ed4dadd80c8313645b9107b34e259.sol
pragma VAR1 ^0.4.25;
interface VAR2 {
function FUN1(address VAR3) payable external returns(uint256);
function FUN2(uint256 VAR4) external;
function FUN3() external;
function FUN4() external;
function transfer(address VAR5, uint256 VAR4) external returns(bool);
function FUN5(address VAR6) view external returns(uint256);
function FUN6(bool VAR7) external view returns(uint256);
}
contract VAR8 {
event FUN7(address indexed VAR9, address indexed VAR10);
mapping (address => address) public VAR11;
function FUN8()
public
view
returns (bool)
{
return VAR11[msg.sender] != address(0);
}
function FUN9()
external
view
returns (address)
{
require(FUN8(), "");
return VAR11[msg.sender];
}
function FUN10(uint256 VAR12)
public
{
require(!FUN8(), "");
require(VAR12 > 0);
address VAR9 = msg.sender;
VAR11[VAR9] = VAR13 FUN11(VAR9, VAR12);
emit FUN7(VAR9, VAR11[VAR9]);
}
}
contract VAR14 {
HourglassInterface constant VAR15 = FUN12(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
address public VAR9;
uint256 public VAR16;
uint256 public VAR17;
modifier FUN13()
{
require(VAR18 >= VAR16 + VAR17 * 1 VAR19);
VAR20;
}
modifier onlyOwner()
{
require(msg.sender == VAR9);
VAR20;
}
constructor(address VAR21, uint256 VAR12)
public
{
VAR9 = VAR21;
VAR17 =VAR12;
VAR16 = VAR18;
}
function() public payable {}
function FUN14()
public
view
returns(bool)
{
return VAR18 < VAR16 + VAR17 * 1 VAR19;
}
function FUN15()
external
view
returns(uint256)
{
return VAR16 + VAR17 * 1 VAR19;
}
function FUN16(uint256 VAR22)
external
onlyOwner
{
uint256 VAR23 = VAR17 + VAR22;
require(VAR23 > VAR17);
VAR17 = VAR23;
}
function FUN4()
external
onlyOwner
{
VAR9.transfer(address(this).VAR24);
}
function FUN17()
external
onlyOwner
{
VAR15.VAR25.value(address(this).VAR24)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);
}
function FUN5()
external
view
returns(uint256)
{
return VAR15.FUN5(address(this));
}
function FUN18()
external
view
returns(uint256)
{
return VAR15.FUN6(true);
}
function FUN1()
external
payable
onlyOwner
{
VAR15.VAR25.value(msg.value)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);
}
function FUN3()
external
onlyOwner
{
VAR15.FUN3();
}
function FUN19()
external
onlyOwner
{
VAR15.FUN4();
VAR9.transfer(address(this).VAR24);
}
function FUN2(uint256 VAR26)
external
VAR27
onlyOwner
{
VAR15.FUN2(VAR26);
VAR9.transfer(address(this).VAR24);
}
function transfer(address VAR5, uint256 VAR4)
external
VAR27
onlyOwner
returns(bool)
{
return VAR15.transfer(VAR5, VAR4);
}
}
1
---------------------------------
45 0x3c3f481950fa627bb9f39a04bccdc88f4130795b.sol
pragma VAR1 ^0.4.24;
contract VAR2{
address VAR3 = address(0);
bool VAR4 = false;
function FUN1() payable
{
if ((FUN2()%2==1) && (msg.value == 1 VAR5) && (!VAR4))
{
if (!msg.sender.call.value(2 VAR5)())
throw;
}
}
function FUN3()
{
if (VAR3==msg.sender)
{
VAR4 = true;
}
}
function FUN4()
{
if (VAR3==msg.sender)
{
VAR4 = false;
}
}
function FUN5(address VAR6)
{
if ((VAR3 == address(0)) || (VAR3 == msg.sender))
{
VAR3 = VAR6;
}
}
function FUN6(uint VAR7)
{
if (VAR3==msg.sender)
{
if (!msg.sender.call.value( VAR7 * (1 VAR5))())
throw;
}
}
function FUN2() view returns (uint8) {
return uint8(uint256(FUN7(VAR8.VAR9, VAR8.VAR10))%256);
}
function () public  payable
{
FUN1();
}
}
1
---------------------------------
46 0x3c42ab93886b2a3ed97f4d9e1d7d7552d94fe9ac.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint VAR3);
function FUN2( address VAR4 ) public view returns (uint value);
function FUN3( address VAR5, address VAR6 ) public view returns (uint VAR7);
function transfer( address VAR8, uint value) public returns (bool VAR9);
function FUN4( address VAR10, address VAR8, uint value) public returns (bool VAR9);
function FUN5( address VAR6, uint value ) public returns (bool VAR9);
}
contract VAR11 {
function FUN6() public payable;
function FUN7(uint VAR12) public;
function FUN5(address VAR13, uint VAR12) public returns (bool);
function transfer(address VAR14, uint VAR12) public returns (bool);
function FUN4(address VAR15, address VAR14, uint VAR12) public returns (bool);
}
contract VAR16 {
function FUN8(uint256 VAR17, uint256 VAR18) public payable returns (uint256);
function FUN9(uint256 VAR19, uint256 VAR20, uint256 VAR18) public returns(uint256);
}
contract VAR21 {
address public VAR5;
constructor ()
public
{
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(
msg.sender == VAR5,
""
);
VAR22;
}
function FUN10(address VAR23)
public
onlyOwner
{
if (VAR23 != address(0)) {
VAR5 = VAR23;
}
}
}
contract UniswapWrapper is VAR21{
address public VAR24;
address public VAR25;
address public VAR26;
constructor(address VAR27, address VAR28, address VAR29)
public
{
VAR24 = VAR27;
VAR25 = VAR28;
VAR26 = VAR29;
}
function FUN5(address VAR30, address VAR31)
public
onlyOwner
{
uint256 VAR32 = 2 ** 256 - 1;
require(FUN11(VAR30).FUN5(VAR31, VAR32), "");
}
function FUN12(uint256 VAR33)
public
onlyOwner
{
VAR5.transfer(VAR33);
}
function FUN13(address VAR30, uint256 VAR33)
public
onlyOwner
{
require(FUN11(VAR30).transfer(VAR5, VAR33), "");
}
function FUN14(uint256 VAR34, uint256 VAR35, uint256 VAR18)
public
onlyOwner
{
require(FUN15(VAR26).FUN4(msg.sender, this, VAR35), "");
FUN15(VAR26).FUN7(VAR35);
uint256 VAR36 = FUN16(VAR24).VAR37.value(VAR35)(VAR34, VAR18);
FUN11(VAR25).transfer(VAR5, VAR36);
}
function FUN17(uint256 VAR38, uint256 VAR39, uint256 VAR18)
public
onlyOwner
{
require(FUN11(VAR25).FUN4(msg.sender, this, VAR39), "");
uint256 VAR40 = FUN16(VAR24).FUN9(VAR39, VAR38, VAR18);
FUN15(VAR26).VAR41.value(VAR40)();
FUN15(VAR26).transfer(msg.sender, VAR40);
}
}
1
---------------------------------
47 0x3e4ecfcfdabb36c1f0058694941801cbb11f6582.sol
pragma VAR1 ^0.4.21;
pragma VAR1 ^0.4.18;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) external payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) external payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) public payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) external payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) public payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) external payable returns (bytes32 VAR7);
function FUN7(string VAR5) public returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) public returns (uint VAR12);
function FUN8(byte VAR14) external;
function FUN9(uint VAR15) external;
function FUN10() external constant returns(bytes32);
}
contract VAR16 {
function FUN11() public returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x20;
byte constant VAR25 = 0x30;
byte constant VAR26 = 0xF0;
byte constant VAR27 = 0x01;
uint8 constant VAR28 = 0;
uint8 constant VAR29 = 1;
uint8 constant VAR30 = 2;
uint8 constant VAR31 = 2;
uint8 constant VAR32 = 161;
OraclizeAddrResolverI VAR33;
OraclizeI VAR34;
modifier VAR35 {
if((address(VAR33)==0)||(FUN12(address(VAR33))==0))
FUN13(VAR28);
if(address(VAR34) != VAR33.FUN11())
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
modifier FUN15(string VAR37){
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
function FUN13(uint8 VAR38) internal returns(bool){
return FUN13();
VAR38;
}
function FUN13() internal returns(bool){
if (FUN12(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR33 = FUN16(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN17("");
return true;
}
if (FUN12(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR33 = FUN16(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN17("");
return true;
}
if (FUN12(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR33 = FUN16(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN17("");
return true;
}
if (FUN12(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR33 = FUN16(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN17("");
return true;
}
if (FUN12(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR33 = FUN16(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN12(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR33 = FUN16(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN12(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR33 = FUN16(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN18(bytes32 VAR39, string VAR40) public {
FUN18(VAR39, VAR40, VAR41 bytes(0));
}
function FUN18(bytes32 VAR39, string VAR40, bytes VAR42) public {
return;
VAR39; VAR40; VAR42;
}
function FUN19(string VAR43) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43);
}
function FUN19(string VAR43, uint VAR13) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43, VAR13);
}
function FUN20(string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(0, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(VAR51, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(VAR51, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(0, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(0, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(VAR51, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(VAR51, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(0, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN23() oraclizeAPI internal returns (address){
return VAR34.FUN24();
}
function FUN25(byte VAR62) oraclizeAPI internal {
return VAR34.FUN8(VAR62);
}
function FUN26(uint VAR63) oraclizeAPI internal {
return VAR34.FUN9(VAR63);
}
function FUN27() oraclizeAPI internal returns (bytes32){
return VAR34.FUN10();
}
function FUN12(address VAR17) constant internal returns(uint VAR64) {
VAR65 {
VAR64 := FUN28(VAR17)
}
}
function FUN29(string VAR66) internal pure returns (address){
bytes memory VAR67 = bytes(VAR66);
uint160 VAR68 = 0;
uint160 VAR69;
uint160 VAR70;
for (uint VAR71=2; VAR71<2+2*20; VAR71+=2){
VAR68 *= 256;
VAR69 = FUN30(VAR67[VAR71]);
VAR70 = FUN30(VAR67[VAR71+1]);
if ((VAR69 >= 97)&&(VAR69 <= 102)) VAR69 -= 87;
else if ((VAR69 >= 65)&&(VAR69 <= 70)) VAR69 -= 55;
else if ((VAR69 >= 48)&&(VAR69 <= 57)) VAR69 -= 48;
if ((VAR70 >= 97)&&(VAR70 <= 102)) VAR70 -= 87;
else if ((VAR70 >= 65)&&(VAR70 <= 70)) VAR70 -= 55;
else if ((VAR70 >= 48)&&(VAR70 <= 57)) VAR70 -= 48;
VAR68 += (VAR69*16+VAR70);
}
return address(VAR68);
}
function FUN31(string VAR66, string VAR72) internal pure returns (int) {
bytes memory VAR73 = bytes(VAR66);
bytes memory VAR74 = bytes(VAR72);
uint VAR75 = VAR73.VAR76;
if (VAR74.VAR76 < VAR75) VAR75 = VAR74.VAR76;
for (uint VAR71 = 0; VAR71 < VAR75; VAR71 ++)
if (VAR73[VAR71] < VAR74[VAR71])
return -1;
else if (VAR73[VAR71] > VAR74[VAR71])
return 1;
if (VAR73.VAR76 < VAR74.VAR76)
return -1;
else if (VAR73.VAR76 > VAR74.VAR76)
return 1;
else
return 0;
}
function FUN32(string VAR77, string VAR78) internal pure returns (int) {
bytes memory VAR79 = bytes(VAR77);
bytes memory VAR80 = bytes(VAR78);
if(VAR79.VAR76 < 1 || VAR80.VAR76 < 1 || (VAR80.VAR76 > VAR79.VAR76))
return -1;
else if(VAR79.VAR76 > (2**128 -1))
return -1;
else
{
uint VAR81 = 0;
for (uint VAR71 = 0; VAR71 < VAR79.VAR76; VAR71 ++)
{
if (VAR79[VAR71] == VAR80[0])
{
VAR81 = 1;
while(VAR81 < VAR80.VAR76 && (VAR71 + VAR81) < VAR79.VAR76 && VAR79[VAR71 + VAR81] == VAR80[VAR81])
{
VAR81++;
}
if(VAR81 == VAR80.VAR76)
return int(VAR71);
}
}
return -1;
}
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83, string VAR84) internal pure returns (string) {
bytes memory VAR85 = bytes(VAR66);
bytes memory VAR86 = bytes(VAR72);
bytes memory VAR87 = bytes(VAR82);
bytes memory VAR88 = bytes(VAR83);
bytes memory VAR89 = bytes(VAR84);
string memory VAR90 = VAR41 string(VAR85.VAR76 + VAR86.VAR76 + VAR87.VAR76 + VAR88.VAR76 + VAR89.VAR76);
bytes memory VAR91 = bytes(VAR90);
uint VAR92 = 0;
for (uint VAR71 = 0; VAR71 < VAR85.VAR76; VAR71++) VAR91[VAR92++] = VAR85[VAR71];
for (VAR71 = 0; VAR71 < VAR86.VAR76; VAR71++) VAR91[VAR92++] = VAR86[VAR71];
for (VAR71 = 0; VAR71 < VAR87.VAR76; VAR71++) VAR91[VAR92++] = VAR87[VAR71];
for (VAR71 = 0; VAR71 < VAR88.VAR76; VAR71++) VAR91[VAR92++] = VAR88[VAR71];
for (VAR71 = 0; VAR71 < VAR89.VAR76; VAR71++) VAR91[VAR92++] = VAR89[VAR71];
return string(VAR91);
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, VAR83, "");
}
function FUN33(string VAR66, string VAR72, string VAR82) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, "", "");
}
function FUN33(string VAR66, string VAR72) internal pure returns (string) {
return FUN33(VAR66, VAR72, "", "", "");
}
function FUN34(string VAR66) internal pure returns (uint) {
return FUN34(VAR66, 0);
}
function FUN34(string VAR66, uint VAR72) internal pure returns (uint) {
bytes memory VAR93 = bytes(VAR66);
uint VAR94 = 0;
bool VAR95 = false;
for (uint VAR71=0; VAR71<VAR93.VAR76; VAR71++){
if ((VAR93[VAR71] >= 48)&&(VAR93[VAR71] <= 57)){
if (VAR95){
if (VAR72 == 0) break;
else VAR72--;
}
VAR94 *= 10;
VAR94 += uint(VAR93[VAR71]) - 48;
} else if (VAR93[VAR71] == 46) VAR95 = true;
}
if (VAR72 > 0) VAR94 *= 10**VAR72;
return VAR94;
}
function FUN35(uint VAR71) internal pure returns (string){
if (VAR71 == 0) return "";
uint VAR96 = VAR71;
uint VAR97;
while (VAR96 != 0){
VAR97++;
VAR96 /= 10;
}
bytes memory VAR98 = VAR41 bytes(VAR97);
uint VAR92 = VAR97 - 1;
while (VAR71 != 0){
VAR98[VAR92--] = FUN36(48 + VAR71 % 10);
VAR71 /= 10;
}
return string(VAR98);
}
function FUN21(string[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
function FUN22(bytes[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
string VAR109;
function FUN17(string VAR110) internal {
VAR109 = VAR110;
}
function FUN37() internal view returns (string) {
return VAR109;
}
function FUN38(uint VAR111, uint VAR112, uint VAR113) internal returns (bytes32){
require((VAR112 > 0) && (VAR112 <= 32));
VAR111 *= 10;
bytes memory VAR114 = VAR41 bytes(1);
VAR114[0] = FUN36(VAR112);
bytes memory VAR115 = VAR41 bytes(32);
bytes memory VAR116 = VAR41 bytes(32);
bytes32 VAR117 = FUN27();
VAR65 {
FUN39(VAR115, 0x20)
FUN39(FUN40(VAR115, 0x20), FUN41(FUN42(FUN43(VAR118, 1)), FUN41(VAR119, VAR51)))
FUN39(VAR116, 0x20)
FUN39(FUN40(VAR116, 0x20), VAR117)
}
bytes memory VAR120 = VAR41 bytes(32);
VAR65 {
FUN39(FUN40(VAR120, 0x20), VAR111)
}
bytes memory VAR121 = VAR41 bytes(8);
FUN44(VAR120, 24, 8, VAR121, 0);
bytes[4] memory VAR58 = [VAR115, VAR114, VAR116, VAR120];
bytes32 VAR122 = FUN20("", VAR58, VAR113);
bytes memory VAR123 = VAR41 bytes(8);
VAR65 {
let VAR106 := FUN45(FUN40(VAR121, 0x20))
FUN46(FUN40(VAR123, 0x27), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x26), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x25), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x24), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x23), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x22), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x21), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x20), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000))
}
FUN48(VAR122, FUN49(VAR123, VAR58[1], FUN50(VAR58[0]), VAR58[2]));
return VAR122;
}
function FUN48(bytes32 VAR122, bytes32 VAR124) internal {
VAR125[VAR122] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN51(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR41 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN44(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR41 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN44(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR65 {
VAR132 := FUN45(FUN40(VAR134, 32))
VAR133 := FUN45(FUN40(VAR136, 32))
}
(VAR130, VAR131) = FUN52(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN52(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN53(bytes VAR42, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR41 bytes(uint(VAR42[VAR137+1])+2);
FUN44(VAR42, VAR137, VAR138.VAR76, VAR138, 0);
bytes memory VAR139 = VAR41 bytes(64);
FUN44(VAR42, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR41 bytes(1+65+32);
VAR140[0] = FUN36(1);
FUN44(VAR42, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN44(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN51(FUN50(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR41 bytes(1+65);
VAR144[0] = 0xFE;
FUN44(VAR42, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR41 bytes(uint(VAR42[3+65+1])+2);
FUN44(VAR42, 3+65, VAR145.VAR76, VAR145, 0);
VAR130 = FUN51(FUN50(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN54(bytes32 VAR146, string VAR147, bytes VAR148) {
require((VAR148[0] == "") && (VAR148[1] == "") && (VAR148[2] == 1));
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
require(VAR149);
VAR36;
}
function FUN56(bytes32 VAR146, string VAR147, bytes VAR148) internal returns (uint8){
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) return 1;
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
if (VAR149 == false) return 2;
return 0;
}
function FUN57(bytes32 VAR150, bytes VAR151, uint VAR152) internal pure returns (bool){
bool VAR153 = true;
require(VAR151.VAR76 == VAR152);
for (uint256 VAR71=0; VAR71< VAR152; VAR71++) {
if (VAR150[VAR71] != VAR151[VAR71]) VAR153 = false;
}
return VAR153;
}
function FUN55(bytes VAR42, bytes32 VAR122, bytes VAR40, string VAR154) internal returns (bool){
uint VAR155 = 3+65+(uint(VAR42[3+65+1])+2)+32;
bytes memory VAR156 = VAR41 bytes(32);
FUN44(VAR42, VAR155, 32, VAR156, 0);
if (!(FUN49(VAR156) == FUN49(FUN50(VAR154, VAR122)))) return false;
bytes memory VAR157 = VAR41 bytes(uint(VAR42[VAR155+(32+8+1+32)+1])+2);
FUN44(VAR42, VAR155+(32+8+1+32), VAR157.VAR76, VAR157, 0);
if (!FUN57(FUN50(VAR157), VAR40, uint(VAR42[VAR155+32+8]))) return false;
bytes memory VAR158 = VAR41 bytes(8+1+32);
FUN44(VAR42, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR41 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR76+65;
FUN44(VAR42, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN50(VAR159);
if (VAR125[VAR122] == FUN49(VAR158, VAR160)){
delete VAR125[VAR122];
} else return false;
bytes memory VAR161 = VAR41 bytes(32+8+1+32);
FUN44(VAR42, VAR155, 32+8+1+32, VAR161, 0);
if (!FUN51(FUN50(VAR161), VAR157, VAR159)) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN53(VAR42, VAR137);
}
return VAR126[VAR160];
}
function FUN44(bytes VAR162, uint VAR163, uint VAR76, bytes VAR164, uint VAR165) internal pure returns (bytes) {
uint VAR75 = VAR76 + VAR165;
require(VAR164.VAR76 >= VAR75);
uint VAR71 = 32 + VAR163;
uint VAR96 = 32 + VAR165;
while (VAR71 < (32 + VAR163 + VAR76)) {
VAR65 {
let VAR67 := FUN45(FUN40(VAR162, VAR71))
FUN39(FUN40(VAR164, VAR96), VAR67)
}
VAR71 += 32;
VAR96 += 32;
}
return VAR164;
}
function FUN52(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR65 {
let VAR172 := FUN45(0x40)
FUN39(VAR172, VAR166)
FUN39(FUN40(VAR172, 32), VAR167)
FUN39(FUN40(VAR172, 64), VAR168)
FUN39(FUN40(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN45(VAR172)
}
return (VAR170, VAR171);
}
function FUN58(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR76 != 65)
return (false, 0);
VAR65 {
VAR168 := FUN45(FUN40(VAR173, 32))
VAR169 := FUN45(FUN40(VAR173, 64))
VAR167 := FUN36(0, FUN45(FUN40(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN52(VAR166, VAR167, VAR168, VAR169);
}
}
contract VAR174 {
uint256 public VAR175;
uint256 public VAR176;
function FUN59(address VAR177) public;
function FUN60() payable public;
function FUN61() public view returns(uint256);
}
contract VAR178 {
function FUN62(uint256 VAR179, address VAR180) public;
function FUN63() payable public;
function FUN64(uint256 VAR181) public;
function FUN65() public view returns(uint256);
}
contract VAR182 {
function FUN66() constant public returns (uint VAR183);
function FUN67(address VAR184) constant public returns (uint VAR185);
function transfer(address VAR186, uint VAR187) public returns (bool VAR188);
function FUN68(address VAR189, address VAR186, uint VAR187) public returns (bool VAR188);
function FUN69(address VAR190, uint VAR187) public returns (bool VAR188);
function FUN70(address VAR184, address VAR190) constant public returns (uint VAR191);
event Transfer(address indexed VAR189, address indexed VAR186, uint VAR187);
event FUN71(address indexed VAR184, address indexed VAR190, uint VAR187);
}
contract EOSBetBankroll is VAR182, VAR178 {
using SafeMath for *;
address public VAR192;
uint256 public VAR193;
uint256 public VAR194;
uint256 public VAR175;
mapping(address => bool) public VAR195;
address public VAR196;
address public VAR197;
mapping(address => uint256) VAR198;
string public constant VAR199 = "";
string public constant VAR200 = "";
uint8 public constant VAR95 = 18;
uint256 public VAR201;
mapping(address => uint256) public VAR202;
mapping(address => mapping(address => uint256)) public VAR203;
event FUN72(address VAR204, uint256 VAR205, uint256 VAR206);
event FUN73(address VAR204, uint256 VAR207, uint256 VAR208);
event FUN74(address VAR209, uint256 VAR210);
modifier FUN75(address VAR211){
require(VAR195[VAR211]);
VAR36;
}
function FUN76(address VAR212, address VAR213) public payable {
require (msg.value > 0);
VAR192 = msg.sender;
uint256 VAR214 = msg.value * 100;
VAR202[msg.sender] = VAR214;
VAR201 = VAR214;
emit Transfer(0x0, msg.sender, VAR214);
VAR195[VAR212] = true;
VAR195[VAR213] = true;
VAR196 = VAR212;
VAR197 = VAR213;
VAR194 = 0 VAR215;
VAR193 = 500 VAR47;
}
function FUN77(address VAR216) view public returns(uint256){
return VAR198[VAR216];
}
function FUN65() view public returns(uint256){
return VAR217.FUN43(address(this).VAR185, VAR175);
}
function FUN62(uint256 VAR179, address VAR180) public FUN75(msg.sender){
if (! VAR180.FUN78(VAR179)){
emit FUN74(VAR180, VAR179);
if (! VAR192.FUN78(VAR179)){
emit FUN74(VAR192, VAR179);
}
}
}
function FUN63() payable public FUN75(msg.sender){
}
function FUN64(uint256 VAR181) public FUN75(msg.sender){
FUN79(msg.sender).VAR218.value(VAR181)();
}
function () public payable {
uint256 VAR219 = VAR217.FUN43(FUN65(), msg.value);
uint256 VAR220 = VAR193;
require(VAR219 < VAR220 && msg.value != 0);
uint256 VAR221 = VAR201;
uint256 VAR222;
bool VAR223;
uint256 VAR224;
uint256 VAR225;
if (VAR217.FUN40(VAR219, msg.value) > VAR220){
VAR223 = true;
VAR222 = VAR217.FUN43(VAR220, VAR219);
VAR224 = VAR217.FUN43(msg.value, VAR222);
}
else {
VAR222 = msg.value;
}
if (VAR221 != 0){
VAR225 = VAR217.FUN80(VAR222, VAR221) / VAR219;
}
else {
VAR225 = VAR217.FUN80(VAR222, 100);
}
VAR201 = VAR217.FUN40(VAR221, VAR225);
VAR202[msg.sender] = VAR217.FUN40(VAR202[msg.sender], VAR225);
VAR198[msg.sender] = VAR226.VAR51;
if (VAR223){
msg.sender.transfer(VAR224);
}
emit FUN72(msg.sender, VAR222, VAR225);
emit Transfer(0x0, msg.sender, VAR225);
}
function FUN81(uint256 VAR227) public {
uint256 VAR228 = VAR202[msg.sender];
require(VAR227 <= VAR228
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR227 > 0);
uint256 VAR219 = FUN65();
uint256 VAR221 = VAR201;
uint256 VAR229 = VAR217.FUN80(VAR227, VAR219) / VAR221;
uint256 VAR230 = VAR229 / 100;
uint256 VAR231 = VAR217.FUN43(VAR229, VAR230);
VAR201 = VAR217.FUN43(VAR221, VAR227);
VAR202[msg.sender] = VAR217.FUN43(VAR228, VAR227);
VAR175 = VAR217.FUN40(VAR175, VAR230);
msg.sender.transfer(VAR231);
emit FUN73(msg.sender, VAR231, VAR227);
emit Transfer(msg.sender, 0x0, VAR227);
}
function FUN82() public {
FUN81(VAR202[msg.sender]);
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN84(uint256 VAR233) public {
require (msg.sender == VAR192 && VAR233 <= 6048000);
VAR194 = VAR233;
}
function FUN85(uint256 VAR234) public {
require(msg.sender == VAR192);
VAR193 = VAR234;
}
function FUN86(address VAR235) public {
require(msg.sender == VAR192);
FUN79(VAR196).FUN59(VAR235);
FUN79(VAR197).FUN59(VAR235);
uint256 VAR236 = VAR175;
VAR175 = 0;
VAR235.transfer(VAR236);
}
function FUN87() public {
require(msg.sender == VAR192);
FUN88(msg.sender);
}
function FUN66() constant public returns(uint){
return VAR201;
}
function FUN67(address VAR184) constant public returns(uint){
return VAR202[VAR184];
}
function transfer(address VAR186, uint256 VAR187) public returns (bool VAR188){
if (VAR202[msg.sender] >= VAR187
&& VAR187 > 0
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)){
VAR202[msg.sender] = VAR217.FUN43(VAR202[msg.sender], VAR187);
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
emit Transfer(msg.sender, VAR186, VAR187);
return true;
}
else {
return false;
}
}
function FUN68(address VAR189, address VAR186, uint VAR187) public returns(bool){
if (VAR203[VAR189][msg.sender] >= VAR187
&& VAR202[VAR189] >= VAR187
&& VAR187 > 0
&& VAR198[VAR189] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)){
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
VAR202[VAR189] = VAR217.FUN43(VAR202[VAR189], VAR187);
VAR203[VAR189][msg.sender] = VAR217.FUN43(VAR203[VAR189][msg.sender], VAR187);
emit Transfer(VAR189, VAR186, VAR187);
return true;
}
else {
return false;
}
}
function FUN69(address VAR190, uint VAR187) public returns(bool){
if(VAR187 > 0){
VAR203[msg.sender][VAR190] = VAR187;
emit FUN71(msg.sender, VAR190, VAR187);
return true;
}
else {
return false;
}
}
function FUN70(address VAR184, address VAR190) constant public returns(uint){
return VAR203[VAR184][VAR190];
}
}
library VAR217 {
function FUN80(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
if (VAR73 == 0) {
return 0;
}
uint256 VAR237 = VAR73 * VAR74;
assert(VAR237 / VAR73 == VAR74);
return VAR237;
}
function FUN47(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR237 = VAR73 / VAR74;
return VAR237;
}
function FUN43(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
assert(VAR74 <= VAR73);
return VAR73 - VAR74;
}
function FUN40(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR237 = VAR73 + VAR74;
assert(VAR237 >= VAR73);
return VAR237;
}
}
contract EOSBetSlots is VAR18, VAR174 {
using SafeMath for *;
event FUN89(bytes32 indexed VAR238);
event FUN90(bytes32 indexed VAR238);
event FUN91(bytes32 indexed VAR238, uint256 VAR239);
event FUN92(bytes32 indexed VAR238, uint256 VAR240, uint256 VAR241, uint256 VAR242, uint256 VAR243, uint256 VAR244, uint256 VAR245, uint256 VAR246, uint256 VAR247);
event FUN93(uint256 VAR240, uint256 VAR241, uint256 VAR242, uint256 VAR243, uint256 VAR244, uint256 VAR245, uint256 VAR246, uint256 VAR247);
struct VAR248 {
address VAR249;
bool VAR250;
uint256 VAR251;
uint256 VAR252;
uint8 VAR253;
}
mapping (bytes32 => VAR248) public VAR254;
uint256 public VAR176;
uint256 public VAR175;
uint256 public VAR255;
uint256 public VAR256;
uint256 public VAR257;
uint256 public VAR258;
uint256 public VAR259;
uint256 public VAR260;
uint256 public VAR261;
uint16 public VAR262;
bool public VAR263;
bool public VAR264;
address public VAR192;
address public VAR265;
function FUN94() public {
FUN25(VAR25);
FUN26(10000000000);
VAR260 = 10000000000;
VAR261 = 225000;
VAR255 = 0;
VAR256 = 0;
VAR263 = false;
VAR264 = true;
VAR257 = 6 VAR266;
VAR258 = 350 VAR267;
VAR259 = 1 VAR267;
VAR262 = 300;
VAR192 = msg.sender;
}
function FUN59(address VAR177) public {
require(msg.sender == VAR265);
uint256 VAR268 = VAR175;
VAR175 = 0;
VAR177.transfer(VAR268);
}
function FUN60() payable public {
require(msg.sender == VAR265);
}
function FUN61() public view returns(uint256){
return (VAR217.FUN80(FUN95(VAR265).FUN65(), VAR262) / 1000);
}
function FUN96(address VAR269) public {
require(msg.sender == VAR192 && VAR265 == address(0));
require(FUN95(VAR269).FUN65() != 0);
VAR265 = VAR269;
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN97(uint256 VAR270) public {
require(msg.sender == VAR192);
VAR257 = VAR270;
}
function FUN98(uint256 VAR63) public {
require(msg.sender == VAR192);
VAR260 = VAR63;
FUN26(VAR63);
}
function FUN99(uint256 VAR271) public {
require(msg.sender == VAR192);
VAR261 = VAR271;
}
function FUN100(bool VAR272) public {
require(msg.sender == VAR192);
VAR263 = VAR272;
}
function FUN101(bool VAR273) public {
require(msg.sender == VAR192);
VAR264 = VAR273;
}
function FUN102(uint256 VAR274) public {
require(msg.sender == VAR192);
VAR258 = VAR274;
}
function FUN103(uint256 VAR274) public {
require(msg.sender == VAR192 && VAR274 > 1000);
VAR259 = VAR274;
}
function FUN104(uint16 VAR275) public {
require(msg.sender == VAR192 && VAR275 <= 333);
VAR262 = VAR275;
}
function FUN87() public {
require(msg.sender == VAR192);
FUN88(msg.sender);
}
function FUN105(bytes32 VAR238) public {
SlotsGameData memory VAR276 = VAR254[VAR238];
require(VAR217.FUN43(VAR226.VAR51, VAR276.VAR251) >= VAR257
&& (msg.sender == VAR192 || msg.sender == VAR276.VAR249)
&& (!VAR276.VAR250)
&& VAR276.VAR252 <= VAR176
&& VAR276.VAR252 > 0
&& VAR264);
VAR254[VAR238].VAR250 = true;
VAR176 = VAR217.FUN43(VAR176, VAR276.VAR252);
VAR276.VAR249.transfer(VAR276.VAR252);
emit FUN91(VAR238, VAR276.VAR252);
}
function FUN106(uint8 VAR253) public payable {
uint256 VAR277 = msg.value / VAR253;
require(!VAR263
&& msg.value > 0
&& VAR277 >= VAR259
&& VAR253 > 0
&& VAR253 <= 224
&& VAR217.FUN80(VAR277, 5000) <= FUN61());
if (VAR277 < VAR258){
bytes32 VAR278 = VAR226.FUN42(VAR226.VAR118);
uint256 VAR279;
uint8 VAR280;
uint8 VAR281;
uint8 VAR282;
uint256[] memory VAR283 = new uint256[](8);
uint256 VAR284;
for (uint8 VAR71 = 0; VAR71 < VAR253; VAR71++){
VAR279 += 1;
VAR280 = uint8(uint(FUN49(VAR278, VAR279)) % 64);
VAR279 += 1;
VAR281 = uint8(uint(FUN49(VAR278, VAR279)) % 64);
VAR279 += 1;
VAR282 = uint8(uint(FUN49(VAR278, VAR279)) % 64);
VAR280 = FUN107(VAR280);
VAR281 = FUN108(VAR281);
VAR282 = FUN109(VAR282);
VAR284 += FUN110(VAR280, VAR281, VAR282);
if (VAR71 <= 27){
VAR283[0] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (27 - VAR71)) + 2));
VAR283[0] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (27 - VAR71)) + 1));
VAR283[0] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (27 - VAR71))));
}
else if (VAR71 <= 55){
VAR283[1] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (55 - VAR71)) + 2));
VAR283[1] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (55 - VAR71)) + 1));
VAR283[1] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (55 - VAR71))));
}
else if (VAR71 <= 83) {
VAR283[2] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (83 - VAR71)) + 2));
VAR283[2] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (83 - VAR71)) + 1));
VAR283[2] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (83 - VAR71))));
}
else if (VAR71 <= 111) {
VAR283[3] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (111 - VAR71)) + 2));
VAR283[3] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (111 - VAR71)) + 1));
VAR283[3] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (111 - VAR71))));
}
else if (VAR71 <= 139){
VAR283[4] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (139 - VAR71)) + 2));
VAR283[4] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (139 - VAR71)) + 1));
VAR283[4] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (139 - VAR71))));
}
else if (VAR71 <= 167){
VAR283[5] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (167 - VAR71)) + 2));
VAR283[5] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (167 - VAR71)) + 1));
VAR283[5] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (167 - VAR71))));
}
else if (VAR71 <= 195){
VAR283[6] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (195 - VAR71)) + 2));
VAR283[6] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (195 - VAR71)) + 1));
VAR283[6] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (195 - VAR71))));
}
else {
VAR283[7] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (223 - VAR71)) + 2));
VAR283[7] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (223 - VAR71)) + 1));
VAR283[7] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (223 - VAR71))));
}
}
VAR256 += VAR279;
VAR255 = VAR217.FUN40(VAR255, msg.value);
uint256 VAR230 = msg.value / 100;
VAR175 = VAR217.FUN40(VAR175, VAR230);
FUN95(VAR265).VAR285.value(VAR217.FUN43(msg.value, VAR230))();
uint256 VAR286 = VAR217.FUN80(VAR277, VAR284);
FUN95(VAR265).FUN62(VAR286, msg.sender);
emit FUN93(VAR283[0], VAR283[1], VAR283[2], VAR283[3], VAR283[4], VAR283[5], VAR283[6], VAR283[7]);
}
else {
bytes32 VAR238;
uint256 VAR287 = VAR261 + (uint256(3270) * VAR253);
FUN95(VAR265).FUN64(FUN19('', VAR287));
VAR238 = FUN38(0, 30, VAR287);
VAR254[VAR238] = FUN111({
VAR249 : msg.sender,
VAR250 : false,
VAR251 : VAR226.VAR51,
VAR252 : msg.value,
VAR253 : VAR253
});
VAR176 = VAR217.FUN40(VAR176, msg.value);
emit FUN89(VAR238);
}
}
function FUN18(bytes32 VAR146, string VAR147, bytes VAR148) public {
SlotsGameData memory VAR276 = VAR254[VAR146];
require(msg.sender == FUN23()
&& !VAR276.VAR250
&& VAR276.VAR249 != address(0)
&& VAR176 >= VAR276.VAR252);
if (FUN56(VAR146, VAR147, VAR148) != 0){
if (VAR264){
VAR254[VAR146].VAR250 = true;
VAR176 = VAR217.FUN43(VAR176, VAR276.VAR252);
VAR276.VAR249.transfer(VAR276.VAR252);
emit FUN91(VAR146, VAR276.VAR252);
}
emit FUN90(VAR146);
}
else {
uint256 VAR279;
uint8 VAR280;
uint8 VAR281;
uint8 VAR282;
uint256[] memory VAR283 = new uint256[](8);
uint256 VAR284;
for (uint8 VAR71 = 0; VAR71 < VAR276.VAR253; VAR71++){
VAR279 += 1;
VAR280 = uint8(uint(FUN49(VAR147, VAR279)) % 64);
VAR279 += 1;
VAR281 = uint8(uint(FUN49(VAR147, VAR279)) % 64);
VAR279 += 1;
VAR282 = uint8(uint(FUN49(VAR147, VAR279)) % 64);
VAR280 = FUN107(VAR280);
VAR281 = FUN108(VAR281);
VAR282 = FUN109(VAR282);
VAR284 += FUN110(VAR280, VAR281, VAR282);
if (VAR71 <= 27){
VAR283[0] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (27 - VAR71)) + 2));
VAR283[0] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (27 - VAR71)) + 1));
VAR283[0] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (27 - VAR71))));
}
else if (VAR71 <= 55){
VAR283[1] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (55 - VAR71)) + 2));
VAR283[1] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (55 - VAR71)) + 1));
VAR283[1] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (55 - VAR71))));
}
else if (VAR71 <= 83) {
VAR283[2] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (83 - VAR71)) + 2));
VAR283[2] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (83 - VAR71)) + 1));
VAR283[2] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (83 - VAR71))));
}
else if (VAR71 <= 111) {
VAR283[3] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (111 - VAR71)) + 2));
VAR283[3] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (111 - VAR71)) + 1));
VAR283[3] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (111 - VAR71))));
}
else if (VAR71 <= 139){
VAR283[4] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (139 - VAR71)) + 2));
VAR283[4] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (139 - VAR71)) + 1));
VAR283[4] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (139 - VAR71))));
}
else if (VAR71 <= 167){
VAR283[5] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (167 - VAR71)) + 2));
VAR283[5] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (167 - VAR71)) + 1));
VAR283[5] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (167 - VAR71))));
}
else if (VAR71 <= 195){
VAR283[6] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (195 - VAR71)) + 2));
VAR283[6] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (195 - VAR71)) + 1));
VAR283[6] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (195 - VAR71))));
}
else if (VAR71 <= 223){
VAR283[7] += uint256(VAR280) * uint256(2) ** (3 * ((3 * (223 - VAR71)) + 2));
VAR283[7] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (223 - VAR71)) + 1));
VAR283[7] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (223 - VAR71))));
}
}
VAR256 += VAR279;
VAR255 = VAR217.FUN40(VAR255, VAR276.VAR252);
VAR254[VAR146].VAR250 = true;
VAR176 = VAR217.FUN43(VAR176, VAR276.VAR252);
uint256 VAR230 = VAR276.VAR252 / 100;
VAR175 = VAR217.FUN40(VAR175, VAR230);
FUN95(VAR265).VAR285.value(VAR217.FUN43(VAR276.VAR252, VAR230))();
uint256 VAR286 = VAR217.FUN80((VAR276.VAR252 / VAR276.VAR253), VAR284);
FUN95(VAR265).FUN62(VAR286, VAR276.VAR249);
emit FUN92(VAR146, VAR283[0], VAR283[1], VAR283[2], VAR283[3], VAR283[4], VAR283[5], VAR283[6], VAR283[7]);
}
}
function FUN107(uint8 VAR288) internal pure returns(uint8) {
if (VAR288 == 0) 							        { return 0; }
else if (VAR288 >= 1 && VAR288 <= 7) 			{ return 1; }
else if (VAR288 == 8) 						        { return 2; }
else if (VAR288 >= 9 && VAR288 <= 13) 		{ return 3; }
else if (VAR288 >= 14 && VAR288 <= 22) 		{ return 4; }
else if (VAR288 >= 23 && VAR288 <= 31) 		{ return 5; }
else 										                { return 6; }
}
function FUN108(uint8 VAR289) internal pure returns(uint8) {
if (VAR289 >= 0 && VAR289 <= 2) 				{ return 0; }
else if (VAR289 == 3) 						        { return 1; }
else if (VAR289 >= 4 && VAR289 <= 10)			{ return 2; }
else if (VAR289 >= 11 && VAR289 <= 17) 		{ return 3; }
else if (VAR289 >= 18 && VAR289 <= 23) 		{ return 4; }
else if (VAR289 >= 24 && VAR289 <= 31) 		{ return 5; }
else 										                { return 6; }
}
function FUN109(uint8 VAR290) internal pure returns(uint8) {
if (VAR290 == 0) 							        { return 0; }
else if (VAR290 >= 1 && VAR290 <= 6)			{ return 1; }
else if (VAR290 >= 7 && VAR290 <= 12) 		{ return 2; }
else if (VAR290 >= 13 && VAR290 <= 18)		{ return 3; }
else if (VAR290 >= 19 && VAR290 <= 25) 		{ return 4; }
else if (VAR290 >= 26 && VAR290 <= 31) 		{ return 5; }
else 										                { return 6; }
}
function FUN110(uint8 VAR280, uint8 VAR281, uint8 VAR282) internal pure returns(uint256) {
if (VAR280 == 6 || VAR281 == 6 || VAR282 == 6){
if (VAR280 == 6 && VAR281 == 6 && VAR282 == 6)
return 1;
}
else if (VAR280 == 5){
if (VAR281 == 4 && VAR282 == 3)
return 90;
else if (VAR281 == 3 && VAR282 == 4)
return 20;
else if (VAR281 == 5 && VAR282 == 5)
return 10;
else if (VAR281 >= 3 && VAR281 <= 5 && VAR282 >= 3 && VAR282 <= 5)
return 3;
else if ((VAR281 == 2 || VAR281 == 5) && (VAR282 == 2 || VAR282 == 5))
return 2;
}
else if (VAR280 == 4){
if (VAR281 == 4 && VAR282 == 4)
return 25;
else if ((VAR281 == 3 && VAR282 == 5) || (VAR281 == 5 && VAR282 == 3))
return 20;
else if (VAR281 >= 3 && VAR281 <= 5 && VAR282 >= 3 && VAR282 <= 5)
return 3;
else if ((VAR281 == 1 || VAR281 == 4) && (VAR282 == 1 || VAR282 == 4))
return 2;
}
else if (VAR280 == 3){
if (VAR281 == 3 && VAR282 == 3)
return 50;
else if ((VAR281 == 4 && VAR282 == 5) || (VAR281 == 5 && VAR282 == 4))
return 20;
else if (VAR281 >= 3 && VAR281 <= 5 && VAR282 >= 3 && VAR282 <= 5)
return 3;
else if ((VAR281 == 0 || VAR281 == 3) && (VAR282 == 0 || VAR282 == 3))
return 3;
}
else if (VAR280 == 2){
if (VAR281 == 1 && VAR282 == 0)
return 5000;
else if (VAR281 == 2 && VAR282 == 2)
return 250;
else if (VAR281 >= 0 && VAR281 <= 2 && VAR282 >= 0 && VAR282 <= 2)
return 95;
else if ((VAR281 == 2 || VAR281 == 5) && (VAR282 == 2 || VAR282 == 5))
return 2;
}
else if (VAR280 == 1){
if (VAR281 == 1 && VAR282 == 1)
return 250;
else if (VAR281 >= 0 && VAR281 <= 2 && VAR282 >= 0 && VAR282 <= 2)
return 95;
else if ((VAR281 == 1 || VAR281 == 4) && (VAR282 == 1 || VAR282 == 4))
return 3;
}
else if (VAR280 == 0){
if (VAR281 == 0 && VAR282 == 0)
return 1777;
else if (VAR281 >= 0 && VAR281 <= 2 && VAR282 >= 0 && VAR282 <= 2)
return 95;
else if ((VAR281 == 0 || VAR281 == 3) && (VAR282 == 0 || VAR282 == 3))
return 3;
}
return 0;
}
}
1
---------------------------------
48 0x3f500a7e3783fbd228ddb894de2db110eed83a5b.sol
pragma VAR1 ^ 0.4.13;
contract VAR2 {
function FUN1(address VAR3, uint256 VAR4);
}
contract VAR5 {
function FUN2(address VAR6) constant returns(uint256 VAR7);
mapping(address => uint) public VAR8;
uint public VAR9;
}
contract VAR10 {
address public VAR11;
address public VAR12;
address public VAR13;
address public VAR14;
function FUN3() payable {
VAR11 = msg.sender;
}
modifier onlyOwner {
require(VAR11 == msg.sender);
VAR15;
}
modifier VAR16 {
require(VAR11 == msg.sender || VAR13 == msg.sender);
VAR15;
}
modifier VAR17 {
require(VAR11 == msg.sender || VAR14 == msg.sender);
VAR15;
}
function FUN4(address VAR6) onlyOwner external {
require(VAR6 != 0);
VAR12 = VAR6;
}
function FUN5() external {
require(VAR12 == msg.sender);
VAR11 = VAR12;
delete VAR12;
}
function FUN6(address VAR18) onlyOwner external {
require(VAR18 != 0);
VAR13 = VAR18;
}
function FUN7(address VAR19) onlyOwner external {
require(VAR19 != 0);
VAR14 = VAR19;
}
}
contract VAR20 {
function FUN8(address VAR21, uint256 VAR4, bytes32[] VAR22) external;
}
contract VAR23 {
uint public VAR24;
function FUN2(address VAR25) constant returns(uint);
function transfer(address VAR26, uint value);
function FUN9(address VAR11, address VAR27) constant returns(uint);
function FUN10(address VAR28, address VAR26, uint value);
function FUN11(address VAR27, uint value);
event FUN12(address indexed VAR11, address indexed VAR27, uint value);
event Transfer(address indexed VAR28, address indexed VAR26, uint value);
}
contract VAR29 {
enum VAR30 {
VAR31,
VAR32,
VAR33,
VAR34,
VAR35,
VAR36
}
State public VAR37 = VAR30.VAR31;
event FUN13(State VAR38, State VAR39);
function FUN14(State VAR39) internal {
State VAR38 = VAR37;
VAR37 = VAR39;
FUN13(VAR38, VAR39);
}
}
contract Crowdsale is VAR10, VAR29 {
uint public VAR40;
address public VAR41;
uint public VAR42;
uint public VAR43;
uint public VAR44;
uint public VAR45;
uint public VAR46;
struct VAR47 {
uint VAR48;
uint VAR49;
}
struct VAR50 {
uint VAR51;
uint VAR52;
address VAR53;
}
mapping(bytes32 => VAR50) public VAR54;
mapping(address => VAR47) public VAR55;
mapping(uint => address) public VAR56;
uint public VAR57;
mapping(uint => address) public VAR58;
uint public VAR59;
function FUN15() payable FUN3() {}
function FUN16(address VAR60, uint VAR61, uint VAR62) internal returns(uint VAR63);
function FUN17() internal;
function FUN18(address VAR64, uint VAR65) internal;
function() payable crowdsaleState limitNotExceeded VAR66 {
uint VAR67 = msg.value;
uint VAR68 = VAR67 * VAR40 / 1 VAR69;
uint VAR9 = FUN19();
if (VAR44 + VAR68 > VAR42) {
VAR68 = VAR42 - VAR44;
VAR67 = VAR68 * 1 VAR69 / VAR40;
uint VAR70 = msg.value - VAR67;
bool VAR71 = msg.sender.call.FUN20(3000000).value(VAR70)();
require(VAR71);
VAR44 = VAR42;
} else {
VAR44 += VAR68;
}
FUN21(msg.sender, VAR9, VAR68, VAR67);
}
function FUN22(address VAR72, uint VAR73) external onlyOwner crowdsaleState limitNotExceeded VAR66 {
uint VAR9 = FUN19();
VAR44 += VAR73;
FUN21(VAR72, VAR9, VAR73, 0);
}
function FUN23(address VAR72, uint VAR74, uint VAR75, bytes32 VAR76) external onlyOwnerOrBtcOracle crowdsaleState limitNotExceeded VAR66 {
uint VAR68 = VAR74 * VAR75 / 1 VAR69;
uint VAR9 = FUN19();
BtcDeposit storage VAR77 = VAR54[VAR76];
require(VAR77.VAR51 == 0);
VAR77.VAR51 = VAR74;
VAR77.VAR52 = VAR75;
VAR77.VAR53 = VAR72;
VAR44 += VAR68;
FUN21(VAR72, VAR9, VAR68, 0);
}
function FUN21(address VAR60, uint VAR61, uint VAR78, uint VAR79) internal {
var VAR80 = FUN16(VAR60, VAR61, VAR78);
Investor storage VAR81 = VAR55[VAR60];
if (VAR81.VAR48 == 0) {
VAR56[VAR57++] = VAR60;
}
VAR81.VAR48 += VAR80;
if (VAR37 == VAR30.VAR34) {
VAR81.VAR49 += VAR79;
}
}
function FUN19() internal returns(uint VAR9) {
VAR9 = 0;
if (VAR37 == VAR30.VAR32) {
VAR9 = 76923076923076900;
}
if (VAR37 == VAR30.VAR34) {
if (VAR82 < VAR45 + 1 VAR83) {
VAR9 = 86956521730000000;
} else if (VAR82 < VAR45 + 1 VAR84) {
VAR9 = 90909090900000000;
} else if (VAR82 < VAR45 + 2 VAR84) {
VAR9 = 95238095230000000;
} else {
VAR9 = 100000000000000000;
}
}
}
function FUN24(
address VAR85,
uint VAR86,
uint VAR87,
uint VAR88) external onlyOwner {
require(VAR37 == VAR30.VAR31);
VAR45 = VAR82;
VAR41 = VAR85;
VAR40 = VAR86;
VAR42 = VAR87;
VAR46 = VAR82 + VAR88 * 1 VAR83;
VAR44 = 0;
FUN14(VAR30.VAR32);
}
function FUN25() public onlyOwner {
require(VAR37 == VAR30.VAR32);
bool VAR71 = VAR41.call.FUN20(3000000).value(this.VAR7)();
require(VAR71);
FUN14(VAR30.VAR33);
}
function FUN26(
address VAR85,
uint VAR86,
uint VAR87,
uint VAR88,
uint VAR89) external onlyOwner {
require(VAR37 == VAR30.VAR33);
VAR45 = VAR82;
VAR41 = VAR85;
VAR40 = VAR86;
VAR42 = VAR87;
VAR46 = VAR82 + VAR88 * 1 VAR83;
VAR43 = VAR89;
VAR44 = 0;
FUN14(VAR30.VAR34);
}
function FUN27(uint VAR90) public {
require(VAR37 == VAR30.VAR34);
require(VAR82 >= VAR46 && VAR44 < VAR43);
while (VAR90 > 0 && VAR57 > 0) {
address VAR91 = VAR56[--VAR57];
Investor memory VAR81 = VAR55[VAR91];
FUN18(VAR91, VAR81.VAR48);
--VAR90;
delete VAR56[VAR57];
VAR58[VAR59] = VAR91;
VAR59++;
}
if (VAR57 > 0) {
return;
}
FUN14(VAR30.VAR36);
}
function FUN28(uint VAR90) public onlyOwner {
require(VAR37 == VAR30.VAR34);
require(VAR44 >= VAR43);
while (VAR90 > 0 && VAR57 > 0) {
--VAR57;
--VAR90;
delete VAR55[VAR56[VAR57]];
delete VAR56[VAR57];
}
if (VAR57 > 0) {
return;
}
FUN17();
bool VAR71 = VAR41.call.FUN20(3000000).value(this.VAR7)();
require(VAR71);
FUN14(VAR30.VAR35);
}
function FUN29(uint VAR86) external VAR16 {
VAR40 = VAR86;
}
function FUN30(address VAR85) external onlyOwner() {
require(VAR85 != 0);
VAR41 = VAR85;
}
function FUN31() external VAR92 {
FUN32(msg.sender);
}
function FUN33(uint VAR90) public VAR92 {
while (VAR90 > 0 && VAR59 > 0) {
address VAR91 = VAR58[--VAR59];
delete VAR58[VAR59];
--VAR90;
FUN32(VAR91);
}
}
function FUN34(address VAR72) public VAR92 {
FUN32(VAR72);
}
function FUN32(address VAR72) internal {
Investor memory VAR81 = VAR55[VAR72];
uint value = VAR81.VAR49;
if (value > 0) {
delete VAR55[VAR72];
require(VAR72.call.FUN20(3000000).value(value)());
}
}
function FUN35(uint VAR4) public onlyOwner {
require(VAR37 == VAR30.VAR32 || (VAR37 == VAR30.VAR34 && VAR44 > VAR43));
if (VAR4 == 0) {
VAR4 = this.VAR7;
}
bool VAR71 = VAR41.call.FUN20(3000000).value(VAR4)();
require(VAR71);
}
modifier VAR66 {
require(VAR82 < VAR46);
VAR15;
}
modifier VAR93 {
require(VAR44 < VAR42);
VAR15;
}
modifier VAR94 {
require(VAR37 == VAR30.VAR32 || VAR37 == VAR30.VAR34);
VAR15;
}
modifier VAR92 {
require(VAR37 == VAR30.VAR36);
VAR15;
}
modifier VAR95 {
require(VAR37 == VAR30.VAR35);
VAR15;
}
}
contract Token is VAR96, VAR23 {
mapping(address => uint) internal VAR97;
mapping(address => mapping(address => uint)) public VAR98;
uint8 public constant VAR99 = 8;
function FUN36() payable FUN15() {}
function FUN2(address VAR25) constant returns(uint) {
return VAR97[VAR25];
}
function transfer(address VAR72, uint VAR4) public VAR95 FUN37(2 * 32) {
require(VAR97[msg.sender] >= VAR4);
require(VAR97[VAR72] + VAR4 >= VAR97[VAR72]);
VAR97[msg.sender] -= VAR4;
VAR97[VAR72] += VAR4;
Transfer(msg.sender, VAR72, VAR4);
}
function FUN10(address VAR3, address VAR72, uint VAR4) public VAR95 FUN37(3 * 32) {
require(VAR97[VAR3] >= VAR4);
require(VAR97[VAR72] + VAR4 >= VAR97[VAR72]);
require(VAR98[VAR3][msg.sender] >= VAR4);
VAR97[VAR3] -= VAR4;
VAR97[VAR72] += VAR4;
VAR98[VAR3][msg.sender] -= VAR4;
Transfer(VAR3, VAR72, VAR4);
}
function FUN11(address VAR100, uint VAR4) public VAR95 {
VAR98[msg.sender][VAR100] = VAR4;
FUN12(msg.sender, VAR100, VAR4);
}
function FUN9(address VAR6, address VAR100) public constant VAR95 returns(uint VAR101) {
return VAR98[VAR6][VAR100];
}
modifier FUN37(uint VAR102) {
require(msg.VAR103.VAR104 >= VAR102 + 4);
VAR15;
}
}
contract MigratableToken is VAR105 {
function FUN38() payable FUN36() {}
address public VAR106;
uint public VAR107;
address public VAR108;
mapping(address => bool) VAR109;
event FUN39(address indexed VAR28, address indexed VAR26, uint value);
function FUN40(address VAR64) external onlyOwner {
require(VAR64 != 0);
VAR108 = VAR64;
}
function FUN41(address VAR64) external onlyOwner {
require(VAR108 != 0 &&
VAR37 != VAR30.VAR36 &&
VAR40 != 0 &&
VAR109[VAR64] == false);
PreArtexToken VAR110 = FUN42(VAR108);
uint VAR111 = VAR110.FUN2(VAR64);
require(VAR111 > 0);
uint VAR112 = VAR110.FUN43(VAR64);
uint VAR113 = VAR110.FUN44();
uint VAR114 = 0;
if (VAR111 != 0 && VAR112 == 0) {
VAR114 = VAR111 * 140 / 130;
} else {
var VAR115 = ((VAR111 * VAR113 * 1 VAR69) / (VAR112 * (10 ** uint(VAR99))));
if (VAR40 > VAR115) {
VAR114 = (VAR111 * VAR40 * 140) / (VAR115 * 130);
} else {
VAR114 = VAR111 * 140 / 130;
}
}
VAR97[VAR64] = VAR114;
VAR24 += VAR114;
VAR109[VAR64] = true;
if (VAR37 != VAR30.VAR35) {
Investor storage VAR81 = VAR55[VAR64];
VAR56[VAR57++] = VAR64;
VAR81.VAR48 += VAR114;
}
Transfer(this, VAR64, VAR114);
}
function FUN45() external {
require(VAR106 != 0);
uint value = VAR97[msg.sender];
VAR97[msg.sender] -= value;
Transfer(msg.sender, this, value);
VAR24 -= value;
VAR107 += value;
FUN46(VAR106).FUN1(msg.sender, value);
FUN39(msg.sender, VAR106, value);
}
function FUN47(address VAR116) external onlyOwner {
require(VAR106 == 0);
VAR106 = VAR116;
}
}
contract ArtexToken is VAR117 {
string public constant VAR118 = "";
string public constant VAR119 = "";
mapping(address => bool) public VAR120;
function FUN48() payable FUN38() {}
function FUN16(address VAR60, uint VAR61, uint VAR78) internal returns(uint VAR63) {
VAR63 = (VAR78 * (10 ** uint(VAR99))) / VAR61;
require(VAR97[VAR60] + VAR63 > VAR97[VAR60]);
require(VAR63 > 0);
VAR97[VAR60] += VAR63;
VAR24 += VAR63;
Transfer(this, VAR60, VAR63);
}
function FUN17() internal {
uint VAR63 = VAR24 * 100 / 74 - VAR24;
require(VAR97[VAR41] + VAR63 > VAR97[VAR41]);
require(VAR63 > 0);
VAR97[VAR41] += VAR63;
VAR24 += VAR63;
Transfer(this, VAR41, VAR63);
}
function FUN18(address VAR64, uint VAR65) internal {
VAR97[VAR64] -= VAR65;
VAR24 -= VAR65;
Transfer(VAR64, this, VAR65);
}
function FUN49(address VAR64) external onlyOwner {
require(VAR64 != 0);
VAR120[VAR64] = true;
}
function FUN50(address VAR64) external onlyOwner {
require(VAR64 != 0);
delete VAR120[VAR64];
}
function FUN51(address VAR72, uint256 VAR4, bytes32[] VAR22) external FUN52(VAR72) {
var VAR121 = FUN53(VAR72);
transfer(VAR72, VAR4);
VAR121.FUN8(msg.sender, VAR4, VAR22);
}
modifier FUN52(address VAR64) {
require(VAR120[VAR64] == true);
VAR15;
}
}
1
---------------------------------
49 0x3f7a7fe9b5304042d179deadf2521ea12d97a5c7.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) pure internal returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) pure internal returns (uint) {
uint VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint VAR3, uint VAR4) pure internal returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint VAR3, uint VAR4) pure internal returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint64 VAR3, uint64 VAR4) pure internal returns (VAR6) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN6(uint64 VAR3, uint64 VAR4) pure internal returns (VAR6) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN7(uint256 VAR3, uint256 VAR4) pure internal returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN8(uint256 VAR3, uint256 VAR4) pure internal returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
contract VAR7 {
address public VAR8;
constructor() public {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR9;
}
function FUN9(address VAR10) public onlyOwner {
if (VAR10 != address(0)) {
VAR8 = VAR10;
}
}
}
interface VAR11 {
function FUN10() external view returns (uint VAR12);
function FUN11(address VAR13) external view returns (uint VAR14);
function transfer(address VAR15, uint VAR16) external;
function FUN12(address VAR17, address VAR15, uint VAR16) external;
function FUN13(address VAR18, uint VAR16) external;
function FUN14(address VAR13, address VAR18) external view returns (uint VAR19);
function FUN15() external view returns(uint VAR20);
event FUN16(address indexed VAR13, address indexed VAR18, uint VAR16);
}
interface VAR21 {
event FUN17( ERC20 VAR22, uint VAR23, ERC20 VAR24, uint VAR25);
function FUN18(
ERC20 VAR22,
ERC20 VAR24,
uint VAR23
)
external
payable
returns(uint);
function FUN19(
ERC20 VAR22,
ERC20 VAR24,
uint VAR23
)
external
view
returns(uint, uint);
}
contract KulapDex is VAR7 {
event FUN17(
address indexed VAR26,
uint256         VAR27,
address indexed VAR28,
uint256         VAR29,
address indexed VAR30,
uint256          VAR31
);
using SafeMath for uint256;
ERC20 public VAR32 = FUN20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
VAR21[] public VAR33;
function FUN21(
uint256 VAR34,
uint256 VAR23,
ERC20 VAR24
)
private
returns(uint256)  {
KULAPTradingProxy VAR35 = VAR33[VAR34];
uint256 VAR25 = VAR35.VAR36.value(VAR23)(
VAR32,
VAR24,
VAR23
);
return VAR25;
}
function () public payable {
}
function FUN22(
uint256 VAR34,
ERC20 VAR22,
uint256 VAR23
)
private
returns(uint256)  {
KULAPTradingProxy VAR35 = VAR33[VAR34];
VAR22.FUN13(VAR35, VAR23);
uint256 VAR25 = VAR35.FUN18(
VAR22,
VAR32,
VAR23
);
return VAR25;
}
//
function FUN23(
uint256             VAR37,
ERC20               VAR38,
uint256             VAR27,
ERC20               VAR39,
uint256             VAR40
) private returns(uint256)  {
uint256 VAR25;
uint256 VAR41;
uint256 VAR42;
if (VAR32 == VAR38) {
VAR41 = address(this).VAR14;
} else {
VAR41 = VAR38.FUN11(this);
}
if (VAR32 == VAR39) {
VAR42 = address(this).VAR14;
} else {
VAR42 = VAR39.FUN11(this);
}
if (VAR32 == VAR38) {
VAR25 = FUN21(VAR37, VAR27, VAR39);
} else if (VAR32 == VAR39) {
VAR25 = FUN22(VAR37, VAR38, VAR27);
} else {
revert();
}
if (VAR32 == VAR38) {
assert(address(this).VAR14 == VAR41.FUN3(VAR27));
} else {
assert(VAR38.FUN11(this) == VAR41.FUN3(VAR27));
}
if (VAR32 == VAR39) {
assert(address(this).VAR14 == VAR42.FUN4(VAR25));
} else {
assert(VAR39.FUN11(this) == VAR42.FUN4(VAR25));
}
assert(VAR25 >= VAR40);
return VAR25;
}
//
function FUN18(uint256 VAR34, ERC20 VAR22, uint256 VAR23, ERC20 VAR24, uint256 VAR43) payable public returns(uint256)  {
uint256 VAR25;
if (VAR32 == VAR22) {
VAR25 = FUN23(VAR34, VAR22, VAR23, VAR24, 1);
assert(VAR25 >= VAR43);
VAR24.transfer(msg.sender, VAR25);
} else if (VAR32 == VAR24) {
VAR22.FUN12(msg.sender, address(this), VAR23);
VAR25 = FUN23(VAR34, VAR22, VAR23, VAR24, 1);
assert(VAR25 >= VAR43);
msg.sender.transfer(VAR25);
} else {
revert();
}
emit FUN17( VAR22, VAR23, VAR24, VAR25, msg.sender, 0);
return VAR25;
}
//
function FUN24(ERC20 VAR22, uint256 VAR23, ERC20 VAR24, uint256 VAR43, address[] VAR44) payable public returns(uint256)  {
uint256 VAR25;
if (VAR32 != VAR22) {
VAR22.FUN12(msg.sender, address(this), VAR23);
}
uint256 VAR45 = VAR23;
for (uint VAR46=0; VAR46 < VAR44.VAR47; VAR46+=3) {
uint256 VAR34 =         uint256(VAR44[VAR46]);
ERC20 VAR48 =                     FUN20(VAR44[VAR46+1]);
ERC20 VAR49 =                    FUN20(VAR44[VAR46+2]);
VAR25 = FUN23(VAR34, VAR48, VAR45, VAR49, 1);
VAR45 = VAR25;
}
assert(VAR25 >= VAR43);
if (VAR32 == VAR24) {
msg.sender.transfer(VAR25);
} else {
VAR24.transfer(msg.sender, VAR25);
}
emit FUN17( VAR22, VAR23, VAR24, VAR25, msg.sender, 0);
return VAR25;
}
function FUN19(uint256 VAR34, ERC20 VAR22, ERC20 VAR24, uint VAR23) public view returns(uint, uint) {
KULAPTradingProxy VAR35 = VAR33[VAR34];
return VAR35.FUN19(VAR22, VAR24, VAR23);
}
function FUN25(
KULAPTradingProxy VAR50
) public onlyOwner returns (uint256) {
VAR33.FUN26( VAR50 );
return VAR33.VAR47;
}
}
1
---------------------------------
50 0x40b10014a17e997e8e55594cbfb4f085c5ec815b.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
address public VAR3;
function FUN1() {
VAR3 = msg.sender;
}
modifier onlyOwner {
if (msg.sender != VAR3) throw;
VAR4;
}
function FUN2(address VAR5) onlyOwner {
VAR3 = VAR5;
}
}
contract MultiSig is VAR2 {
uint constant public VAR6 = 50;
event FUN3(address indexed sender, uint indexed VAR7);
event FUN4(address indexed sender, uint indexed VAR7);
event FUN5(uint indexed VAR7);
event FUN6(uint indexed VAR7);
event FUN7(uint indexed VAR7);
event FUN8(address indexed sender, uint value);
event FUN9(address indexed VAR3);
event FUN10(address indexed VAR3);
event FUN11(uint VAR8);
mapping (uint => Transaction) public VAR9;
mapping (uint => mapping (address => bool)) public VAR10;
mapping (address => bool) public VAR11;
address[] public VAR12;
uint public VAR8;
uint public VAR13;
struct Transaction {
address VAR14;
uint value;
bytes VAR15;
bool VAR16;
}
modifier FUN12() {
if (msg.sender != address(this))
throw;
VAR4;
}
modifier FUN13(address VAR3) {
if (VAR11[VAR3])
throw;
VAR4;
}
modifier ownerExists(address VAR3) {
if (!VAR11[VAR3])
throw;
VAR4;
}
modifier FUN14(uint VAR7) {
if (VAR9[VAR7].VAR14 == 0)
throw;
VAR4;
}
modifier confirmed(uint VAR7, address VAR3) {
if (!VAR10[VAR7][VAR3])
throw;
VAR4;
}
modifier notConfirmed(uint VAR7, address VAR3) {
if (VAR10[VAR7][VAR3])
throw;
VAR4;
}
modifier notExecuted(uint VAR7) {
if (VAR9[VAR7].VAR16)
throw;
VAR4;
}
modifier FUN15(address VAR17) {
if (VAR17 == 0)
throw;
VAR4;
}
modifier FUN16(uint VAR18, uint VAR19) {
if (   VAR18 > VAR6
|| VAR19 > VAR18
|| VAR19 == 0
|| VAR18 == 0)
throw;
VAR4;
}
function FUN17(address[] VAR20, uint VAR19)
public
FUN16(VAR20.VAR21, VAR19)
{
for (uint VAR22=0; VAR22<VAR20.VAR21; VAR22++) {
if (VAR11[VAR20[VAR22]] || VAR20[VAR22] == 0)
throw;
VAR11[VAR20[VAR22]] = true;
}
VAR12 = VAR20;
VAR8 = VAR19;
}
function FUN18(address VAR3)
public
VAR23
FUN13(VAR3)
FUN15(VAR3)
FUN16(VAR12.VAR21 + 1, VAR8)
{
VAR11[VAR3] = true;
VAR12.FUN19(VAR3);
FUN20(VAR12.VAR21 / 2 + 1);
FUN9(VAR3);
}
function FUN21(address VAR3)
public
VAR23
ownerExists(VAR3)
{
VAR11[VAR3] = false;
for (uint VAR22=0; VAR22<VAR12.VAR21 - 1; VAR22++)
if (VAR12[VAR22] == VAR3) {
VAR12[VAR22] = VAR12[VAR12.VAR21 - 1];
break;
}
VAR12.VAR21 -= 1;
FUN20(VAR12.VAR21 / 2 + 1);
FUN10(VAR3);
}
function FUN22(address VAR3, address VAR5)
public
VAR23
ownerExists(VAR3)
FUN13(VAR5)
{
for (uint VAR22=0; VAR22<VAR12.VAR21; VAR22++)
if (VAR12[VAR22] == VAR3) {
VAR12[VAR22] = VAR5;
break;
}
VAR11[VAR3] = false;
VAR11[VAR5] = true;
FUN10(VAR3);
FUN9(VAR5);
}
function FUN20(uint VAR19)
public
VAR23
FUN16(VAR12.VAR21, VAR19)
{
VAR8 = VAR19;
FUN11(VAR19);
}
function FUN23(address VAR14, uint value, bytes VAR15)
public
ownerExists(msg.sender)
returns (uint VAR7)
{
VAR7 = FUN24(VAR14, value, VAR15);
FUN25(VAR7);
}
function FUN25(uint VAR7)
public
ownerExists(msg.sender)
FUN14(VAR7)
notConfirmed(VAR7, msg.sender)
{
VAR10[VAR7][msg.sender] = true;
FUN3(msg.sender, VAR7);
FUN26(VAR7);
}
function FUN27(uint VAR7)
public
ownerExists(msg.sender)
confirmed(VAR7, msg.sender)
notExecuted(VAR7)
{
VAR10[VAR7][msg.sender] = false;
FUN4(msg.sender, VAR7);
}
function FUN26(uint VAR7)
public
notExecuted(VAR7)
{
}
function FUN28(uint VAR7)
public
constant
returns (bool)
{
uint VAR24 = 0;
for (uint VAR22=0; VAR22<VAR12.VAR21; VAR22++) {
if (VAR10[VAR7][VAR12[VAR22]])
VAR24 += 1;
if (VAR24 == VAR8)
return true;
}
}
function FUN24(address VAR14, uint value, bytes VAR15)
internal
FUN15(VAR14)
returns (uint VAR7)
{
VAR7 = VAR13;
VAR9[VAR7] = Transaction({
VAR14: VAR14,
value: value,
VAR15: VAR15,
VAR16: false
});
VAR13 += 1;
FUN5(VAR7);
}
function FUN29(uint VAR7)
public
constant
returns (uint VAR24)
{
for (uint VAR22=0; VAR22<VAR12.VAR21; VAR22++)
if (VAR10[VAR7][VAR12[VAR22]])
VAR24 += 1;
}
function FUN30(bool VAR25, bool VAR16)
public
constant
returns (uint VAR24)
{
for (uint VAR22=0; VAR22<VAR13; VAR22++)
if (   VAR25 && !VAR9[VAR22].VAR16
|| VAR16 && VAR9[VAR22].VAR16)
VAR24 += 1;
}
function FUN31()
public
constant
returns (address[])
{
return VAR12;
}
function FUN32(uint VAR7)
public
constant
returns (address[] VAR26)
{
address[] memory VAR27 = new address[](VAR12.VAR21);
uint VAR24 = 0;
uint VAR22;
for (VAR22=0; VAR22<VAR12.VAR21; VAR22++)
if (VAR10[VAR7][VAR12[VAR22]]) {
VAR27[VAR24] = VAR12[VAR22];
VAR24 += 1;
}
VAR26 = new address[](VAR24);
for (VAR22=0; VAR22<VAR24; VAR22++)
VAR26[VAR22] = VAR27[VAR22];
}
function FUN33(uint VAR28, uint VAR29, bool VAR25, bool VAR16)
public
constant
returns (uint[] VAR30)
{
uint[] memory VAR31 = new uint[](VAR13);
uint VAR24 = 0;
uint VAR22;
for (VAR22=0; VAR22<VAR13; VAR22++)
if (   VAR25 && !VAR9[VAR22].VAR16
|| VAR16 && VAR9[VAR22].VAR16)
{
VAR31[VAR24] = VAR22;
VAR24 += 1;
}
VAR30 = new uint[](VAR29 - VAR28);
for (VAR22=VAR28; VAR22<VAR29; VAR22++)
VAR30[VAR22 - VAR28] = VAR31[VAR22];
}
}
contract MultiSigWallet is VAR32 {
function FUN34(address[] VAR20, uint VAR19)
public
FUN17( VAR20, VAR19)
{
}
function()
payable
{
if (msg.value > 0)
FUN8(msg.sender, msg.value);
}
function FUN26(uint VAR7)
public
notExecuted(VAR7)
{
if (FUN28(VAR7)) {
Transaction VAR33 = VAR9[VAR7];
if (VAR33.VAR14.call.value(VAR33.value)(VAR33.VAR15)) {
VAR33.VAR16 = true;
FUN6(VAR7);
} else {
FUN7(VAR7);
VAR33.VAR16 = false;
}
}
}
}
contract VAR34 {function transfer(address VAR35, uint VAR36) returns (bool VAR37);}
contract MultiSigToken is VAR32 {
token public VAR38 ;
function FUN35(address[] VAR20, uint VAR19, token VAR39)
public
FUN17( VAR20, VAR19)
{
VAR38 = FUN36(VAR39);
}
function()
{
throw;
}
function FUN26(uint VAR7)
public
notExecuted(VAR7)
{
if (FUN28(VAR7)) {
Transaction VAR33 = VAR9[VAR7];
if (VAR38.transfer(VAR33.VAR14, VAR33.value)) {
VAR33.VAR16 = true;
FUN6(VAR7);
} else {
VAR33.VAR16 = false;
FUN7(VAR7);
}
}
}
}
1
---------------------------------
51 0x41aef9b47f6e37de66e34ce073023b36f1823b2a.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 value) public returns (bool);
event Transfer(address indexed VAR5, address indexed VAR4, uint256 value);
}
library VAR6 {
function FUN3(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
if (VAR7 == 0) {
return 0;
}
uint256 VAR9 = VAR7 * VAR8;
assert(VAR9 / VAR7 == VAR8);
return VAR9;
}
function FUN4(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
uint256 VAR9 = VAR7 / VAR8;
return VAR9;
}
function FUN5(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
assert(VAR8 <= VAR7);
return VAR7 - VAR8;
}
function FUN6(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
uint256 VAR9 = VAR7 + VAR8;
assert(VAR9 >= VAR7);
return VAR9;
}
}
contract BasicToken is VAR2 {
using SafeMath for uint256;
mapping(address => uint256) VAR10;
uint256 VAR11;
function FUN1() public view returns (uint256) {
return VAR11;
}
function transfer(address VAR12, uint256 VAR13) public returns (bool) {
require(VAR12 != address(0));
require(VAR13 <= VAR10[msg.sender]);
VAR10[msg.sender] = VAR10[msg.sender].FUN5(VAR13);
VAR10[VAR12] = VAR10[VAR12].FUN6(VAR13);
Transfer(msg.sender, VAR12, VAR13);
return true;
}
function FUN2(address VAR14) public view returns (uint256 VAR15) {
return VAR10[VAR14];
}
}
contract ERC20 is VAR2 {
function FUN7(address VAR16, address VAR17) public view returns (uint256);
function FUN8(address VAR5, address VAR4, uint256 value) public returns (bool);
function FUN9(address VAR17, uint256 value) public returns (bool);
event FUN10(address indexed VAR16, address indexed VAR17, uint256 value);
}
contract StandardToken is VAR18, VAR19 {
mapping (address => mapping (address => uint256)) internal VAR20;
function FUN8(address VAR21, address VAR12, uint256 VAR13) public returns (bool) {
require(VAR12 != address(0));
require(VAR13 <= VAR10[VAR21]);
require(VAR13 <= VAR20[VAR21][msg.sender]);
VAR10[VAR21] = VAR10[VAR21].FUN5(VAR13);
VAR10[VAR12] = VAR10[VAR12].FUN6(VAR13);
VAR20[VAR21][msg.sender] = VAR20[VAR21][msg.sender].FUN5(VAR13);
Transfer(VAR21, VAR12, VAR13);
return true;
}
function FUN9(address VAR22, uint256 VAR13) public returns (bool) {
VAR20[msg.sender][VAR22] = VAR13;
FUN10(msg.sender, VAR22, VAR13);
return true;
}
function FUN7(address VAR14, address VAR22) public view returns (uint256) {
return VAR20[VAR14][VAR22];
}
function FUN11(address VAR22, uint VAR23) public returns (bool) {
VAR20[msg.sender][VAR22] = VAR20[msg.sender][VAR22].FUN6(VAR23);
FUN10(msg.sender, VAR22, VAR20[msg.sender][VAR22]);
return true;
}
function FUN12(address VAR22, uint VAR24) public returns (bool) {
uint VAR25 = VAR20[msg.sender][VAR22];
if (VAR24 > VAR25) {
VAR20[msg.sender][VAR22] = 0;
} else {
VAR20[msg.sender][VAR22] = VAR25.FUN5(VAR24);
}
FUN10(msg.sender, VAR22, VAR20[msg.sender][VAR22]);
return true;
}
}
contract IChain is VAR26 {
string public VAR27 = '';
string public VAR28 = '';
uint8 public VAR29 = 18;
uint public VAR30 = 1000000000 VAR31;
address public VAR32;
address public VAR16;
uint256 public VAR33 ;
uint256 public VAR34 ;
uint256 public VAR35 ;
uint256 public VAR36;
uint256 public VAR37 = 800000000 VAR31;
uint256 public VAR38;
uint256 public VAR39 = VAR30.FUN5(VAR37);
bool public VAR40 = false;
bool public VAR41 = false;
event FUN13(address VAR42, uint VAR43);
event FUN14(address VAR44, uint VAR45, bool VAR46);
function FUN15(address VAR47,
uint VAR48,
uint VAR49
) public {
VAR32 = VAR47;
VAR33 = VAR48 * 1 VAR31;
VAR36 = VAR49;
VAR16 = msg.sender;
VAR10[msg.sender] = VAR37;
}
modifier FUN16() {
require(!VAR41);
VAR50;
}
modifier onlyOwner() {
require(msg.sender == VAR16);
VAR50;
}
function () external payable {
require(!VAR41);
require(!VAR40);
FUN17();
}
function FUN18() onlyOwner canDistr  public returns (bool) {
VAR41 = true;
uint256 VAR51 = VAR39.FUN5(VAR35);
VAR10[VAR32] = VAR10[VAR32].FUN6(VAR51);
require(msg.sender.call.value(VAR34)());
return true;
}
function FUN19(uint VAR51) onlyOwner  public returns (bool) {
require(msg.sender.call.value(VAR51)());
return true;
}
function FUN17() payable{
if (VAR34 >= VAR33) {
VAR40 = true;
return;
}
address VAR52 = msg.sender;
uint VAR51 = msg.value;
FUN20(VAR52,VAR51);
}
function FUN20(address VAR12, uint256 VAR53) canDistr private returns (bool) {
VAR34 += VAR53;
VAR53=VAR53.FUN3(VAR36);
VAR35 += VAR53;
VAR10[VAR12] = VAR10[VAR12].FUN6(VAR53);
FUN14(msg.sender,VAR53,true);
return true;
}
}
1
---------------------------------
52 0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address=>uint256) public VAR3;
uint public VAR4 = 1 VAR5;
LogFile VAR6 = FUN1(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
bool VAR7;
function FUN2(uint VAR8)
public
{
if(VAR7)revert();
VAR4 = VAR8;
}
function FUN3(address VAR9)
public
{
if(VAR7)revert();
VAR6 = FUN1(VAR9);
}
function FUN4()
public
{
VAR7 = true;
}
function FUN5()
public
payable
{
VAR3[msg.sender]+= msg.value;
VAR6.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR10)
public
payable
{
if(VAR3[msg.sender]>=VAR4 && VAR3[msg.sender]>=VAR10)
{
if(msg.sender.call.value(VAR10)())
{
VAR3[msg.sender]-=VAR10;
VAR6.FUN6(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN5();
}
}
contract VAR11
{
struct VAR12
{
address VAR13;
string  VAR14;
uint VAR15;
uint  VAR16;
}
VAR12[] public VAR17;
Message VAR18;
function FUN6(address VAR19,uint VAR8,string VAR20)
public
{
VAR18.VAR13 = VAR19;
VAR18.VAR16 = VAR21;
VAR18.VAR15 = VAR8;
VAR18.VAR14 = VAR20;
VAR17.FUN8(VAR18);
}
}
1
---------------------------------
53 0x43326dd7b558cc59b44e998357a28e8649279cfe.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
using SafeMath for uint;
struct VAR3 {
uint8 VAR4;
uint256 VAR5;
bool VAR6;
mapping (uint8 => address) VAR7;
mapping (address => bool) VAR8;
mapping (uint8 => address) VAR9;
}
HourglassInterface constant VAR10 = FUN1(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
SPASMInterface constant VAR11 = FUN2(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
uint256 constant private VAR12 = 0.005 VAR13;
uint8 constant public VAR14 = 2;
uint256 constant public VAR15 = 0.1 VAR13;
uint256 public VAR16;
uint256 public VAR17;
uint256 public VAR18;
mapping(address => uint256) public VAR19;
uint256 private VAR20 = VAR12 * (VAR14 - 1);
uint256 public VAR21 = 0.185 VAR13;
mapping(address => string) public VAR22;
mapping(address => uint256) private VAR23;
mapping(uint256 => VAR3) public VAR24;
mapping(uint256 => address) public VAR25;
mapping(uint256 => address) public VAR26;
uint256 public  VAR27;
uint256 public  VAR28;
uint256 private VAR29;
uint256 public VAR30;
event FUN3(address indexed VAR31, uint256 VAR32);
event FUN4(address indexed VAR33);
event FUN5(address indexed VAR34);
event FUN6(address indexed VAR33, uint256 indexed VAR35);
event FUN7(uint256 indexed VAR36);
function FUN8()
public
view
returns(address VAR37 , address VAR38, string VAR39 ,address VAR40, string VAR41 )
{
return (VAR26[VAR29],VAR24[VAR29].VAR7[0],VAR22[VAR24[VAR29].VAR7[0]],VAR24[VAR29].VAR7[1],VAR22[VAR24[VAR29].VAR7[1]]);
}
function FUN9()
public
view
returns( address VAR38, string VAR39 ,address VAR40, string VAR41 )
{
return (VAR24[VAR30].VAR7[0],VAR22[VAR24[VAR30].VAR7[0]],VAR24[VAR30].VAR7[1],VAR22[VAR24[VAR30].VAR7[1]]);
}
function FUN10()
public
view
returns(uint256 VAR32 )
{
return (VAR17);
}
function FUN11()
public
view
returns(bool VAR42 )
{
bool VAR43;
if(VAR30 >= VAR29)
{
if(!VAR24[VAR29].VAR6 && VAR24[VAR29].VAR4 < VAR14 && VAR24[VAR29].VAR5 != 0)
{
VAR43 = true;
}
}
return (VAR43);
}
function FUN12()
public
view
returns(address VAR44, uint256 VAR45,uint256 VAR46, uint256 VAR47 , string VAR48)
{
VAR45 = VAR28 - VAR27;
uint256 VAR49 = VAR10.FUN13(true);
return (VAR25[VAR27],VAR45, VAR49 , VAR16 ,VAR22[VAR25[VAR27]]);
}
function FUN14(address VAR50) public
{
uint256 VAR51 = VAR19[VAR50];
VAR19[VAR50] = 0;
if(VAR50 == 0x0){VAR50 = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}
VAR10.VAR52.value(VAR51)(VAR50);
}
function FUN15 ()public
{
uint256 VAR49 = VAR10.FUN13(true);
require(VAR49 > 0);
uint256 VAR53 = VAR49.FUN16(100);
VAR10.FUN17();
VAR11.VAR54.value(VAR53)();
VAR16 = VAR16.FUN18(VAR53.FUN19(94));
VAR17 = VAR17.FUN18(VAR53.FUN19(5));
//
}
function FUN20 ()public payable
{
require(msg.value > 0);
VAR16 = VAR16.FUN18(msg.value);
}
function FUN21 ()public
{
uint256 VAR55 = VAR16;
require(VAR55 > 0.1 VAR13);
VAR16 -= 0.1 VAR13;
VAR25[VAR27].transfer(0.1 VAR13);
VAR27++;
//
}
function FUN22(string VAR56 , address VAR50) public payable
{
require(msg.value >= 1  VAR57);
VAR22[msg.sender] = VAR56;
uint256 VAR51 = VAR19[VAR50].FUN18(msg.value);
VAR19[VAR50] = 0;
if(VAR50 == 0x0){VAR50 = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}
VAR10.VAR52.value(VAR51)(VAR50);
}
modifier FUN23()
{
require(msg.value == VAR15);
VAR58;
}
modifier FUN24()
{
require(VAR23[msg.sender] >= VAR15);
VAR58;
}
modifier FUN25()
{
require(VAR23[msg.sender] > 0);
VAR58;
}
modifier FUN26()
{
if(VAR24[VAR30 - 1].VAR4 == VAR14) {
VAR24[VAR30] = FUN27(0, 0, false );
VAR30++;
}
VAR58;
}
modifier FUN28()
{
require(VAR24[VAR30 - 1].VAR8[msg.sender] == false);
VAR58;
}
constructor()
public
{
VAR24[VAR30] = FUN27(0, 0, false);
VAR30++;
}
function() external payable {}
function FUN29(address VAR59)
external
payable
VAR60
VAR61
VAR62
{
FUN30(VAR59);
FUN31();
}
function FUN32(address VAR59)
external
VAR63
VAR61
VAR62
{
VAR23[msg.sender] -= VAR15;
FUN30(VAR59);
FUN31();
}
function FUN17()
external
VAR64
{
FUN31();
uint256 VAR35 = VAR23[msg.sender];
VAR23[msg.sender] = 0;
emit FUN6(msg.sender, VAR35);
msg.sender.transfer(VAR35);
}
function FUN33()
external
view
VAR64
returns(uint256)
{
return VAR23[msg.sender];
}
function FUN34()
external
view
returns(uint256)
{
return VAR24[VAR30 - 1].VAR4;
}
function FUN30(address VAR59)
private
{
Stage storage VAR65 = VAR24[VAR30 - 1];
assert(VAR65.VAR4 < VAR14);
address VAR33 = msg.sender;
VAR65.VAR7[VAR65.VAR4] = VAR33;
VAR65.VAR4++;
VAR65.VAR8[VAR33] = true;
VAR65.VAR9[VAR65.VAR4] = VAR59;
emit FUN4(VAR33);
if(VAR65.VAR4 == VAR14) {
VAR65.VAR5 = VAR66.VAR67;
}
}
function FUN31()
public
{
assert(VAR30 >= VAR29);
if(VAR30 == VAR29) {return;}
Stage storage VAR68 = VAR24[VAR29];
assert(!VAR68.VAR6);
if(VAR68.VAR4 < VAR14) {return;}
assert(VAR68.VAR5 != 0);
if(VAR66.VAR67 - 256 <= VAR68.VAR5) {
if(VAR66.VAR67 == VAR68.VAR5) {return;}
uint8 VAR69 = uint8(FUN35(VAR68.VAR5)) % VAR14;
uint256 VAR70 = uint256(FUN35(VAR68.VAR5)) % 1000;
address VAR71 = VAR68.VAR7[VAR69];
VAR26[VAR29] = VAR71;
emit FUN5(VAR71);
FUN36(VAR71);
if(VAR70 == 777){
VAR71.transfer(VAR17);
emit FUN3 ( VAR71, VAR17);
VAR17 = 0;
}
VAR25[VAR28] = VAR71;
VAR28++;
VAR19[VAR68.VAR9[1]] = VAR19[VAR68.VAR9[1]].FUN18(0.005 VAR13);
VAR19[VAR68.VAR9[1]] = VAR19[VAR68.VAR9[2]].FUN18(0.005 VAR13);
VAR16 = VAR16.FUN18(0.005 VAR13);
} else {
FUN37(VAR29);
emit FUN7(VAR29);
}
VAR68.VAR6 = true;
VAR29++;
}
function FUN36(address VAR71)
private
{
for (uint8 VAR72 = 0; VAR72 < VAR14; VAR72++) {
address VAR73 = VAR24[VAR29].VAR7[VAR72];
if(VAR73 != VAR71) {
VAR23[VAR73] += VAR21;
}
}
}
function FUN37(uint256 VAR74)
private
{
Stage storage VAR75 = VAR24[VAR74];
for (uint8 VAR72 = 0; VAR72 < VAR14; VAR72++) {
address VAR33 = VAR75.VAR7[VAR72];
VAR23[VAR33] += VAR15;
}
}
}
interface VAR76 {
function FUN38(address VAR77) payable external returns(uint256);
function FUN17() external;
function FUN13(bool VAR78) external view returns(uint256);
function FUN39(address VAR77) external view returns(uint256);
}
interface VAR79  {
function() payable external;
function FUN40() external  payable;
}
library VAR80 {
function FUN18(uint VAR81, uint VAR82) internal pure returns (uint VAR83) {
VAR83 = VAR81 + VAR82;
require(VAR83 >= VAR81);
}
function FUN41(uint VAR81, uint VAR82) internal pure returns (uint VAR83) {
require(VAR82 <= VAR81);
VAR83 = VAR81 - VAR82;
}
function FUN19(uint VAR81, uint VAR82) internal pure returns (uint VAR83) {
VAR83 = VAR81 * VAR82;
require(VAR81 == 0 || VAR83 / VAR81 == VAR82);
}
function FUN16(uint VAR81, uint VAR82) internal pure returns (uint VAR83) {
require(VAR82 > 0);
VAR83 = VAR81 / VAR82;
}
}
1
---------------------------------
54 0x4556d522453633cfc6962cbde7cc4da840eb6707.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
interface VAR6 {
function FUN4(address VAR3, address[] VAR7, address[] VAR8) external;
function FUN5() external view returns (address[]);
function FUN6() external view returns (address[]);
}
contract VAR9 {
function FUN7() public view returns (uint);
function FUN8() public view returns (uint);
function FUN9(address VAR10) public view returns (uint VAR11);
function FUN10(address VAR10, address VAR12) public view returns (uint VAR13);
function transfer(address VAR14, uint VAR15) public returns (bool VAR16);
function FUN11(address VAR12, uint VAR15) public returns (bool VAR16);
function FUN12(address VAR17, address VAR14, uint VAR15) public returns (bool VAR16);
}
contract VAR18 {
address public VAR19;
event FUN13(address indexed VAR20);
modifier onlyOwner {
require(msg.sender == VAR19, "");
VAR21;
}
constructor() public {
VAR19 = msg.sender;
}
function FUN14(address VAR20) external onlyOwner {
require(VAR20 != address(0), "");
VAR19 = VAR20;
emit FUN13(VAR20);
}
}
contract VAR22 {
address public VAR23;
address public VAR19;
mapping (address => bool) public VAR24;
mapping (bytes4 => address) public VAR25;
uint public VAR26;
event FUN15(address indexed VAR27, bool value);
event FUN16(address indexed VAR27, bytes4 indexed VAR28);
event FUN17(address indexed VAR27, address indexed VAR29, uint indexed value, bytes VAR30);
event FUN18(uint indexed value, address indexed sender, bytes VAR30);
event FUN13(address VAR19);
modifier VAR31 {
require(VAR24[msg.sender], "");
VAR21;
}
function FUN1(address VAR32, address[] VAR33) external {
require(VAR19 == address(0) && VAR26 == 0, "");
require(VAR33.VAR34 > 0, "");
VAR19 = VAR32;
VAR26 = VAR33.VAR34;
for(uint256 VAR35 = 0; VAR35 < VAR33.VAR34; VAR35++) {
require(VAR24[VAR33[VAR35]] == false, "");
VAR24[VAR33[VAR35]] = true;
FUN19(VAR33[VAR35]).FUN1(this);
emit FUN15(VAR33[VAR35], true);
}
}
function FUN20(address VAR4, bool VAR36) external VAR31 {
if (VAR24[VAR4] != VAR36) {
if(VAR36 == true) {
VAR26 += 1;
VAR24[VAR4] = true;
FUN19(VAR4).FUN1(this);
}
else {
VAR26 -= 1;
require(VAR26 > 0, "");
delete VAR24[VAR4];
}
emit FUN15(VAR4, VAR36);
}
}
function FUN21(address VAR4, bytes4 VAR37) external VAR31 {
require(VAR24[VAR4], "");
VAR25[VAR37] = VAR4;
emit FUN16(VAR4, VAR37);
}
function FUN22(address VAR20) external VAR31 {
require(VAR20 != address(0), "");
VAR19 = VAR20;
emit FUN13(VAR20);
}
function FUN23(address VAR38, uint VAR36, bytes VAR39) external VAR31 {
require(VAR38.call.value(VAR36)(VAR39), "");
emit FUN17(msg.sender, VAR38, VAR36, VAR39);
}
function() public payable {
if(msg.VAR30.VAR34 > 0) {
address VAR27 = VAR25[msg.VAR40];
if(VAR27 == address(0)) {
emit FUN18(msg.value, msg.sender, msg.VAR30);
}
else {
require(VAR24[VAR27], "");
VAR41 {
FUN24(0, 0, FUN25())
let VAR42 := FUN26(VAR43, VAR27, 0, FUN25(), 0, 0)
FUN27(0, 0, FUN28())
switch VAR42
case 0 {revert(0, FUN28())}
default {return (0, FUN28())}
}
}
}
}
}
contract ModuleRegistry is VAR18 {
mapping (address => VAR44) internal VAR26;
mapping (address => VAR44) internal VAR45;
event FUN29(address indexed VAR27, bytes32 VAR46);
event FUN30(address VAR27);
event FUN31(address indexed VAR47, bytes32 VAR46);
event FUN32(address VAR47);
struct VAR44 {
bool VAR48;
bytes32 VAR46;
}
function FUN33(address VAR4, bytes32 VAR49) external onlyOwner {
require(!VAR26[VAR4].VAR48, "");
VAR26[VAR4] = FUN34({VAR48: true, VAR46: VAR49});
emit FUN29(VAR4, VAR49);
}
function FUN35(address VAR4) external onlyOwner {
require(VAR26[VAR4].VAR48, "");
delete VAR26[VAR4];
emit FUN30(VAR4);
}
function FUN36(address VAR50, bytes32 VAR49) external onlyOwner {
require(!VAR45[VAR50].VAR48, "");
VAR45[VAR50] = FUN34({VAR48: true, VAR46: VAR49});
emit FUN31(VAR50, VAR49);
}
function FUN37(address VAR50) external onlyOwner {
require(VAR45[VAR50].VAR48, "");
delete VAR45[VAR50];
emit FUN32(VAR50);
}
function FUN3(address VAR5) external onlyOwner {
uint VAR51 = FUN38(VAR5).FUN9(address(this));
FUN38(VAR5).transfer(msg.sender, VAR51);
}
function FUN39(address VAR4) external view returns (bytes32) {
return VAR26[VAR4].VAR46;
}
function FUN40(address VAR50) external view returns (bytes32) {
return VAR45[VAR50].VAR46;
}
function FUN41(address VAR4) external view returns (bool) {
return VAR26[VAR4].VAR48;
}
function FUN41(address[] VAR33) external view returns (bool) {
for(uint VAR35 = 0; VAR35 < VAR33.VAR34; VAR35++) {
if (!VAR26[VAR33[VAR35]].VAR48) {
return false;
}
}
return true;
}
function FUN42(address VAR50) external view returns (bool) {
return VAR45[VAR50].VAR48;
}
}
contract BaseModule is VAR2 {
ModuleRegistry internal VAR52;
event FUN43(bytes32 VAR46);
event FUN44(address VAR53);
constructor(ModuleRegistry VAR54, bytes32 VAR49) public {
VAR52 = VAR54;
emit FUN43(VAR49);
}
modifier FUN45(BaseWallet VAR3) {
require(msg.sender == address(VAR3), "");
VAR21;
}
modifier onlyOwner(BaseWallet VAR3) {
require(msg.sender == address(this) || FUN46(VAR3, msg.sender), "");
VAR21;
}
modifier FUN47(BaseWallet VAR3) {
require(FUN46(VAR3, msg.sender), "");
VAR21;
}
function FUN1(BaseWallet VAR3) external FUN45(VAR3) {
emit FUN44(VAR3);
}
function FUN2(BaseWallet VAR3, Module VAR4) external FUN47(VAR3) {
require(VAR52.FUN41(VAR4), "");
VAR3.FUN20(VAR4, true);
}
function FUN3(address VAR5) external {
uint VAR51 = FUN38(VAR5).FUN9(address(this));
FUN38(VAR5).transfer(address(VAR52), VAR51);
}
function FUN46(BaseWallet VAR3, address VAR55) internal view returns (bool) {
return VAR3.FUN48() == VAR55;
}
}
contract RelayerModule is VAR2 {
uint256 constant internal VAR56 = 10000;
mapping (address => VAR57) public VAR58;
struct VAR57 {
uint256 VAR59;
mapping (bytes32 => bool) VAR60;
}
event FUN49(address indexed VAR53, bool indexed VAR16, bytes32 VAR61);
modifier VAR62 {
require(msg.sender == address(this), "");
VAR21;
}
function FUN50(BaseWallet VAR3, bytes VAR39) internal view returns (uint256);
function FUN51(BaseWallet VAR3, bytes VAR39, bytes32 VAR63, bytes VAR64) internal view returns (bool);
function FUN52(
BaseWallet VAR3,
bytes VAR39,
uint256 VAR65,
bytes VAR64,
uint256 VAR66,
uint256 VAR67
)
external
returns (bool VAR16)
{
uint VAR68 = FUN53();
bytes32 VAR69 = FUN54(address(this), VAR3, 0, VAR39, VAR65, VAR66, VAR67);
require(FUN55(VAR3, VAR65, VAR69), "");
require(FUN56(address(VAR3), VAR39), "");
uint256 VAR70 = FUN50(VAR3, VAR39);
if((VAR70 * 65) == VAR64.VAR34) {
if(FUN57(VAR3, VAR67, VAR66, VAR70)) {
if(VAR70 == 0 || FUN51(VAR3, VAR39, VAR69, VAR64)) {
VAR16 = address(this).call(VAR39);
FUN58(VAR3, VAR68 - FUN53(), VAR66, VAR67, VAR70, msg.sender);
}
}
}
emit FUN49(VAR3, VAR16, VAR69);
}
function FUN59(BaseWallet VAR3) external view returns (uint256 VAR59) {
return VAR58[VAR3].VAR59;
}
function FUN54(
address VAR71,
address VAR72,
uint256 VAR36,
bytes VAR39,
uint256 VAR65,
uint256 VAR66,
uint256 VAR67
)
internal
pure
returns (bytes32)
{
return FUN60(
VAR73.FUN61(
"",
FUN60(VAR73.FUN61(FUN62(0x19), FUN62(0), VAR71, VAR72, VAR36, VAR39, VAR65, VAR66, VAR67))
));
}
function FUN55(BaseWallet VAR3, uint256 VAR65, bytes32 VAR63) internal returns (bool) {
if(VAR58[VAR3].VAR60[VAR63] == true) {
return false;
}
VAR58[VAR3].VAR60[VAR63] = true;
return true;
}
function FUN63(BaseWallet VAR3, uint256 VAR65) internal returns (bool) {
if(VAR65 <= VAR58[VAR3].VAR59) {
return false;
}
uint256 VAR74 = (VAR65 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;
if(VAR74 > VAR75.VAR76 + VAR56) {
return false;
}
VAR58[VAR3].VAR59 = VAR65;
return true;
}
function FUN64(bytes32 VAR77, bytes VAR64, uint VAR78) internal pure returns (address) {
uint8 VAR79;
bytes32 VAR80;
bytes32 VAR81;
VAR41 {
VAR80 := FUN65(FUN66(VAR64, FUN66(0x20,FUN67(0x41,VAR78))))
VAR81 := FUN65(FUN66(VAR64, FUN66(0x40,FUN67(0x41,VAR78))))
VAR79 := FUN68(FUN65(FUN66(VAR64, FUN66(0x41,FUN67(0x41,VAR78)))), 0xff)
}
require(VAR79 == 27 || VAR79 == 28);
return FUN69(VAR77, VAR79, VAR80, VAR81);
}
function FUN58(BaseWallet VAR3, uint VAR82, uint VAR66, uint VAR67, uint VAR64, address VAR83) internal {
uint256 VAR84 = 29292 + VAR82;
if(VAR66 > 0 && VAR64 > 1 && VAR84 <= VAR67) {
if(VAR66 > VAR85.VAR86) {
VAR84 = VAR84 * VAR85.VAR86;
}
else {
VAR84 = VAR84 * VAR66;
}
VAR3.FUN23(VAR83, VAR84, "");
}
}
function FUN57(BaseWallet VAR3, uint VAR82, uint VAR66, uint VAR64) internal view returns (bool) {
if(VAR66 > 0
&& VAR64 > 1
&& (address(VAR3).VAR11 < VAR82 * VAR66 || VAR3.FUN70(this) == false)) {
return false;
}
return true;
}
function FUN56(address VAR3, bytes VAR39) private pure returns (bool) {
require(VAR39.VAR34 >= 36, "");
address VAR87;
VAR41 {
VAR87 := FUN65(FUN66(VAR39, 0x24))
}
return VAR87 == VAR3;
}
function FUN71(bytes VAR39) internal pure returns (bytes4 VAR88) {
require(VAR39.VAR34 >= 4, "");
VAR41 {
VAR88 := FUN65(FUN66(VAR39, 0x20))
}
}
}
contract VAR89 {
modifier FUN72(BaseWallet VAR3) {
require(VAR3.FUN70(msg.sender), "");
VAR21;
}
}
contract GuardianStorage is VAR89 {
struct VAR90 {
address[] VAR91;
mapping (address => VAR92) VAR93;
uint256 VAR94;
address VAR95;
}
struct VAR92 {
bool VAR48;
uint128 VAR96;
}
mapping (address => VAR90) internal VAR97;
function FUN73(BaseWallet VAR3, address VAR98) external FUN72(VAR3) {
GuardianStorageConfig storage VAR99 = VAR97[VAR3];
VAR99.VAR93[VAR98].VAR48 = true;
VAR99.VAR93[VAR98].VAR96 = uint128(VAR99.VAR91.FUN74(VAR98) - 1);
}
function FUN75(BaseWallet VAR3, address VAR98) external FUN72(VAR3) {
GuardianStorageConfig storage VAR99 = VAR97[VAR3];
address VAR100 = VAR99.VAR91[VAR99.VAR91.VAR34 - 1];
if (VAR98 != VAR100) {
uint128 VAR101 = VAR99.VAR93[VAR98].VAR96;
VAR99.VAR91[VAR101] = VAR100;
VAR99.VAR93[VAR100].VAR96 = VAR101;
}
VAR99.VAR91.VAR34--;
delete VAR99.VAR93[VAR98];
}
function FUN76(BaseWallet VAR3) external view returns (uint256) {
return VAR97[VAR3].VAR91.VAR34;
}
function FUN77(BaseWallet VAR3) external view returns (address[]) {
GuardianStorageConfig storage VAR99 = VAR97[VAR3];
address[] memory VAR91 = new address[](VAR99.VAR91.VAR34);
for (uint256 VAR35 = 0; VAR35 < VAR99.VAR91.VAR34; VAR35++) {
VAR91[VAR35] = VAR99.VAR91[VAR35];
}
return VAR91;
}
function FUN78(BaseWallet VAR3, address VAR98) external view returns (bool) {
return VAR97[VAR3].VAR93[VAR98].VAR48;
}
function FUN79(BaseWallet VAR3, uint256 VAR102) external FUN72(VAR3) {
VAR97[VAR3].VAR94 = VAR102;
if(VAR102 != 0 && msg.sender != VAR97[VAR3].VAR95) {
VAR97[VAR3].VAR95 = msg.sender;
}
}
function FUN80(BaseWallet VAR3) external view returns (bool) {
return VAR97[VAR3].VAR94 > VAR103;
}
function FUN81(BaseWallet VAR3) external view returns (uint256) {
return VAR97[VAR3].VAR94;
}
function FUN82(BaseWallet VAR3) external view returns (address) {
return VAR97[VAR3].VAR95;
}
}
library VAR104 {
function FUN78(address[] VAR105, address VAR98) internal view returns (bool, address[]) {
if(VAR105.VAR34 == 0 || VAR98 == address(0)) {
return (false, VAR105);
}
bool VAR106 = false;
address[] memory VAR107 = new address[](VAR105.VAR34 - 1);
uint256 VAR96 = 0;
for (uint256 VAR35 = 0; VAR35 < VAR105.VAR34; VAR35++) {
if(!VAR106) {
if(VAR98 == VAR105[VAR35]) {
VAR106 = true;
continue;
}
if(FUN83(VAR105[VAR35]) && FUN84(VAR105[VAR35], VAR98)) {
VAR106 = true;
continue;
}
}
if(VAR96 < VAR107.VAR34) {
VAR107[VAR96] = VAR105[VAR35];
VAR96++;
}
}
return VAR106 ? (true, VAR107) : (false, VAR105);
}
function FUN83(address VAR55) internal view returns (bool) {
uint32 VAR108;
VAR41 {
VAR108 := FUN85(VAR55)
}
return (VAR108 > 0);
}
function FUN84(address VAR98, address VAR32) internal view returns (bool) {
address VAR19 = address(0);
bytes4 VAR40 = bytes4(FUN60(""));
VAR41 {
let VAR109 := FUN65(0x40)
FUN86(VAR109,VAR40)
let VAR42 := FUN26(5000, VAR98, VAR109, 0x20, VAR109, 0x20)
if FUN87(VAR42, 1) {
VAR19 := FUN65(VAR109)
}
}
return VAR19 == VAR32;
}
}
library VAR110 {
function FUN67(uint256 VAR111, uint256 VAR112) internal pure returns (uint256) {
if (VAR111 == 0) {
return 0;
}
uint256 VAR113 = VAR111 * VAR112;
require(VAR113 / VAR111 == VAR112);
return VAR113;
}
function FUN88(uint256 VAR111, uint256 VAR112) internal pure returns (uint256) {
require(VAR112 > 0);
uint256 VAR113 = VAR111 / VAR112;
return VAR113;
}
function FUN89(uint256 VAR111, uint256 VAR112) internal pure returns (uint256) {
require(VAR112 <= VAR111);
uint256 VAR113 = VAR111 - VAR112;
return VAR113;
}
function FUN66(uint256 VAR111, uint256 VAR112) internal pure returns (uint256) {
uint256 VAR113 = VAR111 + VAR112;
require(VAR113 >= VAR111);
return VAR113;
}
function FUN90(uint256 VAR111, uint256 VAR112) internal pure returns (uint256) {
require(VAR112 != 0);
return VAR111 % VAR112;
}
function FUN91(uint256 VAR111, uint256 VAR112) internal pure returns (uint256) {
uint256 VAR113 = VAR111 / VAR112;
if(VAR111 % VAR112 == 0) {
return VAR113;
}
else {
return VAR113 + 1;
}
}
}
contract ApprovedTransfer is VAR114, VAR115 {
bytes32 constant VAR116 = "";
address constant internal VAR117 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
GuardianStorage internal VAR118;
event FUN92(address VAR55);
event Transfer(address indexed VAR53, address indexed VAR119, uint256 indexed VAR84, address VAR14, bytes VAR30);
modifier FUN93(BaseWallet VAR3) {
require(!VAR118.FUN80(VAR3), "");
VAR21;
}
constructor(ModuleRegistry VAR54, GuardianStorage VAR120) FUN94(VAR54, VAR116) public {
VAR118 = VAR120;
}
function FUN95(
BaseWallet VAR3,
address VAR5,
address VAR72,
uint256 VAR121,
bytes VAR39
)
external
VAR62
FUN93(VAR3)
{
if(VAR5 == VAR117) {
VAR3.FUN23(VAR72, VAR121, VAR39);
emit Transfer(VAR3, VAR117, VAR121, VAR72, VAR39);
}
else {
bytes memory VAR122 = VAR73.FUN96("", VAR72, VAR121);
VAR3.FUN23(VAR5, 0, VAR122);
emit Transfer(VAR3, VAR5, VAR121, VAR72, VAR39);
}
}
function FUN51(BaseWallet VAR3, bytes VAR39, bytes32 VAR63, bytes VAR64) internal view returns (bool) {
address VAR123 = address(0);
address[] memory VAR91 = VAR118.FUN77(VAR3);
bool VAR124 = false;
for (uint8 VAR35 = 0; VAR35 < VAR64.VAR34 / 65; VAR35++) {
address VAR125 = FUN64(VAR63, VAR64, VAR35);
if(VAR35 == 0) {
if(!FUN46(VAR3, VAR125)) {
return false;
}
}
else {
if(VAR125 <= VAR123) {
return false;
}
VAR123 = VAR125;
(VAR124, VAR91) = VAR104.FUN78(VAR91, VAR125);
if(!VAR124) {
return false;
}
}
}
return true;
}
function FUN50(BaseWallet VAR3, bytes VAR39) internal view returns (uint256) {
return  1 + VAR110.FUN91(VAR118.FUN76(VAR3), 2);
}
}
1
---------------------------------
55 0x463f235748bc7862deaa04d85b4b16ac8fafef39.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) VAR3;
function FUN1()
public
returns(uint)
{
return VAR3[msg.sender];
}
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN2(address VAR7)
{
VAR6 = FUN3(VAR7);
}
function FUN4()
public
payable
{
if(msg.value >= VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN5(msg.sender,msg.value,"");
}
}
function FUN6(uint VAR8)
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN5(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN5(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN7(VAR16);
}
}
1
---------------------------------
56 0x464904238b5cdbdce12722a7e6014ec1c0b66928.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1() external payable returns(bool);
function FUN2() external view returns(address, address, bool);
function FUN3(address VAR3) external returns(bool);
function FUN4() external returns(bool);
function FUN5() external returns(bool);
function FUN6(address VAR4) external;
}
contract VAR5 {
JIincForwarderInterface private VAR6 = FUN7(0x0);
VAR7.Data private VAR8;
function FUN8(bytes32 VAR9) FUN9() public {VAR7.FUN10(VAR8, VAR9);}
function FUN11(bytes32 VAR9) FUN12() public view returns(bytes32 VAR10, uint256 VAR11) {return(VAR7.FUN13(VAR8, VAR9), VAR7.FUN14(VAR8, VAR9));}
function FUN15(bytes32 VAR9, uint256 VAR12, uint256 VAR13, uint256 VAR14) FUN12() public view returns(bytes32, bytes32, bytes32) {return(this.FUN16(VAR7.FUN17(VAR8, VAR9, VAR12)), this.FUN16(VAR7.FUN17(VAR8, VAR9, VAR13)), this.FUN16(VAR7.FUN17(VAR8, VAR9, VAR14)));}
struct VAR15 {
bool VAR16;
bool VAR17;
bytes32 VAR18;
}
mapping (address => VAR15) VAR19;
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
uint256 VAR23;
constructor()
public
{
address VAR24 = 0x18E90Fc6F70344f53EBd4f6070bf6Aa23e2D748C;
address VAR25   = 0x8b4DA1827932D71759687f925D17F81Fc94e3A9D;
address VAR26    = 0x8e0d985f3Ec1857BEc39B76aAabDEa6B31B67d53;
address VAR27  = 0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C;
address VAR28 = 0xF39e044e1AB204460e06E87c6dca2c6319fC69E3;
VAR19[VAR24] = FUN18(true, true, "");
VAR19[VAR25]   = FUN18(true, true, "");
VAR19[VAR26]    = FUN18(true, true, "");
VAR19[VAR27]  = FUN18(true, true, "");
VAR19[VAR28] = FUN18(true, true, "");
VAR20 = 5;
VAR21 = 5;
VAR22 = 1;
VAR23 = 1;
}
function ()
public
payable
{
VAR6.VAR29.value(address(this).VAR30)();
}
function FUN6(address VAR31)
FUN9()
public
{
require( address(VAR6) == address(0) );
VAR6 = FUN7(VAR31);
}
modifier FUN9()
{
require(VAR19[msg.sender].VAR17 == true, "");
VAR32;
}
modifier FUN12()
{
require(VAR19[msg.sender].VAR16 == true, "");
VAR32;
}
function FUN19(address VAR33, bytes32 VAR34, bool VAR35)
public
FUN9()
{
if (VAR7.FUN20(VAR8, VAR23, "") == true)
{
VAR7.FUN10(VAR8, "");
if (VAR19[VAR33].VAR16 == false)
{
VAR19[VAR33].VAR16 = true;
VAR20 += 1;
VAR22 += 1;
}
if (VAR35 == true)
{
VAR19[VAR33].VAR17 = VAR35;
VAR21 += 1;
VAR23 += 1;
}
}
VAR19[VAR33].VAR18 = VAR34;
}
function FUN21(address VAR33)
public
FUN9()
{
require(VAR20 > 1, "");
require(VAR20 >= VAR22, "");
if (VAR19[VAR33].VAR17 == true)
{
require(VAR21 > 1, "");
require(VAR21 >= VAR23, "");
}
if (VAR7.FUN20(VAR8, VAR23, "") == true)
{
VAR7.FUN10(VAR8, "");
if (VAR19[VAR33].VAR16 == true) {
VAR19[VAR33].VAR16 = false;
VAR20 -= 1;
if (VAR22 > 1)
{
VAR22 -= 1;
}
}
if (VAR19[VAR33].VAR17 == true) {
VAR19[VAR33].VAR17 = false;
VAR21 -= 1;
if (VAR23 > 1)
{
VAR23 -= 1;
}
}
}
}
function FUN22(uint256 VAR36)
public
FUN9()
{
require(VAR36 > 0 && VAR36 <= VAR20, "");
if (VAR7.FUN20(VAR8, VAR23, "") == true)
{
VAR7.FUN10(VAR8, "");
VAR22 = VAR36;
}
}
function FUN23(uint256 VAR36)
public
FUN9()
{
require(VAR36 > 0 && VAR36 <= VAR21, "");
if (VAR7.FUN20(VAR8, VAR23, "") == true)
{
VAR7.FUN10(VAR8, "");
VAR23 = VAR36;
}
}
function FUN24() external view returns(uint256) {return(VAR22);}
function FUN25() external view returns(uint256) {return(VAR23);}
function FUN26() external view returns(uint256) {return(VAR20);}
function FUN27() external view returns(uint256) {return(VAR21);}
function FUN16(address VAR33) external view returns(bytes32) {return(VAR19[VAR33].VAR18);}
function FUN28(address VAR33) external view returns(bool) {return(VAR19[VAR33].VAR16);}
function FUN29(address VAR33) external view returns(bool) {return(VAR19[VAR33].VAR17);}
}
library VAR7 {
struct VAR37
{
mapping (bytes32 => VAR38) VAR39;
}
struct VAR38
{
bytes32 VAR40;
uint256 VAR41;
mapping (address => bool) VAR42;
mapping (uint256 => address) VAR43;
}
function FUN20(Data storage VAR44, uint256 VAR45, bytes32 VAR9)
internal
returns(bool)
{
bytes32 VAR46 = FUN30(VAR9);
uint256 VAR47 = VAR44.VAR39[VAR46].VAR41;
address VAR48 = msg.sender;
bytes32 VAR49 = FUN31(msg.VAR50);
if (VAR47 == 0)
{
VAR44.VAR39[VAR46].VAR40 = VAR49;
VAR44.VAR39[VAR46].VAR42[VAR48] = true;
VAR44.VAR39[VAR46].VAR43[VAR47] = VAR48;
VAR44.VAR39[VAR46].VAR41 += 1;
if (VAR44.VAR39[VAR46].VAR41 == VAR45) {
return(true);
}
} else if (VAR44.VAR39[VAR46].VAR40 == VAR49) {
if (VAR44.VAR39[VAR46].VAR42[VAR48] == false)
{
VAR44.VAR39[VAR46].VAR42[VAR48] = true;
VAR44.VAR39[VAR46].VAR43[VAR47] = VAR48;
VAR44.VAR39[VAR46].VAR41 += 1;
}
if (VAR44.VAR39[VAR46].VAR41 == VAR45) {
return(true);
}
}
}
function FUN10(Data storage VAR44, bytes32 VAR9)
internal
{
bytes32 VAR46 = FUN30(VAR9);
address VAR48;
for (uint256 VAR51=0; VAR51 < VAR44.VAR39[VAR46].VAR41; VAR51++) {
VAR48 = VAR44.VAR39[VAR46].VAR43[VAR51];
delete VAR44.VAR39[VAR46].VAR42[VAR48];
delete VAR44.VAR39[VAR46].VAR43[VAR51];
}
delete VAR44.VAR39[VAR46];
}
function FUN30(bytes32 VAR9)
private
view
returns(bytes32)
{
return(FUN31(VAR52.FUN32(VAR9,this)));
}
function FUN13 (Data storage VAR44, bytes32 VAR9)
internal
view
returns (bytes32 VAR53)
{
bytes32 VAR46 = FUN30(VAR9);
return (VAR44.VAR39[VAR46].VAR40);
}
function FUN14 (Data storage VAR44, bytes32 VAR9)
internal
view
returns (uint256 VAR11)
{
bytes32 VAR46 = FUN30(VAR9);
return (VAR44.VAR39[VAR46].VAR41);
}
function FUN17 (Data storage VAR44, bytes32 VAR9, uint256 VAR54)
internal
view
returns (address VAR55)
{
require(VAR54 > 0, "");
bytes32 VAR46 = FUN30(VAR9);
return (VAR44.VAR39[VAR46].VAR43[VAR54 - 1]);
}
}
1
---------------------------------
57 0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
using SafeMath for uint;
struct VAR3 {
uint8 VAR4;
uint256 VAR5;
bool VAR6;
mapping (uint8 => address) VAR7;
mapping (address => bool) VAR8;
mapping (uint8 => address) VAR9;
}
HourglassInterface constant VAR10 = FUN1(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
SPASMInterface constant VAR11 = FUN2(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
uint256 constant private VAR12 = 0.005 VAR13;
uint8 constant public VAR14 = 2;
uint256 constant public VAR15 = 0.1 VAR13;
uint256 public VAR16;
uint256 public VAR17;
uint256 public VAR18;
mapping(address => uint256) public VAR19;
uint256 private VAR20 = VAR12 * (VAR14 - 1);
uint256 public VAR21 = 0.185 VAR13;
mapping(address => string) public VAR22;
mapping(address => uint256) private VAR23;
mapping(uint256 => VAR3) public VAR24;
mapping(uint256 => address) public VAR25;
mapping(uint256 => address) public VAR26;
uint256 public  VAR27;
uint256 public  VAR28;
uint256 private VAR29;
uint256 public VAR30;
event FUN3(address indexed VAR31, uint256 VAR32);
event FUN4(address indexed VAR33);
event FUN5(address indexed VAR34);
event FUN6(address indexed VAR33, uint256 indexed VAR35);
event FUN7(uint256 indexed VAR36);
function FUN8()
public
view
returns(address)
{
return (VAR26[VAR29]);
}
function FUN9()
public
view
returns(address)
{
return (VAR24[VAR29].VAR7[0]);
}
function FUN10()
public
view
returns(address)
{
return (VAR24[VAR29].VAR7[2]);
}
function FUN11()
public
view
returns( address )
{
return (VAR24[VAR30].VAR7[0]);
}
function FUN12()
public
view
returns( address )
{
return (VAR24[VAR30].VAR7[1]);
}
function FUN13(address VAR37)
public
view
returns( string )
{
return (VAR22[VAR37]);
}
function FUN14()
public
view
returns(uint256 VAR32 )
{
return (VAR17);
}
function FUN15()
public
view
returns(bool  )
{
bool VAR38;
if(VAR30 >= VAR29)
{
if(!VAR24[VAR29].VAR6 && VAR24[VAR29].VAR4 < VAR14 && VAR24[VAR29].VAR5 != 0)
{
VAR38 = true;
}
}
return (VAR38);
}
function FUN16()
public
view
returns(address)
{
return (VAR25[VAR27]);
}
function FUN17()
public
view
returns(uint256)
{
return (VAR10.FUN18(address(this)));
}
function FUN19(address VAR39) public
{
uint256 VAR40 = VAR19[VAR39];
VAR19[VAR39] = 0;
if(VAR39 == 0x0){VAR39 = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}
VAR10.VAR41.value(VAR40)(VAR39);
}
function FUN20 ()public
{
uint256 VAR42 = VAR10.FUN21(true);
require(VAR42 > 0);
uint256 VAR43 = VAR42.FUN22(100);
VAR10.FUN23();
VAR11.VAR44.value(VAR43)();
VAR16 = VAR16.FUN24(VAR43.FUN25(94));
VAR17 = VAR17.FUN24(VAR43.FUN25(5));
//
}
function FUN26 ()public payable
{
require(msg.value > 0);
VAR16 = VAR16.FUN24(msg.value);
}
function FUN27 ()public
{
uint256 VAR45 = VAR16;
require(VAR45 > 0.1 VAR13);
VAR16 -= 0.1 VAR13;
VAR25[VAR27].transfer(0.1 VAR13);
VAR27++;
//
}
function FUN28(string VAR46 , address VAR39) public payable
{
require(msg.value >= 1  VAR47);
VAR22[msg.sender] = VAR46;
uint256 VAR40 = VAR19[VAR39].FUN24(msg.value);
VAR19[VAR39] = 0;
if(VAR39 == 0x0){VAR39 = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}
VAR10.VAR41.value(VAR40)(VAR39);
}
modifier FUN29()
{
require(msg.value == VAR15);
VAR48;
}
modifier FUN30()
{
require(VAR23[msg.sender] >= VAR15);
VAR48;
}
modifier FUN31()
{
require(VAR23[msg.sender] > 0);
VAR48;
}
modifier FUN32()
{
if(VAR24[VAR30 - 1].VAR4 == VAR14) {
VAR24[VAR30] = FUN33(0, 0, false );
VAR30++;
}
VAR48;
}
modifier FUN34()
{
require(VAR24[VAR30 - 1].VAR8[msg.sender] == false);
VAR48;
}
constructor()
public
{
VAR24[VAR30] = FUN33(0, 0, false);
VAR30++;
}
function() external payable {}
function FUN35(address VAR49)
external
payable
VAR50
VAR51
VAR52
{
FUN36(VAR49);
FUN37();
}
function FUN38(address VAR49)
external
VAR53
VAR51
VAR52
{
VAR23[msg.sender] -= VAR15;
FUN36(VAR49);
FUN37();
}
function FUN23()
external
VAR54
{
FUN37();
uint256 VAR35 = VAR23[msg.sender];
VAR23[msg.sender] = 0;
emit FUN6(msg.sender, VAR35);
msg.sender.transfer(VAR35);
}
function FUN39()
external
view
VAR54
returns(uint256)
{
return VAR23[msg.sender];
}
function FUN40()
external
view
returns(uint256)
{
return VAR24[VAR30 - 1].VAR4;
}
function FUN36(address VAR49)
private
{
Stage storage VAR55 = VAR24[VAR30 - 1];
assert(VAR55.VAR4 < VAR14);
address VAR33 = msg.sender;
VAR55.VAR7[VAR55.VAR4] = VAR33;
VAR55.VAR4++;
VAR55.VAR8[VAR33] = true;
VAR55.VAR9[VAR55.VAR4] = VAR49;
emit FUN4(VAR33);
if(VAR55.VAR4 == VAR14) {
VAR55.VAR5 = VAR56.VAR57;
}
}
function FUN37()
public
{
assert(VAR30 >= VAR29);
if(VAR30 == VAR29) {return;}
Stage storage VAR58 = VAR24[VAR29];
assert(!VAR58.VAR6);
if(VAR58.VAR4 < VAR14) {return;}
assert(VAR58.VAR5 != 0);
if(VAR56.VAR57 - 256 <= VAR58.VAR5) {
if(VAR56.VAR57 == VAR58.VAR5) {return;}
uint8 VAR59 = uint8(FUN41(VAR58.VAR5)) % VAR14;
uint256 VAR60 = uint256(FUN41(VAR58.VAR5)) % 1000;
address VAR61 = VAR58.VAR7[VAR59];
VAR26[VAR29] = VAR61;
emit FUN5(VAR61);
FUN42(VAR61);
if(VAR60 == 777){
VAR61.transfer(VAR17);
emit FUN3 ( VAR61, VAR17);
VAR17 = 0;
}
VAR25[VAR28] = VAR61;
VAR28++;
VAR19[VAR58.VAR9[1]] = VAR19[VAR58.VAR9[1]].FUN24(0.005 VAR13);
VAR19[VAR58.VAR9[1]] = VAR19[VAR58.VAR9[2]].FUN24(0.005 VAR13);
VAR16 = VAR16.FUN24(0.005 VAR13);
} else {
FUN43(VAR29);
emit FUN7(VAR29);
}
VAR58.VAR6 = true;
VAR29++;
}
function FUN42(address VAR61)
private
{
for (uint8 VAR62 = 0; VAR62 < VAR14; VAR62++) {
address VAR63 = VAR24[VAR29].VAR7[VAR62];
if(VAR63 != VAR61) {
VAR23[VAR63] += VAR21;
}
}
}
function FUN43(uint256 VAR64)
private
{
Stage storage VAR65 = VAR24[VAR64];
for (uint8 VAR62 = 0; VAR62 < VAR14; VAR62++) {
address VAR33 = VAR65.VAR7[VAR62];
VAR23[VAR33] += VAR15;
}
}
}
interface VAR66 {
function FUN44(address VAR67) payable external returns(uint256);
function FUN23() external;
function FUN21(bool VAR68) external view returns(uint256);
function FUN18(address VAR67) external view returns(uint256);
}
interface VAR69  {
function() payable external;
function FUN45() external  payable;
}
library VAR70 {
function FUN24(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
VAR73 = VAR71 + VAR72;
require(VAR73 >= VAR71);
}
function FUN46(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
require(VAR72 <= VAR71);
VAR73 = VAR71 - VAR72;
}
function FUN25(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
VAR73 = VAR71 * VAR72;
require(VAR71 == 0 || VAR73 / VAR71 == VAR72);
}
function FUN22(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
require(VAR72 > 0);
VAR73 = VAR71 / VAR72;
}
}
1
---------------------------------
58 0x489e2685f9601b23c2316e87c6dbb30355a8a813.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract HubTokenInvestment is VAR2 {
address public VAR13 = 0xcc04AF825eEf340e99710D4366e3021F8d82F42A;
address public VAR14 = 0x212286e36Ae998FAd27b627EB326107B3aF1FeD4;
address public VAR15 = 0x515962688858eD980EB2Db2b6fA2802D9f620C6d;
uint public VAR16 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR17) internal {
uint VAR18 = VAR17 * 3 / 105;
uint VAR19 = VAR17 * 2 / 105;
require(VAR14.call.FUN9(VAR16).value(VAR18)());
require(VAR15.call.FUN9(VAR16).value(VAR19)());
uint VAR20 = VAR17 - VAR18 - VAR19;
require(VAR13.call.FUN9(VAR16).value(VAR20)());
}
function FUN10(uint VAR21) public onlyOwner {
VAR16 = VAR21;
}
function FUN11(EIP20Token VAR22, address VAR23, uint value) public onlyOwner {
VAR22.FUN5(VAR23, value);
}
function FUN12() public onlyOwner {
require(msg.sender.call.FUN9(VAR16).value(address(this).VAR24)());
}
}
1
---------------------------------
59 0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol
pragma VAR1 ^0.4.19;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address VAR8, address VAR9);
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;}
function FUN6() public {
VAR7 = msg.sender;
}
function FUN7(address VAR11) onlyOwner public {
address VAR8 = VAR7;
VAR7 = VAR11;
FUN5(VAR8, VAR7);
}
}
contract MontexToken is VAR6{
string public VAR12;
string public VAR13;
uint256 public VAR14;
uint256 public VAR15;
mapping (address => uint256) public VAR16;
event Transfer(address indexed VAR17, address indexed VAR18, uint256 value);
function FUN8() public{
VAR12 = "";
VAR13 = "";
VAR14 = 8;
VAR15 = 2e9 * 10**uint256(VAR14);
VAR16[msg.sender] = VAR15;
}
function transfer(address VAR19, uint256 VAR20) public{
if (VAR16[msg.sender] < VAR20) revert();
if (VAR16[VAR19] + VAR20 < VAR16[VAR19]) revert();
VAR16[msg.sender] -= VAR20;
VAR16[VAR19] += VAR20;
Transfer(msg.sender, VAR19, VAR20);
}
}
contract Crowdsale is VAR6 {
using SafeMath for uint256;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23;
uint256 public VAR24;
uint256 public VAR25;
uint256 public VAR26;
MontexToken public VAR27;
bool public VAR28 = false;
bool public VAR29;
mapping (address => VAR30) public VAR31;
struct VAR30 {
uint256 VAR32;
uint256 VAR33;
}
event FUN9(uint VAR21, uint VAR25, uint VAR23, address VAR34);
event FUN10(address VAR35, uint VAR36, uint VAR37, uint VAR24);
event FUN11(address VAR38, uint VAR36, bool VAR39);
event FUN12(address VAR38, uint VAR36, bool VAR39);
event FUN13(address VAR34, uint VAR21, uint VAR40, bool VAR41, uint VAR42);
modifier FUN14() { if (VAR43 >= VAR25) VAR10; }
function FUN15 (
uint VAR44,
uint VAR45,
uint VAR46,
MontexToken VAR47
) public {
VAR21 = VAR44 * 1 VAR48;
VAR22 = 1 VAR48 / VAR46;
VAR27 = FUN8(VAR47);
VAR23 = VAR45 * 10 ** uint256(8);
}
function () payable external{
if (!VAR29 || VAR43 >= VAR25) revert();
uint VAR36 = msg.value;
uint VAR49 = VAR36 * 1000;
uint VAR37 = (VAR49 / VAR22 * VAR26 / 1000) * 10 ** uint256(8);
if (VAR37 == 0 || VAR24 + VAR37 > VAR23) revert();
VAR31[msg.sender].VAR32 += VAR36 / 10 ** uint256(8);
VAR31[msg.sender].VAR33 += VAR37;
VAR24 += VAR37;
VAR27.transfer(msg.sender, VAR37);
FUN10(msg.sender, VAR36, VAR37,VAR24);
}
function FUN16(uint VAR50,uint VAR51,uint VAR52) onlyOwner public{
VAR25 = VAR51;
VAR26 = VAR52;
if (VAR21 == 0 || VAR23 == 0 ||
VAR27 == address(0) ||  VAR50 >= VAR43)
{
revert();
}
if (VAR27.FUN17(this) >= VAR23) {
if(VAR50 <= VAR43 && VAR43 <= VAR25){
VAR29 = true;
FUN9(VAR21, VAR25, VAR23, VAR7);
}
}
}
function FUN18(address VAR53) public
constant returns(uint VAR54,uint VAR55)
{
VAR54 = VAR31[VAR53].VAR32 * (1 VAR48) / 10 ** uint256(8);
VAR55 = VAR31[VAR53].VAR33;
}
function FUN19(uint VAR56) public
view returns(uint VAR57,uint VAR58)
{
VAR57 = VAR26;
VAR58 = VAR56 * VAR57;
}
function FUN20() public
constant returns(
uint VAR59,
uint VAR60,
uint VAR61,
uint VAR62,
uint VAR63,
uint VAR64,
uint VAR65,
uint VAR66,
uint VAR67,
uint VAR68,
uint VAR69)
{
if(VAR43 < VAR25) {
VAR61 = (VAR25 - VAR43) / (1 VAR70);
VAR62 = (VAR25 - VAR43) / (1 VAR71);
VAR63 = (VAR25 - VAR43) / (1 VAR72);
VAR66 = (VAR25 - VAR43) / (1 VAR73);
VAR59 = VAR43;
VAR60 = VAR25;
}
VAR64 = (VAR21 - this.VAR74) / (1 VAR48);
VAR65 = VAR23 - VAR24;
VAR67 = this.VAR74 / (1 VAR48);
VAR68 = VAR27.FUN17(this);
VAR69 = VAR23;
}
function FUN21() onlyOwner public {
if (this.VAR74 >= VAR21) {
VAR28 = true;
}
if(VAR29==true){
VAR29 = false;
uint VAR75 = VAR23 - VAR24;
if (VAR75 > 0) {
VAR27.transfer(msg.sender, VAR23 - VAR24);
FUN11(msg.sender, VAR75, true);
}
}
FUN13(VAR7, VAR21, this.VAR74, VAR28, VAR24);
}
function FUN22() onlyOwner public{
uint VAR36 = this.VAR74;
if (VAR36 > 0) {
bool VAR76 = msg.sender.call.value(VAR36)();
FUN12(msg.sender, VAR36, VAR76);
}
}
}
1
---------------------------------
60 0x49edf201c1e139282643d5e7c6fb0c7219ad1db7.sol
pragma VAR1 >=0.4.4;
contract VAR2 {
uint public VAR3;
uint public VAR4;
uint public VAR5;
uint public VAR6;
uint public VAR7;
uint public VAR8;
mapping(address => uint) public VAR9;
function FUN1(address VAR10, uint VAR11, uint VAR12) returns (uint);
function FUN2(address VAR13) constant returns (uint);
function FUN3(address VAR13) constant returns (uint);
function FUN4() constant returns (uint);
function FUN5() constant returns (uint);
function FUN6() constant returns (uint);
function FUN7(uint VAR14) constant returns (bool);
function FUN8(uint VAR14) constant returns (bool);
}
contract VAR15 {
uint VAR16 = 8;
}
contract VAR17 {
event FUN9(uint VAR3, uint VAR4);
event FUN10(address indexed VAR18, uint VAR19);
event FUN11(address indexed VAR18, uint VAR20, uint VAR21);
event Transfer(address indexed VAR22, address indexed VAR23, uint value);
event FUN12(address indexed VAR24, address indexed VAR25, uint value);
}
contract VAR26 {
uint VAR27;
bool public VAR28;
modifier FUN13() {
if (!VAR28) throw;
VAR29;
}
function FUN14(uint VAR30) VAR31 {
VAR27 = VAR30;
}
function FUN15(uint VAR32) VAR31 {
VAR27 = VAR27 + (VAR32 * 1 VAR33);
}
function FUN16(uint VAR34) VAR31 {
VAR27 = VAR27 + (VAR34 * 1 VAR35);
}
function FUN17() constant returns (uint) {
if (VAR28) {
return VAR27;
} else {
return VAR36.VAR37;
}
}
function FUN18() constant returns (uint) {
if (VAR28) {
return 200;
} else {
return 10**18;
}
}
}
contract VAR38 {
address public VAR24;
modifier onlyOwner() {
if (msg.sender != VAR24) throw;
VAR29;
}
address VAR39;
function FUN19(address VAR40) onlyOwner {
VAR39 = VAR40;
}
function FUN20() {
if (msg.sender == VAR39) {
VAR24 = VAR39;
}
}
}
contract VAR41 {
function FUN21(uint VAR42, uint VAR43) internal returns (uint) {
uint VAR44 = VAR42 * VAR43;
assert(VAR42 == 0 || VAR44 / VAR42 == VAR43);
return VAR44;
}
function FUN22(uint VAR42, uint VAR43) internal returns (uint) {
assert(VAR43 <= VAR42);
return VAR42 - VAR43;
}
function FUN23(uint VAR42, uint VAR43) internal returns (uint) {
uint VAR44 = VAR42 + VAR43;
assert(VAR44>=VAR42 && VAR44>=VAR43);
return VAR44;
}
function assert(bool VAR45) internal {
if (!VAR45) throw;
}
}
contract Token is VAR41, VAR38, VAR15 {
uint public VAR46;
address VAR47;
address VAR48;
string public VAR49;
uint8 public VAR50;
string public VAR51;
modifier FUN24() {
if (msg.sender != VAR47 &&
msg.sender != VAR48) throw;
VAR29;
}
modifier FUN25(uint VAR52) {
assert(msg.VAR53.VAR54 == VAR52 * 32 + 4);
VAR29;
}
function FUN26() {
VAR24 = msg.sender;
VAR49 = "";
VAR50 = uint8(VAR16);
VAR51 = "";
}
function FUN27(address VAR55) onlyOwner {
if (VAR47 != 0) throw;
VAR47 = VAR55;
}
function FUN28(address VAR56) onlyOwner {
if (VAR48 != 0) throw;
VAR48 = VAR56;
}
event Transfer(address indexed VAR22, address indexed VAR23, uint value);
event FUN12(address indexed VAR24, address indexed VAR25, uint value);
event FUN29(address VAR24, uint VAR57);
function FUN30(address VAR58, uint VAR57) VAR59 {
if (VAR60 > 0 && FUN23(VAR46, VAR57) > VAR60) throw;
VAR61[VAR58] = FUN23(VAR61[VAR58], VAR57);
VAR46 = FUN23(VAR46, VAR57);
FUN29(VAR58, VAR57);
}
mapping(address => uint) public VAR61;
mapping (address => mapping (address => uint)) public VAR62;
function transfer(address VAR63, uint VAR64)
FUN25(2)
returns (bool VAR65) {
if (VAR61[msg.sender] < VAR64) return false;
VAR61[msg.sender] = VAR61[msg.sender] - VAR64;
VAR61[VAR63] = FUN23(VAR61[VAR63], VAR64);
Transfer(msg.sender, VAR63, VAR64);
return true;
}
function FUN31(address VAR66, address VAR63, uint VAR64)
FUN25(3)
returns (bool VAR65) {
if (VAR61[VAR66] < VAR64) return false;
var VAR67 = VAR62[VAR66][msg.sender];
if (VAR67 < VAR64) return false;
VAR61[VAR63] = FUN23(VAR61[VAR63], VAR64);
VAR61[VAR66] = FUN22(VAR61[VAR66], VAR64);
VAR62[VAR66][msg.sender] = FUN22(VAR67, VAR64);
Transfer(VAR66, VAR63, VAR64);
return true;
}
function FUN32(address VAR68, uint VAR64)
FUN25(2)
returns (bool VAR65) {
if ((VAR64 != 0) && (VAR62[msg.sender][VAR68] != 0)) {
return false;
}
VAR62[msg.sender][VAR68] = VAR64;
FUN12(msg.sender, VAR68, VAR64);
return true;
}
function FUN33 (address VAR68, uint VAR69)
FUN25(2)
returns (bool VAR65) {
uint VAR70 = VAR62[msg.sender][VAR68];
VAR62[msg.sender][VAR68] = FUN23(VAR70, VAR69);
return true;
}
function FUN34 (address VAR68, uint VAR71)
FUN25(2)
returns (bool VAR65) {
uint VAR70 = VAR62[msg.sender][VAR68];
if (VAR71 > VAR70) {
VAR62[msg.sender][VAR68] = 0;
} else {
VAR62[msg.sender][VAR68] = FUN22(VAR70, VAR71);
}
return true;
}
TokenHolder VAR72;
bool VAR73;
function FUN35() onlyOwner {
VAR73 = true;
}
function FUN36(address VAR74) onlyOwner {
if (VAR73) throw;
VAR72 = FUN37(VAR74);
}
event FUN38(address VAR75, uint VAR57);
function FUN39(uint VAR76) returns (bool VAR77) {
if (VAR76 > VAR61[msg.sender]) return false;
VAR61[msg.sender] = FUN22(VAR61[msg.sender], VAR76);
VAR46 = FUN22(VAR46, VAR76);
VAR77 = VAR72.FUN39(msg.sender, VAR76);
if (!VAR77) throw;
FUN38(msg.sender, VAR76);
}
uint public VAR60;
function FUN40(uint VAR78) {
if (msg.sender != VAR48) throw;
if (VAR60 > 0) throw;
VAR60 = VAR78;
}
}
contract VAR79 {
function FUN39(address VAR80, uint VAR76)
returns (bool VAR77) {
return false;
}
}
contract ICO is VAR17, VAR26, VAR41, VAR38 {
Token public VAR81;
address public VAR48;
address public VAR82;
VAR2[] public VAR83;
mapping (uint => uint) VAR84;
mapping (address => uint) public VAR85;
mapping (address => uint) VAR86;
modifier FUN41() {
if (address(VAR81) == 0) throw;
VAR29;
}
modifier FUN42() {
if (msg.sender != address(VAR48)) throw;
VAR29;
}
function FUN43() {
VAR24 = msg.sender;
VAR82 = msg.sender;
VAR87 = msg.sender;
}
function FUN44(address VAR88)
onlyOwner VAR89 {
VAR82 = VAR88;
}
function FUN45(address VAR90) onlyOwner {
if (address(VAR81) != 0x0) throw;
VAR81 = FUN26(VAR90);
}
function FUN46() onlyOwner {
if (VAR83.VAR54 == 0) {
VAR28 = true;
}
}
function FUN28(address VAR56)
onlyOwner VAR89 {
if (address(VAR48) != 0x0) throw;
VAR48 = VAR56;
}
function FUN47(address VAR91, uint VAR92)
onlyController VAR89 {
uint VAR93 = VAR83.VAR54;
VAR83.FUN48(FUN49(VAR91));
VAR84[VAR93] = VAR92;
FUN9(FUN49(VAR91).FUN50(), FUN49(VAR91).FUN51());
}
function FUN47(address VAR91) VAR94 {
FUN47(VAR91, 0);
}
function FUN52() constant returns (uint) {
if (VAR83.VAR54 == 0) throw;
return VAR83.VAR54 - 1;
}
function FUN53() constant returns (bool) {
return VAR83[FUN52()].FUN7(FUN17());
}
function FUN54() constant returns (bool) {
return VAR83[FUN52()].FUN8(FUN17());
}
function FUN55() constant returns (uint) {
return VAR83.VAR54;
}
function FUN56(uint VAR93) constant returns (uint) {
return VAR83[VAR93].FUN56();
}
event FUN10(address indexed VAR18, uint value);
function () payable {
FUN57();
}
function FUN57() payable VAR89 {
FUN58(msg.sender, msg.value);
uint VAR95 = VAR86[msg.sender];
VAR86[msg.sender] = VAR95 + msg.value;
FUN10(msg.sender, msg.value);
}
function FUN58(address VAR96, uint VAR64) private {
uint VAR97 = FUN52();
if (!FUN53()) throw;
if (VAR64 < VAR84[VAR97]) throw;
uint VAR98 = VAR83[VAR97].FUN1(VAR96, VAR64, FUN17());
if (VAR98 > 0) {
VAR81.FUN30(VAR96, VAR98);
}
}
event FUN59(
address indexed VAR18, address indexed VAR81,
uint VAR99, uint VAR100,
bytes32 VAR101);
event FUN60(
address indexed VAR18, uint VAR100,
bytes32 VAR101);
mapping (bytes32 => bool) public VAR102;
mapping (address => uint) public VAR103;
uint public VAR104;
function FUN61(address VAR96, uint VAR105, bytes32 VAR101)
notAllStopped onlyOwner {
if (FUN52() > 0) throw;
if (VAR102[VAR101]) throw;
VAR102[VAR101] = true;
VAR104 = FUN23(VAR104, VAR105);
FUN58(VAR96, VAR105);
FUN60(VAR96, VAR105, VAR101);
}
function FUN62(address VAR96, address VAR90,
uint VAR105, uint VAR106,
bytes32 VAR101)
notAllStopped onlyOwner {
if (FUN52() > 0) throw;
if (VAR102[VAR101]) throw;
VAR102[VAR101] = true;
VAR103[VAR90] = FUN23(VAR103[VAR90], VAR105);
uint VAR107 = VAR83[0].FUN6();
uint VAR108 = FUN21(VAR105, VAR107) / FUN18();
VAR81.FUN30(VAR96, VAR108);
FUN59(VAR96, VAR90, VAR106, VAR105, VAR101);
}
function FUN63(uint VAR109) private returns (uint) {
if (VAR109 > this.VAR110) {
return this.VAR110;
} else {
return VAR109;
}
}
uint public VAR111;
function FUN64() payable onlyOwner VAR89 {
VAR111 = FUN23(VAR111, msg.value);
}
function FUN65() onlyOwner VAR89 {
uint VAR57 = VAR111;
VAR111 = 0;
if (!msg.sender.call.value(FUN63(VAR57))()) throw;
}
function FUN66() VAR89 {
FUN67 (VAR21, VAR20, VAR112) = FUN68(msg.sender, true);
VAR85[msg.sender] = VAR112;
FUN11(msg.sender, VAR20, VAR21);
if (VAR21 > 0) {
VAR81.FUN30(msg.sender, VAR21);
}
if (VAR20 > 0) {
VAR86[msg.sender] = FUN22(VAR86[msg.sender], VAR20);
if (!msg.sender.FUN69(FUN63(VAR20))) throw;
}
}
function FUN70(address VAR66, address VAR63)
onlyOwner VAR89 {
FUN67 (VAR21, VAR20, VAR112) = FUN68(VAR66, false);
VAR85[VAR66] = VAR112;
FUN11(VAR66, VAR20, VAR21);
if (VAR21 > 0) {
VAR81.FUN30(VAR63, VAR21);
}
if (VAR20 > 0) {
VAR86[VAR66] = FUN22(VAR86[VAR66], VAR20);
if (!VAR63.FUN69(FUN63(VAR20))) throw;
}
}
function FUN68(address VAR10, bool VAR113)
constant private VAR114
returns (uint VAR21, uint VAR20, uint VAR112) {
VAR112 = VAR85[VAR10];
while (VAR112 < VAR83.VAR54 &&
VAR83[VAR112].FUN8(FUN17()) &&
( VAR113 ||
VAR83[VAR112].FUN51() + 1 VAR115 < FUN17() ))
{
VAR20 = FUN23(VAR20, VAR83[VAR112].FUN3(VAR10));
VAR21 = FUN23(VAR21, VAR83[VAR112].FUN2(VAR10));
VAR112 += 1;
}
}
function FUN71(address VAR42) constant returns (uint) {
FUN67 (VAR21, VAR20, VAR112) = FUN68(VAR42, true);
return VAR21;
}
function FUN72(address VAR42) constant returns (uint) {
FUN67 (VAR21, VAR20, VAR112) = FUN68(VAR42, true);
return VAR20;
}
function FUN71() constant returns (uint) {
return FUN71(msg.sender);
}
function FUN72() constant returns (uint) {
return FUN72(msg.sender);
}
mapping (uint => bool) VAR116;
function FUN73(uint VAR93) constant returns (uint) {
uint VAR14 = FUN17();
if (!VAR83[VAR93].FUN8(VAR14)) return 0;
return VAR83[VAR93].FUN5();
}
function FUN74(uint VAR93) onlyOwner VAR89 {
if (VAR116[VAR93]) throw;
uint VAR117 = FUN73(VAR93);
if (VAR117 > 0) {
VAR116[VAR93] = true;
if ( !VAR82.call.value(FUN63(VAR117))() ) throw;
}
}
event FUN75(address VAR81, address VAR23, uint VAR57);
function FUN76(address VAR90, address VAR63) onlyOwner {
Token VAR81 = FUN26(VAR90);
uint VAR110 = VAR81.FUN77(this);
VAR81.transfer(VAR63, VAR110);
FUN75(VAR90, VAR63, VAR110);
}
bool VAR118;
bool VAR119;
address VAR87;
function FUN78(address VAR10) onlyOwner {
if (VAR87 != VAR24) return;
VAR87 = VAR10;
}
modifier FUN79() {
if (msg.sender != VAR87) throw;
VAR29;
}
event FUN80();
event FUN81();
modifier FUN82() {
if (!VAR118) throw;
VAR29;
}
modifier FUN83() {
if (VAR118) throw;
VAR29;
}
function FUN84() VAR120 {
VAR118 = true;
FUN80();
}
function FUN85() VAR120 {
if (!VAR119) {
VAR118 = false;
FUN81();
}
}
function FUN86(address VAR10, uint VAR121)
VAR122
VAR120 {
VAR119 = true;
uint VAR123 = VAR121;
uint VAR124 = VAR86[VAR10];
if (VAR123 == 0) VAR123 = VAR124;
if (VAR123 > VAR124) VAR123 = VAR124;
if ( !VAR10.call.value(FUN63(VAR123))() ) throw;
}
function FUN87() constant returns (uint) {
return VAR83[FUN52()].FUN87();
}
function FUN6() constant returns (uint) {
return VAR83[FUN52()].FUN6();
}
}
1
---------------------------------
61 0x4a3e0c60f7fa67e8b65c401ddbbf7c17fea5fe40.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) external payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) external payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) public payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) external payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) public payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) external payable returns (bytes32 VAR7);
function FUN7(string VAR5) public returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) public returns (uint VAR12);
function FUN8(byte VAR14) external;
function FUN9(uint VAR15) external;
function FUN10() external constant returns(bytes32);
}
contract VAR16 {
function FUN11() public returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x20;
byte constant VAR25 = 0x30;
byte constant VAR26 = 0xF0;
byte constant VAR27 = 0x01;
uint8 constant VAR28 = 0;
uint8 constant VAR29 = 1;
uint8 constant VAR30 = 2;
uint8 constant VAR31 = 2;
uint8 constant VAR32 = 161;
OraclizeAddrResolverI VAR33;
OraclizeI VAR34;
modifier VAR35 {
if((address(VAR33)==0)||(FUN12(address(VAR33))==0))
FUN13(VAR28);
if(address(VAR34) != VAR33.FUN11())
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
modifier FUN15(string VAR37){
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
function FUN13(uint8 VAR38) internal returns(bool){
return FUN13();
VAR38;
}
function FUN13() internal returns(bool){
if (FUN12(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR33 = FUN16(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN17("");
return true;
}
if (FUN12(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR33 = FUN16(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN17("");
return true;
}
if (FUN12(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR33 = FUN16(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN17("");
return true;
}
if (FUN12(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR33 = FUN16(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN17("");
return true;
}
if (FUN12(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR33 = FUN16(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN12(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR33 = FUN16(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN12(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR33 = FUN16(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN18(bytes32 VAR39, string VAR40) public {
FUN18(VAR39, VAR40, VAR41 bytes(0));
}
function FUN18(bytes32 VAR39, string VAR40, bytes VAR42) public {
return;
VAR39; VAR40; VAR42;
}
function FUN19(string VAR43) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43);
}
function FUN19(string VAR43, uint VAR13) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43, VAR13);
}
function FUN20(string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(0, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(VAR51, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(VAR51, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(0, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(0, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(VAR51, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(VAR51, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(0, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN23() oraclizeAPI internal returns (address){
return VAR34.FUN24();
}
function FUN25(byte VAR62) oraclizeAPI internal {
return VAR34.FUN8(VAR62);
}
function FUN26(uint VAR63) oraclizeAPI internal {
return VAR34.FUN9(VAR63);
}
function FUN27() oraclizeAPI internal returns (bytes32){
return VAR34.FUN10();
}
function FUN12(address VAR17) constant internal returns(uint VAR64) {
VAR65 {
VAR64 := FUN28(VAR17)
}
}
function FUN29(string VAR66) internal pure returns (address){
bytes memory VAR67 = bytes(VAR66);
uint160 VAR68 = 0;
uint160 VAR69;
uint160 VAR70;
for (uint VAR71=2; VAR71<2+2*20; VAR71+=2){
VAR68 *= 256;
VAR69 = FUN30(VAR67[VAR71]);
VAR70 = FUN30(VAR67[VAR71+1]);
if ((VAR69 >= 97)&&(VAR69 <= 102)) VAR69 -= 87;
else if ((VAR69 >= 65)&&(VAR69 <= 70)) VAR69 -= 55;
else if ((VAR69 >= 48)&&(VAR69 <= 57)) VAR69 -= 48;
if ((VAR70 >= 97)&&(VAR70 <= 102)) VAR70 -= 87;
else if ((VAR70 >= 65)&&(VAR70 <= 70)) VAR70 -= 55;
else if ((VAR70 >= 48)&&(VAR70 <= 57)) VAR70 -= 48;
VAR68 += (VAR69*16+VAR70);
}
return address(VAR68);
}
function FUN31(string VAR66, string VAR72) internal pure returns (int) {
bytes memory VAR73 = bytes(VAR66);
bytes memory VAR74 = bytes(VAR72);
uint VAR75 = VAR73.VAR76;
if (VAR74.VAR76 < VAR75) VAR75 = VAR74.VAR76;
for (uint VAR71 = 0; VAR71 < VAR75; VAR71 ++)
if (VAR73[VAR71] < VAR74[VAR71])
return -1;
else if (VAR73[VAR71] > VAR74[VAR71])
return 1;
if (VAR73.VAR76 < VAR74.VAR76)
return -1;
else if (VAR73.VAR76 > VAR74.VAR76)
return 1;
else
return 0;
}
function FUN32(string VAR77, string VAR78) internal pure returns (int) {
bytes memory VAR79 = bytes(VAR77);
bytes memory VAR80 = bytes(VAR78);
if(VAR79.VAR76 < 1 || VAR80.VAR76 < 1 || (VAR80.VAR76 > VAR79.VAR76))
return -1;
else if(VAR79.VAR76 > (2**128 -1))
return -1;
else
{
uint VAR81 = 0;
for (uint VAR71 = 0; VAR71 < VAR79.VAR76; VAR71 ++)
{
if (VAR79[VAR71] == VAR80[0])
{
VAR81 = 1;
while(VAR81 < VAR80.VAR76 && (VAR71 + VAR81) < VAR79.VAR76 && VAR79[VAR71 + VAR81] == VAR80[VAR81])
{
VAR81++;
}
if(VAR81 == VAR80.VAR76)
return int(VAR71);
}
}
return -1;
}
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83, string VAR84) internal pure returns (string) {
bytes memory VAR85 = bytes(VAR66);
bytes memory VAR86 = bytes(VAR72);
bytes memory VAR87 = bytes(VAR82);
bytes memory VAR88 = bytes(VAR83);
bytes memory VAR89 = bytes(VAR84);
string memory VAR90 = VAR41 string(VAR85.VAR76 + VAR86.VAR76 + VAR87.VAR76 + VAR88.VAR76 + VAR89.VAR76);
bytes memory VAR91 = bytes(VAR90);
uint VAR92 = 0;
for (uint VAR71 = 0; VAR71 < VAR85.VAR76; VAR71++) VAR91[VAR92++] = VAR85[VAR71];
for (VAR71 = 0; VAR71 < VAR86.VAR76; VAR71++) VAR91[VAR92++] = VAR86[VAR71];
for (VAR71 = 0; VAR71 < VAR87.VAR76; VAR71++) VAR91[VAR92++] = VAR87[VAR71];
for (VAR71 = 0; VAR71 < VAR88.VAR76; VAR71++) VAR91[VAR92++] = VAR88[VAR71];
for (VAR71 = 0; VAR71 < VAR89.VAR76; VAR71++) VAR91[VAR92++] = VAR89[VAR71];
return string(VAR91);
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, VAR83, "");
}
function FUN33(string VAR66, string VAR72, string VAR82) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, "", "");
}
function FUN33(string VAR66, string VAR72) internal pure returns (string) {
return FUN33(VAR66, VAR72, "", "", "");
}
function FUN34(string VAR66) internal pure returns (uint) {
return FUN34(VAR66, 0);
}
function FUN34(string VAR66, uint VAR72) internal pure returns (uint) {
bytes memory VAR93 = bytes(VAR66);
uint VAR94 = 0;
bool VAR95 = false;
for (uint VAR71=0; VAR71<VAR93.VAR76; VAR71++){
if ((VAR93[VAR71] >= 48)&&(VAR93[VAR71] <= 57)){
if (VAR95){
if (VAR72 == 0) break;
else VAR72--;
}
VAR94 *= 10;
VAR94 += uint(VAR93[VAR71]) - 48;
} else if (VAR93[VAR71] == 46) VAR95 = true;
}
if (VAR72 > 0) VAR94 *= 10**VAR72;
return VAR94;
}
function FUN35(uint VAR71) internal pure returns (string){
if (VAR71 == 0) return "";
uint VAR96 = VAR71;
uint VAR97;
while (VAR96 != 0){
VAR97++;
VAR96 /= 10;
}
bytes memory VAR98 = VAR41 bytes(VAR97);
uint VAR92 = VAR97 - 1;
while (VAR71 != 0){
VAR98[VAR92--] = FUN36(48 + VAR71 % 10);
VAR71 /= 10;
}
return string(VAR98);
}
function FUN21(string[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
function FUN22(bytes[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
string VAR109;
function FUN17(string VAR110) internal {
VAR109 = VAR110;
}
function FUN37() internal view returns (string) {
return VAR109;
}
function FUN38(uint VAR111, uint VAR112, uint VAR113) internal returns (bytes32){
require((VAR112 > 0) && (VAR112 <= 32));
VAR111 *= 10;
bytes memory VAR114 = VAR41 bytes(1);
VAR114[0] = FUN36(VAR112);
bytes memory VAR115 = VAR41 bytes(32);
bytes memory VAR116 = VAR41 bytes(32);
bytes32 VAR117 = FUN27();
VAR65 {
FUN39(VAR115, 0x20)
FUN39(FUN40(VAR115, 0x20), FUN41(FUN42(FUN43(VAR118, 1)), FUN41(VAR119, VAR51)))
FUN39(VAR116, 0x20)
FUN39(FUN40(VAR116, 0x20), VAR117)
}
bytes memory VAR120 = VAR41 bytes(32);
VAR65 {
FUN39(FUN40(VAR120, 0x20), VAR111)
}
bytes memory VAR121 = VAR41 bytes(8);
FUN44(VAR120, 24, 8, VAR121, 0);
bytes[4] memory VAR58 = [VAR115, VAR114, VAR116, VAR120];
bytes32 VAR122 = FUN20("", VAR58, VAR113);
bytes memory VAR123 = VAR41 bytes(8);
VAR65 {
let VAR106 := FUN45(FUN40(VAR121, 0x20))
FUN46(FUN40(VAR123, 0x27), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x26), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x25), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x24), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x23), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x22), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x21), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x20), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000))
}
FUN48(VAR122, FUN49(VAR123, VAR58[1], FUN50(VAR58[0]), VAR58[2]));
return VAR122;
}
function FUN48(bytes32 VAR122, bytes32 VAR124) internal {
VAR125[VAR122] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN51(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR41 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN44(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR41 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN44(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR65 {
VAR132 := FUN45(FUN40(VAR134, 32))
VAR133 := FUN45(FUN40(VAR136, 32))
}
(VAR130, VAR131) = FUN52(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN52(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN53(bytes VAR42, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR41 bytes(uint(VAR42[VAR137+1])+2);
FUN44(VAR42, VAR137, VAR138.VAR76, VAR138, 0);
bytes memory VAR139 = VAR41 bytes(64);
FUN44(VAR42, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR41 bytes(1+65+32);
VAR140[0] = FUN36(1);
FUN44(VAR42, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN44(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN51(FUN50(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR41 bytes(1+65);
VAR144[0] = 0xFE;
FUN44(VAR42, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR41 bytes(uint(VAR42[3+65+1])+2);
FUN44(VAR42, 3+65, VAR145.VAR76, VAR145, 0);
VAR130 = FUN51(FUN50(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN54(bytes32 VAR146, string VAR147, bytes VAR148) {
require((VAR148[0] == "") && (VAR148[1] == "") && (VAR148[2] == 1));
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
require(VAR149);
VAR36;
}
function FUN56(bytes32 VAR146, string VAR147, bytes VAR148) internal returns (uint8){
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) return 1;
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
if (VAR149 == false) return 2;
return 0;
}
function FUN57(bytes32 VAR150, bytes VAR151, uint VAR152) internal pure returns (bool){
bool VAR153 = true;
require(VAR151.VAR76 == VAR152);
for (uint256 VAR71=0; VAR71< VAR152; VAR71++) {
if (VAR150[VAR71] != VAR151[VAR71]) VAR153 = false;
}
return VAR153;
}
function FUN55(bytes VAR42, bytes32 VAR122, bytes VAR40, string VAR154) internal returns (bool){
uint VAR155 = 3+65+(uint(VAR42[3+65+1])+2)+32;
bytes memory VAR156 = VAR41 bytes(32);
FUN44(VAR42, VAR155, 32, VAR156, 0);
if (!(FUN49(VAR156) == FUN49(FUN50(VAR154, VAR122)))) return false;
bytes memory VAR157 = VAR41 bytes(uint(VAR42[VAR155+(32+8+1+32)+1])+2);
FUN44(VAR42, VAR155+(32+8+1+32), VAR157.VAR76, VAR157, 0);
if (!FUN57(FUN50(VAR157), VAR40, uint(VAR42[VAR155+32+8]))) return false;
bytes memory VAR158 = VAR41 bytes(8+1+32);
FUN44(VAR42, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR41 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR76+65;
FUN44(VAR42, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN50(VAR159);
if (VAR125[VAR122] == FUN49(VAR158, VAR160)){
delete VAR125[VAR122];
} else return false;
bytes memory VAR161 = VAR41 bytes(32+8+1+32);
FUN44(VAR42, VAR155, 32+8+1+32, VAR161, 0);
if (!FUN51(FUN50(VAR161), VAR157, VAR159)) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN53(VAR42, VAR137);
}
return VAR126[VAR160];
}
function FUN44(bytes VAR162, uint VAR163, uint VAR76, bytes VAR164, uint VAR165) internal pure returns (bytes) {
uint VAR75 = VAR76 + VAR165;
require(VAR164.VAR76 >= VAR75);
uint VAR71 = 32 + VAR163;
uint VAR96 = 32 + VAR165;
while (VAR71 < (32 + VAR163 + VAR76)) {
VAR65 {
let VAR67 := FUN45(FUN40(VAR162, VAR71))
FUN39(FUN40(VAR164, VAR96), VAR67)
}
VAR71 += 32;
VAR96 += 32;
}
return VAR164;
}
function FUN52(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR65 {
let VAR172 := FUN45(0x40)
FUN39(VAR172, VAR166)
FUN39(FUN40(VAR172, 32), VAR167)
FUN39(FUN40(VAR172, 64), VAR168)
FUN39(FUN40(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN45(VAR172)
}
return (VAR170, VAR171);
}
function FUN58(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR76 != 65)
return (false, 0);
VAR65 {
VAR168 := FUN45(FUN40(VAR173, 32))
VAR169 := FUN45(FUN40(VAR173, 64))
VAR167 := FUN36(0, FUN45(FUN40(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN52(VAR166, VAR167, VAR168, VAR169);
}
}
contract VAR174 {
uint256 public VAR175;
uint256 public VAR176;
function FUN59(address VAR177) public;
function FUN60() payable public;
function FUN61() public view returns(uint256);
}
contract VAR178 {
function FUN62(uint256 VAR179, address VAR180) public;
function FUN63() payable public;
function FUN64(uint256 VAR181) public;
function FUN65() public view returns(uint256);
}
contract VAR182 {
function FUN66() constant public returns (uint VAR183);
function FUN67(address VAR184) constant public returns (uint VAR185);
function transfer(address VAR186, uint VAR187) public returns (bool VAR188);
function FUN68(address VAR189, address VAR186, uint VAR187) public returns (bool VAR188);
function FUN69(address VAR190, uint VAR187) public returns (bool VAR188);
function FUN70(address VAR184, address VAR190) constant public returns (uint VAR191);
event Transfer(address indexed VAR189, address indexed VAR186, uint VAR187);
event FUN71(address indexed VAR184, address indexed VAR190, uint VAR187);
}
contract EOSBetBankroll is VAR182, VAR178 {
using SafeMath for *;
address public VAR192;
uint256 public VAR193;
uint256 public VAR194;
uint256 public VAR175;
mapping(address => bool) public VAR195;
address public VAR196;
address public VAR197;
mapping(address => uint256) VAR198;
string public constant VAR199 = "";
string public constant VAR200 = "";
uint8 public constant VAR95 = 18;
uint256 public VAR201;
mapping(address => uint256) public VAR202;
mapping(address => mapping(address => uint256)) public VAR203;
event FUN72(address VAR204, uint256 VAR205, uint256 VAR206);
event FUN73(address VAR204, uint256 VAR207, uint256 VAR208);
event FUN74(address VAR209, uint256 VAR210);
modifier FUN75(address VAR211){
require(VAR195[VAR211]);
VAR36;
}
function FUN76(address VAR212, address VAR213) public payable {
require (msg.value > 0);
VAR192 = msg.sender;
uint256 VAR214 = msg.value * 100;
VAR202[msg.sender] = VAR214;
VAR201 = VAR214;
emit Transfer(0x0, msg.sender, VAR214);
VAR195[VAR212] = true;
VAR195[VAR213] = true;
VAR196 = VAR212;
VAR197 = VAR213;
VAR194 = 6 VAR215;
VAR193 = 500 VAR47;
}
function FUN77(address VAR216) view public returns(uint256){
return VAR198[VAR216];
}
function FUN65() view public returns(uint256){
return VAR217.FUN43(address(this).VAR185, VAR175);
}
function FUN62(uint256 VAR179, address VAR180) public FUN75(msg.sender){
if (! VAR180.FUN78(VAR179)){
emit FUN74(VAR180, VAR179);
if (! VAR192.FUN78(VAR179)){
emit FUN74(VAR192, VAR179);
}
}
}
function FUN63() payable public FUN75(msg.sender){
}
function FUN64(uint256 VAR181) public FUN75(msg.sender){
FUN79(msg.sender).VAR218.value(VAR181)();
}
function () public payable {
uint256 VAR219 = VAR217.FUN43(FUN65(), msg.value);
uint256 VAR220 = VAR193;
require(VAR219 < VAR220 && msg.value != 0);
uint256 VAR221 = VAR201;
uint256 VAR222;
bool VAR223;
uint256 VAR224;
uint256 VAR225;
if (VAR217.FUN40(VAR219, msg.value) > VAR220){
VAR223 = true;
VAR222 = VAR217.FUN43(VAR220, VAR219);
VAR224 = VAR217.FUN43(msg.value, VAR222);
}
else {
VAR222 = msg.value;
}
if (VAR221 != 0){
VAR225 = VAR217.FUN80(VAR222, VAR221) / VAR219;
}
else {
VAR225 = VAR217.FUN80(VAR222, 100);
}
VAR201 = VAR217.FUN40(VAR221, VAR225);
VAR202[msg.sender] = VAR217.FUN40(VAR202[msg.sender], VAR225);
VAR198[msg.sender] = VAR226.VAR51;
if (VAR223){
msg.sender.transfer(VAR224);
}
emit FUN72(msg.sender, VAR222, VAR225);
emit Transfer(0x0, msg.sender, VAR225);
}
function FUN81(uint256 VAR227) public {
uint256 VAR228 = VAR202[msg.sender];
require(VAR227 <= VAR228
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR227 > 0);
uint256 VAR219 = FUN65();
uint256 VAR221 = VAR201;
uint256 VAR229 = VAR217.FUN80(VAR227, VAR219) / VAR221;
uint256 VAR230 = VAR229 / 100;
uint256 VAR231 = VAR217.FUN43(VAR229, VAR230);
VAR201 = VAR217.FUN43(VAR221, VAR227);
VAR202[msg.sender] = VAR217.FUN43(VAR228, VAR227);
VAR175 = VAR217.FUN40(VAR175, VAR230);
msg.sender.transfer(VAR231);
emit FUN73(msg.sender, VAR231, VAR227);
emit Transfer(msg.sender, 0x0, VAR227);
}
function FUN82() public {
FUN81(VAR202[msg.sender]);
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN84(uint256 VAR233) public {
require (msg.sender == VAR192 && VAR233 <= 6048000);
VAR194 = VAR233;
}
function FUN85(uint256 VAR234) public {
require(msg.sender == VAR192);
VAR193 = VAR234;
}
function FUN86(address VAR235) public {
require(msg.sender == VAR192);
FUN79(VAR196).FUN59(VAR235);
FUN79(VAR197).FUN59(VAR235);
uint256 VAR236 = VAR175;
VAR175 = 0;
VAR235.transfer(VAR236);
}
function FUN87(address VAR237, uint256 VAR238) public {
require (msg.sender == VAR192);
FUN88(VAR237).transfer(msg.sender, VAR238);
}
function FUN66() constant public returns(uint){
return VAR201;
}
function FUN67(address VAR184) constant public returns(uint){
return VAR202[VAR184];
}
function transfer(address VAR186, uint256 VAR187) public returns (bool VAR188){
require(VAR202[msg.sender] >= VAR187
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)
&& VAR186 != address(0));
VAR202[msg.sender] = VAR217.FUN43(VAR202[msg.sender], VAR187);
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
emit Transfer(msg.sender, VAR186, VAR187);
return true;
}
function FUN68(address VAR189, address VAR186, uint VAR187) public returns(bool){
require(VAR203[VAR189][msg.sender] >= VAR187
&& VAR202[VAR189] >= VAR187
&& VAR198[VAR189] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)
&& VAR186 != address(0));
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
VAR202[VAR189] = VAR217.FUN43(VAR202[VAR189], VAR187);
VAR203[VAR189][msg.sender] = VAR217.FUN43(VAR203[VAR189][msg.sender], VAR187);
emit Transfer(VAR189, VAR186, VAR187);
return true;
}
function FUN69(address VAR190, uint VAR187) public returns(bool){
VAR203[msg.sender][VAR190] = VAR187;
emit FUN71(msg.sender, VAR190, VAR187);
return true;
}
function FUN70(address VAR184, address VAR190) constant public returns(uint){
return VAR203[VAR184][VAR190];
}
}
pragma VAR1 ^0.4.18;
library VAR217 {
function FUN80(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
if (VAR73 == 0) {
return 0;
}
uint256 VAR239 = VAR73 * VAR74;
assert(VAR239 / VAR73 == VAR74);
return VAR239;
}
function FUN47(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR239 = VAR73 / VAR74;
return VAR239;
}
function FUN43(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
assert(VAR74 <= VAR73);
return VAR73 - VAR74;
}
function FUN40(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR239 = VAR73 + VAR74;
assert(VAR239 >= VAR73);
return VAR239;
}
}
contract EOSBetSlots is VAR18, VAR174 {
using SafeMath for *;
event FUN89(bytes32 indexed VAR240);
event FUN90(bytes32 indexed VAR240);
event FUN91(bytes32 indexed VAR240, uint256 VAR241);
event FUN92(bytes32 indexed VAR240, uint256 VAR242, uint256 VAR243, uint256 VAR244, uint256 VAR245, uint256 VAR246, uint256 VAR247, uint256 VAR248, uint256 VAR249);
event FUN93(uint256 VAR242, uint256 VAR243, uint256 VAR244, uint256 VAR245, uint256 VAR246, uint256 VAR247, uint256 VAR248, uint256 VAR249);
struct VAR250 {
address VAR251;
bool VAR252;
uint256 VAR253;
uint256 VAR254;
uint8 VAR255;
}
mapping (bytes32 => VAR250) public VAR256;
uint256 public VAR176;
uint256 public VAR175;
uint256 public VAR257;
uint256 public VAR258;
uint256 public VAR259;
uint256 public VAR260;
uint256 public VAR261;
uint256 public VAR262;
uint256 public VAR263;
uint16 public VAR264;
bool public VAR265;
bool public VAR266;
address public VAR192;
address public VAR267;
function FUN94() public {
FUN25(VAR25);
FUN26(8000000000);
VAR262 = 8000000000;
VAR263 = 225000;
VAR257 = 0;
VAR258 = 0;
VAR265 = false;
VAR266 = true;
VAR259 = 6 VAR215;
VAR260 = 2 VAR268;
VAR261 = 10 VAR268;
VAR264 = 333;
VAR192 = msg.sender;
}
function FUN59(address VAR177) public {
require(msg.sender == VAR267);
uint256 VAR269 = VAR175;
VAR175 = 0;
VAR177.transfer(VAR269);
}
function FUN60() payable public {
require(msg.sender == VAR267);
}
function FUN61() public view returns(uint256){
return (VAR217.FUN80(FUN95(VAR267).FUN65(), VAR264) / 1000);
}
function FUN96(address VAR270) public {
require(msg.sender == VAR192 && VAR267 == address(0));
require(FUN95(VAR270).FUN65() != 0);
VAR267 = VAR270;
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN97(uint256 VAR271) public {
require(msg.sender == VAR192);
VAR259 = VAR271;
}
function FUN98(uint256 VAR63) public {
require(msg.sender == VAR192);
VAR262 = VAR63;
FUN26(VAR63);
}
function FUN99(uint256 VAR272) public {
require(msg.sender == VAR192);
VAR263 = VAR272;
}
function FUN100(bool VAR273) public {
require(msg.sender == VAR192);
VAR265 = VAR273;
}
function FUN101(bool VAR274) public {
require(msg.sender == VAR192);
VAR266 = VAR274;
}
function FUN102(uint256 VAR275) public {
require(msg.sender == VAR192 && VAR275 > 1000);
VAR260 = VAR275;
}
function FUN103(uint256 VAR275) public {
require(msg.sender == VAR192 && VAR275 > 1000);
VAR261 = VAR275;
}
function FUN104(uint16 VAR276) public {
require(msg.sender == VAR192 && VAR276 <= 333);
VAR264 = VAR276;
}
function FUN87(address VAR237, uint256 VAR238) public {
require (msg.sender == VAR192);
FUN88(VAR237).transfer(msg.sender, VAR238);
}
function FUN105(bytes32 VAR240) public {
SlotsGameData memory VAR277 = VAR256[VAR240];
require(VAR217.FUN43(VAR226.VAR51, VAR277.VAR253) >= VAR259
&& (msg.sender == VAR192 || msg.sender == VAR277.VAR251)
&& (!VAR277.VAR252)
&& VAR277.VAR254 <= VAR176
&& VAR277.VAR254 > 0
&& VAR266);
VAR256[VAR240].VAR252 = true;
VAR176 = VAR217.FUN43(VAR176, VAR277.VAR254);
VAR277.VAR251.transfer(VAR277.VAR254);
emit FUN91(VAR240, VAR277.VAR254);
}
function FUN106(uint8 VAR255) public payable {
uint256 VAR278 = msg.value / VAR255;
require(!VAR265
&& msg.value >= VAR261
&& VAR278 >= VAR260
&& VAR255 > 0
&& VAR255 <= 224
&& VAR217.FUN80(VAR278, 5000) <= FUN61());
uint256 VAR279 = VAR263 + (uint256(3270) * VAR255);
FUN95(VAR267).FUN64(FUN19('', VAR279));
bytes32 VAR240 = FUN38(0, 30, VAR279);
VAR256[VAR240] = FUN107({
VAR251 : msg.sender,
VAR252 : false,
VAR253 : VAR226.VAR51,
VAR254 : msg.value,
VAR255 : VAR255
});
VAR176 = VAR217.FUN40(VAR176, msg.value);
emit FUN89(VAR240);
}
function FUN18(bytes32 VAR146, string VAR147, bytes VAR148) public {
SlotsGameData memory VAR277 = VAR256[VAR146];
require(msg.sender == FUN23()
&& !VAR277.VAR252
&& VAR277.VAR251 != address(0)
&& VAR176 >= VAR277.VAR254);
if (FUN56(VAR146, VAR147, VAR148) != 0){
if (VAR266){
VAR256[VAR146].VAR252 = true;
VAR176 = VAR217.FUN43(VAR176, VAR277.VAR254);
VAR277.VAR251.transfer(VAR277.VAR254);
emit FUN91(VAR146, VAR277.VAR254);
}
emit FUN90(VAR146);
}
else {
uint256 VAR280;
uint8 VAR281;
uint8 VAR282;
uint8 VAR283;
uint256[] memory VAR284 = new uint256[](8);
uint256 VAR285;
for (uint8 VAR71 = 0; VAR71 < VAR277.VAR255; VAR71++){
VAR280 += 1;
VAR281 = uint8(uint(FUN49(VAR147, VAR280)) % 64);
VAR280 += 1;
VAR282 = uint8(uint(FUN49(VAR147, VAR280)) % 64);
VAR280 += 1;
VAR283 = uint8(uint(FUN49(VAR147, VAR280)) % 64);
VAR281 = FUN108(VAR281);
VAR282 = FUN109(VAR282);
VAR283 = FUN110(VAR283);
VAR285 += FUN111(VAR281, VAR282, VAR283);
if (VAR71 <= 27){
VAR284[0] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (27 - VAR71)) + 2));
VAR284[0] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (27 - VAR71)) + 1));
VAR284[0] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (27 - VAR71))));
}
else if (VAR71 <= 55){
VAR284[1] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (55 - VAR71)) + 2));
VAR284[1] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (55 - VAR71)) + 1));
VAR284[1] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (55 - VAR71))));
}
else if (VAR71 <= 83) {
VAR284[2] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (83 - VAR71)) + 2));
VAR284[2] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (83 - VAR71)) + 1));
VAR284[2] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (83 - VAR71))));
}
else if (VAR71 <= 111) {
VAR284[3] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (111 - VAR71)) + 2));
VAR284[3] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (111 - VAR71)) + 1));
VAR284[3] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (111 - VAR71))));
}
else if (VAR71 <= 139){
VAR284[4] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (139 - VAR71)) + 2));
VAR284[4] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (139 - VAR71)) + 1));
VAR284[4] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (139 - VAR71))));
}
else if (VAR71 <= 167){
VAR284[5] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (167 - VAR71)) + 2));
VAR284[5] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (167 - VAR71)) + 1));
VAR284[5] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (167 - VAR71))));
}
else if (VAR71 <= 195){
VAR284[6] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (195 - VAR71)) + 2));
VAR284[6] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (195 - VAR71)) + 1));
VAR284[6] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (195 - VAR71))));
}
else if (VAR71 <= 223){
VAR284[7] += uint256(VAR281) * uint256(2) ** (3 * ((3 * (223 - VAR71)) + 2));
VAR284[7] += uint256(VAR282) * uint256(2) ** (3 * ((3 * (223 - VAR71)) + 1));
VAR284[7] += uint256(VAR283) * uint256(2) ** (3 * ((3 * (223 - VAR71))));
}
}
VAR258 += VAR280;
VAR257 = VAR217.FUN40(VAR257, VAR277.VAR254);
VAR256[VAR146].VAR252 = true;
VAR176 = VAR217.FUN43(VAR176, VAR277.VAR254);
uint256 VAR230 = VAR277.VAR254 / 100;
VAR175 = VAR217.FUN40(VAR175, VAR230);
FUN95(VAR267).VAR286.value(VAR217.FUN43(VAR277.VAR254, VAR230))();
uint256 VAR287 = VAR217.FUN80((VAR277.VAR254 / VAR277.VAR255), VAR285);
FUN95(VAR267).FUN62(VAR287, VAR277.VAR251);
emit FUN92(VAR146, VAR284[0], VAR284[1], VAR284[2], VAR284[3], VAR284[4], VAR284[5], VAR284[6], VAR284[7]);
}
}
function FUN108(uint8 VAR288) internal pure returns(uint8) {
if (VAR288 == 0) 							        { return 0; }
else if (VAR288 >= 1 && VAR288 <= 7) 			{ return 1; }
else if (VAR288 == 8) 						        { return 2; }
else if (VAR288 >= 9 && VAR288 <= 13) 		{ return 3; }
else if (VAR288 >= 14 && VAR288 <= 22) 		{ return 4; }
else if (VAR288 >= 23 && VAR288 <= 31) 		{ return 5; }
else 										                { return 6; }
}
function FUN109(uint8 VAR289) internal pure returns(uint8) {
if (VAR289 >= 0 && VAR289 <= 2) 				{ return 0; }
else if (VAR289 == 3) 						        { return 1; }
else if (VAR289 >= 4 && VAR289 <= 10)			{ return 2; }
else if (VAR289 >= 11 && VAR289 <= 17) 		{ return 3; }
else if (VAR289 >= 18 && VAR289 <= 23) 		{ return 4; }
else if (VAR289 >= 24 && VAR289 <= 31) 		{ return 5; }
else 										                { return 6; }
}
function FUN110(uint8 VAR290) internal pure returns(uint8) {
if (VAR290 == 0) 							        { return 0; }
else if (VAR290 >= 1 && VAR290 <= 6)			{ return 1; }
else if (VAR290 >= 7 && VAR290 <= 12) 		{ return 2; }
else if (VAR290 >= 13 && VAR290 <= 18)		{ return 3; }
else if (VAR290 >= 19 && VAR290 <= 25) 		{ return 4; }
else if (VAR290 >= 26 && VAR290 <= 31) 		{ return 5; }
else 										                { return 6; }
}
function FUN111(uint8 VAR281, uint8 VAR282, uint8 VAR283) internal pure returns(uint256) {
if (VAR281 == 6 || VAR282 == 6 || VAR283 == 6){
if (VAR281 == 6 && VAR282 == 6 && VAR283 == 6)
return 1;
}
else if (VAR281 == 5){
if (VAR282 == 4 && VAR283 == 3)
return 90;
else if (VAR282 == 3 && VAR283 == 4)
return 15;
else if (VAR282 == 5 && VAR283 == 5)
return 10;
else if (VAR282 >= 3 && VAR282 <= 5 && VAR283 >= 3 && VAR283 <= 5)
return 3;
else if ((VAR282 == 2 || VAR282 == 5) && (VAR283 == 2 || VAR283 == 5))
return 2;
}
else if (VAR281 == 4){
if (VAR282 == 4 && VAR283 == 4)
return 25;
else if ((VAR282 == 3 && VAR283 == 5) || (VAR282 == 5 && VAR283 == 3))
return 15;
else if (VAR282 >= 3 && VAR282 <= 5 && VAR283 >= 3 && VAR283 <= 5)
return 3;
else if ((VAR282 == 1 || VAR282 == 4) && (VAR283 == 1 || VAR283 == 4))
return 2;
}
else if (VAR281 == 3){
if (VAR282 == 3 && VAR283 == 3)
return 50;
else if ((VAR282 == 4 && VAR283 == 5) || (VAR282 == 5 && VAR283 == 4))
return 15;
else if (VAR282 >= 3 && VAR282 <= 5 && VAR283 >= 3 && VAR283 <= 5)
return 3;
else if ((VAR282 == 0 || VAR282 == 3) && (VAR283 == 0 || VAR283 == 3))
return 3;
}
else if (VAR281 == 2){
if (VAR282 == 1 && VAR283 == 0)
return 5000;
else if (VAR282 == 2 && VAR283 == 2)
return 250;
else if (VAR282 >= 0 && VAR282 <= 2 && VAR283 >= 0 && VAR283 <= 2)
return 70;
else if ((VAR282 == 2 || VAR282 == 5) && (VAR283 == 2 || VAR283 == 5))
return 2;
}
else if (VAR281 == 1){
if (VAR282 == 1 && VAR283 == 1)
return 250;
else if (VAR282 >= 0 && VAR282 <= 2 && VAR283 >= 0 && VAR283 <= 2)
return 70;
else if ((VAR282 == 1 || VAR282 == 4) && (VAR283 == 1 || VAR283 == 4))
return 3;
}
else if (VAR281 == 0){
if (VAR282 == 0 && VAR283 == 0)
return 1777;
else if (VAR282 >= 0 && VAR282 <= 2 && VAR283 >= 0 && VAR283 <= 2)
return 70;
else if ((VAR282 == 0 || VAR282 == 3) && (VAR283 == 0 || VAR283 == 3))
return 3;
}
return 0;
}
}
1
---------------------------------
62 0x4b8d81ca8ce555ab97ee1eebe3c844c3ef7af8ef.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
pragma VAR1 ^0.4.11;
contract VAR6 {
address public VAR7;
function FUN5(uint VAR8, string VAR9, string VAR10) payable returns (bytes32 VAR11);
function FUN6(uint VAR8, string VAR9, string VAR10, uint VAR12) payable returns (bytes32 VAR11);
function FUN7(uint VAR8, string VAR9, string VAR13, string VAR14) payable returns (bytes32 VAR11);
function FUN8(uint VAR8, string VAR9, string VAR13, string VAR14, uint VAR12) payable returns (bytes32 VAR11);
function FUN9(uint VAR8, string VAR9, bytes VAR15) payable returns (bytes32 VAR11);
function FUN10(uint VAR8, string VAR9, bytes VAR15, uint VAR12) payable returns (bytes32 VAR11);
function FUN11(string VAR9) returns (uint VAR16);
function FUN11(string VAR9, uint VAR17) returns (uint VAR16);
function FUN12(string VAR18);
function FUN13(byte VAR19);
function FUN14(bytes32 VAR20);
function FUN15(uint VAR21);
function FUN16() returns(bytes32);
}
contract VAR22 {
function FUN17() returns (address VAR23);
}
contract VAR24 {
uint constant VAR25 = 60*60*24;
uint constant VAR26 = 60*60*24*7;
uint constant VAR27 = 60*60*24*30;
byte constant VAR28 = 0x00;
byte constant VAR29 = 0x10;
byte constant VAR30 = 0x20;
byte constant VAR31 = 0x30;
byte constant VAR32 = 0xF0;
byte constant VAR33 = 0x01;
uint8 constant VAR34 = 0;
uint8 constant VAR35 = 1;
uint8 constant VAR36 = 2;
uint8 constant VAR37 = 2;
uint8 constant VAR38 = 161;
OraclizeAddrResolverI VAR39;
OraclizeI VAR40;
modifier VAR41 {
if((address(VAR39)==0)||(FUN18(address(VAR39))==0)) FUN19(VAR34);
VAR40 = FUN20(VAR39.FUN17());
VAR42;
}
modifier FUN21(string VAR43){
VAR40 = FUN20(VAR39.FUN17());
VAR40.FUN12(VAR43);
VAR42;
}
function FUN19(uint8 VAR44) internal returns(bool){
if (FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR39 = FUN22(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN23("");
return true;
}
if (FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR39 = FUN22(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN23("");
return true;
}
if (FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR39 = FUN22(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN23("");
return true;
}
if (FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR39 = FUN22(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN23("");
return true;
}
if (FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR39 = FUN22(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR39 = FUN22(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR39 = FUN22(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN24(bytes32 VAR45, string VAR46) {
FUN24(VAR45, VAR46, VAR47 bytes(0));
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) {
}
function FUN25(string VAR43) oraclizeAPI internal {
VAR40.FUN12(VAR43);
}
function FUN26(string VAR49) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49);
}
function FUN26(string VAR49, uint VAR17) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49, VAR17);
}
function FUN27(string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(0, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(VAR57, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(VAR57, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(0, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(0, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(VAR57, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(VAR57, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(0, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN30() oraclizeAPI internal returns (address){
return VAR40.FUN31();
}
function FUN32(byte VAR68) oraclizeAPI internal {
return VAR40.FUN13(VAR68);
}
function FUN33(uint VAR69) oraclizeAPI internal {
return VAR40.FUN15(VAR69);
}
function FUN34(bytes32 VAR70) oraclizeAPI internal {
return VAR40.FUN14(VAR70);
}
function FUN35() oraclizeAPI internal returns (bytes32){
return VAR40.FUN16();
}
function FUN18(address VAR23) constant internal returns(uint VAR71) {
VAR72 {
VAR71 := FUN36(VAR23)
}
}
function FUN37(string VAR73) internal returns (address){
bytes memory VAR74 = bytes(VAR73);
uint160 VAR75 = 0;
uint160 VAR76;
uint160 VAR77;
for (uint VAR78=2; VAR78<2+2*20; VAR78+=2){
VAR75 *= 256;
VAR76 = FUN38(VAR74[VAR78]);
VAR77 = FUN38(VAR74[VAR78+1]);
if ((VAR76 >= 97)&&(VAR76 <= 102)) VAR76 -= 87;
else if ((VAR76 >= 65)&&(VAR76 <= 70)) VAR76 -= 55;
else if ((VAR76 >= 48)&&(VAR76 <= 57)) VAR76 -= 48;
if ((VAR77 >= 97)&&(VAR77 <= 102)) VAR77 -= 87;
else if ((VAR77 >= 65)&&(VAR77 <= 70)) VAR77 -= 55;
else if ((VAR77 >= 48)&&(VAR77 <= 57)) VAR77 -= 48;
VAR75 += (VAR76*16+VAR77);
}
return address(VAR75);
}
function FUN39(string VAR73, string VAR79) internal returns (int) {
bytes memory VAR3 = bytes(VAR73);
bytes memory VAR4 = bytes(VAR79);
uint VAR80 = VAR3.VAR81;
if (VAR4.VAR81 < VAR80) VAR80 = VAR4.VAR81;
for (uint VAR78 = 0; VAR78 < VAR80; VAR78 ++)
if (VAR3[VAR78] < VAR4[VAR78])
return -1;
else if (VAR3[VAR78] > VAR4[VAR78])
return 1;
if (VAR3.VAR81 < VAR4.VAR81)
return -1;
else if (VAR3.VAR81 > VAR4.VAR81)
return 1;
else
return 0;
}
function FUN40(string VAR82, string VAR83) internal returns (int) {
bytes memory VAR84 = bytes(VAR82);
bytes memory VAR85 = bytes(VAR83);
if(VAR84.VAR81 < 1 || VAR85.VAR81 < 1 || (VAR85.VAR81 > VAR84.VAR81))
return -1;
else if(VAR84.VAR81 > (2**128 -1))
return -1;
else
{
uint VAR86 = 0;
for (uint VAR78 = 0; VAR78 < VAR84.VAR81; VAR78 ++)
{
if (VAR84[VAR78] == VAR85[0])
{
VAR86 = 1;
while(VAR86 < VAR85.VAR81 && (VAR78 + VAR86) < VAR84.VAR81 && VAR84[VAR78 + VAR86] == VAR85[VAR86])
{
VAR86++;
}
if(VAR86 == VAR85.VAR81)
return int(VAR78);
}
}
return -1;
}
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88, string VAR89) internal returns (string) {
bytes memory VAR90 = bytes(VAR73);
bytes memory VAR91 = bytes(VAR79);
bytes memory VAR92 = bytes(VAR87);
bytes memory VAR93 = bytes(VAR88);
bytes memory VAR94 = bytes(VAR89);
string memory VAR95 = VAR47 string(VAR90.VAR81 + VAR91.VAR81 + VAR92.VAR81 + VAR93.VAR81 + VAR94.VAR81);
bytes memory VAR96 = bytes(VAR95);
uint VAR97 = 0;
for (uint VAR78 = 0; VAR78 < VAR90.VAR81; VAR78++) VAR96[VAR97++] = VAR90[VAR78];
for (VAR78 = 0; VAR78 < VAR91.VAR81; VAR78++) VAR96[VAR97++] = VAR91[VAR78];
for (VAR78 = 0; VAR78 < VAR92.VAR81; VAR78++) VAR96[VAR97++] = VAR92[VAR78];
for (VAR78 = 0; VAR78 < VAR93.VAR81; VAR78++) VAR96[VAR97++] = VAR93[VAR78];
for (VAR78 = 0; VAR78 < VAR94.VAR81; VAR78++) VAR96[VAR97++] = VAR94[VAR78];
return string(VAR96);
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, VAR88, "");
}
function FUN41(string VAR73, string VAR79, string VAR87) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, "", "");
}
function FUN41(string VAR73, string VAR79) internal returns (string) {
return FUN41(VAR73, VAR79, "", "", "");
}
function FUN42(string VAR73) internal returns (uint) {
return FUN42(VAR73, 0);
}
function FUN42(string VAR73, uint VAR79) internal returns (uint) {
bytes memory VAR98 = bytes(VAR73);
uint VAR99 = 0;
bool VAR100 = false;
for (uint VAR78=0; VAR78<VAR98.VAR81; VAR78++){
if ((VAR98[VAR78] >= 48)&&(VAR98[VAR78] <= 57)){
if (VAR100){
if (VAR79 == 0) break;
else VAR79--;
}
VAR99 *= 10;
VAR99 += uint(VAR98[VAR78]) - 48;
} else if (VAR98[VAR78] == 46) VAR100 = true;
}
if (VAR79 > 0) VAR99 *= 10**VAR79;
return VAR99;
}
function FUN43(uint VAR78) internal returns (string){
if (VAR78 == 0) return "";
uint VAR101 = VAR78;
uint VAR102;
while (VAR101 != 0){
VAR102++;
VAR101 /= 10;
}
bytes memory VAR103 = VAR47 bytes(VAR102);
uint VAR97 = VAR102 - 1;
while (VAR78 != 0){
VAR103[VAR97--] = FUN44(48 + VAR78 % 10);
VAR78 /= 10;
}
return string(VAR103);
}
function FUN28(string[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
function FUN29(bytes[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
string VAR114;
function FUN23(string VAR115) internal {
VAR114 = VAR115;
}
function FUN45() internal returns (string) {
return VAR114;
}
function FUN46(uint VAR116, uint VAR117, uint VAR118) internal returns (bytes32){
if ((VAR117 == 0)||(VAR117 > 32)) throw;
bytes memory VAR119 = VAR47 bytes(1);
VAR119[0] = FUN44(VAR117);
bytes memory VAR120 = VAR47 bytes(32);
bytes memory VAR121 = VAR47 bytes(32);
bytes32 VAR122 = FUN35();
VAR72 {
FUN47(VAR120, 0x20)
FUN47(FUN4(VAR120, 0x20), FUN48(FUN49(FUN3(VAR123, 1)), FUN48(VAR124, VAR57)))
FUN47(VAR121, 0x20)
FUN47(FUN4(VAR121, 0x20), VAR122)
}
bytes[3] memory VAR64 = [VAR120, VAR119, VAR121];
bytes32 VAR125 = FUN27(VAR116, "", VAR64, VAR118);
FUN50(VAR125, FUN51(FUN52(VAR116), VAR64[1], FUN53(VAR64[0]), VAR64[2]));
return VAR125;
}
function FUN50(bytes32 VAR125, bytes32 VAR126) internal {
VAR127[VAR125] = VAR126;
}
mapping(bytes32=>bytes32) VAR127;
mapping(bytes32=>bool) VAR128;
function FUN54(bytes32 VAR129, bytes VAR130, bytes VAR131) internal returns (bool){
bool VAR132;
address VAR133;
bytes32 VAR134;
bytes32 VAR135;
bytes memory VAR136 = VAR47 bytes(32);
uint VAR137 = 4+(uint(VAR130[3]) - 0x20);
VAR136 = FUN55(VAR130, VAR137, 32, VAR136, 0);
bytes memory VAR138 = VAR47 bytes(32);
VAR137 += 32 + 2;
VAR138 = FUN55(VAR130, VAR137+(uint(VAR130[VAR137-1]) - 0x20), 32, VAR138, 0);
VAR72 {
VAR134 := FUN56(FUN4(VAR136, 32))
VAR135 := FUN56(FUN4(VAR138, 32))
}
(VAR132, VAR133) = FUN57(VAR129, 27, VAR134, VAR135);
if (address(FUN51(VAR131)) == VAR133) return true;
else {
(VAR132, VAR133) = FUN57(VAR129, 28, VAR134, VAR135);
return (address(FUN51(VAR131)) == VAR133);
}
}
function FUN58(bytes VAR48, uint VAR139) internal returns (bool) {
bool VAR132;
bytes memory VAR140 = VAR47 bytes(uint(VAR48[VAR139+1])+2);
FUN55(VAR48, VAR139, VAR140.VAR81, VAR140, 0);
bytes memory VAR141 = VAR47 bytes(64);
FUN55(VAR48, 3+1, 64, VAR141, 0);
bytes memory VAR142 = VAR47 bytes(1+65+32);
VAR142[0] = 1;
FUN55(VAR48, VAR139-65, 65, VAR142, 1);
bytes memory VAR143 = VAR144"";
FUN55(VAR143, 0, 32, VAR142, 1+65);
VAR132 = FUN54(FUN53(VAR142), VAR140, VAR141);
if (VAR132 == false) return false;
bytes memory VAR145 = VAR144"";
bytes memory VAR146 = VAR47 bytes(1+65);
VAR146[0] = 0xFE;
FUN55(VAR48, 3, 65, VAR146, 1);
bytes memory VAR147 = VAR47 bytes(uint(VAR48[3+65+1])+2);
FUN55(VAR48, 3+65, VAR147.VAR81, VAR147, 0);
VAR132 = FUN54(FUN53(VAR146), VAR147, VAR145);
return VAR132;
}
modifier FUN59(bytes32 VAR148, string VAR149, bytes VAR150) {
if ((VAR150[0] != "")||(VAR150[1] != "")||(VAR150[2] != 1)) throw;
bool VAR151 = FUN60(VAR150, VAR148, bytes(VAR149), FUN45());
if (VAR151 == false) throw;
VAR42;
}
function FUN61(bytes32 VAR152, bytes VAR153) internal returns (bool){
bool VAR154 = true;
for (var VAR78=0; VAR78<VAR153.VAR81; VAR78++){
if (VAR152[VAR78] != VAR153[VAR78]) VAR154 = false;
}
return VAR154;
}
function FUN60(bytes VAR48, bytes32 VAR125, bytes VAR46, string VAR155) internal returns (bool){
bool VAR156;
uint VAR157 = 3+65+(uint(VAR48[3+65+1])+2)+32;
bytes memory VAR158 = VAR47 bytes(32);
FUN55(VAR48, VAR157, 32, VAR158, 0);
VAR156 = (FUN51(VAR158) == FUN51(FUN53(VAR155, VAR125)));
if (VAR156 == false) return false;
bytes memory VAR159 = VAR47 bytes(uint(VAR48[VAR157+(32+8+1+32)+1])+2);
FUN55(VAR48, VAR157+(32+8+1+32), VAR159.VAR81, VAR159, 0);
VAR156 = FUN61(FUN53(VAR159), VAR46);
if (VAR156 == false) return false;
bytes memory VAR160 = VAR47 bytes(8+1+32);
FUN55(VAR48, VAR157+32, 8+1+32, VAR160, 0);
bytes memory VAR161 = VAR47 bytes(64);
uint VAR139 = VAR157+32+(8+1+32)+VAR159.VAR81+65;
FUN55(VAR48, VAR139-64, 64, VAR161, 0);
bytes32 VAR162 = FUN53(VAR161);
if (VAR127[VAR125] == FUN51(VAR160, VAR162)){
delete VAR127[VAR125];
} else return false;
bytes memory VAR163 = VAR47 bytes(32+8+1+32);
FUN55(VAR48, VAR157, 32+8+1+32, VAR163, 0);
VAR156 = FUN54(FUN53(VAR163), VAR159, VAR161);
if (VAR156 == false) return false;
if (VAR128[VAR162] == false){
VAR128[VAR162] = FUN58(VAR48, VAR139);
}
return VAR128[VAR162];
}
function FUN55(bytes VAR164, uint VAR165, uint VAR81, bytes VAR166, uint VAR167) internal returns (bytes) {
uint VAR80 = VAR81 + VAR167;
if (VAR166.VAR81 < VAR80) {
throw;
}
uint VAR78 = 32 + VAR165;
uint VAR101 = 32 + VAR167;
while (VAR78 < (32 + VAR165 + VAR81)) {
VAR72 {
let VAR74 := FUN56(FUN4(VAR164, VAR78))
FUN47(FUN4(VAR166, VAR101), VAR74)
}
VAR78 += 32;
VAR101 += 32;
}
return VAR166;
}
function FUN57(bytes32 VAR168, uint8 VAR169, bytes32 VAR170, bytes32 VAR171) internal returns (bool, address) {
bool VAR172;
address VAR173;
VAR72 {
let VAR174 := FUN56(0x40)
FUN47(VAR174, VAR168)
FUN47(FUN4(VAR174, 32), VAR169)
FUN47(FUN4(VAR174, 64), VAR170)
FUN47(FUN4(VAR174, 96), VAR171)
VAR172 := call(3000, 1, 0, VAR174, 128, VAR174, 32)
VAR173 := FUN56(VAR174)
}
return (VAR172, VAR173);
}
function FUN62(bytes32 VAR168, bytes VAR175) internal returns (bool, address) {
bytes32 VAR170;
bytes32 VAR171;
uint8 VAR169;
if (VAR175.VAR81 != 65)
return (false, 0);
VAR72 {
VAR170 := FUN56(FUN4(VAR175, 32))
VAR171 := FUN56(FUN4(VAR175, 64))
VAR169 := FUN44(0, FUN56(FUN4(VAR175, 96)))
}
//
if (VAR169 < 27)
VAR169 += 27;
if (VAR169 != 27 && VAR169 != 28)
return (false, 0);
return FUN57(VAR168, VAR169, VAR170, VAR171);
}
}
contract VAR176 {
function FUN63() external;
function FUN64() external payable;
}
contract Betting is VAR24 {
using SafeMath for uint256;
uint VAR177=3;
address public VAR178;
uint public VAR179;
string public constant VAR180 = "";
BettingControllerInterface internal VAR181;
struct VAR182 {
bool  VAR183;
bool  VAR184;
bool  VAR185;
bool  VAR186;
uint32  VAR187;
uint32  VAR188;
uint32  VAR189;
uint32 VAR190;
}
struct VAR191{
int32  VAR192;
int32  VAR193;
int32  VAR194;
bytes32 VAR195;
bytes32 VAR196;
bytes32 VAR197;
uint VAR198;
}
struct VAR199{
bytes32 VAR200;
uint VAR201;
}
struct VAR202{
uint256 VAR203;
uint256 VAR204;
uint160 VAR205;
uint32 VAR206;
bool VAR207;
bytes32 VAR208;
bytes32 VAR209;
}
struct VAR210 {
uint160 VAR211;
bool VAR212;
mapping(bytes32=>uint) VAR213;
}
mapping (bytes32 => bytes32) VAR214;
mapping (bytes32 => VAR202) VAR215;
mapping (address => VAR210) VAR216;
uint public VAR217;
uint32 VAR218;
mapping (bytes32 => bool) public VAR219;
event FUN65(string VAR220);
event FUN66(uint VAR52);
event FUN67(address VAR221, uint256 VAR222, bytes32 VAR223, uint256 VAR224);
event FUN68(address VAR225, uint256 VAR222);
function FUN69() public payable {
FUN32(VAR29 | VAR33);
VAR178 = msg.sender;
VAR226.VAR195 = bytes32("");
VAR226.VAR196 = bytes32("");
VAR226.VAR197 = bytes32("");
VAR226.VAR198 = 300000;
VAR181 = FUN70(VAR178);
}
horses_info public VAR226;
chronus_info public VAR227;
modifier onlyOwner {
require(VAR178 == msg.sender);
VAR42;
}
modifier VAR228 {
require(VAR227.VAR183);
VAR42;
}
modifier VAR229 {
require(!VAR227.VAR183 && !VAR227.VAR184);
VAR42;
}
modifier VAR230 {
require(VAR227.VAR185);
VAR42;
}
function FUN71(address VAR231) onlyOwner external {
VAR178 = VAR231;
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) public {
require (msg.sender == FUN30());
require (!VAR227.VAR185);
bytes32 VAR232;
VAR227.VAR184 = true;
VAR227.VAR183 = false;
VAR181.FUN63();
VAR232 = VAR214[VAR45];
if (VAR45 == VAR215[VAR232].VAR208) {
if (VAR233 >= VAR227.VAR187+VAR227.VAR188+ 5 VAR234) {
FUN72();
} else {
VAR215[VAR232].VAR203 = FUN73(VAR46);
emit FUN66(VAR215[VAR232].VAR203);
}
} else if (VAR45 == VAR215[VAR232].VAR209){
if (VAR215[VAR232].VAR203 > 0 ){
if (VAR233 >= VAR227.VAR187+VAR227.VAR189+ 5 VAR234) {
FUN72();
} else {
VAR215[VAR232].VAR204 = FUN73(VAR46);
VAR215[VAR232].VAR207 = true;
emit FUN66(VAR215[VAR232].VAR204);
if (VAR215[VAR226.VAR196].VAR207 && VAR215[VAR226.VAR195].VAR207 && VAR215[VAR226.VAR197].VAR207) {
FUN74();
}
}
} else {
FUN72();
}
}
}
function FUN75(bytes32 VAR200) external duringBetting payable  {
require(msg.value >= 0.01 VAR53);
if (VAR216[msg.sender].VAR211==0) {
VAR218+=1;
}
uint VAR235 = VAR216[msg.sender].VAR213[VAR200] + msg.value;
VAR216[msg.sender].VAR213[VAR200] = VAR235;
VAR216[msg.sender].VAR211 += FUN38(msg.value);
uint160 VAR236 = VAR215[VAR200].VAR205 + FUN38(msg.value);
uint32 VAR237 = VAR215[VAR200].VAR206 + 1;
VAR215[VAR200].VAR205 = VAR236;
VAR215[VAR200].VAR206 = VAR237;
emit FUN67(msg.sender, msg.value, VAR200, VAR233);
}
function () private payable {}
function FUN76(uint VAR238, uint  VAR239) onlyOwner beforeBetting public payable returns(bool) {
if (FUN26("")*3 + FUN26("", VAR226.VAR198)*3  > address(this).VAR240) {
emit FUN65("");
return false;
} else {
VAR227.VAR187 = FUN77(VAR241.VAR57);
VAR227.VAR183 = true;
bytes32 VAR242;
emit FUN65("");
VAR227.VAR188 = FUN77(VAR238);
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR196;
VAR215[VAR226.VAR196].VAR208 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR197;
VAR215[VAR226.VAR197].VAR208 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR195;
VAR215[VAR226.VAR195].VAR208 = VAR242;
VAR238 = VAR238.FUN4(VAR239);
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR196;
VAR215[VAR226.VAR196].VAR209 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR197;
VAR215[VAR226.VAR197].VAR209 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR195;
VAR215[VAR226.VAR195].VAR209 = VAR242;
VAR227.VAR189 = FUN77(VAR238);
return true;
}
}
function FUN74() internal {
VAR226.VAR192 = FUN79(VAR215[VAR226.VAR195].VAR204 - VAR215[VAR226.VAR195].VAR203)*100000/FUN79(VAR215[VAR226.VAR195].VAR203);
VAR226.VAR193 = FUN79(VAR215[VAR226.VAR196].VAR204 - VAR215[VAR226.VAR196].VAR203)*100000/FUN79(VAR215[VAR226.VAR196].VAR203);
VAR226.VAR194 = FUN79(VAR215[VAR226.VAR197].VAR204 - VAR215[VAR226.VAR197].VAR203)*100000/FUN79(VAR215[VAR226.VAR197].VAR203);
VAR217 = (VAR215[VAR226.VAR195].VAR205) + (VAR215[VAR226.VAR196].VAR205) + (VAR215[VAR226.VAR197].VAR205);
if (VAR218 <= 1) {
FUN72();
} else {
uint VAR244 = VAR217.FUN1(5).FUN2(100);
require(VAR244 < address(this).VAR240);
VAR217 = VAR217.FUN3(VAR244);
VAR181.VAR245.value(VAR244)();
}
if (VAR226.VAR192 > VAR226.VAR193) {
if (VAR226.VAR192 > VAR226.VAR194) {
VAR219[VAR226.VAR195] = true;
VAR179 = VAR215[VAR226.VAR195].VAR205;
}
else if(VAR226.VAR194 > VAR226.VAR192) {
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR197].VAR205;
} else {
VAR219[VAR226.VAR195] = true;
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR195].VAR205 + (VAR215[VAR226.VAR197].VAR205);
}
} else if(VAR226.VAR193 > VAR226.VAR192) {
if (VAR226.VAR193 > VAR226.VAR194) {
VAR219[VAR226.VAR196] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205;
}
else if (VAR226.VAR194 > VAR226.VAR193) {
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR197].VAR205;
} else {
VAR219[VAR226.VAR196] = true;
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205 + (VAR215[VAR226.VAR197].VAR205);
}
} else {
if (VAR226.VAR194 > VAR226.VAR193) {
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR197].VAR205;
} else if(VAR226.VAR194 < VAR226.VAR193){
VAR219[VAR226.VAR196] = true;
VAR219[VAR226.VAR195] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205 + (VAR215[VAR226.VAR195].VAR205);
} else {
VAR219[VAR226.VAR197] = true;
VAR219[VAR226.VAR196] = true;
VAR219[VAR226.VAR195] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205 + (VAR215[VAR226.VAR195].VAR205) + (VAR215[VAR226.VAR197].VAR205);
}
}
VAR227.VAR185 = true;
}
function FUN80(address VAR246) internal afterRace constant returns(uint VAR247) {
voter_info storage VAR248 = VAR216[VAR246];
if(VAR227.VAR186) {
VAR247 = VAR248.VAR211;
} else {
uint VAR249;
if(VAR219[VAR226.VAR195]) {
VAR249 += VAR248.VAR213[VAR226.VAR195];
} if(VAR219[VAR226.VAR196]) {
VAR249 += VAR248.VAR213[VAR226.VAR196];
} if(VAR219[VAR226.VAR197]) {
VAR249 += VAR248.VAR213[VAR226.VAR197];
}
VAR247 += (((VAR217.FUN1(10000000)).FUN2(VAR179)).FUN1(VAR249)).FUN2(10000000);
}
}
function FUN81() afterRace external constant returns (uint) {
require(!VAR216[msg.sender].VAR212);
return FUN80(msg.sender);
}
function FUN82() afterRace external {
require(!VAR216[msg.sender].VAR212);
uint VAR250 = FUN80(msg.sender);
require(address(this).VAR240 >= VAR250);
VAR216[msg.sender].VAR212 = true;
msg.sender.transfer(VAR250);
emit FUN68(msg.sender, VAR250);
}
function FUN72() internal {
VAR227.VAR186=true;
VAR227.VAR185 = true;
VAR227.VAR190=FUN77(VAR233);
}
function FUN73(string VAR171) internal pure returns (uint VAR46) {
uint VAR251 =2;
bool VAR252=false;
bytes memory VAR4 = bytes(VAR171);
uint VAR78;
VAR46 = 0;
for (VAR78 = 0; VAR78 < VAR4.VAR81; VAR78++) {
if (VAR252) {VAR251 = VAR251-1;}
if (uint(VAR4[VAR78]) == 46){VAR252 = true;}
uint VAR5 = uint(VAR4[VAR78]);
if (VAR5 >= 48 && VAR5 <= 57) {VAR46 = VAR46 * 10 + (VAR5 - 48);}
if (VAR252 && VAR251 == 0){return VAR46;}
}
while (VAR251!=0) {
VAR46 = VAR46*10;
VAR251=VAR251-1;
}
}
function FUN83(bytes32 VAR253, address VAR246) external constant returns (uint, uint, uint, bool, uint) {
return (VAR215[VAR253].VAR205, VAR215[VAR253].VAR203, VAR215[VAR253].VAR204, VAR215[VAR253].VAR207, VAR216[VAR246].VAR213[VAR253]);
}
function FUN84() external constant returns (uint) {
return ((VAR215[VAR226.VAR195].VAR205) + (VAR215[VAR226.VAR196].VAR205) + (VAR215[VAR226.VAR197].VAR205));
}
function FUN85() external onlyOwner {
require(VAR233 > VAR227.VAR187 + VAR227.VAR189);
require((VAR227.VAR183 && !VAR227.VAR184)
|| (VAR227.VAR184 && !VAR227.VAR185));
VAR227.VAR186 = true;
VAR227.VAR185 = true;
VAR227.VAR190=FUN77(VAR233);
VAR181.FUN63();
}
function FUN86() external onlyOwner{
require((VAR227.VAR185 && VAR233 > VAR227.VAR187 + VAR227.VAR189 + (30 VAR254))
|| (VAR227.VAR186 && VAR233 > VAR227.VAR190 + (30 VAR254)));
VAR181.VAR245.value(address(this).VAR240)();
}
}
1
---------------------------------
63 0x4dd68a6c27359e5640fa6dcaf13631398c5613f1.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
interface VAR6 {
function FUN4(address VAR3, address[] VAR7, address[] VAR8) external;
function FUN5() external view returns (address[]);
function FUN6() external view returns (address[]);
}
contract BaseModule is VAR2 {
ModuleRegistry internal VAR9;
event FUN7(bytes32 VAR10);
event FUN8(address VAR11);
constructor(ModuleRegistry VAR12, bytes32 VAR13) public {
VAR9 = VAR12;
emit FUN7(VAR13);
}
modifier FUN9(BaseWallet VAR3) {
require(msg.sender == address(VAR3), "");
VAR14;
}
modifier onlyOwner(BaseWallet VAR3) {
require(msg.sender == address(this) || FUN10(VAR3, msg.sender), "");
VAR14;
}
modifier FUN11(BaseWallet VAR3) {
require(FUN10(VAR3, msg.sender), "");
VAR14;
}
function FUN1(BaseWallet VAR3) external FUN9(VAR3) {
emit FUN8(VAR3);
}
function FUN2(BaseWallet VAR3, Module VAR4) external FUN11(VAR3) {
require(VAR9.FUN12(VAR4), "");
VAR3.FUN13(VAR4, true);
}
function FUN3(address VAR5) external {
uint VAR15 = FUN14(VAR5).FUN15(address(this));
FUN14(VAR5).transfer(address(VAR9), VAR15);
}
function FUN10(BaseWallet VAR3, address VAR16) internal view returns (bool) {
return VAR3.FUN16() == VAR16;
}
}
contract RelayerModule is VAR2 {
uint256 constant internal VAR17 = 10000;
mapping (address => VAR18) public VAR19;
struct VAR18 {
uint256 VAR20;
mapping (bytes32 => bool) VAR21;
}
event FUN17(address indexed VAR11, bool indexed VAR22, bytes32 VAR23);
modifier VAR24 {
require(msg.sender == address(this), "");
VAR14;
}
function FUN18(BaseWallet VAR3, bytes VAR25) internal view returns (uint256);
function FUN19(BaseWallet VAR3, bytes VAR25, bytes32 VAR26, bytes VAR27) internal view returns (bool);
function FUN20(
BaseWallet VAR3,
bytes VAR25,
uint256 VAR28,
bytes VAR27,
uint256 VAR29,
uint256 VAR30
)
external
returns (bool VAR22)
{
uint VAR31 = FUN21();
bytes32 VAR32 = FUN22(address(this), VAR3, 0, VAR25, VAR28, VAR29, VAR30);
require(FUN23(VAR3, VAR28, VAR32), "");
require(FUN24(address(VAR3), VAR25), "");
uint256 VAR33 = FUN18(VAR3, VAR25);
if((VAR33 * 65) == VAR27.VAR34) {
if(FUN25(VAR3, VAR30, VAR29, VAR33)) {
if(VAR33 == 0 || FUN19(VAR3, VAR25, VAR32, VAR27)) {
VAR22 = address(this).call(VAR25);
FUN26(VAR3, VAR31 - FUN21(), VAR29, VAR30, VAR33, msg.sender);
}
}
}
emit FUN17(VAR3, VAR22, VAR32);
}
function FUN27(BaseWallet VAR3) external view returns (uint256 VAR20) {
return VAR19[VAR3].VAR20;
}
function FUN22(
address VAR35,
address VAR36,
uint256 VAR37,
bytes VAR25,
uint256 VAR28,
uint256 VAR29,
uint256 VAR30
)
internal
pure
returns (bytes32)
{
return FUN28(
VAR38.FUN29(
"",
FUN28(VAR38.FUN29(FUN30(0x19), FUN30(0), VAR35, VAR36, VAR37, VAR25, VAR28, VAR29, VAR30))
));
}
function FUN23(BaseWallet VAR3, uint256 VAR28, bytes32 VAR26) internal returns (bool) {
if(VAR19[VAR3].VAR21[VAR26] == true) {
return false;
}
VAR19[VAR3].VAR21[VAR26] = true;
return true;
}
function FUN31(BaseWallet VAR3, uint256 VAR28) internal returns (bool) {
if(VAR28 <= VAR19[VAR3].VAR20) {
return false;
}
uint256 VAR39 = (VAR28 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;
if(VAR39 > VAR40.VAR41 + VAR17) {
return false;
}
VAR19[VAR3].VAR20 = VAR28;
return true;
}
function FUN32(bytes32 VAR42, bytes VAR27, uint VAR43) internal pure returns (address) {
uint8 VAR44;
bytes32 VAR45;
bytes32 VAR46;
VAR47 {
VAR45 := FUN33(FUN34(VAR27, FUN34(0x20,FUN35(0x41,VAR43))))
VAR46 := FUN33(FUN34(VAR27, FUN34(0x40,FUN35(0x41,VAR43))))
VAR44 := FUN36(FUN33(FUN34(VAR27, FUN34(0x41,FUN35(0x41,VAR43)))), 0xff)
}
require(VAR44 == 27 || VAR44 == 28);
return FUN37(VAR42, VAR44, VAR45, VAR46);
}
function FUN26(BaseWallet VAR3, uint VAR48, uint VAR29, uint VAR30, uint VAR27, address VAR49) internal {
uint256 VAR50 = 29292 + VAR48;
if(VAR29 > 0 && VAR27 > 1 && VAR50 <= VAR30) {
if(VAR29 > VAR51.VAR52) {
VAR50 = VAR50 * VAR51.VAR52;
}
else {
VAR50 = VAR50 * VAR29;
}
VAR3.FUN38(VAR49, VAR50, "");
}
}
function FUN25(BaseWallet VAR3, uint VAR48, uint VAR29, uint VAR27) internal view returns (bool) {
if(VAR29 > 0
&& VAR27 > 1
&& (address(VAR3).VAR53 < VAR48 * VAR29 || VAR3.FUN39(this) == false)) {
return false;
}
return true;
}
function FUN24(address VAR3, bytes VAR25) private pure returns (bool) {
require(VAR25.VAR34 >= 36, "");
address VAR54;
VAR47 {
VAR54 := FUN33(FUN34(VAR25, 0x24))
}
return VAR54 == VAR3;
}
function FUN40(bytes VAR25) internal pure returns (bytes4 VAR55) {
require(VAR25.VAR34 >= 4, "");
VAR47 {
VAR55 := FUN33(FUN34(VAR25, 0x20))
}
}
}
contract OnlyOwnerModule is VAR56, VAR57 {
function FUN23(BaseWallet VAR3, uint256 VAR28, bytes32 VAR26) internal returns (bool) {
return FUN31(VAR3, VAR28);
}
function FUN19(BaseWallet VAR3, bytes VAR25, bytes32 VAR26, bytes VAR27) internal view returns (bool) {
address VAR58 = FUN32(VAR26, VAR27, 0);
return FUN10(VAR3, VAR58);
}
function FUN18(BaseWallet VAR3, bytes VAR25) internal view returns (uint256) {
return 1;
}
}
contract VAR59 {
function FUN41() public view returns (uint);
function FUN42() public view returns (uint);
function FUN15(address VAR60) public view returns (uint VAR53);
function FUN43(address VAR60, address VAR61) public view returns (uint VAR62);
function transfer(address VAR63, uint VAR64) public returns (bool VAR22);
function FUN44(address VAR61, uint VAR64) public returns (bool VAR22);
function FUN45(address VAR65, address VAR63, uint VAR64) public returns (bool VAR22);
}
contract VAR66 {
address public VAR67;
event FUN46(address indexed VAR68);
modifier onlyOwner {
require(msg.sender == VAR67, "");
VAR14;
}
constructor() public {
VAR67 = msg.sender;
}
function FUN47(address VAR68) external onlyOwner {
require(VAR68 != address(0), "");
VAR67 = VAR68;
emit FUN46(VAR68);
}
}
contract ModuleRegistry is VAR66 {
mapping (address => VAR69) internal VAR70;
mapping (address => VAR69) internal VAR71;
event FUN48(address indexed VAR72, bytes32 VAR10);
event FUN49(address VAR72);
event FUN50(address indexed VAR73, bytes32 VAR10);
event FUN51(address VAR73);
struct VAR69 {
bool VAR74;
bytes32 VAR10;
}
function FUN52(address VAR4, bytes32 VAR13) external onlyOwner {
require(!VAR70[VAR4].VAR74, "");
VAR70[VAR4] = FUN53({VAR74: true, VAR10: VAR13});
emit FUN48(VAR4, VAR13);
}
function FUN54(address VAR4) external onlyOwner {
require(VAR70[VAR4].VAR74, "");
delete VAR70[VAR4];
emit FUN49(VAR4);
}
function FUN55(address VAR75, bytes32 VAR13) external onlyOwner {
require(!VAR71[VAR75].VAR74, "");
VAR71[VAR75] = FUN53({VAR74: true, VAR10: VAR13});
emit FUN50(VAR75, VAR13);
}
function FUN56(address VAR75) external onlyOwner {
require(VAR71[VAR75].VAR74, "");
delete VAR71[VAR75];
emit FUN51(VAR75);
}
function FUN3(address VAR5) external onlyOwner {
uint VAR15 = FUN14(VAR5).FUN15(address(this));
FUN14(VAR5).transfer(msg.sender, VAR15);
}
function FUN57(address VAR4) external view returns (bytes32) {
return VAR70[VAR4].VAR10;
}
function FUN58(address VAR75) external view returns (bytes32) {
return VAR71[VAR75].VAR10;
}
function FUN12(address VAR4) external view returns (bool) {
return VAR70[VAR4].VAR74;
}
function FUN12(address[] VAR76) external view returns (bool) {
for(uint VAR77 = 0; VAR77 < VAR76.VAR34; VAR77++) {
if (!VAR70[VAR76[VAR77]].VAR74) {
return false;
}
}
return true;
}
function FUN59(address VAR75) external view returns (bool) {
return VAR71[VAR75].VAR74;
}
}
contract VAR78 {
address public VAR79;
address public VAR67;
mapping (address => bool) public VAR80;
mapping (bytes4 => address) public VAR81;
uint public VAR70;
event FUN60(address indexed VAR72, bool value);
event FUN61(address indexed VAR72, bytes4 indexed VAR82);
event FUN62(address indexed VAR72, address indexed VAR83, uint indexed value, bytes VAR84);
event FUN63(uint indexed value, address indexed sender, bytes VAR84);
event FUN46(address VAR67);
modifier VAR85 {
require(VAR80[msg.sender], "");
VAR14;
}
function FUN1(address VAR86, address[] VAR76) external {
require(VAR67 == address(0) && VAR70 == 0, "");
require(VAR76.VAR34 > 0, "");
VAR67 = VAR86;
VAR70 = VAR76.VAR34;
for(uint256 VAR77 = 0; VAR77 < VAR76.VAR34; VAR77++) {
require(VAR80[VAR76[VAR77]] == false, "");
VAR80[VAR76[VAR77]] = true;
FUN64(VAR76[VAR77]).FUN1(this);
emit FUN60(VAR76[VAR77], true);
}
}
function FUN13(address VAR4, bool VAR37) external VAR85 {
if (VAR80[VAR4] != VAR37) {
if(VAR37 == true) {
VAR70 += 1;
VAR80[VAR4] = true;
FUN64(VAR4).FUN1(this);
}
else {
VAR70 -= 1;
require(VAR70 > 0, "");
delete VAR80[VAR4];
}
emit FUN60(VAR4, VAR37);
}
}
function FUN65(address VAR4, bytes4 VAR87) external VAR85 {
require(VAR80[VAR4], "");
VAR81[VAR87] = VAR4;
emit FUN61(VAR4, VAR87);
}
function FUN66(address VAR68) external VAR85 {
require(VAR68 != address(0), "");
VAR67 = VAR68;
emit FUN46(VAR68);
}
function FUN38(address VAR88, uint VAR37, bytes VAR25) external VAR85 {
require(VAR88.call.value(VAR37)(VAR25), "");
emit FUN62(msg.sender, VAR88, VAR37, VAR25);
}
function() public payable {
if(msg.VAR84.VAR34 > 0) {
address VAR72 = VAR81[msg.VAR89];
if(VAR72 == address(0)) {
emit FUN63(msg.value, msg.sender, msg.VAR84);
}
else {
require(VAR80[VAR72], "");
VAR47 {
FUN67(0, 0, FUN68())
let VAR90 := FUN69(VAR91, VAR72, 0, FUN68(), 0, 0)
FUN70(0, 0, FUN71())
switch VAR90
case 0 {revert(0, FUN71())}
default {return (0, FUN71())}
}
}
}
}
}
contract ModuleManager is VAR56, VAR57, VAR92 {
bytes32 constant VAR93 = "";
constructor(ModuleRegistry VAR12) FUN72(VAR12, VAR93) public {
}
function FUN4(BaseWallet VAR3, Upgrader VAR75) external onlyOwner(VAR3) {
require(VAR9.FUN59(VAR75), "");
address[] memory VAR94 = VAR75.FUN5();
address[] memory VAR95 = VAR75.FUN6();
bytes memory VAR96 = VAR38.FUN73("", VAR3, VAR94, VAR95);
require(address(VAR75).FUN74(VAR96), "");
}
}
1
---------------------------------
64 0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address=>uint256) public VAR3;
uint public VAR4;
LogFile VAR5;
bool VAR6;
function FUN1(uint VAR7)
public
{
require(!VAR6);
VAR4 = VAR7;
}
function FUN2(address VAR8)
public
{
require(!VAR6);
VAR5 = FUN3(VAR8);
}
function FUN4()
public
{
VAR6 = true;
}
function FUN5()
public
payable
{
VAR3[msg.sender]+= msg.value;
VAR5.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR9)
public
payable
{
if(VAR3[msg.sender]>=VAR4 && VAR3[msg.sender]>=VAR9)
{
if(msg.sender.call.value(VAR9)())
{
VAR3[msg.sender]-=VAR9;
VAR5.FUN6(msg.sender,VAR9,"");
}
}
}
function()
public
payable
{
FUN5();
}
}
contract VAR10
{
struct VAR11
{
address VAR12;
string  VAR13;
uint VAR14;
uint  VAR15;
}
VAR11[] public VAR16;
Message VAR17;
function FUN6(address VAR18,uint VAR7,string VAR19)
public
{
VAR17.VAR12 = VAR18;
VAR17.VAR15 = VAR20;
VAR17.VAR14 = VAR7;
VAR17.VAR13 = VAR19;
VAR16.FUN8(VAR17);
}
}
1
---------------------------------
65 0x4ee1ba168551379fd8a59e2e918ff9ee109a6abf.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(uint256 VAR3, address VAR4, bytes32 VAR5, uint256 VAR6) external;
function FUN2(uint256 VAR3, bytes32 VAR5) external;
}
interface VAR7 {
function FUN3() external view returns(uint256);
function FUN4() external view returns(uint256);
function FUN5() external view returns(uint256);
function FUN6() external view returns(uint256);
function FUN7(address VAR8) external view returns(bytes32);
function FUN8(address VAR8) external view returns(bool);
function FUN9(address VAR8) external view returns(bool);
}
interface VAR9 {
function FUN10() external payable;
}
contract VAR10 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR11;
TeamDreamHubInterface public VAR12;
TeamDreamInterface public VAR13;
VAR14.Data private VAR15;
function FUN11(bytes32 VAR16) private returns (bool) {return(VAR14.FUN12(VAR15, VAR13.FUN4(), VAR16));}
function FUN13(bytes32 VAR16) private {VAR14.FUN13(VAR15, VAR16);}
function FUN14(bytes32 VAR16) FUN15() public {VAR14.FUN13(VAR15, VAR16);}
function FUN16(bytes32 VAR16) FUN15() public view returns(bytes32, uint256) {return(VAR14.FUN17(VAR15, VAR16), VAR14.FUN18(VAR15, VAR16));}
function FUN19(bytes32 VAR16, uint256 VAR17, uint256 VAR18, uint256 VAR19) FUN15() public view returns(address, address, address) {return(VAR14.FUN20(VAR15, VAR16, VAR17), VAR14.FUN20(VAR15, VAR16, VAR18), VAR14.FUN20(VAR15, VAR16, VAR19));}
function FUN21(bytes32 VAR16, uint256 VAR17, uint256 VAR18, uint256 VAR19) FUN15() public view returns(bytes32, bytes32, bytes32) {return(VAR13.FUN7(VAR14.FUN20(VAR15, VAR16, VAR17)), VAR13.FUN7(VAR14.FUN20(VAR15, VAR16, VAR18)), VAR13.FUN7(VAR14.FUN20(VAR15, VAR16, VAR19)));}
uint256 public VAR20 = 10 VAR21;
mapping(uint256 => VAR2) public VAR22;
mapping(address => bytes32) public VAR23;
mapping(address => uint256) public VAR24;
uint256 public VAR25;
uint256 public VAR26;
mapping (address => uint256) public VAR27;
mapping (bytes32 => uint256) public VAR28;
mapping (uint256 => VAR29) public VAR30;
mapping (uint256 => mapping (bytes32 => bool)) public VAR31;
mapping (uint256 => mapping (uint256 => bytes32)) public VAR32;
struct VAR29 {
address VAR33;
bytes32 VAR34;
uint256 VAR35;
uint256 VAR36;
}
constructor(address VAR37, address VAR38)
public
{
VAR11 = msg.sender;
VAR12 = FUN22(VAR37);
VAR13 = FUN23(VAR38);
VAR30[1].VAR33 = VAR11;
VAR30[1].VAR34 = "";
VAR30[1].VAR36 = 1;
VAR27[VAR11] = 1;
VAR28[""] = 1;
VAR31[1][""] = true;
VAR32[1][1] = "";
VAR30[2].VAR33 = 0xEd5E1C52B48C8a6cfEc77DeB57Be61D097d2eE28;
VAR30[2].VAR34 = "";
VAR30[2].VAR36 = 1;
VAR27[0xEd5E1C52B48C8a6cfEc77DeB57Be61D097d2eE28] = 2;
VAR28[""] = 2;
VAR31[2][""] = true;
VAR32[2][1] = "";
VAR30[3].VAR33 = 0x059743e7B1086c852e0459ded4E8Bc254E7d93CD;
VAR30[3].VAR34 = "";
VAR30[3].VAR36 = 1;
VAR27[0x059743e7B1086c852e0459ded4E8Bc254E7d93CD] = 3;
VAR28[""] = 3;
VAR31[3][""] = true;
VAR32[3][1] = "";
VAR26 = 3;
}
modifier FUN24() {
address VAR4 = msg.sender;
require (VAR4 == VAR39.VAR40);
uint256 VAR41;
VAR42 {VAR41 := FUN25(VAR4)}
require(VAR41 == 0, "");
VAR43;
}
modifier FUN15()
{
require(VAR13.FUN9(msg.sender) == true, "");
VAR43;
}
modifier FUN26()
{
require(VAR24[msg.sender] != 0);
VAR43;
}
event VAR44
(
uint256 indexed VAR45,
address indexed VAR46,
bytes32 indexed VAR47,
bool VAR48,
uint256 VAR49,
address VAR50,
bytes32 VAR51,
uint256 VAR52,
uint256 VAR53
);
function FUN27(string VAR54)
public
view
returns(bool)
{
bytes32 VAR5 = VAR54.FUN28();
if (VAR28[VAR5] == 0)
return (true);
else
return (false);
}
function FUN29(string VAR55, uint256 VAR56, bool VAR57)
FUN24()
public
payable
{
require (msg.value >= VAR20, "");
bytes32 VAR5 = VAR58.FUN28(VAR55);
address VAR4 = msg.sender;
bool VAR59 = FUN30(VAR4);
uint256 VAR3 = VAR27[VAR4];
if (VAR56 != 0 && VAR56 != VAR30[VAR3].VAR35 && VAR56 != VAR3)
{
VAR30[VAR3].VAR35 = VAR56;
} else if (VAR56 == VAR3) {
VAR56 = 0;
}
FUN31(VAR3, VAR4, VAR56, VAR5, VAR59, VAR57);
}
function FUN32(string VAR55, address VAR56, bool VAR57)
FUN24()
public
payable
{
require (msg.value >= VAR20, "");
bytes32 VAR5 = VAR58.FUN28(VAR55);
address VAR4 = msg.sender;
bool VAR59 = FUN30(VAR4);
uint256 VAR3 = VAR27[VAR4];
uint256 VAR60;
if (VAR56 != address(0) && VAR56 != VAR4)
{
VAR60 = VAR27[VAR56];
if (VAR60 != VAR30[VAR3].VAR35)
{
VAR30[VAR3].VAR35 = VAR60;
}
}
FUN31(VAR3, VAR4, VAR60, VAR5, VAR59, VAR57);
}
function FUN33(string VAR55, bytes32 VAR56, bool VAR57)
FUN24()
public
payable
{
require (msg.value >= VAR20, "");
bytes32 VAR5 = VAR58.FUN28(VAR55);
address VAR4 = msg.sender;
bool VAR59 = FUN30(VAR4);
uint256 VAR3 = VAR27[VAR4];
uint256 VAR60;
if (VAR56 != "" && VAR56 != VAR5)
{
VAR60 = VAR28[VAR56];
if (VAR60 != VAR30[VAR3].VAR35)
{
VAR30[VAR3].VAR35 = VAR60;
}
}
FUN31(VAR3, VAR4, VAR60, VAR5, VAR59, VAR57);
}
function FUN34(uint256 VAR61)
FUN24()
public
{
require(VAR61 <= VAR25, "");
address VAR4 = msg.sender;
uint256 VAR3 = VAR27[VAR4];
require(VAR3 != 0, "");
uint256 VAR62 = VAR30[VAR3].VAR36;
VAR22[VAR61].FUN1(VAR3, VAR4, VAR30[VAR3].VAR34, VAR30[VAR3].VAR35);
if (VAR62 > 1)
for (uint256 VAR63 = 1; VAR63 <= VAR62; VAR63++)
VAR22[VAR61].FUN2(VAR3, VAR32[VAR3][VAR63]);
}
function FUN35()
FUN24()
public
{
address VAR4 = msg.sender;
uint256 VAR3 = VAR27[VAR4];
require(VAR3 != 0, "");
uint256 VAR6 = VAR30[VAR3].VAR35;
uint256 VAR62 = VAR30[VAR3].VAR36;
bytes32 VAR5 = VAR30[VAR3].VAR34;
for (uint256 VAR64 = 1; VAR64 <= VAR25; VAR64++)
{
VAR22[VAR64].FUN1(VAR3, VAR4, VAR5, VAR6);
if (VAR62 > 1)
for (uint256 VAR63 = 1; VAR63 <= VAR62; VAR63++)
VAR22[VAR64].FUN2(VAR3, VAR32[VAR3][VAR63]);
}
}
function FUN36(string VAR55)
FUN24()
public
{
bytes32 VAR5 = VAR55.FUN28();
uint256 VAR3 = VAR27[msg.sender];
require(VAR31[VAR3][VAR5] == true, "");
VAR30[VAR3].VAR34 = VAR5;
}
function FUN31(uint256 VAR3, address VAR4, uint256 VAR60, bytes32 VAR5, bool VAR59, bool VAR57)
private
{
if (VAR28[VAR5] != 0)
require(VAR31[VAR3][VAR5] == true, "");
VAR30[VAR3].VAR34 = VAR5;
VAR28[VAR5] = VAR3;
if (VAR31[VAR3][VAR5] == false)
{
VAR31[VAR3][VAR5] = true;
VAR30[VAR3].VAR36++;
VAR32[VAR3][VAR30[VAR3].VAR36] = VAR5;
}
VAR12.VAR65.value(address(this).VAR66)();
if (VAR57 == true)
for (uint256 VAR64 = 1; VAR64 <= VAR25; VAR64++)
VAR22[VAR64].FUN1(VAR3, VAR4, VAR5, VAR60);
emit FUN37(VAR3, VAR4, VAR5, VAR59, VAR60, VAR30[VAR60].VAR33, VAR30[VAR60].VAR34, msg.value, VAR67);
}
function FUN30(address VAR4)
private
returns (bool)
{
if (VAR27[VAR4] == 0)
{
VAR26++;
VAR27[VAR4] = VAR26;
VAR30[VAR26].VAR33 = VAR4;
return (true);
} else {
return (false);
}
}
function FUN38(address VAR4)
FUN26()
external
returns (uint256)
{
FUN30(VAR4);
return (VAR27[VAR4]);
}
function FUN39(uint256 VAR3)
external
view
returns (bytes32)
{
return (VAR30[VAR3].VAR34);
}
function FUN40(uint256 VAR3)
external
view
returns (uint256)
{
return (VAR30[VAR3].VAR35);
}
function FUN41(uint256 VAR3)
external
view
returns (address)
{
return (VAR30[VAR3].VAR33);
}
function FUN42()
external
view
returns (uint256)
{
return(VAR20);
}
function FUN43(address VAR4, bytes32 VAR5, uint256 VAR56, bool VAR57)
FUN26()
external
payable
returns(bool, uint256)
{
require (msg.value >= VAR20, "");
bool VAR59 = FUN30(VAR4);
uint256 VAR3 = VAR27[VAR4];
uint256 VAR60 = VAR56;
if (VAR60 != 0 && VAR60 != VAR30[VAR3].VAR35 && VAR60 != VAR3)
{
VAR30[VAR3].VAR35 = VAR60;
} else if (VAR60 == VAR3) {
VAR60 = 0;
}
FUN31(VAR3, VAR4, VAR60, VAR5, VAR59, VAR57);
return(VAR59, VAR60);
}
function FUN44(address VAR4, bytes32 VAR5, address VAR56, bool VAR57)
FUN26()
external
payable
returns(bool, uint256)
{
require (msg.value >= VAR20, "");
bool VAR59 = FUN30(VAR4);
uint256 VAR3 = VAR27[VAR4];
uint256 VAR60;
if (VAR56 != address(0) && VAR56 != VAR4)
{
VAR60 = VAR27[VAR56];
if (VAR60 != VAR30[VAR3].VAR35)
{
VAR30[VAR3].VAR35 = VAR60;
}
}
FUN31(VAR3, VAR4, VAR60, VAR5, VAR59, VAR57);
return(VAR59, VAR60);
}
function FUN45(address VAR4, bytes32 VAR5, bytes32 VAR56, bool VAR57)
FUN26()
external
payable
returns(bool, uint256)
{
require (msg.value >= VAR20, "");
bool VAR59 = FUN30(VAR4);
uint256 VAR3 = VAR27[VAR4];
uint256 VAR60;
if (VAR56 != "" && VAR56 != VAR5)
{
VAR60 = VAR28[VAR56];
if (VAR60 != VAR30[VAR3].VAR35)
{
VAR30[VAR3].VAR35 = VAR60;
}
}
FUN31(VAR3, VAR4, VAR60, VAR5, VAR59, VAR57);
return(VAR59, VAR60);
}
function FUN46(address VAR68, string VAR69)
FUN15()
public
{
require(VAR24[VAR68] == 0, "");
if (FUN11("") == true)
{FUN13("");
VAR25++;
bytes32 VAR5 = VAR69.FUN28();
VAR24[VAR68] = VAR25;
VAR23[VAR68] = VAR5;
VAR22[VAR25] = FUN47(VAR68);
VAR22[VAR25].FUN1(1, VAR30[1].VAR33, VAR30[1].VAR34, 0);
VAR22[VAR25].FUN1(2, VAR30[2].VAR33, VAR30[2].VAR34, 0);
VAR22[VAR25].FUN1(3, VAR30[3].VAR33, VAR30[3].VAR34, 0);
}
}
function FUN48(uint256 VAR70)
FUN15()
public
{
if (FUN11("") == true)
{FUN13("");
VAR20 = VAR70;
}
}
}
library VAR58 {
function FUN28(string VAR71)
internal
pure
returns(bytes32)
{
bytes memory VAR72 = bytes(VAR71);
uint256 VAR73 = VAR72.VAR74;
require (VAR73 <= 32 && VAR73 > 0, "");
require(VAR72[0] != 0x20 && VAR72[VAR73-1] != 0x20, "");
if (VAR72[0] == 0x30)
{
require(VAR72[1] != 0x78, "");
require(VAR72[1] != 0x58, "");
}
bool VAR75;
for (uint256 VAR64 = 0; VAR64 < VAR73; VAR64++)
{
if (VAR72[VAR64] > 0x40 && VAR72[VAR64] < 0x5b)
{
VAR72[VAR64] = FUN49(uint(VAR72[VAR64]) + 32);
if (VAR75 == false)
VAR75 = true;
} else {
require
(
VAR72[VAR64] == 0x20 ||
(VAR72[VAR64] > 0x60 && VAR72[VAR64] < 0x7b) ||
(VAR72[VAR64] > 0x2f && VAR72[VAR64] < 0x3a),
""
);
if (VAR72[VAR64] == 0x20)
require( VAR72[VAR64+1] != 0x20, "");
if (VAR75 == false && (VAR72[VAR64] < 0x30 || VAR72[VAR64] > 0x39))
VAR75 = true;
}
}
require(VAR75 == true, "");
bytes32 VAR76;
VAR42 {
VAR76 := FUN50(FUN51(VAR72, 32))
}
return (VAR76);
}
}
library VAR77 {
function FUN52(uint256 VAR78, uint256 VAR79)
internal
pure
returns (uint256 VAR80)
{
if (VAR78 == 0) {
return 0;
}
VAR80 = VAR78 * VAR79;
require(VAR80 / VAR78 == VAR79, "");
return VAR80;
}
function FUN53(uint256 VAR78, uint256 VAR79)
internal
pure
returns (uint256)
{
require(VAR79 <= VAR78, "");
return VAR78 - VAR79;
}
function FUN51(uint256 VAR78, uint256 VAR79)
internal
pure
returns (uint256 VAR80)
{
VAR80 = VAR78 + VAR79;
require(VAR80 >= VAR78, "");
return VAR80;
}
function FUN54(uint256 VAR81)
internal
pure
returns (uint256 VAR82)
{
uint256 VAR83 = ((FUN51(VAR81,1)) / 2);
VAR82 = VAR81;
while (VAR83 < VAR82)
{
VAR82 = VAR83;
VAR83 = ((FUN51((VAR81 / VAR83),VAR83)) / 2);
}
}
function FUN55(uint256 VAR81)
internal
pure
returns (uint256)
{
return (FUN52(VAR81,VAR81));
}
function FUN56(uint256 VAR81, uint256 VAR82)
internal
pure
returns (uint256)
{
if (VAR81==0)
return (0);
else if (VAR82==0)
return (1);
else
{
uint256 VAR83 = VAR81;
for (uint256 VAR64=1; VAR64 < VAR82; VAR64++)
VAR83 = FUN52(VAR83,VAR81);
return (VAR83);
}
}
}
library VAR14 {
struct VAR84
{
mapping (bytes32 => VAR85) VAR86;
}
struct VAR85
{
bytes32 VAR87;
uint256 VAR88;
mapping (address => bool) VAR89;
mapping (uint256 => address) VAR90;
}
function FUN12(Data storage VAR91, uint256 VAR92, bytes32 VAR16)
internal
returns(bool)
{
bytes32 VAR93 = FUN57(VAR16);
uint256 VAR94 = VAR91.VAR86[VAR93].VAR88;
address VAR95 = msg.sender;
bytes32 VAR96 = FUN58(msg.VAR97);
if (VAR94 == 0)
{
VAR91.VAR86[VAR93].VAR87 = VAR96;
VAR91.VAR86[VAR93].VAR89[VAR95] = true;
VAR91.VAR86[VAR93].VAR90[VAR94] = VAR95;
VAR91.VAR86[VAR93].VAR88 += 1;
if (VAR91.VAR86[VAR93].VAR88 == VAR92) {
return(true);
}
} else if (VAR91.VAR86[VAR93].VAR87 == VAR96) {
if (VAR91.VAR86[VAR93].VAR89[VAR95] == false)
{
VAR91.VAR86[VAR93].VAR89[VAR95] = true;
VAR91.VAR86[VAR93].VAR90[VAR94] = VAR95;
VAR91.VAR86[VAR93].VAR88 += 1;
}
if (VAR91.VAR86[VAR93].VAR88 == VAR92) {
return(true);
}
}
}
function FUN13(Data storage VAR91, bytes32 VAR16)
internal
{
bytes32 VAR93 = FUN57(VAR16);
address VAR95;
for (uint256 VAR64=0; VAR64 < VAR91.VAR86[VAR93].VAR88; VAR64++) {
VAR95 = VAR91.VAR86[VAR93].VAR90[VAR64];
delete VAR91.VAR86[VAR93].VAR89[VAR95];
delete VAR91.VAR86[VAR93].VAR90[VAR64];
}
delete VAR91.VAR86[VAR93];
}
function FUN57(bytes32 VAR16)
private
view
returns(bytes32)
{
return(FUN58(VAR98.FUN59(VAR16,this)));
}
function FUN17 (Data storage VAR91, bytes32 VAR16)
internal
view
returns (bytes32 VAR99)
{
bytes32 VAR93 = FUN57(VAR16);
return (VAR91.VAR86[VAR93].VAR87);
}
function FUN18 (Data storage VAR91, bytes32 VAR16)
internal
view
returns (uint256 VAR100)
{
bytes32 VAR93 = FUN57(VAR16);
return (VAR91.VAR86[VAR93].VAR88);
}
function FUN20 (Data storage VAR91, bytes32 VAR16, uint256 VAR101)
internal
view
returns (address VAR102)
{
require(VAR101 > 0, "");
bytes32 VAR93 = FUN57(VAR16);
return (VAR91.VAR86[VAR93].VAR90[VAR101 - 1]);
}
}
1
---------------------------------
66 0x4f86182ff4704330b0f169ed897d608b367015b7.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1() external payable;
}
interface VAR3 {
function FUN2(uint256 VAR4, address VAR5, bytes32 VAR6, uint256 VAR7) external;
function FUN3(uint256 VAR4, bytes32 VAR6) external;
}
contract VAR8 {
address public VAR9;
event FUN4(address indexed VAR10, address indexed VAR11);
constructor() public {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9, "");
VAR12;
}
function FUN5(address VAR13) public onlyOwner {
require(VAR13 != address(0), "");
VAR9 = VAR13;
emit FUN4(VAR9, VAR13);
}
}
contract PlayerBook is VAR8 {
using SafeMath for uint256;
using NameFilter for string;
FoundationInterface private VAR14 = FUN6(0xc91CA445AcdAe9EebAf003A64088cA29A694C3ae);
uint256 public VAR15 = 10 VAR16;
mapping(uint256 => VAR3) public VAR17;
mapping(address => bytes32) public VAR18;
mapping(address => uint256) public VAR19;
uint256 public VAR20;
uint256 public VAR21;
mapping (address => uint256) public VAR22;
mapping (bytes32 => uint256) public VAR23;
struct VAR24 {
address VAR25;
bytes32 VAR26;
uint256 VAR27;
uint256 VAR28;
}
mapping (uint256 => VAR24) public VAR29;
mapping (uint256 => mapping (bytes32 => bool)) public VAR30;
mapping (uint256 => mapping (uint256 => bytes32)) public VAR31;
event FUN7(
uint256 indexed VAR32,
address indexed VAR33,
bytes32 indexed VAR34,
bool VAR35,
uint256 VAR36,
address VAR37,
bytes32 VAR38,
uint256 VAR39,
uint256 VAR40
);
modifier FUN8() {
address VAR5 = msg.sender;
uint256 VAR41;
VAR42 {
VAR41 := FUN9(VAR5)
}
require(VAR41 == 0, "");
VAR12;
}
modifier FUN10() {
require(VAR19[msg.sender] != 0);
VAR12;
}
constructor() public {
VAR29[1].VAR25 = 0xD023964aE2f127c7f35dC5dD66BB5FbED3BC7E61;
VAR29[1].VAR26 = "";
VAR29[1].VAR28 = 1;
VAR22[0xD023964aE2f127c7f35dC5dD66BB5FbED3BC7E61] = 1;
VAR23[""] = 1;
VAR30[1][""] = true;
VAR31[1][1] = "";
VAR21 = 1;
}
function FUN11(address VAR43) public onlyOwner {
VAR14 = FUN6(VAR43);
}
function FUN12(string VAR44) public view returns(bool) {
bytes32 VAR6 = VAR44.FUN13();
if (VAR23[VAR6] == 0) {
return (true);
} else {
return (false);
}
}
function FUN14(string VAR45, uint256 VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
if (VAR46 != 0 && VAR46 != VAR29[VAR4].VAR27 && VAR46 != VAR4) {
VAR29[VAR4].VAR27 = VAR46;
} else if (VAR46 == VAR4) {
VAR46 = 0;
}
FUN16(VAR4, VAR5, VAR46, VAR6, VAR50, VAR47);
}
function FUN17(string VAR45, address VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != address(0) && VAR46 != VAR5) {
VAR51 = VAR22[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
}
function FUN18(string VAR45, bytes32 VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != "" && VAR46 != VAR6) {
VAR51 = VAR23[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
}
function FUN19(uint256 VAR52) public VAR48 {
require(VAR52 <= VAR20, "");
address VAR5 = msg.sender;
uint256 VAR4 = VAR22[VAR5];
require(VAR4 != 0, "");
VAR17[VAR52].FUN2(VAR4, VAR5, VAR29[VAR4].VAR26, VAR29[VAR4].VAR27);
uint256 VAR53 = VAR29[VAR4].VAR28;
if (VAR53 > 1) {
for (uint256 VAR54 = 1; VAR54 <= VAR53; VAR54++) {
VAR17[VAR52].FUN3(VAR4, VAR31[VAR4][VAR54]);
}
}
}
function FUN20() public VAR48 {
address VAR5 = msg.sender;
uint256 VAR4 = VAR22[VAR5];
require(VAR4 != 0, "");
uint256 VAR7 = VAR29[VAR4].VAR27;
uint256 VAR53 = VAR29[VAR4].VAR28;
bytes32 VAR6 = VAR29[VAR4].VAR26;
for (uint256 VAR55 = 1; VAR55 <= VAR20; VAR55++) {
VAR17[VAR55].FUN2(VAR4, VAR5, VAR6, VAR7);
if (VAR53 > 1) {
for (uint256 VAR54 = 1; VAR54 <= VAR53; VAR54++) {
VAR17[VAR55].FUN3(VAR4, VAR31[VAR4][VAR54]);
}
}
}
}
function FUN21(string VAR45) public VAR48 {
bytes32 VAR6 = VAR45.FUN13();
uint256 VAR4 = VAR22[msg.sender];
require(VAR30[VAR4][VAR6] == true, "");
VAR29[VAR4].VAR26 = VAR6;
}
function FUN16(uint256 VAR4, address VAR5, uint256 VAR51, bytes32 VAR6, bool VAR50, bool VAR47) private {
if (VAR23[VAR6] != 0) {
require(VAR30[VAR4][VAR6] == true, "");
}
VAR29[VAR4].VAR26 = VAR6;
VAR23[VAR6] = VAR4;
if (VAR30[VAR4][VAR6] == false) {
VAR30[VAR4][VAR6] = true;
VAR29[VAR4].VAR28++;
VAR31[VAR4][VAR29[VAR4].VAR28] = VAR6;
}
VAR14.VAR56.value(address(this).VAR57)();
if (VAR47 == true) {
for (uint256 VAR55 = 1; VAR55 <= VAR20; VAR55++) {
VAR17[VAR55].FUN2(VAR4, VAR5, VAR6, VAR51);
}
}
emit FUN7(VAR4, VAR5, VAR6, VAR50, VAR51, VAR29[VAR51].VAR25, VAR29[VAR51].VAR26, msg.value, VAR58);
}
function FUN15(address VAR5) private returns (bool) {
if (VAR22[VAR5] == 0) {
VAR21++;
VAR22[VAR5] = VAR21;
VAR29[VAR21].VAR25 = VAR5;
return (true);
} else {
return (false);
}
}
function FUN22(address VAR5) external isRegisteredGame returns (uint256) {
FUN15(VAR5);
return (VAR22[VAR5]);
}
function FUN23(uint256 VAR4) external view returns (bytes32) {
return (VAR29[VAR4].VAR26);
}
function FUN24(uint256 VAR4) external view returns (uint256) {
return (VAR29[VAR4].VAR27);
}
function FUN25(uint256 VAR4) external view returns (address) {
return (VAR29[VAR4].VAR25);
}
function FUN26() external view returns (uint256) {
return(VAR15);
}
function FUN27(address VAR5, bytes32 VAR6, uint256 VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51 = VAR46;
if (VAR51 != 0 && VAR51 != VAR29[VAR4].VAR27 && VAR51 != VAR4) {
VAR29[VAR4].VAR27 = VAR51;
} else if (VAR51 == VAR4) {
VAR51 = 0;
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN28(address VAR5, bytes32 VAR6, address VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != address(0) && VAR46 != VAR5) {
VAR51 = VAR22[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN29(address VAR5, bytes32 VAR6, bytes32 VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != "" && VAR46 != VAR6) {
VAR51 = VAR23[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN30(address VAR60, string VAR61) public onlyOwner {
require(VAR19[VAR60] == 0, "");
VAR20++;
bytes32 VAR6 = VAR61.FUN13();
VAR19[VAR60] = VAR20;
VAR18[VAR60] = VAR6;
VAR17[VAR20] = FUN31(VAR60);
VAR17[VAR20].FUN2(1, VAR29[1].VAR25, VAR29[1].VAR26, 0);
}
function FUN32(uint256 VAR62) public onlyOwner {
VAR15 = VAR62;
}
}
library VAR49 {
function FUN13(string VAR63) internal pure returns(bytes32) {
bytes memory VAR64 = bytes(VAR63);
uint256 VAR65 = VAR64.VAR66;
require (VAR65 <= 32 && VAR65 > 0, "");
require(VAR64[0] != 0x20 && VAR64[VAR65-1] != 0x20, "");
if (VAR64[0] == 0x30) {
require(VAR64[1] != 0x78, "");
require(VAR64[1] != 0x58, "");
}
bool VAR67;
for (uint256 VAR55 = 0; VAR55 < VAR65; VAR55++) {
if (VAR64[VAR55] > 0x40 && VAR64[VAR55] < 0x5b) {
VAR64[VAR55] = FUN33(uint(VAR64[VAR55]) + 32);
if (VAR67 == false) {
VAR67 = true;
}
} else {
require(VAR64[VAR55] == 0x20 || (VAR64[VAR55] > 0x60 && VAR64[VAR55] < 0x7b) || (VAR64[VAR55] > 0x2f && VAR64[VAR55] < 0x3a), "");
if (VAR64[VAR55] == 0x20) {
require( VAR64[VAR55 + 1] != 0x20, "");
}
if (VAR67 == false && (VAR64[VAR55] < 0x30 || VAR64[VAR55] > 0x39)) {
VAR67 = true;
}
}
}
require(VAR67 == true, "");
bytes32 VAR68;
VAR42 {
VAR68 := FUN34(FUN35(VAR64, 32))
}
return (VAR68);
}
}
library VAR69 {
function FUN35(uint256 VAR70, uint256 VAR71) internal pure returns (uint256 VAR72) {
VAR72 = VAR70 + VAR71;
require(VAR72 >= VAR70, "");
return VAR72;
}
}
1
---------------------------------
67 0x4fe60d660e2b2580eb2c6e8328cee66e159fa25c.sol
pragma VAR1 ^0.4.25;
interface VAR2  {
function() payable external;
function FUN1(address VAR3)
external
payable
;
function FUN2()
external
;
function FUN3()
external
view
returns(uint256);
function FUN4()
external;
function FUN5(address VAR4) external payable;
function FUN6(address VAR5) external;
function FUN7() external;
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN8(address indexed VAR9, address indexed VAR10);
constructor() public {
VAR7 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR11;
}
function FUN9(address VAR12) public onlyOwner {
VAR7 = VAR12;
}
}
library VAR13 {
function FUN10(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
VAR16 = VAR14 + VAR15;
require(VAR16 >= VAR14);
}
function FUN11(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
require(VAR15 <= VAR14);
VAR16 = VAR14 - VAR15;
}
function FUN12(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
VAR16 = VAR14 * VAR15;
require(VAR14 == 0 || VAR16 / VAR14 == VAR15);
}
function FUN13(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
require(VAR15 > 0);
VAR16 = VAR14 / VAR15;
}
}
contract Slaughter3D is  VAR6 {
using SafeMath for uint;
Snip3DInterface constant VAR17 = FUN14(0xA76daa02C1A6411c6c368f3A59f4f2257a460006);
function FUN15()
view
public
returns(uint256)
{
return ( address(this).VAR18)  ;
}
function FUN16()
view
public
returns(uint256)
{
return ( VAR17.FUN3())  ;
}
function FUN17 () onlyOwner public payable {
VAR17.VAR19.value(0.1 VAR20)(msg.sender);
}
function FUN18 () onlyOwner public {
VAR17.FUN4();
}
function FUN19 () onlyOwner public {
VAR17.FUN2();
}
function FUN20 () onlyOwner public {
msg.sender.transfer(address(this).VAR18);
}
}
1
---------------------------------
68 0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8.sol
pragma VAR1 ^0.4.11;
library VAR2
{
uint256 constant public VAR3 =
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
function FUN1() pure internal returns(uint256){
return VAR3;
}
function FUN2(uint VAR4, uint VAR5) internal returns(uint){
uint VAR6 = VAR4 * VAR5;
FUN3(VAR4 == 0 || VAR6 / VAR4 == VAR5);
return VAR6;
}
function FUN4(uint VAR4, uint VAR5) pure internal returns(uint){
uint VAR6 = VAR4 / VAR5;
return VAR6;
}
function FUN5(uint VAR4, uint VAR5) internal returns(uint){
FUN3(VAR5 <= VAR4);
return VAR4 - VAR5;
}
function FUN6(uint VAR4, uint VAR5) internal returns(uint){
uint VAR6 = VAR4 + VAR5;
FUN3(VAR6 >= VAR4);
return VAR6;
}
function FUN7(uint64 VAR4, uint64 VAR5) internal view returns(VAR7){
return VAR4 >= VAR5 ? VAR4 : VAR5;
}
function FUN8(uint64 VAR4, uint64 VAR5) internal view returns(VAR7){
return VAR4 < VAR5 ? VAR4 : VAR5;
}
function FUN9(uint256 VAR4, uint256 VAR5) internal view returns(uint256){
return VAR4 >= VAR5 ? VAR4 : VAR5;
}
function FUN10(uint256 VAR4, uint256 VAR5) internal view returns(uint256){
return VAR4 < VAR5 ? VAR4 : VAR5;
}
function FUN3(bool VAR8) internal {
if (!VAR8) {
revert();
}
}
}
contract VAR9 {
function FUN11() payable public returns(address) {
AuctionContract VAR10 = (new VAR11).value(msg.value)(3000, this);
return VAR10;
}
}
contract VAR11 {
using SafeMath for uint;
event FUN12(address VAR12, uint VAR13);
event FUN13(address VAR12, uint VAR13);
event FUN14(address VAR12, uint VAR13);
uint public VAR14 = 30;
uint public VAR15;
uint public VAR16;
uint public VAR17;
mapping (address => uint) public VAR18;
address public VAR19;
address public VAR20;
address public VAR21;
uint public VAR22;
uint public VAR23;
address public VAR24;
address public VAR25;
uint public VAR26 = 10000000000000000;
uint public VAR27 = 10000000000000000;
address public VAR28;
bool public VAR29;
constructor (uint VAR30, address VAR31) payable public{
assert(msg.value >= VAR26);
VAR23 = msg.value;
VAR28 = VAR31;
VAR16 = VAR30;
VAR15 = VAR32.VAR33.FUN6(VAR30);
VAR17 = 0;
VAR22 = 0;
VAR29 = true;
emit FUN14(this, VAR23);
}
function() public payable {
assert(VAR15 >= VAR32.VAR33);
uint value = VAR18[msg.sender];
value = value.FUN6(msg.value);
assert(msg.value >= VAR27);
assert(VAR22 < value);
VAR18[msg.sender] = value;
VAR22 = value;
if (msg.sender != VAR19) {
VAR20 = VAR19;
}
VAR19 = msg.sender;
VAR17 = VAR17.FUN6(1);
VAR15 = VAR15.FUN6(VAR14);
VAR21 = msg.sender;
emit FUN12(msg.sender, msg.value);
}
function FUN15() public {
assert(VAR19 != msg.sender);
assert(VAR20 != msg.sender);
uint value = VAR18[msg.sender];
assert(value != 0);
msg.sender.transfer(value);
VAR18[msg.sender] = 0;
emit FUN13(msg.sender, value);
}
function FUN16() public {
assert(VAR29);
assert(VAR15 < VAR32.VAR33);
assert(msg.sender == VAR21);
msg.sender.transfer(VAR23);
Auctioneer VAR34 = FUN17(VAR28);
if(VAR19 != address(0)) {
uint VAR35 = VAR18[VAR19];
if (VAR35 >= VAR26) {
address VAR36 = VAR34.VAR37.value(VAR35)();
VAR24 = VAR36;
}
}
if(VAR20 != address(0)) {
uint VAR38 = VAR18[VAR20];
if (VAR38 >= VAR26) {
address VAR39 = VAR34.VAR37.value(VAR38)();
VAR25 = VAR39;
}
}
VAR29 = false;
}
}
1
---------------------------------
69 0x53a39eef083c4a91e36145176cc9f52be29b7288.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function FUN1(address VAR3) public payable returns(uint256);
function FUN2() public;
}
contract VAR4 {
FairExchange VAR5 = FUN3(0xdE2b11b71AD892Ac3e47ce99D107788d65fE764e);
function () public payable {
}
function FUN4(uint256 VAR6) external {
for (uint256 VAR7 = 0; VAR7 < VAR6; VAR7++) {
if (address(this).VAR8 < 0.001 VAR9) {
break;
}
VAR5.VAR10.value(address(this).VAR8)(0x0);
VAR5.FUN2();
}
}
}
1
---------------------------------
70 0x55c44fbad82686afb0ca41cefb8d086cb937b2e6.sol
pragma VAR1 ^0.4.4;
contract VAR2 {
function transfer(address VAR3, uint VAR4) returns (bool);
function FUN1(address VAR5) returns(uint);
}
contract VAR6 {
address public VAR5;
function FUN2() {
VAR5 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR5) throw;
VAR7;
}
address VAR8;
function FUN3(address VAR9) onlyOwner {
VAR8 = VAR9;
}
function FUN4() {
if (msg.sender == VAR8) {
VAR5 = VAR8;
}
}
}
contract TokenReceivable is VAR6 {
event FUN5(address VAR10, address VAR11, uint VAR12);
function FUN6(address VAR13, address VAR3) onlyOwner returns (bool) {
Token VAR10 = FUN7(VAR13);
uint VAR14 = VAR10.FUN1(this);
if (VAR10.transfer(VAR3, VAR14)) {
FUN5(VAR13, VAR3, VAR14);
return true;
}
return false;
}
}
contract FunFairSale is VAR6, VAR15 {
uint public VAR16 = 1499436000;
uint public VAR17 = 1498140000;
uint public VAR18;
function FUN8() {}
function FUN9(uint VAR19) onlyOwner {
if (VAR19 > VAR16) throw;
VAR16 = VAR19;
}
function FUN10(uint VAR20) onlyOwner {
VAR18 = VAR20;
}
function () payable {
if (VAR21.VAR22 < VAR17 || VAR21.VAR22 >= VAR16) throw;
if (this.VAR14 > VAR18) {
VAR16 = VAR21.VAR22 - 1;
}
}
function FUN11() onlyOwner {
if (VAR21.VAR22 < VAR16) throw;
if (!VAR5.call.value(this.VAR14)()) throw;
}
function FUN12(uint VAR23, uint VAR24) onlyOwner {
if (VAR21.VAR22 >= VAR17) throw;
VAR17 = VAR23;
VAR16 = VAR24;
}
}
1
---------------------------------
71 0x561eac93c92360949ab1f1403323e6db345cbf31.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address=>uint256) public VAR3;
uint public VAR4;
LogFile VAR5;
bool VAR6;
function FUN1(uint VAR7)
public
{
if(VAR6)throw;
VAR4 = VAR7;
}
function FUN2(address VAR8)
public
{
if(VAR6)throw;
VAR5 = FUN3(VAR8);
}
function FUN4()
public
{
VAR6 = true;
}
function FUN5()
public
payable
{
VAR3[msg.sender]+= msg.value;
VAR5.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR9)
public
payable
{
if(VAR3[msg.sender]>=VAR4 && VAR3[msg.sender]>=VAR9)
{
if(msg.sender.call.value(VAR9)())
{
VAR3[msg.sender]-=VAR9;
VAR5.FUN6(msg.sender,VAR9,"");
}
}
}
function()
public
payable
{
FUN5();
}
}
contract VAR10
{
struct VAR11
{
address VAR12;
string  VAR13;
uint VAR14;
uint  VAR15;
}
VAR11[] public VAR16;
Message VAR17;
function FUN6(address VAR18,uint VAR7,string VAR19)
public
{
VAR17.VAR12 = VAR18;
VAR17.VAR15 = VAR20;
VAR17.VAR14 = VAR7;
VAR17.VAR13 = VAR19;
VAR16.FUN8(VAR17);
}
}
1
---------------------------------
72 0x56ba2ee7890461f463f7be02aac3099f6d5811a8.sol
pragma VAR1^0.4.11;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint VAR3, uint VAR4) internal returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint64 VAR3, uint64 VAR4) internal constant returns (VAR6) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN6(uint64 VAR3, uint64 VAR4) internal constant returns (VAR6) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN7(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN8(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function assert(bool VAR7) internal {
if (!VAR7) {
throw;
}
}
}
contract VAR8 {
uint public VAR9;
function FUN9(address VAR10) constant returns (uint);
function transfer(address VAR11, uint value);
event Transfer(address indexed VAR12, address indexed VAR11, uint value);
}
contract ERC20 is VAR8 {
function FUN10(address VAR13, address VAR14) constant returns (uint);
function FUN11(address VAR12, address VAR11, uint value);
function FUN12(address VAR14, uint value);
event FUN13(address indexed VAR13, address indexed VAR14, uint value);
}
contract BasicToken is VAR8 {
using SafeMath for uint;
mapping(address => uint) VAR15;
modifier FUN14(uint VAR16) {
if(msg.VAR17.VAR18 < VAR16 + 4) {
throw;
}
VAR19;
}
function transfer(address VAR20, uint VAR21) FUN14(2 * 32) {
VAR15[msg.sender] = VAR15[msg.sender].FUN3(VAR21);
VAR15[VAR20] = VAR15[VAR20].FUN4(VAR21);
Transfer(msg.sender, VAR20, VAR21);
}
function FUN9(address VAR22) constant returns (uint VAR23) {
return VAR15[VAR22];
}
}
contract StandardToken is VAR24, VAR25 {
mapping (address => mapping (address => uint)) VAR26;
function FUN11(address VAR27, address VAR20, uint VAR21) FUN14(3 * 32) {
var VAR28 = VAR26[VAR27][msg.sender];
VAR15[VAR20] = VAR15[VAR20].FUN4(VAR21);
VAR15[VAR27] = VAR15[VAR27].FUN3(VAR21);
VAR26[VAR27][msg.sender] = VAR28.FUN3(VAR21);
Transfer(VAR27, VAR20, VAR21);
}
function FUN12(address VAR29, uint VAR21) {
if ((VAR21 != 0) && (VAR26[msg.sender][VAR29] != 0)) throw;
VAR26[msg.sender][VAR29] = VAR21;
FUN13(msg.sender, VAR29, VAR21);
}
function FUN10(address VAR22, address VAR29) constant returns (uint VAR30) {
return VAR26[VAR22][VAR29];
}
}
contract CATToken is VAR31 {
using SafeMath for uint256;
string public constant VAR32 = "";
event FUN15(address indexed VAR33, uint256 VAR34);
event FUN16(address indexed VAR35, uint256 VAR36);
string public constant VAR37 = "";
string public constant VAR38 = "";
uint256 public constant VAR39 = 18;
string public VAR40 = "";
address public VAR41;
address public VAR42;
address public VAR43;
address public VAR44;
bool public VAR45;
bool public VAR46;
bool public VAR47;
mapping (address => uint256) public VAR48;
uint256 public VAR49;
uint256 public VAR50;
uint256 public VAR51;
uint256 public VAR52;
uint256 public VAR53;
uint256 public constant VAR54 = 20;
uint256 public constant VAR55 = 1;
uint256 public constant VAR56 = VAR54 + VAR55;
uint256 public constant VAR57 = 1000000 VAR58;
uint256 public constant VAR59 = 300;
uint256 public constant VAR60 = 330;
uint256 public constant VAR61 = 315;
function FUN17(
address VAR62,
address VAR63,
address VAR64,
uint256 VAR65,
uint256 VAR66
) {
if (VAR62 == address(0x0)) throw;
if (VAR63 == address(0x0)) throw;
if (VAR64 == address(0x0)) throw;
if (VAR66 <= VAR67.VAR68) throw;
if (VAR66 <= VAR65) throw;
VAR41 = msg.sender;
VAR45 = false;
VAR46 = false;
VAR47 = false;
VAR42 = VAR62;
VAR43 = VAR63;
VAR44 = VAR64;
VAR49 = 0;
VAR50 = VAR65;
VAR51 = VAR66;
VAR52 = VAR50 + 6171;
VAR53 = VAR52 + 12342;
VAR9 = 0;
}
function FUN18() payable external {
if (VAR45) throw;
if (VAR67.VAR68 < VAR50) throw;
if (VAR67.VAR68 > VAR51) throw;
uint256 VAR69 = VAR49.FUN4(msg.value);
if (VAR69 > VAR57) throw;
if (0 == msg.value) throw;
uint256 VAR70 = VAR59;
if (VAR67.VAR68 < VAR52) {
VAR70 = VAR60;
}
else if (VAR67.VAR68 < VAR53) {
VAR70 = VAR61;
}
uint256 VAR71 = msg.value.FUN1(VAR70);
uint256 VAR72 = VAR9.FUN4(VAR71);
uint256 VAR73 = VAR15[msg.sender].FUN4(VAR71);
uint256 VAR74 = VAR48[msg.sender].FUN4(msg.value);
VAR9 = VAR72;
VAR15[msg.sender] = VAR73;
VAR49 = VAR69;
VAR48[msg.sender] = VAR74;
FUN15(msg.sender, VAR71);
}
function FUN19() {
if (VAR45) throw;
if (!VAR46) throw;
if (msg.sender != VAR41) throw;
VAR45 = true;
uint256 VAR75 = (VAR9.FUN1(VAR56)).FUN2(100 - VAR56);
uint256 VAR72 = VAR9.FUN4(VAR75);
uint256 VAR76 = (VAR75.FUN1(VAR55)).FUN2(VAR56);
uint256 VAR77 = VAR75.FUN3(VAR76);
VAR9 = VAR72;
VAR15[VAR43] = VAR77;
VAR15[VAR44] = VAR76;
FUN15(VAR43, VAR77);
FUN15(VAR44, VAR76);
if (this.VAR23 > 0) {
if (!VAR42.call.value(this.VAR23)()) throw;
}
}
function FUN20() {
if (!VAR46) throw;
if (0 == this.VAR23) throw;
if (!VAR42.call.value(this.VAR23)()) throw;
}
function FUN21() {
if (msg.sender != VAR41) throw;
VAR46 = true;
}
function FUN22() {
if (VAR45) throw;
if (VAR46) throw;
if (VAR67.VAR68 < VAR51) throw;
if (msg.sender != VAR41) throw;
VAR47 = true;
}
function FUN23() external {
if (!VAR47) throw;
if (0 == VAR48[msg.sender]) throw;
uint256 VAR78 = VAR48[msg.sender];
VAR48[msg.sender] = 0;
FUN16(msg.sender, VAR78);
if (!msg.sender.FUN24(VAR78)) throw;
}
function FUN25(address VAR79) {
if (msg.sender != VAR41) throw;
VAR42 = VAR79;
}
function FUN26(address VAR79) {
if (msg.sender != VAR41) throw;
VAR43 = VAR79;
}
function FUN27(address VAR79) {
if (msg.sender != VAR41) throw;
VAR44 = VAR79;
}
function transfer(address VAR20, uint VAR21) {
if (!VAR46) throw;
super.transfer(VAR20, VAR21);
}
function FUN11(address VAR27, address VAR20, uint VAR21) {
if (!VAR46) throw;
super.FUN11(VAR27, VAR20, VAR21);
}
}
1
---------------------------------
73 0x58ed44f46c279f30fd0a0724d3fed4bc18b11bb0.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function FUN1() public constant returns (uint256);
function FUN2(address VAR3) public constant returns (uint256 VAR4);
function FUN3(address VAR3, address VAR5) public constant returns (uint256 VAR6);
function transfer(address VAR7, uint256 VAR8) public returns (bool VAR9);
function FUN4(address VAR5, uint256 VAR8) public returns (bool VAR9);
function FUN5(address VAR10, address VAR7, uint256 VAR8) public returns (bool VAR9);
event Transfer(address indexed VAR10, address indexed VAR7, uint VAR8);
event FUN6(address indexed VAR3, address indexed VAR5, uint VAR8);
}
contract VAR11 {
function FUN7(address) public payable returns(uint256){}
function FUN8() public {}
}
contract VAR12 {
address public VAR13;
address public VAR14;
function FUN9() public {
VAR13 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR13);
VAR15;
}
function FUN10(address VAR16) public onlyOwner {
VAR14 = VAR16;
}
function FUN11() public {
require(msg.sender == VAR14);
VAR13 = VAR14;
}
}
contract BoomerangLiquidity is VAR12 {
modifier onlyOwner(){
require(msg.sender == VAR13);
VAR15;
}
modifier FUN12(address VAR17){
require(VAR17 != VAR18);
VAR15;
}
uint public VAR19;
uint public VAR20 = 0;
address VAR18;
POWH VAR21;
function FUN13(uint VAR22, address VAR23) public {
VAR19 = VAR22;
VAR18 = VAR23;
VAR21 = FUN14(VAR18);
}
struct VAR24 {
address VAR25;
uint VAR26;
}
VAR24[] public VAR27;
function() payable public {
FUN15();
}
function FUN15() payable public {
VAR27.FUN16(FUN17(msg.sender, (msg.value * VAR19) / 100));
FUN18();
}
function FUN18() public {
uint VAR4 = address(this).VAR4;
require(VAR4 > 1);
uint VAR28 = VAR4 / 2;
VAR4 -= VAR28;
VAR21.VAR29.value(VAR28).FUN19(1000000)(msg.sender);
while (VAR4 > 0) {
uint VAR30 = VAR4 < VAR27[VAR20].VAR26 ? VAR4 : VAR27[VAR20].VAR26;
if(VAR30 > 0){
VAR27[VAR20].VAR26 -= VAR30;
VAR4 -= VAR30;
if(!VAR27[VAR20].VAR25.FUN20(VAR30)){
VAR27[VAR20].VAR25.call.value(VAR30).FUN19(1000000)();
}
}
if(VAR4 > 0){
VAR20 += 1;
}
if(VAR20 >= VAR27.VAR31){
return;
}
}
}
function FUN8() public {
VAR21.VAR32.FUN19(3000000)();
}
function FUN21() payable public {
}
function FUN22(address VAR33, uint VAR8) public onlyOwner FUN12(VAR33) returns (bool VAR9) {
return FUN23(VAR33).transfer(VAR13, VAR8);
}
}
1
---------------------------------
74 0x58fcf11196abaeefdf23198ec4ec9c5237963e17.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) public view returns (uint256);
function transfer(address VAR5, uint256 value) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7 {
address public VAR8;
event FUN2(address indexed VAR9, address indexed VAR10);
function FUN3() public {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR11;
}
function FUN4(address VAR10) public onlyOwner {
require(VAR10 != address(0));
FUN2(VAR8, VAR10);
VAR8 = VAR10;
}
}
contract BasicToken is VAR2 {
using SafeMath for uint256;
mapping(address => uint256) VAR12;
function transfer(address VAR13, uint256 VAR14) public returns (bool) {
require(VAR13 != address(0));
require(VAR14 <= VAR12[msg.sender]);
VAR12[msg.sender] = VAR12[msg.sender].FUN5(VAR14);
VAR12[VAR13] = VAR12[VAR13].FUN6(VAR14);
Transfer(msg.sender, VAR13, VAR14);
return true;
}
function FUN1(address VAR15) public view returns (uint256 VAR16) {
return VAR12[VAR15];
}
}
contract ERC20 is VAR2 {
function FUN7(address VAR8, address VAR17) public view returns (uint256);
function FUN8(address VAR6, address VAR5, uint256 value) public returns (bool);
function FUN9(address VAR17, uint256 value) public returns (bool);
event FUN10(address indexed VAR8, address indexed VAR17, uint256 value);
}
contract StandardToken is VAR18, VAR19 {
mapping (address => mapping (address => uint256)) internal VAR20;
function FUN8(address VAR21, address VAR13, uint256 VAR14) public returns (bool) {
require(VAR13 != address(0));
require(VAR14 <= VAR12[VAR21]);
require(VAR14 <= VAR20[VAR21][msg.sender]);
VAR12[VAR21] = VAR12[VAR21].FUN5(VAR14);
VAR12[VAR13] = VAR12[VAR13].FUN6(VAR14);
VAR20[VAR21][msg.sender] = VAR20[VAR21][msg.sender].FUN5(VAR14);
Transfer(VAR21, VAR13, VAR14);
return true;
}
function FUN9(address VAR22, uint256 VAR14) public returns (bool) {
VAR20[msg.sender][VAR22] = VAR14;
FUN10(msg.sender, VAR22, VAR14);
return true;
}
function FUN7(address VAR15, address VAR22) public view returns (uint256) {
return VAR20[VAR15][VAR22];
}
function FUN11(address VAR22, uint VAR23) public returns (bool) {
VAR20[msg.sender][VAR22] = VAR20[msg.sender][VAR22].FUN6(VAR23);
FUN10(msg.sender, VAR22, VAR20[msg.sender][VAR22]);
return true;
}
function FUN12(address VAR22, uint VAR24) public returns (bool) {
uint VAR25 = VAR20[msg.sender][VAR22];
if (VAR24 > VAR25) {
VAR20[msg.sender][VAR22] = 0;
} else {
VAR20[msg.sender][VAR22] = VAR25.FUN5(VAR24);
}
FUN10(msg.sender, VAR22, VAR20[msg.sender][VAR22]);
return true;
}
}
contract BurnableToken is VAR26 {
event FUN13(address indexed VAR27, uint256 value);
function FUN14(uint256 VAR14) public {
require(VAR14 > 0);
require(VAR14 <= VAR12[msg.sender]);
address VAR27 = msg.sender;
VAR12[VAR27] = VAR12[VAR27].FUN5(VAR14);
VAR3 = VAR3.FUN5(VAR14);
FUN13(VAR27, VAR14);
}
}
contract Pausable is VAR7 {
event FUN15();
event FUN16();
bool public VAR28 = false;
modifier FUN17() {
require(!VAR28);
VAR11;
}
modifier FUN18() {
require(VAR28);
VAR11;
}
function FUN19() onlyOwner whenNotPaused public {
VAR28 = true;
FUN15();
}
function FUN20() onlyOwner whenPaused public {
VAR28 = false;
FUN16();
}
}
contract PausableToken is VAR26, VAR29 {
function transfer(address VAR13, uint256 VAR14) public whenNotPaused returns (bool) {
return super.transfer(VAR13, VAR14);
}
function FUN8(address VAR21, address VAR13, uint256 VAR14) public whenNotPaused returns (bool) {
return super.FUN8(VAR21, VAR13, VAR14);
}
function FUN9(address VAR22, uint256 VAR14) public whenNotPaused returns (bool) {
return super.FUN9(VAR22, VAR14);
}
function FUN11(address VAR22, uint VAR23) public whenNotPaused returns (bool VAR30) {
return super.FUN11(VAR22, VAR23);
}
function FUN12(address VAR22, uint VAR24) public whenNotPaused returns (bool VAR30) {
return super.FUN12(VAR22, VAR24);
}
}
contract BullToken is VAR31, VAR32 {
string public constant VAR33 = "";
string public constant VAR34 = "";
uint256 public constant VAR35 = 18;
uint256 public constant VAR36 = 55000000;
bool public VAR37;
mapping (address => bool) public VAR38;
address [] public VAR39;
function FUN21() public {
VAR3 = VAR36 * 10 ** uint256(VAR35);
VAR12[msg.sender] = VAR3;
VAR37 = false;
}
function FUN22() onlyOwner public {
VAR37 = true;
FUN23();
}
function FUN24() onlyOwner public {
VAR37 = false;
FUN25();
}
function transfer(address VAR5, uint256 value) public returns (bool) {
require(VAR37 || msg.sender == VAR8);
if (!VAR38[VAR5]) {
VAR39.FUN26(VAR5);
VAR38[VAR5] = true;
}
return super.transfer(VAR5, value);
}
function FUN8(address VAR6, address VAR5, uint256 value) public returns (bool) {
require(VAR37 || VAR6 == VAR8);
if (!VAR38[VAR5]) {
VAR39.FUN26(VAR5);
VAR38[VAR5] = true;
}
return super.FUN8(VAR6, VAR5, value);
}
event FUN23();
event FUN25();
}
contract Curatable is VAR7 {
address public VAR40;
event FUN27(address indexed VAR41, address indexed VAR42);
function FUN28() public {
VAR8 = msg.sender;
VAR40 = VAR8;
}
modifier FUN29() {
require(msg.sender == VAR40);
VAR11;
}
function FUN30(address VAR42) public onlyOwner {
require(VAR42 != address(0));
FUN27(VAR40, VAR42);
VAR40 = VAR42;
}
}
contract Whitelist is VAR43 {
mapping (address => bool) public VAR44;
function FUN31() public {
}
function FUN32(address VAR45) external VAR46 {
require(VAR45 != 0x0 && !VAR44[VAR45]);
VAR44[VAR45] = true;
}
function FUN33(address VAR45) external VAR46 {
require(VAR45 != 0x0 && VAR44[VAR45]);
VAR44[VAR45] = false;
}
function FUN34(address VAR45) constant external returns (bool VAR47) {
return VAR44[VAR45];
}
}
library VAR48 {
function FUN35(uint256 VAR49, uint256 VAR50) internal pure returns (uint256) {
if (VAR49 == 0) {
return 0;
}
uint256 VAR51 = VAR49 * VAR50;
assert(VAR51 / VAR49 == VAR50);
return VAR51;
}
function FUN36(uint256 VAR49, uint256 VAR50) internal pure returns (uint256) {
uint256 VAR51 = VAR49 / VAR50;
return VAR51;
}
function FUN5(uint256 VAR49, uint256 VAR50) internal pure returns (uint256) {
assert(VAR50 <= VAR49);
return VAR49 - VAR50;
}
function FUN6(uint256 VAR49, uint256 VAR50) internal pure returns (uint256) {
uint256 VAR51 = VAR49 + VAR50;
assert(VAR51 >= VAR49);
return VAR51;
}
}
contract VAR52 {
using SafeMath for uint256;
BurnableToken public VAR53;
uint256 public VAR54;
uint256 public VAR55;
address public VAR56;
uint256 public VAR57;
uint256 public VAR58;
address public VAR59;
event FUN37(address indexed VAR60, address indexed VAR61, uint256 value, uint256 VAR62);
function FUN38(uint256 VAR63, uint256 VAR64, uint256 VAR65, address VAR66, address VAR67) public {
require(VAR63 >= VAR68);
require(VAR64 >= VAR63);
require(VAR65 > 0);
require(VAR66 != address(0));
VAR59 = VAR67;
VAR53 = FUN39();
VAR54 = VAR63;
VAR55 = VAR64;
VAR57 = VAR65;
VAR56 = VAR66;
}
function FUN39() internal returns (VAR31) {
return VAR69 FUN40();
}
function () external payable {
FUN41(msg.sender);
}
function FUN41(address VAR61) public payable {
}
function FUN42() internal {
}
function FUN43() internal view returns (bool) {
bool VAR70 = VAR68 >= VAR54 && VAR68 <= VAR55;
bool VAR71 = msg.value != 0;
return VAR70 && VAR71;
}
function FUN44() public view returns (bool) {
return VAR68 > VAR55;
}
}
contract CappedCrowdsale is VAR52 {
using SafeMath for uint256;
uint256 public VAR72;
function FUN45(uint256 VAR73) public {
require(VAR73 > 0);
VAR72 = VAR73;
}
function FUN43() internal view returns (bool) {
bool VAR74 = VAR58.FUN6(msg.value) <= VAR72;
return super.FUN43() && VAR74;
}
function FUN44() public view returns (bool) {
bool VAR75 = VAR58 >= VAR72;
return super.FUN44() || VAR75;
}
}
contract RefundVault is VAR7 {
using SafeMath for uint256;
enum VAR76 { VAR77, VAR78, VAR79 }
mapping (address => uint256) public VAR80;
address public VAR56;
State public VAR81;
event FUN46();
event FUN47();
event FUN48(address indexed VAR61, uint256 VAR82);
function FUN49(address VAR66) public {
require(VAR66 != address(0));
VAR56 = VAR66;
VAR81 = VAR76.VAR77;
}
function FUN50(address VAR45) onlyOwner public payable {
require(VAR81 == VAR76.VAR77);
VAR80[VAR45] = VAR80[VAR45].FUN6(msg.value);
}
function FUN51() onlyOwner public {
require(VAR81 == VAR76.VAR77);
VAR81 = VAR76.VAR79;
FUN46();
VAR56.transfer(this.VAR16);
}
function FUN52() onlyOwner public {
require(VAR81 == VAR76.VAR77);
VAR81 = VAR76.VAR78;
FUN47();
}
function FUN53(address VAR45) public {
require(VAR81 == VAR76.VAR78);
uint256 VAR83 = VAR80[VAR45];
VAR80[VAR45] = 0;
VAR45.transfer(VAR83);
FUN48(VAR45, VAR83);
}
}
contract BullTokenRefundVault is VAR84 {
function FUN54(address VAR66) public FUN49(VAR66) {}
function FUN51() onlyOwner public {
require(VAR81 == VAR76.VAR77);
VAR81 = VAR76.VAR79;
FUN46();
VAR56.call.value(this.VAR16)();
}
function FUN42() onlyOwner public {
require(this.VAR16 > 0);
VAR56.call.value(this.VAR16)();
}
}
contract FinalizableCrowdsale is VAR52, VAR7 {
using SafeMath for uint256;
bool public VAR85 = false;
event FUN55();
function FUN56() onlyOwner public {
require(!VAR85);
require(FUN44());
FUN57();
FUN55();
VAR85 = true;
}
function FUN57() internal {
}
}
contract RefundableCrowdsale is VAR86 {
using SafeMath for uint256;
uint256 public VAR87;
BullTokenRefundVault public VAR88;
function FUN58(uint256 VAR89) public {
require(VAR89 > 0);
VAR88 = VAR69 FUN54(VAR56);
VAR87 = VAR89;
}
function FUN42() internal {
VAR88.VAR90.value(msg.value)(msg.sender);
}
function FUN59() public {
require(VAR85);
require(!FUN60());
VAR88.FUN53(msg.sender);
}
function FUN57() internal {
if (FUN60()) {
VAR88.FUN51();
} else {
VAR88.FUN52();
}
super.FUN57();
}
function FUN60() public view returns (bool) {
return VAR58 >= VAR87;
}
}
contract BullTokenCrowdsale is VAR91, VAR92 {
using SafeMath for uint256;
Whitelist public VAR44;
uint256 public VAR93;
function FUN61(
uint256 VAR63,
uint256 VAR64,
uint256 VAR65,
uint256 VAR89,
uint256 VAR73,
uint256 VAR94,
address VAR67,
address VAR66,
address VAR95
) public
FUN45(VAR73)
FUN62()
FUN58(VAR89)
FUN38(VAR63, VAR64, VAR65, VAR66, VAR67)
{
require(VAR89 <= VAR73);
VAR44 = FUN31(VAR95);
VAR93 = VAR94;
}
function FUN39() internal returns (VAR31) {
return FUN21(VAR59);
}
function () external payable {
FUN41(msg.sender);
}
function FUN41(address VAR61) public payable {
require(VAR61 != address(0));
require(VAR44.FUN34(VAR61));
uint256 VAR82 = msg.value;
uint256 VAR96 = VAR58.FUN6(VAR82);
if (VAR96 > VAR72) {
require(FUN63() && !FUN44());
uint256 VAR97 = VAR96.FUN5(VAR72);
VAR82 = VAR72.FUN5(VAR58);
VAR61.transfer(VAR97);
} else {
require(FUN43());
}
uint256 VAR98 = VAR82.FUN35(VAR57);
VAR58 = VAR58.FUN6(VAR82);
VAR53.FUN8(VAR8, VAR61, VAR98);
FUN37(msg.sender, VAR61, VAR82, VAR98);
FUN64(VAR82);
}
function FUN43() internal view returns (bool) {
return super.FUN43() && FUN65();
}
function FUN44() public view returns (bool) {
bool VAR75 = VAR58.FUN6(VAR93) > VAR72;
return super.FUN44() || VAR75;
}
function FUN63() public constant returns (bool) {
return VAR68 >= VAR54;
}
function FUN65() internal view returns (bool) {
return msg.value >= VAR93;
}
function FUN64(uint256 VAR62) internal {
if (FUN60() && VAR88.VAR16 > 0) {
VAR88.FUN42();
}
if (FUN60()) {
VAR56.call.value(VAR62)();
} else {
VAR88.VAR90.value(VAR62)(msg.sender);
}
}
}
1
---------------------------------
75 0x594f1b4fa77be53c36001b2a207e58d8bcbf3d4f.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
bool public VAR42;
bool public VAR43;
bool public VAR44;
address public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => uint256) public VAR47;
mapping (address => bool) public VAR48;
uint public VAR49;
enum VAR50{VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57, VAR58}
event FUN26(address VAR59, uint VAR60, uint VAR21, uint128 VAR61);
event FUN27(address VAR59, uint VAR60);
event FUN28(bool VAR43, bool VAR44, address VAR45);
event FUN29(address VAR62, bool VAR63);
event FUN30(uint VAR38);
function FUN31(address VAR64, PricingStrategy VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR69) {
VAR9 = msg.sender;
VAR32 = FUN32(VAR64);
FUN33(VAR65);
VAR35 = VAR66;
if(VAR35 == 0) {
throw;
}
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR68 == 0) {
throw;
}
VAR38 = VAR68;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR69;
}
function() payable {
throw;
}
function FUN34(address VAR70, uint128 VAR61) stopInEmergency private {
if(FUN35() == VAR50.VAR53) {
if(!VAR48[VAR70]) {
throw;
}
} else if(FUN35() == VAR50.VAR54) {
} else {
throw;
}
uint VAR60 = msg.value;
uint VAR21 = VAR33.FUN18(VAR60, VAR17, VAR18, msg.sender, VAR32.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR46[VAR70] == 0) {
VAR39++;
}
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR60, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR70, VAR21);
if(!VAR35.FUN39(VAR60)) throw;
FUN26(VAR70, VAR60, VAR21, VAR61);
}
function FUN40(address VAR70, uint VAR71, uint VAR72) public onlyOwner {
uint VAR21 = VAR71 * 10**VAR32.FUN36();
uint VAR60 = VAR72 * VAR71;
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
FUN38(VAR70, VAR21);
FUN26(VAR70, VAR60, VAR21, 0);
}
function FUN41(address VAR62, uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
bytes32 VAR76 = FUN42(VAR62);
if (FUN43(VAR76, VAR73, VAR74, VAR75) != VAR45) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN44(address VAR62, uint128 VAR61) public payable {
if(VAR44) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN45(address VAR62) public payable {
if(VAR43) throw;
if(VAR44) throw;
FUN34(VAR62, 0);
}
function FUN46(uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
FUN41(msg.sender, VAR61, VAR73, VAR74, VAR75);
}
function FUN47(uint128 VAR61) public payable {
FUN44(msg.sender, VAR61);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR50.VAR55) onlyOwner VAR13 {
if(VAR42) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN20();
}
VAR42 = true;
}
function FUN51(FinalizeAgent VAR62) onlyOwner {
VAR34 = VAR62;
if(!VAR34.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR43 = value;
FUN28(VAR43, VAR44, VAR45);
}
function FUN53(bool value, address VAR77) onlyOwner {
VAR44 = value;
VAR45 = VAR77;
FUN28(VAR43, VAR44, VAR45);
}
function FUN54(address VAR62, bool VAR63) onlyOwner {
VAR48[VAR62] = VAR63;
FUN29(VAR62, VAR63);
}
function FUN55(uint VAR78) onlyOwner {
if(VAR79 > VAR78) {
throw;
}
VAR38 = VAR78;
FUN30(VAR38);
}
function FUN33(PricingStrategy VAR65) onlyOwner {
VAR33 = VAR65;
if(!VAR33.FUN16()) {
throw;
}
}
function FUN56(address VAR62) public onlyOwner {
if(VAR39 > VAR31) {
throw;
}
VAR35 = VAR62;
}
function FUN57() public payable FUN50(VAR50.VAR56) {
if(msg.value == 0) throw;
VAR40 = VAR40.FUN11(msg.value);
}
function FUN58() public FUN50(VAR50.VAR58) {
uint256 VAR80 = VAR46[msg.sender];
if (VAR80 == 0) throw;
VAR46[msg.sender] = 0;
VAR41 = VAR41.FUN11(VAR80);
FUN27(msg.sender, VAR80);
if (!msg.sender.FUN39(VAR80)) throw;
}
function FUN59() public constant returns (bool VAR81) {
return VAR17 >= VAR36;
}
function FUN60() public constant returns (bool VAR82) {
return VAR34.FUN17();
}
function FUN61() public constant returns (bool VAR82) {
return VAR33.FUN17(address(this));
}
function FUN35() public constant returns (VAR50) {
if(VAR42) return VAR50.VAR57;
else if (address(VAR34) == 0) return VAR50.VAR52;
else if (!VAR34.FUN17()) return VAR50.VAR52;
else if (!VAR33.FUN17(address(this))) return VAR50.VAR52;
else if (VAR83.VAR84 < VAR37) return VAR50.VAR53;
else if (VAR83.VAR84 <= VAR38 && !FUN62()) return VAR50.VAR54;
else if (FUN59()) return VAR50.VAR55;
else if (!FUN59() && VAR17 > 0 && VAR40 >= VAR17) return VAR50.VAR58;
else return VAR50.VAR56;
}
function FUN63(uint VAR85) onlyOwner {
VAR49 = VAR85;
}
function FUN64() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR86) {
if(FUN35() != VAR86) throw;
VAR10;
}
//
//
function FUN37(uint VAR60, uint VAR21, uint VAR87, uint VAR88) constant returns (bool VAR89);
function FUN62() public constant returns (bool);
function FUN38(address VAR70, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN65(address VAR70, uint VAR90);
mapping(address => uint) VAR91;
mapping (address => mapping (address => uint)) VAR92;
function FUN66() public constant returns (bool VAR93) {
return true;
}
modifier FUN67(uint VAR94) {
if(msg.VAR95.VAR96 < VAR94 + 4) {
throw;
}
VAR10;
}
function transfer(address VAR97, uint VAR98) FUN67(2 * 32) returns (bool VAR99) {
VAR91[msg.sender] = FUN3(VAR91[msg.sender], VAR98);
VAR91[VAR97] = FUN4(VAR91[VAR97], VAR98);
Transfer(msg.sender, VAR97, VAR98);
return true;
}
function FUN23(address VAR100, address VAR97, uint VAR98) returns (bool VAR99) {
uint VAR101 = VAR92[VAR100][msg.sender];
VAR91[VAR97] = FUN4(VAR91[VAR97], VAR98);
VAR91[VAR100] = FUN3(VAR91[VAR100], VAR98);
VAR92[VAR100][msg.sender] = FUN3(VAR101, VAR98);
Transfer(VAR100, VAR97, VAR98);
return true;
}
function FUN21(address VAR102) constant returns (uint VAR103) {
return VAR91[VAR102];
}
function FUN24(address VAR104, uint VAR98) returns (bool VAR99) {
if ((VAR98 != 0) && (VAR92[msg.sender][VAR104] != 0)) throw;
VAR92[msg.sender][VAR104] = VAR98;
FUN25(msg.sender, VAR104, VAR98);
return true;
}
function FUN22(address VAR102, address VAR104) constant returns (uint VAR105) {
return VAR92[VAR102][VAR104];
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR39;
uint public VAR87;
address[] public VAR106;
mapping(address => uint) public VAR91;
mapping(address => uint) public VAR107;
uint public VAR108;
uint public VAR109;
uint public VAR110;
uint public VAR111;
uint public VAR112;
uint public VAR113;
Crowdsale public VAR16;
enum VAR50{VAR51, VAR54, VAR114, VAR58}
event FUN26(address VAR59, uint value);
event FUN68(address VAR59, uint value);
event FUN69(uint VAR115);
event FUN70(address VAR106, uint VAR115);
function FUN71(address VAR102, uint VAR116, uint VAR117, uint VAR118) {
VAR9 = VAR102;
if(VAR116 == 0) {
throw;
}
if(VAR117 == 0) {
throw;
}
VAR109 = VAR117;
VAR110 = VAR118;
VAR108 = VAR116;
}
function FUN72() public constant returns(VAR119) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN73();
}
function FUN45() public stopInEmergency payable {
if(FUN35() != VAR50.VAR54) throw;
if(msg.value == 0) throw;
address VAR59 = msg.sender;
bool VAR120 = VAR91[VAR59] > 0;
VAR91[VAR59] = FUN4(VAR91[VAR59], msg.value);
if(VAR91[VAR59] < VAR109) {
throw;
}
if(!VAR120) {
VAR106.FUN74(VAR59);
VAR39++;
}
VAR87 = FUN4(VAR87, msg.value);
if(VAR87 > VAR110) {
throw;
}
FUN26(VAR59, msg.value);
}
function FUN75() stopInEmergency public {
if(FUN35() != VAR50.VAR54) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR121.value(VAR87)(address(this));
VAR111 = FUN72().FUN21(address(this));
if(VAR111 == 0) {
throw;
}
FUN69(VAR111);
}
function FUN76(address VAR59) public constant returns (uint) {
if(FUN35() != VAR50.VAR114) {
throw;
}
return FUN1(VAR91[VAR59], VAR111) / VAR87;
}
function FUN77(address VAR59) public constant returns (uint) {
return FUN3(FUN76(VAR59), VAR107[VAR59]);
}
function FUN78() {
FUN79(FUN77(msg.sender));
}
function FUN79(uint VAR90) VAR13 {
address VAR59 = msg.sender;
if(VAR90 == 0) {
throw;
}
if(FUN77(VAR59) < VAR90) {
throw;
}
if(VAR107[VAR59] == 0) {
VAR112++;
}
VAR107[VAR59] = FUN4(VAR107[VAR59], VAR90);
VAR113 = FUN4(VAR113, VAR90);
FUN72().transfer(VAR59, VAR90);
FUN70(VAR59, VAR90);
}
function FUN58() VAR13 {
if(FUN35() != VAR50.VAR58) throw;
address VAR59 = msg.sender;
if(VAR91[VAR59] == 0) throw;
uint VAR90 = VAR91[VAR59];
delete VAR91[VAR59];
if(!(VAR59.call.value(VAR90)())) throw;
FUN68(VAR59, VAR90);
}
function FUN80(Crowdsale VAR122) public onlyOwner {
VAR16 = VAR122;
if(!VAR16.FUN64()) true;
}
function FUN35() public returns(VAR50) {
if(VAR111 == 0) {
if(VAR79 >= VAR108) {
return VAR50.VAR58;
} else {
return VAR50.VAR54;
}
} else {
return VAR50.VAR114;
}
}
function() payable {
throw;
}
}
1
---------------------------------
76 0x5b5d8a8a732a3c73ff0fb6980880ef399ecaf72e.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
address public VAR4;
function FUN1() payable {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(VAR3 == msg.sender);
VAR5;
}
function FUN2(address VAR6) onlyOwner public {
require(VAR6 != 0);
VAR4 = VAR6;
}
function FUN3() public {
require(VAR4 == msg.sender);
VAR3 = VAR4;
delete VAR4;
}
}
contract VAR7 {
uint public VAR8;
function FUN4(address VAR9) constant returns (uint);
function transfer(address VAR10, uint value);
function FUN5(address VAR3, address VAR11) constant returns (uint);
function FUN6(address VAR12, address VAR10, uint value);
function FUN7(address VAR11, uint value);
event FUN8(address indexed VAR3, address indexed VAR11, uint value);
event Transfer(address indexed VAR12, address indexed VAR10, uint value);
}
contract ManualMigration is VAR2, VAR7 {
mapping (address => uint) internal VAR13;
address public VAR14;
function FUN9(address VAR15) payable FUN1() {
VAR14 = VAR15;
}
function FUN10(address VAR16) onlyOwner {
require(VAR14 != 0);
uint VAR17 = FUN11(VAR14).FUN4(VAR16);
VAR17 = VAR17 * 125 / 100;
VAR13[VAR16] = VAR17;
VAR8 += VAR17;
Transfer(VAR14, VAR16, VAR17);
}
function FUN12() onlyOwner {
delete VAR14;
}
}
contract Crowdsale is VAR18 {
uint    public VAR19;
address public VAR20;
uint    public VAR21;
uint    public VAR22;
uint    public VAR23;
enum VAR24 { VAR25, VAR26, VAR27, VAR28, VAR29, VAR30 }
event FUN13(State VAR31);
State   public VAR31 = VAR24.VAR25;
uint    public VAR32;
uint    public VAR33;
modifier VAR34 {
require(VAR31 == VAR24.VAR29);
VAR5;
}
modifier VAR35 {
require(VAR31 == VAR24.VAR29 || VAR31 == VAR24.VAR30);
VAR5;
}
struct VAR36 {
uint VAR37;
uint VAR38;
}
mapping (address => VAR36) public VAR39;
mapping (uint => address)     public VAR40;
uint                          public VAR41;
function FUN14(address VAR15)
payable FUN9(VAR15) {
}
function () payable {
require(VAR31 == VAR24.VAR26 || VAR31 == VAR24.VAR28);
require(VAR42 < VAR33);
uint VAR43 = msg.value;
uint VAR44 = VAR43 * VAR19 / 1000000000000000000;
if (VAR23 + VAR44 > VAR21) {
VAR44 = VAR21 - VAR23;
VAR43 = VAR44 * 1000000000000000000 / VAR19;
require(msg.sender.call.FUN15(3000000).value(msg.value - VAR43)());
VAR23 = VAR21;
} else {
VAR23 += VAR44;
}
FUN16(msg.sender, VAR44, VAR43);
}
function FUN17(address VAR45, uint VAR46) public onlyOwner {
require(VAR31 == VAR24.VAR26 || VAR31 == VAR24.VAR28);
require(VAR42 < VAR33);
require(VAR23 + VAR46 <= VAR21);
VAR23 += VAR46;
FUN16(VAR45, VAR46, 0);
}
function FUN16(address VAR45, uint VAR46, uint VAR47) internal {
uint VAR48 = 100;
if (VAR31 == VAR24.VAR26) {
if (VAR42 < VAR32 + 1 VAR49 && VAR46 >= 50000) {
VAR48 = 150;
} else {
VAR48 = 125;
}
} else if (VAR31 == VAR24.VAR28) {
if (VAR42 < VAR32 + 1 VAR49) {
VAR48 = 115;
} else if (VAR42 < VAR32 + 1 VAR50) {
VAR48 = 110;
}
}
uint VAR17 = VAR48 * VAR46;
require(VAR13[VAR45] + VAR17 > VAR13[VAR45]);
require(VAR17 > 0);
Investor storage VAR51 = VAR39[VAR45];
if (VAR51.VAR37 == 0) {
VAR40[VAR41++] = VAR45;
}
VAR51.VAR37 += VAR17;
VAR51.VAR38 += VAR47;
VAR13[VAR45] += VAR17;
Transfer(this, VAR45, VAR17);
VAR8 += VAR17;
}
function FUN18(
address VAR52,
uint    VAR53,
uint    VAR54,
uint    VAR55,
uint    VAR56) public onlyOwner {
require(VAR31 == VAR24.VAR25 || VAR31 == VAR24.VAR27);
VAR32 = VAR42;
VAR20 = VAR52;
VAR19 = VAR56;
delete VAR41;
delete VAR23;
VAR33 = VAR42 + VAR53 * 1 VAR49;
VAR21 = VAR54;
VAR22 = VAR55;
if (VAR31 == VAR24.VAR25) {
VAR31 = VAR24.VAR26;
} else {
VAR31 = VAR24.VAR28;
}
FUN13(VAR31);
}
function FUN19() public constant returns(uint VAR57) {
require(VAR31 == VAR24.VAR26 || VAR31 == VAR24.VAR28);
if (VAR42 > VAR33) {
VAR57 = 0;
} else {
VAR57 = VAR33 - VAR42;
}
}
function FUN20(uint VAR58) public {
require(VAR31 == VAR24.VAR26 || VAR31 == VAR24.VAR28);
require(VAR42 >= VAR33 || VAR23 == VAR21 ||
(VAR23 >= VAR22 && msg.sender == VAR3));
if (VAR23 < VAR22) {
while (VAR58 > 0 && VAR41 > 0) {
address VAR59 = VAR40[--VAR41];
Investor memory VAR51 = VAR39[VAR59];
VAR13[VAR59] -= VAR51.VAR37;
VAR8 -= VAR51.VAR37;
Transfer(VAR59, this, VAR51.VAR37);
--VAR58;
delete VAR40[VAR41];
}
if (VAR41 > 0) {
return;
}
if (VAR31 == VAR24.VAR26) {
VAR31 = VAR24.VAR25;
} else {
VAR31 = VAR24.VAR27;
}
} else {
while (VAR58 > 0 && VAR41 > 0) {
--VAR41;
--VAR58;
delete VAR39[VAR40[VAR41]];
delete VAR40[VAR41];
}
if (VAR41 > 0) {
return;
}
if (VAR31 == VAR24.VAR26) {
require(VAR20.call.FUN15(3000000).value(this.VAR60)());
VAR31 = VAR24.VAR27;
} else {
require(VAR20.call.FUN15(3000000).value(VAR22 * 1000000000000000000 / VAR19)());
uint VAR17 = 3 * VAR8 / 7;
VAR13[VAR3] = VAR17;
VAR8 += VAR17;
Transfer(this, VAR3, VAR17);
VAR31 = VAR24.VAR29;
}
}
FUN13(VAR31);
}
function FUN21() public {
require(VAR31 == VAR24.VAR25 || VAR31 == VAR24.VAR27);
uint value = VAR39[msg.sender].VAR38;
if (value > 0) {
delete VAR39[msg.sender];
require(msg.sender.call.FUN15(3000000).value(value)());
}
}
}
contract VAR61 {
function FUN22(address VAR62, uint VAR63);
}
contract Token is VAR28, VAR61 {
string  public VAR64    = '';
string  public VAR65        = '';
string  public VAR66      = "";
uint8   public VAR67    = 0;
mapping (address => mapping (address => uint)) public VAR68;
mapping (address => bool) public VAR69;
modifier VAR70 {
require(VAR13[msg.sender] != 0);
VAR5;
}
modifier FUN23(uint VAR71) {
require(msg.VAR72.VAR73 >= VAR71 + 4);
VAR5;
}
modifier VAR74 {
require(VAR69[msg.sender]);
VAR5;
}
function FUN24(address VAR15)
payable FUN14(VAR15) {}
function FUN4(address VAR9) constant returns (uint) {
return VAR13[VAR9];
}
function transfer(address VAR62, uint VAR63)
public VAR34 FUN23(2 * 32) {
require(VAR13[msg.sender] >= VAR63);
require(VAR13[VAR62] + VAR63 >= VAR13[VAR62]);
VAR13[msg.sender] -= VAR63;
VAR13[VAR62] += VAR63;
Transfer(msg.sender, VAR62, VAR63);
}
function FUN6(address VAR75, address VAR62, uint VAR63)
public VAR34 FUN23(3 * 32) {
require(VAR13[VAR75] >= VAR63);
require(VAR13[VAR62] + VAR63 >= VAR13[VAR62]);
require(VAR68[VAR75][msg.sender] >= VAR63);
VAR13[VAR75] -= VAR63;
VAR13[VAR62] += VAR63;
VAR68[VAR75][msg.sender] -= VAR63;
Transfer(VAR75, VAR62, VAR63);
}
function FUN7(address VAR76, uint VAR63) public VAR34 {
VAR68[msg.sender][VAR76] = VAR63;
FUN8(msg.sender, VAR76, VAR63);
}
function FUN5(address VAR6, address VAR76) public constant VAR34
returns (uint VAR77) {
return VAR68[VAR6][VAR76];
}
function FUN22(address VAR62, uint VAR63) public VAR74 {
require(VAR13[this] >= VAR63);
require(VAR13[VAR62] + VAR63 >= VAR13[VAR62]);
VAR13[this] -= VAR63;
VAR13[VAR62] += VAR63;
Transfer(this, VAR62, VAR63);
}
}
contract ProofVote is VAR78 {
function FUN25(address VAR15)
payable FUN24(VAR15) {}
event FUN26(uint VAR79, VoteReason VAR80);
event FUN27(address indexed VAR81, bool VAR82);
event FUN28(bool VAR82);
enum VAR83 { VAR84, VAR85, VAR86 }
enum VAR87 { VAR88, VAR89, VAR30, VAR90 }
uint public VAR79;
uint public VAR91;
uint public VAR92;
uint public VAR93;
uint public VAR94;
VoteReason  VAR80;
mapping (address => VAR83) public VAR95;
mapping (uint => address) public VAR96;
address public VAR97;
address public VAR98;
address public VAR99;
function FUN29(uint VAR100) public enabledOrMigrationState onlyOwner {
require(VAR100 > 0);
FUN30(VAR100, VAR87.VAR89, 7);
}
function FUN30(uint VAR100, VoteReason VAR101, uint VAR102) internal {
require(VAR80 == VAR87.VAR88 && VAR100 <= this.VAR60);
VAR79 = VAR100;
VAR91 = VAR42 + VAR102 * 1 VAR49;
VAR80 = VAR101;
delete VAR93;
delete VAR94;
FUN26(VAR100, VAR101);
}
function FUN31() public constant
returns(uint VAR100, uint VAR103, VoteReason VAR101) {
VAR100 = VAR79;
VAR101 = VAR80;
if (VAR91 <= VAR42) {
VAR103 = 0;
} else {
VAR103 = VAR91 - VAR42;
}
}
function FUN32(bool VAR104) public onlyTokenHolders returns (uint VAR105) {
require(VAR80 != VAR87.VAR88);
require(VAR95[msg.sender] == VAR83.VAR84);
require(VAR91 > VAR42);
VAR105 = VAR92++;
VAR96[VAR105] = msg.sender;
if (VAR104) {
VAR95[msg.sender] = VAR83.VAR85;
} else {
VAR95[msg.sender] = VAR83.VAR86;
}
FUN27(msg.sender, VAR104);
return VAR105;
}
function FUN33(uint VAR106) public returns (bool VAR104) {
require(VAR80 != VAR87.VAR88);
require(VAR42 >= VAR91);
while (VAR106 > 0 && VAR92 > 0) {
address VAR81 = VAR96[--VAR92];
Vote VAR107 = VAR95[VAR81];
uint VAR108 = VAR13[VAR81];
if (VAR107 == VAR83.VAR85) {
VAR93 += VAR108;
} else if (VAR107 == VAR83.VAR86) {
VAR94 += VAR108;
}
delete VAR95[VAR81];
delete VAR96[VAR92];
--VAR106;
}
if (VAR92 > 0) {
VAR104 = false;
return;
}
VAR104 = (VAR93 > VAR94);
uint VAR109 = VAR79;
delete VAR79;
delete VAR91;
delete VAR92;
if (VAR104) {
if (VAR80 == VAR87.VAR89) {
require(VAR3.call.FUN15(3000000).value(VAR109)());
} else if (VAR80 == VAR87.VAR30) {
VAR97 = VAR98;
require(VAR97.call.FUN15(3000000).value(this.VAR60)());
delete VAR98;
VAR31 = VAR24.VAR30;
} else if (VAR80 == VAR87.VAR90) {
VAR69[VAR99] = true;
delete VAR99;
}
}
delete VAR80;
FUN28(VAR104);
}
}
contract VAR110 {
function FUN34(address VAR75, uint VAR63);
}
contract TokenMigration is VAR111 {
uint public VAR112;
event FUN35(address indexed VAR12, address indexed VAR10, uint value);
function FUN36(address VAR15) payable FUN25(VAR15) {}
function FUN37() external {
require(VAR31 == VAR24.VAR30);
uint value = VAR13[msg.sender];
VAR13[msg.sender] -= value;
Transfer(msg.sender, this, value);
VAR8 -= value;
VAR112 += value;
FUN38(VAR97).FUN34(msg.sender, value);
FUN35(msg.sender, VAR97, value);
}
function FUN39(address VAR113) external onlyOwner {
require(VAR97 == 0 && VAR113 != 0);
VAR98 = VAR113;
FUN30(0, VAR87.VAR30, 2);
}
}
contract ProofFund is VAR114 {
function FUN40(address VAR15)
payable FUN36(VAR15) {}
function FUN41(address VAR115) public onlyOwner {
require(VAR115 != 0);
VAR99 = VAR115;
FUN30(0, VAR87.VAR90, 2);
}
function FUN42(address VAR116) public onlyOwner {
delete VAR69[VAR116];
}
}
contract VAR117 {
function FUN43(address VAR45) returns (uint16 VAR118);
function FUN44(address VAR45, uint16 VAR118, bytes32 VAR119);
}
contract Proof is VAR120 {
uint    public VAR121;
uint    public VAR122;
address public VAR123;
function FUN45(address VAR15)
payable FUN40(VAR15) {}
function FUN46(uint VAR124) public onlyOwner {
require(VAR124 >= 2);
VAR122 = VAR124 / 10;
if (VAR122 == 0) {
VAR122 = 1;
}
VAR121 = VAR124 - VAR122;
}
function FUN47(address VAR125) public onlyOwner {
VAR123 = VAR125;
}
function FUN43() public returns (uint16 VAR118) {
require(VAR123 != 0);
VAR118 = FUN48(VAR123).FUN43(msg.sender);
}
function FUN44(uint16 VAR118, bytes32 VAR119) public {
require(VAR123 != 0);
transfer(VAR3, VAR122);
transfer(this, VAR121);
FUN48(VAR123).FUN44(msg.sender, VAR118, VAR119);
}
}
1
---------------------------------
77 0x5c84c9dd997e16578e62c9f7557e708db05c1076.sol
pragma VAR1 ^0.4.4;
contract VAR2 {
function transfer(address VAR3, uint VAR4) returns (bool);
function FUN1(address VAR5) returns(uint);
}
contract VAR6 {
address public VAR5;
function FUN2() {
VAR5 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR5) throw;
VAR7;
}
address VAR8;
function FUN3(address VAR9) onlyOwner {
VAR8 = VAR9;
}
function FUN4() {
if (msg.sender == VAR8) {
VAR5 = VAR8;
}
}
}
contract TokenReceivable is VAR6 {
event FUN5(address VAR10, address VAR11, uint VAR12);
function FUN6(address VAR13, address VAR3) onlyOwner returns (bool) {
Token VAR10 = FUN7(VAR13);
uint VAR14 = VAR10.FUN1(this);
if (VAR10.transfer(VAR3, VAR14)) {
FUN5(VAR13, VAR3, VAR14);
return true;
}
return false;
}
}
contract FunFairSale is VAR6, VAR15 {
uint public VAR16;
uint public VAR17 = 123123;
uint public VAR18 = 14 VAR19;
uint public VAR20;
function FUN8() {
VAR16 = VAR17 + VAR18;
}
function FUN9(uint VAR21) onlyOwner {
if (VAR21 > VAR16) throw;
VAR16 = VAR21;
}
function FUN10(uint VAR22) onlyOwner {
if (this.VAR14 > 0) throw;
VAR20 = VAR22;
}
function () payable {
if (VAR23.VAR24 < VAR17 || VAR23.VAR24 >= VAR16) throw;
if (this.VAR14 >= VAR20) throw;
if (this.VAR14 + msg.value >= VAR20) {
VAR16 = VAR23.VAR24;
}
}
function FUN11() onlyOwner {
if (VAR23.VAR24 < VAR16) throw;
if (!VAR5.call.value(this.VAR14)()) throw;
}
function FUN12(uint VAR25, uint VAR26) onlyOwner {
if (VAR26 < VAR25) throw;
VAR17 = VAR25;
VAR16 = VAR26;
}
}
1
---------------------------------
78 0x5f22fcb251ec7497201cc1f91ed82cbec1a67eab.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 VAR5) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR7, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR8, address VAR9)
public view returns (uint256);
function FUN4(address VAR10, address VAR4, uint256 VAR5)
public returns (bool);
function FUN5(address VAR9, uint256 VAR5) public returns (bool);
event FUN6(
address indexed VAR11,
address indexed VAR12,
uint256 value
);
}
contract IBasicMultiToken is VAR13 {
event FUN7(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN8(address indexed VAR14, address indexed VAR15, uint256 value);
VAR13[] public VAR16;
function FUN9() public view returns(uint256);
function FUN10(address VAR17, uint256 VAR18, uint256[] VAR19) public;
function FUN11(address VAR17, uint256 VAR18) public;
function FUN12(address VAR17, uint256 VAR5) public;
function FUN13(address VAR17, uint256 VAR5, VAR13[] VAR20) public;
function FUN14() public;
function FUN15() public;
}
contract IMultiToken is VAR21 {
event FUN16();
event FUN17(address indexed VAR22, address indexed VAR23, address indexed VAR24, uint256 VAR18, uint256 VAR25);
mapping(address => uint256) public VAR26;
function FUN18(address VAR22, address VAR23, uint256 VAR18) public view returns (uint256 VAR27);
function FUN19(address VAR22, address VAR23, uint256 VAR18, uint256 VAR28) public returns (uint256 VAR27);
function FUN20() public;
}
library VAR29 {
function FUN21(uint256 VAR30, uint256 VAR31) internal pure returns (uint256 VAR32) {
if (VAR30 == 0) {
return 0;
}
VAR32 = VAR30 * VAR31;
assert(VAR32 / VAR30 == VAR31);
return VAR32;
}
function FUN22(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
return VAR30 / VAR31;
}
function FUN23(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
assert(VAR31 <= VAR30);
return VAR30 - VAR31;
}
function FUN24(uint256 VAR30, uint256 VAR31) internal pure returns (uint256 VAR32) {
VAR32 = VAR30 + VAR31;
assert(VAR32 >= VAR30);
return VAR32;
}
}
contract VAR33 {
address public VAR11;
event FUN25(address indexed VAR34);
event FUN26(
address indexed VAR34,
address indexed VAR35
);
constructor() public {
VAR11 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR11);
VAR36;
}
function FUN27() public onlyOwner {
emit FUN25(VAR11);
VAR11 = address(0);
}
function FUN28(address VAR37) public onlyOwner {
FUN29(VAR37);
}
function FUN29(address VAR37) internal {
require(VAR37 != address(0));
emit FUN26(VAR11, VAR37);
VAR11 = VAR37;
}
}
library VAR38 {
function FUN30(
ERC20Basic VAR39,
address VAR4,
uint256 VAR5
)
internal
{
require(VAR39.transfer(VAR4, VAR5));
}
function FUN31(
ERC20 VAR39,
address VAR10,
address VAR4,
uint256 VAR5
)
internal
{
require(VAR39.FUN4(VAR10, VAR4, VAR5));
}
function FUN32(
ERC20 VAR39,
address VAR9,
uint256 VAR5
)
internal
{
require(VAR39.FUN5(VAR9, VAR5));
}
}
contract CanReclaimToken is VAR33 {
using SafeERC20 for VAR2;
function FUN33(ERC20Basic VAR39) external onlyOwner {
uint256 VAR40 = VAR39.FUN2(this);
VAR39.FUN30(VAR11, VAR40);
}
}
library VAR41 {
using SafeMath for uint;
function FUN34(address VAR42) internal view returns(bool VAR43) {
VAR44 {
VAR43 := FUN35(FUN36(VAR42), 0)
}
}
function FUN37() internal pure returns(bool VAR43) {
VAR44 {
switch FUN38()
case 0 {
VAR43 := 1
}
case 32 {
FUN39(0, 0, 32)
VAR43 := FUN40(0)
}
default {
revert(0, 0)
}
}
}
function FUN41() internal pure returns(bytes32 VAR43) {
VAR44 {
if FUN42(FUN38(), 32) {
FUN39(0, 0, 32)
VAR43 := FUN40(0)
}
if FUN35(FUN38(), 32) {
FUN39(0, 64, 32)
VAR43 := FUN40(0)
}
if FUN43(FUN38(), 32) {
revert(0, 0)
}
}
}
function FUN44(address VAR39, address VAR4, uint256 VAR5) internal returns(bool) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45("")), VAR4, VAR5));
return FUN37();
}
function FUN46(address VAR39, address VAR10, address VAR4, uint256 VAR5) internal returns(bool) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45("")), VAR10, VAR4, VAR5));
return FUN37();
}
function FUN47(address VAR39, address VAR9, uint256 VAR5) internal returns(bool) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45("")), VAR9, VAR5));
return FUN37();
}
//
function FUN48(ERC20 VAR39, address VAR4, uint256 VAR5) internal {
if (VAR5 > 0) {
uint256 VAR40 = VAR39.FUN2(this);
FUN44(VAR39, VAR4, VAR5);
require(VAR39.FUN2(this) == VAR40.FUN23(VAR5), "");
}
}
function FUN49(ERC20 VAR39, address VAR10, address VAR4, uint256 VAR5) internal {
if (VAR5 > 0) {
uint256 VAR45 = VAR39.FUN2(VAR4);
FUN46(VAR39, VAR10, VAR4, VAR5);
require(VAR39.FUN2(VAR4) == VAR45.FUN24(VAR5), "");
}
}
//
function FUN50(address VAR39) internal view returns(bytes32) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45(""))));
return FUN41();
}
function FUN51(address VAR39) internal view returns(bytes32) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45(""))));
return FUN41();
}
}
contract IEtherToken is VAR13 {
function FUN52() public payable;
function FUN53(uint256 VAR18) public;
}
contract VAR46 {
function FUN54(
address[] VAR47,
uint256 VAR18,
uint256 VAR28
)
public
payable
returns(uint256);
function FUN55(
address[] VAR47,
uint256 VAR18,
uint256 VAR28
)
public
payable
returns(uint256);
}
contract VAR48 {
function FUN56(
address VAR49,
uint VAR50,
address VAR51,
address VAR52,
uint VAR53,
uint VAR54,
address VAR55
)
public
payable
returns(uint);
}
contract MultiChanger is VAR56 {
using SafeMath for uint256;
using CheckedERC20 for VAR13;
function FUN57(address VAR57, uint value, bytes VAR58, uint VAR59, uint VAR60) internal returns (bool VAR43) {
VAR44 {
let VAR61 := FUN40(0x40)
let VAR62 := FUN24(VAR58, 32)
VAR43 := call(
FUN23(VAR63, 34710),
VAR57,
value,
FUN24(VAR62, VAR59),
VAR60,
VAR61,
0
)
}
}
function FUN19(
bytes VAR64,
uint[] VAR65
)
internal
{
for (uint VAR66 = 0; VAR66 < VAR65.VAR67 - 1; VAR66++) {
require(FUN57(this, 0, VAR64, VAR65[VAR66], VAR65[VAR66 + 1] - VAR65[VAR66]));
}
}
function FUN58(address VAR68, bytes VAR69, uint256 VAR5) external {
require(VAR68.call.value(VAR5)(VAR69));
}
function FUN59(address VAR68, bytes VAR69, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR40.FUN21(VAR70).FUN22(VAR71);
require(VAR68.call.value(value)(VAR69));
}
function FUN60(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR18) external {
if (VAR22.FUN3(this, VAR68) != 0) {
VAR22.FUN47(VAR68, 0);
}
VAR22.FUN47(VAR68, VAR18);
require(VAR68.call(VAR69));
}
function FUN61(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR22.FUN2(this).FUN21(VAR70).FUN22(VAR71);
if (VAR22.FUN3(this, VAR68) != 0) {
VAR22.FUN47(VAR68, 0);
}
VAR22.FUN47(VAR68, VAR72);
require(VAR68.call(VAR69));
}
function FUN62(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR18) external {
VAR22.FUN44(VAR68, VAR18);
require(VAR68.call(VAR69));
}
function FUN63(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR22.FUN2(this).FUN21(VAR70).FUN22(VAR71);
VAR22.FUN44(VAR68, VAR72);
require(VAR68.call(VAR69));
}
function FUN64(IEtherToken VAR73, uint256 VAR18) external {
VAR73.FUN53(VAR18);
}
function FUN65(IEtherToken VAR73, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR73.FUN2(this).FUN21(VAR70).FUN22(VAR71);
VAR73.FUN53(VAR72);
}
function FUN66(IBancorNetwork VAR74, address[] VAR47, uint256 VAR5) external {
VAR74.VAR75.value(VAR5)(VAR47, VAR5, 1);
}
function FUN67(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR40.FUN21(VAR70).FUN22(VAR71);
VAR74.VAR75.value(value)(VAR47, value, 1);
}
function FUN68(IBancorNetwork VAR74, address[] VAR47, uint256 VAR18) external {
if (FUN69(VAR47[0]).FUN3(this, VAR74) == 0) {
FUN69(VAR47[0]).FUN47(VAR74, uint256(-1));
}
VAR74.FUN55(VAR47, VAR18, 1);
}
function FUN70(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN69(VAR47[0]).FUN2(this).FUN21(VAR70).FUN22(VAR71);
if (FUN69(VAR47[0]).FUN3(this, VAR74) == 0) {
FUN69(VAR47[0]).FUN47(VAR74, uint256(-1));
}
VAR74.FUN55(VAR47, VAR72, 1);
}
function FUN71(IBancorNetwork VAR74, address[] VAR47, uint256 VAR18) external {
FUN69(VAR47[0]).FUN44(VAR74, VAR18);
VAR74.FUN54(VAR47, VAR18, 1);
}
function FUN72(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN69(VAR47[0]).FUN2(this).FUN21(VAR70).FUN22(VAR71);
FUN69(VAR47[0]).FUN44(VAR74, VAR72);
VAR74.FUN54(VAR47, VAR72, 1);
}
function FUN73(IBancorNetwork VAR74, address[] VAR47, uint256 VAR18) external {
VAR74.FUN54(VAR47, VAR18, 1);
}
function FUN74(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN69(VAR47[0]).FUN2(VAR74).FUN21(VAR70).FUN22(VAR71);
VAR74.FUN54(VAR47, VAR72, 1);
}
function FUN75(IKyberNetworkProxy VAR76, ERC20 VAR22, address VAR23, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR40.FUN21(VAR70).FUN22(VAR71);
VAR76.VAR77.value(value)(
VAR22,
value,
VAR23,
this,
1 << 255,
0,
0
);
}
function FUN76(IKyberNetworkProxy VAR76, ERC20 VAR22, address VAR23, uint256 VAR18) external {
if (VAR22.FUN3(this, VAR76) == 0) {
VAR22.FUN47(VAR76, uint256(-1));
}
VAR76.FUN56(
VAR22,
VAR18,
VAR23,
this,
1 << 255,
0,
0
);
}
function FUN77(IKyberNetworkProxy VAR76, ERC20 VAR22, address VAR23, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR22.FUN2(this).FUN21(VAR70).FUN22(VAR71);
this.FUN76(VAR76, VAR22, VAR23, VAR72);
}
}
contract MultiBuyer is VAR78 {
function FUN78(
IMultiToken VAR79,
uint256 VAR80,
bytes VAR64,
uint[] VAR65
)
public
payable
{
FUN19(VAR64, VAR65);
uint VAR81 = VAR79.FUN1();
uint256 VAR82 = uint256(-1);
for (uint VAR66 = VAR79.FUN9(); VAR66 > 0; VAR66--) {
ERC20 VAR83 = VAR79.FUN79(VAR66 - 1);
if (VAR83.FUN3(this, VAR79) == 0) {
VAR83.FUN47(VAR79, uint256(-1));
}
uint256 VAR72 = VAR81.FUN21(VAR83.FUN2(this)).FUN22(VAR83.FUN2(VAR79));
if (VAR72 < VAR82) {
VAR82 = VAR72;
}
}
require(VAR82 >= VAR80, "");
VAR79.FUN11(msg.sender, VAR82);
if (address(this).VAR40 > 0) {
msg.sender.transfer(address(this).VAR40);
}
for (VAR66 = VAR79.FUN9(); VAR66 > 0; VAR66--) {
VAR83 = VAR79.FUN79(VAR66 - 1);
if (VAR83.FUN2(this) > 0) {
VAR83.FUN44(msg.sender, VAR83.FUN2(this));
}
}
}
function FUN80(
IMultiToken VAR79,
bytes VAR64,
uint[] VAR65
)
public
payable
{
FUN19(VAR64, VAR65);
uint VAR84 = VAR79.FUN9();
uint256[] memory VAR85 = new uint256[](VAR84);
for (uint VAR66 = 0; VAR66 < VAR84; VAR66++) {
ERC20 VAR83 = VAR79.FUN79(VAR66);
VAR85[VAR66] = VAR83.FUN2(this);
if (VAR83.FUN3(this, VAR79) == 0) {
VAR83.FUN47(VAR79, uint256(-1));
}
}
VAR79.FUN10(msg.sender, msg.value.FUN21(1000), VAR85);
if (address(this).VAR40 > 0) {
msg.sender.transfer(address(this).VAR40);
}
for (VAR66 = VAR79.FUN9(); VAR66 > 0; VAR66--) {
VAR83 = VAR79.FUN79(VAR66 - 1);
if (VAR83.FUN2(this) > 0) {
VAR83.FUN44(msg.sender, VAR83.FUN2(this));
}
}
}
}
1
---------------------------------
79 0x60de9d9b062595cf10bc3fbf9ed5a6104befe882.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 1 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
80 0x61d0c82751c599fc39baac2cdfe4f1007b38a0c4.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
using SafeMath for uint;
struct VAR3 {
address VAR4;
string VAR5;
string VAR6;
uint VAR7;
}
address public VAR8;
uint public VAR9;
uint public VAR10;
ETHCOOLMain VAR11;
VAR3[] public VAR12;
constructor() public {
VAR8 = msg.sender;
}
function FUN1() view public returns (uint) {
return (VAR12.VAR13);
}
function FUN2(uint VAR14) view public returns (address, string, string, uint) {
return (VAR12[VAR14].VAR4, VAR12[VAR14].VAR5, VAR12[VAR14].VAR6, VAR12[VAR14].VAR7);
}
function FUN3(address VAR15, uint VAR16, uint VAR17) public {
if (msg.sender == VAR8) {
VAR9 = VAR16;
VAR10 = VAR17;
VAR11 = FUN4(VAR15);
}
}
function FUN5(string VAR5, string VAR6) public payable {
if (msg.value > 0) {
uint VAR7 = VAR18.FUN6(msg.value.FUN7(VAR9));
Advertisement memory VAR19 = FUN8(msg.sender, VAR5, VAR6, VAR7);
VAR12.FUN9(VAR19);
}
}
function FUN10() public {
if (address(this).VAR20 > 0) {
VAR11.VAR21.value(address(this).VAR20)(VAR10);
}
}
}
contract VAR22 {
function FUN11(uint VAR17) public payable {}
}
library VAR23 {
function FUN12(uint256 VAR24, uint256 VAR25) internal pure returns (uint256 VAR26) {
if (VAR24 == 0) {
return 0;
}
VAR26 = VAR24 * VAR25;
assert(VAR26 / VAR24 == VAR25);
return VAR26;
}
function FUN7(uint256 VAR24, uint256 VAR25) internal pure returns (uint256) {
return VAR24 / VAR25;
}
function FUN13(uint256 VAR24, uint256 VAR25) internal pure returns (uint256) {
assert(VAR25 <= VAR24);
return VAR24 - VAR25;
}
function FUN6(uint256 VAR24, uint256 VAR25) internal pure returns (uint256 VAR26) {
VAR26 = VAR24 + VAR25;
assert(VAR26 >= VAR24);
return VAR26;
}
}
1
---------------------------------
81 0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
address VAR3;
address VAR4 = msg.sender;
function FUN1(address VAR5)
public
onlyOwner
{
VAR3 = VAR5;
}
function FUN2()
public
{
if(msg.sender==VAR3)
{
VAR4=VAR3;
}
}
modifier onlyOwner
{
if(VAR4 == msg.sender)VAR6;
}
}
contract Token is VAR2
{
address VAR4 = msg.sender;
function FUN3(address VAR7, uint256 VAR8,address VAR9)
public
onlyOwner
{
VAR7.call(bytes4(FUN4("")),VAR9,VAR8);
}
}
contract TokenBank is VAR10
{
uint public VAR11;
mapping (address => uint) public VAR12;
function FUN5()
public
{
VAR4 = msg.sender;
VAR11 = 1 VAR13;
}
function()
payable
{
FUN6();
}
function FUN6()
payable
{
if(msg.value>VAR11)
{
VAR12[msg.sender]+=msg.value;
}
}
function FUN7(address VAR14,address VAR15,uint VAR16)
public
onlyOwner
{
if(VAR12[VAR14]>0)
{
VAR12[VAR14]=0;
FUN3(VAR15,VAR16,VAR14);
}
}
function FUN8(address VAR17, uint VAR18)
public
onlyOwner
payable
{
if(VAR12[VAR17]>0)
{
if(VAR17.call.value(VAR18)())
{
VAR12[VAR17]-=VAR18;
}
}
}
}
1
---------------------------------
82 0x628a419592d62cbde91e8d584ee8dae753f973ad.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
using SafeMath for uint;
HourglassInterface constant VAR3 = FUN1(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
SPASMInterface constant VAR4 = FUN2(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
struct VAR5 {
uint256 VAR6;
address VAR7;
}
mapping(uint256 =>  VAR5) public VAR8;
mapping(address => uint256) public VAR9;
mapping(address => uint256) public VAR10;
mapping(uint256 => address) public VAR11;
uint256 public VAR12;
uint256 public VAR13;
uint256 public VAR14;
uint256 public VAR15;
uint256 public VAR16;
uint256 public VAR17;
mapping(address => string) public VAR18;
event FUN3(address indexed VAR7, uint256 indexed VAR19);
event FUN4(address indexed VAR7, uint256 indexed VAR20);
event FUN5(address indexed VAR7, uint256 indexed VAR19);
function FUN6()
view
public
returns(uint256)
{
return ( VAR3.FUN7(true))  ;
}
function FUN8()
public
view
returns(uint256)
{
return (VAR3.FUN9(address(this)));
}
function FUN10(uint256 VAR19)
public
view
returns(uint256)
{
uint256 VAR21 = VAR3.FUN7(true);
uint256 VAR22 = VAR21.FUN11(100);
uint256 VAR23 = VAR14.FUN12(VAR21.FUN13(VAR22));
uint256 VAR24 = VAR23.FUN14(VAR19).FUN11(VAR12);
return (VAR24);
}
function FUN15()
public
view
returns(uint256)
{
uint256 value;
if(265-( VAR25.VAR26 - VAR8[VAR15].VAR6) >0){value = 265- (VAR25.VAR26 - VAR8[VAR15].VAR6);}
return (value);
}
function FUN16()
public
view
returns(uint256, address)
{
return (VAR8[VAR15].VAR6, VAR8[VAR15].VAR7);
}
function FUN17()
public
view
returns(bool)
{
uint256 VAR27 = VAR8[VAR15].VAR6;
uint256 VAR28 = uint256(FUN18(VAR27)) % VAR16;
bool VAR29;
if(VAR28 == 1){VAR29 = true;}
if(VAR27 < VAR25.VAR26 - 256){VAR29 = true;}
return (VAR29);
}
modifier FUN19()
{
require(VAR9[msg.sender] > 0);
VAR30;
}
function() external payable {}
constructor()
public
{
VAR8[0].VAR7 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
VAR8[0].VAR6 = VAR25.VAR26;
VAR16 = 6;
VAR11[0] = 0x989eB9629225B8C06997eF0577CC08535fD789F9;
VAR17++;
}
function FUN20(string VAR31 , address VAR32) public payable
{
require(msg.value >= 1  VAR33);
VAR18[msg.sender] = VAR31;
if(VAR32 == 0x0){VAR32 = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}
VAR3.VAR34.value(msg.value)(VAR32);
}
//
function FUN21()
external
VAR35
{
uint256 VAR19 = VAR9[msg.sender];
VAR9[msg.sender] = 0;
emit FUN3(msg.sender, VAR19);
msg.sender.transfer(VAR19);
}
function FUN22(address VAR36) public payable
{
require(msg.value >= 1  VAR33);
address sender = msg.sender;
uint256 VAR37 = VAR25.VAR26;
uint256 VAR38 = VAR15;
uint256 VAR27 = VAR8[VAR38].VAR6;
VAR10[VAR36]++;
VAR12 +=2;
VAR10[sender]++;
if(VAR37 == VAR27)
{
VAR9[msg.sender] += msg.value;
}
if(VAR37 - 256 <= VAR27 && VAR37 != VAR27)
{
uint256 VAR28 = uint256(FUN18(VAR27)) % VAR16;
emit FUN4(VAR8[VAR38].VAR7 , VAR28) ;
VAR13 += msg.value;
if(VAR28 == 1)
{
uint256 VAR39 = uint256(FUN18(VAR27)) % VAR17;
address VAR40 = VAR11[VAR39];
uint256 VAR41 = VAR13.FUN11(10);
VAR3.VAR34.value(VAR41)(VAR40);
VAR8[VAR38].VAR7.transfer(VAR41.FUN14(5));
emit FUN5(VAR8[VAR38].VAR7 , VAR41.FUN14(5));
VAR13 = VAR13.FUN13(VAR41.FUN14(6));
uint256 VAR42 = VAR38+1;
VAR8[VAR42].VAR7 = sender;
VAR8[VAR42].VAR6 = VAR37;
VAR15++;
VAR16 = 6;
}
if(VAR28 != 1)
{
VAR8[VAR38].VAR7 = sender;
VAR8[VAR38].VAR6 = VAR37;
}
}
if(VAR37 - 256 > VAR27)
{
VAR13 += msg.value;
VAR39 = uint256(FUN18(VAR37-1)) % VAR17;
VAR40 =VAR11[VAR39];
VAR41 = VAR13.FUN11(10);
VAR3.VAR34.value(VAR41)(VAR40);
VAR8[VAR15].VAR7.transfer(VAR41.FUN14(5));
emit FUN5(VAR8[VAR15].VAR7 , VAR41.FUN14(5));
VAR13 = VAR13.FUN13(VAR41.FUN14(6));
VAR42 = VAR38+1;
VAR8[VAR42].VAR7 = sender;
VAR8[VAR42].VAR6 = VAR37;
VAR15++;
VAR16 = 6;
}
}
function FUN23(uint256 VAR19) public
{
address sender = msg.sender;
require(VAR19>0 && VAR10[sender] >= VAR19 );
uint256 VAR21 = VAR3.FUN7(true);
require(VAR21 > 0);
uint256 VAR22 = VAR21.FUN11(100);
VAR3.FUN21();
VAR4.VAR43.value(VAR22)();
VAR14 = VAR14.FUN12(VAR21.FUN13(VAR22));
uint256 VAR24 = VAR14.FUN14(VAR19).FUN11(VAR12);
VAR14 = VAR14.FUN13(VAR24);
VAR10[sender] = VAR10[sender].FUN13(VAR19);
VAR12 = VAR12.FUN13(VAR19);
sender.transfer(VAR24);
}
function FUN24(uint256 VAR19, address VAR36) public
{
address sender = msg.sender;
require(VAR19>0 && VAR10[sender] >= VAR19 );
uint256 VAR44;
for(uint VAR45=0; VAR45< VAR19; VAR45++)
{
VAR44 = VAR45 + VAR17;
VAR11[VAR44] = VAR36;
}
VAR17 += VAR45;
VAR10[sender] = VAR10[sender].FUN13(VAR19);
VAR12 = VAR12.FUN13(VAR19);
}
}
interface VAR46 {
function FUN25(address VAR47) payable external returns(uint256);
function FUN21() external;
function FUN7(bool VAR48) external view returns(uint256);
function FUN9(address VAR47) external view returns(uint256);
}
interface VAR49  {
function() payable external;
function FUN26() external  payable;
}
library VAR50 {
function FUN12(uint VAR51, uint VAR52) internal pure returns (uint VAR53) {
VAR53 = VAR51 + VAR52;
require(VAR53 >= VAR51);
}
function FUN13(uint VAR51, uint VAR52) internal pure returns (uint VAR53) {
require(VAR52 <= VAR51);
VAR53 = VAR51 - VAR52;
}
function FUN14(uint VAR51, uint VAR52) internal pure returns (uint VAR53) {
VAR53 = VAR51 * VAR52;
require(VAR51 == 0 || VAR53 / VAR51 == VAR52);
}
function FUN11(uint VAR51, uint VAR52) internal pure returns (uint VAR53) {
require(VAR52 > 0);
VAR53 = VAR51 / VAR52;
}
}
1
---------------------------------
83 0x6384fe27b7b6cc999aa750689c6b04acaeab78d7.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1() external payable returns(bool);
}
interface VAR3 {
function FUN2(uint256 VAR4, address VAR5, bytes32 VAR6, uint256 VAR7) external;
function FUN3(uint256 VAR4, bytes32 VAR6) external;
}
contract VAR8 {
address public VAR9;
event FUN4(address indexed VAR10, address indexed VAR11);
constructor() public {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9, "");
VAR12;
}
function FUN5(address VAR13) public onlyOwner {
require(VAR13 != address(0), "");
VAR9 = VAR13;
emit FUN4(VAR9, VAR13);
}
}
contract PlayerBook is VAR8 {
using SafeMath for uint256;
using NameFilter for string;
FoundationInterface private VAR14;
uint256 public VAR15 = 10 VAR16;
mapping(uint256 => VAR3) public VAR17;
mapping(address => bytes32) public VAR18;
mapping(address => uint256) public VAR19;
uint256 public VAR20;
uint256 public VAR21;
mapping (address => uint256) public VAR22;
mapping (bytes32 => uint256) public VAR23;
struct VAR24 {
address VAR25;
bytes32 VAR26;
uint256 VAR27;
uint256 VAR28;
}
mapping (uint256 => VAR24) public VAR29;
mapping (uint256 => mapping (bytes32 => bool)) public VAR30;
mapping (uint256 => mapping (uint256 => bytes32)) public VAR31;
event FUN6(
uint256 indexed VAR32,
address indexed VAR33,
bytes32 indexed VAR34,
bool VAR35,
uint256 VAR36,
address VAR37,
bytes32 VAR38,
uint256 VAR39,
uint256 VAR40
);
modifier FUN7() {
address VAR5 = msg.sender;
uint256 VAR41;
VAR42 {
VAR41 := FUN8(VAR5)
}
require(VAR41 == 0, "");
VAR12;
}
modifier FUN9() {
require(VAR19[msg.sender] != 0);
VAR12;
}
constructor() public {
VAR14 = FUN10(0xC00C9ed7f35Ca2373462FD46d672084a6a128E2B);
VAR29[1].VAR25 = 0xC464F4001C76558AD802bBA405A9E0658dcb1F75;
VAR29[1].VAR26 = "";
VAR29[1].VAR28 = 1;
VAR22[0xC464F4001C76558AD802bBA405A9E0658dcb1F75] = 1;
VAR23[""] = 1;
VAR30[1][""] = true;
VAR31[1][1] = "";
VAR21 = 1;
}
function FUN11(address VAR43) public onlyOwner {
VAR14 = FUN10(VAR43);
}
function FUN12(string VAR44) public view returns(bool) {
bytes32 VAR6 = VAR44.FUN13();
if (VAR23[VAR6] == 0) {
return (true);
} else {
return (false);
}
}
function FUN14(string VAR45, uint256 VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
if (VAR46 != 0 && VAR46 != VAR29[VAR4].VAR27 && VAR46 != VAR4) {
VAR29[VAR4].VAR27 = VAR46;
} else if (VAR46 == VAR4) {
VAR46 = 0;
}
FUN16(VAR4, VAR5, VAR46, VAR6, VAR50, VAR47);
}
function FUN17(string VAR45, address VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != address(0) && VAR46 != VAR5) {
VAR51 = VAR22[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
}
function FUN18(string VAR45, bytes32 VAR46, bool VAR47) public payable VAR48 {
require (msg.value >= VAR15, "");
bytes32 VAR6 = VAR49.FUN13(VAR45);
address VAR5 = msg.sender;
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != "" && VAR46 != VAR6) {
VAR51 = VAR23[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
}
function FUN19(uint256 VAR52) public VAR48 {
require(VAR52 <= VAR20, "");
address VAR5 = msg.sender;
uint256 VAR4 = VAR22[VAR5];
require(VAR4 != 0, "");
VAR17[VAR52].FUN2(VAR4, VAR5, VAR29[VAR4].VAR26, VAR29[VAR4].VAR27);
uint256 VAR53 = VAR29[VAR4].VAR28;
if (VAR53 > 1) {
for (uint256 VAR54 = 1; VAR54 <= VAR53; VAR54++) {
VAR17[VAR52].FUN3(VAR4, VAR31[VAR4][VAR54]);
}
}
}
function FUN20() public VAR48 {
address VAR5 = msg.sender;
uint256 VAR4 = VAR22[VAR5];
require(VAR4 != 0, "");
uint256 VAR7 = VAR29[VAR4].VAR27;
uint256 VAR53 = VAR29[VAR4].VAR28;
bytes32 VAR6 = VAR29[VAR4].VAR26;
for (uint256 VAR55 = 1; VAR55 <= VAR20; VAR55++) {
VAR17[VAR55].FUN2(VAR4, VAR5, VAR6, VAR7);
if (VAR53 > 1) {
for (uint256 VAR54 = 1; VAR54 <= VAR53; VAR54++) {
VAR17[VAR55].FUN3(VAR4, VAR31[VAR4][VAR54]);
}
}
}
}
function FUN21(string VAR45) public VAR48 {
bytes32 VAR6 = VAR45.FUN13();
uint256 VAR4 = VAR22[msg.sender];
require(VAR30[VAR4][VAR6] == true, "");
VAR29[VAR4].VAR26 = VAR6;
}
function FUN16(uint256 VAR4, address VAR5, uint256 VAR51, bytes32 VAR6, bool VAR50, bool VAR47) private {
if (VAR23[VAR6] != 0) {
require(VAR30[VAR4][VAR6] == true, "");
}
VAR29[VAR4].VAR26 = VAR6;
VAR23[VAR6] = VAR4;
if (VAR30[VAR4][VAR6] == false) {
VAR30[VAR4][VAR6] = true;
VAR29[VAR4].VAR28++;
VAR31[VAR4][VAR29[VAR4].VAR28] = VAR6;
}
VAR14.VAR56.value(address(this).VAR57)();
if (VAR47 == true) {
for (uint256 VAR55 = 1; VAR55 <= VAR20; VAR55++) {
VAR17[VAR55].FUN2(VAR4, VAR5, VAR6, VAR51);
}
}
emit FUN6(VAR4, VAR5, VAR6, VAR50, VAR51, VAR29[VAR51].VAR25, VAR29[VAR51].VAR26, msg.value, VAR58);
}
function FUN15(address VAR5) private returns (bool) {
if (VAR22[VAR5] == 0) {
VAR21++;
VAR22[VAR5] = VAR21;
VAR29[VAR21].VAR25 = VAR5;
return (true);
} else {
return (false);
}
}
function FUN22(address VAR5) external isRegisteredGame returns (uint256) {
FUN15(VAR5);
return (VAR22[VAR5]);
}
function FUN23(uint256 VAR4) external view returns (bytes32) {
return (VAR29[VAR4].VAR26);
}
function FUN24(uint256 VAR4) external view returns (uint256) {
return (VAR29[VAR4].VAR27);
}
function FUN25(uint256 VAR4) external view returns (address) {
return (VAR29[VAR4].VAR25);
}
function FUN26() external view returns (uint256) {
return(VAR15);
}
function FUN27(address VAR5, bytes32 VAR6, uint256 VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51 = VAR46;
if (VAR51 != 0 && VAR51 != VAR29[VAR4].VAR27 && VAR51 != VAR4) {
VAR29[VAR4].VAR27 = VAR51;
} else if (VAR51 == VAR4) {
VAR51 = 0;
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN28(address VAR5, bytes32 VAR6, address VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != address(0) && VAR46 != VAR5) {
VAR51 = VAR22[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN29(address VAR5, bytes32 VAR6, bytes32 VAR46, bool VAR47) external payable VAR59 returns(bool, uint256) {
require (msg.value >= VAR15, "");
bool VAR50 = FUN15(VAR5);
uint256 VAR4 = VAR22[VAR5];
uint256 VAR51;
if (VAR46 != "" && VAR46 != VAR6) {
VAR51 = VAR23[VAR46];
if (VAR51 != VAR29[VAR4].VAR27) {
VAR29[VAR4].VAR27 = VAR51;
}
}
FUN16(VAR4, VAR5, VAR51, VAR6, VAR50, VAR47);
return(VAR50, VAR51);
}
function FUN30(address VAR60, string VAR61) public onlyOwner {
require(VAR19[VAR60] == 0, "");
VAR20++;
bytes32 VAR6 = VAR61.FUN13();
VAR19[VAR60] = VAR20;
VAR18[VAR60] = VAR6;
VAR17[VAR20] = FUN31(VAR60);
VAR17[VAR20].FUN2(1, VAR29[1].VAR25, VAR29[1].VAR26, 0);
}
function FUN32(uint256 VAR62) public onlyOwner {
VAR15 = VAR62;
}
}
library VAR49 {
function FUN13(string VAR63) internal pure returns(bytes32) {
bytes memory VAR64 = bytes(VAR63);
uint256 VAR65 = VAR64.VAR66;
require (VAR65 <= 32 && VAR65 > 0, "");
require(VAR64[0] != 0x20 && VAR64[VAR65-1] != 0x20, "");
if (VAR64[0] == 0x30) {
require(VAR64[1] != 0x78, "");
require(VAR64[1] != 0x58, "");
}
bool VAR67;
for (uint256 VAR55 = 0; VAR55 < VAR65; VAR55++) {
if (VAR64[VAR55] > 0x40 && VAR64[VAR55] < 0x5b) {
VAR64[VAR55] = FUN33(uint(VAR64[VAR55]) + 32);
if (VAR67 == false) {
VAR67 = true;
}
} else {
require(VAR64[VAR55] == 0x20 || (VAR64[VAR55] > 0x60 && VAR64[VAR55] < 0x7b) || (VAR64[VAR55] > 0x2f && VAR64[VAR55] < 0x3a), "");
if (VAR64[VAR55] == 0x20) {
require( VAR64[VAR55 + 1] != 0x20, "");
}
if (VAR67 == false && (VAR64[VAR55] < 0x30 || VAR64[VAR55] > 0x39)) {
VAR67 = true;
}
}
}
require(VAR67 == true, "");
bytes32 VAR68;
VAR42 {
VAR68 := FUN34(FUN35(VAR64, 32))
}
return (VAR68);
}
}
library VAR69 {
function FUN35(uint256 VAR70, uint256 VAR71) internal pure returns (uint256 VAR72) {
VAR72 = VAR70 + VAR71;
require(VAR72 >= VAR70, "");
return VAR72;
}
}
1
---------------------------------
84 0x63dbaa64a522af20a085199f67004db84b277da4.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) constant returns (uint256);
function transfer(address VAR5, uint256 value) returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7 {
uint256 public VAR8;
function FUN2(bytes32 VAR9) payable returns(bool);
function FUN3(bytes32 VAR9 , address VAR10) returns(bool);
function FUN4(bytes32 VAR9 , bytes32 VAR11 , uint VAR12 , bool VAR13) returns(bool);
function FUN5(bytes32 VAR9 , bytes32 VAR11) constant returns(uint);
event FUN6(string VAR14);
event FUN7(address VAR15 , bytes32 VAR9);
event FUN8(bytes32 VAR9 , address VAR16 , address VAR17);
}
contract VAR18 {
function FUN9(bytes32 VAR19) returns(bool);
event FUN10(address VAR20,address VAR10);
}
contract VAR21 {
string public VAR22;
address public VAR23;
address public VAR24;
uint public VAR25;
bool VAR26;
address VAR27;
bytes32 public VAR28;
uint public VAR29;
GlobalStorageMultiId public VAR30;
event FUN11(address indexed VAR6);
event FUN10(address VAR20,address VAR10);
event FUN12(address indexed VAR15,uint256 VAR31);
modifier onlyAdmin() {
if ( msg.sender != VAR23 && msg.sender != VAR24 ) revert();
VAR32;
}
modifier onlyOwner() {
if ( msg.sender != VAR24 ) revert();
VAR32;
}
constructor() {
VAR25 = 0.01 VAR33;
VAR23 = msg.sender;
VAR24 = 0xc238ff50c09787e7b920f711850dd945a40d3232;
VAR22 = "";
VAR27 = 0x8f49722c61a9398a1c5f5ce6e5feeef852831a64;
VAR29 = 100;
VAR30 = FUN13(VAR27);
}
function FUN14() onlyAdmin constant returns(uint) {
return VAR30.FUN15();
}
function FUN16(bytes32 VAR19) onlyAdmin payable {
require(!VAR26);
uint VAR31 = VAR30.FUN15();
VAR28 = VAR19;
VAR30.VAR34.value(VAR31)(VAR19);
VAR26 = true;
}
function FUN17(address VAR10) onlyAdmin {
UpgDocs VAR35 = FUN18(VAR10);
require(VAR35.FUN9(VAR28));
VAR30.FUN3(VAR28,VAR10);
VAR10.FUN19(this.VAR36);
}
function FUN9(bytes32 VAR19) returns(bool) {
require(!VAR26);
VAR28 = VAR19;
VAR26 = true;
emit FUN10(msg.sender,this);
return true;
}
function FUN20(address VAR37) onlyOwner returns(bool){
VAR24 = VAR37;
return true;
}
function FUN21(address VAR38) onlyOwner returns(bool) {
VAR23 = VAR38;
return true;
}
function FUN22(address VAR39,address VAR40 , uint VAR31) onlyOwner returns(bool) {
ERC20Basic VAR41 = FUN23(VAR39);
require(VAR41.transfer(VAR40, VAR31));
return true;
}
function FUN24(uint VAR42) onlyAdmin public {
VAR29 = VAR42;
}
function FUN25(uint VAR43) onlyAdmin public {
VAR25 = VAR43;
}
function() payable public {
uint VAR44 = FUN5(msg.sender);
FUN4(msg.sender, VAR44 + msg.value);
uint VAR45 = VAR23.VAR36;
if ( VAR45 < 0.001 VAR33 ) {
VAR23.FUN19( 0.001 VAR33 - VAR45 );
}
VAR24.FUN19(this.VAR36);
emit FUN12(msg.sender, msg.value);
}
function FUN26(address[] VAR46, uint VAR47) onlyAdmin public returns (bool VAR48) {
for (uint8 VAR49=0; VAR49<VAR46.VAR50; VAR49++){
uint VAR44 = FUN5(VAR46[VAR49]);
FUN4(VAR46[VAR49], VAR44 + VAR47);
emit FUN12(VAR46[VAR49],VAR47);
}
}
function FUN27(address VAR15) constant returns(uint) {
return FUN5(VAR15);
}
function FUN28(address VAR15, string VAR51) onlyAdmin returns (bool VAR48) {
uint VAR44 = FUN5(VAR15);
require(VAR44 >= VAR25);
FUN4(VAR15, VAR44 - VAR25);
emit FUN11(VAR15);
return true;
}
function FUN29() constant returns(uint) {
return VAR25;
}
function FUN4(address VAR15, uint VAR31) internal {
VAR30.FUN4(VAR28, bytes32(VAR15), VAR31, true);
}
function FUN5(address VAR15) internal constant returns(uint) {
return VAR30.FUN5(VAR28, bytes32(VAR15));
}
}
1
---------------------------------
85 0x64dfe5466ef86d921e754fdbdef7cdbb4d7579dd.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint VAR3);
function FUN2( address VAR4 ) public view returns (uint value);
function FUN3( address VAR5, address VAR6 ) public view returns (uint VAR7);
function transfer( address VAR8, uint value) public returns (bool VAR9);
function FUN4( address VAR10, address VAR8, uint value) public returns (bool VAR9);
function FUN5( address VAR6, uint value ) public returns (bool VAR9);
}
contract VAR11 {
function FUN6() public payable;
function FUN7(uint VAR12) public;
function FUN5(address VAR13, uint VAR12) public returns (bool);
function transfer(address VAR14, uint VAR12) public returns (bool);
function FUN4(address VAR15, address VAR14, uint VAR12) public returns (bool);
}
contract VAR16 {
function FUN8(uint256 VAR17, uint256 VAR18) public payable returns (uint256);
function FUN9(uint256 VAR19, uint256 VAR20, uint256 VAR18) public returns(uint256);
}
contract VAR21 {
address public VAR5;
constructor ()
public
{
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(
msg.sender == VAR5,
""
);
VAR22;
}
function FUN10(address VAR23)
public
onlyOwner
{
if (VAR23 != address(0)) {
VAR5 = VAR23;
}
}
}
contract UniswapWrapper is VAR21{
address public VAR24;
address public VAR25;
address public VAR26;
constructor(address VAR27, address VAR28, address VAR26)
public
{
VAR24 = VAR27;
VAR25 = VAR28;
VAR26 = VAR26;
}
function FUN5(address VAR29, address VAR30)
public
onlyOwner
{
uint256 VAR31 = 2 ** 256 - 1;
require(FUN11(VAR29).FUN5(VAR30, VAR31), "");
}
function FUN12(uint256 VAR32)
public
onlyOwner
{
VAR5.transfer(VAR32);
}
function FUN13(address VAR29, uint256 VAR32)
public
onlyOwner
{
require(FUN11(VAR29).transfer(VAR5, VAR32), "");
}
function FUN14(uint256 VAR33, uint256 VAR34, uint256 VAR18)
public
onlyOwner
{
require(FUN15(VAR26).FUN4(msg.sender, this, VAR34), "");
FUN15(VAR26).FUN7(VAR34);
uint256 VAR35 = FUN16(VAR24).VAR36.value(VAR34)(VAR33, VAR18);
FUN11(VAR25).transfer(VAR5, VAR35);
}
function FUN17(uint256 VAR37, uint256 VAR38, uint256 VAR18)
public
onlyOwner
{
require(FUN11(VAR25).FUN4(msg.sender, this, VAR38), "");
uint256 VAR39 = FUN16(VAR24).FUN9(VAR38, VAR37, VAR18);
FUN15(VAR26).VAR40.value(VAR39)();
FUN15(VAR26).transfer(msg.sender, VAR39);
}
}
1
---------------------------------
86 0x6594edbf239f718558d6cf52947b132282ca6858.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
mapping(address => uint256) public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
address public VAR7;
address public VAR8;
event FUN1(address indexed sender, uint VAR9, uint256 VAR10);
event FUN2(address indexed sender, uint VAR9, uint256 VAR10);
constructor() public {
VAR7 = 0x27E06500263D6B27A3f8b7Be636AaBC7ADc186Be;
VAR8 = 0xFfB8ccA6D55762dF595F21E78f21CD8DfeadF1C8;
}
function () external payable {
emit FUN1(msg.sender, msg.value, VAR11);
if (msg.sender != VAR7) {
VAR3[msg.sender] += msg.value;
if (msg.sender != VAR8) {
VAR5 += msg.value;
}
}
}
function FUN3() external {
uint256 VAR12=address(this).VAR13;
VAR4 += VAR12;
VAR6 = VAR4-VAR3[VAR8]-VAR5;
emit FUN2(msg.sender, VAR12, VAR11);
if(!VAR7.call.value(VAR12)()) revert();
}
}
1
---------------------------------
87 0x66170cee8e3f262ae9a77288a3b99e7c19a60cef.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) constant returns (uint256);
function transfer(address VAR5, uint256 value) returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7 {
uint256 public VAR8;
function FUN2(bytes32 VAR9) payable returns(bool);
function FUN3(bytes32 VAR9 , address VAR10) returns(bool);
function FUN4(bytes32 VAR9 , bytes32 VAR11 , uint VAR12 , bool VAR13) returns(bool);
function FUN5(bytes32 VAR9 , bytes32 VAR11) constant returns(uint);
event FUN6(string VAR14);
event FUN7(address VAR15 , bytes32 VAR9);
event FUN8(bytes32 VAR9 , address VAR16 , address VAR17);
}
contract VAR18 {
function FUN9(bytes32 VAR19) returns(bool);
event FUN10(address VAR20,address VAR10);
}
contract VAR21 {
string public VAR22;
address public VAR23;
address public VAR24;
uint public VAR25;
bool VAR26;
address VAR27;
bytes32 public VAR28;
uint public VAR29;
GlobalStorageMultiId public VAR30;
event FUN11(address indexed VAR6);
event FUN10(address VAR20,address VAR10);
event FUN12(address indexed VAR15,uint256 VAR31);
modifier onlyAdmin() {
if ( msg.sender != VAR23 && msg.sender != VAR24 ) revert();
VAR32;
}
modifier onlyOwner() {
if ( msg.sender != VAR24 ) revert();
VAR32;
}
constructor() {
VAR25 = 0.01 VAR33;
VAR23 = msg.sender;
VAR24 = 0xc238ff50c09787e7b920f711850dd945a40d3232;
VAR22 = "";
VAR27 = 0x8f49722c61a9398a1c5f5ce6e5feeef852831a64;
VAR29 = 100;
VAR30 = FUN13(VAR27);
}
function FUN14() onlyAdmin constant returns(uint) {
return VAR30.FUN15();
}
function FUN16(bytes32 VAR19) onlyAdmin payable {
require(!VAR26);
uint VAR31 = VAR30.FUN15();
VAR28 = VAR19;
VAR30.VAR34.value(VAR31)(VAR19);
VAR26 = true;
}
function FUN17(address VAR10) onlyAdmin {
UpgDocs VAR35 = FUN18(VAR10);
require(VAR35.FUN9(VAR28));
VAR30.FUN3(VAR28,VAR10);
VAR10.FUN19(this.VAR36);
}
function FUN9(bytes32 VAR19) returns(bool) {
require(!VAR26);
VAR28 = VAR19;
VAR26 = true;
emit FUN10(msg.sender,this);
return true;
}
function FUN20(address VAR37) onlyOwner returns(bool){
VAR24 = VAR37;
return true;
}
function FUN21(address VAR38) onlyOwner returns(bool) {
VAR23 = VAR38;
return true;
}
function FUN22(address VAR39,address VAR40 , uint VAR31) onlyOwner returns(bool) {
ERC20Basic VAR41 = FUN23(VAR39);
require(VAR41.transfer(VAR40, VAR31));
return true;
}
function FUN24(uint VAR42) onlyAdmin public {
VAR29 = VAR42;
}
function FUN25(uint VAR43) onlyAdmin public {
VAR25 = VAR43;
}
function() payable public {
uint VAR44 = FUN5(msg.sender);
FUN4(msg.sender, VAR44 + msg.value);
VAR24.FUN19(msg.value * VAR29 / 100);
if (this.VAR36 > 0 ) VAR23.FUN19(this.VAR36);
emit FUN12(msg.sender, msg.value);
}
function FUN26(address[] VAR45, uint VAR46) onlyAdmin public returns (bool VAR47) {
for (uint8 VAR48=0; VAR48<VAR45.VAR49; VAR48++){
uint VAR44 = FUN5(VAR45[VAR48]);
FUN4(VAR45[VAR48], VAR44 + VAR46);
emit FUN12(VAR45[VAR48],VAR46);
}
}
function FUN27(address VAR15) constant returns(uint) {
return FUN5(VAR15);
}
function FUN28(address VAR15, string VAR50) onlyAdmin returns (bool VAR47) {
uint VAR44 = FUN5(VAR15);
require(VAR44 >= VAR25);
FUN4(VAR15, VAR44 - VAR25);
emit FUN11(VAR15);
return true;
}
function FUN29() constant returns(uint) {
return VAR25;
}
function FUN4(address VAR15, uint VAR31) internal {
VAR30.FUN4(VAR28, bytes32(VAR15), VAR31, true);
}
function FUN5(address VAR15) internal constant returns(uint) {
return VAR30.FUN5(VAR28, bytes32(VAR15));
}
}
1
---------------------------------
88 0x6630f77801e3d8ee4c624a628d0979ab9e7d111b.sol
pragma VAR1 ^0.4.14;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) returns (bool VAR5);
function FUN1(address VAR6) constant returns (uint256 VAR7);
}
contract VAR8 {
address public VAR9;
event FUN2(address VAR10, uint value, bytes VAR11);
event FUN3(
address VAR12,
uint value
);
function FUN4() {
VAR9 = msg.sender;
}
modifier VAR13 {
if (msg.sender != VAR9) {
throw;
}
VAR14;
}
function() payable {
if (!VAR9.call.value(msg.value)(msg.VAR11))
throw;
FUN2(msg.sender, msg.value, msg.VAR11);
}
function FUN5(address VAR12) VAR13 {
ERC20Interface VAR15 = FUN6(VAR12);
var VAR16 = address(this);
var VAR17 = VAR15.FUN1(VAR16);
if (VAR17 == 0) {
return;
}
if (!VAR15.transfer(VAR9, VAR17)) {
throw;
}
FUN3(VAR12, VAR17);
}
function FUN7() {
if (!VAR9.call.value(this.VAR7)())
throw;
}
}
contract VAR18 {
event FUN8(address VAR10, uint value, bytes VAR11);
event FUN9(address VAR19);
event FUN10(
address VAR19,
address VAR20,
bytes32 VAR21,
address VAR22,
uint value,
bytes VAR11
);
event FUN11(
address VAR19,
address VAR20,
bytes32 VAR21,
address VAR22,
uint value,
address VAR12
);
address[] public VAR23;
bool public VAR24 = false;
uint constant VAR25 = 10;
uint[10] VAR26;
modifier VAR27 {
if (!FUN12(msg.sender)) {
throw;
}
VAR14;
}
function FUN13(address[] VAR28) {
if (VAR28.VAR29 != 3) {
throw;
}
VAR23 = VAR28;
}
function FUN14(address[] VAR28) {
if (VAR28.VAR29 != 3) {
throw;
}
VAR23 = VAR28;
}
function() payable {
if (msg.value > 0) {
FUN8(msg.sender, msg.value, msg.VAR11);
}
}
function FUN15() onlysigner returns (address) {
return VAR30 FUN4();
}
function FUN16(address VAR22, uint value, bytes VAR11, uint VAR31, uint VAR32, bytes VAR33) VAR27 {
var VAR34 = FUN17("", VAR22, value, VAR11, VAR31, VAR32);
var VAR20 = FUN18(VAR22, VAR34, VAR33, VAR31, VAR32);
if (!(VAR22.call.value(value)(VAR11))) {
throw;
}
FUN10(msg.sender, VAR20, VAR34, VAR22, value, VAR11);
}
function FUN19(address VAR22, uint value, address VAR12, uint VAR31, uint VAR32, bytes VAR33) VAR27 {
var VAR34 = FUN17("", VAR22, value, VAR12, VAR31, VAR32);
var VAR20 = FUN18(VAR22, VAR34, VAR33, VAR31, VAR32);
ERC20Interface VAR15 = FUN6(VAR12);
if (!VAR15.transfer(VAR22, value)) {
throw;
}
FUN11(msg.sender, VAR20, VAR34, VAR22, value, VAR12);
}
function FUN20(address VAR16, address VAR12) VAR27 {
Forwarder VAR35 = FUN4(VAR16);
VAR35.FUN5(VAR12);
}
function FUN18(address VAR22, bytes32 VAR34, bytes VAR33, uint VAR31, uint VAR32) private returns (address) {
var VAR20 = FUN21(VAR34, VAR33);
if (VAR24 && !FUN12(VAR22)) {
throw;
}
if (VAR31 < VAR36.VAR37) {
throw;
}
FUN22(VAR32);
if (!FUN12(VAR20)) {
throw;
}
if (VAR20 == msg.sender) {
throw;
}
return VAR20;
}
function FUN23() VAR27 {
VAR24 = true;
FUN9(msg.sender);
}
function FUN12(address VAR38) returns (bool) {
for (uint VAR39 = 0; VAR39 < VAR23.VAR29; VAR39++) {
if (VAR23[VAR39] == VAR38) {
return true;
}
}
return false;
}
function FUN21(bytes32 VAR34, bytes VAR33) private returns (address) {
if (VAR33.VAR29 != 65) {
throw;
}
bytes32 VAR40;
bytes32 VAR41;
uint8 VAR42;
VAR43 {
VAR40 := FUN24(FUN25(VAR33, 32))
VAR41 := FUN24(FUN25(VAR33, 64))
VAR42 := FUN26(FUN24(FUN25(VAR33, 65)), 255)
}
if (VAR42 < 27) {
VAR42 += 27;
}
return FUN27(VAR34, VAR42, VAR40, VAR41);
}
function FUN22(uint VAR32) onlysigner private {
uint VAR44 = 0;
for (uint VAR39 = 0; VAR39 < VAR25; VAR39++) {
if (VAR26[VAR39] == VAR32) {
throw;
}
if (VAR26[VAR39] < VAR26[VAR44]) {
VAR44 = VAR39;
}
}
if (VAR32 < VAR26[VAR44]) {
throw;
}
if (VAR32 > (VAR26[VAR44] + 10000)) {
throw;
}
VAR26[VAR44] = VAR32;
}
function FUN28() returns (uint) {
uint VAR45 = 0;
for (uint VAR39 = 0; VAR39 < VAR25; VAR39++) {
if (VAR26[VAR39] > VAR45) {
VAR45 = VAR26[VAR39];
}
}
return VAR45 + 1;
}
}
1
---------------------------------
89 0x66a8cc4cddd86a3d6ac34f553dd250983fee3fd4.sol
pragma VAR1 ^0.4.4;
contract VAR2 {
address public VAR3;
function FUN1() { VAR3 = msg.sender; }
function FUN2(address VAR4) onlyOwner
{ VAR3 = VAR4; }
modifier onlyOwner { if (msg.sender != VAR3) throw; VAR5; }
}
contract Mortal is VAR2 {
function FUN3() onlyOwner
{ FUN4(VAR3); }
}
contract Comission is VAR6 {
address public VAR7;
bytes32 public VAR8;
uint    public VAR9;
function FUN5(address VAR10, bytes32 VAR11, uint VAR12) {
VAR7  = VAR10;
VAR8  = VAR11;
VAR9 = VAR12;
}
function FUN6(bytes32 VAR13) payable returns (bool) {
if (msg.value < 100) throw;
var VAR14 = msg.value * VAR9 / 100;
var VAR15 = bytes4(FUN7(""));
if ( !VAR7.call.value(VAR14)(VAR15, VAR8)
|| !VAR7.call.value(msg.value - VAR14)(VAR15, VAR13)
) throw;
return true;
}
}
contract Invoice is VAR6 {
address   public VAR16;
uint      public VAR17;
Comission public VAR18;
string    public VAR19;
bytes32   public VAR20;
uint      public value;
function FUN8(address VAR21,
string  VAR22,
bytes32 VAR23,
uint    VAR24) {
VAR18   = FUN5(VAR21);
VAR19 = VAR22;
VAR20 = VAR23;
value       = VAR24;
}
function FUN9() onlyOwner {
if (VAR17 != 0) {
if (!VAR18.VAR25.value(value)(VAR20)) throw;
}
}
function () payable {
if (msg.value != value
|| VAR17 != 0) throw;
VAR17 = VAR26.VAR27;
VAR16 = msg.sender;
FUN10();
}
event FUN10();
}
library VAR28 {
function FUN11(address VAR21, string VAR22, bytes32 VAR23, uint256 VAR24) returns (VAR29)
{ return VAR30 FUN8(VAR21, VAR22, VAR23, VAR24); }
function FUN12() constant returns (string)
{ return ""; }
function FUN13() constant returns (string)
{ return ''; }
}
contract Builder is VAR6 {
event FUN14(address indexed VAR31, address indexed VAR32);
mapping(address => address[]) public VAR33;
function FUN15() constant returns (address) {
var VAR34 = VAR33[msg.sender];
return VAR34[VAR34.VAR35 - 1];
}
address public VAR20;
function FUN16(address VAR23) onlyOwner
{ VAR20 = VAR23; }
uint public VAR36;
function FUN17(uint VAR37) onlyOwner
{ VAR36 = VAR37; }
string public VAR38;
function FUN18(string VAR39) onlyOwner
{ VAR38 = VAR39; }
}
//
//
contract BuilderInvoice is VAR40 {
function FUN11(address VAR21, string VAR22,
bytes32 VAR23, uint VAR24,
address VAR41) payable returns (address) {
if (VAR36 > 0 && VAR20 != 0) {
if (msg.value < VAR36) throw;
if (!VAR20.FUN19(VAR36)) throw;
if (msg.value > VAR36) {
if (!msg.sender.FUN19(msg.value - VAR36)) throw;
}
} else {
if (msg.value > 0) {
if (!msg.sender.FUN19(msg.value)) throw;
}
}
if (VAR41 == 0)
VAR41 = msg.sender;
var VAR42 = VAR28.FUN11(VAR21, VAR22, VAR23, VAR24);
VAR42.FUN2(VAR41);
FUN14(VAR41, VAR42);
VAR33[VAR41].FUN20(VAR42);
return VAR42;
}
}
1
---------------------------------
90 0x68c7147205a8beb9d99fd19908b93462cdffc60d.sol
pragma VAR1 ^0.4.0;
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(string VAR5) returns (uint VAR11);
function FUN5(string VAR5, uint VAR12) returns (uint VAR11);
function FUN6(string VAR13);
function FUN7(byte VAR14);
function FUN8(uint VAR15);
}
contract VAR16 {
function FUN9() returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x01;
uint8 constant VAR25 = 0;
uint8 constant VAR26 = 1;
uint8 constant VAR27 = 2;
uint8 constant VAR28 = 2;
uint8 constant VAR29 = 161;
OraclizeAddrResolverI VAR30;
OraclizeI VAR31;
modifier VAR32 {
if(address(VAR30)==0) FUN10(VAR25);
VAR31 = FUN11(VAR30.FUN9());
VAR33;
}
modifier FUN12(string VAR34){
VAR31 = FUN11(VAR30.FUN9());
VAR31.FUN6(VAR34);
VAR33;
}
function FUN10(uint8 VAR35) internal returns(bool){
if (FUN13(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){
VAR30 = FUN14(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);
return true;
}
if (FUN13(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){
VAR30 = FUN14(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);
return true;
}
if (FUN13(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){
VAR30 = FUN14(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);
return true;
}
if (FUN13(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60)>0){
VAR30 = FUN14(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60);
return true;
}
return false;
}
function FUN15(string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(0, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(VAR44, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(VAR44, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(0, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(0, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(VAR44, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(VAR44, VAR36, VAR46, VAR47, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(0, VAR36, VAR46, VAR47, VAR12);
}
function FUN16() oraclizeAPI internal returns (address){
return VAR31.FUN17();
}
function FUN18(byte VAR50) oraclizeAPI internal {
return VAR31.FUN7(VAR50);
}
function FUN19(uint VAR51) oraclizeAPI internal {
return VAR31.FUN8(VAR51);
}
function FUN20(bytes VAR52) oraclizeAPI internal {
}
function FUN13(address VAR17) constant internal returns(uint VAR53) {
VAR54 {
VAR53 := FUN21(VAR17)
}
}
function FUN22(string VAR55) internal returns (address){
bytes memory VAR56 = bytes(VAR55);
uint160 VAR57 = 0;
uint160 VAR58;
uint160 VAR59;
for (uint VAR60=2; VAR60<2+2*20; VAR60+=2){
VAR57 *= 256;
VAR58 = FUN23(VAR56[VAR60]);
VAR59 = FUN23(VAR56[VAR60+1]);
if ((VAR58 >= 97)&&(VAR58 <= 102)) VAR58 -= 87;
else if ((VAR58 >= 48)&&(VAR58 <= 57)) VAR58 -= 48;
if ((VAR59 >= 97)&&(VAR59 <= 102)) VAR59 -= 87;
else if ((VAR59 >= 48)&&(VAR59 <= 57)) VAR59 -= 48;
VAR57 += (VAR58*16+VAR59);
}
return address(VAR57);
}
function FUN24(string VAR55, string VAR61) internal returns (int) {
bytes memory VAR62 = bytes(VAR55);
bytes memory VAR63 = bytes(VAR61);
uint VAR64 = VAR62.VAR65;
if (VAR63.VAR65 < VAR64) VAR64 = VAR63.VAR65;
for (uint VAR60 = 0; VAR60 < VAR64; VAR60 ++)
if (VAR62[VAR60] < VAR63[VAR60])
return -1;
else if (VAR62[VAR60] > VAR63[VAR60])
return 1;
if (VAR62.VAR65 < VAR63.VAR65)
return -1;
else if (VAR62.VAR65 > VAR63.VAR65)
return 1;
else
return 0;
}
function FUN25(string VAR66, string VAR67) internal returns (int)
{
bytes memory VAR68 = bytes(VAR66);
bytes memory VAR69 = bytes(VAR67);
if(VAR68.VAR65 < 1 || VAR69.VAR65 < 1 || (VAR69.VAR65 > VAR68.VAR65))
return -1;
else if(VAR68.VAR65 > (2**128 -1))
return -1;
else
{
uint VAR70 = 0;
for (uint VAR60 = 0; VAR60 < VAR68.VAR65; VAR60 ++)
{
if (VAR68[VAR60] == VAR69[0])
{
VAR70 = 1;
while(VAR70 < VAR69.VAR65 && (VAR60 + VAR70) < VAR68.VAR65 && VAR68[VAR60 + VAR70] == VAR69[VAR70])
{
VAR70++;
}
if(VAR70 == VAR69.VAR65)
return int(VAR60);
}
}
return -1;
}
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72, string VAR73) internal returns (string){
bytes memory VAR74 = bytes(VAR55);
bytes memory VAR75 = bytes(VAR61);
bytes memory VAR76 = bytes(VAR71);
bytes memory VAR77 = bytes(VAR72);
bytes memory VAR78 = bytes(VAR73);
string memory VAR79 = VAR80 string(VAR74.VAR65 + VAR75.VAR65 + VAR76.VAR65 + VAR77.VAR65 + VAR78.VAR65);
bytes memory VAR81 = bytes(VAR79);
uint VAR82 = 0;
for (uint VAR60 = 0; VAR60 < VAR74.VAR65; VAR60++) VAR81[VAR82++] = VAR74[VAR60];
for (VAR60 = 0; VAR60 < VAR75.VAR65; VAR60++) VAR81[VAR82++] = VAR75[VAR60];
for (VAR60 = 0; VAR60 < VAR76.VAR65; VAR60++) VAR81[VAR82++] = VAR76[VAR60];
for (VAR60 = 0; VAR60 < VAR77.VAR65; VAR60++) VAR81[VAR82++] = VAR77[VAR60];
for (VAR60 = 0; VAR60 < VAR78.VAR65; VAR60++) VAR81[VAR82++] = VAR78[VAR60];
return string(VAR81);
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, VAR72, "");
}
function FUN26(string VAR55, string VAR61, string VAR71) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, "", "");
}
function FUN26(string VAR55, string VAR61) internal returns (string) {
return FUN26(VAR55, VAR61, "", "", "");
}
function FUN27(string VAR55) internal returns (uint) {
return FUN27(VAR55, 0);
}
function FUN27(string VAR55, uint VAR61) internal returns (uint) {
bytes memory VAR83 = bytes(VAR55);
uint VAR84 = 0;
bool VAR85 = false;
for (uint VAR60=0; VAR60<VAR83.VAR65; VAR60++){
if ((VAR83[VAR60] >= 48)&&(VAR83[VAR60] <= 57)){
if (VAR85){
if (VAR61 == 0) break;
else VAR61--;
}
VAR84 *= 10;
VAR84 += uint(VAR83[VAR60]) - 48;
} else if (VAR83[VAR60] == 46) VAR85 = true;
}
if (VAR61 > 0) VAR84 *= 10**VAR61;
return VAR84;
}
}
contract FirstContract is VAR18 {
address VAR86;
uint constant VAR87 = 125000;
uint public VAR88  = 0;
uint VAR89 = 25000;
function FUN28() {
FUN18(VAR23 | VAR24);
VAR86 = msg.sender;
}
modifier VAR90 {
if (msg.sender != FUN16()) throw;
VAR33;
}
modifier onlyOwner {
if (VAR86 != msg.sender) throw;
VAR33;
}
function FUN29(uint VAR91) onlyOwner {
VAR89 = VAR91;
}
function FUN30() onlyOwner {
FUN15("", "", VAR87 + VAR89);
}
function FUN31() {
}
function FUN32 (bytes32 VAR92, string VAR93, bytes VAR94) VAR90 {
VAR88 = FUN27(VAR93);
}
function FUN33(address VAR95, uint value) private {
if (this.VAR96 < value) {
throw;
}
if (!(VAR95.call.FUN34(VAR89).value(value)())) {
throw;
}
}
function FUN35(uint VAR97) onlyOwner {
FUN33(VAR86, VAR97);
}
function FUN36() onlyOwner {
FUN37(VAR86);
}
}
1
---------------------------------
91 0x6a72b9813003dbda09b6c03ef9f2521086022585.sol
pragma VAR1 ^0.4.15;
pragma VAR1 ^0.4.14;
library VAR2 {
struct VAR3 {
uint VAR4;
uint VAR5;
}
function FUN1(uint VAR6, uint VAR7, uint VAR8) private pure {
for(; VAR8 >= 32; VAR8 -= 32) {
VAR9 {
FUN2(VAR6, FUN3(VAR7))
}
VAR6 += 32;
VAR7 += 32;
}
uint VAR10 = 256 ** (32 - VAR8) - 1;
VAR9 {
let VAR11 := FUN4(FUN3(VAR7), FUN5(VAR10))
let VAR12 := FUN4(FUN3(VAR6), VAR10)
FUN2(VAR6, or(VAR12, VAR11))
}
}
function FUN6(string VAR13) internal pure returns (VAR3) {
uint VAR14;
VAR9 {
VAR14 := FUN7(VAR13, 0x20)
}
return FUN8(bytes(VAR13).VAR15, VAR14);
}
function FUN9(bytes32 VAR13) internal pure returns (uint) {
uint VAR16;
if (VAR13 == 0)
return 0;
if (VAR13 & 0xffffffffffffffffffffffffffffffff == 0) {
VAR16 += 16;
VAR13 = bytes32(uint(VAR13) / 0x100000000000000000000000000000000);
}
if (VAR13 & 0xffffffffffffffff == 0) {
VAR16 += 8;
VAR13 = bytes32(uint(VAR13) / 0x10000000000000000);
}
if (VAR13 & 0xffffffff == 0) {
VAR16 += 4;
VAR13 = bytes32(uint(VAR13) / 0x100000000);
}
if (VAR13 & 0xffff == 0) {
VAR16 += 2;
VAR13 = bytes32(uint(VAR13) / 0x10000);
}
if (VAR13 & 0xff == 0) {
VAR16 += 1;
}
return 32 - VAR16;
}
function FUN10(bytes32 VAR13) internal pure returns (slice VAR16) {
VAR9 {
let VAR14 := FUN3(0x40)
FUN2(0x40, FUN7(VAR14, 0x20))
FUN2(VAR14, VAR13)
FUN2(FUN7(VAR16, 0x20), VAR14)
}
VAR16.VAR4 = FUN9(VAR13);
}
function FUN11(slice VAR13) internal pure returns (VAR3) {
return FUN8(VAR13.VAR4, VAR13.VAR5);
}
function FUN12(slice VAR13) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
return VAR16;
}
function FUN9(slice VAR13) internal pure returns (uint VAR19) {
uint VAR14 = VAR13.VAR5 - 31;
uint VAR20 = VAR14 + VAR13.VAR4;
for (VAR19 = 0; VAR14 < VAR20; VAR19++) {
uint8 VAR21;
VAR9 { VAR21 := FUN4(FUN3(VAR14), 0xFF) }
if (VAR21 < 0x80) {
VAR14 += 1;
} else if(VAR21 < 0xE0) {
VAR14 += 2;
} else if(VAR21 < 0xF0) {
VAR14 += 3;
} else if(VAR21 < 0xF8) {
VAR14 += 4;
} else if(VAR21 < 0xFC) {
VAR14 += 5;
} else {
VAR14 += 6;
}
}
}
function FUN13(slice VAR13) internal pure returns (bool) {
return VAR13.VAR4 == 0;
}
function FUN14(slice VAR13, slice VAR22) internal pure returns (int) {
uint VAR23 = VAR13.VAR4;
if (VAR22.VAR4 < VAR13.VAR4)
VAR23 = VAR22.VAR4;
uint VAR24 = VAR13.VAR5;
uint VAR25 = VAR22.VAR5;
for (uint VAR26 = 0; VAR26 < VAR23; VAR26 += 32) {
uint VAR27;
uint VAR21;
VAR9 {
VAR27 := FUN3(VAR24)
VAR21 := FUN3(VAR25)
}
if (VAR27 != VAR21) {
uint256 VAR10 = uint256(-1);
if(VAR23 < 32) {
VAR10 = ~(2 ** (8 * (32 - VAR23 + VAR26)) - 1);
}
uint256 VAR28 = (VAR27 & VAR10) - (VAR21 & VAR10);
if (VAR28 != 0)
return int(VAR28);
}
VAR24 += 32;
VAR25 += 32;
}
return int(VAR13.VAR4) - int(VAR22.VAR4);
}
function FUN15(slice VAR13, slice VAR22) internal pure returns (bool) {
return FUN14(VAR13, VAR22) == 0;
}
function FUN16(slice VAR13, slice VAR29) internal pure returns (VAR3) {
VAR29.VAR5 = VAR13.VAR5;
if (VAR13.VAR4 == 0) {
VAR29.VAR4 = 0;
return VAR29;
}
uint VAR19;
uint VAR21;
VAR9 { VAR21 := FUN4(FUN3(FUN17(FUN3(FUN7(VAR13, 32)), 31)), 0xFF) }
if (VAR21 < 0x80) {
VAR19 = 1;
} else if(VAR21 < 0xE0) {
VAR19 = 2;
} else if(VAR21 < 0xF0) {
VAR19 = 3;
} else {
VAR19 = 4;
}
if (VAR19 > VAR13.VAR4) {
VAR29.VAR4 = VAR13.VAR4;
VAR13.VAR5 += VAR13.VAR4;
VAR13.VAR4 = 0;
return VAR29;
}
VAR13.VAR5 += VAR19;
VAR13.VAR4 -= VAR19;
VAR29.VAR4 = VAR19;
return VAR29;
}
function FUN16(slice VAR13) internal pure returns (slice VAR16) {
FUN16(VAR13, VAR16);
}
function FUN18(slice VAR13) internal pure returns (uint VAR16) {
if (VAR13.VAR4 == 0) {
return 0;
}
uint VAR30;
uint VAR15;
uint VAR31 = 2 ** 248;
VAR9 { VAR30:= FUN3(FUN3(FUN7(VAR13, 32))) }
uint VAR21 = VAR30 / VAR31;
if (VAR21 < 0x80) {
VAR16 = VAR21;
VAR15 = 1;
} else if(VAR21 < 0xE0) {
VAR16 = VAR21 & 0x1F;
VAR15 = 2;
} else if(VAR21 < 0xF0) {
VAR16 = VAR21 & 0x0F;
VAR15 = 3;
} else {
VAR16 = VAR21 & 0x07;
VAR15 = 4;
}
if (VAR15 > VAR13.VAR4) {
return 0;
}
for (uint VAR32 = 1; VAR32 < VAR15; VAR32++) {
VAR31 = VAR31 / 256;
VAR21 = (VAR30 / VAR31) & 0xFF;
if (VAR21 & 0xC0 != 0x80) {
return 0;
}
VAR16 = (VAR16 * 64) | (VAR21 & 0x3F);
}
return VAR16;
}
function FUN19(slice VAR13) internal pure returns (bytes32 VAR16) {
VAR9 {
VAR16 := FUN20(FUN3(FUN7(VAR13, 32)), FUN3(VAR13))
}
}
function FUN21(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
if (VAR13.VAR5 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN23(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
bool VAR34 = true;
if (VAR13.VAR5 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN24(VAR24, VAR15), FUN24(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
VAR13.VAR5 += VAR33.VAR4;
}
return VAR13;
}
function FUN25(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
if (VAR24 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN26(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
bool VAR34 = true;
if (VAR24 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
}
return VAR13;
}
event FUN27(bytes32 VAR10);
function FUN28(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14 = VAR24;
uint VAR26;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
uint VAR20 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 >= VAR20)
return VAR24 + VAR36;
VAR14++;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
for (VAR26 = 0; VAR26 <= VAR36 - VAR37; VAR26++) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14;
VAR14 += 1;
}
}
}
return VAR24 + VAR36;
}
function FUN29(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
VAR14 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 <= VAR24)
return VAR24;
VAR14--;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14 + VAR37;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
VAR14 = VAR24 + (VAR36 - VAR37);
while (VAR14 >= VAR24) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14 + VAR37;
VAR14 -= 1;
}
}
}
return VAR24;
}
function FUN30(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 -= VAR14 - VAR13.VAR5;
VAR13.VAR5 = VAR14;
return VAR13;
}
function FUN31(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 = VAR14 - VAR13.VAR5;
return VAR13;
}
function FUN32(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR13.VAR5;
VAR42.VAR4 = VAR14 - VAR13.VAR5;
if (VAR14 == VAR13.VAR5 + VAR13.VAR4) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
VAR13.VAR5 = VAR14 + VAR33.VAR4;
}
return VAR42;
}
function FUN32(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN32(VAR13, VAR33, VAR42);
}
function FUN33(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR14;
VAR42.VAR4 = VAR13.VAR4 - (VAR14 - VAR13.VAR5);
if (VAR14 == VAR13.VAR5) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
}
return VAR42;
}
function FUN33(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN33(VAR13, VAR33, VAR42);
}
function FUN34(slice VAR13, slice VAR33) internal pure returns (uint VAR43) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
while (VAR14 <= VAR13.VAR5 + VAR13.VAR4) {
VAR43++;
VAR14 = FUN28(VAR13.VAR4 - (VAR14 - VAR13.VAR5), VAR14, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
}
}
function FUN35(slice VAR13, slice VAR33) internal pure returns (bool) {
return FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) != VAR13.VAR5;
}
function FUN36(slice VAR13, slice VAR22) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4 + VAR22.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
FUN1(VAR18 + VAR13.VAR4, VAR22.VAR5, VAR22.VAR4);
return VAR16;
}
function FUN37(slice VAR13, VAR3[] VAR44) internal pure returns (string) {
if (VAR44.VAR15 == 0)
return "";
uint VAR15 = VAR13.VAR4 * (VAR44.VAR15 - 1);
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++)
VAR15 += VAR44[VAR32].VAR4;
string memory VAR16 = VAR17 string(VAR15);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
for(VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
FUN1(VAR18, VAR44[VAR32].VAR5, VAR44[VAR32].VAR4);
VAR18 += VAR44[VAR32].VAR4;
if (VAR32 < VAR44.VAR15 - 1) {
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
VAR18 += VAR13.VAR4;
}
}
return VAR16;
}
}
address sender;
address VAR45;
uint256 VAR46;
uint256 VAR47;
address VAR48;
string VAR49;
string VAR50;
string VAR51;
mapping (string => bool) VAR52;
enum VAR53 {VAR54, VAR55, VAR56, VAR57}
Status VAR58;
event FUN38(address VAR59, uint value);
event FUN39(address VAR48, uint value, address VAR60, bytes VAR61);
function FUN40 () {
sender = msg.sender;
VAR58 = VAR53.VAR57;
}
function FUN41(address VAR62, string VAR63, string VAR64, string VAR65, address VAR66, uint256 VAR67, uint256 VAR68) onlySender VAR69 {
VAR58 = VAR53.VAR54;
VAR45 = VAR66;
VAR48 = VAR62;
VAR46 = VAR67;
VAR47 = VAR68;
VAR50 = VAR63;
VAR51 = VAR64;
VAR49 = VAR65;
var VAR70 = VAR64.FUN6().FUN11();
var VAR71 = "".FUN6();
var VAR44 = new uint256[](VAR70.FUN34(VAR71) + 1);
uint256 VAR72;
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
VAR72 = VAR72 + FUN42(VAR70.FUN32(VAR71).FUN12());
}
require(VAR72 == 100000);
}
modifier onlyOwner() {
require(msg.sender == VAR48);
VAR73;
}
modifier FUN43() {
require(msg.sender == sender);
VAR73;
}
modifier FUN44() {
require(VAR58 == VAR53.VAR57);
VAR73;
}
modifier FUN45() {
require(VAR58 == VAR53.VAR55 || VAR58 == VAR53.VAR54);
VAR73;
}
modifier FUN46() {
require(VAR58 == VAR53.VAR56);
VAR73;
}
modifier FUN47() {
var VAR70 = VAR50.FUN6().FUN11();
var VAR71 = "".FUN6();
string[] memory VAR74 = new string[](VAR70.FUN34(VAR71) + 1);
bool VAR75 = false;
string memory VAR76 = FUN48(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR74.VAR15; VAR32++) {
if(FUN20(VAR76) == FUN20(VAR70.FUN32(VAR71).FUN12())){
VAR75 = true;
break;
}
}
require(VAR75);
VAR73;
}
modifier FUN49() {
var VAR70 = VAR49.FUN6().FUN11();
var VAR71 = "".FUN6();
string[] memory VAR77 = new string[](VAR70.FUN34(VAR71) + 1);
bool VAR78 = false;
string memory VAR76 = FUN48(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR77.VAR15; VAR32++) {
if(FUN20(VAR76) == FUN20(VAR70.FUN32(VAR71).FUN12())){
VAR78 = true;
break;
}
}
require(VAR78);
VAR73;
}
function () payable VAR79 {
if (VAR58 == VAR53.VAR54) {
var VAR80 = VAR49.FUN6().FUN11();
var VAR81 = VAR80.FUN34("".FUN6()) + 1;
var VAR82 = FUN50() * VAR81 + FUN51();
require(msg.value > VAR82);
VAR45.transfer(FUN51());
for (uint VAR32 = 0; VAR32 < VAR81; VAR32++) {
var VAR83 = FUN52(VAR80.FUN32("".FUN6()).FUN12());
VAR83.transfer(FUN50());
}
VAR58 = VAR53.VAR55;
FUN38(msg.sender, msg.value);
} else {
FUN38(msg.sender, msg.value);
}
}
function FUN53() onlyWitness VAR79 {
require (this.VAR84 > 0);
VAR52[FUN48(msg.sender)] = true;
var VAR85 = VAR49.FUN6().FUN11();
uint256 VAR86 = VAR85.FUN34("".FUN6()) + 1;
uint8 VAR87 = 0;
for(uint VAR32 = 0; VAR32 < VAR86; VAR32++) {
if(VAR52[VAR85.FUN32("".FUN6()).FUN12()] == true){
VAR87 = VAR87 + 1;
}
}
if(VAR87 == VAR86){
VAR85 = VAR50.FUN6().FUN11();
var  VAR88 = VAR51.FUN6().FUN11();
VAR86 = VAR85.FUN34("".FUN6()) + 1;
for(VAR32 = 0; VAR32 < VAR86 - 1; VAR32++) {
FUN52(VAR85.FUN32("".FUN6()).FUN12()).transfer(((this.VAR84 * FUN42(VAR88.FUN32("".FUN6()).FUN12())) / 100000));
}
FUN52(VAR85.FUN32("".FUN6()).FUN12()).transfer(this.VAR84);
VAR58 = VAR53.VAR56;
}
}
function FUN54(address VAR89, uint VAR90, bytes VAR91) external onlyOwner {
FUN39(msg.sender, VAR90, VAR89, VAR91);
VAR89.call.value(VAR90)(VAR91);
}
function FUN55() returns (bool){
return msg.sender == VAR48;
}
function FUN56() returns (VAR53){
return VAR58;
}
function FUN51() returns (uint256) {
return VAR46 * VAR47;
}
function FUN50() returns (uint256) {
return (1000000 * VAR46);
}
function FUN57() returns (string, string) {
return (VAR50, VAR51);
}
function FUN58() returns (string) {
return VAR49;
}
function FUN59() returns (uint) {
return VAR49.FUN6().FUN11().FUN34("".FUN6()) + 1;
}
function FUN60() constant returns (uint) {
return  address(this).VAR84;
}
function FUN61() returns (bool){
return VAR52[FUN48(msg.sender)];
}
function FUN42(string VAR70) constant private returns (uint VAR92) {
bytes memory VAR21 = bytes(VAR70);
uint VAR32;
VAR92 = 0;
for (VAR32 = 0; VAR32 < VAR21.VAR15; VAR32++) {
uint VAR93 = uint(VAR21[VAR32]);
if (VAR93 >= 48 && VAR93 <= 57) {
VAR92 = VAR92 * 10 + (VAR93 - 48);
}
}
}
function FUN48(address VAR94) private returns (string) {
bytes memory VAR70 = VAR17 bytes(42);
VAR70[0] = "";
VAR70[1] = "";
for (uint VAR32 = 0; VAR32 < 20; VAR32++) {
byte VAR21 = FUN62(uint8(uint(VAR94) / (2**(8*(19 - VAR32)))));
byte VAR95 = FUN62(uint8(VAR21) / 16);
byte VAR96 = FUN62(uint8(VAR21) - 16 * uint8(VAR95));
VAR70[2+2*VAR32] = FUN63(VAR95);
VAR70[2+2*VAR32+1] = FUN63(VAR96);
}
return string(VAR70);
}
function FUN63(byte VAR21) private returns (byte VAR93) {
if (VAR21 < 10) return FUN62(uint8(VAR21) + 0x30);
else return FUN62(uint8(VAR21) + 0x57);
}
function FUN52(string VAR97) internal returns (address){
bytes memory VAR98 = bytes(VAR97);
uint160 VAR99 = 0;
uint160 VAR100;
uint160 VAR101;
for (uint VAR32=2; VAR32<2+2*20; VAR32+=2){
VAR99 *= 256;
VAR100 = FUN64(VAR98[VAR32]);
VAR101 = FUN64(VAR98[VAR32+1]);
if ((VAR100 >= 97)&&(VAR100 <= 102)) VAR100 -= 87;
else if ((VAR100 >= 48)&&(VAR100 <= 57)) VAR100 -= 48;
if ((VAR101 >= 97)&&(VAR101 <= 102)) VAR101 -= 87;
else if ((VAR101 >= 48)&&(VAR101 <= 57)) VAR101 -= 48;
VAR99 += (VAR100*16+VAR101);
}
return address(VAR99);
}
}
function FUN65 () {
VAR45 = msg.sender;
}
function FUN66 (address VAR62, string VAR63, string VAR64, string VAR65, uint256 VAR67, uint256 VAR68) {
address VAR48 = VAR62;
var VAR70 = VAR63.FUN6().FUN11();
if (!VAR70.FUN25("".FUN6())){
VAR63.FUN6().FUN36("".FUN6());
}
VAR70 = VAR65.FUN6().FUN11();
if (!VAR70.FUN25("".FUN6())){
VAR65.FUN6().FUN36("".FUN6());
}
VAR70 = VAR64.FUN6().FUN11();
if (!VAR70.FUN25("".FUN6())){
VAR64.FUN6().FUN36("".FUN6());
}
VAR70 = VAR65.FUN6().FUN11();
var VAR71 = "".FUN6();
uint256 VAR102 = VAR70.FUN34(VAR71) + 1;
address VAR103 = VAR17 FUN40();
MyWill VAR104 = FUN40(VAR103);
VAR104.FUN41(VAR48, VAR63, VAR64, VAR65, VAR45, VAR67, VAR68);
var VAR105 = FUN48(VAR103);
VAR106[VAR48] =  VAR106[VAR48].FUN6().FUN36(VAR105.FUN6()).FUN6().FUN36("".FUN6());
}
function FUN67(address VAR48) returns (string) {
return VAR106[VAR48];
}
function FUN48(address VAR94) returns (string) {
bytes memory VAR70 = VAR17 bytes(42);
VAR70[0] = "";
VAR70[1] = "";
for (uint VAR32 = 0; VAR32 < 20; VAR32++) {
byte VAR21 = FUN62(uint8(uint(VAR94) / (2**(8*(19 - VAR32)))));
byte VAR95 = FUN62(uint8(VAR21) / 16);
byte VAR96 = FUN62(uint8(VAR21) - 16 * uint8(VAR95));
VAR70[2+2*VAR32] = FUN63(VAR95);
VAR70[2+2*VAR32+1] = FUN63(VAR96);
}
return string(VAR70);
}
function FUN63(byte VAR21) returns (byte VAR93) {
if (VAR21 < 10) return FUN62(uint8(VAR21) + 0x30);
else return FUN62(uint8(VAR21) + 0x57);
}
function FUN60() constant returns (uint) {
return  address(this).VAR84;
}
}
1
---------------------------------
92 0x6b1fb08639acec6ed415bacab6453b523aec7d4b.sol
pragma VAR1 ^0.4.18;
interface VAR2 {
function FUN1() public;
function FUN2() payable public returns(bool VAR3);
}
interface VAR4 {
function transfer(address VAR5, uint256 VAR6) public;
}
contract VAR7 {
Crowdsale public VAR8;
Token public VAR9;
address public VAR10;
address[] public VAR11;
mapping(address => bool) public VAR12;
uint public VAR13;
uint constant public VAR14 = 10;
event FUN3(uint VAR15);
event FUN4(address indexed VAR16);
event FUN5(address indexed VAR16);
function FUN6(
address VAR17,
address VAR18,
address[] VAR19,
uint VAR20
) public {
VAR10 = VAR17;
VAR8 = FUN7(VAR17);
VAR9 = FUN8(VAR18);
for (uint VAR21 = 0; VAR21 < VAR19.VAR22; VAR21++) {
require(!VAR12[VAR19[VAR21]] && VAR19[VAR21] != 0);
VAR12[VAR19[VAR21]] = true;
}
VAR11 = VAR19;
VAR13 = VAR20;
}
modifier FUN9(address VAR16) {
require(!VAR12[VAR16]);
VAR23;
}
modifier ownerExists(address VAR16) {
require(VAR12[VAR16]);
VAR23;
}
modifier FUN10(address VAR24) {
require(VAR24 != 0);
VAR23;
}
modifier FUN11() {
require((msg.value - VAR13) > 0);
VAR23;
}
function()
payable
public
VAR25
{
if(VAR8.VAR26.value(msg.value - VAR13)()){
FUN3(msg.value - VAR13);
}
}
function FUN12()
public
constant
returns (address[])
{
return VAR11;
}
function transfer(address VAR5, uint256 VAR6)
ownerExists(msg.sender)
public {
VAR9.transfer(VAR5, VAR6);
}
function FUN13()
ownerExists(msg.sender)
public {
VAR8.FUN1();
}
function FUN14(address VAR5, uint256 VAR6)
ownerExists(msg.sender)
public {
VAR5.transfer(VAR6);
}
function FUN15(address[] VAR5, uint256[] VAR6)
ownerExists(msg.sender)
public {
require(VAR5.VAR22 == VAR6.VAR22);
for (uint VAR21 = 0; VAR21 < VAR5.VAR22; VAR21++) {
VAR5[VAR21].transfer(VAR6[VAR21]);
}
}
function FUN16(uint VAR20)
ownerExists(msg.sender)
public {
VAR13 = VAR20;
}
function FUN17()
ownerExists(msg.sender)
public {
msg.sender.transfer(this.VAR27);
}
}
1
---------------------------------
93 0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4.sol
pragma VAR1 ^0.4.15;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) returns (bool VAR5);
function FUN1(address VAR6) constant returns (uint256 VAR7);
}
contract VAR8 {
mapping (address => uint256) public VAR9;
bool public VAR10;
uint256 public VAR11;
uint256 public VAR12;
bool public VAR13;
address public VAR14;
string VAR15;
address public VAR16;
ERC20 public VAR17;
bytes32 VAR18;
uint256 VAR19;
uint256 VAR20;
function FUN2(
string VAR21,
address VAR22,
address VAR23,
bytes32 VAR24,
uint256 VAR25,
uint256 VAR26
) payable {
VAR14 = msg.sender;
VAR15 = VAR21;
VAR16 = VAR22;
VAR17 = FUN3(VAR23);
VAR18 = VAR24;
VAR19 = VAR25;
VAR20 = VAR26;
}
function FUN4(address VAR27) internal {
if (!VAR10) {
uint256 VAR28 = VAR9[VAR27];
VAR9[VAR27] = 0;
VAR27.transfer(VAR28);
} else {
uint256 VAR29 = VAR17.FUN1(address(this));
require(VAR29 > 0);
uint256 VAR30 = (VAR9[VAR27] * VAR29) / VAR12;
VAR12 -= VAR9[VAR27];
VAR9[VAR27] = 0;
require(VAR17.transfer(VAR27, VAR30));
}
}
function FUN5(address VAR27){
require (VAR10 && VAR31 > VAR11 + 1 VAR32);
FUN4(VAR27);
}
function FUN6(){
require(VAR10);
require(VAR33.VAR34 < VAR19);
require(VAR31 < VAR20);
require(!VAR13);
VAR10 = true;
VAR11 = VAR31;
VAR12 = this.VAR7;
require(VAR16.call.value(VAR12)());
}
function FUN7(string VAR35) {
require(FUN8(VAR35) == VAR18);
VAR13 = true;
}
function FUN9() payable {
if (msg.value <= 1 VAR36) {
FUN4(msg.sender);
} else {
require (!VAR13);
require (!VAR10);
VAR9[msg.sender] += msg.value;
}
}
function () payable {
require(msg.sender != address(VAR16));
FUN9();
}
}
contract VAR37 {
function FUN10 (
string VAR21,
address VAR22,
address VAR23,
bytes32 VAR24,
uint256 VAR25,
uint256 VAR26
) returns (Equio VAR38) {
return VAR39 FUN2(
VAR21,
VAR22,
VAR23,
VAR24,
VAR25,
VAR26
);
}
}
1
---------------------------------
94 0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
function transfer(address VAR3, uint VAR4) returns (bool VAR5);
}
contract VAR6 {
function FUN1() payable returns (uint256 VAR7);
}
contract VAR8 {
mapping (address => uint) public VAR9;
uint public VAR10;
bool public VAR11;
uint public VAR12;
address VAR13 = 0xBbc79794599b19274850492394004087cBf89710;
address VAR14 = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C;
address VAR15 = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e;
function FUN2(){
uint VAR7 = VAR9[msg.sender];
VAR9[msg.sender] = 0;
msg.sender.transfer(VAR7);
}
function FUN3() payable {
VAR10 += msg.value;
}
function FUN4(){
VAR11 = true;
VAR12 = VAR16;
FUN5(VAR13).VAR17.value(this.VAR18 - VAR10)();
msg.sender.transfer(VAR10);
}
function FUN6() payable {
if (!VAR11) {
VAR9[msg.sender] += msg.value;
}
else {
uint VAR7 = VAR9[msg.sender] * 100;
VAR9[msg.sender] = 0;
uint VAR19 = 0;
if (VAR16 > VAR12 + 1 VAR20) {
VAR19 = VAR7 / 100;
}
FUN7(VAR14).transfer(msg.sender, VAR7 - VAR19);
FUN7(VAR14).transfer(VAR15, VAR19);
msg.sender.transfer(msg.value);
}
}
function () payable {
FUN6();
}
}
1
---------------------------------
95 0x6bf4ac662f183f3ba1960bd6d6691b7613589d23.sol
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function transfer(address VAR3, uint256 value) public returns (bool);
event Transfer(address indexed VAR4, address indexed VAR3, uint256 value);
function FUN3(address VAR5, address VAR6) public view returns (uint256);
function FUN4(address VAR4, address VAR3, uint256 value) public returns (bool);
function FUN5(address VAR6, uint256 value) public returns (bool);
event FUN6(
address indexed VAR5,
address indexed VAR6,
uint256 value
);
}
library VAR7 {
function FUN7(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
if (VAR8 == 0) {
return 0;
}
VAR10 = VAR8 * VAR9;
assert(VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN8(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
return VAR8 / VAR9;
}
function FUN9(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
assert(VAR9 <= VAR8);
return VAR8 - VAR9;
}
function FUN10(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
VAR10 = VAR8 + VAR9;
assert(VAR10 >= VAR8);
return VAR10;
}
}
contract PostboyToken is VAR1 {
using SafeMath for uint256;
struct VAR11 {
uint256 VAR12;
uint256 VAR13;
}
string public constant VAR14 = "";
string public constant VAR15 = "";
uint8 public constant VAR16 = 0;
uint256 public constant VAR17 = 100000;
uint256 public VAR18;
uint256 VAR19;
mapping (address => VAR11) VAR20;
mapping (address => mapping (address => uint256)) internal VAR21;
address public VAR22;
address public VAR23;
constructor() public {
VAR19 = VAR17;
VAR18 = 0;
VAR20[msg.sender].VAR12 = VAR17;
VAR22 = msg.sender;
VAR23 = address(0);
emit Transfer(address(0), msg.sender, VAR17);
}
function FUN1() public view returns (uint256) {
return VAR19;
}
function transfer(address VAR24, uint256 VAR25) public returns (bool) {
FUN11(msg.sender, VAR24, VAR25);
return true;
}
function FUN4(
address VAR26,
address VAR24,
uint256 VAR25
)
public
returns (bool)
{
require(VAR25 <= VAR21[VAR26][msg.sender]);
VAR21[VAR26][msg.sender] = VAR21[VAR26][msg.sender].FUN9(VAR25);
FUN11(VAR26, VAR24, VAR25);
return true;
}
function FUN2(address VAR27) public view returns (uint256) {
return VAR20[VAR27].VAR12;
}
function FUN5(address VAR28, uint256 VAR25) public returns (bool) {
VAR21[msg.sender][VAR28] = VAR25;
emit FUN6(msg.sender, VAR28, VAR25);
return true;
}
function FUN3(
address VAR27,
address VAR28
)
public
view
returns (uint256)
{
return VAR21[VAR27][VAR28];
}
function FUN12(
address VAR28,
uint256 VAR29
)
public
returns (bool)
{
VAR21[msg.sender][VAR28] = (
VAR21[msg.sender][VAR28].FUN10(VAR29));
emit FUN6(msg.sender, VAR28, VAR21[msg.sender][VAR28]);
return true;
}
function FUN13(
address VAR28,
uint256 VAR30
)
public
returns (bool)
{
uint256 VAR31 = VAR21[msg.sender][VAR28];
if (VAR30 > VAR31) {
VAR21[msg.sender][VAR28] = 0;
} else {
VAR21[msg.sender][VAR28] = VAR31.FUN9(VAR30);
}
emit FUN6(msg.sender, VAR28, VAR21[msg.sender][VAR28]);
return true;
}
function FUN14(address VAR32) public view returns (uint256) {
uint256 VAR33 = VAR18.FUN9(VAR20[VAR32].VAR13);
uint256 VAR34 = VAR20[VAR32].VAR12.FUN7(VAR33);
return VAR34.FUN8(VAR19);
}
function FUN15() public {
uint256 VAR35 = FUN14(msg.sender);
if (VAR35 > 0) {
VAR20[msg.sender].VAR13 = VAR18;
msg.sender.transfer(VAR35);
}
}
function FUN11(address VAR26, address VAR24, uint256 VAR25) internal {
require(VAR24 != address(0));
require(VAR25 <= VAR20[VAR26].VAR12);
require(VAR20[VAR24].VAR12 + VAR25 >= VAR20[VAR24].VAR12);
uint256 VAR36 = FUN14(VAR26);
uint256 VAR37 = FUN14(VAR24);
require(VAR36 <= 0 && VAR37 <= 0);
VAR20[VAR26].VAR12 = VAR20[VAR26].VAR12.FUN9(VAR25);
VAR20[VAR24].VAR12 = VAR20[VAR24].VAR12.FUN10(VAR25);
VAR20[VAR24].VAR13 = VAR20[VAR26].VAR13;
emit Transfer(VAR26, VAR24, VAR25);
}
function FUN16(address VAR38) public returns (bool) {
require(msg.sender == VAR22);
VAR23 = VAR38;
}
function FUN17() public payable {
require(msg.sender == VAR23);
VAR18 = VAR18.FUN10(msg.value);
}
function () external payable {
require(false);
}
}
contract VAR39 {
address public VAR40;
address public VAR41;
address public VAR42;
PostboyToken public VAR43;
modifier FUN18() {
require(msg.sender == VAR40 || msg.sender == VAR41 || msg.sender == VAR42);
VAR44;
}
constructor(address VAR45, address VAR46, address VAR47, PostboyToken VAR48) public {
VAR40 = VAR45;
VAR41 = VAR46;
VAR42 = VAR47;
VAR43 = VAR48;
}
function FUN19() isAdmin public {
VAR43.VAR49.value(address(this).VAR12)();
}
function () external payable {
}
}
1
---------------------------------
96 0x6c1bcb34142bffd35f57db626e0ac427af616a4d.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) returns (bool VAR5);
function FUN1(address VAR6) constant returns (uint256 VAR7);
}
contract VAR8 {
mapping (address => uint256) public VAR9;
mapping (address => uint256) public VAR10;
bool public VAR11;
bool public VAR12;
bool public VAR13;
uint256 public VAR14;
bool public VAR15;
bytes32 VAR16 = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d;
address public VAR17 = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882;
address public VAR18 = 0xc4740f71323129669424d1Ae06c42AEE99da30e2;
ERC20 public VAR19;
uint256 public VAR20 = 3235 VAR21;
function FUN2(address VAR22) {
require(msg.sender == VAR17);
VAR19 = FUN3(VAR22);
VAR12 = true;
}
function FUN4(bool VAR23) {
require(msg.sender == VAR17);
VAR13 = VAR23;
}
function FUN5(string VAR24) {
require(msg.sender == VAR17 || FUN6(VAR24) == VAR16);
VAR15 = true;
}
function FUN7(){
if (VAR10[msg.sender]>0 && msg.sender != VAR18) {
uint256 VAR25 = VAR10[msg.sender];
VAR10[msg.sender] = 0;
msg.sender.transfer(VAR25);
}
if (VAR9[msg.sender] == 0) return;
require(msg.sender != VAR18);
if (!VAR11 || VAR13) {
uint256 VAR26 = VAR9[msg.sender];
VAR9[msg.sender] = 0;
msg.sender.transfer(VAR26);
}
else {
require(VAR12);
uint256 VAR27 = VAR19.FUN1(address(this));
require(VAR27 != 0);
uint256 VAR28 = (VAR9[msg.sender] * VAR27) / VAR14;
VAR14 -= VAR9[msg.sender];
VAR9[msg.sender] = 0;
uint256 VAR29 = VAR28 / 100;
require(VAR19.transfer(VAR17, VAR29));
require(VAR19.transfer(msg.sender, VAR28 - VAR29));
}
}
function FUN8(address VAR30){
require(VAR11 || VAR15);
require(VAR30 != VAR18);
if (VAR10[VAR30]>0 && VAR30 != VAR18) {
uint256 VAR25 = VAR10[VAR30];
VAR10[VAR30] = 0;
VAR30.transfer(VAR25);
}
if (VAR9[VAR30] == 0) return;
if (!VAR11 || VAR13) {
uint256 VAR26 = VAR9[VAR30];
VAR9[VAR30] = 0;
VAR30.transfer(VAR26);
}
else {
require(VAR12);
uint256 VAR27 = VAR19.FUN1(address(this));
require(VAR27 != 0);
uint256 VAR28 = (VAR9[VAR30] * VAR27) / VAR14;
VAR14 -= VAR9[VAR30];
VAR9[VAR30] = 0;
uint256 VAR29 = VAR28 / 100;
require(VAR19.transfer(VAR17, VAR29));
require(VAR19.transfer(VAR30, VAR28 - VAR29));
}
}
function FUN9() {
require(msg.sender == VAR17);
if (this.VAR7 < VAR20) return;
if (VAR15) return;
require(VAR18 != 0x0);
VAR11 = true;
VAR14 = this.VAR7;
require(VAR18.call.value(VAR14)());
require(this.VAR7==0);
}
function () payable {
if (!VAR11) {
VAR9[msg.sender] += msg.value;
} else {
VAR10[msg.sender] += msg.value;
if (msg.sender == VAR18 && this.VAR7 >= VAR14) {
VAR13 = true;
}
}
}
}
1
---------------------------------
97 0x6d997edca04282950416fa380d834f360fc36ebb.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
bool public VAR42;
bool public VAR43;
bool public VAR44;
address public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => uint256) public VAR47;
mapping (address => bool) public VAR48;
uint public VAR49;
enum VAR50{VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57, VAR58}
event FUN26(address VAR59, uint VAR60, uint VAR21, uint128 VAR61);
event FUN27(address VAR59, uint VAR60);
event FUN28(bool VAR43, bool VAR44, address VAR45);
event FUN29(address VAR62, bool VAR63);
event FUN30(uint VAR38);
function FUN31(address VAR64, PricingStrategy VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR69) {
VAR9 = msg.sender;
VAR32 = FUN32(VAR64);
FUN33(VAR65);
VAR35 = VAR66;
if(VAR35 == 0) {
throw;
}
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR68 == 0) {
throw;
}
VAR38 = VAR68;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR69;
}
function() payable {
throw;
}
function FUN34(address VAR70, uint128 VAR61) stopInEmergency private {
if(FUN35() == VAR50.VAR53) {
if(!VAR48[VAR70]) {
throw;
}
} else if(FUN35() == VAR50.VAR54) {
} else {
throw;
}
uint VAR60 = msg.value;
uint VAR21 = VAR33.FUN18(VAR60, VAR17, VAR18, msg.sender, VAR32.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR46[VAR70] == 0) {
VAR39++;
}
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR60, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR70, VAR21);
if(!VAR35.FUN39(VAR60)) throw;
FUN26(VAR70, VAR60, VAR21, VAR61);
}
function FUN40(address VAR70, uint VAR71, uint VAR72) public onlyOwner {
uint VAR21 = VAR71 * 10**VAR32.FUN36();
uint VAR60 = VAR72 * VAR71;
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
FUN38(VAR70, VAR21);
FUN26(VAR70, VAR60, VAR21, 0);
}
function FUN41(address VAR62, uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
bytes32 VAR76 = FUN42(VAR62);
if (FUN43(VAR76, VAR73, VAR74, VAR75) != VAR45) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN44(address VAR62, uint128 VAR61) public payable {
if(VAR44) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN45(address VAR62) public payable {
if(VAR43) throw;
if(VAR44) throw;
FUN34(VAR62, 0);
}
function FUN46(uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
FUN41(msg.sender, VAR61, VAR73, VAR74, VAR75);
}
function FUN47(uint128 VAR61) public payable {
FUN44(msg.sender, VAR61);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR50.VAR55) onlyOwner VAR13 {
if(VAR42) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN20();
}
VAR42 = true;
}
function FUN51(FinalizeAgent VAR62) onlyOwner {
VAR34 = VAR62;
if(!VAR34.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR43 = value;
FUN28(VAR43, VAR44, VAR45);
}
function FUN53(bool value, address VAR77) onlyOwner {
VAR44 = value;
VAR45 = VAR77;
FUN28(VAR43, VAR44, VAR45);
}
function FUN54(address VAR62, bool VAR63) onlyOwner {
VAR48[VAR62] = VAR63;
FUN29(VAR62, VAR63);
}
function FUN55(uint VAR78) onlyOwner {
if(VAR79 > VAR78) {
throw;
}
VAR38 = VAR78;
FUN30(VAR38);
}
function FUN33(PricingStrategy VAR65) onlyOwner {
VAR33 = VAR65;
if(!VAR33.FUN16()) {
throw;
}
}
function FUN56(address VAR62) public onlyOwner {
if(VAR39 > VAR31) {
throw;
}
VAR35 = VAR62;
}
function FUN57() public payable FUN50(VAR50.VAR56) {
if(msg.value == 0) throw;
VAR40 = VAR40.FUN11(msg.value);
}
function FUN58() public FUN50(VAR50.VAR58) {
uint256 VAR80 = VAR46[msg.sender];
if (VAR80 == 0) throw;
VAR46[msg.sender] = 0;
VAR41 = VAR41.FUN11(VAR80);
FUN27(msg.sender, VAR80);
if (!msg.sender.FUN39(VAR80)) throw;
}
function FUN59() public constant returns (bool VAR81) {
return VAR17 >= VAR36;
}
function FUN60() public constant returns (bool VAR82) {
return VAR34.FUN17();
}
function FUN61() public constant returns (bool VAR82) {
return VAR33.FUN17(address(this));
}
function FUN35() public constant returns (VAR50) {
if(VAR42) return VAR50.VAR57;
else if (address(VAR34) == 0) return VAR50.VAR52;
else if (!VAR34.FUN17()) return VAR50.VAR52;
else if (!VAR33.FUN17(address(this))) return VAR50.VAR52;
else if (VAR83.VAR84 < VAR37) return VAR50.VAR53;
else if (VAR83.VAR84 <= VAR38 && !FUN62()) return VAR50.VAR54;
else if (FUN59()) return VAR50.VAR55;
else if (!FUN59() && VAR17 > 0 && VAR40 >= VAR17) return VAR50.VAR58;
else return VAR50.VAR56;
}
function FUN63(uint VAR85) onlyOwner {
VAR49 = VAR85;
}
function FUN64() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR86) {
if(FUN35() != VAR86) throw;
VAR10;
}
//
//
function FUN37(uint VAR60, uint VAR21, uint VAR87, uint VAR88) constant returns (bool VAR89);
function FUN62() public constant returns (bool);
function FUN38(address VAR70, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN65(address VAR70, uint VAR90);
mapping(address => uint) VAR91;
mapping (address => mapping (address => uint)) VAR92;
function FUN66() public constant returns (bool VAR93) {
return true;
}
modifier FUN67(uint VAR94) {
if(msg.VAR95.VAR96 < VAR94 + 4) {
throw;
}
VAR10;
}
function transfer(address VAR97, uint VAR98) FUN67(2 * 32) returns (bool VAR99) {
VAR91[msg.sender] = FUN3(VAR91[msg.sender], VAR98);
VAR91[VAR97] = FUN4(VAR91[VAR97], VAR98);
Transfer(msg.sender, VAR97, VAR98);
return true;
}
function FUN23(address VAR100, address VAR97, uint VAR98) returns (bool VAR99) {
uint VAR101 = VAR92[VAR100][msg.sender];
VAR91[VAR97] = FUN4(VAR91[VAR97], VAR98);
VAR91[VAR100] = FUN3(VAR91[VAR100], VAR98);
VAR92[VAR100][msg.sender] = FUN3(VAR101, VAR98);
Transfer(VAR100, VAR97, VAR98);
return true;
}
function FUN21(address VAR102) constant returns (uint VAR103) {
return VAR91[VAR102];
}
function FUN24(address VAR104, uint VAR98) returns (bool VAR99) {
if ((VAR98 != 0) && (VAR92[msg.sender][VAR104] != 0)) throw;
VAR92[msg.sender][VAR104] = VAR98;
FUN25(msg.sender, VAR104, VAR98);
return true;
}
function FUN22(address VAR102, address VAR104) constant returns (uint VAR105) {
return VAR92[VAR102][VAR104];
}
function FUN68(address VAR104, uint VAR106)
returns (bool VAR99) {
uint VAR107 = VAR92[msg.sender][VAR104];
VAR92[msg.sender][VAR104] = FUN4(VAR107, VAR106);
FUN25(msg.sender, VAR104, VAR92[msg.sender][VAR104]);
return true;
}
function FUN69(address VAR104, uint VAR108)
returns (bool VAR99) {
uint VAR109 = VAR92[msg.sender][VAR104];
if (VAR108 > VAR109) {
VAR92[msg.sender][VAR104] = 0;
} else {
VAR92[msg.sender][VAR104] = FUN3(VAR109, VAR108);
}
FUN25(msg.sender, VAR104, VAR92[msg.sender][VAR104]);
return true;
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR39;
uint public VAR87;
address[] public VAR110;
mapping(address => uint) public VAR91;
mapping(address => uint) public VAR111;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
uint public VAR116;
uint public VAR117;
Crowdsale public VAR16;
enum VAR50{VAR51, VAR54, VAR118, VAR58}
event FUN26(address VAR59, uint value);
event FUN70(address VAR59, uint value);
event FUN71(uint VAR119);
event FUN72(address VAR110, uint VAR119);
function FUN73(address VAR102, uint VAR120, uint VAR121, uint VAR122) {
VAR9 = VAR102;
if(VAR120 == 0) {
throw;
}
if(VAR121 == 0) {
throw;
}
VAR113 = VAR121;
VAR114 = VAR122;
VAR112 = VAR120;
}
function FUN74() public constant returns(VAR123) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN75();
}
function FUN45() public stopInEmergency payable {
if(FUN35() != VAR50.VAR54) throw;
if(msg.value == 0) throw;
address VAR59 = msg.sender;
bool VAR124 = VAR91[VAR59] > 0;
VAR91[VAR59] = FUN4(VAR91[VAR59], msg.value);
if(VAR91[VAR59] < VAR113) {
throw;
}
if(!VAR124) {
VAR110.FUN76(VAR59);
VAR39++;
}
VAR87 = FUN4(VAR87, msg.value);
if(VAR87 > VAR114) {
throw;
}
FUN26(VAR59, msg.value);
}
function FUN77() stopInEmergency public {
if(FUN35() != VAR50.VAR54) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR125.value(VAR87)(address(this));
VAR115 = FUN74().FUN21(address(this));
if(VAR115 == 0) {
throw;
}
FUN71(VAR115);
}
function FUN78(address VAR59) public constant returns (uint) {
if(FUN35() != VAR50.VAR118) {
throw;
}
return FUN1(VAR91[VAR59], VAR115) / VAR87;
}
function FUN79(address VAR59) public constant returns (uint) {
return FUN3(FUN78(VAR59), VAR111[VAR59]);
}
function FUN80() {
FUN81(FUN79(msg.sender));
}
function FUN81(uint VAR90) VAR13 {
address VAR59 = msg.sender;
if(VAR90 == 0) {
throw;
}
if(FUN79(VAR59) < VAR90) {
throw;
}
if(VAR111[VAR59] == 0) {
VAR116++;
}
VAR111[VAR59] = FUN4(VAR111[VAR59], VAR90);
VAR117 = FUN4(VAR117, VAR90);
FUN74().transfer(VAR59, VAR90);
FUN72(VAR59, VAR90);
}
function FUN58() VAR13 {
if(FUN35() != VAR50.VAR58) throw;
address VAR59 = msg.sender;
if(VAR91[VAR59] == 0) throw;
uint VAR90 = VAR91[VAR59];
delete VAR91[VAR59];
if(!VAR59.FUN39(VAR90)) throw;
FUN70(VAR59, VAR90);
}
function FUN82(Crowdsale VAR126) public onlyOwner {
VAR16 = VAR126;
if(!VAR16.FUN64()) true;
}
function FUN35() public returns(VAR50) {
if(VAR115 == 0) {
if(VAR79 >= VAR112) {
return VAR50.VAR58;
} else {
return VAR50.VAR54;
}
} else {
return VAR50.VAR118;
}
}
function() payable {
throw;
}
}
1
---------------------------------
98 0x6e0ae69d262420b8ccd7ecdc11f12bb8b38104fc.sol
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
library VAR5 {
function FUN5(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN6(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN7(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
}
contract VAR6 {
function FUN8() public constant returns (bool) {
return true;
}
function FUN9(address VAR7) public constant returns (bool) {
return true;
}
function FUN10(address VAR8) public constant returns (bool) {
return false;
}
function FUN11(uint value, uint VAR9, uint VAR10, address VAR11, uint VAR12) public constant returns (uint VAR13);
}
contract VAR14 {
function FUN12() public constant returns(bool) {
return true;
}
function FUN9() public constant returns (bool);
function FUN13();
}
contract VAR15 {
uint256 public VAR16;
function FUN14(address VAR17) constant returns (uint256);
function transfer(address VAR18, uint256 value) returns (bool);
event Transfer(address indexed VAR19, address indexed VAR18, uint256 value);
}
contract ERC20 is VAR15 {
function FUN15(address VAR20, address VAR21) constant returns (uint256);
function FUN16(address VAR19, address VAR18, uint256 value) returns (bool);
function FUN17(address VAR21, uint256 value) returns (bool);
event FUN18(address indexed VAR20, address indexed VAR21, uint256 value);
}
contract FractionalERC20 is VAR22 {
uint public VAR12;
}
contract VAR23 {
address public VAR20;
function FUN19() {
VAR20 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR20);
VAR24;
}
function FUN20(address VAR25) onlyOwner {
require(VAR25 != address(0));
VAR20 = VAR25;
}
}
contract Haltable is VAR23 {
bool public VAR26;
modifier VAR27 {
if (VAR26) throw;
VAR24;
}
modifier VAR28 {
if (VAR26 && msg.sender != VAR20) throw;
VAR24;
}
modifier VAR29 {
if (!VAR26) throw;
VAR24;
}
function FUN21() external onlyOwner {
VAR26 = true;
}
function FUN22() external onlyOwner VAR29 {
VAR26 = false;
}
}
contract CrowdsaleBase is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR10 = 0;
uint public VAR9 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
uint public VAR42 = 0;
bool public VAR43;
mapping (address => uint256) public VAR44;
mapping (address => uint256) public VAR45;
mapping (address => bool) public VAR46;
uint public VAR47;
enum VAR48{VAR49, VAR50, VAR51, VAR52, VAR53, VAR54, VAR55, VAR56}
event FUN23(address VAR57, uint VAR58, uint VAR13, uint128 VAR59);
event FUN24(address VAR57, uint VAR58);
event FUN25(bool VAR60, bool VAR61, address VAR62);
event FUN26(address VAR63, bool VAR64);
event FUN27(uint VAR65);
State public VAR66;
function FUN28(address VAR67, PricingStrategy VAR68, address VAR69, uint VAR70, uint VAR71, uint VAR72) {
VAR20 = msg.sender;
VAR32 = FUN29(VAR67);
FUN30(VAR68);
VAR35 = VAR69;
if(VAR35 == 0) {
throw;
}
if(VAR70 == 0) {
throw;
}
VAR37 = VAR70;
if(VAR71 == 0) {
throw;
}
VAR38 = VAR71;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR72;
}
function() payable {
throw;
}
function FUN31(address VAR73, uint128 VAR59) stopInEmergency internal returns(uint VAR74) {
if(FUN32() == VAR48.VAR51) {
if(!VAR46[VAR73]) {
throw;
}
} else if(FUN32() == VAR48.VAR52) {
} else {
throw;
}
uint VAR58 = msg.value;
uint VAR13 = VAR33.FUN11(VAR58, VAR9 - VAR39, VAR10, msg.sender, VAR32.FUN33());
require(VAR13 != 0);
if(VAR44[VAR73] == 0) {
VAR40++;
}
VAR44[VAR73] = VAR44[VAR73].FUN7(VAR58);
VAR45[VAR73] = VAR45[VAR73].FUN7(VAR13);
VAR9 = VAR9.FUN7(VAR58);
VAR10 = VAR10.FUN7(VAR13);
if(VAR33.FUN10(VAR73)) {
VAR39 = VAR39.FUN7(VAR58);
}
require(!FUN34(VAR58, VAR13, VAR9, VAR10));
FUN35(VAR73, VAR13);
if(!VAR35.FUN36(VAR58)) throw;
FUN23(VAR73, VAR58, VAR13, VAR59);
return VAR13;
}
function FUN37() public FUN38(VAR48.VAR53) onlyOwner VAR27 {
if(VAR43) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN13();
}
VAR43 = true;
}
function FUN39(FinalizeAgent VAR63) onlyOwner {
VAR34 = VAR63;
if(!VAR34.FUN12()) {
throw;
}
}
function FUN40(uint VAR75) onlyOwner {
if(VAR76 > VAR75) {
throw;
}
if(VAR37 > VAR75) {
throw;
}
VAR38 = VAR75;
FUN27(VAR38);
}
function FUN30(PricingStrategy VAR68) onlyOwner {
VAR33 = VAR68;
if(!VAR33.FUN8()) {
throw;
}
}
function FUN41(address VAR63) public onlyOwner {
if(VAR40 > VAR31) {
throw;
}
VAR35 = VAR63;
}
function FUN42() public payable FUN38(VAR48.VAR54) {
if(msg.value == 0) throw;
VAR41 = VAR41.FUN7(msg.value);
}
function FUN43() public FUN38(VAR48.VAR56) {
uint256 VAR77 = VAR44[msg.sender];
if (VAR77 == 0) throw;
VAR44[msg.sender] = 0;
VAR42 = VAR42.FUN7(VAR77);
FUN24(msg.sender, VAR77);
if (!msg.sender.FUN36(VAR77)) throw;
}
function FUN44() public constant returns (bool VAR78) {
return VAR9 >= VAR36;
}
function FUN45() public constant returns (bool VAR79) {
return VAR34.FUN9();
}
function FUN46() public constant returns (bool VAR79) {
return VAR33.FUN9(address(this));
}
function FUN32() public constant returns (VAR48) {
if(VAR43) return VAR48.VAR55;
else if (address(VAR34) == 0) return VAR48.VAR50;
else if (!VAR34.FUN9()) return VAR48.VAR50;
else if (!VAR33.FUN9(address(this))) return VAR48.VAR50;
else if (VAR80.VAR81 < VAR37) return VAR48.VAR51;
else if (VAR80.VAR81 <= VAR38 && !FUN47()) return VAR48.VAR52;
else if (FUN44()) return VAR48.VAR53;
else if (!FUN44() && VAR9 > 0 && VAR41 >= VAR9) return VAR48.VAR56;
else return VAR48.VAR54;
}
function FUN48(uint VAR82) onlyOwner {
VAR47 = VAR82;
}
function FUN49(address VAR63, bool VAR64) onlyOwner {
VAR46[VAR63] = VAR64;
FUN26(VAR63, VAR64);
}
function FUN50() public constant returns (bool) {
return true;
}
//
//
modifier FUN38(State VAR83) {
if(FUN32() != VAR83) throw;
VAR24;
}
//
//
function FUN34(uint VAR58, uint VAR13, uint VAR84, uint VAR85) constant returns (bool VAR86);
function FUN47() public constant returns (bool);
function FUN35(address VAR73, uint VAR13) internal;
}
contract Crowdsale is VAR87 {
bool public VAR88;
bool public VAR89;
address public VAR90;
function FUN51(address VAR67, PricingStrategy VAR68, address VAR69, uint VAR70, uint VAR71, uint VAR72) FUN28(VAR67, VAR68, VAR69, VAR70, VAR71, VAR72) {
}
function FUN52(address VAR73, uint VAR91, uint VAR92) public onlyOwner {
uint VAR13 = VAR91 * 10**VAR32.FUN33();
uint VAR58 = VAR92 * VAR91;
VAR9 = VAR9.FUN7(VAR58);
VAR10 = VAR10.FUN7(VAR13);
VAR44[VAR73] = VAR44[VAR73].FUN7(VAR58);
VAR45[VAR73] = VAR45[VAR73].FUN7(VAR13);
FUN35(VAR73, VAR13);
FUN23(VAR73, VAR58, VAR13, 0);
}
function FUN53(address VAR63, uint128 VAR59, uint8 VAR93, bytes32 VAR94, bytes32 VAR95) public payable {
bytes32 VAR96 = FUN54(VAR63);
if (FUN55(VAR96, VAR93, VAR94, VAR95) != VAR90) throw;
if(VAR59 == 0) throw;
FUN31(VAR63, VAR59);
}
function FUN56(address VAR63, uint128 VAR59) public payable {
if(VAR89) throw;
if(VAR59 == 0) throw;
FUN31(VAR63, VAR59);
}
function FUN57(address VAR63) public payable {
if(VAR88) throw;
if(VAR89) throw;
FUN31(VAR63, 0);
}
function FUN58(uint128 VAR59, uint8 VAR93, bytes32 VAR94, bytes32 VAR95) public payable {
FUN53(msg.sender, VAR59, VAR93, VAR94, VAR95);
}
function FUN59(uint128 VAR59) public payable {
FUN56(msg.sender, VAR59);
}
function FUN60() public payable {
FUN57(msg.sender);
}
function FUN61(bool value) onlyOwner {
VAR88 = value;
FUN25(VAR88, VAR89, VAR90);
}
function FUN62(bool value, address VAR97) onlyOwner {
VAR89 = value;
VAR90 = VAR97;
FUN25(VAR88, VAR89, VAR90);
}
}
contract PreICOProxyBuyer is VAR23, VAR30 {
using SafeMath for uint;
uint public VAR40;
uint public VAR9;
address[] public VAR98;
mapping(address => uint) public VAR99;
mapping(address => uint) public VAR100;
uint public VAR101;
uint public VAR102;
uint public VAR103;
uint public VAR104;
uint public VAR74;
uint public VAR105;
uint public VAR106;
uint public VAR107;
bool public VAR108;
Crowdsale public VAR7;
enum VAR48{VAR49, VAR52, VAR109, VAR56}
event FUN23(address VAR57, uint VAR58, uint VAR13, uint128 VAR59);
event FUN63(address VAR57, uint value);
event FUN64(uint VAR110);
event FUN65(address VAR57, uint VAR110);
function FUN66(address VAR111, uint VAR112, uint VAR113, uint VAR114, uint VAR115) {
VAR20 = VAR111;
if(VAR112 == 0) {
throw;
}
if(VAR113 == 0) {
throw;
}
if(VAR114 == 0) {
throw;
}
VAR102 = VAR113;
VAR103 = VAR114;
VAR104 = VAR115;
VAR101 = VAR112;
}
function FUN67() public constant returns(VAR116) {
if(address(VAR7) == 0)  {
throw;
}
return VAR7.FUN68();
}
function FUN57(uint128 VAR59) private {
if(FUN32() != VAR48.VAR52) throw;
if(msg.value == 0) throw;
address VAR57 = msg.sender;
bool VAR117 = VAR99[VAR57] > 0;
VAR99[VAR57] = VAR99[VAR57].FUN4(msg.value);
if(VAR99[VAR57] < VAR102 || VAR99[VAR57] > VAR103) {
throw;
}
if(!VAR117) {
VAR98.FUN69(VAR57);
VAR40++;
}
VAR9 = VAR9.FUN4(msg.value);
if(VAR9 > VAR104) {
throw;
}
FUN23(VAR57, msg.value, 0, VAR59);
}
function FUN59(uint128 VAR59) public stopInEmergency payable {
FUN57(VAR59);
}
function FUN60() public stopInEmergency payable {
FUN57(0x0);
}
function FUN70() stopNonOwnersInEmergency public {
if(FUN32() != VAR48.VAR52) {
throw;
}
if(address(VAR7) == 0) throw;
VAR7.VAR118.value(VAR9)(address(this));
VAR74 = FUN67().FUN14(address(this));
if(VAR74 == 0) {
throw;
}
FUN64(VAR74);
}
function FUN71(address VAR57) public constant returns (uint) {
if(FUN32() != VAR48.VAR109) {
throw;
}
return VAR99[VAR57].FUN1(VAR74) / VAR9;
}
function FUN72(address VAR57) public constant returns (uint) {
return FUN71(VAR57).FUN3(VAR100[VAR57]);
}
function FUN73() {
FUN74(FUN72(msg.sender));
}
function FUN74(uint VAR119) VAR27 {
require (VAR76 > VAR107);
address VAR57 = msg.sender;
if(VAR119 == 0) {
throw;
}
if(FUN72(VAR57) < VAR119) {
throw;
}
if(VAR100[VAR57] == 0) {
VAR105++;
}
VAR100[VAR57] = VAR100[VAR57].FUN4(VAR119);
VAR106 = VAR106.FUN4(VAR119);
FUN67().transfer(VAR57, VAR119);
FUN65(VAR57, VAR119);
}
function FUN43() VAR27 {
if(FUN32() != VAR48.VAR56) throw;
address VAR57 = msg.sender;
if(VAR99[VAR57] == 0) throw;
uint VAR119 = VAR99[VAR57];
delete VAR99[VAR57];
if(!(VAR57.call.value(VAR119)())) throw;
FUN63(VAR57, VAR119);
}
function FUN75(Crowdsale VAR120) public onlyOwner {
VAR7 = VAR120;
if(!VAR7.FUN50()) true;
}
function FUN76(uint VAR121) public onlyOwner {
VAR107 = VAR121;
}
function FUN77() public onlyOwner {
VAR108 = true;
}
function FUN42() public payable {
if(FUN32() != VAR48.VAR56) throw;
}
function FUN32() public returns(VAR48) {
if (VAR108)
return VAR48.VAR56;
if(VAR74 == 0) {
if(VAR76 >= VAR101) {
return VAR48.VAR56;
} else {
return VAR48.VAR52;
}
} else {
return VAR48.VAR109;
}
}
function FUN78() public constant returns (bool) {
return true;
}
function() payable {
throw;
}
}
1
---------------------------------
99 0x6f3a995e904c9be5279e375e79f3c30105efa618.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
address public VAR3;
address public VAR4;
function FUN1() public {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(VAR3 == msg.sender);
VAR5;
}
function FUN2(address VAR6) onlyOwner public {
VAR4 = VAR6;
}
function FUN3() public {
require(VAR4 == msg.sender);
VAR3 = VAR4;
delete VAR4;
}
}
contract VAR7 {
function FUN4(address VAR8) public constant returns (uint);
function transfer(address VAR9, uint value) public;
}
contract ManualMigration is VAR2 {
address                      public VAR10 = 0x5B5d8A8A732A3c73fF0fB6980880Ef399ecaf72E;
uint                         public VAR11;
mapping (address => uint256) public VAR12;
uint                         public VAR13;
mapping (address => bool)    public VAR14;
event Transfer(address indexed VAR15, address indexed VAR9, uint value);
function FUN5() public FUN1() {}
function FUN6(address VAR16, bool VAR17) public onlyOwner {
require(VAR10 != 0);
require(VAR12[VAR16] == 0);
uint VAR18 = FUN7(VAR10).FUN4(VAR16);
VAR18 *= VAR17 ? 27 : 45;
VAR18 /= 10;
VAR18 *= 100000000;
VAR12[VAR16] = VAR18;
VAR11 += VAR18;
if (!VAR14[VAR16]) {
VAR14[VAR16] = true;
++VAR13;
}
Transfer(VAR10, VAR16, VAR18);
}
function FUN8(address [] VAR16, bool VAR17) public onlyOwner {
for(uint VAR19 = 0; VAR19 < VAR16.VAR20; ++VAR19) {
FUN6(VAR16[VAR19], VAR17);
}
}
function FUN9() public onlyOwner {
delete VAR10;
}
}
contract Crowdsale is VAR21 {
address public VAR22;
address public VAR23 = 0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1;
uint    public VAR24 = 1517270400;
uint    public VAR25 = 1522454400;
uint    public VAR26;
uint    public VAR27;
bool    public VAR28;
event FUN10(address indexed VAR29, uint VAR30, bytes32 VAR31);
modifier FUN11(uint VAR32) {
require(msg.VAR33.VAR20 >= VAR32 + 4);
VAR5;
}
modifier FUN12() {
require(VAR34 >= VAR24 && VAR34 <= VAR25);
VAR5;
}
function FUN13(address VAR35, uint VAR36) public FUN5() {
VAR22 = VAR35;
VAR26 = VAR36;
}
function FUN14(address VAR35) public onlyOwner {
VAR22 = VAR35;
}
function FUN15(uint VAR36) public {
require(msg.sender == VAR3 || msg.sender == VAR22);
VAR26 = VAR36;
}
function () payable public VAR37 {
uint VAR38 = msg.value * VAR26 / 1 VAR39;
VAR27 += VAR38;
FUN16(msg.sender, VAR38);
}
function FUN17(address VAR16, uint VAR40) public VAR37 {
require(msg.sender == VAR22 || msg.sender == VAR3);
VAR27 += VAR40;
FUN16(VAR16, VAR40);
}
function FUN16(address VAR16, uint VAR40) internal {
uint VAR41 = 100;
if (VAR40 >= 50000) {
VAR41 = 120;
} else if (VAR34 < VAR24 + 1 VAR42) {
VAR41 = 115;
} else if (VAR34 < VAR24 + 1 VAR43) {
VAR41 = 110;
}
uint VAR30 = VAR41 * VAR40 * 100000000;
require(VAR12[VAR16] + VAR30 > VAR12[VAR16]);
require(VAR30 > 0);
VAR12[VAR16] += VAR30;
if (!VAR14[VAR16]) {
VAR14[VAR16] = true;
++VAR13;
}
Transfer(this, VAR16, VAR30);
VAR11 += VAR30;
}
function FUN18(address VAR16, uint VAR44, bytes32 VAR45) public VAR37 {
require(msg.sender == VAR22 || msg.sender == VAR3);
uint VAR30 = 15 * VAR44 / 10;
require(VAR12[VAR16] + VAR30 > VAR12[VAR16]);
require(VAR30 > 0);
VAR12[VAR16] += VAR30;
VAR11 += VAR30;
VAR27 += VAR44 / 100;
if (!VAR14[VAR16]) {
VAR14[VAR16] = true;
++VAR13;
}
Transfer(this, VAR16, VAR30);
FUN10(VAR16, VAR30, VAR45);
}
function FUN19() public onlyOwner {
require(msg.sender.call.FUN20(3000000).value(this.VAR18)());
uint VAR18 = FUN7(VAR23).FUN4(this);
FUN7(VAR23).transfer(msg.sender, VAR18);
}
function FUN21() public onlyOwner {
require(!VAR28);
uint VAR46 = VAR11 / 2;
VAR12[msg.sender] += VAR46;
VAR11 += VAR46;
if (!VAR14[msg.sender]) {
VAR14[msg.sender] = true;
++VAR13;
}
Transfer(this, msg.sender, VAR46);
VAR28 = true;
}
}
contract ProofToken is VAR47 {
string  public VAR48 = '';
string  public VAR49     = '';
string  public VAR50   = '';
uint8   public VAR51 = 8;
mapping (address => mapping (address => uint)) public VAR52;
event FUN22(address indexed VAR3, address indexed VAR53, uint value);
event FUN23(address indexed VAR3, uint value);
function FUN24(address VAR35, uint VAR36) public
payable FUN13(VAR35, VAR36) {
}
function transfer(address VAR54, uint256 VAR55) public FUN11(2 * 32) {
require(VAR12[msg.sender] >= VAR55);
require(VAR12[VAR54] + VAR55 >= VAR12[VAR54]);
VAR12[msg.sender] -= VAR55;
VAR12[VAR54] += VAR55;
Transfer(msg.sender, VAR54, VAR55);
}
function FUN25(address VAR56, address VAR54, uint VAR55) public FUN11(3 * 32) {
require(VAR12[VAR56] >= VAR55);
require(VAR12[VAR54] + VAR55 >= VAR12[VAR54]);
require(VAR52[VAR56][msg.sender] >= VAR55);
VAR12[VAR56] -= VAR55;
VAR12[VAR54] += VAR55;
VAR52[VAR56][msg.sender] -= VAR55;
Transfer(VAR56, VAR54, VAR55);
}
function FUN26(address VAR57, uint VAR55) public {
VAR52[msg.sender][VAR57] = VAR55;
FUN22(msg.sender, VAR57, VAR55);
}
function FUN27(address VAR6, address VAR57) public constant returns (uint VAR58) {
return VAR52[VAR6][VAR57];
}
function FUN28(uint VAR55) public {
require(VAR12[msg.sender] >= VAR55);
VAR12[msg.sender] -= VAR55;
VAR11 -= VAR55;
FUN23(msg.sender, VAR55);
}
}
1
---------------------------------
100 0x6f9ef4d30498f23e7d3116e272b855597fba83bd.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR10);
constructor() public {
VAR7 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR11;
}
function FUN6(address VAR12) public onlyOwner {
VAR8 = VAR12;
}
function FUN7() public {
require(msg.sender == VAR8);
emit FUN5(VAR7, VAR8);
VAR7 = VAR8;
VAR8 = address(0);
}
}
interface VAR13  {
function() payable external;
function FUN8() external  payable;
}
interface VAR14  {
function() payable external;
function FUN9(address VAR15) payable external returns(uint256);
function FUN10(uint256 VAR16) external;
function FUN11() external;
function FUN12() external;
function FUN13() external;
function FUN14(address VAR15) external view returns(uint256);
function FUN15(address VAR15) external view returns(uint256);
function transfer(address VAR17, uint256 VAR16) external returns(bool);
function FUN16() external view returns(uint256);
}
contract P3DRaffle is  VAR6 {
using SafeMath for uint;
HourglassInterface constant VAR18 = FUN17(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
function FUN18()
view
public
returns(uint256)
{
return ( VAR18.FUN14(address(this)))  ;
}
function FUN19(uint256 VAR19)
view
public
returns(uint256 VAR20,    uint256 VAR21,
uint256 VAR22,
uint256 VAR23,
bool VAR24,
bool VAR25,
address VAR26 )
{
return (VAR27[VAR19].VAR20,    VAR27[VAR19].VAR21,
VAR27[VAR19].VAR22,
VAR27[VAR19].VAR23,
VAR27[VAR19].VAR24,
VAR27[VAR19].VAR25,
VAR27[VAR19].VAR26
)  ;
}
function FUN20(address VAR28) view public returns(string)
{
return VAR29[VAR28];
}
function FUN21() view public returns(uint256)
{
return VAR30;
}
function FUN22() view public returns(uint256)
{
return (VAR31);
}
function FUN23() view public returns(uint256)
{
return (VAR32);
}
function FUN24() pure public returns(uint256 VAR33, uint256 VAR34)
{
return (VAR33, VAR34);
}
struct VAR35 {
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
uint256 VAR23;
bool VAR24;
bool VAR25;
address VAR26;
}
uint256 public VAR31;
uint256 public VAR32;
mapping(uint256 => address) public VAR36;
mapping(uint256 => VAR35) public VAR27;
mapping(address => string) public VAR29;
uint256 public VAR33;
uint256 public VAR34;
uint256 public VAR30;
SPASMInterface constant VAR37 = FUN25(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
constructor() public{
VAR27[0].VAR24 = true;
VAR32++;
}
function FUN26(uint256 VAR38 ,address VAR39) public payable{
require(msg.value >= 10 VAR40 * VAR38);
require(VAR38 > 0);
uint256 VAR41;
address sender  = msg.sender;
for(uint VAR42=0; VAR42< VAR38; VAR42++)
{
VAR41 = VAR42 + VAR31;
VAR36[VAR41] = sender;
}
VAR31 += VAR42;
VAR18.VAR43.value(msg.value)(VAR39);
}
function FUN27 () public{
VAR18.FUN12();
}
function FUN28 () public {
VAR37.VAR44.value(VAR30)();
VAR30 = 0;
}
function FUN29(string VAR45) public payable{
require(msg.value >= 100  VAR40);
VAR29[msg.sender] = VAR45;
VAR33 = VAR33.FUN1(msg.value);
}
function FUN30 () public{
require(VAR27[VAR32 - 1].VAR24 == true);
require(VAR33 >= 103 VAR40);
VAR27[VAR32].VAR20 = VAR46.VAR47;
VAR27[VAR32].VAR21 = VAR31;
VAR32++;
}
function FUN31 () public{
uint256 VAR48 = VAR32 - 1;
bool VAR49 = VAR27[VAR48].VAR24;
uint256 VAR20 = VAR27[VAR48].VAR20;
require(VAR49 != true);
require(VAR20 < VAR46.VAR47);
if(VAR46.VAR47 - 256 > VAR20) {
VAR27[VAR48].VAR24 = true;
VAR27[VAR48].VAR25 = false;
}
if(VAR46.VAR47 - 256 <= VAR20) {
uint256 VAR50 = uint256(FUN32(VAR20)) % VAR27[VAR48].VAR21;
uint256 VAR51 = uint256(FUN32(VAR20)) % 1000;
address VAR52 = VAR36[VAR50];
VAR27[VAR48].VAR24 = true;
VAR27[VAR48].VAR25 = true;
VAR27[VAR48].VAR22 = VAR50;
VAR27[VAR48].VAR23 = VAR51;
VAR27[VAR48].VAR26 = VAR52;
if(VAR51 == 777){
VAR52.transfer(VAR34);
VAR34 = 0;
}
VAR52.transfer(100 VAR40);
msg.sender.transfer(3 VAR40);
VAR33 = VAR33.FUN2(103 VAR40);
}
}
function () external payable{
uint256 VAR53 = msg.value.FUN4(100);
VAR33 = VAR33.FUN1(VAR53.FUN3(90));
VAR34 = VAR34.FUN1(VAR53.FUN3(9));
VAR30 = VAR30.FUN1(VAR53);
}
}
1
---------------------------------
101 0x6faff25ef78e39c518687b0dd19113f9b29ac562.sol
pragma VAR1 ^0.4.25;
interface VAR2 {
function FUN1(string VAR3) public payable;
}
contract VAR4 {
modifier VAR5 {
require(FUN2() > 0);
VAR6;
}
modifier VAR7 {
require(FUN3(true) > 0);
VAR6;
}
modifier onlyOwner{
require(msg.sender == VAR8, "");
VAR6;
}
event FUN4(
uint256 VAR9,
string VAR10,
address indexed VAR11,
uint VAR12
);
event FUN5(
uint256 VAR13,
address indexed VAR11,
address indexed VAR14,
uint VAR12
);
event FUN6(
address indexed VAR15,
address indexed VAR16,
uint VAR12
);
event FUN7(
address indexed VAR17,
address indexed VAR18,
uint VAR19
);
event FUN8(
address indexed VAR11,
uint256 VAR20,
uint256 VAR21,
address indexed VAR22,
uint VAR12,
uint256 VAR23
);
event FUN9(
address indexed VAR11,
uint256 VAR24,
uint256 VAR25,
uint VAR12,
uint256 VAR23
);
event FUN10(
address indexed VAR11,
uint256 VAR26,
uint256 VAR21
);
event FUN11(
address indexed VAR11,
uint256 VAR27
);
event Transfer(
address indexed VAR28,
address indexed VAR29,
uint256 VAR19
);
string public VAR30 = "";
string public VAR31 = "";
uint8 constant public VAR32 = 18;
uint8 constant internal VAR33 = 15;
uint8 constant internal VAR34 = 0;
uint8 constant internal VAR35 = 5;
uint8 constant internal VAR36 = 15;
uint256 constant internal VAR37 = 0.0000001 VAR38;
uint256 constant internal VAR39 = 0.00000001 VAR38;
uint256 constant internal VAR40 = 2 ** 64;
uint256 public VAR41 = 50e18;
mapping(address => uint256) internal VAR42;
mapping(address => uint256) internal VAR43;
mapping(address => VAR44) internal VAR45;
mapping(address => address) internal VAR46;
mapping(address => mapping (address => uint256)) VAR47;
uint256 internal VAR48;
uint256 internal VAR49;
address private VAR8=msg.sender;
mapping(address => uint256) internal VAR50;
uint private constant VAR51 = 365 VAR52;
uint8 constant internal VAR53 = 9;
uint8 constant internal VAR54 = 1;
address public VAR55=msg.sender;
address public VAR56=0xfc81655585F2F3935895C1409b332AB797D90B33;
uint256 public VAR57;
uint256 public VAR58;
function FUN12(address VAR59) public onlyOwner{
require(VAR59 != address(0));
VAR8 = VAR59;
}
function FUN13(address VAR60) public onlyOwner{
require(VAR60 != address(0));
VAR55 = VAR60;
}
function FUN1(string VAR3) public payable {
FUN14(msg.value,VAR3);
}
function FUN14(uint256 VAR61,string VAR3) internal {
address VAR62 = msg.sender;
uint256 VAR63 = VAR61;
if (VAR48 > 0) {
VAR49 += (VAR63 * VAR40 / VAR48);
}
emit FUN4(VAR63,VAR3,VAR62,VAR64);
}
function FUN15(address VAR65) public {
address VAR62 = VAR65;
require(VAR50[VAR62]!=0 && VAR64 >= VAR66.FUN16(VAR50[VAR62],VAR51), "");
uint256 VAR67 = VAR42[VAR62];
if (VAR67 > 0) FUN17(VAR67);
uint256 VAR63 = FUN18(VAR62);
VAR63 += VAR43[VAR62];
FUN14(VAR63,'');
delete VAR42[VAR62];
delete VAR43[VAR62];
delete VAR45[VAR62];
delete VAR50[VAR62];
emit FUN5(VAR63,VAR62,msg.sender,VAR64);
}
function FUN19() public{
require(VAR57>0 && VAR58>0, "");
VAR55.transfer(VAR57);
DevsInterface VAR68 = FUN20(VAR56);
VAR68.VAR69.value(VAR58)('');
VAR57=0;
VAR58=0;
}
function FUN21(address VAR70, address VAR71, uint256 VAR72) public returns (bool VAR73) {
uint256 VAR74 = VAR47[VAR70][msg.sender];
require(VAR42[VAR70] >= VAR72 && VAR74 >= VAR72);
VAR42[VAR71] =VAR66.FUN16(VAR42[VAR71],VAR72);
VAR42[VAR70] = VAR66.FUN22(VAR42[VAR70],VAR72);
VAR47[VAR70][msg.sender] = VAR66.FUN22(VAR47[VAR70][msg.sender],VAR72);
emit Transfer(VAR70, VAR71, VAR72);
return true;
}
function FUN23(address VAR75, uint256 VAR72) public returns (bool VAR73) {
VAR47[msg.sender][VAR75] = VAR72;
emit FUN7(msg.sender, VAR75, VAR72);
return true;
}
function FUN24(address VAR76, address VAR75) public view returns (uint256 VAR77) {
return VAR47[VAR76][VAR75];
}
function FUN25(address VAR78) public payable returns (uint256) {
FUN26(msg.value, VAR78);
}
function() payable public {
if (msg.value == 1e10) {
FUN27();
}
else if (msg.value == 2e10) {
FUN28();
}
else if (msg.value == 3e10) {
FUN29();
}
else {
FUN26(msg.value, 0x0);
}
}
function FUN27() onlyStronghands public {
uint256 VAR63 = FUN3(false);
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
VAR45[VAR62] +=  (VAR44) (VAR63 * VAR40);
VAR63 += VAR43[VAR62];
VAR43[VAR62] = 0;
uint256 VAR67 = FUN26(VAR63, 0x0);
emit FUN10(VAR62, VAR63, VAR67);
}
function FUN29() public {
address VAR62 = msg.sender;
uint256 VAR67 = VAR42[VAR62];
if (VAR67 > 0) FUN17(VAR67);
FUN28();
}
function FUN28() onlyStronghands public {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
uint256 VAR63 = FUN3(false);
VAR45[VAR62] += (VAR44) (VAR63 * VAR40);
VAR63 += VAR43[VAR62];
VAR43[VAR62] = 0;
VAR62.transfer(VAR63);
emit FUN11(VAR62, VAR63);
}
function FUN17(uint256 VAR79) onlyBagholders public {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
require(VAR79 <= VAR42[VAR62]);
uint256 VAR67 = VAR79;
uint256 VAR80 = FUN30(VAR67);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR35), 100);
uint256 VAR81 = VAR66.FUN22(VAR80, VAR63);
VAR48 = VAR66.FUN22(VAR48, VAR67);
VAR42[VAR62] = VAR66.FUN22(VAR42[VAR62], VAR67);
int256 VAR82 = (VAR44) (VAR49 * VAR67 + (VAR81 * VAR40));
VAR45[VAR62] -= VAR82;
if (VAR48 > 0) {
VAR49 = VAR66.FUN16(VAR49, (VAR63 * VAR40) / VAR48);
}
emit FUN9(VAR62, VAR67, VAR81, VAR64, FUN33());
}
function transfer(address VAR83, uint256 VAR79) onlyBagholders public returns (bool) {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
if (VAR79>VAR41) {
VAR50[VAR83] = VAR64;
}
require(VAR79 <= VAR42[VAR62]);
if (FUN3(true) > 0) {
FUN28();
}
uint256 VAR84 = VAR66.FUN31(VAR66.FUN32(VAR79, VAR34), 100);
uint256 VAR85 = VAR66.FUN22(VAR79, VAR84);
uint256 VAR63 = FUN30(VAR84);
VAR48 = VAR66.FUN22(VAR48, VAR84);
VAR42[VAR62] = VAR66.FUN22(VAR42[VAR62], VAR79);
VAR42[VAR83] = VAR66.FUN16(VAR42[VAR83], VAR85);
VAR45[VAR62] -= (VAR44) (VAR49 * VAR79);
VAR45[VAR83] += (VAR44) (VAR49 * VAR85);
VAR49 = VAR66.FUN16(VAR49, (VAR63 * VAR40) / VAR48);
emit Transfer(VAR62, VAR83, VAR85);
return true;
}
function FUN34() public view returns (uint256) {
return address(this).VAR86;
}
function FUN35() public view returns (uint256) {
return VAR48;
}
function FUN36(address VAR62) public view returns (address) {
return VAR46[VAR62];
}
function FUN2() public view returns (uint256) {
address VAR62 = msg.sender;
return FUN37(VAR62);
}
function FUN3(bool VAR87) public view returns (uint256) {
address VAR62 = msg.sender;
return VAR87 ? FUN18(VAR62) + VAR43[VAR62] : FUN18(VAR62) ;
}
function FUN37(address VAR62) public view returns (uint256) {
return VAR42[VAR62];
}
function FUN18(address VAR62) public view returns (uint256) {
return (uint256) ((VAR44) (VAR49 * VAR42[VAR62]) - VAR45[VAR62]) / VAR40;
}
function FUN38() public view returns (uint256) {
if (VAR48 == 0) {
return VAR37 - VAR39;
} else {
uint256 VAR80 = FUN30(1e18);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR35), 100);
uint256 VAR81 = VAR66.FUN22(VAR80, VAR63);
return VAR81;
}
}
function FUN33() public view returns (uint256) {
if (VAR48 == 0) {
return VAR37 + VAR39;
} else {
uint256 VAR80 = FUN30(1e18);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR33), 100);
uint256 VAR81 = VAR66.FUN16(VAR80, VAR63);
return VAR81;
}
}
function FUN39(uint256 VAR88) public view returns (uint256) {
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR88, VAR33), 100);
uint256 VAR81 = VAR66.FUN22(VAR88, VAR63);
uint256 VAR79 = FUN40(VAR81);
return VAR79;
}
function FUN41(uint256 VAR89) public view returns (uint256) {
require(VAR89 <= VAR48);
uint256 VAR80 = FUN30(VAR89);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR35), 100);
uint256 VAR81 = VAR66.FUN22(VAR80, VAR63);
return VAR81;
}
function FUN26(uint256 VAR90, address VAR78) internal returns (uint256) {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
uint256 VAR91 = VAR66.FUN31(VAR66.FUN32(VAR90, VAR33-VAR53-VAR54), 100);
uint256 VAR92 = VAR66.FUN31(VAR66.FUN32(VAR90, VAR53), 100);
uint256 VAR93 = VAR66.FUN31(VAR66.FUN32(VAR90, VAR54), 100);
uint256 VAR94 = VAR66.FUN31(VAR66.FUN32(VAR91, VAR36), 100);
uint256 VAR63 = VAR66.FUN22(VAR91, VAR94);
uint256 VAR81 = VAR66.FUN22(VAR66.FUN22(VAR66.FUN22(VAR90, VAR91),VAR92),VAR93);
uint256 VAR79 = FUN40(VAR81);
uint256 VAR95 = VAR63 * VAR40;
require(VAR79 > 0 && VAR66.FUN16(VAR79, VAR48) > VAR48);
if (
VAR78 != 0x0000000000000000000000000000000000000000 &&
VAR78 != VAR62 &&
VAR42[VAR78] >= VAR41 &&
VAR46[VAR62] == 0x0
) {
VAR46[VAR62] = VAR78;
emit FUN6(VAR62,VAR78, VAR64);
}
if (
VAR46[VAR62] != 0x0 &&
VAR42[VAR46[VAR62]] >= VAR41
) {
VAR43[VAR78] = VAR66.FUN16(VAR43[VAR78], VAR94);
} else {
VAR63 = VAR66.FUN16(VAR63, VAR94);
VAR95 = VAR63 * VAR40;
}
if (VAR48 > 0) {
VAR48 = VAR66.FUN16(VAR48, VAR79);
VAR49 += (VAR63 * VAR40 / VAR48);
VAR95 = VAR95 - (VAR95 - (VAR79 * (VAR63 * VAR40 / VAR48)));
} else {
VAR48 = VAR79;
}
VAR42[VAR62] = VAR66.FUN16(VAR42[VAR62], VAR79);
int256 VAR82 = (VAR44) (VAR49 * VAR79 - VAR95);
VAR45[VAR62] += VAR82;
VAR57=VAR66.FUN16(VAR57,VAR92);
VAR58=VAR66.FUN16(VAR58,VAR93);
if (VAR57>1e17){
FUN19();
}
emit FUN8(VAR62, VAR90, VAR79, VAR78, VAR64, FUN33());
return VAR79;
}
function FUN40(uint256 VAR80) internal view returns (uint256) {
uint256 VAR96 = VAR37 * 1e18;
uint256 VAR97 =
(
(
VAR66.FUN22(
(VAR98
(
(VAR96 ** 2)
+
(2 * (VAR39 * 1e18) * (VAR80 * 1e18))
+
((VAR39 ** 2) * (VAR48 ** 2))
+
(2 * VAR39 * VAR96*VAR48)
)
), VAR96
)
) / (VAR39)
) - (VAR48);
return VAR97;
}
function FUN30(uint256 VAR67) internal view returns (uint256) {
uint256 VAR99 = (VAR67 + 1e18);
uint256 VAR100 = (VAR48 + 1e18);
uint256 VAR101 =
(
VAR66.FUN22(
(
(
(
VAR37 + (VAR39 * (VAR100 / 1e18))
) - VAR39
) * (VAR99 - 1e18)
), (VAR39 * ((VAR99 ** 2 - VAR99) / 1e18)) / 2
)
/ 1e18);
return VAR101;
}
function FUN42(uint256 VAR102) internal pure returns (uint256 VAR103) {
uint256 VAR104 = (VAR102 + 1) / 2;
VAR103 = VAR102;
while (VAR104 < VAR103) {
VAR103 = VAR104;
VAR104 = (VAR102 / VAR104 + VAR104) / 2;
}
}
}
library VAR66 {
function FUN32(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
if (VAR105 == 0) {
return 0;
}
uint256 VAR107 = VAR105 * VAR106;
assert(VAR107 / VAR105 == VAR106);
return VAR107;
}
function FUN31(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
uint256 VAR107 = VAR105 / VAR106;
return VAR107;
}
function FUN22(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
assert(VAR106 <= VAR105);
return VAR105 - VAR106;
}
function FUN16(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
uint256 VAR107 = VAR105 + VAR106;
assert(VAR107 >= VAR105);
return VAR107;
}
}
1
---------------------------------
102 0x70396c561849d1ed656c6e0d2a04b83131c0c645.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
bool public VAR42;
bool public VAR43;
bool public VAR44;
address public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => uint256) public VAR47;
mapping (address => bool) public VAR48;
uint public VAR49;
enum VAR50{VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57, VAR58}
event FUN26(address VAR59, uint VAR60, uint VAR21, uint128 VAR61);
event FUN27(address VAR59, uint VAR60);
event FUN28(bool VAR43, bool VAR44, address VAR45);
event FUN29(address VAR62, bool VAR63);
event FUN30(uint VAR38);
function FUN31(address VAR64, PricingStrategy VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR69) {
VAR9 = msg.sender;
VAR32 = FUN32(VAR64);
FUN33(VAR65);
VAR35 = VAR66;
if(VAR35 == 0) {
throw;
}
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR68 == 0) {
throw;
}
VAR38 = VAR68;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR69;
}
function() payable {
throw;
}
function FUN34(address VAR70, uint128 VAR61) stopInEmergency private {
if(FUN35() == VAR50.VAR53) {
if(!VAR48[VAR70]) {
throw;
}
} else if(FUN35() == VAR50.VAR54) {
} else {
throw;
}
uint VAR60 = msg.value;
uint VAR21 = VAR33.FUN18(VAR60, VAR17, VAR18, msg.sender, VAR32.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR46[VAR70] == 0) {
VAR39++;
}
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR60, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR70, VAR21);
if(!VAR35.FUN39(VAR60)) throw;
FUN26(VAR70, VAR60, VAR21, VAR61);
}
function FUN40(address VAR70, uint VAR71, uint VAR72) public onlyOwner {
uint VAR21 = VAR71 * 10**VAR32.FUN36();
uint VAR60 = VAR72 * VAR71;
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
FUN38(VAR70, VAR21);
FUN26(VAR70, VAR60, VAR21, 0);
}
function FUN41(address VAR62, uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
bytes32 VAR76 = FUN42(VAR62);
if (FUN43(VAR76, VAR73, VAR74, VAR75) != VAR45) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN44(address VAR62, uint128 VAR61) public payable {
if(VAR44) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN45(address VAR62) public payable {
if(VAR43) throw;
if(VAR44) throw;
FUN34(VAR62, 0);
}
function FUN46(uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
FUN41(msg.sender, VAR61, VAR73, VAR74, VAR75);
}
function FUN47(uint128 VAR61) public payable {
FUN44(msg.sender, VAR61);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR50.VAR55) onlyOwner VAR13 {
if(VAR42) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN20();
}
VAR42 = true;
}
function FUN51(FinalizeAgent VAR62) onlyOwner {
VAR34 = VAR62;
if(!VAR34.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR43 = value;
FUN28(VAR43, VAR44, VAR45);
}
function FUN53(bool value, address VAR77) onlyOwner {
VAR44 = value;
VAR45 = VAR77;
FUN28(VAR43, VAR44, VAR45);
}
function FUN54(address VAR62, bool VAR63) onlyOwner {
VAR48[VAR62] = VAR63;
FUN29(VAR62, VAR63);
}
function FUN55(uint VAR78) onlyOwner {
if(VAR79 > VAR78) {
throw;
}
VAR38 = VAR78;
FUN30(VAR38);
}
function FUN33(PricingStrategy VAR65) onlyOwner {
VAR33 = VAR65;
if(!VAR33.FUN16()) {
throw;
}
}
function FUN56(address VAR62) public onlyOwner {
if(VAR39 > VAR31) {
throw;
}
VAR35 = VAR62;
}
function FUN57() public payable FUN50(VAR50.VAR56) {
if(msg.value == 0) throw;
VAR40 = VAR40.FUN11(msg.value);
}
function FUN58() public FUN50(VAR50.VAR58) {
uint256 VAR80 = VAR46[msg.sender];
if (VAR80 == 0) throw;
VAR46[msg.sender] = 0;
VAR41 = VAR41.FUN11(VAR80);
FUN27(msg.sender, VAR80);
if (!msg.sender.FUN39(VAR80)) throw;
}
function FUN59() public constant returns (bool VAR81) {
return VAR17 >= VAR36;
}
function FUN60() public constant returns (bool VAR82) {
return VAR34.FUN17();
}
function FUN61() public constant returns (bool VAR82) {
return VAR33.FUN17(address(this));
}
function FUN35() public constant returns (VAR50) {
if(VAR42) return VAR50.VAR57;
else if (address(VAR34) == 0) return VAR50.VAR52;
else if (!VAR34.FUN17()) return VAR50.VAR52;
else if (!VAR33.FUN17(address(this))) return VAR50.VAR52;
else if (VAR83.VAR84 < VAR37) return VAR50.VAR53;
else if (VAR83.VAR84 <= VAR38 && !FUN62()) return VAR50.VAR54;
else if (FUN59()) return VAR50.VAR55;
else if (!FUN59() && VAR17 > 0 && VAR40 >= VAR17) return VAR50.VAR58;
else return VAR50.VAR56;
}
function FUN63(uint VAR85) onlyOwner {
VAR49 = VAR85;
}
function FUN64() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR86) {
if(FUN35() != VAR86) throw;
VAR10;
}
//
//
function FUN37(uint VAR60, uint VAR21, uint VAR87, uint VAR88) constant returns (bool VAR89);
function FUN62() public constant returns (bool);
function FUN38(address VAR70, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN65(address VAR70, uint VAR90);
mapping(address => uint) VAR91;
mapping (address => mapping (address => uint)) VAR92;
function FUN66() public constant returns (bool VAR93) {
return true;
}
function transfer(address VAR94, uint VAR95) returns (bool VAR96) {
VAR91[msg.sender] = FUN3(VAR91[msg.sender], VAR95);
VAR91[VAR94] = FUN4(VAR91[VAR94], VAR95);
Transfer(msg.sender, VAR94, VAR95);
return true;
}
function FUN23(address VAR97, address VAR94, uint VAR95) returns (bool VAR96) {
uint VAR98 = VAR92[VAR97][msg.sender];
VAR91[VAR94] = FUN4(VAR91[VAR94], VAR95);
VAR91[VAR97] = FUN3(VAR91[VAR97], VAR95);
VAR92[VAR97][msg.sender] = FUN3(VAR98, VAR95);
Transfer(VAR97, VAR94, VAR95);
return true;
}
function FUN21(address VAR99) constant returns (uint VAR100) {
return VAR91[VAR99];
}
function FUN24(address VAR101, uint VAR95) returns (bool VAR96) {
if ((VAR95 != 0) && (VAR92[msg.sender][VAR101] != 0)) throw;
VAR92[msg.sender][VAR101] = VAR95;
FUN25(msg.sender, VAR101, VAR95);
return true;
}
function FUN22(address VAR99, address VAR101) constant returns (uint VAR102) {
return VAR92[VAR99][VAR101];
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR39;
uint public VAR87;
address[] public VAR103;
mapping(address => uint) public VAR91;
mapping(address => uint) public VAR104;
uint public VAR105;
uint public VAR106;
uint public VAR107;
uint public VAR108;
uint public VAR109;
uint public VAR110;
uint public VAR111;
Crowdsale public VAR16;
enum VAR50{VAR51, VAR54, VAR112, VAR58}
event FUN26(address VAR59, uint value, uint128 VAR61);
event FUN67(address VAR59, uint value);
event FUN68(uint VAR113);
event FUN69(address VAR103, uint VAR113);
function FUN70(address VAR99, uint VAR114, uint VAR115, uint VAR116, uint VAR117) {
VAR9 = VAR99;
if(VAR114 == 0) {
throw;
}
if(VAR115 == 0) {
throw;
}
if(VAR116 == 0) {
throw;
}
VAR106 = VAR115;
VAR107 = VAR116;
VAR108 = VAR117;
VAR105 = VAR114;
}
function FUN71() public constant returns(VAR118) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN72();
}
function FUN45(uint128 VAR61) private {
if(FUN35() != VAR50.VAR54) throw;
if(msg.value == 0) throw;
address VAR59 = msg.sender;
bool VAR119 = VAR91[VAR59] > 0;
VAR91[VAR59] = FUN4(VAR91[VAR59], msg.value);
if(VAR91[VAR59] < VAR106 || VAR91[VAR59] > VAR107) {
throw;
}
if(!VAR119) {
VAR103.FUN73(VAR59);
VAR39++;
}
VAR87 = FUN4(VAR87, msg.value);
if(VAR87 > VAR108) {
throw;
}
FUN26(VAR59, msg.value, VAR61);
}
function FUN74(uint128 VAR61) public stopInEmergency payable {
FUN45(VAR61);
}
function FUN75() public stopInEmergency payable {
FUN45(0x0);
}
function FUN76() stopInEmergency public {
if(FUN35() != VAR50.VAR54) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR120.value(VAR87)(address(this));
VAR109 = FUN71().FUN21(address(this));
if(VAR109 == 0) {
throw;
}
FUN68(VAR109);
}
function FUN77(address VAR59) public constant returns (uint) {
if(FUN35() != VAR50.VAR112) {
throw;
}
return FUN1(VAR91[VAR59], VAR109) / VAR87;
}
function FUN78(address VAR59) public constant returns (uint) {
return FUN3(FUN77(VAR59), VAR104[VAR59]);
}
function FUN79() {
FUN80(FUN78(msg.sender));
}
function FUN80(uint VAR90) VAR13 {
address VAR59 = msg.sender;
if(VAR90 == 0) {
throw;
}
if(FUN78(VAR59) < VAR90) {
throw;
}
if(VAR104[VAR59] == 0) {
VAR110++;
}
VAR104[VAR59] = FUN4(VAR104[VAR59], VAR90);
VAR111 = FUN4(VAR111, VAR90);
FUN71().transfer(VAR59, VAR90);
FUN69(VAR59, VAR90);
}
function FUN58() VAR13 {
if(FUN35() != VAR50.VAR58) throw;
address VAR59 = msg.sender;
if(VAR91[VAR59] == 0) throw;
uint VAR90 = VAR91[VAR59];
delete VAR91[VAR59];
if(!(VAR59.call.value(VAR90)())) throw;
FUN67(VAR59, VAR90);
}
function FUN81(Crowdsale VAR121) public onlyOwner {
VAR16 = VAR121;
if(!VAR16.FUN64()) true;
}
function FUN35() public returns(VAR50) {
if(VAR109 == 0) {
if(VAR79 >= VAR105) {
return VAR50.VAR58;
} else {
return VAR50.VAR54;
}
} else {
return VAR50.VAR112;
}
}
function() payable {
throw;
}
}
1
---------------------------------
103 0x70bfe40f98c06a0ad60759be8c4b1ecf0c354baf.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
address public VAR3;
event FUN1(address indexed VAR4);
event FUN2(
address indexed VAR4,
address indexed VAR5
);
constructor() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR6;
}
function FUN3() public onlyOwner {
emit FUN1(VAR3);
VAR3 = address(0);
}
function FUN4(address VAR7) public onlyOwner {
FUN5(VAR7);
}
function FUN5(address VAR7) internal {
require(VAR7 != address(0));
emit FUN2(VAR3, VAR7);
VAR3 = VAR7;
}
}
library VAR8 {
function FUN6(uint256 VAR9, uint256 VAR10) internal pure returns (uint256 VAR11) {
if (VAR9 == 0) {
return 0;
}
VAR11 = VAR9 * VAR10;
assert(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
return VAR9 / VAR10;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (uint256 VAR11) {
VAR11 = VAR9 + VAR10;
assert(VAR11 >= VAR9);
return VAR11;
}
}
contract VAR12 {
function FUN10() public view returns (uint256);
function FUN11(address VAR13) public view returns (uint256);
function transfer(address VAR14, uint256 value) public returns (bool);
event Transfer(address indexed VAR15, address indexed VAR14, uint256 value);
}
contract BasicToken is VAR12 {
using SafeMath for uint256;
mapping(address => uint256) VAR16;
uint256 VAR17;
function FUN10() public view returns (uint256) {
return VAR17;
}
function transfer(address VAR18, uint256 VAR19) public returns (bool) {
require(VAR18 != address(0));
require(VAR19 <= VAR16[msg.sender]);
VAR16[msg.sender] = VAR16[msg.sender].FUN8(VAR19);
VAR16[VAR18] = VAR16[VAR18].FUN9(VAR19);
emit Transfer(msg.sender, VAR18, VAR19);
return true;
}
function FUN11(address VAR20) public view returns (uint256) {
return VAR16[VAR20];
}
}
contract ERC20 is VAR12 {
function FUN12(address VAR3, address VAR21)
public view returns (uint256);
function FUN13(address VAR15, address VAR14, uint256 value)
public returns (bool);
function FUN14(address VAR21, uint256 value) public returns (bool);
event FUN15(
address indexed VAR3,
address indexed VAR21,
uint256 value
);
}
contract StandardToken is VAR22, VAR23 {
mapping (address => mapping (address => uint256)) internal VAR24;
function FUN13(
address VAR25,
address VAR18,
uint256 VAR19
)
public
returns (bool)
{
require(VAR18 != address(0));
require(VAR19 <= VAR16[VAR25]);
require(VAR19 <= VAR24[VAR25][msg.sender]);
VAR16[VAR25] = VAR16[VAR25].FUN8(VAR19);
VAR16[VAR18] = VAR16[VAR18].FUN9(VAR19);
VAR24[VAR25][msg.sender] = VAR24[VAR25][msg.sender].FUN8(VAR19);
emit Transfer(VAR25, VAR18, VAR19);
return true;
}
function FUN14(address VAR26, uint256 VAR19) public returns (bool) {
VAR24[msg.sender][VAR26] = VAR19;
emit FUN15(msg.sender, VAR26, VAR19);
return true;
}
function FUN12(
address VAR20,
address VAR26
)
public
view
returns (uint256)
{
return VAR24[VAR20][VAR26];
}
function FUN16(
address VAR26,
uint256 VAR27
)
public
returns (bool)
{
VAR24[msg.sender][VAR26] = (
VAR24[msg.sender][VAR26].FUN9(VAR27));
emit FUN15(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
function FUN17(
address VAR26,
uint256 VAR28
)
public
returns (bool)
{
uint256 VAR29 = VAR24[msg.sender][VAR26];
if (VAR28 > VAR29) {
VAR24[msg.sender][VAR26] = 0;
} else {
VAR24[msg.sender][VAR26] = VAR29.FUN8(VAR28);
}
emit FUN15(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
}
contract Pausable is VAR2 {
event FUN18();
event FUN19();
bool public VAR30 = false;
modifier FUN20() {
require(!VAR30);
VAR6;
}
modifier FUN21() {
require(VAR30);
VAR6;
}
function FUN22() onlyOwner whenNotPaused public {
VAR30 = true;
emit FUN18();
}
function FUN23() onlyOwner whenPaused public {
VAR30 = false;
emit FUN19();
}
}
contract PausableToken is VAR31, VAR32 {
function transfer(
address VAR18,
uint256 VAR19
)
public
VAR33
returns (bool)
{
return super.transfer(VAR18, VAR19);
}
function FUN13(
address VAR25,
address VAR18,
uint256 VAR19
)
public
VAR33
returns (bool)
{
return super.FUN13(VAR25, VAR18, VAR19);
}
function FUN14(
address VAR26,
uint256 VAR19
)
public
VAR33
returns (bool)
{
return super.FUN14(VAR26, VAR19);
}
function FUN16(
address VAR26,
uint VAR27
)
public
VAR33
returns (bool VAR34)
{
return super.FUN16(VAR26, VAR27);
}
function FUN17(
address VAR26,
uint VAR28
)
public
VAR33
returns (bool VAR34)
{
return super.FUN17(VAR26, VAR28);
}
}
contract BurnableToken is VAR23 {
event FUN24(address indexed VAR35, uint256 value);
function FUN25(uint256 VAR19) public {
FUN26(msg.sender, VAR19);
}
function FUN26(address VAR36, uint256 VAR19) internal {
require(VAR19 <= VAR16[VAR36]);
VAR16[VAR36] = VAR16[VAR36].FUN8(VAR19);
VAR17 = VAR17.FUN8(VAR19);
emit FUN24(VAR36, VAR19);
emit Transfer(VAR36, address(0), VAR19);
}
}
contract RepublicToken is VAR37, VAR38 {
string public constant VAR39 = "";
string public constant VAR40 = "";
uint8 public constant VAR41 = 18;
uint256 public constant VAR42 = 1000000000 * 10**uint256(VAR41);
constructor() public {
VAR17 = VAR42;
VAR16[msg.sender] = VAR42;
}
function FUN27(address VAR43, uint256 VAR44) public onlyOwner returns (bool) {
require(VAR44 > 0);
VAR16[VAR3] = VAR16[VAR3].FUN8(VAR44);
VAR16[VAR43] = VAR16[VAR43].FUN9(VAR44);
emit Transfer(VAR3, VAR43, VAR44);
return true;
}
}
contract Claimable is VAR2 {
address public VAR45;
modifier FUN28() {
require(msg.sender == VAR45);
VAR6;
}
function FUN4(address VAR5) onlyOwner public {
VAR45 = VAR5;
}
function FUN29() onlyPendingOwner public {
emit FUN2(VAR3, VAR45);
VAR3 = VAR45;
VAR45 = address(0);
}
}
library VAR46 {
address public constant NULL = 0x0;
struct VAR47 {
bool VAR48;
address VAR49;
address VAR50;
}
struct VAR51 {
mapping (address => VAR47) VAR52;
}
function FUN30(List storage VAR53, address VAR54, address VAR55) internal {
require(!FUN31(VAR53, VAR55), "");
require(FUN31(VAR53, VAR54) || VAR54 == NULL, "");
address VAR56 = VAR53.VAR52[VAR54].VAR49;
VAR53.VAR52[VAR55].VAR50 = VAR54;
VAR53.VAR52[VAR55].VAR49 = VAR56;
VAR53.VAR52[VAR54].VAR49 = VAR55;
VAR53.VAR52[VAR56].VAR50 = VAR55;
VAR53.VAR52[VAR55].VAR48 = true;
}
function FUN32(List storage VAR53, address VAR54, address VAR55) internal {
require(!FUN31(VAR53, VAR55), "");
require(FUN31(VAR53, VAR54) || VAR54 == NULL, "");
address VAR57 = VAR53.VAR52[VAR54].VAR50;
VAR53.VAR52[VAR55].VAR49 = VAR54;
VAR53.VAR52[VAR55].VAR50 = VAR57;
VAR53.VAR52[VAR54].VAR50 = VAR55;
VAR53.VAR52[VAR57].VAR49 = VAR55;
VAR53.VAR52[VAR55].VAR48 = true;
}
function FUN33(List storage VAR53, address VAR58) internal {
require(FUN31(VAR53, VAR58), "");
if (VAR58 == NULL) {
return;
}
address VAR59 = VAR53.VAR52[VAR58].VAR49;
address VAR57 = VAR53.VAR52[VAR58].VAR50;
VAR53.VAR52[VAR59].VAR50 = VAR57;
VAR53.VAR52[VAR57].VAR49 = VAR59;
VAR53.VAR52[VAR58].VAR48 = false;
delete VAR53.VAR52[VAR58];
}
function FUN34(List storage VAR53, address VAR58) internal {
FUN30(VAR53, FUN35(VAR53), VAR58);
}
function FUN36(List storage VAR53, address VAR58) internal {
FUN32(VAR53, FUN37(VAR53), VAR58);
}
function FUN38(List storage VAR53, address VAR60, address VAR61) internal {
address VAR62 = VAR53.VAR52[VAR61].VAR49;
FUN33(VAR53, VAR61);
FUN32(VAR53, VAR60, VAR61);
FUN33(VAR53, VAR60);
FUN32(VAR53, VAR62, VAR60);
}
function FUN31(List storage VAR53, address VAR58) internal view returns (bool) {
return VAR53.VAR52[VAR58].VAR48;
}
function FUN35(List storage VAR53) internal view returns (address) {
return VAR53.VAR52[NULL].VAR50;
}
function FUN37(List storage VAR53) internal view returns (address) {
return VAR53.VAR52[NULL].VAR49;
}
function FUN39(List storage VAR53, address VAR58) internal view returns (address) {
require(FUN31(VAR53, VAR58), "");
return VAR53.VAR52[VAR58].VAR50;
}
function FUN40(List storage VAR53, address VAR58) internal view returns (address) {
require(FUN31(VAR53, VAR58), "");
return VAR53.VAR52[VAR58].VAR49;
}
}
contract DarknodeRegistryStore is VAR63 {
using SafeMath for uint256;
string public VAR64;
struct VAR65 {
address VAR3;
uint256 VAR66;
uint256 VAR67;
uint256 VAR68;
bytes VAR69;
}
mapping(address => VAR65) private VAR70;
VAR46.List private VAR71;
RepublicToken public VAR72;
constructor(
string VAR73,
RepublicToken VAR74
) public {
VAR64 = VAR73;
VAR72 = VAR74;
}
function FUN41(
address VAR75,
address VAR76,
uint256 VAR77,
bytes VAR78,
uint256 VAR79,
uint256 VAR80
) external onlyOwner {
Darknode memory VAR81 = FUN42({
VAR3: VAR76,
VAR66: VAR77,
VAR69: VAR78,
VAR67: VAR79,
VAR68: VAR80
});
VAR70[VAR75] = VAR81;
VAR46.FUN36(VAR71, VAR75);
}
function FUN35() external view onlyOwner returns(address) {
return VAR46.FUN35(VAR71);
}
function FUN39(address VAR82) external view onlyOwner returns(address) {
return VAR46.FUN39(VAR71, VAR82);
}
function FUN43(address VAR82) external onlyOwner {
uint256 VAR66 = VAR70[VAR82].VAR66;
delete VAR70[VAR82];
VAR46.FUN33(VAR71, VAR82);
require(VAR72.transfer(VAR3, VAR66), "");
}
function FUN44(address VAR82, uint256 VAR83) external onlyOwner {
uint256 VAR84 = VAR70[VAR82].VAR66;
require(VAR83 < VAR84, "");
VAR70[VAR82].VAR66 = VAR83;
require(VAR72.transfer(VAR3, VAR84.FUN8(VAR83)), "");
}
function FUN45(address VAR82, uint256 VAR68) external onlyOwner {
VAR70[VAR82].VAR68 = VAR68;
}
function FUN46(address VAR82) external view onlyOwner returns (address) {
return VAR70[VAR82].VAR3;
}
function FUN47(address VAR82) external view onlyOwner returns (uint256) {
return VAR70[VAR82].VAR66;
}
function FUN48(address VAR82) external view onlyOwner returns (uint256) {
return VAR70[VAR82].VAR67;
}
function FUN49(address VAR82) external view onlyOwner returns (uint256) {
return VAR70[VAR82].VAR68;
}
function FUN50(address VAR82) external view onlyOwner returns (bytes) {
return VAR70[VAR82].VAR69;
}
}
contract DarknodeRegistry is VAR2 {
using SafeMath for uint256;
string public VAR64;
struct VAR85 {
uint256 VAR86;
uint256 VAR87;
}
uint256 public VAR88;
uint256 public VAR89;
uint256 public VAR90;
uint256 public VAR91;
uint256 public VAR92;
uint256 public VAR93;
address public VAR94;
uint256 public VAR95;
uint256 public VAR96;
uint256 public VAR97;
address public VAR98;
Epoch public VAR99;
Epoch public VAR100;
RepublicToken public VAR72;
DarknodeRegistryStore public VAR101;
event FUN51(address VAR75, uint256 VAR77);
event FUN52(address VAR75);
event FUN53(address VAR20, uint256 VAR102);
event FUN54();
event FUN55(uint256 VAR103, uint256 VAR95);
event FUN56(uint256 VAR104, uint256 VAR96);
event FUN57(uint256 VAR105, uint256 VAR97);
event FUN58(address VAR106, address VAR98);
modifier FUN59(address VAR75) {
require(VAR101.FUN46(VAR75) == msg.sender, "");
VAR6;
}
modifier FUN60(address VAR75) {
require(FUN61(VAR75), "");
VAR6;
}
modifier FUN62(address VAR75) {
require(FUN63(VAR75), "");
VAR6;
}
modifier FUN64(address VAR75) {
require(FUN65(VAR75), "");
VAR6;
}
modifier FUN66() {
require(VAR94 == msg.sender, "");
VAR6;
}
constructor(
string VAR73,
RepublicToken VAR107,
DarknodeRegistryStore VAR108,
uint256 VAR109,
uint256 VAR110,
uint256 VAR111
) public {
VAR64 = VAR73;
VAR101 = VAR108;
VAR72 = VAR107;
VAR91 = VAR109;
VAR95 = VAR91;
VAR92 = VAR110;
VAR96 = VAR92;
VAR93 = VAR111;
VAR97 = VAR93;
VAR99 = FUN67({
VAR86: uint256(FUN68(VAR112.VAR113 - 1)),
VAR87: VAR112.VAR113
});
VAR88 = 0;
VAR89 = 0;
VAR90 = 0;
}
function FUN69(address VAR75, bytes VAR78) external FUN60(VAR75) {
uint256 VAR66 = VAR91;
require(VAR72.FUN13(msg.sender, VAR101, VAR66), "");
VAR101.FUN41(
VAR75,
msg.sender,
VAR66,
VAR78,
VAR99.VAR87.FUN9(VAR93),
0
);
VAR89 = VAR89.FUN9(1);
emit FUN51(VAR75, VAR66);
}
function FUN70(address VAR75) external FUN64(VAR75) FUN59(VAR75) {
FUN71(VAR75);
}
function FUN72() external {
if (VAR100.VAR87 == 0) {
require(msg.sender == VAR3, "");
}
require(VAR112.VAR113 >= VAR99.VAR87.FUN9(VAR93), "");
uint256 VAR86 = uint256(FUN68(VAR112.VAR113 - 1));
VAR100 = VAR99;
VAR99 = FUN67({
VAR86: VAR86,
VAR87: VAR112.VAR113
});
VAR90 = VAR88;
VAR88 = VAR89;
if (VAR95 != VAR91) {
VAR91 = VAR95;
emit FUN55(VAR91, VAR95);
}
if (VAR96 != VAR92) {
VAR92 = VAR96;
emit FUN56(VAR92, VAR96);
}
if (VAR97 != VAR93) {
VAR93 = VAR97;
emit FUN57(VAR93, VAR97);
}
if (VAR98 != VAR94) {
VAR94 = VAR98;
emit FUN58(VAR94, VAR98);
}
emit FUN54();
}
function FUN73(address VAR7) external onlyOwner {
VAR101.FUN4(VAR7);
}
function FUN74() external onlyOwner {
VAR101.FUN29();
}
function FUN75(uint256 VAR114) external onlyOwner {
VAR95 = VAR114;
}
function FUN76(uint256 VAR115) external onlyOwner {
VAR96 = VAR115;
}
function FUN77(uint256 VAR116) external onlyOwner {
VAR97 = VAR116;
}
function FUN78(address VAR117) external onlyOwner {
require(VAR117 != 0x0, "");
VAR98 = VAR117;
}
function FUN79(address VAR118, address VAR119, address VAR120)
external
VAR121
{
uint256 VAR122 = VAR101.FUN47(VAR118) / 2;
uint256 VAR123 = VAR122 / 4;
VAR101.FUN44(VAR118, VAR122);
if (FUN65(VAR118)) {
FUN71(VAR118);
}
require(VAR72.transfer(VAR101.FUN46(VAR119), VAR123), "");
require(VAR72.transfer(VAR101.FUN46(VAR120), VAR123), "");
}
function FUN80(address VAR75) external FUN62(VAR75) {
address VAR124 = VAR101.FUN46(VAR75);
uint256 VAR44 = VAR101.FUN47(VAR75);
VAR101.FUN43(VAR75);
require(VAR72.transfer(VAR124, VAR44), "");
emit FUN53(VAR124, VAR44);
}
function FUN81(address VAR75) external view returns (address) {
return VAR101.FUN46(VAR75);
}
function FUN82(address VAR75) external view returns (uint256) {
return VAR101.FUN47(VAR75);
}
function FUN83(address VAR75) external view returns (bytes) {
return VAR101.FUN50(VAR75);
}
function FUN84(address VAR125, uint256 VAR126) external view returns (address[]) {
uint256 VAR127 = VAR126;
if (VAR127 == 0) {
VAR127 = VAR88;
}
return FUN85(VAR125, VAR127, false);
}
function FUN86(address VAR125, uint256 VAR126) external view returns (address[]) {
uint256 VAR127 = VAR126;
if (VAR127 == 0) {
VAR127 = VAR90;
}
return FUN85(VAR125, VAR127, true);
}
function FUN87(address VAR75) external view returns (bool) {
uint256 VAR67 = VAR101.FUN48(VAR75);
return VAR67 != 0 && VAR67 > VAR99.VAR87;
}
function FUN88(address VAR75) external view returns (bool) {
uint256 VAR68 = VAR101.FUN49(VAR75);
return VAR68 != 0 && VAR68 > VAR99.VAR87;
}
function FUN89(address VAR75) public view returns (bool) {
uint256 VAR68 = VAR101.FUN49(VAR75);
return VAR68 != 0 && VAR68 <= VAR99.VAR87;
}
function FUN65(address VAR75) public view returns (bool) {
uint256 VAR68 = VAR101.FUN49(VAR75);
return FUN90(VAR75) && VAR68 == 0;
}
function FUN61(address VAR75) public view returns (bool) {
uint256 VAR67 = VAR101.FUN48(VAR75);
uint256 VAR68 = VAR101.FUN49(VAR75);
return VAR67 == 0 && VAR68 == 0;
}
function FUN63(address VAR75) public view returns (bool) {
return FUN89(VAR75) && VAR101.FUN49(VAR75) <= VAR100.VAR87;
}
function FUN90(address VAR75) public view returns (bool) {
return FUN91(VAR75, VAR99);
}
function FUN92(address VAR75) public view returns (bool) {
return FUN91(VAR75, VAR100);
}
function FUN91(address VAR75, Epoch VAR128) private view returns (bool) {
uint256 VAR67 = VAR101.FUN48(VAR75);
uint256 VAR68 = VAR101.FUN49(VAR75);
bool VAR129 = VAR67 != 0 && VAR67 <= VAR128.VAR87;
bool VAR130 = VAR68 == 0 || VAR68 > VAR128.VAR87;
return VAR129 && VAR130;
}
function FUN85(address VAR125, uint256 VAR126, bool VAR131) private view returns (address[]) {
uint256 VAR127 = VAR126;
if (VAR127 == 0) {
VAR127 = VAR88;
}
address[] memory VAR132 = new address[](VAR127);
uint256 VAR57 = 0;
address VAR50 = VAR125;
if (VAR50 == 0x0) {
VAR50 = VAR101.FUN35();
}
while (VAR57 < VAR127) {
if (VAR50 == 0x0) {
break;
}
bool VAR133;
if (VAR131) {
VAR133 = FUN92(VAR50);
} else {
VAR133 = FUN90(VAR50);
}
if (!VAR133) {
VAR50 = VAR101.FUN39(VAR50);
continue;
}
VAR132[VAR57] = VAR50;
VAR50 = VAR101.FUN39(VAR50);
VAR57 += 1;
}
return VAR132;
}
function FUN71(address VAR75) private {
VAR101.FUN45(VAR75, VAR99.VAR87.FUN9(VAR93));
VAR89 = VAR89.FUN8(1);
emit FUN52(VAR75);
}
}
interface VAR134 {
function FUN93(
address VAR135,
bytes VAR136,
bytes32 VAR137
) external returns (bool);
}
interface VAR138 {
function FUN94(
bytes VAR139,
uint64 VAR140,
uint64 VAR141,
uint256 VAR142,
uint256 VAR143,
uint256 VAR144
) external;
function FUN95() external view returns (uint256);
function FUN96(
bytes32 VAR145,
bytes32 VAR146
) external;
function FUN97(bytes32 VAR137) external view returns (uint8);
}
contract SettlementRegistry is VAR2 {
string public VAR64;
struct VAR147 {
bool VAR129;
Settlement VAR148;
BrokerVerifier VAR149;
}
mapping(VAR150 => VAR147) public VAR151;
event FUN98(uint64 VAR152, Settlement VAR148, BrokerVerifier VAR149);
event FUN99(uint64 VAR152, Settlement VAR148, BrokerVerifier VAR149);
event FUN100(uint64 VAR152);
constructor(string VAR73) public {
VAR64 = VAR73;
}
function FUN101(uint64 VAR140) external view returns (bool) {
return VAR151[VAR140].VAR129;
}
function FUN102(uint64 VAR140) external view returns (VAR138) {
return VAR151[VAR140].VAR148;
}
function FUN103(uint64 VAR140) external view returns (VAR134) {
return VAR151[VAR140].VAR149;
}
function FUN104(uint64 VAR140, Settlement VAR153, BrokerVerifier VAR154) public onlyOwner {
bool VAR155 = VAR151[VAR140].VAR129;
VAR151[VAR140] = FUN105({
VAR129: true,
VAR148: VAR153,
VAR149: VAR154
});
if (VAR155) {
emit FUN99(VAR140, VAR153, VAR154);
} else {
emit FUN98(VAR140, VAR153, VAR154);
}
}
function FUN106(uint64 VAR140) external onlyOwner {
require(VAR151[VAR140].VAR129, "");
delete VAR151[VAR140];
emit FUN100(VAR140);
}
}
library VAR156 {
function FUN107(bytes32 VAR157, bytes VAR158)
internal
pure
returns (address)
{
bytes32 VAR159;
bytes32 VAR160;
uint8 VAR161;
if (VAR158.VAR162 != 65) {
return (address(0));
}
VAR163 {
VAR159 := FUN108(FUN9(VAR158, 32))
VAR160 := FUN108(FUN9(VAR158, 64))
VAR161 := FUN109(0, FUN108(FUN9(VAR158, 96)))
}
if (VAR161 < 27) {
VAR161 += 27;
}
if (VAR161 != 27 && VAR161 != 28) {
return (address(0));
} else {
return FUN110(VAR157, VAR161, VAR159, VAR160);
}
}
function FUN111(bytes32 VAR157)
internal
pure
returns (bytes32)
{
return FUN112(
VAR164.FUN113("", VAR157)
);
}
}
library VAR165 {
function FUN114(uint256 VAR166) internal pure returns (bytes) {
uint256 VAR161 = VAR166;
if (VAR161 == 0) {
return "";
}
uint256 VAR167 = 0;
uint256 VAR168 = VAR161;
while (VAR168 > 0) {
VAR168 /= 10;
VAR167 += 1;
}
bytes memory VAR169 = VAR170 bytes(VAR167);
for (uint256 VAR171 = 0; VAR171 < VAR167; VAR171++) {
VAR169[VAR167 - VAR171 - 1] = FUN115((VAR161 % 10) + 48);
VAR161 /= 10;
}
return VAR169;
}
function FUN116(bytes VAR172, bytes VAR136) internal pure returns (address) {
bytes memory VAR173 = "";
bytes memory VAR174 = VAR164.FUN113(VAR173, FUN114(VAR172.VAR162), VAR172);
bytes32 VAR175 = FUN112(VAR174);
return VAR156.FUN107(VAR175, VAR136);
}
}
contract Orderbook is VAR2 {
using SafeMath for uint256;
string public VAR64;
enum VAR176 {VAR177, VAR178, VAR179, VAR180}
struct VAR181 {
OrderState VAR182;
address VAR183;
address VAR184;
uint64 VAR152;
uint256 VAR185;
uint256 VAR186;
bytes32 VAR187;
}
DarknodeRegistry public VAR70;
SettlementRegistry public VAR188;
bytes32[] private VAR189;
mapping(bytes32 => VAR181) public VAR190;
event FUN117(uint256 VAR191, uint256 VAR192);
event FUN118(DarknodeRegistry VAR193, DarknodeRegistry VAR194);
modifier FUN119(address VAR195) {
require(VAR70.FUN90(VAR195), "");
VAR6;
}
constructor(
string VAR73,
DarknodeRegistry VAR196,
SettlementRegistry VAR197
) public {
VAR64 = VAR73;
VAR70 = VAR196;
VAR188 = VAR197;
}
function FUN120(DarknodeRegistry VAR198) external onlyOwner {
require(bytes(VAR198.FUN121()).VAR162 > 0, "");
emit FUN118(VAR70, VAR198);
VAR70 = VAR198;
}
function FUN122(uint64 VAR140, bytes VAR136, bytes32 VAR137) external {
require(VAR190[VAR137].VAR182 == VAR176.VAR177, "");
address VAR183 = msg.sender;
require(VAR188.FUN101(VAR140), "");
BrokerVerifier VAR199 = VAR188.FUN103(VAR140);
require(VAR199.FUN93(VAR183, VAR136, VAR137), "");
VAR190[VAR137] = FUN123({
VAR182: VAR176.VAR178,
VAR183: VAR183,
VAR184: 0x0,
VAR152: VAR140,
VAR185: VAR189.VAR162 + 1,
VAR186: VAR112.VAR113,
VAR187: 0x0
});
VAR189.FUN124(VAR137);
}
function FUN125(bytes32 VAR137, bytes32 VAR200) external FUN119(msg.sender) {
require(VAR190[VAR137].VAR182 == VAR176.VAR178, "");
require(VAR190[VAR200].VAR182 == VAR176.VAR178, "");
VAR190[VAR137].VAR182 = VAR176.VAR179;
VAR190[VAR137].VAR184 = msg.sender;
VAR190[VAR137].VAR187 = VAR200;
VAR190[VAR137].VAR186 = VAR112.VAR113;
VAR190[VAR200].VAR182 = VAR176.VAR179;
VAR190[VAR200].VAR184 = msg.sender;
VAR190[VAR200].VAR187 = VAR137;
VAR190[VAR200].VAR186 = VAR112.VAR113;
}
function FUN126(bytes32 VAR137) external {
require(VAR190[VAR137].VAR182 == VAR176.VAR178, "");
address VAR199 = VAR188.FUN103(VAR190[VAR137].VAR152);
require(msg.sender == VAR190[VAR137].VAR183 || msg.sender == VAR199, "");
VAR190[VAR137].VAR182 = VAR176.VAR180;
VAR190[VAR137].VAR186 = VAR112.VAR113;
}
function FUN127(bytes32 VAR137) external view returns (VAR176) {
return VAR190[VAR137].VAR182;
}
function FUN128(bytes32 VAR137) external view returns (bytes32) {
return VAR190[VAR137].VAR187;
}
function FUN129(bytes32 VAR137) external view returns (uint256) {
return VAR190[VAR137].VAR185;
}
function FUN130(bytes32 VAR137) external view returns (address) {
return VAR190[VAR137].VAR183;
}
function FUN131(bytes32 VAR137) external view returns (address) {
return VAR190[VAR137].VAR184;
}
function FUN132(bytes32 VAR137) external view returns (uint256) {
return VAR190[VAR137].VAR186;
}
function FUN133(bytes32 VAR137) external view returns (uint256) {
if (VAR190[VAR137].VAR186 == 0) {
return 0;
}
return (VAR112.VAR113.FUN8(VAR190[VAR137].VAR186));
}
function FUN134() external view returns (uint256) {
return VAR189.VAR162;
}
function FUN135(uint256 VAR201, uint256 VAR202) external view returns (bytes32[], address[], uint8[]) {
if (VAR201 >= VAR189.VAR162) {
return;
}
uint256 VAR203 = VAR202;
if (VAR201.FUN9(VAR203) > VAR189.VAR162) {
VAR203 = VAR189.VAR162 - VAR201;
}
bytes32[] memory VAR204 = new bytes32[](VAR203);
address[] memory VAR205 = new address[](VAR203);
uint8[] memory VAR206 = new uint8[](VAR203);
for (uint256 VAR171 = 0; VAR171 < VAR203; VAR171++) {
bytes32 VAR207 = VAR189[VAR171 + VAR201];
VAR204[VAR171] = VAR207;
VAR205[VAR171] = VAR190[VAR207].VAR183;
VAR206[VAR171] = uint8(VAR190[VAR207].VAR182);
}
return (VAR204, VAR205, VAR206);
}
}
library VAR208 {
struct VAR209 {
uint64 VAR152;
uint64 VAR210;
uint256 VAR211;
uint256 VAR212;
uint256 VAR213;
}
function FUN136(bytes VAR214, OrderDetails memory VAR207) internal pure returns (bytes32) {
return FUN112(
VAR164.FUN113(
VAR214,
VAR207.VAR152,
VAR207.VAR210,
VAR207.VAR211,
VAR207.VAR212,
VAR207.VAR213
)
);
}
function FUN137(OrderDetails memory VAR215, OrderDetails memory VAR216) internal pure returns (bool) {
if (!FUN138(VAR215.VAR210, VAR216.VAR210)) {
return false;
}
if (VAR215.VAR211 < VAR216.VAR211) {
return false;
}
if (VAR215.VAR212 < VAR216.VAR213) {
return false;
}
if (VAR216.VAR212 < VAR215.VAR213) {
return false;
}
if (VAR215.VAR152 != VAR216.VAR152) {
return false;
}
return true;
}
function FUN138(uint64 VAR217, uint64 VAR218) internal pure returns (bool) {
return ((
FUN139(VAR217) == FUN139(VAR218 >> 32)) && (
FUN139(VAR218) == FUN139(VAR217 >> 32)) && (
FUN139(VAR217 >> 32) <= FUN139(VAR217))
);
}
}
library VAR219 {
function FUN140(uint64 VAR9, uint64 VAR10) internal pure returns (VAR150) {
return VAR9 >= VAR10 ? VAR9 : VAR10;
}
function FUN141(uint64 VAR9, uint64 VAR10) internal pure returns (VAR150) {
return VAR9 < VAR10 ? VAR9 : VAR10;
}
function FUN142(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
return VAR9 >= VAR10 ? VAR9 : VAR10;
}
function FUN143(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
return VAR9 < VAR10 ? VAR9 : VAR10;
}
}
library VAR220 {
using SafeMath for uint256;
function FUN144(address VAR221, address VAR14, uint256 VAR44) internal {
FUN145(VAR221).transfer(VAR14, VAR44);
require(FUN146(), "");
}
function FUN147(address VAR221, address VAR15, address VAR14, uint256 VAR44) internal {
FUN145(VAR221).FUN13(VAR15, VAR14, VAR44);
require(FUN146(), "");
}
function FUN148(address VAR221, address VAR21, uint256 VAR44) internal {
FUN145(VAR221).FUN14(VAR21, VAR44);
require(FUN146(), "");
}
function FUN149(address VAR221, address VAR15, address VAR14, uint256 VAR44) internal returns (uint256) {
uint256 VAR222 = FUN145(VAR221).FUN11(VAR14);
FUN145(VAR221).FUN13(VAR15, VAR14, VAR44);
require(FUN146(), "");
uint256 VAR223 = FUN145(VAR221).FUN11(VAR14);
return VAR219.FUN143(VAR44, VAR223.FUN8(VAR222));
}
function FUN146() private pure returns (bool)
{
uint256 VAR224 = 0;
VAR163 {
switch VAR225
case 0 {
VAR224 := 1
}
case 32 {
FUN150(0, 0, 32)
VAR224 := FUN108(0)
}
default { }
}
return VAR224 != 0;
}
}
interface VAR226 {
function transfer(address VAR14, uint256 value) external;
function FUN13(address VAR15, address VAR14, uint256 value) external;
function FUN14(address VAR21, uint256 value) external;
function FUN10() external view returns (uint256);
function FUN11(address VAR13) external view returns (uint256);
function FUN12(address VAR3, address VAR21) external view returns (uint256);
event Transfer(address indexed VAR15, address indexed VAR14, uint256 value);
event FUN15(address indexed VAR3, address indexed VAR21, uint256 value);
}
contract DarknodeRewardVault is VAR2 {
using SafeMath for uint256;
using CompatibleERC20Functions for VAR226;
string public VAR64;
address constant public VAR227 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
DarknodeRegistry public VAR70;
mapping(address => mapping(address => uint256)) public VAR228;
event FUN118(DarknodeRegistry VAR193, DarknodeRegistry VAR194);
constructor(string VAR73, DarknodeRegistry VAR196) public {
VAR64 = VAR73;
VAR70 = VAR196;
}
function FUN120(DarknodeRegistry VAR198) public onlyOwner {
require(bytes(VAR198.FUN121()).VAR162 > 0, "");
emit FUN118(VAR70, VAR198);
VAR70 = VAR198;
}
function FUN151(address VAR229, ERC20 VAR230, uint256 VAR19) public payable {
uint256 VAR231 = VAR19;
if (VAR230 == VAR227) {
require(msg.value == VAR19, "");
} else {
require(msg.value == 0, "");
VAR231 = FUN145(VAR230).FUN149(msg.sender, this, VAR19);
}
VAR228[VAR229][VAR230] = VAR228[VAR229][VAR230].FUN9(VAR231);
}
function FUN152(address VAR229, ERC20 VAR230) public {
address VAR124 = VAR70.FUN81(VAR229);
require(VAR124 != 0x0, "");
uint256 value = VAR228[VAR229][VAR230];
VAR228[VAR229][VAR230] = 0;
if (VAR230 == VAR227) {
VAR124.transfer(value);
} else {
FUN145(VAR230).FUN144(VAR124, value);
}
}
}
contract RenExTokens is VAR2 {
string public VAR64;
struct VAR232 {
address VAR233;
uint8 VAR41;
bool VAR129;
}
mapping(VAR234 => VAR232) public VAR210;
mapping(VAR234 => bool) private VAR235;
event FUN153(uint32 VAR236, address VAR237, uint8 VAR238);
event FUN154(uint32 VAR236);
constructor(string VAR73) public {
VAR64 = VAR73;
}
function FUN155(uint32 VAR239, address VAR240, uint8 VAR241) public onlyOwner {
require(!VAR210[VAR239].VAR129, "");
if (VAR235[VAR239]) {
require(VAR210[VAR239].VAR233 == VAR240, "");
require(VAR210[VAR239].VAR41 == VAR241, "");
} else {
VAR235[VAR239] = true;
}
VAR210[VAR239] = FUN156({
VAR233: VAR240,
VAR41: VAR241,
VAR129: true
});
emit FUN153(VAR239, VAR240, VAR241);
}
function FUN157(uint32 VAR239) external onlyOwner {
require(VAR210[VAR239].VAR129, "");
VAR210[VAR239].VAR129 = false;
emit FUN154(VAR239);
}
}
contract RenExSettlement is VAR2 {
using SafeMath for uint256;
string public VAR64;
uint256 constant public VAR242 = 2;
uint256 constant public VAR243 = 1000;
uint32 constant public VAR244 = 1;
uint32 constant public VAR245 = 2;
int16 constant private VAR246 = 12;
int16 constant private VAR247 = 12;
Orderbook public VAR248;
RenExTokens public VAR249;
RenExBalances public VAR250;
address public VAR251;
uint256 public VAR252;
enum VAR253 {VAR254, VAR255, VAR256, VAR257}
struct VAR258 {
VAR259.TokenDetails VAR260;
VAR259.TokenDetails VAR261;
}
struct VAR262 {
uint256 value;
uint256 VAR263;
}
struct VAR264 {
uint256 VAR265;
uint256 VAR266;
}
struct VAR147 {
uint256 VAR267;
uint256 VAR268;
uint256 VAR269;
uint256 VAR270;
address VAR271;
address VAR272;
}
event FUN158(Orderbook VAR273, Orderbook VAR274);
event FUN159(RenExTokens VAR275, RenExTokens VAR276);
event FUN160(RenExBalances VAR277, RenExBalances VAR278);
event FUN161(uint256 VAR279, uint256 VAR280);
event FUN58(address VAR106, address VAR98);
mapping(bytes32 => VAR208.VAR209) public VAR281;
mapping(bytes32 => address) public VAR282;
mapping(bytes32 => VAR253) public VAR283;
mapping(bytes32 => mapping(bytes32 => uint256)) public VAR284;
modifier FUN162(uint256 VAR285) {
require(VAR286.VAR287 <= VAR285, "");
VAR6;
}
modifier FUN66() {
require(msg.sender == VAR251, "");
VAR6;
}
constructor(
string VAR73,
Orderbook VAR288,
RenExTokens VAR289,
RenExBalances VAR290,
address VAR291,
uint256 VAR292
) public {
VAR64 = VAR73;
VAR248 = VAR288;
VAR249 = VAR289;
VAR250 = VAR290;
VAR251 = VAR291;
VAR252 = VAR292;
}
function FUN163(Orderbook VAR293) external onlyOwner {
require(bytes(VAR293.FUN121()).VAR162 > 0, "");
emit FUN158(VAR248, VAR293);
VAR248 = VAR293;
}
function FUN164(RenExTokens VAR294) external onlyOwner {
require(bytes(VAR294.FUN121()).VAR162 > 0, "");
emit FUN159(VAR249, VAR294);
VAR249 = VAR294;
}
function FUN165(RenExBalances VAR295) external onlyOwner {
require(bytes(VAR295.FUN121()).VAR162 > 0, "");
emit FUN160(VAR250, VAR295);
VAR250 = VAR295;
}
function FUN166(uint256 VAR296) external onlyOwner {
require(VAR296 >= 100000000, "");
emit FUN161(VAR252, VAR296);
VAR252 = VAR296;
}
function FUN78(address VAR297) external onlyOwner {
require(VAR297 != 0x0, "");
emit FUN58(VAR251, VAR297);
VAR251 = VAR297;
}
function FUN94(
bytes VAR298,
uint64 VAR140,
uint64 VAR141,
uint256 VAR142,
uint256 VAR143,
uint256 VAR144
) external FUN162(VAR252) {
VAR208.OrderDetails memory VAR207 = VAR208.FUN167({
VAR152: VAR140,
VAR210: VAR141,
VAR211: VAR142,
VAR212: VAR143,
VAR213: VAR144
});
bytes32 VAR299 = VAR208.FUN136(VAR298, VAR207);
require(VAR283[VAR299] == VAR253.VAR254, "");
require(VAR248.FUN127(VAR299) == VAR300.VAR176.VAR179, "");
VAR282[VAR299] = msg.sender;
VAR283[VAR299] = VAR253.VAR255;
VAR281[VAR299] = VAR207;
}
function FUN96(bytes32 VAR145, bytes32 VAR146) external {
require(VAR283[VAR145] == VAR253.VAR255, "");
require(VAR283[VAR146] == VAR253.VAR255, "");
require(
VAR281[VAR145].VAR152 == VAR245 ||
VAR281[VAR145].VAR152 == VAR244,
""
);
require(VAR208.FUN137(VAR281[VAR145], VAR281[VAR146]), "");
require(VAR248.FUN128(VAR145) == VAR146, "");
TokenPair memory VAR210 = FUN168(VAR281[VAR145].VAR210);
require(VAR210.VAR260.VAR129, "");
require(VAR210.VAR261.VAR129, "");
address VAR301 = VAR248.FUN130(VAR145);
address VAR302 = VAR248.FUN130(VAR146);
require(VAR301 != VAR302, "");
FUN169(VAR145, VAR146, VAR301, VAR302, VAR210);
VAR284[VAR145][VAR146] = VAR303;
VAR283[VAR145] = VAR253.VAR256;
VAR283[VAR146] = VAR253.VAR256;
}
function FUN79(bytes32 VAR304) external VAR121 {
require(VAR281[VAR304].VAR152 == VAR245, "");
bytes32 VAR305 = VAR248.FUN128(VAR304);
require(VAR283[VAR304] == VAR253.VAR256, "");
require(VAR283[VAR305] == VAR253.VAR256, "");
VAR283[VAR304] = VAR253.VAR257;
(bytes32 VAR306, bytes32 VAR307) = FUN170(VAR304) ?
(VAR304, VAR305) : (VAR305, VAR304);
TokenPair memory VAR210 = FUN168(VAR281[VAR306].VAR210);
SettlementDetails memory VAR151 = FUN171(VAR306, VAR307, VAR210);
VAR250.FUN172(
VAR248.FUN130(VAR304),
VAR248.FUN130(VAR305),
VAR151.VAR271,
VAR151.VAR269,
0,
0x0
);
VAR250.FUN172(
VAR248.FUN130(VAR304),
VAR251,
VAR151.VAR271,
VAR151.VAR269,
0,
0x0
);
}
function FUN173(bytes32 VAR137)
external view returns (
bool VAR308,
bool VAR309,
bytes32 VAR310,
uint256 VAR311,
uint256 VAR312,
uint256 VAR313,
uint256 VAR314,
uint32 VAR260,
uint32 VAR261
) {
VAR310 = VAR248.FUN128(VAR137);
VAR309 = FUN170(VAR137);
(bytes32 VAR306, bytes32 VAR307) = VAR309 ?
(VAR137, VAR310) : (VAR310, VAR137);
SettlementDetails memory VAR151 = FUN174(
VAR306,
VAR307,
FUN168(VAR281[VAR306].VAR210)
);
return (
VAR283[VAR137] == VAR253.VAR256 || VAR283[VAR137] == VAR253.VAR257,
VAR309,
VAR310,
VAR151.VAR267,
VAR151.VAR268,
VAR151.VAR269,
VAR151.VAR270,
FUN139(VAR281[VAR306].VAR210 >> 32),
FUN139(VAR281[VAR306].VAR210)
);
}
function FUN136(
bytes VAR298,
uint64 VAR140,
uint64 VAR141,
uint256 VAR142,
uint256 VAR143,
uint256 VAR144
) external pure returns (bytes32) {
return VAR208.FUN136(VAR298, VAR208.FUN167({
VAR152: VAR140,
VAR210: VAR141,
VAR211: VAR142,
VAR212: VAR143,
VAR213: VAR144
}));
}
function FUN169(
bytes32 VAR145,
bytes32 VAR146,
address VAR315,
address VAR316,
TokenPair memory VAR141
) private {
SettlementDetails memory VAR151 = (VAR281[VAR145].VAR152 == VAR245) ?
VAR151 = FUN171(VAR145, VAR146, VAR141) :
VAR151 = FUN174(VAR145, VAR146, VAR141);
VAR250.FUN172(
VAR315,
VAR316,
VAR151.VAR271,
VAR151.VAR267,
VAR151.VAR269,
VAR282[VAR145]
);
VAR250.FUN172(
VAR316,
VAR315,
VAR151.VAR272,
VAR151.VAR268,
VAR151.VAR270,
VAR282[VAR146]
);
}
function FUN174(
bytes32 VAR145,
bytes32 VAR146,
TokenPair memory VAR141
) private view returns (SettlementDetails VAR317) {
Fraction memory VAR318 = FUN175(VAR281[VAR145].VAR211.FUN9(VAR281[VAR146].VAR211), 2);
uint256 VAR319 = VAR219.FUN143(VAR281[VAR145].VAR212, VAR281[VAR146].VAR212);
uint256 VAR320 = FUN176(
VAR319.FUN6(VAR318.VAR265),
VAR318.VAR266,
FUN177(VAR141.VAR260.VAR41) - VAR246 - VAR247
);
uint256 VAR321 = FUN176(
VAR319,
1,
FUN177(VAR141.VAR261.VAR41) - VAR247
);
ValueWithFees memory VAR322 = FUN178(VAR320);
ValueWithFees memory VAR323 = FUN178(VAR321);
return FUN105({
VAR267: VAR322.value,
VAR268: VAR323.value,
VAR269: VAR322.VAR263,
VAR270: VAR323.VAR263,
VAR271: VAR141.VAR260.VAR233,
VAR272: VAR141.VAR261.VAR233
});
}
function FUN171(
bytes32 VAR145,
bytes32 VAR146,
TokenPair memory VAR141
) private view returns (SettlementDetails VAR317) {
Fraction memory VAR318 = FUN175(VAR281[VAR145].VAR211.FUN9(VAR281[VAR146].VAR211), 2);
uint256 VAR319 = VAR219.FUN143(VAR281[VAR145].VAR212, VAR281[VAR146].VAR212);
if (FUN179(VAR141.VAR261.VAR233)) {
uint256 VAR321 = FUN176(
VAR319,
1,
FUN177(VAR141.VAR261.VAR41) - VAR247
);
ValueWithFees memory VAR323 = FUN178(VAR321);
return FUN105({
VAR267: 0,
VAR268: 0,
VAR269: VAR323.VAR263,
VAR270: VAR323.VAR263,
VAR271: VAR141.VAR261.VAR233,
VAR272: VAR141.VAR261.VAR233
});
} else if (FUN179(VAR141.VAR260.VAR233)) {
uint256 VAR320 = FUN176(
VAR319.FUN6(VAR318.VAR265),
VAR318.VAR266,
FUN177(VAR141.VAR260.VAR41) - VAR246 - VAR247
);
ValueWithFees memory VAR322 = FUN178(VAR320);
return FUN105({
VAR267: 0,
VAR268: 0,
VAR269: VAR322.VAR263,
VAR270: VAR322.VAR263,
VAR271: VAR141.VAR260.VAR233,
VAR272: VAR141.VAR260.VAR233
});
} else {
revert("");
}
}
function FUN170(bytes32 VAR137) private view returns (bool) {
uint64 VAR210 = VAR281[VAR137].VAR210;
uint32 VAR324 = FUN139(VAR210 >> 32);
uint32 VAR261 = FUN139(VAR210);
return (VAR324 < VAR261);
}
function FUN178(uint256 VAR19) private pure returns (ValueWithFees VAR317) {
uint256 VAR325 = (VAR19.FUN6(VAR243 - VAR242)) / VAR243;
return FUN180(VAR325, VAR19.FUN8(VAR325));
}
function FUN168(uint64 VAR141) private view returns (TokenPair VAR317) {
(
address VAR326,
uint8 VAR327,
bool VAR328
) = VAR249.FUN181(FUN139(VAR141 >> 32));
(
address VAR329,
uint8 VAR330,
bool VAR331
) = VAR249.FUN181(FUN139(VAR141));
return FUN182({
VAR260: VAR259.FUN156(VAR326, VAR327, VAR328),
VAR261: VAR259.FUN156(VAR329, VAR330, VAR331)
});
}
function FUN179(address VAR240) private pure returns (bool) {
return (VAR240 != 0x0);
}
function FUN176(uint256 VAR332, uint256 VAR333, int16 VAR334) private pure returns (uint256) {
if (VAR334 >= 0) {
assert(VAR334 <= 77);
return VAR332.FUN6(10 ** uint256(VAR334)) / VAR333;
} else {
return (VAR332 / VAR333) / 10 ** uint256(-VAR334);
}
}
}
contract RenExBrokerVerifier is VAR2 {
string public VAR64;
event FUN183(address VAR335, address VAR336);
event FUN184(address VAR337);
event FUN185(address VAR337);
mapping(address => bool) public VAR338;
mapping(address => mapping(address => uint256)) public VAR339;
address public VAR340;
modifier FUN186() {
require(msg.sender == VAR340, "");
VAR6;
}
constructor(string VAR73) public {
VAR64 = VAR73;
}
function FUN187(address VAR341) external onlyOwner {
require(VAR341 != 0x0, "");
emit FUN183(VAR340, VAR341);
VAR340 = VAR341;
}
function FUN188(address VAR342) external onlyOwner {
require(!VAR338[VAR342], "");
VAR338[VAR342] = true;
emit FUN184(VAR342);
}
function FUN189(address VAR342) external onlyOwner {
require(VAR338[VAR342], "");
VAR338[VAR342] = false;
emit FUN185(VAR342);
}
function FUN93(
address VAR135,
bytes VAR136,
bytes32 VAR137
) external view returns (bool) {
bytes memory VAR343 = VAR164.FUN113("", VAR135, VAR137);
address VAR344 = VAR165.FUN116(VAR343, VAR136);
return (VAR338[VAR344] == true);
}
function FUN190(
address VAR135,
address VAR230,
bytes VAR136
) external onlyBalancesContract returns (bool) {
bytes memory VAR343 = VAR164.FUN113(
"",
VAR135,
VAR230,
VAR339[VAR135][VAR230]
);
address VAR344 = VAR165.FUN116(VAR343, VAR136);
if (VAR338[VAR344]) {
VAR339[VAR135][VAR230] += 1;
return true;
}
return false;
}
}
contract RenExBalances is VAR2 {
using SafeMath for uint256;
using CompatibleERC20Functions for VAR226;
string public VAR64;
RenExSettlement public VAR148;
RenExBrokerVerifier public VAR149;
DarknodeRewardVault public VAR345;
address constant public VAR227 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
uint256 constant public VAR346 = 48 VAR347;
event FUN191(address VAR183, ERC20 VAR221, uint256 value);
event FUN192(address VAR183, ERC20 VAR221, uint256 value);
event FUN193(address VAR348, address VAR349);
event FUN194(address VAR350, address VAR351);
event FUN195(address VAR352, address VAR353);
mapping(address => mapping(address => uint256)) public VAR354;
mapping(address => mapping(address => uint256)) public VAR355;
constructor(
string VAR73,
DarknodeRewardVault VAR356,
RenExBrokerVerifier VAR154
) public {
VAR64 = VAR73;
VAR345 = VAR356;
VAR149 = VAR154;
}
modifier FUN196() {
require(msg.sender == address(VAR148), "");
VAR6;
}
modifier FUN197(address VAR230, bytes VAR136) {
address VAR183 = msg.sender;
if (VAR136.VAR162 > 0) {
require (VAR149.FUN190(VAR183, VAR230, VAR136), "");
} else  {
require(VAR355[VAR183][VAR230] != 0, "");
require((VAR303 - VAR355[VAR183][VAR230]) > VAR346, "");
VAR355[VAR183][VAR230] = 0;
}
VAR6;
}
function FUN198(RenExSettlement VAR357) external onlyOwner {
require(bytes(VAR357.FUN121()).VAR162 > 0, "");
emit FUN193(VAR148, VAR357);
VAR148 = VAR357;
}
function FUN199(DarknodeRewardVault VAR358) external onlyOwner {
require(bytes(VAR358.FUN121()).VAR162 > 0, "");
emit FUN194(VAR345, VAR358);
VAR345 = VAR358;
}
function FUN200(RenExBrokerVerifier VAR359) external onlyOwner {
require(bytes(VAR359.FUN121()).VAR162 > 0, "");
emit FUN195(VAR149, VAR359);
VAR149 = VAR359;
}
function FUN172(address VAR360, address VAR361, address VAR230, uint256 VAR19, uint256 VAR362, address VAR363)
external VAR364 {
require(VAR354[VAR360][VAR230] >= VAR362, "");
FUN201(VAR360, FUN202(VAR230), VAR19.FUN9(VAR362));
if (VAR230 == VAR227) {
VAR345.VAR365.value(VAR362)(VAR363, FUN202(VAR230), VAR362);
} else {
FUN145(VAR230).FUN148(VAR345, VAR362);
VAR345.FUN151(VAR363, FUN202(VAR230), VAR362);
}
if (VAR19 > 0) {
FUN203(VAR361, FUN202(VAR230), VAR19);
}
}
function FUN151(ERC20 VAR230, uint256 VAR19) external payable {
address VAR183 = msg.sender;
uint256 VAR231 = VAR19;
if (VAR230 == VAR227) {
require(msg.value == VAR19, "");
} else {
require(msg.value == 0, "");
VAR231 = FUN145(VAR230).FUN149(VAR183, this, VAR19);
}
FUN203(VAR183, VAR230, VAR231);
}
function FUN152(ERC20 VAR230, uint256 VAR19, bytes VAR136) external FUN197(VAR230, VAR136) {
address VAR183 = msg.sender;
FUN201(VAR183, VAR230, VAR19);
if (VAR230 == VAR227) {
VAR183.transfer(VAR19);
} else {
FUN145(VAR230).FUN144(VAR183, VAR19);
}
}
function FUN204(address VAR230) external {
VAR355[msg.sender][VAR230] = VAR303;
}
function FUN203(address VAR135, ERC20 VAR230, uint256 VAR19) private {
VAR354[VAR135][VAR230] = VAR354[VAR135][VAR230].FUN9(VAR19);
emit FUN192(VAR135, VAR230, VAR19);
}
function FUN201(address VAR135, ERC20 VAR230, uint256 VAR19) private {
require(VAR354[VAR135][VAR230] >= VAR19, "");
VAR354[VAR135][VAR230] = VAR354[VAR135][VAR230].FUN8(VAR19);
emit FUN191(VAR135, VAR230, VAR19);
}
}
contract RenExSwapperdSettlement is VAR2 {
using SafeMath for uint256;
string public VAR64;
uint256 constant public VAR242 = 0;
uint256 constant public VAR243 = 1000;
uint32 constant public VAR366 = 3;
int16 constant private VAR246 = 12;
int16 constant private VAR247 = 12;
Orderbook public VAR248;
RenExTokens public VAR249;
RenExBalances public VAR250;
address public VAR251;
uint256 public VAR252;
enum VAR253 {VAR254, VAR255, VAR256, VAR257}
struct VAR258 {
VAR259.TokenDetails VAR260;
VAR259.TokenDetails VAR261;
}
struct VAR262 {
uint256 value;
uint256 VAR263;
}
struct VAR264 {
uint256 VAR265;
uint256 VAR266;
}
struct VAR147 {
uint256 VAR267;
uint256 VAR268;
uint256 VAR269;
uint256 VAR270;
address VAR271;
address VAR272;
}
event FUN158(Orderbook VAR273, Orderbook VAR274);
event FUN159(RenExTokens VAR275, RenExTokens VAR276);
event FUN160(RenExBalances VAR277, RenExBalances VAR278);
event FUN161(uint256 VAR279, uint256 VAR280);
event FUN58(address VAR106, address VAR98);
event FUN205(bytes32 indexed VAR299);
mapping(bytes32 => VAR208.VAR209) public VAR281;
mapping(bytes32 => address) public VAR282;
mapping(bytes32 => VAR253) public VAR283;
mapping(bytes32 => mapping(bytes32 => uint256)) public VAR284;
modifier FUN162(uint256 VAR285) {
require(VAR286.VAR287 <= VAR285, "");
VAR6;
}
modifier FUN66() {
require(msg.sender == VAR251, "");
VAR6;
}
constructor(
string VAR73,
Orderbook VAR288,
RenExTokens VAR289,
RenExBalances VAR290,
address VAR291,
uint256 VAR292
) public {
VAR64 = VAR73;
VAR248 = VAR288;
VAR249 = VAR289;
VAR250 = VAR290;
VAR251 = VAR291;
VAR252 = VAR292;
}
function FUN163(Orderbook VAR293) external onlyOwner {
require(bytes(VAR293.FUN121()).VAR162 > 0, "");
emit FUN158(VAR248, VAR293);
VAR248 = VAR293;
}
function FUN164(RenExTokens VAR294) external onlyOwner {
require(bytes(VAR294.FUN121()).VAR162 > 0, "");
emit FUN159(VAR249, VAR294);
VAR249 = VAR294;
}
function FUN165(RenExBalances VAR295) external onlyOwner {
require(bytes(VAR295.FUN121()).VAR162 > 0, "");
emit FUN160(VAR250, VAR295);
VAR250 = VAR295;
}
function FUN166(uint256 VAR296) external onlyOwner {
require(VAR296 >= 100000000, "");
emit FUN161(VAR252, VAR296);
VAR252 = VAR296;
}
function FUN78(address VAR297) external onlyOwner {
require(VAR297 != 0x0, "");
emit FUN58(VAR251, VAR297);
VAR251 = VAR297;
}
function FUN94(
bytes VAR298,
uint64 VAR140,
uint64 VAR141,
uint256 VAR142,
uint256 VAR143,
uint256 VAR144
) external FUN162(VAR252) {
VAR208.OrderDetails memory VAR207 = VAR208.FUN167({
VAR152: VAR140,
VAR210: VAR141,
VAR211: VAR142,
VAR212: VAR143,
VAR213: VAR144
});
bytes32 VAR299 = VAR208.FUN136(VAR298, VAR207);
require(VAR283[VAR299] == VAR253.VAR254, "");
require(VAR248.FUN127(VAR299) == VAR300.VAR176.VAR179, "");
VAR282[VAR299] = msg.sender;
VAR283[VAR299] = VAR253.VAR255;
VAR281[VAR299] = VAR207;
}
function FUN96(bytes32 VAR145, bytes32 VAR146) external {
require(VAR283[VAR145] == VAR253.VAR255, "");
require(VAR283[VAR146] == VAR253.VAR255, "");
require(
VAR281[VAR145].VAR152 == VAR366,
""
);
require(VAR208.FUN137(VAR281[VAR145], VAR281[VAR146]), "");
require(VAR248.FUN128(VAR145) == VAR146, "");
TokenPair memory VAR210 = FUN168(VAR281[VAR145].VAR210);
require(VAR210.VAR260.VAR129, "");
require(VAR210.VAR261.VAR129, "");
address VAR301 = VAR248.FUN130(VAR145);
address VAR302 = VAR248.FUN130(VAR146);
require(VAR301 != VAR302, "");
VAR284[VAR145][VAR146] = VAR303;
VAR283[VAR145] = VAR253.VAR256;
VAR283[VAR146] = VAR253.VAR256;
emit FUN205(VAR145);
emit FUN205(VAR146);
}
function FUN173(bytes32 VAR137)
external view returns (
bool VAR308,
bool VAR309,
bytes32 VAR310,
uint256 VAR311,
uint256 VAR312,
uint256 VAR313,
uint256 VAR314,
uint32 VAR260,
uint32 VAR261
) {
VAR310 = VAR248.FUN128(VAR137);
VAR309 = FUN170(VAR137);
(bytes32 VAR306, bytes32 VAR307) = VAR309 ?
(VAR137, VAR310) : (VAR310, VAR137);
SettlementDetails memory VAR151 = FUN174(
VAR306,
VAR307,
FUN168(VAR281[VAR306].VAR210)
);
return (
VAR283[VAR137] == VAR253.VAR256 || VAR283[VAR137] == VAR253.VAR257,
VAR309,
VAR310,
VAR151.VAR267,
VAR151.VAR268,
VAR151.VAR269,
VAR151.VAR270,
FUN139(VAR281[VAR306].VAR210 >> 32),
FUN139(VAR281[VAR306].VAR210)
);
}
function FUN136(
bytes VAR298,
uint64 VAR140,
uint64 VAR141,
uint256 VAR142,
uint256 VAR143,
uint256 VAR144
) external pure returns (bytes32) {
return VAR208.FUN136(VAR298, VAR208.FUN167({
VAR152: VAR140,
VAR210: VAR141,
VAR211: VAR142,
VAR212: VAR143,
VAR213: VAR144
}));
}
function FUN174(
bytes32 VAR145,
bytes32 VAR146,
TokenPair memory VAR141
) private view returns (SettlementDetails VAR317) {
Fraction memory VAR318 = FUN175(VAR281[VAR145].VAR211.FUN9(VAR281[VAR146].VAR211), 2);
uint256 VAR319 = VAR219.FUN143(VAR281[VAR145].VAR212, VAR281[VAR146].VAR212);
uint256 VAR320 = FUN176(
VAR319.FUN6(VAR318.VAR265),
VAR318.VAR266,
FUN177(VAR141.VAR260.VAR41) - VAR246 - VAR247
);
uint256 VAR321 = FUN176(
VAR319,
1,
FUN177(VAR141.VAR261.VAR41) - VAR247
);
ValueWithFees memory VAR322 = FUN178(VAR320);
ValueWithFees memory VAR323 = FUN178(VAR321);
return FUN105({
VAR267: VAR322.value,
VAR268: VAR323.value,
VAR269: VAR322.VAR263,
VAR270: VAR323.VAR263,
VAR271: VAR141.VAR260.VAR233,
VAR272: VAR141.VAR261.VAR233
});
}
function FUN171(
bytes32 VAR145,
bytes32 VAR146,
TokenPair memory VAR141
) private view returns (SettlementDetails VAR317) {
Fraction memory VAR318 = FUN175(VAR281[VAR145].VAR211.FUN9(VAR281[VAR146].VAR211), 2);
uint256 VAR319 = VAR219.FUN143(VAR281[VAR145].VAR212, VAR281[VAR146].VAR212);
if (FUN179(VAR141.VAR261.VAR233)) {
uint256 VAR321 = FUN176(
VAR319,
1,
FUN177(VAR141.VAR261.VAR41) - VAR247
);
ValueWithFees memory VAR323 = FUN178(VAR321);
return FUN105({
VAR267: 0,
VAR268: 0,
VAR269: VAR323.VAR263,
VAR270: VAR323.VAR263,
VAR271: VAR141.VAR261.VAR233,
VAR272: VAR141.VAR261.VAR233
});
} else if (FUN179(VAR141.VAR260.VAR233)) {
uint256 VAR320 = FUN176(
VAR319.FUN6(VAR318.VAR265),
VAR318.VAR266,
FUN177(VAR141.VAR260.VAR41) - VAR246 - VAR247
);
ValueWithFees memory VAR322 = FUN178(VAR320);
return FUN105({
VAR267: 0,
VAR268: 0,
VAR269: VAR322.VAR263,
VAR270: VAR322.VAR263,
VAR271: VAR141.VAR260.VAR233,
VAR272: VAR141.VAR260.VAR233
});
} else {
revert("");
}
}
function FUN170(bytes32 VAR137) private view returns (bool) {
uint64 VAR210 = VAR281[VAR137].VAR210;
uint32 VAR324 = FUN139(VAR210 >> 32);
uint32 VAR261 = FUN139(VAR210);
return (VAR324 < VAR261);
}
function FUN178(uint256 VAR19) private pure returns (ValueWithFees VAR317) {
uint256 VAR325 = (VAR19.FUN6(VAR243 - VAR242)) / VAR243;
return FUN180(VAR325, VAR19.FUN8(VAR325));
}
function FUN168(uint64 VAR141) private view returns (TokenPair VAR317) {
(
address VAR326,
uint8 VAR327,
bool VAR328
) = VAR249.FUN181(FUN139(VAR141 >> 32));
(
address VAR329,
uint8 VAR330,
bool VAR331
) = VAR249.FUN181(FUN139(VAR141));
return FUN182({
VAR260: VAR259.FUN156(VAR326, VAR327, VAR328),
VAR261: VAR259.FUN156(VAR329, VAR330, VAR331)
});
}
function FUN179(address VAR240) private pure returns (bool) {
return (VAR240 != 0x0);
}
function FUN176(uint256 VAR332, uint256 VAR333, int16 VAR334) private pure returns (uint256) {
if (VAR334 >= 0) {
assert(VAR334 <= 77);
return VAR332.FUN6(10 ** uint256(VAR334)) / VAR333;
} else {
return (VAR332 / VAR333) / 10 ** uint256(-VAR334);
}
}
}
1
---------------------------------
104 0x7183169973eda16209f66a602f2e27e1303bf414.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function FUN1() public constant returns (uint256);
function FUN2(address VAR3) public constant returns (uint256 VAR4);
function FUN3(address VAR3, address VAR5) public constant returns (uint256 VAR6);
function transfer(address VAR7, uint256 VAR8) public returns (bool VAR9);
function FUN4(address VAR5, uint256 VAR8) public returns (bool VAR9);
function FUN5(address VAR10, address VAR7, uint256 VAR8) public returns (bool VAR9);
event Transfer(address indexed VAR10, address indexed VAR7, uint VAR8);
event FUN6(address indexed VAR3, address indexed VAR5, uint VAR8);
}
contract VAR11 {
function FUN7(address) public payable returns(uint256){}
function FUN8() public {}
function FUN9() public view returns(uint256) {}
}
contract VAR12 {
address public VAR13;
address public VAR14;
function FUN10() public {
VAR13 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR13);
VAR15;
}
function FUN11(address VAR16) public onlyOwner {
VAR14 = VAR16;
}
function FUN12() public {
require(msg.sender == VAR14);
VAR13 = VAR14;
}
}
contract BoomerangLiquidity is VAR12 {
modifier onlyOwner(){
require(msg.sender == VAR13);
VAR15;
}
modifier FUN13(address VAR17){
require(VAR17 != VAR18);
VAR15;
}
uint public VAR19;
uint public VAR20 = 0;
address VAR18;
POWH VAR21;
function FUN14(uint VAR22, address VAR23) public {
VAR19 = VAR22;
VAR18 = VAR23;
VAR21 = FUN15(VAR18);
}
struct VAR24 {
address VAR25;
uint VAR26;
}
VAR24[] public VAR27;
function() payable public {
FUN16();
}
function FUN16() payable public {
VAR27.FUN17(FUN18(msg.sender, (msg.value * VAR19) / 100));
FUN8();
FUN19();
}
function FUN19() public {
uint VAR4 = address(this).VAR4;
require(VAR4 > 1);
uint VAR28 = VAR4 / 2;
VAR4 -= VAR28;
VAR21.VAR29.value(VAR28)(msg.sender);
while (VAR4 > 0) {
uint VAR30 = VAR4 < VAR27[VAR20].VAR26 ? VAR4 : VAR27[VAR20].VAR26;
if(VAR30 > 0){
VAR27[VAR20].VAR26 -= VAR30;
VAR4 -= VAR30;
if(!VAR27[VAR20].VAR25.FUN20(VAR30)){
VAR27[VAR20].VAR25.call.value(VAR30).FUN21(1000000)();
}
}
if(VAR4 > 0){
VAR20 += 1;
}
}
}
function FUN9() public view returns(uint256){
return VAR21.FUN9();
}
function FUN8() public {
if(FUN9() > 0){
VAR21.FUN8();
}
}
function FUN22() payable public {
}
function FUN23(address VAR31, uint VAR8) public onlyOwner FUN13(VAR31) returns (bool VAR9) {
return FUN24(VAR31).transfer(VAR13, VAR8);
}
}
1
---------------------------------
105 0x73bbb94cb75ba2627fef42668b2881412b0d2749.sol
pragma VAR1 ^0.4.15;
pragma VAR1 ^0.4.14;
library VAR2 {
struct VAR3 {
uint VAR4;
uint VAR5;
}
function FUN1(uint VAR6, uint VAR7, uint VAR8) private pure {
for(; VAR8 >= 32; VAR8 -= 32) {
VAR9 {
FUN2(VAR6, FUN3(VAR7))
}
VAR6 += 32;
VAR7 += 32;
}
uint VAR10 = 256 ** (32 - VAR8) - 1;
VAR9 {
let VAR11 := FUN4(FUN3(VAR7), FUN5(VAR10))
let VAR12 := FUN4(FUN3(VAR6), VAR10)
FUN2(VAR6, or(VAR12, VAR11))
}
}
function FUN6(string VAR13) internal pure returns (VAR3) {
uint VAR14;
VAR9 {
VAR14 := FUN7(VAR13, 0x20)
}
return FUN8(bytes(VAR13).VAR15, VAR14);
}
function FUN9(bytes32 VAR13) internal pure returns (uint) {
uint VAR16;
if (VAR13 == 0)
return 0;
if (VAR13 & 0xffffffffffffffffffffffffffffffff == 0) {
VAR16 += 16;
VAR13 = bytes32(uint(VAR13) / 0x100000000000000000000000000000000);
}
if (VAR13 & 0xffffffffffffffff == 0) {
VAR16 += 8;
VAR13 = bytes32(uint(VAR13) / 0x10000000000000000);
}
if (VAR13 & 0xffffffff == 0) {
VAR16 += 4;
VAR13 = bytes32(uint(VAR13) / 0x100000000);
}
if (VAR13 & 0xffff == 0) {
VAR16 += 2;
VAR13 = bytes32(uint(VAR13) / 0x10000);
}
if (VAR13 & 0xff == 0) {
VAR16 += 1;
}
return 32 - VAR16;
}
function FUN10(bytes32 VAR13) internal pure returns (slice VAR16) {
VAR9 {
let VAR14 := FUN3(0x40)
FUN2(0x40, FUN7(VAR14, 0x20))
FUN2(VAR14, VAR13)
FUN2(FUN7(VAR16, 0x20), VAR14)
}
VAR16.VAR4 = FUN9(VAR13);
}
function FUN11(slice VAR13) internal pure returns (VAR3) {
return FUN8(VAR13.VAR4, VAR13.VAR5);
}
function FUN12(slice VAR13) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
return VAR16;
}
function FUN9(slice VAR13) internal pure returns (uint VAR19) {
uint VAR14 = VAR13.VAR5 - 31;
uint VAR20 = VAR14 + VAR13.VAR4;
for (VAR19 = 0; VAR14 < VAR20; VAR19++) {
uint8 VAR21;
VAR9 { VAR21 := FUN4(FUN3(VAR14), 0xFF) }
if (VAR21 < 0x80) {
VAR14 += 1;
} else if(VAR21 < 0xE0) {
VAR14 += 2;
} else if(VAR21 < 0xF0) {
VAR14 += 3;
} else if(VAR21 < 0xF8) {
VAR14 += 4;
} else if(VAR21 < 0xFC) {
VAR14 += 5;
} else {
VAR14 += 6;
}
}
}
function FUN13(slice VAR13) internal pure returns (bool) {
return VAR13.VAR4 == 0;
}
function FUN14(slice VAR13, slice VAR22) internal pure returns (int) {
uint VAR23 = VAR13.VAR4;
if (VAR22.VAR4 < VAR13.VAR4)
VAR23 = VAR22.VAR4;
uint VAR24 = VAR13.VAR5;
uint VAR25 = VAR22.VAR5;
for (uint VAR26 = 0; VAR26 < VAR23; VAR26 += 32) {
uint VAR27;
uint VAR21;
VAR9 {
VAR27 := FUN3(VAR24)
VAR21 := FUN3(VAR25)
}
if (VAR27 != VAR21) {
uint256 VAR10 = uint256(-1);
if(VAR23 < 32) {
VAR10 = ~(2 ** (8 * (32 - VAR23 + VAR26)) - 1);
}
uint256 VAR28 = (VAR27 & VAR10) - (VAR21 & VAR10);
if (VAR28 != 0)
return int(VAR28);
}
VAR24 += 32;
VAR25 += 32;
}
return int(VAR13.VAR4) - int(VAR22.VAR4);
}
function FUN15(slice VAR13, slice VAR22) internal pure returns (bool) {
return FUN14(VAR13, VAR22) == 0;
}
function FUN16(slice VAR13, slice VAR29) internal pure returns (VAR3) {
VAR29.VAR5 = VAR13.VAR5;
if (VAR13.VAR4 == 0) {
VAR29.VAR4 = 0;
return VAR29;
}
uint VAR19;
uint VAR21;
VAR9 { VAR21 := FUN4(FUN3(FUN17(FUN3(FUN7(VAR13, 32)), 31)), 0xFF) }
if (VAR21 < 0x80) {
VAR19 = 1;
} else if(VAR21 < 0xE0) {
VAR19 = 2;
} else if(VAR21 < 0xF0) {
VAR19 = 3;
} else {
VAR19 = 4;
}
if (VAR19 > VAR13.VAR4) {
VAR29.VAR4 = VAR13.VAR4;
VAR13.VAR5 += VAR13.VAR4;
VAR13.VAR4 = 0;
return VAR29;
}
VAR13.VAR5 += VAR19;
VAR13.VAR4 -= VAR19;
VAR29.VAR4 = VAR19;
return VAR29;
}
function FUN16(slice VAR13) internal pure returns (slice VAR16) {
FUN16(VAR13, VAR16);
}
function FUN18(slice VAR13) internal pure returns (uint VAR16) {
if (VAR13.VAR4 == 0) {
return 0;
}
uint VAR30;
uint VAR15;
uint VAR31 = 2 ** 248;
VAR9 { VAR30:= FUN3(FUN3(FUN7(VAR13, 32))) }
uint VAR21 = VAR30 / VAR31;
if (VAR21 < 0x80) {
VAR16 = VAR21;
VAR15 = 1;
} else if(VAR21 < 0xE0) {
VAR16 = VAR21 & 0x1F;
VAR15 = 2;
} else if(VAR21 < 0xF0) {
VAR16 = VAR21 & 0x0F;
VAR15 = 3;
} else {
VAR16 = VAR21 & 0x07;
VAR15 = 4;
}
if (VAR15 > VAR13.VAR4) {
return 0;
}
for (uint VAR32 = 1; VAR32 < VAR15; VAR32++) {
VAR31 = VAR31 / 256;
VAR21 = (VAR30 / VAR31) & 0xFF;
if (VAR21 & 0xC0 != 0x80) {
return 0;
}
VAR16 = (VAR16 * 64) | (VAR21 & 0x3F);
}
return VAR16;
}
function FUN19(slice VAR13) internal pure returns (bytes32 VAR16) {
VAR9 {
VAR16 := FUN20(FUN3(FUN7(VAR13, 32)), FUN3(VAR13))
}
}
function FUN21(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
if (VAR13.VAR5 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN23(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
bool VAR34 = true;
if (VAR13.VAR5 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN24(VAR24, VAR15), FUN24(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
VAR13.VAR5 += VAR33.VAR4;
}
return VAR13;
}
function FUN25(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
if (VAR24 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN26(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
bool VAR34 = true;
if (VAR24 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
}
return VAR13;
}
event FUN27(bytes32 VAR10);
function FUN28(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14 = VAR24;
uint VAR26;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
uint VAR20 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 >= VAR20)
return VAR24 + VAR36;
VAR14++;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
for (VAR26 = 0; VAR26 <= VAR36 - VAR37; VAR26++) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14;
VAR14 += 1;
}
}
}
return VAR24 + VAR36;
}
function FUN29(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
VAR14 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 <= VAR24)
return VAR24;
VAR14--;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14 + VAR37;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
VAR14 = VAR24 + (VAR36 - VAR37);
while (VAR14 >= VAR24) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14 + VAR37;
VAR14 -= 1;
}
}
}
return VAR24;
}
function FUN30(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 -= VAR14 - VAR13.VAR5;
VAR13.VAR5 = VAR14;
return VAR13;
}
function FUN31(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 = VAR14 - VAR13.VAR5;
return VAR13;
}
function FUN32(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR13.VAR5;
VAR42.VAR4 = VAR14 - VAR13.VAR5;
if (VAR14 == VAR13.VAR5 + VAR13.VAR4) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
VAR13.VAR5 = VAR14 + VAR33.VAR4;
}
return VAR42;
}
function FUN32(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN32(VAR13, VAR33, VAR42);
}
function FUN33(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR14;
VAR42.VAR4 = VAR13.VAR4 - (VAR14 - VAR13.VAR5);
if (VAR14 == VAR13.VAR5) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
}
return VAR42;
}
function FUN33(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN33(VAR13, VAR33, VAR42);
}
function FUN34(slice VAR13, slice VAR33) internal pure returns (uint VAR43) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
while (VAR14 <= VAR13.VAR5 + VAR13.VAR4) {
VAR43++;
VAR14 = FUN28(VAR13.VAR4 - (VAR14 - VAR13.VAR5), VAR14, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
}
}
function FUN35(slice VAR13, slice VAR33) internal pure returns (bool) {
return FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) != VAR13.VAR5;
}
function FUN36(slice VAR13, slice VAR22) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4 + VAR22.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
FUN1(VAR18 + VAR13.VAR4, VAR22.VAR5, VAR22.VAR4);
return VAR16;
}
function FUN37(slice VAR13, VAR3[] VAR44) internal pure returns (string) {
if (VAR44.VAR15 == 0)
return "";
uint VAR15 = VAR13.VAR4 * (VAR44.VAR15 - 1);
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++)
VAR15 += VAR44[VAR32].VAR4;
string memory VAR16 = VAR17 string(VAR15);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
for(VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
FUN1(VAR18, VAR44[VAR32].VAR5, VAR44[VAR32].VAR4);
VAR18 += VAR44[VAR32].VAR4;
if (VAR32 < VAR44.VAR15 - 1) {
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
VAR18 += VAR13.VAR4;
}
}
return VAR16;
}
}
address VAR45;
address VAR46;
string VAR47;
string VAR48;
string VAR49;
mapping (string => bool) VAR50;
enum VAR51 {VAR52, VAR53, VAR54}
Status VAR55;
event FUN38(address VAR56, uint value);
event FUN39(address VAR46, uint value, address VAR57, bytes VAR58);
function FUN40 (address VAR59, string VAR60, string VAR61, string VAR62, address VAR63) {
VAR45 = VAR63;
VAR46 = VAR59;
VAR55 = VAR51.VAR52;
VAR48 = VAR60;
VAR49 = VAR61;
VAR47 = VAR62;
var VAR64 = VAR61.FUN6().FUN11();
var VAR65 = "".FUN6();
var VAR44 = new uint256[](VAR64.FUN34(VAR65) + 1);
uint256 VAR66;
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
VAR66 = VAR66 + FUN41(VAR64.FUN32(VAR65).FUN12());
}
require(VAR66 == 100000);
}
modifier onlyOwner() {
require(msg.sender == VAR46);
VAR67;
}
modifier FUN42() {
require(VAR55 == VAR51.VAR53 || VAR55 == VAR51.VAR52);
VAR67;
}
modifier FUN43() {
require(VAR55 == VAR51.VAR54);
VAR67;
}
modifier FUN44() {
var VAR64 = VAR48.FUN6().FUN11();
var VAR65 = "".FUN6();
string[] memory VAR68 = new string[](VAR64.FUN34(VAR65) + 1);
bool VAR69 = false;
string memory VAR70 = FUN45(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR68.VAR15; VAR32++) {
if(FUN20(VAR70) == FUN20(VAR64.FUN32(VAR65).FUN12())){
VAR69 = true;
break;
}
}
require(VAR69);
VAR67;
}
modifier FUN46() {
var VAR64 = VAR47.FUN6().FUN11();
var VAR65 = "".FUN6();
string[] memory VAR71 = new string[](VAR64.FUN34(VAR65) + 1);
bool VAR72 = false;
string memory VAR70 = FUN45(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR71.VAR15; VAR32++) {
if(FUN20(VAR70) == FUN20(VAR64.FUN32(VAR65).FUN12())){
VAR72 = true;
break;
}
}
require(VAR72);
VAR67;
}
function () payable VAR73 {
if (VAR55 == VAR51.VAR52) {
var VAR74 = VAR47.FUN6().FUN11();
var VAR75 = VAR74.FUN34("".FUN6()) + 1;
var VAR76 = 1000000000000000 * VAR75 + 5000000000000000;
require(msg.value > VAR76);
for (uint VAR32 = 0; VAR32 < VAR75; VAR32++) {
var VAR77 = FUN47(VAR74.FUN32("".FUN6()).FUN12());
VAR77.transfer(1000000000000000);
}
VAR45.transfer(5000000000000000);
VAR55 = VAR51.VAR53;
FUN38(msg.sender, msg.value - VAR76);
} else {
FUN38(msg.sender, msg.value);
}
}
function FUN48() onlyWitness VAR73 {
require (this.VAR78 > 0);
VAR50[FUN45(msg.sender)] = true;
var VAR79 = VAR47.FUN6().FUN11();
uint256 VAR80 = VAR79.FUN34("".FUN6()) + 1;
uint8 VAR81 = 0;
for(uint VAR32 = 0; VAR32 < VAR80; VAR32++) {
if(VAR50[VAR79.FUN32("".FUN6()).FUN12()] == true){
VAR81 = VAR81 + 1;
}
}
if(VAR81 == VAR80){
VAR79 = VAR48.FUN6().FUN11();
var  VAR82 = VAR49.FUN6().FUN11();
VAR80 = VAR79.FUN34("".FUN6()) + 1;
for(VAR32 = 0; VAR32 < VAR80 - 1; VAR32++) {
FUN47(VAR79.FUN32("".FUN6()).FUN12()).transfer(((this.VAR78 * FUN41(VAR82.FUN32("".FUN6()).FUN12())) / 100000));
}
FUN47(VAR79.FUN32("".FUN6()).FUN12()).transfer(this.VAR78);
VAR55 = VAR51.VAR54;
}
}
function FUN49(address VAR83, uint VAR84, bytes VAR85) external onlyOwner {
FUN39(msg.sender, VAR84, VAR83, VAR85);
VAR83.call.value(VAR84)(VAR85);
}
function FUN50() returns (bool){
return msg.sender == VAR46;
}
function FUN51() returns (VAR51){
return VAR55;
}
function FUN52() returns (string, string) {
return (VAR48, VAR49);
}
function FUN53() returns (string) {
return VAR47;
}
function FUN54() returns (uint) {
return VAR47.FUN6().FUN11().FUN34("".FUN6()) + 1;
}
function FUN55() constant returns (uint) {
return  address(this).VAR78;
}
function FUN56() returns (bool){
return VAR50[FUN45(msg.sender)];
}
function FUN41(string VAR64) constant private returns (uint VAR86) {
bytes memory VAR21 = bytes(VAR64);
uint VAR32;
VAR86 = 0;
for (VAR32 = 0; VAR32 < VAR21.VAR15; VAR32++) {
uint VAR87 = uint(VAR21[VAR32]);
if (VAR87 >= 48 && VAR87 <= 57) {
VAR86 = VAR86 * 10 + (VAR87 - 48);
}
}
}
function FUN45(address VAR88) private returns (string) {
bytes memory VAR64 = VAR17 bytes(42);
VAR64[0] = "";
VAR64[1] = "";
for (uint VAR32 = 0; VAR32 < 20; VAR32++) {
byte VAR21 = FUN57(uint8(uint(VAR88) / (2**(8*(19 - VAR32)))));
byte VAR89 = FUN57(uint8(VAR21) / 16);
byte VAR90 = FUN57(uint8(VAR21) - 16 * uint8(VAR89));
VAR64[2+2*VAR32] = FUN58(VAR89);
VAR64[2+2*VAR32+1] = FUN58(VAR90);
}
return string(VAR64);
}
function FUN58(byte VAR21) private returns (byte VAR87) {
if (VAR21 < 10) return FUN57(uint8(VAR21) + 0x30);
else return FUN57(uint8(VAR21) + 0x57);
}
function FUN47(string VAR91) internal returns (address){
bytes memory VAR92 = bytes(VAR91);
uint160 VAR93 = 0;
uint160 VAR94;
uint160 VAR95;
for (uint VAR32=2; VAR32<2+2*20; VAR32+=2){
VAR93 *= 256;
VAR94 = FUN59(VAR92[VAR32]);
VAR95 = FUN59(VAR92[VAR32+1]);
if ((VAR94 >= 97)&&(VAR94 <= 102)) VAR94 -= 87;
else if ((VAR94 >= 48)&&(VAR94 <= 57)) VAR94 -= 48;
if ((VAR95 >= 97)&&(VAR95 <= 102)) VAR95 -= 87;
else if ((VAR95 >= 48)&&(VAR95 <= 57)) VAR95 -= 48;
VAR93 += (VAR94*16+VAR95);
}
return address(VAR93);
}
}
function FUN60 () {
VAR45 = msg.sender;
}
function FUN61 (address VAR59, string VAR60, string VAR61, string VAR62) {
address VAR46 = VAR59;
var VAR64 = VAR60.FUN6().FUN11();
if (!VAR64.FUN25("".FUN6())){
VAR60.FUN6().FUN36("".FUN6());
}
VAR64 = VAR62.FUN6().FUN11();
if (!VAR64.FUN25("".FUN6())){
VAR62.FUN6().FUN36("".FUN6());
}
VAR64 = VAR61.FUN6().FUN11();
if (!VAR64.FUN25("".FUN6())){
VAR61.FUN6().FUN36("".FUN6());
}
VAR64 = VAR62.FUN6().FUN11();
var VAR65 = "".FUN6();
uint256 VAR96 = VAR64.FUN34(VAR65) + 1;
address VAR97 = VAR17 FUN40(VAR46, VAR60, VAR61, VAR62, VAR45);
var VAR98 = FUN45(VAR97);
VAR99[VAR46] =  VAR99[VAR46].FUN6().FUN36(VAR98.FUN6()).FUN6().FUN36("".FUN6());
}
function FUN62(address VAR46) returns (string) {
return VAR99[VAR46];
}
function FUN45(address VAR88) returns (string) {
bytes memory VAR64 = VAR17 bytes(42);
VAR64[0] = "";
VAR64[1] = "";
for (uint VAR32 = 0; VAR32 < 20; VAR32++) {
byte VAR21 = FUN57(uint8(uint(VAR88) / (2**(8*(19 - VAR32)))));
byte VAR89 = FUN57(uint8(VAR21) / 16);
byte VAR90 = FUN57(uint8(VAR21) - 16 * uint8(VAR89));
VAR64[2+2*VAR32] = FUN58(VAR89);
VAR64[2+2*VAR32+1] = FUN58(VAR90);
}
return string(VAR64);
}
function FUN58(byte VAR21) returns (byte VAR87) {
if (VAR21 < 10) return FUN57(uint8(VAR21) + 0x30);
else return FUN57(uint8(VAR21) + 0x57);
}
function FUN55() constant returns (uint) {
return  address(this).VAR78;
}
}
1
---------------------------------
106 0x7430984e1d05d5f447c747123dd26845f6f17544.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1(address VAR3, uint8 VAR4, string VAR5) public payable returns (uint);
function FUN2(address VAR6) public view returns (uint);
function transfer(address VAR7, uint VAR8)     public returns (bool);
function FUN3(address VAR9, address VAR10, uint VAR11) public returns (bool);
function FUN4() public;
function FUN5(uint VAR12) public;
function FUN6(address VAR13) public;
}
contract VAR14 {
function FUN7(address VAR9, uint VAR11, bytes VAR15) public returns (bool);
}
contract ZethrBankroll is VAR14 {
using SafeMath for uint;
event FUN8(address indexed sender, uint indexed VAR16);
event FUN9(address indexed sender, uint indexed VAR16);
event FUN10(uint indexed VAR16);
event FUN11(uint indexed VAR16);
event FUN12(uint indexed VAR16);
event FUN13(address indexed sender, uint value);
event FUN14(address indexed VAR17);
event FUN15(address indexed VAR17);
event FUN16(address indexed VAR18);
event FUN17(address indexed VAR18);
event FUN18(uint VAR19);
event FUN19(uint VAR20, uint VAR21);
event FUN20(uint VAR22, address sender);
event FUN21(uint VAR22);
event FUN22(address VAR23);
event FUN23(address VAR23, uint VAR24);
event FUN24(address VAR23, uint VAR24);
uint constant public VAR25 = 10;
uint constant public VAR26 = 15;
uint constant public VAR27 = 5;
uint constant internal VAR28 = 1 VAR29;
address internal VAR30;
ZTHInterface public VAR31;
mapping (uint => Transaction) public VAR32;
mapping (uint => mapping (address => bool)) public VAR33;
mapping (address => bool) public VAR34;
mapping (address => bool) public VAR35;
mapping (address => uint) public VAR36;
address internal VAR37;
address[] public VAR38;
address[] public VAR39;
uint public VAR19;
uint public VAR40;
uint internal VAR41;
uint internal VAR42;
uint internal VAR43;
bool internal VAR44 = false;
struct Transaction {
address VAR45;
uint value;
bytes VAR46;
bool VAR47;
}
struct VAR48 {
address sender;
uint value;
}
modifier FUN25() {
if (msg.sender != address(this))
revert();
VAR49;
}
modifier FUN26(address VAR18) {
if (VAR35[VAR18])
revert();
VAR49;
}
modifier FUN27(address VAR18) {
if (!VAR35[VAR18])
revert();
VAR49;
}
modifier FUN28() {
address VAR50 = msg.sender;
if (!VAR34[VAR50])
revert();
VAR49;
}
modifier FUN29(address VAR17) {
if (VAR34[VAR17])
revert();
VAR49;
}
modifier ownerExists(address VAR17) {
if (!VAR34[VAR17])
revert();
VAR49;
}
modifier FUN30(uint VAR16) {
if (VAR32[VAR16].VAR45 == 0)
revert();
VAR49;
}
modifier confirmed(uint VAR16, address VAR17) {
if (!VAR33[VAR16][VAR17])
revert();
VAR49;
}
modifier notConfirmed(uint VAR16, address VAR17) {
if (VAR33[VAR16][VAR17])
revert();
VAR49;
}
modifier notExecuted(uint VAR16) {
if (VAR32[VAR16].VAR47)
revert();
VAR49;
}
modifier FUN31(address VAR51) {
if (VAR51 == 0)
revert();
VAR49;
}
modifier FUN32(uint VAR52, uint VAR53) {
if (   VAR52 > VAR25
|| VAR53 > VAR52
|| VAR53 == 0
|| VAR52 == 0)
revert();
VAR49;
}
constructor (address[] VAR54, uint VAR53)
public
FUN32(VAR54.VAR55, VAR53)
{
for (uint VAR56=0; VAR56<VAR54.VAR55; VAR56++) {
if (VAR34[VAR54[VAR56]] || VAR54[VAR56] == 0)
revert();
VAR34[VAR54[VAR56]] = true;
}
VAR38 = VAR54;
VAR19 = VAR53;
VAR41 = VAR57 - (1 VAR29);
}
function FUN33(address VAR58, address VAR59)
public
VAR60
{
VAR30   = VAR58;
VAR37 = VAR59;
VAR31 = FUN34(VAR30);
}
function()
public
payable
{
}
uint VAR61;
function FUN35()
public
payable
{
VAR61 = VAR61.FUN36(msg.value);
}
function FUN37()
public
payable
VAR60
{
uint VAR62 = address(this).VAR63;
if (VAR62 > 0.01 VAR64) {
VAR31.VAR65.value(VAR62)(address(0x0), 33, "");
emit FUN21(VAR62);
}
else {
emit FUN20(msg.value, msg.sender);
}
}
function FUN7(address
, uint
, bytes
) public returns (bool) {
}
function FUN38(uint VAR66)
public
returns(bool)
{
uint VAR67     = VAR57;
uint VAR68    = VAR31.FUN2(address(this));
uint VAR69        = (VAR68.FUN39(VAR27)).FUN40(100);
require (VAR66 <= VAR69);
if (VAR67 - VAR41 >= VAR28)
{
VAR41     = VAR67;
VAR42      = (VAR68.FUN39(VAR26)).FUN40(100);
VAR43 = VAR66;
return true;
}
else
{
if (VAR43.FUN36(VAR66) <= VAR42)
{
VAR43 += VAR66;
return true;
}
else { return false; }
}
}
function FUN41(uint VAR70)
public
VAR60
{
VAR42 = VAR70;
}
function FUN42(address VAR17)
public
VAR71
FUN29(VAR17)
FUN31(VAR17)
FUN32(VAR38.VAR55 + 1, VAR19)
{
VAR34[VAR17] = true;
VAR38.FUN43(VAR17);
emit FUN14(VAR17);
}
function FUN44(address VAR17)
public
VAR71
ownerExists(VAR17)
FUN32(VAR38.VAR55, VAR19)
{
VAR34[VAR17] = false;
for (uint VAR56=0; VAR56<VAR38.VAR55 - 1; VAR56++)
if (VAR38[VAR56] == VAR17) {
VAR38[VAR56] = VAR38[VAR38.VAR55 - 1];
break;
}
VAR38.VAR55 -= 1;
if (VAR19 > VAR38.VAR55)
FUN45(VAR38.VAR55);
emit FUN15(VAR17);
}
function FUN46(address VAR17, address VAR72)
public
VAR71
ownerExists(VAR17)
FUN29(VAR72)
{
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR38[VAR56] == VAR17) {
VAR38[VAR56] = VAR72;
break;
}
VAR34[VAR17] = false;
VAR34[VAR72] = true;
emit FUN15(VAR17);
emit FUN14(VAR72);
}
function FUN45(uint VAR53)
public
VAR71
FUN32(VAR38.VAR55, VAR53)
{
VAR19 = VAR53;
emit FUN18(VAR53);
}
function FUN47(address VAR45, uint value, bytes VAR46)
public
returns (uint VAR16)
{
VAR16 = FUN48(VAR45, value, VAR46);
FUN49(VAR16);
}
function FUN49(uint VAR16)
public
ownerExists(msg.sender)
FUN30(VAR16)
notConfirmed(VAR16, msg.sender)
{
VAR33[VAR16][msg.sender] = true;
emit FUN8(msg.sender, VAR16);
FUN50(VAR16);
}
function FUN51(uint VAR16)
public
ownerExists(msg.sender)
confirmed(VAR16, msg.sender)
notExecuted(VAR16)
{
VAR33[VAR16][msg.sender] = false;
emit FUN9(msg.sender, VAR16);
}
function FUN50(uint VAR16)
public
notExecuted(VAR16)
{
if (FUN52(VAR16)) {
Transaction storage VAR73 = VAR32[VAR16];
VAR73.VAR47 = true;
if (VAR73.VAR45.call.value(VAR73.value)(VAR73.VAR46))
emit FUN11(VAR16);
else {
emit FUN12(VAR16);
VAR73.VAR47 = false;
}
}
}
function FUN52(uint VAR16)
public
constant
returns (bool)
{
uint VAR74 = 0;
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++) {
if (VAR33[VAR16][VAR38[VAR56]])
VAR74 += 1;
if (VAR74 == VAR19)
return true;
}
}
function FUN48(address VAR45, uint value, bytes VAR46)
internal
FUN31(VAR45)
returns (uint VAR16)
{
VAR16 = VAR40;
VAR32[VAR16] = Transaction({
VAR45: VAR45,
value: value,
VAR46: VAR46,
VAR47: false
});
VAR40 += 1;
emit FUN10(VAR16);
}
function FUN53(uint VAR16)
public
constant
returns (uint VAR74)
{
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR33[VAR16][VAR38[VAR56]])
VAR74 += 1;
}
function FUN54(bool VAR75, bool VAR47)
public
constant
returns (uint VAR74)
{
for (uint VAR56=0; VAR56<VAR40; VAR56++)
if (   VAR75 && !VAR32[VAR56].VAR47
|| VAR47 && VAR32[VAR56].VAR47)
VAR74 += 1;
}
function FUN55()
public
constant
returns (address[])
{
return VAR38;
}
function FUN56(uint VAR16)
public
constant
returns (address[] VAR76)
{
address[] memory VAR77 = new address[](VAR38.VAR55);
uint VAR74 = 0;
uint VAR56;
for (VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR33[VAR16][VAR38[VAR56]]) {
VAR77[VAR74] = VAR38[VAR56];
VAR74 += 1;
}
VAR76 = new address[](VAR74);
for (VAR56=0; VAR56<VAR74; VAR56++)
VAR76[VAR56] = VAR77[VAR56];
}
function FUN57(uint VAR78, uint VAR79, bool VAR75, bool VAR47)
public
constant
returns (uint[] VAR80)
{
uint[] memory VAR81 = new uint[](VAR40);
uint VAR74 = 0;
uint VAR56;
for (VAR56=0; VAR56<VAR40; VAR56++)
if (   VAR75 && !VAR32[VAR56].VAR47
|| VAR47 && VAR32[VAR56].VAR47)
{
VAR81[VAR74] = VAR56;
VAR74 += 1;
}
VAR80 = new uint[](VAR79 - VAR78);
for (VAR56=VAR78; VAR56<VAR79; VAR56++)
VAR80[VAR56 - VAR78] = VAR81[VAR56];
}
function FUN58(address VAR18)
public
VAR60
FUN26(VAR18)
FUN31(VAR18)
{
VAR35[VAR18] = true;
VAR39.FUN43(VAR18);
VAR36[VAR18] = 0;
emit FUN16(VAR18);
}
function FUN59(address VAR18)
public
VAR60
FUN27(VAR18)
{
VAR35[VAR18] = false;
for (uint VAR56=0; VAR56 < VAR39.VAR55 - 1; VAR56++)
if (VAR39[VAR56] == VAR18) {
VAR39[VAR56] = VAR38[VAR39.VAR55 - 1];
break;
}
VAR39.VAR55 -= 1;
emit FUN17(VAR18);
}
function FUN60(uint VAR82, address VAR83) public
FUN27(msg.sender)
{
require(VAR35[msg.sender]);
require(VAR31.transfer(VAR83, VAR82));
}
function FUN61(address VAR84, uint VAR85)
public
VAR60
FUN27(VAR84)
{
VAR36[VAR84] = VAR85;
}
function FUN62(address VAR84)
public
view
returns (uint)
{
return VAR36[VAR84];
}
function FUN63()
public
VAR60
{
for (uint VAR56=0; VAR56 < VAR39.VAR55; VAR56++)
{
address VAR84 = VAR39[VAR56];
if ( VAR36[VAR84] > 0 )
{
FUN64(VAR84);
emit FUN22(VAR84);
}
}
}
function FUN65(address VAR84, uint VAR86)
public
VAR60
FUN27(VAR84)
{
require(VAR31.FUN3(VAR84, address(this), VAR86));
}
function FUN64(address VAR84)
public
VAR60
FUN27(VAR84)
{
uint VAR87 = VAR36[VAR84];
uint VAR88  = VAR31.FUN2(VAR84);
if (VAR88 <= VAR87)
{
uint VAR89  = VAR87.FUN66(VAR88);
require(FUN38(VAR89));
require(VAR31.transfer(VAR84, VAR89));
emit FUN23(VAR84, VAR89);
} else
{
uint VAR90 = VAR88.FUN66(VAR87);
require(VAR31.FUN3(VAR84, address(this), VAR90));
emit FUN24(VAR84, VAR90);
}
emit FUN22(VAR84);
}
function FUN67(uint VAR82) public
VAR71
{
require(FUN38(VAR82));
uint VAR21 = VAR91.FUN40(VAR82, VAR38.VAR55);
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++) {
VAR31.transfer(VAR38[VAR56], VAR21);
}
emit FUN19(VAR82, VAR21);
}
function FUN68(address VAR92)
public
VAR60
{
VAR37 = VAR92;
}
function FUN69() public payable {
if (!VAR44) {
uint VAR93 = (address(this).VAR63.FUN66(VAR61));
if (VAR93 > 0.01 VAR64) {
VAR44 = true;
VAR31.VAR65.value(VAR93)(address(0x0), 33, "");
emit FUN21(VAR93);
VAR44 = false;
}
}
}
function FUN70() public payable VAR60 {
if (!VAR44) {
uint VAR63 = address(this).VAR63;
require (VAR63 > 0.01 VAR64);
VAR31.VAR65.value(VAR63)(address(0x0), 33, "");
}
}
function FUN71(uint VAR94) public pure returns (uint) {
if (FUN72(VAR94) >= FUN72('') && FUN72(VAR94) <= FUN72('')) {
return VAR94 - uint(FUN72(''));
}
if (FUN72(VAR94) >= FUN72('') && FUN72(VAR94) <= FUN72('')) {
return 10 + VAR94 - uint(FUN72(''));
}
if (FUN72(VAR94) >= FUN72('') && FUN72(VAR94) <= FUN72('')) {
return 10 + VAR94 - uint(FUN72(''));
}
}
function FUN73(string VAR95) public pure returns (bytes) {
bytes memory VAR96 = bytes(VAR95);
require(VAR96.VAR55%2 == 0);
bytes memory VAR97 = VAR98 bytes(VAR96.VAR55/2);
for (uint VAR56=0; VAR56<VAR96.VAR55/2; ++VAR56) {
VAR97[VAR56] = FUN72(FUN71(uint(VAR96[2*VAR56])) * 16 +
FUN71(uint(VAR96[2*VAR56+1])));
}
return VAR97;
}
}
library VAR91 {
function FUN39(uint VAR99, uint VAR100) internal pure returns (uint) {
if (VAR99 == 0) {
return 0;
}
uint VAR94 = VAR99 * VAR100;
assert(VAR94 / VAR99 == VAR100);
return VAR94;
}
function FUN40(uint VAR99, uint VAR100) internal pure returns (uint) {
uint VAR94 = VAR99 / VAR100;
return VAR94;
}
function FUN66(uint VAR99, uint VAR100) internal pure returns (uint) {
assert(VAR100 <= VAR99);
return VAR99 - VAR100;
}
function FUN36(uint VAR99, uint VAR100) internal pure returns (uint) {
uint VAR94 = VAR99 + VAR100;
assert(VAR94 >= VAR99);
return VAR94;
}
}
1
---------------------------------
107 0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 2 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
108 0x76fe1ecb4a94f1b88e8b75de11445160a492ea5a.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
contract BaseModule is VAR2 {
ModuleRegistry internal VAR6;
event FUN4(bytes32 VAR7);
event FUN5(address VAR8);
constructor(ModuleRegistry VAR9, bytes32 VAR10) public {
VAR6 = VAR9;
emit FUN4(VAR10);
}
modifier FUN6(BaseWallet VAR3) {
require(msg.sender == address(VAR3), "");
VAR11;
}
modifier onlyOwner(BaseWallet VAR3) {
require(msg.sender == address(this) || FUN7(VAR3, msg.sender), "");
VAR11;
}
modifier FUN8(BaseWallet VAR3) {
require(FUN7(VAR3, msg.sender), "");
VAR11;
}
function FUN1(BaseWallet VAR3) external FUN6(VAR3) {
emit FUN5(VAR3);
}
function FUN2(BaseWallet VAR3, Module VAR4) external FUN8(VAR3) {
require(VAR6.FUN9(VAR4), "");
VAR3.FUN10(VAR4, true);
}
function FUN3(address VAR5) external {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(address(VAR6), VAR12);
}
function FUN7(BaseWallet VAR3, address VAR13) internal view returns (bool) {
return VAR3.FUN13() == VAR13;
}
}
contract RelayerModule is VAR2 {
uint256 constant internal VAR14 = 10000;
mapping (address => VAR15) public VAR16;
struct VAR15 {
uint256 VAR17;
mapping (bytes32 => bool) VAR18;
}
event FUN14(address indexed VAR8, bool indexed VAR19, bytes32 VAR20);
modifier VAR21 {
require(msg.sender == address(this), "");
VAR11;
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256);
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool);
function FUN17(
BaseWallet VAR3,
bytes VAR22,
uint256 VAR25,
bytes VAR24,
uint256 VAR26,
uint256 VAR27
)
external
returns (bool VAR19)
{
uint VAR28 = FUN18();
bytes32 VAR29 = FUN19(address(this), VAR3, 0, VAR22, VAR25, VAR26, VAR27);
require(FUN20(VAR3, VAR25, VAR29), "");
require(FUN21(address(VAR3), VAR22), "");
uint256 VAR30 = FUN15(VAR3, VAR22);
if((VAR30 * 65) == VAR24.VAR31) {
if(FUN22(VAR3, VAR27, VAR26, VAR30)) {
if(VAR30 == 0 || FUN16(VAR3, VAR22, VAR29, VAR24)) {
VAR19 = address(this).call(VAR22);
FUN23(VAR3, VAR28 - FUN18(), VAR26, VAR27, VAR30, msg.sender);
}
}
}
emit FUN14(VAR3, VAR19, VAR29);
}
function FUN24(BaseWallet VAR3) external view returns (uint256 VAR17) {
return VAR16[VAR3].VAR17;
}
function FUN19(
address VAR32,
address VAR33,
uint256 VAR34,
bytes VAR22,
uint256 VAR25,
uint256 VAR26,
uint256 VAR27
)
internal
pure
returns (bytes32)
{
return FUN25(
VAR35.FUN26(
"",
FUN25(VAR35.FUN26(FUN27(0x19), FUN27(0), VAR32, VAR33, VAR34, VAR22, VAR25, VAR26, VAR27))
));
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
if(VAR16[VAR3].VAR18[VAR23] == true) {
return false;
}
VAR16[VAR3].VAR18[VAR23] = true;
return true;
}
function FUN28(BaseWallet VAR3, uint256 VAR25) internal returns (bool) {
if(VAR25 <= VAR16[VAR3].VAR17) {
return false;
}
uint256 VAR36 = (VAR25 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;
if(VAR36 > VAR37.VAR38 + VAR14) {
return false;
}
VAR16[VAR3].VAR17 = VAR25;
return true;
}
function FUN29(bytes32 VAR39, bytes VAR24, uint VAR40) internal pure returns (address) {
uint8 VAR41;
bytes32 VAR42;
bytes32 VAR43;
VAR44 {
VAR42 := FUN30(FUN31(VAR24, FUN31(0x20,FUN32(0x41,VAR40))))
VAR43 := FUN30(FUN31(VAR24, FUN31(0x40,FUN32(0x41,VAR40))))
VAR41 := FUN33(FUN30(FUN31(VAR24, FUN31(0x41,FUN32(0x41,VAR40)))), 0xff)
}
require(VAR41 == 27 || VAR41 == 28);
return FUN34(VAR39, VAR41, VAR42, VAR43);
}
function FUN23(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR27, uint VAR24, address VAR46) internal {
uint256 VAR47 = 29292 + VAR45;
if(VAR26 > 0 && VAR24 > 1 && VAR47 <= VAR27) {
if(VAR26 > VAR48.VAR49) {
VAR47 = VAR47 * VAR48.VAR49;
}
else {
VAR47 = VAR47 * VAR26;
}
VAR3.FUN35(VAR46, VAR47, "");
}
}
function FUN22(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR24) internal view returns (bool) {
if(VAR26 > 0
&& VAR24 > 1
&& (address(VAR3).VAR50 < VAR45 * VAR26 || VAR3.FUN36(this) == false)) {
return false;
}
return true;
}
function FUN21(address VAR3, bytes VAR22) private pure returns (bool) {
require(VAR22.VAR31 >= 36, "");
address VAR51;
VAR44 {
VAR51 := FUN30(FUN31(VAR22, 0x24))
}
return VAR51 == VAR3;
}
function FUN37(bytes VAR22) internal pure returns (bytes4 VAR52) {
require(VAR22.VAR31 >= 4, "");
VAR44 {
VAR52 := FUN30(FUN31(VAR22, 0x20))
}
}
}
contract VAR53 {
function FUN38() public view returns (uint);
function FUN39() public view returns (uint);
function FUN12(address VAR54) public view returns (uint VAR50);
function FUN40(address VAR54, address VAR55) public view returns (uint VAR56);
function transfer(address VAR57, uint VAR58) public returns (bool VAR19);
function FUN41(address VAR55, uint VAR58) public returns (bool VAR19);
function FUN42(address VAR59, address VAR57, uint VAR58) public returns (bool VAR19);
}
contract VAR60 {
address public VAR61;
event FUN43(address indexed VAR62);
modifier onlyOwner {
require(msg.sender == VAR61, "");
VAR11;
}
constructor() public {
VAR61 = msg.sender;
}
function FUN44(address VAR62) external onlyOwner {
require(VAR62 != address(0), "");
VAR61 = VAR62;
emit FUN43(VAR62);
}
}
contract ModuleRegistry is VAR60 {
mapping (address => VAR63) internal VAR64;
mapping (address => VAR63) internal VAR65;
event FUN45(address indexed VAR66, bytes32 VAR7);
event FUN46(address VAR66);
event FUN47(address indexed VAR67, bytes32 VAR7);
event FUN48(address VAR67);
struct VAR63 {
bool VAR68;
bytes32 VAR7;
}
function FUN49(address VAR4, bytes32 VAR10) external onlyOwner {
require(!VAR64[VAR4].VAR68, "");
VAR64[VAR4] = FUN50({VAR68: true, VAR7: VAR10});
emit FUN45(VAR4, VAR10);
}
function FUN51(address VAR4) external onlyOwner {
require(VAR64[VAR4].VAR68, "");
delete VAR64[VAR4];
emit FUN46(VAR4);
}
function FUN52(address VAR69, bytes32 VAR10) external onlyOwner {
require(!VAR65[VAR69].VAR68, "");
VAR65[VAR69] = FUN50({VAR68: true, VAR7: VAR10});
emit FUN47(VAR69, VAR10);
}
function FUN53(address VAR69) external onlyOwner {
require(VAR65[VAR69].VAR68, "");
delete VAR65[VAR69];
emit FUN48(VAR69);
}
function FUN3(address VAR5) external onlyOwner {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(msg.sender, VAR12);
}
function FUN54(address VAR4) external view returns (bytes32) {
return VAR64[VAR4].VAR7;
}
function FUN55(address VAR69) external view returns (bytes32) {
return VAR65[VAR69].VAR7;
}
function FUN9(address VAR4) external view returns (bool) {
return VAR64[VAR4].VAR68;
}
function FUN9(address[] VAR70) external view returns (bool) {
for(uint VAR71 = 0; VAR71 < VAR70.VAR31; VAR71++) {
if (!VAR64[VAR70[VAR71]].VAR68) {
return false;
}
}
return true;
}
function FUN56(address VAR69) external view returns (bool) {
return VAR65[VAR69].VAR68;
}
}
contract VAR72 {
address public VAR73;
address public VAR61;
mapping (address => bool) public VAR74;
mapping (bytes4 => address) public VAR75;
uint public VAR64;
event FUN57(address indexed VAR66, bool value);
event FUN58(address indexed VAR66, bytes4 indexed VAR76);
event FUN59(address indexed VAR66, address indexed VAR77, uint indexed value, bytes VAR78);
event FUN60(uint indexed value, address indexed sender, bytes VAR78);
event FUN43(address VAR61);
modifier VAR79 {
require(VAR74[msg.sender], "");
VAR11;
}
function FUN1(address VAR80, address[] VAR70) external {
require(VAR61 == address(0) && VAR64 == 0, "");
require(VAR70.VAR31 > 0, "");
VAR61 = VAR80;
VAR64 = VAR70.VAR31;
for(uint256 VAR71 = 0; VAR71 < VAR70.VAR31; VAR71++) {
require(VAR74[VAR70[VAR71]] == false, "");
VAR74[VAR70[VAR71]] = true;
FUN61(VAR70[VAR71]).FUN1(this);
emit FUN57(VAR70[VAR71], true);
}
}
function FUN10(address VAR4, bool VAR34) external VAR79 {
if (VAR74[VAR4] != VAR34) {
if(VAR34 == true) {
VAR64 += 1;
VAR74[VAR4] = true;
FUN61(VAR4).FUN1(this);
}
else {
VAR64 -= 1;
require(VAR64 > 0, "");
delete VAR74[VAR4];
}
emit FUN57(VAR4, VAR34);
}
}
function FUN62(address VAR4, bytes4 VAR81) external VAR79 {
require(VAR74[VAR4], "");
VAR75[VAR81] = VAR4;
emit FUN58(VAR4, VAR81);
}
function FUN63(address VAR62) external VAR79 {
require(VAR62 != address(0), "");
VAR61 = VAR62;
emit FUN43(VAR62);
}
function FUN35(address VAR82, uint VAR34, bytes VAR22) external VAR79 {
require(VAR82.call.value(VAR34)(VAR22), "");
emit FUN59(msg.sender, VAR82, VAR34, VAR22);
}
function() public payable {
if(msg.VAR78.VAR31 > 0) {
address VAR66 = VAR75[msg.VAR83];
if(VAR66 == address(0)) {
emit FUN60(msg.value, msg.sender, msg.VAR78);
}
else {
require(VAR74[VAR66], "");
VAR44 {
FUN64(0, 0, FUN65())
let VAR84 := FUN66(VAR85, VAR66, 0, FUN65(), 0, 0)
FUN67(0, 0, FUN68())
switch VAR84
case 0 {revert(0, FUN68())}
default {return (0, FUN68())}
}
}
}
}
}
contract VAR86 {
modifier FUN69(BaseWallet VAR3) {
require(VAR3.FUN36(msg.sender), "");
VAR11;
}
}
contract GuardianStorage is VAR86 {
struct VAR87 {
address[] VAR88;
mapping (address => VAR89) VAR90;
uint256 VAR91;
address VAR92;
}
struct VAR89 {
bool VAR68;
uint128 VAR93;
}
mapping (address => VAR87) internal VAR94;
function FUN70(BaseWallet VAR3, address VAR95) external FUN69(VAR3) {
GuardianStorageConfig storage VAR96 = VAR94[VAR3];
VAR96.VAR90[VAR95].VAR68 = true;
VAR96.VAR90[VAR95].VAR93 = uint128(VAR96.VAR88.FUN71(VAR95) - 1);
}
function FUN72(BaseWallet VAR3, address VAR95) external FUN69(VAR3) {
GuardianStorageConfig storage VAR96 = VAR94[VAR3];
address VAR97 = VAR96.VAR88[VAR96.VAR88.VAR31 - 1];
if (VAR95 != VAR97) {
uint128 VAR98 = VAR96.VAR90[VAR95].VAR93;
VAR96.VAR88[VAR98] = VAR97;
VAR96.VAR90[VAR97].VAR93 = VAR98;
}
VAR96.VAR88.VAR31--;
delete VAR96.VAR90[VAR95];
}
function FUN73(BaseWallet VAR3) external view returns (uint256) {
return VAR94[VAR3].VAR88.VAR31;
}
function FUN74(BaseWallet VAR3) external view returns (address[]) {
GuardianStorageConfig storage VAR96 = VAR94[VAR3];
address[] memory VAR88 = new address[](VAR96.VAR88.VAR31);
for (uint256 VAR71 = 0; VAR71 < VAR96.VAR88.VAR31; VAR71++) {
VAR88[VAR71] = VAR96.VAR88[VAR71];
}
return VAR88;
}
function FUN75(BaseWallet VAR3, address VAR95) external view returns (bool) {
return VAR94[VAR3].VAR90[VAR95].VAR68;
}
function FUN76(BaseWallet VAR3, uint256 VAR99) external FUN69(VAR3) {
VAR94[VAR3].VAR91 = VAR99;
if(VAR99 != 0 && msg.sender != VAR94[VAR3].VAR92) {
VAR94[VAR3].VAR92 = msg.sender;
}
}
function FUN77(BaseWallet VAR3) external view returns (bool) {
return VAR94[VAR3].VAR91 > VAR100;
}
function FUN78(BaseWallet VAR3) external view returns (uint256) {
return VAR94[VAR3].VAR91;
}
function FUN79(BaseWallet VAR3) external view returns (address) {
return VAR94[VAR3].VAR92;
}
}
library VAR101 {
function FUN75(address[] VAR102, address VAR95) internal view returns (bool, address[]) {
if(VAR102.VAR31 == 0 || VAR95 == address(0)) {
return (false, VAR102);
}
bool VAR103 = false;
address[] memory VAR104 = new address[](VAR102.VAR31 - 1);
uint256 VAR93 = 0;
for (uint256 VAR71 = 0; VAR71 < VAR102.VAR31; VAR71++) {
if(!VAR103) {
if(VAR95 == VAR102[VAR71]) {
VAR103 = true;
continue;
}
if(FUN80(VAR102[VAR71]) && FUN81(VAR102[VAR71], VAR95)) {
VAR103 = true;
continue;
}
}
if(VAR93 < VAR104.VAR31) {
VAR104[VAR93] = VAR102[VAR71];
VAR93++;
}
}
return VAR103 ? (true, VAR104) : (false, VAR102);
}
function FUN80(address VAR13) internal view returns (bool) {
uint32 VAR105;
VAR44 {
VAR105 := FUN82(VAR13)
}
return (VAR105 > 0);
}
function FUN81(address VAR95, address VAR80) internal view returns (bool) {
address VAR61 = address(0);
bytes4 VAR83 = bytes4(FUN25(""));
VAR44 {
let VAR106 := FUN30(0x40)
FUN83(VAR106,VAR83)
let VAR84 := FUN66(5000, VAR95, VAR106, 0x20, VAR106, 0x20)
if FUN84(VAR84, 1) {
VAR61 := FUN30(VAR106)
}
}
return VAR61 == VAR80;
}
}
contract LockManager is VAR107, VAR108 {
bytes32 constant VAR109 = "";
GuardianStorage public VAR110;
uint256 public VAR111;
event FUN85(address indexed VAR8, uint64 VAR112);
event FUN86(address indexed VAR8);
modifier FUN87(BaseWallet VAR3) {
require(VAR110.FUN77(VAR3), "");
VAR11;
}
modifier FUN88(BaseWallet VAR3) {
require(!VAR110.FUN77(VAR3), "");
VAR11;
}
modifier FUN89(BaseWallet VAR3) {
(bool VAR113, ) = VAR101.FUN75(VAR110.FUN74(VAR3), msg.sender);
require(msg.sender == address(this) || VAR113, "");
VAR11;
}
constructor(ModuleRegistry VAR9, GuardianStorage VAR114, uint256 VAR115) FUN90(VAR9, VAR109) public {
VAR110 = VAR114;
VAR111 = VAR115;
}
function FUN91(BaseWallet VAR3) external FUN89(VAR3) FUN88(VAR3) {
VAR110.FUN76(VAR3, VAR100 + VAR111);
emit FUN85(VAR3, FUN92(VAR100 + VAR111));
}
function FUN93(BaseWallet VAR3) external FUN89(VAR3) FUN87(VAR3) {
address VAR92 = VAR110.FUN79(VAR3);
require(VAR92 == address(this), "");
VAR110.FUN76(VAR3, 0);
emit FUN86(VAR3);
}
function FUN78(BaseWallet VAR3) public view returns(uint64 VAR99) {
uint256 VAR116 = VAR110.FUN78(VAR3);
if(VAR116 > VAR100) {
VAR99 = FUN92(VAR116);
}
}
function FUN77(BaseWallet VAR3) external view returns (bool VAR117) {
return VAR110.FUN77(VAR3);
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
return FUN28(VAR3, VAR25);
}
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool) {
(bool VAR113, ) = VAR101.FUN75(VAR110.FUN74(VAR3), FUN29(VAR23, VAR24, 0));
return VAR113;
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256) {
return 1;
}
}
1
---------------------------------
109 0x7705faa34b16eb6d77dfc7812be2367ba6b0248e.sol
pragma VAR1 ^ 0.4.13;
contract VAR2 {
function FUN1(address VAR3, uint256 VAR4);
}
contract VAR5 {
struct VAR6 {
uint VAR7;
uint VAR8;
}
uint public VAR9;
address public VAR10;
uint public VAR11;
uint public VAR12;
uint public VAR13;
uint public VAR14;
uint public VAR15;
uint public VAR16;
mapping(address => VAR6) public VAR17;
mapping(uint => address) public VAR18;
uint public VAR19;
}
contract VAR20 {
address public VAR21;
address public VAR22;
address public VAR23;
address public VAR24;
function FUN2() payable {
VAR21 = msg.sender;
}
modifier onlyOwner {
require(VAR21 == msg.sender);
VAR25;
}
modifier VAR26 {
require(VAR21 == msg.sender || VAR23 == msg.sender);
VAR25;
}
modifier VAR27 {
require(VAR21 == msg.sender || VAR24 == msg.sender);
VAR25;
}
function FUN3(address VAR28) onlyOwner external {
require(VAR28 != 0);
VAR22 = VAR28;
}
function FUN4() external {
require(VAR22 == msg.sender);
VAR21 = VAR22;
delete VAR22;
}
function FUN5(address VAR29) onlyOwner external {
require(VAR29 != 0);
VAR23 = VAR29;
}
function FUN6(address VAR30) onlyOwner external {
require(VAR30 != 0);
VAR24 = VAR30;
}
}
contract VAR31 {
function FUN7(address VAR32, uint256 VAR4, bytes32[] VAR33) external;
}
contract VAR34 {
uint public VAR35;
function FUN8(address VAR36) constant returns(uint);
function transfer(address VAR37, uint value);
function FUN9(address VAR21, address VAR38) constant returns(uint);
function FUN10(address VAR39, address VAR37, uint value);
function FUN11(address VAR38, uint value);
event FUN12(address indexed VAR21, address indexed VAR38, uint value);
event Transfer(address indexed VAR39, address indexed VAR37, uint value);
}
contract VAR40 {
enum VAR41 {
VAR42,
VAR43,
VAR44,
VAR45,
VAR46,
VAR47
}
State public VAR14 = VAR41.VAR42;
event FUN13(State VAR48, State VAR49);
function FUN14(State VAR49) internal {
State VAR48 = VAR14;
VAR14 = VAR49;
FUN13(VAR48, VAR49);
}
}
contract Crowdsale is VAR20, VAR40 {
uint public VAR9;
address public VAR10;
uint public VAR11;
uint public VAR12;
uint public VAR13;
uint public VAR15;
uint public VAR16;
uint public VAR50 = 100000000000000000;
struct VAR6 {
uint VAR7;
uint VAR8;
}
struct VAR51 {
uint VAR52;
uint VAR53;
address VAR54;
}
mapping(bytes32 => VAR51) public VAR55;
mapping(address => VAR6) public VAR17;
mapping(uint => address) public VAR18;
uint public VAR19;
mapping(uint => address) public VAR56;
uint public VAR57;
function FUN15() payable FUN2() {}
function FUN16(address VAR58, uint VAR59) internal returns(uint VAR60);
function FUN17() internal;
function FUN18(address VAR61, uint VAR62) internal;
function() payable crowdsaleState limitNotExceeded VAR63 {
uint VAR64 = msg.value;
uint VAR65 = VAR64 * VAR9 / 1 VAR66;
if (VAR13 + VAR65 > VAR11) {
VAR65 = VAR11 - VAR13;
VAR64 = VAR65 * 1 VAR66 / VAR9;
uint VAR67 = msg.value - VAR64;
bool VAR68 = msg.sender.call.FUN19(3000000).value(VAR67)();
require(VAR68);
VAR13 = VAR11;
} else {
VAR13 += VAR65;
}
FUN20(msg.sender, VAR65, VAR64);
}
function FUN21(address VAR69, uint VAR70) external onlyOwner crowdsaleState limitNotExceeded VAR63 {
VAR13 += VAR70;
FUN20(VAR69, VAR70, 0);
}
function FUN22(address VAR69, uint VAR71, uint VAR72, bytes32 VAR73) external onlyOwnerOrBtcOracle crowdsaleState limitNotExceeded VAR63 {
uint VAR65 = VAR71 * VAR72 / 1 VAR66;
BtcDeposit storage VAR74 = VAR55[VAR73];
require(VAR74.VAR52 == 0);
VAR74.VAR52 = VAR71;
VAR74.VAR53 = VAR72;
VAR74.VAR54 = VAR69;
VAR13 += VAR65;
FUN20(VAR69, VAR65, 0);
}
function FUN20(address VAR58, uint VAR75, uint VAR76) internal {
var VAR77 = FUN16(VAR58, VAR75);
Investor storage VAR78 = VAR17[VAR58];
if (VAR78.VAR7 == 0) {
VAR18[VAR19++] = VAR58;
}
VAR78.VAR7 += VAR77;
if (VAR14 == VAR41.VAR45) {
VAR78.VAR8 += VAR76;
}
}
function FUN23(
address VAR79,
uint VAR80,
uint VAR81,
uint VAR82) external onlyOwner {
require(VAR14 == VAR41.VAR42);
VAR15 = VAR83;
VAR10 = VAR79;
VAR9 = VAR80;
VAR11 = VAR81;
VAR16 = VAR83 + VAR82 * 1 VAR84;
VAR13 = 0;
FUN14(VAR41.VAR43);
}
function FUN24() public onlyOwner {
require(VAR14 == VAR41.VAR43);
bool VAR68 = VAR10.call.FUN19(3000000).value(this.VAR85)();
require(VAR68);
FUN14(VAR41.VAR44);
}
function FUN25(
address VAR79,
uint VAR80,
uint VAR81,
uint VAR82,
uint VAR86) external onlyOwner {
require(VAR14 == VAR41.VAR44);
VAR15 = VAR83;
VAR10 = VAR79;
VAR9 = VAR80;
VAR11 = VAR81;
VAR16 = VAR83 + VAR82 * 1 VAR84;
VAR12 = VAR86;
VAR13 = 0;
FUN14(VAR41.VAR45);
}
function FUN26(uint VAR87) public {
require(VAR14 == VAR41.VAR45);
require(VAR83 >= VAR16 && VAR13 < VAR12);
while (VAR87 > 0 && VAR19 > 0) {
address VAR88 = VAR18[--VAR19];
Investor memory VAR78 = VAR17[VAR88];
FUN18(VAR88, VAR78.VAR7);
--VAR87;
delete VAR18[VAR19];
VAR56[VAR57] = VAR88;
VAR57++;
}
if (VAR19 > 0) {
return;
}
FUN14(VAR41.VAR47);
}
function FUN27(uint VAR87) public onlyOwner {
require(VAR14 == VAR41.VAR45);
require(VAR13 >= VAR12);
while (VAR87 > 0 && VAR19 > 0) {
--VAR19;
--VAR87;
delete VAR17[VAR18[VAR19]];
delete VAR18[VAR19];
}
if (VAR19 > 0) {
return;
}
FUN17();
bool VAR68 = VAR10.call.FUN19(3000000).value(this.VAR85)();
require(VAR68);
FUN14(VAR41.VAR46);
}
function FUN28(uint VAR80) external VAR26 {
VAR9 = VAR80;
}
function FUN29(address VAR79) external onlyOwner() {
require(VAR79 != 0);
VAR10 = VAR79;
}
function FUN30() external VAR89 {
FUN31(msg.sender);
}
function FUN32(uint VAR87) public VAR89 {
while (VAR87 > 0 && VAR57 > 0) {
address VAR88 = VAR56[--VAR57];
delete VAR56[VAR57];
--VAR87;
FUN31(VAR88);
}
}
function FUN33(address VAR69) public VAR89 {
FUN31(VAR69);
}
function FUN31(address VAR69) internal {
Investor memory VAR78 = VAR17[VAR69];
uint value = VAR78.VAR8;
if (value > 0) {
delete VAR17[VAR69];
require(VAR69.call.FUN19(3000000).value(value)());
}
}
function FUN34(uint VAR4) public onlyOwner {
require(VAR14 == VAR41.VAR43 || (VAR14 == VAR41.VAR45 && VAR13 > VAR12));
if (VAR4 == 0) {
VAR4 = this.VAR85;
}
bool VAR68 = VAR10.call.FUN19(3000000).value(VAR4)();
require(VAR68);
}
modifier VAR63 {
require(VAR83 < VAR16);
VAR25;
}
modifier VAR90 {
require(VAR13 < VAR11);
VAR25;
}
modifier VAR91 {
require(VAR14 == VAR41.VAR43 || VAR14 == VAR41.VAR45);
VAR25;
}
modifier VAR89 {
require(VAR14 == VAR41.VAR47);
VAR25;
}
modifier VAR92 {
require(VAR14 == VAR41.VAR46);
VAR25;
}
}
contract Token is VAR93, VAR34 {
mapping(address => uint) internal VAR94;
mapping(address => mapping(address => uint)) public VAR95;
uint8 public constant VAR96 = 8;
function FUN35() payable FUN15() {}
function FUN8(address VAR36) constant returns(uint) {
return VAR94[VAR36];
}
function transfer(address VAR69, uint VAR4) public VAR92 FUN36(2 * 32) {
require(VAR94[msg.sender] >= VAR4);
require(VAR94[VAR69] + VAR4 >= VAR94[VAR69]);
VAR94[msg.sender] -= VAR4;
VAR94[VAR69] += VAR4;
Transfer(msg.sender, VAR69, VAR4);
}
function FUN10(address VAR3, address VAR69, uint VAR4) public VAR92 FUN36(3 * 32) {
require(VAR94[VAR3] >= VAR4);
require(VAR94[VAR69] + VAR4 >= VAR94[VAR69]);
require(VAR95[VAR3][msg.sender] >= VAR4);
VAR94[VAR3] -= VAR4;
VAR94[VAR69] += VAR4;
VAR95[VAR3][msg.sender] -= VAR4;
Transfer(VAR3, VAR69, VAR4);
}
function FUN11(address VAR97, uint VAR4) public VAR92 {
VAR95[msg.sender][VAR97] = VAR4;
FUN12(msg.sender, VAR97, VAR4);
}
function FUN9(address VAR28, address VAR97) public constant VAR92 returns(uint VAR98) {
return VAR95[VAR28][VAR97];
}
modifier FUN36(uint VAR99) {
require(msg.VAR100.VAR101 >= VAR99 + 4);
VAR25;
}
}
contract MigratableToken is VAR102 {
function FUN37() payable FUN35() {}
bool VAR103 = false;
address public VAR104;
uint public VAR105;
address public VAR106;
mapping(address => bool) VAR107;
event FUN38(address indexed VAR39, address indexed VAR37, uint value);
function FUN39(address VAR61) external onlyOwner {
require(VAR61 != 0);
VAR106 = VAR61;
}
function FUN40() external onlyOwner {
require(VAR103 == false && VAR106 != 0);
PreArtexToken VAR108 = FUN41(VAR106);
VAR14 = VAR40.VAR41.VAR43;
VAR9 = VAR108.FUN42();
VAR10 = VAR108.FUN43();
VAR11 = VAR108.FUN44();
VAR12 = VAR108.FUN45();
VAR13 = VAR108.FUN46();
VAR15 = VAR108.FUN47();
VAR16 = VAR108.FUN48();
VAR103 = true;
}
function FUN49(uint VAR109) external onlyOwner {
require(VAR106 != 0);
PreArtexToken VAR108 = FUN41(VAR106);
uint VAR110 = VAR108.FUN50();
uint VAR111 = VAR19;
require(VAR111 < VAR110);
for (uint VAR112 = 0; VAR112 < VAR109; VAR112++) {
uint VAR113 = VAR111 + VAR112;
if (VAR113 < VAR110) {
address VAR54 = VAR108.FUN51(VAR113);
FUN52(VAR54, VAR108);
}
else
break;
}
}
function FUN53(address VAR61) external onlyOwner {
require(VAR106 != 0);
PreArtexToken VAR108 = FUN41(VAR106);
FUN52(VAR61, VAR108);
}
function FUN52(address VAR61, PreArtexToken VAR108) internal {
require(VAR14 != VAR41.VAR47 && VAR107[VAR61] == false);
FUN54 (VAR114, VAR115) = VAR108.FUN55(VAR61);
require(VAR114 > 0);
VAR94[VAR61] = VAR114;
VAR35 += VAR114;
VAR107[VAR61] = true;
if (VAR14 != VAR41.VAR46) {
Investor storage VAR54 = VAR17[VAR61];
VAR18[VAR19] = VAR61;
VAR19++;
VAR54.VAR7 += VAR114;
VAR54.VAR8 += VAR115;
}
Transfer(this, VAR61, VAR114);
}
function FUN56() external {
require(VAR104 != 0);
uint value = VAR94[msg.sender];
VAR94[msg.sender] -= value;
Transfer(msg.sender, this, value);
VAR35 -= value;
VAR105 += value;
FUN57(VAR104).FUN1(msg.sender, value);
FUN38(msg.sender, VAR104, value);
}
function FUN58(address VAR116) external onlyOwner {
require(VAR104 == 0);
VAR104 = VAR116;
}
}
contract ArtexToken is VAR117 {
string public constant VAR118 = "";
string public constant VAR119 = "";
mapping(address => bool) public VAR120;
function FUN59() payable FUN37() {}
function FUN16(address VAR58, uint VAR75) internal returns(uint VAR60) {
VAR60 = FUN60(VAR75);
require(VAR94[VAR58] + VAR60 > VAR94[VAR58]);
require(VAR60 > 0);
VAR94[VAR58] += VAR60;
VAR35 += VAR60;
Transfer(this, VAR58, VAR60);
}
function FUN60(uint VAR75) internal constant returns (uint) {
uint VAR121;
if (VAR14 == VAR41.VAR43) {
VAR121 = 130;
} else if (VAR14 == VAR41.VAR45) {
if (VAR75 < 1000 * 1 VAR66)
VAR121 = 100;
else if (VAR75 < 5000 * 1 VAR66)
VAR121 = 103;
else if (VAR75 < 10000 * 1 VAR66)
VAR121 = 105;
else if (VAR75 < 50000 * 1 VAR66)
VAR121 = 110;
else if (VAR75 < 100000 * 1 VAR66)
VAR121 = 115;
else
VAR121 = 120;
}
return (VAR75 * VAR121 * (10 ** uint(VAR96))) / (VAR50 * 100);
}
function FUN17() internal {
uint VAR60 = VAR35 * 100 / 74 - VAR35;
require(VAR94[VAR10] + VAR60 > VAR94[VAR10]);
require(VAR60 > 0);
VAR94[VAR10] += VAR60;
VAR35 += VAR60;
Transfer(this, VAR10, VAR60);
}
function FUN18(address VAR61, uint VAR62) internal {
VAR94[VAR61] -= VAR62;
VAR35 -= VAR62;
Transfer(VAR61, this, VAR62);
}
function FUN61(address VAR61) external onlyOwner {
require(VAR61 != 0);
VAR120[VAR61] = true;
}
function FUN62(address VAR61) external onlyOwner {
require(VAR61 != 0);
delete VAR120[VAR61];
}
function FUN63(address VAR69, uint256 VAR4, bytes32[] VAR33) external FUN64(VAR69) {
var VAR122 = FUN65(VAR69);
transfer(VAR69, VAR4);
VAR122.FUN7(msg.sender, VAR4, VAR33);
}
modifier FUN64(address VAR61) {
require(VAR120[VAR61] == true);
VAR25;
}
}
1
---------------------------------
110 0x7802ab7bb21da4dab4d7f8fefbbd278fc1068417.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
}
library VAR6 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
}
contract VAR7 {
address public VAR8;
function FUN12() {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR9;
}
function FUN13(address VAR10) onlyOwner {
require(VAR10 != address(0));
VAR8 = VAR10;
}
}
contract Haltable is VAR7 {
bool public VAR11;
modifier VAR12 {
if (VAR11) throw;
VAR9;
}
modifier VAR13 {
if (VAR11 && msg.sender != VAR8) throw;
VAR9;
}
modifier VAR14 {
if (!VAR11) throw;
VAR9;
}
function FUN14() external onlyOwner {
VAR11 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR11 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(address VAR17) public constant returns (bool) {
return false;
}
function FUN19(uint value, uint VAR18, uint VAR19, address VAR20, uint VAR21) public constant returns (uint VAR22);
}
contract VAR23 {
function FUN20() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN21();
}
contract VAR24 {
uint256 public VAR25;
function FUN22(address VAR26) constant returns (uint256);
function transfer(address VAR27, uint256 value) returns (bool);
event Transfer(address indexed VAR28, address indexed VAR27, uint256 value);
}
contract ERC20 is VAR24 {
function FUN23(address VAR8, address VAR29) constant returns (uint256);
function FUN24(address VAR28, address VAR27, uint256 value) returns (bool);
function FUN25(address VAR29, uint256 value) returns (bool);
event FUN26(address indexed VAR8, address indexed VAR29, uint256 value);
}
contract FractionalERC20 is VAR30 {
uint public VAR21;
}
contract Crowdsale is VAR31 {
uint public VAR32 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR33;
PricingStrategy public VAR34;
FinalizeAgent public VAR35;
address public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR19 = 0;
uint public VAR18 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
uint public VAR42 = 0;
uint public VAR43 = 0;
bool public VAR44;
bool public VAR45;
bool public VAR46;
address public VAR47;
mapping (address => uint256) public VAR48;
mapping (address => uint256) public VAR49;
mapping (address => bool) public VAR50;
uint public VAR51;
enum VAR52{VAR53, VAR54, VAR55, VAR56, VAR57, VAR58, VAR59, VAR60}
event FUN27(address VAR61, uint VAR62, uint VAR22, uint128 VAR63);
event FUN28(address VAR61, uint VAR62);
event FUN29(bool VAR64, bool VAR65, address VAR66);
event FUN30(address VAR67, bool VAR68);
event FUN31(uint VAR69);
function FUN32(address VAR70, PricingStrategy VAR71, address VAR72, uint VAR73, uint VAR74, uint VAR75) {
VAR8 = msg.sender;
VAR33 = FUN33(VAR70);
FUN34(VAR71);
VAR36 = VAR72;
if(VAR36 == 0) {
throw;
}
if(VAR73 == 0) {
throw;
}
VAR38 = VAR73;
if(VAR74 == 0) {
throw;
}
VAR39 = VAR74;
if(VAR38 >= VAR39) {
throw;
}
VAR37 = VAR75;
}
function() payable {
throw;
}
function FUN35(address VAR76, uint128 VAR63) stopInEmergency private {
if(FUN36() == VAR52.VAR55) {
if(!VAR50[VAR76]) {
throw;
}
} else if(FUN36() == VAR52.VAR56) {
} else {
throw;
}
uint VAR62 = msg.value;
uint VAR22 = VAR34.FUN19(VAR62, VAR18 - VAR40, VAR19, msg.sender, VAR33.FUN37());
if(VAR22 == 0) {
throw;
}
if(VAR48[VAR76] == 0) {
VAR41++;
}
VAR48[VAR76] = VAR48[VAR76].FUN11(VAR62);
VAR49[VAR76] = VAR49[VAR76].FUN11(VAR22);
VAR18 = VAR18.FUN11(VAR62);
VAR19 = VAR19.FUN11(VAR22);
if(VAR34.FUN18(VAR76)) {
VAR40 = VAR40.FUN11(VAR62);
}
if(FUN38(VAR62, VAR22, VAR18, VAR19)) {
throw;
}
FUN39(VAR76, VAR22);
if(!VAR36.FUN40(VAR62)) throw;
FUN27(VAR76, VAR62, VAR22, VAR63);
}
function FUN41(address VAR76, uint VAR77, uint VAR78) public onlyOwner {
uint VAR22 = VAR77 * 10**VAR33.FUN37();
uint VAR62 = VAR78 * VAR77;
VAR18 = VAR18.FUN11(VAR62);
VAR19 = VAR19.FUN11(VAR22);
VAR48[VAR76] = VAR48[VAR76].FUN11(VAR62);
VAR49[VAR76] = VAR49[VAR76].FUN11(VAR22);
FUN39(VAR76, VAR22);
FUN27(VAR76, VAR62, VAR22, 0);
}
function FUN42(address VAR67, uint128 VAR63, uint8 VAR79, bytes32 VAR80, bytes32 VAR81) public payable {
bytes32 VAR82 = FUN43(VAR67);
if (FUN44(VAR82, VAR79, VAR80, VAR81) != VAR47) throw;
if(VAR63 == 0) throw;
FUN35(VAR67, VAR63);
}
function FUN45(address VAR67, uint128 VAR63) public payable {
if(VAR46) throw;
if(VAR63 == 0) throw;
FUN35(VAR67, VAR63);
}
function FUN46(address VAR67) public payable {
if(VAR45) throw;
if(VAR46) throw;
FUN35(VAR67, 0);
}
function FUN47(uint128 VAR63, uint8 VAR79, bytes32 VAR80, bytes32 VAR81) public payable {
FUN42(msg.sender, VAR63, VAR79, VAR80, VAR81);
}
function FUN48(uint128 VAR63) public payable {
FUN45(msg.sender, VAR63);
}
function FUN49() public payable {
FUN46(msg.sender);
}
function FUN50() public FUN51(VAR52.VAR57) onlyOwner VAR12 {
if(VAR44) {
throw;
}
if(address(VAR35) != 0) {
VAR35.FUN21();
}
VAR44 = true;
}
function FUN52(FinalizeAgent VAR67) onlyOwner {
VAR35 = VAR67;
if(!VAR35.FUN20()) {
throw;
}
}
function FUN53(bool value) onlyOwner {
VAR45 = value;
FUN29(VAR45, VAR46, VAR47);
}
function FUN54(bool value, address VAR83) onlyOwner {
VAR46 = value;
VAR47 = VAR83;
FUN29(VAR45, VAR46, VAR47);
}
function FUN55(address VAR67, bool VAR68) onlyOwner {
VAR50[VAR67] = VAR68;
FUN30(VAR67, VAR68);
}
function FUN56(uint VAR84) onlyOwner {
if(VAR85 > VAR84) {
throw;
}
VAR39 = VAR84;
FUN31(VAR39);
}
function FUN34(PricingStrategy VAR71) onlyOwner {
VAR34 = VAR71;
if(!VAR34.FUN16()) {
throw;
}
}
function FUN57(address VAR67) public onlyOwner {
if(VAR41 > VAR32) {
throw;
}
VAR36 = VAR67;
}
function FUN58() public payable FUN51(VAR52.VAR58) {
if(msg.value == 0) throw;
VAR42 = VAR42.FUN11(msg.value);
}
function FUN59() public FUN51(VAR52.VAR60) {
uint256 VAR86 = VAR48[msg.sender];
if (VAR86 == 0) throw;
VAR48[msg.sender] = 0;
VAR43 = VAR43.FUN11(VAR86);
FUN28(msg.sender, VAR86);
if (!msg.sender.FUN40(VAR86)) throw;
}
function FUN60() public constant returns (bool VAR87) {
return VAR18 >= VAR37;
}
function FUN61() public constant returns (bool VAR88) {
return VAR35.FUN17();
}
function FUN62() public constant returns (bool VAR88) {
return VAR34.FUN17(address(this));
}
function FUN36() public constant returns (VAR52) {
if(VAR44) return VAR52.VAR59;
else if (address(VAR35) == 0) return VAR52.VAR54;
else if (!VAR35.FUN17()) return VAR52.VAR54;
else if (!VAR34.FUN17(address(this))) return VAR52.VAR54;
else if (VAR89.VAR90 < VAR38) return VAR52.VAR55;
else if (VAR89.VAR90 <= VAR39 && !FUN63()) return VAR52.VAR56;
else if (FUN60()) return VAR52.VAR57;
else if (!FUN60() && VAR18 > 0 && VAR42 >= VAR18) return VAR52.VAR60;
else return VAR52.VAR58;
}
function FUN64(uint VAR91) onlyOwner {
VAR51 = VAR91;
}
function FUN65() public constant returns (bool) {
return true;
}
//
//
modifier FUN51(State VAR92) {
if(FUN36() != VAR92) throw;
VAR9;
}
//
//
function FUN38(uint VAR62, uint VAR22, uint VAR93, uint VAR94) constant returns (bool VAR95);
function FUN63() public constant returns (bool);
function FUN39(address VAR76, uint VAR22) private;
}
contract StandardToken is VAR30, VAR1 {
event FUN66(address VAR76, uint VAR96);
mapping(address => uint) VAR97;
mapping (address => mapping (address => uint)) VAR98;
function FUN67() public constant returns (bool VAR99) {
return true;
}
function transfer(address VAR100, uint VAR101) returns (bool VAR102) {
VAR97[msg.sender] = FUN3(VAR97[msg.sender], VAR101);
VAR97[VAR100] = FUN4(VAR97[VAR100], VAR101);
Transfer(msg.sender, VAR100, VAR101);
return true;
}
function FUN24(address VAR103, address VAR100, uint VAR101) returns (bool VAR102) {
uint VAR104 = VAR98[VAR103][msg.sender];
VAR97[VAR100] = FUN4(VAR97[VAR100], VAR101);
VAR97[VAR103] = FUN3(VAR97[VAR103], VAR101);
VAR98[VAR103][msg.sender] = FUN3(VAR104, VAR101);
Transfer(VAR103, VAR100, VAR101);
return true;
}
function FUN22(address VAR105) constant returns (uint VAR106) {
return VAR97[VAR105];
}
function FUN25(address VAR107, uint VAR101) returns (bool VAR102) {
if ((VAR101 != 0) && (VAR98[msg.sender][VAR107] != 0)) throw;
VAR98[msg.sender][VAR107] = VAR101;
FUN26(msg.sender, VAR107, VAR101);
return true;
}
function FUN23(address VAR105, address VAR107) constant returns (uint VAR108) {
return VAR98[VAR105][VAR107];
}
}
contract PreICOProxyBuyer is VAR7, VAR31, VAR1 {
uint public VAR41;
uint public VAR18;
address[] public VAR109;
mapping(address => uint) public VAR97;
mapping(address => uint) public VAR110;
uint public VAR111;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
uint public VAR116;
uint public VAR117;
bool public VAR118;
Crowdsale public VAR16;
enum VAR52{VAR53, VAR56, VAR119, VAR60}
event FUN27(address VAR61, uint VAR62, uint VAR22, uint128 VAR63);
event FUN68(address VAR61, uint value);
event FUN69(uint VAR120);
event FUN70(address VAR61, uint VAR120);
function FUN71(address VAR105, uint VAR121, uint VAR122, uint VAR123, uint VAR124) {
VAR8 = VAR105;
if(VAR121 == 0) {
throw;
}
if(VAR122 == 0) {
throw;
}
if(VAR123 == 0) {
throw;
}
VAR112 = VAR122;
VAR113 = VAR123;
VAR114 = VAR124;
VAR111 = VAR121;
}
function FUN72() public constant returns(VAR125) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN73();
}
function FUN46(uint128 VAR63) private {
if(FUN36() != VAR52.VAR56) throw;
if(msg.value == 0) throw;
address VAR61 = msg.sender;
bool VAR126 = VAR97[VAR61] > 0;
VAR97[VAR61] = FUN4(VAR97[VAR61], msg.value);
if(VAR97[VAR61] < VAR112 || VAR97[VAR61] > VAR113) {
throw;
}
if(!VAR126) {
VAR109.FUN74(VAR61);
VAR41++;
}
VAR18 = FUN4(VAR18, msg.value);
if(VAR18 > VAR114) {
throw;
}
FUN27(VAR61, msg.value, 0, VAR63);
}
function FUN48(uint128 VAR63) public stopInEmergency payable {
FUN46(VAR63);
}
function FUN49() public stopInEmergency payable {
FUN46(0x0);
}
function FUN75() stopNonOwnersInEmergency public {
if(FUN36() != VAR52.VAR56) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR127.value(VAR18)(address(this));
VAR115 = FUN72().FUN22(address(this));
if(VAR115 == 0) {
throw;
}
FUN69(VAR115);
}
function FUN76(address VAR61) public constant returns (uint) {
if(FUN36() != VAR52.VAR119) {
throw;
}
return FUN1(VAR97[VAR61], VAR115) / VAR18;
}
function FUN77(address VAR61) public constant returns (uint) {
return FUN3(FUN76(VAR61), VAR110[VAR61]);
}
function FUN78() {
FUN79(FUN77(msg.sender));
}
function FUN79(uint VAR96) VAR12 {
address VAR61 = msg.sender;
if(VAR96 == 0) {
throw;
}
if(FUN77(VAR61) < VAR96) {
throw;
}
if(VAR110[VAR61] == 0) {
VAR116++;
}
VAR110[VAR61] = FUN4(VAR110[VAR61], VAR96);
VAR117 = FUN4(VAR117, VAR96);
FUN72().transfer(VAR61, VAR96);
FUN70(VAR61, VAR96);
}
function FUN59() VAR12 {
if(FUN36() != VAR52.VAR60) throw;
address VAR61 = msg.sender;
if(VAR97[VAR61] == 0) throw;
uint VAR96 = VAR97[VAR61];
delete VAR97[VAR61];
if(!(VAR61.call.value(VAR96)())) throw;
FUN68(VAR61, VAR96);
}
function FUN80(Crowdsale VAR128) public onlyOwner {
VAR16 = VAR128;
if(!VAR16.FUN65()) true;
}
function FUN81() public onlyOwner {
VAR118 = true;
}
function FUN58() public payable {
if(FUN36() != VAR52.VAR60) throw;
}
function FUN36() public returns(VAR52) {
if (VAR118)
return VAR52.VAR60;
if(VAR115 == 0) {
if(VAR85 >= VAR111) {
return VAR52.VAR60;
} else {
return VAR52.VAR56;
}
} else {
return VAR52.VAR119;
}
}
function FUN82() public constant returns (bool) {
return true;
}
function() payable {
throw;
}
}
1
---------------------------------
111 0x7998b7fcf30d4aed870635155cc62aa55be96f9a.sol
pragma VAR1 ^0.4.15;
contract VAR2 {
address VAR3;
modifier VAR4 {
if (VAR3 == msg.sender)
VAR5;
}
function FUN1() {
VAR3 = msg.sender;
}
function FUN2(address VAR6) external VAR4 {
VAR3 = VAR6;
}
function FUN3(address VAR7, uint VAR8, bytes VAR9) external onlyowner returns (bool){
return VAR7.call.value(VAR8)(VAR9);
}
function FUN4(address VAR7, uint VAR8) external onlyowner returns (bool){
return VAR7.FUN4(VAR8);
}
function FUN5() constant returns (address) {
return VAR3;
}
}
1
---------------------------------
112 0x79e784a77254aedbc6488ce0001abee487b1d88d.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 1 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
113 0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
address public VAR6;
Log VAR7;
modifier onlyOwner() {
require(VAR8.VAR9 == VAR6);
VAR10;
}
function FUN1()
{
VAR6 = msg.sender;
VAR7 = VAR11 FUN2();
}
function FUN3(address VAR12) onlyOwner
{
VAR7 = FUN2(VAR12);
}
function FUN4()
public
payable
{
if(msg.value >= VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR7.FUN5(msg.sender,msg.value,"");
}
}
function FUN6(uint VAR13)
{
if(VAR13<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR13)())
{
VAR3[msg.sender]-=VAR13;
VAR7.FUN5(msg.sender,VAR13,"");
}
}
}
function() public payable{}
}
contract VAR14
{
struct VAR15
{
address VAR16;
string  VAR17;
uint VAR18;
uint  VAR19;
}
VAR15[] public VAR20;
Message VAR21;
function FUN5(address VAR22,uint VAR23,string VAR24)
public
{
VAR21.VAR16 = VAR22;
VAR21.VAR19 = VAR25;
VAR21.VAR18 = VAR23;
VAR21.VAR17 = VAR24;
VAR20.FUN7(VAR21);
}
}
1
---------------------------------
114 0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 1 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
115 0x7b3c4d90e8af6030d66c07f8f815f9505e379d6f.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
address public VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
function FUN2() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR6;
}
function FUN3(address VAR5) onlyOwner public {
require(VAR5 != address(0));
FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract Destructible is VAR2 {
function FUN4() public payable { }
function FUN5() onlyOwner public {
FUN6(VAR3);
}
function FUN7(address VAR7) onlyOwner public {
FUN6(VAR7);
}
}
interface VAR8 {
function FUN8() public view returns (uint VAR9);
function FUN9(address VAR10) public view returns (uint VAR11);
function transfer(address VAR12, uint VAR13) public returns (bool VAR14);
function FUN10(address VAR15, address VAR12, uint VAR13) public returns (bool VAR14);
function FUN11(address VAR16, uint VAR13) public returns (bool VAR14);
function FUN12(address VAR10, address VAR16) public view returns (uint VAR17);
function FUN13() public view returns(uint VAR18);
event FUN14(address indexed VAR10, address indexed VAR16, uint VAR13);
}
contract BurnableErc20 is VAR8 {
function FUN15(uint value) external;
}
contract VAR19 {
function FUN16(
ERC20 VAR20,
uint VAR21,
ERC20 VAR22,
address VAR23,
uint VAR24,
uint VAR25,
address VAR26
)
public
payable
returns(uint);
}
contract Burner is VAR27 {
KyberNetwork public VAR28;
BurnableErc20 public VAR29;
function FUN17(address VAR30, address VAR31) public {
require(VAR30 != address(0));
require(VAR31 != address(0));
VAR29 = FUN18(VAR30);
VAR28 = FUN19(VAR31);
}
function() public payable { }
function FUN15(uint VAR32, uint VAR33, uint VAR34)
external
returns(uint)
{
uint VAR35 = address(this).VAR11;
if (VAR32 != 0 && VAR32 < VAR35) {
VAR35 = VAR32;
}
uint VAR24 = VAR33 != 0 ? VAR33 : 2**256 - 1;
uint VAR25 = VAR34 != 0 ? VAR34 : 1;
uint VAR36 = VAR28.VAR37.value(VAR35)(
FUN20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee),
VAR35,
FUN20(VAR29),
this,
VAR24,
VAR25,
0
);
VAR29.FUN15(VAR36);
return VAR36;
}
function FUN21(address VAR38)
external
onlyOwner
{
VAR28 = FUN19(VAR38);
}
}
1
---------------------------------
116 0x7b4629c804afe652e84123a31aedb9b52c7aae05.sol
pragma VAR1 ^0.4.25;
pragma VAR1 >=0.4.18;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) external payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) external payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) public payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) external payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) public payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) external payable returns (bytes32 VAR7);
function FUN7(string VAR5) public returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) public returns (uint VAR12);
function FUN8(byte VAR14) external;
function FUN9(uint VAR15) external;
function FUN10() external constant returns(bytes32);
}
contract VAR16 {
function FUN11() public returns (address VAR17);
}
library VAR18 {
struct VAR19 {
bytes VAR20;
uint VAR21;
}
function FUN12(buffer memory VAR20, uint VAR22) internal pure {
uint VAR21 = VAR22;
if(VAR21 % 32 != 0) VAR21 += 32 - (VAR21 % 32);
VAR20.VAR21 = VAR21;
VAR23 {
let VAR24 := FUN13(0x40)
FUN14(VAR20, VAR24)
FUN14(VAR24, 0)
FUN14(0x40, FUN15(VAR24, VAR21))
}
}
function FUN16(buffer memory VAR20, uint VAR21) private pure {
bytes memory VAR25 = VAR20.VAR20;
FUN12(VAR20, VAR21);
FUN17(VAR20, VAR25);
}
function FUN18(uint VAR26, uint VAR27) private pure returns(uint) {
if(VAR26 > VAR27) {
return VAR26;
}
return VAR27;
}
function FUN17(buffer memory VAR20, bytes VAR28) internal pure returns(buffer VAR29) {
if(VAR28.VAR30 + VAR20.VAR20.VAR30 > VAR20.VAR21) {
FUN16(VAR20, FUN18(VAR20.VAR21, VAR28.VAR30) * 2);
}
uint VAR31;
uint VAR32;
uint VAR33 = VAR28.VAR30;
VAR23 {
let VAR34 := FUN13(VAR20)
let VAR35 := FUN13(VAR34)
VAR31 := FUN15(FUN15(VAR34, VAR35), 32)
FUN14(VAR34, FUN15(VAR35, FUN13(VAR28)))
VAR32 := FUN15(VAR28, 32)
}
for(; VAR33 >= 32; VAR33 -= 32) {
VAR23 {
FUN14(VAR31, FUN13(VAR32))
}
VAR31 += 32;
VAR32 += 32;
}
uint VAR36 = 256 ** (32 - VAR33) - 1;
VAR23 {
let VAR37 := FUN19(FUN13(VAR32), FUN20(VAR36))
let VAR38 := FUN19(FUN13(VAR31), VAR36)
FUN14(VAR31, or(VAR38, VAR37))
}
return VAR20;
}
function FUN17(buffer memory VAR20, uint8 VAR28) internal pure {
if(VAR20.VAR20.VAR30 + 1 > VAR20.VAR21) {
FUN16(VAR20, VAR20.VAR21 * 2);
}
VAR23 {
let VAR34 := FUN13(VAR20)
let VAR35 := FUN13(VAR34)
let VAR31 := FUN15(FUN15(VAR34, VAR35), 32)
FUN21(VAR31, VAR28)
FUN14(VAR34, FUN15(VAR35, 1))
}
}
function FUN22(buffer memory VAR20, uint VAR28, uint VAR33) internal pure returns(buffer VAR29) {
if(VAR33 + VAR20.VAR20.VAR30 > VAR20.VAR21) {
FUN16(VAR20, FUN18(VAR20.VAR21, VAR33) * 2);
}
uint VAR36 = 256 ** VAR33 - 1;
VAR23 {
let VAR34 := FUN13(VAR20)
let VAR35 := FUN13(VAR34)
let VAR31 := FUN15(FUN15(VAR34, VAR35), VAR33)
FUN14(VAR31, or(FUN19(FUN13(VAR31), FUN20(VAR36)), VAR28))
FUN14(VAR34, FUN15(VAR35, VAR33))
}
return VAR20;
}
}
library VAR39 {
using Buffer for VAR18.VAR19;
uint8 private constant VAR40 = 0;
uint8 private constant VAR41 = 1;
uint8 private constant VAR42 = 2;
uint8 private constant VAR43 = 3;
uint8 private constant VAR44 = 4;
uint8 private constant VAR45 = 5;
uint8 private constant VAR46 = 7;
function FUN23(VAR18.buffer memory VAR20, uint8 VAR47, uint value) private pure {
if(value <= 23) {
VAR20.FUN17(uint8((VAR47 << 5) | value));
} else if(value <= 0xFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 24));
VAR20.FUN22(value, 1);
} else if(value <= 0xFFFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 25));
VAR20.FUN22(value, 2);
} else if(value <= 0xFFFFFFFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 26));
VAR20.FUN22(value, 4);
} else if(value <= 0xFFFFFFFFFFFFFFFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 27));
VAR20.FUN22(value, 8);
}
}
function FUN24(VAR18.buffer memory VAR20, uint8 VAR47) private pure {
VAR20.FUN17(uint8((VAR47 << 5) | 31));
}
function FUN25(VAR18.buffer memory VAR20, uint value) internal pure {
FUN23(VAR20, VAR40, value);
}
function FUN26(VAR18.buffer memory VAR20, int value) internal pure {
if(value >= 0) {
FUN23(VAR20, VAR40, uint(value));
} else {
FUN23(VAR20, VAR41, uint(-1 - value));
}
}
function FUN27(VAR18.buffer memory VAR20, bytes value) internal pure {
FUN23(VAR20, VAR42, value.VAR30);
VAR20.FUN17(value);
}
function FUN28(VAR18.buffer memory VAR20, string value) internal pure {
FUN23(VAR20, VAR43, bytes(value).VAR30);
VAR20.FUN17(bytes(value));
}
function FUN29(VAR18.buffer memory VAR20) internal pure {
FUN24(VAR20, VAR44);
}
function FUN30(VAR18.buffer memory VAR20) internal pure {
FUN24(VAR20, VAR45);
}
function FUN31(VAR18.buffer memory VAR20) internal pure {
FUN24(VAR20, VAR46);
}
}
contract VAR48 {
uint constant VAR49 = 60*60*24;
uint constant VAR50 = 60*60*24*7;
uint constant VAR51 = 60*60*24*30;
byte constant VAR52 = 0x00;
byte constant VAR53 = 0x10;
byte constant VAR54 = 0x30;
byte constant VAR55 = 0x40;
byte constant VAR56 = 0xF0;
byte constant VAR57 = 0x01;
uint8 constant VAR58 = 0;
uint8 constant VAR59 = 1;
uint8 constant VAR60 = 2;
uint8 constant VAR61 = 2;
uint8 constant VAR62 = 161;
OraclizeAddrResolverI VAR63;
OraclizeI VAR64;
modifier VAR65 {
if((address(VAR63)==0)||(FUN32(address(VAR63))==0))
FUN33(VAR58);
if(address(VAR64) != VAR63.FUN11())
VAR64 = FUN34(VAR63.FUN11());
VAR66;
}
modifier FUN35(string VAR67){
VAR64 = FUN34(VAR63.FUN11());
VAR66;
}
function FUN33(uint8 VAR68) internal returns(bool){
return FUN33();
VAR68;
}
function FUN33() internal returns(bool){
if (FUN32(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR63 = FUN36(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN37("");
return true;
}
if (FUN32(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR63 = FUN36(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN37("");
return true;
}
if (FUN32(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR63 = FUN36(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN37("");
return true;
}
if (FUN32(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR63 = FUN36(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN37("");
return true;
}
if (FUN32(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR63 = FUN36(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN32(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR63 = FUN36(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN32(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR63 = FUN36(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN38(bytes32 VAR69, string VAR70) public {
FUN38(VAR69, VAR70, VAR71 bytes(0));
}
function FUN38(bytes32 VAR69, string VAR70, bytes VAR72) public {
return;
VAR69; VAR70; VAR72;
}
function FUN39(string VAR73) oraclizeAPI internal returns (uint){
return VAR64.FUN7(VAR73);
}
function FUN39(string VAR73, uint VAR13) oraclizeAPI internal returns (uint){
return VAR64.FUN7(VAR73, VAR13);
}
function FUN40(string VAR73, string VAR74) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR80.value(VAR76)(0, VAR73, VAR74);
}
function FUN40(uint VAR81, string VAR73, string VAR74) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR80.value(VAR76)(VAR81, VAR73, VAR74);
}
function FUN40(uint VAR81, string VAR73, string VAR74, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR82.value(VAR76)(VAR81, VAR73, VAR74, VAR13);
}
function FUN40(string VAR73, string VAR74, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR82.value(VAR76)(0, VAR73, VAR74, VAR13);
}
function FUN40(string VAR73, string VAR83, string VAR84) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR85.value(VAR76)(0, VAR73, VAR83, VAR84);
}
function FUN40(uint VAR81, string VAR73, string VAR83, string VAR84) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR85.value(VAR76)(VAR81, VAR73, VAR83, VAR84);
}
function FUN40(uint VAR81, string VAR73, string VAR83, string VAR84, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR86.value(VAR76)(VAR81, VAR73, VAR83, VAR84, VAR13);
}
function FUN40(string VAR73, string VAR83, string VAR84, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR86.value(VAR76)(0, VAR73, VAR83, VAR84, VAR13);
}
function FUN40(string VAR73, string[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR89.value(VAR76)(0, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, string[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR89.value(VAR76)(VAR81, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, string[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR90.value(VAR76)(VAR81, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, string[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR90.value(VAR76)(0, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, string[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR89.value(VAR76)(0, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, bytes[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR89.value(VAR76)(VAR81, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, bytes[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR90.value(VAR76)(VAR81, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, bytes[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR90.value(VAR76)(0, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, bytes[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN43() oraclizeAPI internal returns (address){
return VAR64.FUN44();
}
function FUN45(byte VAR92) oraclizeAPI internal {
return VAR64.FUN8(VAR92);
}
function FUN46(uint VAR93) oraclizeAPI internal {
return VAR64.FUN9(VAR93);
}
function FUN47() oraclizeAPI internal returns (bytes32){
return VAR64.FUN10();
}
function FUN32(address VAR17) constant internal returns(uint VAR94) {
VAR23 {
VAR94 := FUN48(VAR17)
}
}
function FUN49(string VAR95) internal pure returns (address){
bytes memory VAR96 = bytes(VAR95);
uint160 VAR97 = 0;
uint160 VAR98;
uint160 VAR99;
for (uint VAR100=2; VAR100<2+2*20; VAR100+=2){
VAR97 *= 256;
VAR98 = FUN50(VAR96[VAR100]);
VAR99 = FUN50(VAR96[VAR100+1]);
if ((VAR98 >= 97)&&(VAR98 <= 102)) VAR98 -= 87;
else if ((VAR98 >= 65)&&(VAR98 <= 70)) VAR98 -= 55;
else if ((VAR98 >= 48)&&(VAR98 <= 57)) VAR98 -= 48;
if ((VAR99 >= 97)&&(VAR99 <= 102)) VAR99 -= 87;
else if ((VAR99 >= 65)&&(VAR99 <= 70)) VAR99 -= 55;
else if ((VAR99 >= 48)&&(VAR99 <= 57)) VAR99 -= 48;
VAR97 += (VAR98*16+VAR99);
}
return address(VAR97);
}
function FUN51(string VAR95, string VAR101) internal pure returns (int) {
bytes memory VAR26 = bytes(VAR95);
bytes memory VAR27 = bytes(VAR101);
uint VAR102 = VAR26.VAR30;
if (VAR27.VAR30 < VAR102) VAR102 = VAR27.VAR30;
for (uint VAR100 = 0; VAR100 < VAR102; VAR100 ++)
if (VAR26[VAR100] < VAR27[VAR100])
return -1;
else if (VAR26[VAR100] > VAR27[VAR100])
return 1;
if (VAR26.VAR30 < VAR27.VAR30)
return -1;
else if (VAR26.VAR30 > VAR27.VAR30)
return 1;
else
return 0;
}
function FUN52(string VAR103, string VAR104) internal pure returns (int) {
bytes memory VAR105 = bytes(VAR103);
bytes memory VAR106 = bytes(VAR104);
if(VAR105.VAR30 < 1 || VAR106.VAR30 < 1 || (VAR106.VAR30 > VAR105.VAR30))
return -1;
else if(VAR105.VAR30 > (2**128 -1))
return -1;
else
{
uint VAR107 = 0;
for (uint VAR100 = 0; VAR100 < VAR105.VAR30; VAR100 ++)
{
if (VAR105[VAR100] == VAR106[0])
{
VAR107 = 1;
while(VAR107 < VAR106.VAR30 && (VAR100 + VAR107) < VAR105.VAR30 && VAR105[VAR100 + VAR107] == VAR106[VAR107])
{
VAR107++;
}
if(VAR107 == VAR106.VAR30)
return int(VAR100);
}
}
return -1;
}
}
function FUN53(string VAR95, string VAR101, string VAR108, string VAR109, string VAR110) internal pure returns (string) {
bytes memory VAR111 = bytes(VAR95);
bytes memory VAR112 = bytes(VAR101);
bytes memory VAR113 = bytes(VAR108);
bytes memory VAR114 = bytes(VAR109);
bytes memory VAR115 = bytes(VAR110);
string memory VAR116 = VAR71 string(VAR111.VAR30 + VAR112.VAR30 + VAR113.VAR30 + VAR114.VAR30 + VAR115.VAR30);
bytes memory VAR117 = bytes(VAR116);
uint VAR118 = 0;
for (uint VAR100 = 0; VAR100 < VAR111.VAR30; VAR100++) VAR117[VAR118++] = VAR111[VAR100];
for (VAR100 = 0; VAR100 < VAR112.VAR30; VAR100++) VAR117[VAR118++] = VAR112[VAR100];
for (VAR100 = 0; VAR100 < VAR113.VAR30; VAR100++) VAR117[VAR118++] = VAR113[VAR100];
for (VAR100 = 0; VAR100 < VAR114.VAR30; VAR100++) VAR117[VAR118++] = VAR114[VAR100];
for (VAR100 = 0; VAR100 < VAR115.VAR30; VAR100++) VAR117[VAR118++] = VAR115[VAR100];
return string(VAR117);
}
function FUN53(string VAR95, string VAR101, string VAR108, string VAR109) internal pure returns (string) {
return FUN53(VAR95, VAR101, VAR108, VAR109, "");
}
function FUN53(string VAR95, string VAR101, string VAR108) internal pure returns (string) {
return FUN53(VAR95, VAR101, VAR108, "", "");
}
function FUN53(string VAR95, string VAR101) internal pure returns (string) {
return FUN53(VAR95, VAR101, "", "", "");
}
function FUN54(string VAR95) internal pure returns (uint) {
return FUN54(VAR95, 0);
}
function FUN54(string VAR95, uint VAR101) internal pure returns (uint) {
bytes memory VAR119 = bytes(VAR95);
uint VAR120 = 0;
bool VAR121 = false;
for (uint VAR100=0; VAR100<VAR119.VAR30; VAR100++){
if ((VAR119[VAR100] >= 48)&&(VAR119[VAR100] <= 57)){
if (VAR121){
if (VAR101 == 0) break;
else VAR101--;
}
VAR120 *= 10;
VAR120 += uint(VAR119[VAR100]) - 48;
} else if (VAR119[VAR100] == 46) VAR121 = true;
}
if (VAR101 > 0) VAR120 *= 10**VAR101;
return VAR120;
}
function FUN55(uint VAR100) internal pure returns (string){
if (VAR100 == 0) return "";
uint VAR122 = VAR100;
uint VAR33;
while (VAR122 != 0){
VAR33++;
VAR122 /= 10;
}
bytes memory VAR123 = VAR71 bytes(VAR33);
uint VAR118 = VAR33 - 1;
while (VAR100 != 0){
VAR123[VAR118--] = FUN56(48 + VAR100 % 10);
VAR100 /= 10;
}
return string(VAR123);
}
using CBOR for VAR18.VAR19;
function FUN41(string[] VAR124) internal pure returns (bytes) {
FUN57();
VAR18.buffer memory VAR20;
VAR18.FUN12(VAR20, 1024);
VAR20.FUN29();
for (uint VAR100 = 0; VAR100 < VAR124.VAR30; VAR100++) {
VAR20.FUN28(VAR124[VAR100]);
}
VAR20.FUN31();
return VAR20.VAR20;
}
function FUN42(bytes[] VAR124) internal pure returns (bytes) {
FUN57();
VAR18.buffer memory VAR20;
VAR18.FUN12(VAR20, 1024);
VAR20.FUN29();
for (uint VAR100 = 0; VAR100 < VAR124.VAR30; VAR100++) {
VAR20.FUN27(VAR124[VAR100]);
}
VAR20.FUN31();
return VAR20.VAR20;
}
string VAR125;
function FUN37(string VAR126) internal {
VAR125 = VAR126;
}
function FUN58() internal view returns (string) {
return VAR125;
}
function FUN59(uint VAR127, uint VAR128, uint VAR129) internal returns (bytes32){
require((VAR128 > 0) && (VAR128 <= 32));
VAR127 *= 10;
bytes memory VAR130 = VAR71 bytes(1);
VAR130[0] = FUN56(VAR128);
bytes memory VAR131 = VAR71 bytes(32);
bytes memory VAR132 = VAR71 bytes(32);
bytes32 VAR133 = FUN47();
VAR23 {
FUN14(VAR131, 0x20)
FUN14(FUN15(VAR131, 0x20), FUN60(FUN61(FUN62(VAR134, 1)), FUN60(VAR135, VAR81)))
FUN14(VAR132, 0x20)
FUN14(FUN15(VAR132, 0x20), VAR133)
}
bytes memory VAR136 = VAR71 bytes(32);
VAR23 {
FUN14(FUN15(VAR136, 0x20), VAR127)
}
bytes memory VAR137 = VAR71 bytes(8);
FUN63(VAR136, 24, 8, VAR137, 0);
bytes[4] memory VAR88 = [VAR131, VAR130, VAR132, VAR136];
bytes32 VAR138 = FUN40("", VAR88, VAR129);
bytes memory VAR139 = VAR71 bytes(8);
VAR23 {
let VAR140 := FUN13(FUN15(VAR137, 0x20))
FUN21(FUN15(VAR139, 0x27), FUN64(VAR140, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x26), FUN64(VAR140, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x25), FUN64(VAR140, 0x10000000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x24), FUN64(VAR140, 0x100000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x23), FUN64(VAR140, 0x1000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x22), FUN64(VAR140, 0x10000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x21), FUN64(VAR140, 0x100000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x20), FUN64(VAR140, 0x1000000000000000000000000000000000000000000000000))
}
FUN65(VAR138, FUN66(VAR139, VAR88[1], FUN67(VAR88[0]), VAR88[2]));
return VAR138;
}
function FUN65(bytes32 VAR138, bytes32 VAR141) internal {
VAR142[VAR138] = VAR141;
}
mapping(bytes32=>bytes32) VAR142;
mapping(bytes32=>bool) VAR143;
function FUN68(bytes32 VAR144, bytes VAR145, bytes VAR146) internal returns (bool){
bool VAR147;
address VAR148;
bytes32 VAR149;
bytes32 VAR150;
bytes memory VAR151 = VAR71 bytes(32);
uint VAR152 = 4+(uint(VAR145[3]) - 0x20);
VAR151 = FUN63(VAR145, VAR152, 32, VAR151, 0);
bytes memory VAR153 = VAR71 bytes(32);
VAR152 += 32 + 2;
VAR153 = FUN63(VAR145, VAR152+(uint(VAR145[VAR152-1]) - 0x20), 32, VAR153, 0);
VAR23 {
VAR149 := FUN13(FUN15(VAR151, 32))
VAR150 := FUN13(FUN15(VAR153, 32))
}
(VAR147, VAR148) = FUN69(VAR144, 27, VAR149, VAR150);
if (address(FUN66(VAR146)) == VAR148) return true;
else {
(VAR147, VAR148) = FUN69(VAR144, 28, VAR149, VAR150);
return (address(FUN66(VAR146)) == VAR148);
}
}
function FUN70(bytes VAR72, uint VAR154) internal returns (bool) {
bool VAR147;
bytes memory VAR155 = VAR71 bytes(uint(VAR72[VAR154+1])+2);
FUN63(VAR72, VAR154, VAR155.VAR30, VAR155, 0);
bytes memory VAR156 = VAR71 bytes(64);
FUN63(VAR72, 3+1, 64, VAR156, 0);
bytes memory VAR157 = VAR71 bytes(1+65+32);
VAR157[0] = FUN56(1);
FUN63(VAR72, VAR154-65, 65, VAR157, 1);
bytes memory VAR158 = VAR159"";
FUN63(VAR158, 0, 32, VAR157, 1+65);
VAR147 = FUN68(FUN67(VAR157), VAR155, VAR156);
if (VAR147 == false) return false;
bytes memory VAR160 = VAR159"";
bytes memory VAR161 = VAR71 bytes(1+65);
VAR161[0] = 0xFE;
FUN63(VAR72, 3, 65, VAR161, 1);
bytes memory VAR162 = VAR71 bytes(uint(VAR72[3+65+1])+2);
FUN63(VAR72, 3+65, VAR162.VAR30, VAR162, 0);
VAR147 = FUN68(FUN67(VAR161), VAR162, VAR160);
return VAR147;
}
modifier FUN71(bytes32 VAR163, string VAR164, bytes VAR165) {
require((VAR165[0] == "") && (VAR165[1] == "") && (VAR165[2] == 1));
bool VAR166 = FUN72(VAR165, VAR163, bytes(VAR164), FUN58());
require(VAR166);
VAR66;
}
function FUN73(bytes32 VAR163, string VAR164, bytes VAR165) internal returns (uint8){
if ((VAR165[0] != "")||(VAR165[1] != "")||(VAR165[2] != 1)) return 1;
bool VAR166 = FUN72(VAR165, VAR163, bytes(VAR164), FUN58());
if (VAR166 == false) return 2;
return 0;
}
function FUN74(bytes32 VAR167, bytes VAR168, uint VAR169) internal pure returns (bool){
bool VAR170 = true;
require(VAR168.VAR30 == VAR169);
for (uint256 VAR100=0; VAR100< VAR169; VAR100++) {
if (VAR167[VAR100] != VAR168[VAR100]) VAR170 = false;
}
return VAR170;
}
function FUN72(bytes VAR72, bytes32 VAR138, bytes VAR70, string VAR171) internal returns (bool){
uint VAR172 = 3+65+(uint(VAR72[3+65+1])+2)+32;
bytes memory VAR173 = VAR71 bytes(32);
FUN63(VAR72, VAR172, 32, VAR173, 0);
if (!(FUN66(VAR173) == FUN66(FUN67(VAR171, VAR138)))) return false;
bytes memory VAR174 = VAR71 bytes(uint(VAR72[VAR172+(32+8+1+32)+1])+2);
FUN63(VAR72, VAR172+(32+8+1+32), VAR174.VAR30, VAR174, 0);
if (!FUN74(FUN67(VAR174), VAR70, uint(VAR72[VAR172+32+8]))) return false;
bytes memory VAR175 = VAR71 bytes(8+1+32);
FUN63(VAR72, VAR172+32, 8+1+32, VAR175, 0);
bytes memory VAR176 = VAR71 bytes(64);
uint VAR154 = VAR172+32+(8+1+32)+VAR174.VAR30+65;
FUN63(VAR72, VAR154-64, 64, VAR176, 0);
bytes32 VAR177 = FUN67(VAR176);
if (VAR142[VAR138] == FUN66(VAR175, VAR177)){
delete VAR142[VAR138];
} else return false;
bytes memory VAR178 = VAR71 bytes(32+8+1+32);
FUN63(VAR72, VAR172, 32+8+1+32, VAR178, 0);
if (!FUN68(FUN67(VAR178), VAR174, VAR176)) return false;
if (VAR143[VAR177] == false){
VAR143[VAR177] = FUN70(VAR72, VAR154);
}
return VAR143[VAR177];
}
function FUN63(bytes VAR179, uint VAR180, uint VAR30, bytes VAR181, uint VAR182) internal pure returns (bytes) {
uint VAR102 = VAR30 + VAR182;
require(VAR181.VAR30 >= VAR102);
uint VAR100 = 32 + VAR180;
uint VAR122 = 32 + VAR182;
while (VAR100 < (32 + VAR180 + VAR30)) {
VAR23 {
let VAR96 := FUN13(FUN15(VAR179, VAR100))
FUN14(FUN15(VAR181, VAR122), VAR96)
}
VAR100 += 32;
VAR122 += 32;
}
return VAR181;
}
function FUN69(bytes32 VAR183, uint8 VAR184, bytes32 VAR185, bytes32 VAR186) internal returns (bool, address) {
bool VAR187;
address VAR188;
VAR23 {
let VAR189 := FUN13(0x40)
FUN14(VAR189, VAR183)
FUN14(FUN15(VAR189, 32), VAR184)
FUN14(FUN15(VAR189, 64), VAR185)
FUN14(FUN15(VAR189, 96), VAR186)
VAR187 := call(3000, 1, 0, VAR189, 128, VAR189, 32)
VAR188 := FUN13(VAR189)
}
return (VAR187, VAR188);
}
function FUN75(bytes32 VAR183, bytes VAR190) internal returns (bool, address) {
bytes32 VAR185;
bytes32 VAR186;
uint8 VAR184;
if (VAR190.VAR30 != 65)
return (false, 0);
VAR23 {
VAR185 := FUN13(FUN15(VAR190, 32))
VAR186 := FUN13(FUN15(VAR190, 64))
VAR184 := FUN56(0, FUN13(FUN15(VAR190, 96)))
}
//
if (VAR184 < 27)
VAR184 += 27;
if (VAR184 != 27 && VAR184 != 28)
return (false, 0);
return FUN69(VAR183, VAR184, VAR185, VAR186);
}
function FUN57() internal pure {
VAR23 {
let VAR191 := FUN13(0x40)
FUN76(VAR191, VAR192, FUN62(VAR193, VAR191))
}
}
}
library VAR194 {
function FUN77(uint256 VAR26, uint256 VAR27) internal pure returns (uint256 VAR195) {
if (VAR26 == 0) return 0;
VAR195 = VAR26 * VAR27;
assert(VAR195 / VAR26 == VAR27);
return VAR195;
}
function FUN64(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
return VAR26 / VAR27;
}
function FUN62(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
assert(VAR27 <= VAR26);
return VAR26 - VAR27;
}
function FUN15(uint256 VAR26, uint256 VAR27) internal pure returns (uint256 VAR195) {
VAR195 = VAR26 + VAR27;
assert(VAR195 >= VAR26);
return VAR195;
}
}
contract SmartMining_Mining is VAR48 {
using SafeMath for uint256;
struct VAR196 {
bytes32 VAR138;
uint256 VAR197;
uint256 VAR198;
}
OraclizeQuery public VAR199;
address public VAR200;
uint256 public VAR201;
string  public VAR202;
address public VAR203;
address public VAR204;
constructor(address VAR205) public {
require(VAR205 != 0x0);
VAR200 = VAR205;
emit FUN78(VAR200);
VAR202 = "FUN79(VAR206:
emit FUN80(VAR202);
FUN45(VAR53 | VAR57);
}
event FUN78(address indexed VAR207);
event FUN81(address indexed VAR203);
event FUN82(address indexed VAR204);
event FUN80(string VAR202);
event FUN83(uint256 VAR93);
event FUN84(uint256 VAR208, uint256 VAR209, uint256 VAR93, bytes32 VAR138, uint256 VAR210);
event FUN85(bytes32 VAR138);
event FUN86(address indexed VAR179, uint256 value);
event FUN87(address indexed VAR211, uint256 value);
event FUN88(bytes32 VAR138, string VAR197, bytes VAR72);
event FUN89(address indexed VAR211, uint256 VAR212, uint256 VAR198, uint256 VAR197, bytes32 VAR138);
event FUN90(address indexed VAR211, uint256 VAR213, bytes32 VAR138);
modifier onlyOwner () {
require( msg.sender == VAR200 );
VAR66;
}
function FUN91 (address VAR214) external onlyOwner {
if( VAR214 != 0x0 ) {  VAR200 = VAR214; } else { VAR200 = msg.sender; }
emit FUN78(VAR200);
}
function FUN92 (string VAR215) external onlyOwner {
VAR202 = VAR215;
emit FUN80(VAR202);
}
function FUN93 (uint256 VAR216) external onlyOwner {
VAR201 = VAR216.FUN77(10**9);
emit FUN83( VAR201 );
FUN46( VAR201 );
}
function FUN94 (address VAR217) external onlyOwner {
VAR203 = VAR217;
emit FUN81(VAR203);
}
function FUN95 (address VAR218) external onlyOwner {
VAR204 = VAR218;
emit FUN82(VAR204);
}
function FUN96 (uint256 VAR219, uint256 VAR220) external onlyOwner {
uint256 VAR221 = FUN39("", VAR220);
require( VAR221 < address(this).VAR222 && VAR221 < 800 VAR223 );
bytes32 VAR138 = FUN40("", VAR202, VAR220);
emit FUN84(VAR219, VAR220, VAR201, VAR138, VAR221);
VAR199 = FUN97({
VAR138: VAR138,
VAR197: 0,
VAR198: VAR219
});
}
function FUN98 (bytes32 VAR163) external onlyOwner {
require( VAR163 == VAR199.VAR138 );
emit FUN85(VAR199.VAR138);
delete VAR199;
}
function FUN99 () external onlyOwner {
require( address(this).VAR222 > 0 );
require( VAR203 != 0x0 );
emit FUN87(VAR203, address(this).VAR222);
require( VAR203.call.FUN100( FUN101() ).value( address(this).VAR222 )() );
}
function () external payable {
emit FUN86(msg.sender, msg.value);
}
function FUN38(bytes32 VAR163, string VAR224) public {
FUN38(VAR163, VAR224, VAR71 bytes(0));
}
function FUN38 (bytes32 VAR163, string VAR224, bytes VAR72) public {
require( msg.sender == FUN43() );
require( VAR163 == VAR199.VAR138 );
require( VAR204 != 0x0 && VAR203 != 0x0 );
emit FUN88(VAR163, VAR224, VAR72);
VAR199.VAR197 = FUN54(VAR224, 2);
uint256 VAR225 = VAR199.VAR198.FUN77(10**20).FUN64( VAR199.VAR197 );
emit FUN89(VAR204, VAR225, VAR199.VAR198, VAR199.VAR197, VAR163);
emit FUN90(VAR203, address(this).VAR222, VAR163);
delete VAR199;
VAR204.transfer( VAR225 );
require( VAR203.call.FUN100( FUN101() ).value( address(this).VAR222 )(bytes4(FUN66(""))) );
}
}
1
---------------------------------
117 0x7bc51b19abe2cfb15d58f845dad027feab01bfa0.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR3)
throw;
VAR4;
}
modifier protected() {
if(msg.sender != address(this))
throw;
VAR4;
}
function FUN2(address VAR5) public onlyOwner {
if (VAR5 == address(0))
throw;
VAR3 = VAR5;
}
}
contract DividendDistributor is VAR2{
event Transfer(
uint VAR6,
bytes32 VAR7,
address VAR8,
address VAR9
);
struct VAR10 {
uint VAR11;
uint VAR12;
}
mapping(address => VAR10) VAR13;
uint public VAR14;
uint public VAR15;
uint public VAR16;
function FUN3() public{
VAR14 = 0.4 VAR17;
}
function FUN4(uint VAR6, bytes32 VAR7, address VAR8, address VAR9) protected
{
if(! VAR8.call.value(VAR6)() )
throw;
Transfer(VAR6, VAR7, VAR8, VAR9);
}
function FUN5() public payable {
if (msg.value >= VAR14)
{
VAR13[msg.sender].VAR11 += msg.value;
VAR15 += msg.value;
VAR13[msg.sender].VAR12 = VAR16;
}
}
function FUN6(uint VAR6) public {
if ( VAR13[msg.sender].VAR11 == 0 || VAR6 == 0)
throw;
VAR13[msg.sender].VAR11 -= VAR6;
VAR15 -= VAR6;
this.FUN4(VAR6, "", msg.sender, VAR3);
}
function FUN7() constant public returns(uint VAR18) {
uint VAR12 = VAR13[msg.sender].VAR12;
if (VAR16 > VAR12)
throw;
VAR18 = (VAR16 - VAR12) * VAR13[msg.sender].VAR11 / VAR15;
}
function FUN8() constant public returns(uint VAR11) {
VAR11 = VAR13[msg.sender].VAR11;
}
function FUN9() public {
uint VAR18 = FUN7();
if (VAR18 == 0)
throw;
VAR13[msg.sender].VAR12 = VAR16;
this.FUN4(VAR18, "", msg.sender, VAR3);
}
function FUN10() public payable onlyOwner {
VAR16 += msg.value;
}
function FUN11(address VAR8, uint VAR6) public onlyOwner {
this.FUN4(VAR6, "", VAR8, VAR3);
}
function FUN12(uint VAR6) public onlyOwner {
VAR14 = VAR6;
}
function () public payable onlyOwner {
}
function FUN13() public onlyOwner {
FUN14(msg.sender);
}
}
1
---------------------------------
118 0x7c4393ee129d7856b5bd765c2d20b66f464ccd0f.sol
pragma VAR1 ^0.4.13;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
function FUN6() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract Crowdsale is VAR6 {
using SafeMath for uint256;
uint256 public VAR11;
uint256 public VAR12;
WhitelistedGateway public VAR13;
PendingContributions public VAR14;
bool VAR15 = false;
bool VAR16 = true;
uint256 VAR17;
function FUN8(bool VAR18) public onlyOwner {
VAR16 = VAR18;
}
function FUN9(bool VAR18) public onlyOwner {
VAR15 = VAR18;
}
function FUN10(uint256 VAR19, uint256 VAR20, address VAR21, Whitelist VAR22, uint256 VAR23) public {
require(VAR20 >= VAR19);
require(VAR21 != address(0));
VAR11 = VAR19;
VAR12 = VAR20;
VAR17 = VAR23;
VAR13 = VAR24 FUN11(VAR22, VAR21);
VAR14 = VAR24 FUN12(VAR13);
VAR13.FUN13(VAR14);
}
function () external payable {
require(FUN14());
FUN15();
}
function FUN15() internal {
if(VAR13.FUN16(msg.sender)) {
VAR13.VAR25.value(msg.value)(msg.sender);
return;
}
VAR14.VAR25.value(msg.value)(msg.sender);
}
function FUN14() internal view returns (bool) {
bool VAR26 = VAR27 >= VAR11 && VAR27 <= VAR12;
bool VAR28 = msg.value >= VAR17;
bool VAR29 = VAR13.FUN16(msg.sender);
return !VAR15 && VAR26 && VAR28 && (VAR16 || VAR29);
}
function FUN17() public view returns (bool) {
return VAR27 > VAR12;
}
}
contract PendingContributions is VAR6 {
using SafeMath for uint256;
mapping(address=>uint256) public VAR30;
WhitelistedGateway public VAR13;
event FUN18(address VAR31, uint256 value, uint256 VAR32);
event FUN19(address VAR31, uint256 value, uint256 VAR32);
event FUN20(address VAR31, uint256 value, uint256 VAR32);
function FUN12(WhitelistedGateway VAR33) public {
VAR13 = VAR33;
}
modifier FUN21(address VAR31) {
require(VAR13.FUN16(VAR31));
VAR10;
}
function FUN22(address VAR31) payable public onlyOwner {
VAR30[VAR31] += msg.value;
FUN18(VAR31, msg.value, VAR27);
}
function FUN23() public {
uint256 VAR34 = VAR30[msg.sender];
require(VAR34 > 0);
VAR30[msg.sender] = 0;
msg.sender.transfer(VAR34);
FUN20(msg.sender, VAR34, VAR27);
}
function FUN24(address VAR31) public FUN21(VAR31) {
uint256 VAR34 = VAR30[VAR31];
require(VAR34 > 0);
VAR13.VAR25.value(VAR34)(VAR31);
VAR30[VAR31] = 0;
FUN19(VAR31, VAR34, VAR27);
}
}
contract Whitelist is VAR6 {
using SafeMath for uint256;
mapping(address=>bool) public VAR35;
event FUN25(address VAR36, uint VAR32);
event FUN26(address VAR36, uint VAR32);
function FUN27(address VAR36) public onlyOwner {
VAR35[VAR36] = true;
FUN25(VAR36, VAR27);
}
function FUN28(address VAR36) public onlyOwner {
VAR35[VAR36] = false;
FUN26(VAR36, VAR27);
}
function FUN29(address[50] VAR37) public onlyOwner {
for(uint VAR38 = 0; VAR38 < VAR37.VAR39; VAR38++) {
FUN27(VAR37[VAR38]);
}
}
function FUN16(address VAR36) public view returns(bool) {
return VAR35[VAR36];
}
}
contract VAR40 {
using SafeMath for uint256;
mapping(address=>bool) public VAR41;
mapping(address=>uint) public VAR30;
address public VAR42;
Whitelist public VAR35;
event FUN30(address VAR31, uint256 VAR43, uint256 VAR32);
modifier FUN31() {
require(VAR41[msg.sender]);
VAR10;
}
function FUN13(address VAR9) public VAR44 {
VAR41[VAR9] = true;
}
function FUN11(Whitelist VAR22, address VAR21) public {
VAR35 = VAR22;
VAR42 = VAR21;
VAR41[msg.sender] = true;
}
function FUN16(address VAR36) public view returns(bool) {
return VAR35.FUN16(VAR36);
}
function FUN22(address VAR31) public payable VAR44 {
VAR30[VAR31] += msg.value;
VAR42.transfer(msg.value);
FUN30(VAR31, msg.value, VAR27);
}
}
1
---------------------------------
119 0x7e03b8f86b9cfade0328a4a2c7588a659972129b.sol
pragma VAR1 ^0.4.21;
pragma VAR1 ^0.4.18;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) external payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) external payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) public payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) external payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) public payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) external payable returns (bytes32 VAR7);
function FUN7(string VAR5) public returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) public returns (uint VAR12);
function FUN8(byte VAR14) external;
function FUN9(uint VAR15) external;
function FUN10() external constant returns(bytes32);
}
contract VAR16 {
function FUN11() public returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x20;
byte constant VAR25 = 0x30;
byte constant VAR26 = 0xF0;
byte constant VAR27 = 0x01;
uint8 constant VAR28 = 0;
uint8 constant VAR29 = 1;
uint8 constant VAR30 = 2;
uint8 constant VAR31 = 2;
uint8 constant VAR32 = 161;
OraclizeAddrResolverI VAR33;
OraclizeI VAR34;
modifier VAR35 {
if((address(VAR33)==0)||(FUN12(address(VAR33))==0))
FUN13(VAR28);
if(address(VAR34) != VAR33.FUN11())
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
modifier FUN15(string VAR37){
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
function FUN13(uint8 VAR38) internal returns(bool){
return FUN13();
VAR38;
}
function FUN13() internal returns(bool){
if (FUN12(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR33 = FUN16(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN17("");
return true;
}
if (FUN12(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR33 = FUN16(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN17("");
return true;
}
if (FUN12(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR33 = FUN16(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN17("");
return true;
}
if (FUN12(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR33 = FUN16(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN17("");
return true;
}
if (FUN12(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR33 = FUN16(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN12(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR33 = FUN16(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN12(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR33 = FUN16(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN18(bytes32 VAR39, string VAR40) public {
FUN18(VAR39, VAR40, VAR41 bytes(0));
}
function FUN18(bytes32 VAR39, string VAR40, bytes VAR42) public {
return;
VAR39; VAR40; VAR42;
}
function FUN19(string VAR43) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43);
}
function FUN19(string VAR43, uint VAR13) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43, VAR13);
}
function FUN20(string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(0, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(VAR51, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(VAR51, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(0, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(0, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(VAR51, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(VAR51, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(0, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN23() oraclizeAPI internal returns (address){
return VAR34.FUN24();
}
function FUN25(byte VAR62) oraclizeAPI internal {
return VAR34.FUN8(VAR62);
}
function FUN26(uint VAR63) oraclizeAPI internal {
return VAR34.FUN9(VAR63);
}
function FUN27() oraclizeAPI internal returns (bytes32){
return VAR34.FUN10();
}
function FUN12(address VAR17) constant internal returns(uint VAR64) {
VAR65 {
VAR64 := FUN28(VAR17)
}
}
function FUN29(string VAR66) internal pure returns (address){
bytes memory VAR67 = bytes(VAR66);
uint160 VAR68 = 0;
uint160 VAR69;
uint160 VAR70;
for (uint VAR71=2; VAR71<2+2*20; VAR71+=2){
VAR68 *= 256;
VAR69 = FUN30(VAR67[VAR71]);
VAR70 = FUN30(VAR67[VAR71+1]);
if ((VAR69 >= 97)&&(VAR69 <= 102)) VAR69 -= 87;
else if ((VAR69 >= 65)&&(VAR69 <= 70)) VAR69 -= 55;
else if ((VAR69 >= 48)&&(VAR69 <= 57)) VAR69 -= 48;
if ((VAR70 >= 97)&&(VAR70 <= 102)) VAR70 -= 87;
else if ((VAR70 >= 65)&&(VAR70 <= 70)) VAR70 -= 55;
else if ((VAR70 >= 48)&&(VAR70 <= 57)) VAR70 -= 48;
VAR68 += (VAR69*16+VAR70);
}
return address(VAR68);
}
function FUN31(string VAR66, string VAR72) internal pure returns (int) {
bytes memory VAR73 = bytes(VAR66);
bytes memory VAR74 = bytes(VAR72);
uint VAR75 = VAR73.VAR76;
if (VAR74.VAR76 < VAR75) VAR75 = VAR74.VAR76;
for (uint VAR71 = 0; VAR71 < VAR75; VAR71 ++)
if (VAR73[VAR71] < VAR74[VAR71])
return -1;
else if (VAR73[VAR71] > VAR74[VAR71])
return 1;
if (VAR73.VAR76 < VAR74.VAR76)
return -1;
else if (VAR73.VAR76 > VAR74.VAR76)
return 1;
else
return 0;
}
function FUN32(string VAR77, string VAR78) internal pure returns (int) {
bytes memory VAR79 = bytes(VAR77);
bytes memory VAR80 = bytes(VAR78);
if(VAR79.VAR76 < 1 || VAR80.VAR76 < 1 || (VAR80.VAR76 > VAR79.VAR76))
return -1;
else if(VAR79.VAR76 > (2**128 -1))
return -1;
else
{
uint VAR81 = 0;
for (uint VAR71 = 0; VAR71 < VAR79.VAR76; VAR71 ++)
{
if (VAR79[VAR71] == VAR80[0])
{
VAR81 = 1;
while(VAR81 < VAR80.VAR76 && (VAR71 + VAR81) < VAR79.VAR76 && VAR79[VAR71 + VAR81] == VAR80[VAR81])
{
VAR81++;
}
if(VAR81 == VAR80.VAR76)
return int(VAR71);
}
}
return -1;
}
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83, string VAR84) internal pure returns (string) {
bytes memory VAR85 = bytes(VAR66);
bytes memory VAR86 = bytes(VAR72);
bytes memory VAR87 = bytes(VAR82);
bytes memory VAR88 = bytes(VAR83);
bytes memory VAR89 = bytes(VAR84);
string memory VAR90 = VAR41 string(VAR85.VAR76 + VAR86.VAR76 + VAR87.VAR76 + VAR88.VAR76 + VAR89.VAR76);
bytes memory VAR91 = bytes(VAR90);
uint VAR92 = 0;
for (uint VAR71 = 0; VAR71 < VAR85.VAR76; VAR71++) VAR91[VAR92++] = VAR85[VAR71];
for (VAR71 = 0; VAR71 < VAR86.VAR76; VAR71++) VAR91[VAR92++] = VAR86[VAR71];
for (VAR71 = 0; VAR71 < VAR87.VAR76; VAR71++) VAR91[VAR92++] = VAR87[VAR71];
for (VAR71 = 0; VAR71 < VAR88.VAR76; VAR71++) VAR91[VAR92++] = VAR88[VAR71];
for (VAR71 = 0; VAR71 < VAR89.VAR76; VAR71++) VAR91[VAR92++] = VAR89[VAR71];
return string(VAR91);
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, VAR83, "");
}
function FUN33(string VAR66, string VAR72, string VAR82) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, "", "");
}
function FUN33(string VAR66, string VAR72) internal pure returns (string) {
return FUN33(VAR66, VAR72, "", "", "");
}
function FUN34(string VAR66) internal pure returns (uint) {
return FUN34(VAR66, 0);
}
function FUN34(string VAR66, uint VAR72) internal pure returns (uint) {
bytes memory VAR93 = bytes(VAR66);
uint VAR94 = 0;
bool VAR95 = false;
for (uint VAR71=0; VAR71<VAR93.VAR76; VAR71++){
if ((VAR93[VAR71] >= 48)&&(VAR93[VAR71] <= 57)){
if (VAR95){
if (VAR72 == 0) break;
else VAR72--;
}
VAR94 *= 10;
VAR94 += uint(VAR93[VAR71]) - 48;
} else if (VAR93[VAR71] == 46) VAR95 = true;
}
if (VAR72 > 0) VAR94 *= 10**VAR72;
return VAR94;
}
function FUN35(uint VAR71) internal pure returns (string){
if (VAR71 == 0) return "";
uint VAR96 = VAR71;
uint VAR97;
while (VAR96 != 0){
VAR97++;
VAR96 /= 10;
}
bytes memory VAR98 = VAR41 bytes(VAR97);
uint VAR92 = VAR97 - 1;
while (VAR71 != 0){
VAR98[VAR92--] = FUN36(48 + VAR71 % 10);
VAR71 /= 10;
}
return string(VAR98);
}
function FUN21(string[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
function FUN22(bytes[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
string VAR109;
function FUN17(string VAR110) internal {
VAR109 = VAR110;
}
function FUN37() internal view returns (string) {
return VAR109;
}
function FUN38(uint VAR111, uint VAR112, uint VAR113) internal returns (bytes32){
require((VAR112 > 0) && (VAR112 <= 32));
VAR111 *= 10;
bytes memory VAR114 = VAR41 bytes(1);
VAR114[0] = FUN36(VAR112);
bytes memory VAR115 = VAR41 bytes(32);
bytes memory VAR116 = VAR41 bytes(32);
bytes32 VAR117 = FUN27();
VAR65 {
FUN39(VAR115, 0x20)
FUN39(FUN40(VAR115, 0x20), FUN41(FUN42(FUN43(VAR118, 1)), FUN41(VAR119, VAR51)))
FUN39(VAR116, 0x20)
FUN39(FUN40(VAR116, 0x20), VAR117)
}
bytes memory VAR120 = VAR41 bytes(32);
VAR65 {
FUN39(FUN40(VAR120, 0x20), VAR111)
}
bytes memory VAR121 = VAR41 bytes(8);
FUN44(VAR120, 24, 8, VAR121, 0);
bytes[4] memory VAR58 = [VAR115, VAR114, VAR116, VAR120];
bytes32 VAR122 = FUN20("", VAR58, VAR113);
bytes memory VAR123 = VAR41 bytes(8);
VAR65 {
let VAR106 := FUN45(FUN40(VAR121, 0x20))
FUN46(FUN40(VAR123, 0x27), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x26), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x25), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x24), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x23), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x22), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x21), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x20), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000))
}
FUN48(VAR122, FUN49(VAR123, VAR58[1], FUN50(VAR58[0]), VAR58[2]));
return VAR122;
}
function FUN48(bytes32 VAR122, bytes32 VAR124) internal {
VAR125[VAR122] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN51(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR41 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN44(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR41 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN44(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR65 {
VAR132 := FUN45(FUN40(VAR134, 32))
VAR133 := FUN45(FUN40(VAR136, 32))
}
(VAR130, VAR131) = FUN52(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN52(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN53(bytes VAR42, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR41 bytes(uint(VAR42[VAR137+1])+2);
FUN44(VAR42, VAR137, VAR138.VAR76, VAR138, 0);
bytes memory VAR139 = VAR41 bytes(64);
FUN44(VAR42, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR41 bytes(1+65+32);
VAR140[0] = FUN36(1);
FUN44(VAR42, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN44(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN51(FUN50(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR41 bytes(1+65);
VAR144[0] = 0xFE;
FUN44(VAR42, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR41 bytes(uint(VAR42[3+65+1])+2);
FUN44(VAR42, 3+65, VAR145.VAR76, VAR145, 0);
VAR130 = FUN51(FUN50(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN54(bytes32 VAR146, string VAR147, bytes VAR148) {
require((VAR148[0] == "") && (VAR148[1] == "") && (VAR148[2] == 1));
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
require(VAR149);
VAR36;
}
function FUN56(bytes32 VAR146, string VAR147, bytes VAR148) internal returns (uint8){
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) return 1;
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
if (VAR149 == false) return 2;
return 0;
}
function FUN57(bytes32 VAR150, bytes VAR151, uint VAR152) internal pure returns (bool){
bool VAR153 = true;
require(VAR151.VAR76 == VAR152);
for (uint256 VAR71=0; VAR71< VAR152; VAR71++) {
if (VAR150[VAR71] != VAR151[VAR71]) VAR153 = false;
}
return VAR153;
}
function FUN55(bytes VAR42, bytes32 VAR122, bytes VAR40, string VAR154) internal returns (bool){
uint VAR155 = 3+65+(uint(VAR42[3+65+1])+2)+32;
bytes memory VAR156 = VAR41 bytes(32);
FUN44(VAR42, VAR155, 32, VAR156, 0);
if (!(FUN49(VAR156) == FUN49(FUN50(VAR154, VAR122)))) return false;
bytes memory VAR157 = VAR41 bytes(uint(VAR42[VAR155+(32+8+1+32)+1])+2);
FUN44(VAR42, VAR155+(32+8+1+32), VAR157.VAR76, VAR157, 0);
if (!FUN57(FUN50(VAR157), VAR40, uint(VAR42[VAR155+32+8]))) return false;
bytes memory VAR158 = VAR41 bytes(8+1+32);
FUN44(VAR42, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR41 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR76+65;
FUN44(VAR42, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN50(VAR159);
if (VAR125[VAR122] == FUN49(VAR158, VAR160)){
delete VAR125[VAR122];
} else return false;
bytes memory VAR161 = VAR41 bytes(32+8+1+32);
FUN44(VAR42, VAR155, 32+8+1+32, VAR161, 0);
if (!FUN51(FUN50(VAR161), VAR157, VAR159)) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN53(VAR42, VAR137);
}
return VAR126[VAR160];
}
function FUN44(bytes VAR162, uint VAR163, uint VAR76, bytes VAR164, uint VAR165) internal pure returns (bytes) {
uint VAR75 = VAR76 + VAR165;
require(VAR164.VAR76 >= VAR75);
uint VAR71 = 32 + VAR163;
uint VAR96 = 32 + VAR165;
while (VAR71 < (32 + VAR163 + VAR76)) {
VAR65 {
let VAR67 := FUN45(FUN40(VAR162, VAR71))
FUN39(FUN40(VAR164, VAR96), VAR67)
}
VAR71 += 32;
VAR96 += 32;
}
return VAR164;
}
function FUN52(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR65 {
let VAR172 := FUN45(0x40)
FUN39(VAR172, VAR166)
FUN39(FUN40(VAR172, 32), VAR167)
FUN39(FUN40(VAR172, 64), VAR168)
FUN39(FUN40(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN45(VAR172)
}
return (VAR170, VAR171);
}
function FUN58(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR76 != 65)
return (false, 0);
VAR65 {
VAR168 := FUN45(FUN40(VAR173, 32))
VAR169 := FUN45(FUN40(VAR173, 64))
VAR167 := FUN36(0, FUN45(FUN40(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN52(VAR166, VAR167, VAR168, VAR169);
}
}
contract VAR174 {
uint256 public VAR175;
uint256 public VAR176;
function FUN59(address VAR177) public;
function FUN60() payable public;
function FUN61() public view returns(uint256);
}
contract VAR178 {
function FUN62(uint256 VAR179, address VAR180) public;
function FUN63() payable public;
function FUN64(uint256 VAR181) public;
function FUN65() public view returns(uint256);
}
contract VAR182 {
function FUN66() constant public returns (uint VAR183);
function FUN67(address VAR184) constant public returns (uint VAR185);
function transfer(address VAR186, uint VAR187) public returns (bool VAR188);
function FUN68(address VAR189, address VAR186, uint VAR187) public returns (bool VAR188);
function FUN69(address VAR190, uint VAR187) public returns (bool VAR188);
function FUN70(address VAR184, address VAR190) constant public returns (uint VAR191);
event Transfer(address indexed VAR189, address indexed VAR186, uint VAR187);
event FUN71(address indexed VAR184, address indexed VAR190, uint VAR187);
}
contract EOSBetBankroll is VAR182, VAR178 {
using SafeMath for *;
address public VAR192;
uint256 public VAR193;
uint256 public VAR194;
uint256 public VAR175;
mapping(address => bool) public VAR195;
address public VAR196;
address public VAR197;
mapping(address => uint256) VAR198;
string public constant VAR199 = "";
string public constant VAR200 = "";
uint8 public constant VAR95 = 18;
uint256 public VAR201;
mapping(address => uint256) public VAR202;
mapping(address => mapping(address => uint256)) public VAR203;
event FUN72(address VAR204, uint256 VAR205, uint256 VAR206);
event FUN73(address VAR204, uint256 VAR207, uint256 VAR208);
event FUN74(address VAR209, uint256 VAR210);
modifier FUN75(address VAR211){
require(VAR195[VAR211]);
VAR36;
}
function FUN76(address VAR212, address VAR213) public payable {
require (msg.value > 0);
VAR192 = msg.sender;
uint256 VAR214 = msg.value * 100;
VAR202[msg.sender] = VAR214;
VAR201 = VAR214;
emit Transfer(0x0, msg.sender, VAR214);
VAR195[VAR212] = true;
VAR195[VAR213] = true;
VAR196 = VAR212;
VAR197 = VAR213;
VAR194 = 0 VAR215;
VAR193 = 500 VAR47;
}
function FUN77(address VAR216) view public returns(uint256){
return VAR198[VAR216];
}
function FUN65() view public returns(uint256){
return VAR217.FUN43(address(this).VAR185, VAR175);
}
function FUN62(uint256 VAR179, address VAR180) public FUN75(msg.sender){
if (! VAR180.FUN78(VAR179)){
emit FUN74(VAR180, VAR179);
if (! VAR192.FUN78(VAR179)){
emit FUN74(VAR192, VAR179);
}
}
}
function FUN63() payable public FUN75(msg.sender){
}
function FUN64(uint256 VAR181) public FUN75(msg.sender){
FUN79(msg.sender).VAR218.value(VAR181)();
}
function () public payable {
uint256 VAR219 = VAR217.FUN43(FUN65(), msg.value);
uint256 VAR220 = VAR193;
require(VAR219 < VAR220 && msg.value != 0);
uint256 VAR221 = VAR201;
uint256 VAR222;
bool VAR223;
uint256 VAR224;
uint256 VAR225;
if (VAR217.FUN40(VAR219, msg.value) > VAR220){
VAR223 = true;
VAR222 = VAR217.FUN43(VAR220, VAR219);
VAR224 = VAR217.FUN43(msg.value, VAR222);
}
else {
VAR222 = msg.value;
}
if (VAR221 != 0){
VAR225 = VAR217.FUN80(VAR222, VAR221) / VAR219;
}
else {
VAR225 = VAR217.FUN80(VAR222, 100);
}
VAR201 = VAR217.FUN40(VAR221, VAR225);
VAR202[msg.sender] = VAR217.FUN40(VAR202[msg.sender], VAR225);
VAR198[msg.sender] = VAR226.VAR51;
if (VAR223){
msg.sender.transfer(VAR224);
}
emit FUN72(msg.sender, VAR222, VAR225);
emit Transfer(0x0, msg.sender, VAR225);
}
function FUN81(uint256 VAR227) public {
uint256 VAR228 = VAR202[msg.sender];
require(VAR227 <= VAR228
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR227 > 0);
uint256 VAR219 = FUN65();
uint256 VAR221 = VAR201;
uint256 VAR229 = VAR217.FUN80(VAR227, VAR219) / VAR221;
uint256 VAR230 = VAR229 / 100;
uint256 VAR231 = VAR217.FUN43(VAR229, VAR230);
VAR201 = VAR217.FUN43(VAR221, VAR227);
VAR202[msg.sender] = VAR217.FUN43(VAR228, VAR227);
VAR175 = VAR217.FUN40(VAR175, VAR230);
msg.sender.transfer(VAR231);
emit FUN73(msg.sender, VAR231, VAR227);
emit Transfer(msg.sender, 0x0, VAR227);
}
function FUN82() public {
FUN81(VAR202[msg.sender]);
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN84(uint256 VAR233) public {
require (msg.sender == VAR192 && VAR233 <= 6048000);
VAR194 = VAR233;
}
function FUN85(uint256 VAR234) public {
require(msg.sender == VAR192);
VAR193 = VAR234;
}
function FUN86(address VAR235) public {
require(msg.sender == VAR192);
FUN79(VAR196).FUN59(VAR235);
FUN79(VAR197).FUN59(VAR235);
uint256 VAR236 = VAR175;
VAR175 = 0;
VAR235.transfer(VAR236);
}
function FUN87() public {
require(msg.sender == VAR192);
FUN88(msg.sender);
}
function FUN66() constant public returns(uint){
return VAR201;
}
function FUN67(address VAR184) constant public returns(uint){
return VAR202[VAR184];
}
function transfer(address VAR186, uint256 VAR187) public returns (bool VAR188){
if (VAR202[msg.sender] >= VAR187
&& VAR187 > 0
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)){
VAR202[msg.sender] = VAR217.FUN43(VAR202[msg.sender], VAR187);
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
emit Transfer(msg.sender, VAR186, VAR187);
return true;
}
else {
return false;
}
}
function FUN68(address VAR189, address VAR186, uint VAR187) public returns(bool){
if (VAR203[VAR189][msg.sender] >= VAR187
&& VAR202[VAR189] >= VAR187
&& VAR187 > 0
&& VAR198[VAR189] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)){
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
VAR202[VAR189] = VAR217.FUN43(VAR202[VAR189], VAR187);
VAR203[VAR189][msg.sender] = VAR217.FUN43(VAR203[VAR189][msg.sender], VAR187);
emit Transfer(VAR189, VAR186, VAR187);
return true;
}
else {
return false;
}
}
function FUN69(address VAR190, uint VAR187) public returns(bool){
if(VAR187 > 0){
VAR203[msg.sender][VAR190] = VAR187;
emit FUN71(msg.sender, VAR190, VAR187);
return true;
}
else {
return false;
}
}
function FUN70(address VAR184, address VAR190) constant public returns(uint){
return VAR203[VAR184][VAR190];
}
}
library VAR217 {
function FUN80(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
if (VAR73 == 0) {
return 0;
}
uint256 VAR237 = VAR73 * VAR74;
assert(VAR237 / VAR73 == VAR74);
return VAR237;
}
function FUN47(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR237 = VAR73 / VAR74;
return VAR237;
}
function FUN43(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
assert(VAR74 <= VAR73);
return VAR73 - VAR74;
}
function FUN40(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR237 = VAR73 + VAR74;
assert(VAR237 >= VAR73);
return VAR237;
}
}
contract EOSBetDice is VAR18, VAR174 {
using SafeMath for *;
event FUN89(bytes32 indexed VAR238);
event FUN90(bytes32 indexed VAR238);
event FUN91(bytes32 indexed VAR238, uint256 VAR239);
event FUN92(uint16 VAR240, uint256 VAR241, uint256 VAR242, uint256 VAR243, uint256 VAR244);
event FUN93(bytes32 indexed VAR238, uint16 VAR240, uint256 VAR241, uint256 VAR242, uint256 VAR243, uint256 VAR244);
struct VAR245 {
address VAR246;
bool VAR247;
uint256 VAR248;
uint256 VAR249;
uint256 VAR250;
uint16 VAR251;
uint8 VAR252;
}
mapping (bytes32 => VAR245) public VAR253;
uint256 public VAR176;
uint256 public VAR175;
uint256 public VAR254;
uint256 public VAR255;
uint256 public VAR256;
uint256 public VAR257;
uint256 public VAR258;
uint256 public VAR259;
uint256 public VAR260;
uint8 public VAR261;
uint8 public VAR262;
bool public VAR263;
bool public VAR264;
address public VAR192;
address public VAR265;
function FUN94() public {
FUN25(VAR25);
FUN26(10000000000);
VAR259 = 10000000000;
VAR260 = 225000;
VAR254 = 0;
VAR255 = 0;
VAR263 = false;
VAR264 = true;
VAR256 = 6 VAR266;
VAR257 = 350 VAR267;
VAR258 = 5 VAR267;
VAR261 = 5;
VAR262 = 35;
VAR192 = msg.sender;
}
function FUN59(address VAR177) public {
require(msg.sender == VAR265);
uint256 VAR268 = VAR175;
VAR175 = 0;
VAR177.transfer(VAR268);
}
function FUN60() payable public {
require(msg.sender == VAR265);
}
function FUN61() public view returns(uint256){
return (VAR217.FUN80(FUN95(VAR265).FUN65(), VAR262) / 1000);
}
function FUN96(address VAR269) public {
require(msg.sender == VAR192 && VAR265 == address(0));
require(FUN95(VAR269).FUN65() != 0);
VAR265 = VAR269;
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN97(uint256 VAR270) public {
require(msg.sender == VAR192);
VAR256 = VAR270;
}
function FUN98(uint256 VAR63) public {
require(msg.sender == VAR192);
VAR259 = VAR63;
FUN26(VAR63);
}
function FUN99(uint256 VAR271) public {
require(msg.sender == VAR192);
VAR260 = VAR271;
}
function FUN100(bool VAR272) public {
require(msg.sender == VAR192);
VAR263 = VAR272;
}
function FUN101(bool VAR273) public {
require(msg.sender == VAR192);
VAR264 = VAR273;
}
function FUN102(uint8 VAR274) public {
require(msg.sender == VAR192 && VAR274 <= 50);
VAR261 = VAR274;
}
function FUN103(uint256 VAR275) public {
require(msg.sender == VAR192);
VAR257 = VAR275;
}
function FUN104(uint256 VAR275) public {
require(msg.sender == VAR192 && VAR275 > 1000);
VAR258 = VAR275;
}
function FUN105(uint8 VAR276) public {
require(msg.sender == VAR192 && VAR276 <= 50);
VAR262 = VAR276;
}
function FUN87() public {
require(msg.sender == VAR192);
FUN88(msg.sender);
}
function FUN106(bytes32 VAR238) public {
DiceGameData memory VAR277 = VAR253[VAR238];
require(VAR226.VAR51 - VAR277.VAR248 >= VAR256
&& (msg.sender == VAR192 || msg.sender == VAR277.VAR246)
&& (!VAR277.VAR247)
&& VAR176 >= VAR277.VAR249
&& VAR277.VAR249 > 0
&& VAR264);
VAR253[VAR238].VAR247 = true;
VAR176 = VAR217.FUN43(VAR176, VAR277.VAR249);
VAR277.VAR246.transfer(VAR277.VAR249);
emit FUN91(VAR238, VAR277.VAR249);
}
function FUN107(uint256 VAR250, uint16 VAR251, uint8 VAR252) public payable {
require(!VAR263
&& msg.value > 0
&& VAR250 >= VAR258
&& VAR251 > 0
&& VAR251 <= 1024
&& VAR250 <= msg.value
&& VAR252 > 1
&& VAR252 < 100
&& (VAR217.FUN80(VAR250, 100) / (VAR252 - 1)) <= FUN61());
if (VAR250 < VAR257) {
bytes32 VAR278 = VAR226.FUN42(VAR226.VAR118);
uint8 VAR274 = VAR261;
uint256 VAR279 = msg.value;
uint256[] memory VAR280 = new uint256[](4);
uint256 VAR281;
uint16 VAR282;
uint256 VAR283 = VAR217.FUN80(VAR217.FUN80(VAR250, 100), (1000 - VAR274)) / (VAR252 - 1) / 1000;
while (VAR282 < VAR251 && VAR279 >= VAR250){
if (uint8(uint256(FUN49(VAR278, VAR282)) % 100) + 1 < VAR252){
VAR281 = VAR283;
if (VAR282 <= 255){
VAR280[0] += uint256(2) ** (255 - VAR282);
}
else if (VAR282 <= 511){
VAR280[1] += uint256(2) ** (511 - VAR282);
}
else if (VAR282 <= 767){
VAR280[2] += uint256(2) ** (767 - VAR282);
}
else {
VAR280[3] += uint256(2) ** (1023 - VAR282);
}
}
else {
VAR281 = 1;
}
VAR282++;
VAR279 = VAR217.FUN43(VAR217.FUN40(VAR279, VAR281), VAR250);
}
VAR255 += VAR282;
VAR254 = VAR217.FUN40(VAR254, VAR217.FUN80(VAR250, VAR282));
uint256 VAR230 = VAR217.FUN80(VAR217.FUN80(VAR250, VAR274), VAR282) / 5000;
VAR175 = VAR217.FUN40(VAR175, VAR230);
FUN95(VAR265).VAR284.value(VAR217.FUN43(msg.value, VAR230))();
FUN95(VAR265).FUN62(VAR279, msg.sender);
emit FUN92(VAR282, VAR280[0], VAR280[1], VAR280[2], VAR280[3]);
}
else {
bytes32 VAR238;
FUN95(VAR265).FUN64(FUN19('', VAR260 + (uint256(1005) * VAR251)));
VAR238 = FUN38(0, 30, VAR260 + (uint256(1005) * VAR251));
VAR253[VAR238] = FUN108({
VAR246 : msg.sender,
VAR247 : false,
VAR248 : VAR226.VAR51,
VAR249 : msg.value,
VAR250 : VAR250,
VAR251 : VAR251,
VAR252 : VAR252
});
VAR176 = VAR217.FUN40(VAR176, msg.value);
emit FUN89(VAR238);
}
}
function FUN18(bytes32 VAR146, string VAR147, bytes VAR148) public {
DiceGameData memory VAR277 = VAR253[VAR146];
require(msg.sender == FUN23()
&& !VAR277.VAR247
&& VAR277.VAR246 != address(0)
&& VAR176 >= VAR277.VAR249);
if (FUN56(VAR146, VAR147, VAR148) != 0){
if (VAR264){
VAR253[VAR146].VAR247 = true;
VAR176 = VAR217.FUN43(VAR176, VAR277.VAR249);
VAR277.VAR246.transfer(VAR277.VAR249);
emit FUN91(VAR146, VAR277.VAR249);
}
emit FUN90(VAR146);
}
else {
uint8 VAR274 = VAR261;
uint256 VAR279 = VAR277.VAR249;
uint256[] memory VAR280 = new uint256[](4);
uint256 VAR281;
uint16 VAR282;
uint256 VAR283 = VAR217.FUN80(VAR217.FUN80(VAR277.VAR250, 100), (1000 - VAR274)) / (VAR277.VAR252 - 1) / 1000;
while (VAR282 < VAR277.VAR251 && VAR279 >= VAR277.VAR250){
if (uint8(uint256(FUN49(VAR147, VAR282)) % 100) + 1 < VAR277.VAR252){
VAR281 = VAR283;
if (VAR282 <= 255){
VAR280[0] += uint256(2) ** (255 - VAR282);
}
else if (VAR282 <= 511){
VAR280[1] += uint256(2) ** (511 - VAR282);
}
else if (VAR282 <= 767){
VAR280[2] += uint256(2) ** (767 - VAR282);
}
else {
VAR280[3] += uint256(2) ** (1023 - VAR282);
}
}
else {
VAR281 = 1;
}
VAR282++;
VAR279 = VAR217.FUN43(VAR217.FUN40(VAR279, VAR281), VAR277.VAR250);
}
VAR255 += VAR282;
VAR254 = VAR217.FUN40(VAR254, VAR217.FUN80(VAR277.VAR250, VAR282));
VAR253[VAR146].VAR247 = true;
VAR176 = VAR217.FUN43(VAR176, VAR277.VAR249);
uint256 VAR230 = VAR217.FUN80(VAR217.FUN80(VAR277.VAR250, VAR274), VAR282) / 5000;
VAR175 = VAR217.FUN40(VAR175, VAR230);
FUN95(VAR265).VAR284.value(VAR217.FUN43(VAR277.VAR249, VAR230))();
FUN95(VAR265).FUN62(VAR279, VAR277.VAR246);
emit FUN93(VAR146, VAR282, VAR280[0], VAR280[1], VAR280[2], VAR280[3]);
}
}
}
1
---------------------------------
120 0x812a935527dac8c340ae875ecb7713fcf85127c6.sol
pragma VAR1 ^0.4.25;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR10);
constructor() public {
VAR7 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR11;
}
function FUN6(address VAR12) public onlyOwner {
VAR8 = VAR12;
}
function FUN7() public {
require(msg.sender == VAR8);
emit FUN5(VAR7, VAR8);
VAR7 = VAR8;
VAR8 = address(0);
}
}
contract Snip3D is  VAR6 {
using SafeMath for uint;
uint public VAR13;
mapping(address => uint256)public  VAR14;
mapping(address => uint256)public  VAR15;
mapping(address => uint256)public  VAR16;
mapping(uint256 => address)public  VAR17;
uint256 public VAR18;
mapping(address => uint256)public VAR19;
mapping(uint256 => address) public VAR20;
uint256 public  VAR21;
uint256 public  VAR22;
uint256 public VAR23;
uint256 public VAR24 = 200;
uint256 public VAR25 = 800;
uint256 public VAR26;
uint256 public VAR27;
event FUN8(address indexed VAR28 , uint256 indexed VAR17);
event FUN9(address indexed VAR28);
event FUN10(address indexed VAR28);
event FUN11(address indexed VAR28 , uint256 indexed VAR29, uint256 indexed VAR17);
constructor()
public
{
VAR26 = VAR30.FUN12();
VAR27 = 2784;
}
modifier FUN13()
{
require(VAR14[msg.sender] > 0);
VAR11;
}
HourglassInterface constant VAR31 = FUN14(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
SPASMInterface constant VAR32 = FUN15(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
Snip3dInterface public VAR30 = FUN16(0x6D534b48835701312ebc904d4b37e54D4f7D039f);
function FUN17()
view
public
returns(uint256)
{
return (VAR31.FUN18(true))  ;
}
function FUN19()
public
view
returns(address)
{
return (VAR20[VAR21]);
}
function FUN20(address VAR33)
public
view
returns( string )
{
return (VAR34[VAR33]);
}
function FUN21(address VAR33)
public
view
returns( uint256 )
{
uint256 VAR35;
if(VAR36.VAR35 - VAR19[VAR33] < VAR24)
{VAR35 = VAR24 -(VAR36.VAR35 - VAR19[VAR33]);}
return (VAR35);
}
function FUN22(address VAR33)
public
view
returns( uint256 )
{
uint256 VAR35;
if(VAR36.VAR35 - VAR19[VAR33] < VAR25)
{VAR35 = VAR25 -(VAR36.VAR35 - VAR19[VAR33]);}
return (VAR35);
}
function FUN23() external view returns(uint256){
return ( VAR31.FUN24(address(this)))  ;
}
uint256 public VAR37 = 10e18;
struct VAR38 {
uint VAR39;
uint VAR40;
}
mapping(address=>VAR38) VAR41;
mapping(address => string) public VAR34;
uint public VAR42;
uint public VAR43;
uint public VAR44;
function FUN25(address VAR45) public view returns(uint256) {
uint256 VAR46 = VAR43.FUN2(VAR41[VAR45].VAR40);
return (VAR14[VAR45] * VAR46) / VAR37;
}
modifier FUN26(address VAR45) {
uint256 VAR47 = FUN25(VAR45);
if(VAR47 > 0) {
VAR44 = VAR44.FUN2(VAR47);
VAR16[VAR45] = VAR16[VAR45].FUN1(VAR47);
}
VAR41[VAR45].VAR40 = VAR43;
VAR11;
}
function () external payable{}
function FUN27(address VAR48) public FUN26(VAR48){}
function FUN28(address VAR49, uint256 VAR29) public FUN26(msg.sender)  payable{
uint256 value = msg.value;
require(value >=  VAR29.FUN3(100 VAR50));
address sender = msg.sender;
VAR14[sender]=  VAR14[sender].FUN1(VAR29);
VAR13= VAR13.FUN1(VAR29);
VAR15[sender] = VAR15[sender].FUN1(VAR29).FUN1(VAR29);
for(uint VAR51=0; VAR51< VAR29; VAR51++)
{
uint256 VAR52 = VAR18.FUN1(VAR51);
VAR17[VAR52] = sender;
}
VAR18 += VAR51;
VAR19[sender] = VAR36.VAR35;
uint256 VAR53 = VAR29.FUN3( 5 VAR50);
VAR31.VAR54.value(VAR53)(VAR49);
if(value > VAR29.FUN3(100 VAR50)){VAR23 += value.FUN2(VAR29.FUN3(100 VAR50)) ;}
VAR23 += VAR29.FUN3(5 VAR50);
uint256 VAR55 = VAR29.FUN3(2 VAR50);
VAR32.VAR56.value(VAR55)();
emit FUN11(sender, VAR29, VAR18);
}
function FUN29(address VAR49, address VAR57, uint256 VAR29) public FUN26(msg.sender)  payable{
uint256 value = msg.value;
require(value >=  VAR29.FUN3(100 VAR50));
address sender = msg.sender;
VAR14[sender]=  VAR14[sender].FUN1(VAR29);
VAR13= VAR13.FUN1(VAR29);
VAR15[sender] = VAR15[sender].FUN1(VAR29).FUN1(VAR29);
for(uint VAR51=0; VAR51< VAR29; VAR51++)
{
uint256 VAR52 = VAR18.FUN1(VAR51);
VAR17[VAR52] = sender;
}
VAR18 += VAR51;
VAR19[sender] = VAR36.VAR35;
uint256 VAR53 = VAR29.FUN3( 5 VAR50);
VAR31.VAR54.value(VAR53)(VAR49);
if(value > VAR29.FUN3(100 VAR50)){VAR23 += value.FUN2(VAR29.FUN3(100 VAR50)) ;}
VAR23 += VAR29.FUN3(5 VAR50);
uint256 VAR55 = VAR29.FUN3(1 VAR50);
VAR32.VAR56.value(VAR55)();
VAR16[VAR57] = VAR16[VAR57].FUN1(VAR29.FUN3(1 VAR50));
emit FUN11(sender, VAR29, VAR18);
}
function FUN30() public FUN13() {
address sender = msg.sender;
require(VAR36.VAR35 > VAR19[sender] + VAR24);
require(VAR15[sender] > 0);
uint256 VAR58 = (VAR36.VAR35.FUN2(VAR19[sender])) % 200;
uint256 VAR59 = uint256 (FUN31(VAR36.VAR35.FUN2(VAR58))) % VAR18;
address VAR60 = VAR17[VAR59];
if(sender == VAR60)
{
VAR59 = uint256 (FUN31(VAR36.VAR35.FUN2(VAR58).FUN1(1))) % VAR18;
VAR60 = VAR17[VAR59];
}
FUN27(VAR60);
VAR14[VAR60]--;
VAR13--;
VAR15[sender]--;
uint256 VAR61 = VAR18.FUN2(1);
VAR17[VAR59] = VAR17[VAR61];
VAR18--;
VAR19[sender] = VAR36.VAR35;
FUN32(VAR60);
VAR62[VAR60] += 0.1 VAR63;
uint256 VAR29 = 88 VAR50;
VAR43 = VAR43.FUN1(VAR29.FUN3(VAR37).FUN4(VAR13));
VAR44 = VAR44.FUN1(VAR29);
emit FUN9(sender);
emit FUN8(VAR60, VAR59);
}
function FUN33(uint256 VAR64) public FUN13() {
address sender = msg.sender;
require(VAR64 <= VAR18 && VAR64 > 0);
require(VAR36.VAR35 > VAR19[sender] + VAR25);
require(VAR15[sender] > 0);
if(VAR64 == VAR18){VAR64 = 0;}
address VAR60 = VAR17[VAR64];
FUN27(VAR60);
VAR14[VAR60]--;
VAR13--;
VAR15[sender]--;
uint256 VAR61 = VAR18.FUN2(1);
VAR17[VAR64] = VAR17[VAR61];
VAR18--;
VAR19[sender] = VAR36.VAR35;
FUN32(VAR60);
VAR62[VAR60] += 0.1 VAR63;
uint256 VAR29 = 88 VAR50;
VAR43 = VAR43.FUN1(VAR29.FUN3(VAR37).FUN4(VAR13));
VAR44 = VAR44.FUN1(VAR29);
emit FUN10(sender);
emit FUN8(VAR60, VAR64);
}
function FUN34 ()public
{
require(VAR23 > 0.00001 VAR63);
uint256 VAR29 = VAR23;
VAR23 = 0;
VAR65 = VAR65.FUN1(VAR29.FUN3(VAR37).FUN4(VAR66));
VAR67 = VAR67.FUN1(VAR29);
}
function FUN35() public  payable {
uint256 VAR29 = msg.value;
uint256 VAR68 = VAR29.FUN4(100);
uint256 VAR69 = VAR29.FUN2(VAR68);
VAR43 = VAR43.FUN1(VAR69.FUN3(VAR37).FUN4(VAR13));
VAR44 = VAR44.FUN1(VAR69);
}
function FUN36(address VAR70) public {
require(VAR16[VAR70] > 0);
uint256 value = VAR16[VAR70];
VAR16[VAR70] = 0;
VAR70.transfer(value);
}
function FUN37(string VAR71) public payable{
require(msg.value >= 1  VAR50);
VAR34[msg.sender] = VAR71;
VAR23 += msg.value;
}
function FUN38() public{
uint256 VAR72 = FUN17();
require(VAR72 > 0);
VAR31.FUN39();
uint256 VAR68 = VAR72.FUN4(100);
uint256 VAR69 = VAR72.FUN2(VAR68);
VAR32.VAR56.value(VAR68)();
VAR23 = VAR23.FUN1(VAR69);
}
function FUN40 () public onlyOwner {
FUN41(msg.sender);
}
function FUN42(uint256 VAR73) onlyOwner public{
uint256 VAR74 = VAR26;
for(uint VAR51=0; VAR51< VAR73; VAR51++)
{
address VAR75 = VAR30.FUN43(VAR74 + VAR51);
VAR51++;
VAR62[VAR75] = VAR62[VAR75].FUN1(0.1 VAR63);
}
VAR26 += VAR51;
VAR66 = VAR66.FUN1(VAR51.FUN3(0.1 VAR63));
}
mapping(address => uint256) public VAR62;
uint256 public VAR66;
mapping(address=>VAR38) public VAR76;
uint public VAR77;
uint public VAR65;
uint public VAR67;
function FUN44(address VAR45) public view returns(uint256) {
uint256 VAR78 = VAR65.FUN2(VAR76[VAR45].VAR40);
return (VAR62[VAR45] * VAR78) / VAR37;
}
modifier FUN45(address VAR45) {
uint256 VAR47 = FUN44(VAR45);
if(VAR47 > VAR62[VAR45]){VAR62[VAR45] = VAR47;}
if(VAR47 > 0 ) {
VAR67 = VAR67.FUN2(VAR47);
VAR16[VAR45] = VAR16[VAR45].FUN1(VAR47);
VAR62[VAR45] = VAR62[VAR45].FUN2(VAR47);
VAR66 = VAR66.FUN2(VAR47);
}
VAR76[VAR45].VAR40 = VAR65;
VAR11;
}
function FUN32(address VAR79) public FUN45(VAR79){}
function FUN46() public  payable {
uint256 VAR29 = msg.value;
VAR65 = VAR65.FUN1(VAR29.FUN3(VAR37).FUN4(VAR66));
VAR67 = VAR67.FUN1(VAR29);
}
function FUN47 ()public
{
uint256 VAR80 = VAR31.FUN18(true);
require(VAR80 > 0);
uint256 VAR68 = VAR80.FUN4(100);
VAR31.FUN39();
VAR32.VAR56.value(VAR68.FUN3(5))();
VAR23 = VAR23.FUN1(VAR68.FUN3(95));
}
}
interface VAR81  {
function() payable external;
function FUN48(address VAR82) payable external returns(uint256);
function FUN49(uint256 VAR83) external;
function FUN50() external;
function FUN39() external;
function FUN51() external;
function FUN18(bool VAR84) external view returns(uint256);
function FUN52(address VAR82) external view returns(uint256);
function FUN24(address VAR82) external view returns(uint256);
function transfer(address VAR85, uint256 VAR83) external returns(bool);
function FUN53() external view returns(uint256);
}
interface VAR86 {
function FUN43(uint256 VAR87) external view returns(address);
function FUN12() external view returns(uint256);
function FUN54() external view returns(uint256);
}
interface VAR88  {
function() payable external;
function FUN35() external  payable;
}
1
---------------------------------
121 0x818189b1a0ba4f9e543de04eb76669ec8354e122.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1(address VAR3, uint8 VAR4, string VAR5) public payable returns (uint);
function FUN2(address VAR6) public view returns (uint);
function transfer(address VAR7, uint VAR8)     public returns (bool);
function FUN3(address VAR9, address VAR10, uint VAR11) public returns (bool);
function FUN4() public;
function FUN5(uint VAR12) public;
function FUN6(address VAR13) public;
}
contract VAR14 {
function FUN7(address VAR9, uint VAR11, bytes VAR15) public returns (bool);
}
contract ZethrBankroll is VAR14 {
using SafeMath for uint;
event FUN8(address indexed sender, uint indexed VAR16);
event FUN9(address indexed sender, uint indexed VAR16);
event FUN10(uint indexed VAR16);
event FUN11(uint indexed VAR16);
event FUN12(uint indexed VAR16);
event FUN13(address indexed sender, uint value);
event FUN14(address indexed VAR17);
event FUN15(address indexed VAR17);
event FUN16(address indexed VAR18);
event FUN17(address indexed VAR18);
event FUN18(uint VAR19);
event FUN19(uint VAR20, uint VAR21);
event FUN20(uint VAR22, address sender);
event FUN21(uint VAR22);
event FUN22(address VAR23);
event FUN23(address VAR23, uint VAR24);
event FUN24(address VAR23, uint VAR24);
uint constant public VAR25 = 10;
uint constant public VAR26 = 15;
uint constant public VAR27 = 5;
uint constant internal VAR28 = 1 VAR29;
address internal VAR30;
ZTHInterface public VAR31;
mapping (uint => Transaction) public VAR32;
mapping (uint => mapping (address => bool)) public VAR33;
mapping (address => bool) public VAR34;
mapping (address => bool) public VAR35;
mapping (address => uint) public VAR36;
address internal VAR37;
address[] public VAR38;
address[] public VAR39;
uint public VAR19;
uint public VAR40;
uint internal VAR41;
uint internal VAR42;
uint internal VAR43;
bool internal VAR44 = false;
struct Transaction {
address VAR45;
uint value;
bytes VAR46;
bool VAR47;
}
struct VAR48 {
address sender;
uint value;
}
modifier FUN25() {
if (msg.sender != address(this))
revert();
VAR49;
}
modifier FUN26(address VAR18) {
if (VAR35[VAR18])
revert();
VAR49;
}
modifier FUN27(address VAR18) {
if (!VAR35[VAR18])
revert();
VAR49;
}
modifier FUN28() {
address VAR50 = msg.sender;
if (!VAR34[VAR50])
revert();
VAR49;
}
modifier FUN29(address VAR17) {
if (VAR34[VAR17])
revert();
VAR49;
}
modifier ownerExists(address VAR17) {
if (!VAR34[VAR17])
revert();
VAR49;
}
modifier FUN30(uint VAR16) {
if (VAR32[VAR16].VAR45 == 0)
revert();
VAR49;
}
modifier confirmed(uint VAR16, address VAR17) {
if (!VAR33[VAR16][VAR17])
revert();
VAR49;
}
modifier notConfirmed(uint VAR16, address VAR17) {
if (VAR33[VAR16][VAR17])
revert();
VAR49;
}
modifier notExecuted(uint VAR16) {
if (VAR32[VAR16].VAR47)
revert();
VAR49;
}
modifier FUN31(address VAR51) {
if (VAR51 == 0)
revert();
VAR49;
}
modifier FUN32(uint VAR52, uint VAR53) {
if (   VAR52 > VAR25
|| VAR53 > VAR52
|| VAR53 == 0
|| VAR52 == 0)
revert();
VAR49;
}
constructor (address[] VAR54, uint VAR53)
public
FUN32(VAR54.VAR55, VAR53)
{
for (uint VAR56=0; VAR56<VAR54.VAR55; VAR56++) {
if (VAR34[VAR54[VAR56]] || VAR54[VAR56] == 0)
revert();
VAR34[VAR54[VAR56]] = true;
}
VAR38 = VAR54;
VAR19 = VAR53;
VAR41 = VAR57 - (1 VAR29);
}
function FUN33(address VAR58, address VAR59)
public
VAR60
{
VAR30   = VAR58;
VAR37 = VAR59;
VAR31 = FUN34(VAR30);
}
function()
public
payable
{
}
uint VAR61;
function FUN35()
public
payable
{
VAR61 = VAR61.FUN36(msg.value);
}
function FUN37()
public
payable
VAR60
{
uint VAR62 = address(this).VAR63;
if (VAR62 > 0.01 VAR64) {
VAR31.VAR65.value(VAR62)(address(0x0), 33, "");
emit FUN21(VAR62);
}
else {
emit FUN20(msg.value, msg.sender);
}
}
function FUN7(address
, uint
, bytes
) public returns (bool) {
}
function FUN38(uint VAR66)
public
returns(bool)
{
uint VAR67     = VAR57;
uint VAR68    = VAR31.FUN2(address(this));
uint VAR69        = (VAR68.FUN39(VAR27)).FUN40(100);
require (VAR66 <= VAR69);
if (VAR67 - VAR41 >= VAR28)
{
VAR41     = VAR67;
VAR42      = (VAR68.FUN39(VAR26)).FUN40(100);
VAR43 = VAR66;
return true;
}
else
{
if (VAR43.FUN36(VAR66) <= VAR42)
{
VAR43 += VAR66;
return true;
}
else { return false; }
}
}
function FUN41(uint VAR70)
public
VAR60
{
VAR42 = VAR70;
}
function FUN42(address VAR17)
public
VAR71
FUN29(VAR17)
FUN31(VAR17)
FUN32(VAR38.VAR55 + 1, VAR19)
{
VAR34[VAR17] = true;
VAR38.FUN43(VAR17);
emit FUN14(VAR17);
}
function FUN44(address VAR17)
public
VAR71
ownerExists(VAR17)
FUN32(VAR38.VAR55, VAR19)
{
VAR34[VAR17] = false;
for (uint VAR56=0; VAR56<VAR38.VAR55 - 1; VAR56++)
if (VAR38[VAR56] == VAR17) {
VAR38[VAR56] = VAR38[VAR38.VAR55 - 1];
break;
}
VAR38.VAR55 -= 1;
if (VAR19 > VAR38.VAR55)
FUN45(VAR38.VAR55);
emit FUN15(VAR17);
}
function FUN46(address VAR17, address VAR72)
public
VAR71
ownerExists(VAR17)
FUN29(VAR72)
{
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR38[VAR56] == VAR17) {
VAR38[VAR56] = VAR72;
break;
}
VAR34[VAR17] = false;
VAR34[VAR72] = true;
emit FUN15(VAR17);
emit FUN14(VAR72);
}
function FUN45(uint VAR53)
public
VAR71
FUN32(VAR38.VAR55, VAR53)
{
VAR19 = VAR53;
emit FUN18(VAR53);
}
function FUN47(address VAR45, uint value, bytes VAR46)
public
returns (uint VAR16)
{
VAR16 = FUN48(VAR45, value, VAR46);
FUN49(VAR16);
}
function FUN49(uint VAR16)
public
ownerExists(msg.sender)
FUN30(VAR16)
notConfirmed(VAR16, msg.sender)
{
VAR33[VAR16][msg.sender] = true;
emit FUN8(msg.sender, VAR16);
FUN50(VAR16);
}
function FUN51(uint VAR16)
public
ownerExists(msg.sender)
confirmed(VAR16, msg.sender)
notExecuted(VAR16)
{
VAR33[VAR16][msg.sender] = false;
emit FUN9(msg.sender, VAR16);
}
function FUN50(uint VAR16)
public
notExecuted(VAR16)
{
if (FUN52(VAR16)) {
Transaction storage VAR73 = VAR32[VAR16];
VAR73.VAR47 = true;
if (VAR73.VAR45.call.value(VAR73.value)(VAR73.VAR46))
emit FUN11(VAR16);
else {
emit FUN12(VAR16);
VAR73.VAR47 = false;
}
}
}
function FUN52(uint VAR16)
public
constant
returns (bool)
{
uint VAR74 = 0;
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++) {
if (VAR33[VAR16][VAR38[VAR56]])
VAR74 += 1;
if (VAR74 == VAR19)
return true;
}
}
function FUN48(address VAR45, uint value, bytes VAR46)
internal
FUN31(VAR45)
returns (uint VAR16)
{
VAR16 = VAR40;
VAR32[VAR16] = Transaction({
VAR45: VAR45,
value: value,
VAR46: VAR46,
VAR47: false
});
VAR40 += 1;
emit FUN10(VAR16);
}
function FUN53(uint VAR16)
public
constant
returns (uint VAR74)
{
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR33[VAR16][VAR38[VAR56]])
VAR74 += 1;
}
function FUN54(bool VAR75, bool VAR47)
public
constant
returns (uint VAR74)
{
for (uint VAR56=0; VAR56<VAR40; VAR56++)
if (   VAR75 && !VAR32[VAR56].VAR47
|| VAR47 && VAR32[VAR56].VAR47)
VAR74 += 1;
}
function FUN55()
public
constant
returns (address[])
{
return VAR38;
}
function FUN56(uint VAR16)
public
constant
returns (address[] VAR76)
{
address[] memory VAR77 = new address[](VAR38.VAR55);
uint VAR74 = 0;
uint VAR56;
for (VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR33[VAR16][VAR38[VAR56]]) {
VAR77[VAR74] = VAR38[VAR56];
VAR74 += 1;
}
VAR76 = new address[](VAR74);
for (VAR56=0; VAR56<VAR74; VAR56++)
VAR76[VAR56] = VAR77[VAR56];
}
function FUN57(uint VAR78, uint VAR79, bool VAR75, bool VAR47)
public
constant
returns (uint[] VAR80)
{
uint[] memory VAR81 = new uint[](VAR40);
uint VAR74 = 0;
uint VAR56;
for (VAR56=0; VAR56<VAR40; VAR56++)
if (   VAR75 && !VAR32[VAR56].VAR47
|| VAR47 && VAR32[VAR56].VAR47)
{
VAR81[VAR74] = VAR56;
VAR74 += 1;
}
VAR80 = new uint[](VAR79 - VAR78);
for (VAR56=VAR78; VAR56<VAR79; VAR56++)
VAR80[VAR56 - VAR78] = VAR81[VAR56];
}
function FUN58(address VAR18)
public
VAR60
FUN26(VAR18)
FUN31(VAR18)
{
VAR35[VAR18] = true;
VAR39.FUN43(VAR18);
VAR36[VAR18] = 0;
emit FUN16(VAR18);
}
function FUN59(address VAR18)
public
VAR60
FUN27(VAR18)
{
VAR35[VAR18] = false;
for (uint VAR56=0; VAR56 < VAR39.VAR55 - 1; VAR56++)
if (VAR39[VAR56] == VAR18) {
VAR39[VAR56] = VAR38[VAR39.VAR55 - 1];
break;
}
VAR39.VAR55 -= 1;
emit FUN17(VAR18);
}
function FUN60(uint VAR82, address VAR83) public
FUN27(msg.sender)
{
require(VAR35[msg.sender]);
require(VAR31.transfer(VAR83, VAR82));
}
function FUN61(address VAR84, uint VAR85)
public
VAR60
FUN27(VAR84)
{
VAR36[VAR84] = VAR85;
}
function FUN62(address VAR84)
public
view
returns (uint)
{
return VAR36[VAR84];
}
function FUN63()
public
VAR60
{
for (uint VAR56=0; VAR56 < VAR39.VAR55; VAR56++)
{
address VAR84 = VAR39[VAR56];
if ( VAR36[VAR84] > 0 )
{
FUN64(VAR84);
emit FUN22(VAR84);
}
}
}
function FUN65(address VAR84, uint VAR86)
public
VAR60
FUN27(VAR84)
{
require(VAR31.FUN3(VAR84, address(this), VAR86));
}
function FUN64(address VAR84)
public
VAR60
FUN27(VAR84)
{
uint VAR87 = VAR36[VAR84];
uint VAR88  = VAR31.FUN2(VAR84);
if (VAR88 <= VAR87)
{
uint VAR89  = VAR87.FUN66(VAR88);
require(FUN38(VAR89));
require(VAR31.transfer(VAR84, VAR89));
emit FUN23(VAR84, VAR89);
} else
{
uint VAR90 = VAR88.FUN66(VAR87);
require(VAR31.FUN3(VAR84, address(this), VAR90));
emit FUN24(VAR84, VAR90);
}
emit FUN22(VAR84);
}
function FUN67(uint VAR82) public
VAR71
{
require(FUN38(VAR82));
uint VAR21 = VAR91.FUN40(VAR82, VAR38.VAR55);
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++) {
VAR31.transfer(VAR38[VAR56], VAR21);
}
emit FUN19(VAR82, VAR21);
}
function FUN68(address VAR92)
public
VAR60
{
VAR37 = VAR92;
}
function FUN69() public payable {
if (!VAR44) {
uint VAR93 = (address(this).VAR63.FUN66(VAR61));
if (VAR93 > 0.01 VAR64) {
VAR44 = true;
VAR31.VAR65.value(VAR93)(address(0x0), 33, "");
emit FUN21(VAR93);
VAR44 = false;
}
}
}
function FUN70() public payable VAR60 {
if (!VAR44) {
uint VAR63 = address(this).VAR63;
require (VAR63 > 0.01 VAR64);
VAR31.VAR65.value(VAR63)(address(0x0), 33, "");
}
}
function FUN71(uint VAR94) public pure returns (uint) {
if (FUN72(VAR94) >= FUN72('') && FUN72(VAR94) <= FUN72('')) {
return VAR94 - uint(FUN72(''));
}
if (FUN72(VAR94) >= FUN72('') && FUN72(VAR94) <= FUN72('')) {
return 10 + VAR94 - uint(FUN72(''));
}
if (FUN72(VAR94) >= FUN72('') && FUN72(VAR94) <= FUN72('')) {
return 10 + VAR94 - uint(FUN72(''));
}
}
function FUN73(string VAR95) public pure returns (bytes) {
bytes memory VAR96 = bytes(VAR95);
require(VAR96.VAR55%2 == 0);
bytes memory VAR97 = VAR98 bytes(VAR96.VAR55/2);
for (uint VAR56=0; VAR56<VAR96.VAR55/2; ++VAR56) {
VAR97[VAR56] = FUN72(FUN71(uint(VAR96[2*VAR56])) * 16 +
FUN71(uint(VAR96[2*VAR56+1])));
}
return VAR97;
}
}
library VAR91 {
function FUN39(uint VAR99, uint VAR100) internal pure returns (uint) {
if (VAR99 == 0) {
return 0;
}
uint VAR94 = VAR99 * VAR100;
assert(VAR94 / VAR99 == VAR100);
return VAR94;
}
function FUN40(uint VAR99, uint VAR100) internal pure returns (uint) {
uint VAR94 = VAR99 / VAR100;
return VAR94;
}
function FUN66(uint VAR99, uint VAR100) internal pure returns (uint) {
assert(VAR100 <= VAR99);
return VAR99 - VAR100;
}
function FUN36(uint VAR99, uint VAR100) internal pure returns (uint) {
uint VAR94 = VAR99 + VAR100;
assert(VAR94 >= VAR99);
return VAR94;
}
}
1
---------------------------------
122 0x83011039a24b1fce5e848cbdded20c0a6e14cbf7.sol
pragma VAR1 ^0.4.22;
contract VAR2 {
address public VAR3;
address public VAR4;
bool public VAR5;
constructor(address VAR6, address VAR7) public {
VAR3 = VAR6;
VAR4 = VAR7;
VAR5 = false;
}
modifier FUN1() {
require(msg.sender == VAR3 || msg.sender == VAR4);
VAR8;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR8;
}
modifier FUN2() {
require(VAR5 == false);
VAR8;
}
event FUN3(address VAR9);
event FUN4(address VAR10);
function() payable public {}
function FUN5(address VAR11, bytes VAR12, uint256 VAR13) payable external FUN1() FUN2() {
require(VAR11.call.value(VAR13)(VAR12));
}
function FUN6(address VAR14, uint VAR15) external FUN1() FUN2() {
VAR14.transfer(VAR15);
}
function FUN7(address VAR11, bytes VAR12, uint256 VAR16, uint256 VAR17) payable external FUN1() FUN2() {
require(VAR11.call.value(VAR16).FUN8(VAR17)(VAR12));
}
function FUN9() external FUN1() {
VAR5 = true;
}
function FUN10() external onlyOwner() {
VAR5 = false;
}
function FUN11(address VAR9) external onlyOwner() {
VAR3 = VAR9;
emit FUN3(VAR3);
}
function FUN12(address VAR10) external onlyOwner() {
VAR4 = VAR10;
emit FUN4(VAR4);
}
}
1
---------------------------------
123 0x8302d67bdc44dc0457e0c80312142dd353c9948d.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function FUN1() constant returns (address);
function FUN2() constant returns (bool);
function FUN3(uint VAR3, uint VAR4,
uint VAR5, int VAR6) payable;
function FUN4() constant returns (bool);
function FUN5(uint VAR7);
}
contract VAR8 {
address public VAR9;
address public VAR10;
address public VAR11;
address public VAR12;
uint public VAR13;
uint public VAR14;
int public VAR15;
uint public VAR16;
uint public VAR17;
event FUN6(address indexed VAR18, uint VAR19);
modifier onlyOwner {
require(msg.sender == VAR9);
VAR20;
}
modifier VAR21 {
require(msg.sender == VAR9 || msg.sender == VAR10);
VAR20;
}
function FUN7(address VAR22) {
VAR9 = msg.sender;
VAR10 = msg.sender;
VAR12 = VAR22;
VAR13 = 50 VAR23;
VAR14 = 100 VAR24;
VAR15 = 6;
}
function () payable {
FUN6(msg.sender, msg.value);
}
function FUN8() constant returns (bool) {
return VAR25 - VAR16 >= 24 VAR26;
}
function FUN9() VAR21 {
require(FUN8());
VAR16 = VAR25;
VAR10.transfer(VAR13);
}
function FUN10() constant returns (bool) {
if (FUN11(VAR12).FUN1() != address(this)) {
return false;
}
return FUN11(VAR12).FUN4();
}
function FUN12(uint VAR7) VAR21 {
FUN11(VAR12).FUN5(VAR7);
}
function FUN2() constant returns (bool) {
if (FUN11(VAR12).FUN1() != address(this)) {
return false;
}
return FUN11(VAR12).FUN2();
}
function FUN3(uint VAR27,
uint VAR3, uint VAR4,
uint VAR5, int VAR6)
VAR21 {
require(VAR3 <= VAR14);
require(VAR6 >= VAR15);
VAR17 = VAR27;
FUN11(VAR12).VAR28.value(VAR3)(
VAR3, VAR4, VAR5, VAR6);
}
function FUN13(uint VAR19) onlyOwner {
VAR9.transfer(VAR19);
}
function FUN14(uint VAR29,
uint VAR30,
int VAR31)
onlyOwner {
VAR13 = VAR29;
VAR14 = VAR30;
VAR15 = VAR31;
}
function FUN15(address VAR22) onlyOwner {
VAR12 = VAR22;
}
function FUN16(address VAR32) onlyOwner {
VAR10 = VAR32;
}
function FUN17(address VAR33) onlyOwner {
VAR11 = VAR33;
}
function FUN18() {
require(VAR11 != 0);
require(msg.sender == VAR11);
VAR9 = VAR11;
}
function FUN19() onlyOwner {
FUN20(VAR9);
}
}
1
---------------------------------
124 0x8355048d74888569ad9f9675ae9b6920f54b9985.sol
pragma VAR1 ^0.4.0;
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(string VAR5) returns (uint VAR11);
function FUN5(string VAR5, uint VAR12) returns (uint VAR11);
function FUN6(string VAR13);
function FUN7(byte VAR14);
function FUN8(uint VAR15);
}
contract VAR16 {
function FUN9() returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x01;
uint8 constant VAR25 = 0;
uint8 constant VAR26 = 1;
uint8 constant VAR27 = 2;
uint8 constant VAR28 = 2;
uint8 constant VAR29 = 161;
OraclizeAddrResolverI VAR30;
OraclizeI VAR31;
modifier VAR32 {
if(address(VAR30)==0) FUN10(VAR25);
VAR31 = FUN11(VAR30.FUN9());
VAR33;
}
modifier FUN12(string VAR34){
VAR31 = FUN11(VAR30.FUN9());
VAR31.FUN6(VAR34);
VAR33;
}
function FUN10(uint8 VAR35) internal returns(bool){
if (FUN13(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){
VAR30 = FUN14(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);
return true;
}
if (FUN13(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){
VAR30 = FUN14(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);
return true;
}
if (FUN13(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){
VAR30 = FUN14(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);
return true;
}
if (FUN13(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60)>0){
VAR30 = FUN14(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60);
return true;
}
return false;
}
function FUN15(string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(0, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(VAR44, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(VAR44, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(0, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(0, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(VAR44, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(VAR44, VAR36, VAR46, VAR47, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(0, VAR36, VAR46, VAR47, VAR12);
}
function FUN16() oraclizeAPI internal returns (address){
return VAR31.FUN17();
}
function FUN18(byte VAR50) oraclizeAPI internal {
return VAR31.FUN7(VAR50);
}
function FUN19(uint VAR51) oraclizeAPI internal {
return VAR31.FUN8(VAR51);
}
function FUN20(bytes VAR52) oraclizeAPI internal {
}
function FUN13(address VAR17) constant internal returns(uint VAR53) {
VAR54 {
VAR53 := FUN21(VAR17)
}
}
function FUN22(string VAR55) internal returns (address){
bytes memory VAR56 = bytes(VAR55);
uint160 VAR57 = 0;
uint160 VAR58;
uint160 VAR59;
for (uint VAR60=2; VAR60<2+2*20; VAR60+=2){
VAR57 *= 256;
VAR58 = FUN23(VAR56[VAR60]);
VAR59 = FUN23(VAR56[VAR60+1]);
if ((VAR58 >= 97)&&(VAR58 <= 102)) VAR58 -= 87;
else if ((VAR58 >= 48)&&(VAR58 <= 57)) VAR58 -= 48;
if ((VAR59 >= 97)&&(VAR59 <= 102)) VAR59 -= 87;
else if ((VAR59 >= 48)&&(VAR59 <= 57)) VAR59 -= 48;
VAR57 += (VAR58*16+VAR59);
}
return address(VAR57);
}
function FUN24(string VAR55, string VAR61) internal returns (int) {
bytes memory VAR62 = bytes(VAR55);
bytes memory VAR63 = bytes(VAR61);
uint VAR64 = VAR62.VAR65;
if (VAR63.VAR65 < VAR64) VAR64 = VAR63.VAR65;
for (uint VAR60 = 0; VAR60 < VAR64; VAR60 ++)
if (VAR62[VAR60] < VAR63[VAR60])
return -1;
else if (VAR62[VAR60] > VAR63[VAR60])
return 1;
if (VAR62.VAR65 < VAR63.VAR65)
return -1;
else if (VAR62.VAR65 > VAR63.VAR65)
return 1;
else
return 0;
}
function FUN25(string VAR66, string VAR67) internal returns (int)
{
bytes memory VAR68 = bytes(VAR66);
bytes memory VAR69 = bytes(VAR67);
if(VAR68.VAR65 < 1 || VAR69.VAR65 < 1 || (VAR69.VAR65 > VAR68.VAR65))
return -1;
else if(VAR68.VAR65 > (2**128 -1))
return -1;
else
{
uint VAR70 = 0;
for (uint VAR60 = 0; VAR60 < VAR68.VAR65; VAR60 ++)
{
if (VAR68[VAR60] == VAR69[0])
{
VAR70 = 1;
while(VAR70 < VAR69.VAR65 && (VAR60 + VAR70) < VAR68.VAR65 && VAR68[VAR60 + VAR70] == VAR69[VAR70])
{
VAR70++;
}
if(VAR70 == VAR69.VAR65)
return int(VAR60);
}
}
return -1;
}
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72, string VAR73) internal returns (string){
bytes memory VAR74 = bytes(VAR55);
bytes memory VAR75 = bytes(VAR61);
bytes memory VAR76 = bytes(VAR71);
bytes memory VAR77 = bytes(VAR72);
bytes memory VAR78 = bytes(VAR73);
string memory VAR79 = VAR80 string(VAR74.VAR65 + VAR75.VAR65 + VAR76.VAR65 + VAR77.VAR65 + VAR78.VAR65);
bytes memory VAR81 = bytes(VAR79);
uint VAR82 = 0;
for (uint VAR60 = 0; VAR60 < VAR74.VAR65; VAR60++) VAR81[VAR82++] = VAR74[VAR60];
for (VAR60 = 0; VAR60 < VAR75.VAR65; VAR60++) VAR81[VAR82++] = VAR75[VAR60];
for (VAR60 = 0; VAR60 < VAR76.VAR65; VAR60++) VAR81[VAR82++] = VAR76[VAR60];
for (VAR60 = 0; VAR60 < VAR77.VAR65; VAR60++) VAR81[VAR82++] = VAR77[VAR60];
for (VAR60 = 0; VAR60 < VAR78.VAR65; VAR60++) VAR81[VAR82++] = VAR78[VAR60];
return string(VAR81);
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, VAR72, "");
}
function FUN26(string VAR55, string VAR61, string VAR71) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, "", "");
}
function FUN26(string VAR55, string VAR61) internal returns (string) {
return FUN26(VAR55, VAR61, "", "", "");
}
function FUN27(string VAR55) internal returns (uint) {
return FUN27(VAR55, 0);
}
function FUN27(string VAR55, uint VAR61) internal returns (uint) {
bytes memory VAR83 = bytes(VAR55);
uint VAR84 = 0;
bool VAR85 = false;
for (uint VAR60=0; VAR60<VAR83.VAR65; VAR60++){
if ((VAR83[VAR60] >= 48)&&(VAR83[VAR60] <= 57)){
if (VAR85){
if (VAR61 == 0) break;
else VAR61--;
}
VAR84 *= 10;
VAR84 += uint(VAR83[VAR60]) - 48;
} else if (VAR83[VAR60] == 46) VAR85 = true;
}
if (VAR61 > 0) VAR84 *= 10**VAR61;
return VAR84;
}
}
contract FirstContract is VAR18 {
address VAR86;
uint constant VAR87 = 125000;
uint public VAR88  = 0;
uint public VAR89 = 0;
uint VAR90 = 25000;
function FUN28() {
FUN18(VAR23 | VAR24);
VAR86 = msg.sender;
}
function() {
VAR89++;
}
modifier VAR91 {
if (msg.sender != FUN16()) throw;
VAR33;
}
modifier onlyOwner {
if (VAR86 != msg.sender) throw;
VAR33;
}
function FUN29(uint VAR92) onlyOwner {
VAR90 = VAR92;
}
function FUN30() payable onlyOwner {
FUN15("", "FUN31(VAR93:
}
function FUN32() payable {
}
function FUN33 (bytes32 VAR94, string VAR95, bytes VAR96) payable VAR91 {
VAR88 = FUN27(VAR95);
}
function FUN34(address VAR97, uint value) private {
if (this.VAR98 < value) {
throw;
}
if (!(VAR97.call.FUN35(VAR90).value(value)())) {
throw;
}
}
function FUN36(uint VAR99) payable onlyOwner {
FUN34(VAR86, VAR99);
}
function FUN37() payable onlyOwner {
FUN38(VAR86);
}
}
1
---------------------------------
125 0x83928d7a16e0cbdf77d555c405a3975d11dcf0fa.sol
pragma solidity 0.4.25;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
address public VAR6;
uint public VAR7;
uint VAR8 = 200000;
event FUN5(uint VAR9);
event FUN6(uint VAR10);
constructor() public {
VAR6 = msg.sender;
}
modifier FUN7() {
require(msg.sender == VAR6, '');
VAR11;
}
function FUN8() public VAR12 returns(bool) {
uint VAR9 = address(this).VAR9;
require(VAR9 > VAR8, '');
if (VAR6.call.value(address(this).VAR9).FUN9(VAR8)()) {
emit FUN5(VAR9);
VAR7 = address(this).VAR9;
return true;
} else {
return false;
}
}
function() external payable {
VAR7 += msg.value;
emit FUN6(msg.value);
}
}
contract VAR13{
using VAR1
for uint;
mapping(address => uint) public VAR14;
mapping(address => uint) public VAR15;
address public VAR16 = 0xf846f84841b3242Ccdeac8c43C9cF73Bd781baA7;
EtherheroStabilizationFund public VAR17 = VAR18 FUN10();
uint public VAR19 = 10;
uint public VAR20 = 1;
uint public VAR21 = 10;
address public VAR22;
uint VAR8 = 150000;
uint VAR23 = 30;
uint VAR24 = 150;
uint public VAR25 = 5 VAR26;
uint VAR27 = 1 VAR28;
event FUN11(address indexed VAR29, uint VAR30);
event FUN12(address indexed VAR29, uint value);
event FUN13(address indexed VAR29, uint value);
uint public VAR31;
uint public VAR32;
uint public VAR33;
uint public VAR34;
struct VAR35 {
address VAR36;
uint VAR37;
uint VAR38;
uint VAR39;
uint VAR40;
bool VAR41;
}
mapping(address => VAR35) VAR42;
constructor() public {
VAR22 = VAR17;
}
function FUN14(address VAR43, uint VAR44, uint VAR45, uint VAR46) private {
Beneficiaries storage VAR47 = VAR42[VAR43];
if (!VAR47.VAR41) {
VAR47.VAR41 = true;
VAR47.VAR36 = VAR43;
VAR47.VAR38 = VAR44;
VAR47.VAR39 = VAR45;
VAR47.VAR40 = VAR46;
VAR47.VAR37 = VAR48;
VAR33 += 1;
} else {
VAR47.VAR38 += VAR44;
VAR47.VAR39 += VAR45;
}
}
function FUN15(address VAR43) public view returns(address VAR36, uint VAR49, uint VAR39, uint VAR37) {
Beneficiaries storage VAR47 = VAR42[VAR43];
require(VAR47.VAR41, '');
return (
VAR47.VAR36,
VAR47.VAR38,
VAR47.VAR39,
VAR47.VAR37
);
}
modifier FUN16() {
require(VAR14[msg.sender] > 0, "");
VAR11;
}
modifier FUN17() {
require(VAR48 >= VAR15[msg.sender].FUN4(VAR27), "");
VAR11;
}
function FUN18() public view returns(uint) {
uint VAR50 = VAR48.FUN3(VAR15[msg.sender]).FUN2(VAR27);
if (VAR14[msg.sender] < 10 VAR51) {
if (VAR50 >= 1) {
return (1);
} else {
return (VAR50);
}
}
if (VAR14[msg.sender] >= 10 VAR51 && VAR14[msg.sender] < 50 VAR51) {
if (VAR50 > 3) {
return (3);
} else {
return (VAR50);
}
}
if (VAR14[msg.sender] >= 50 VAR51) {
if (VAR50 > 7) {
return (7);
} else {
return (VAR50);
}
}
}
function FUN19() isIssetUser timePayment internal {
uint VAR52 = VAR31.FUN1(VAR24).FUN2(1000);
uint VAR53 = FUN18();
uint VAR54 = VAR31.FUN1(6).FUN2(100);
if(VAR22.VAR9 > 0){
if (address(this).VAR9 < VAR52) {
VAR17.FUN8();
}
}
require(address(this).VAR9 >= VAR54, '');
uint VAR55 = VAR14[msg.sender].FUN1(VAR23).FUN2(1000).FUN1(VAR53);
VAR15[msg.sender] = VAR48;
msg.sender.transfer(VAR55);
VAR32 += VAR55;
VAR34 = VAR48;
FUN14(msg.sender, VAR23, VAR55, 0);
emit FUN12(msg.sender, VAR55);
}
function FUN20() private {
uint value = msg.value;
uint VAR56 = value.FUN1(VAR19).FUN2(100);
uint VAR57 = value.FUN1(VAR21).FUN2(100);
if (msg.value > 0) {
require(msg.value >= VAR25, '');
if (VAR14[msg.sender] == 0) {
emit FUN11(msg.sender, msg.value);
}
VAR14[msg.sender] = VAR14[msg.sender].FUN4(msg.value);
VAR15[msg.sender] = VAR48;
FUN14(msg.sender, 0, 0, msg.value);
VAR16.transfer(VAR56);
VAR17.call.value(VAR57).FUN9(VAR8)();
VAR31 += msg.value;
emit FUN13(msg.sender, msg.value);
} else {
FUN19();
}
}
function() external payable {
if (msg.sender != VAR22) {
FUN20();
}
}
}
1
---------------------------------
126 0x83a216a7d51f9698fce51364d6a258d725e55b54.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
function FUN1() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN2(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN3() external view returns (uint256);
function FUN4(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN6(address VAR11, uint256 value) external returns (bool VAR9);
function FUN7(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN8(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract RenderTokenInvestment1 is VAR2 {
address public VAR13 = 0x46dda95DEf0ddD0d9F6829352dB2622f27Fe5da7;
address public VAR14 = 0x212286e36Ae998FAd27b627EB326107B3aF1FeD4;
address public VAR15 = 0x515962688858eD980EB2Db2b6fA2802D9f620C6d;
uint public VAR16 = 1000;
function() payable public {
FUN9(msg.value);
}
function FUN9(uint VAR17) internal {
uint VAR18 = VAR17 * 3 / 105;
uint VAR19 = VAR17 * 2 / 105;
require(VAR14.call.FUN10(VAR16).value(VAR18)());
require(VAR15.call.FUN10(VAR16).value(VAR19)());
uint VAR20 = VAR17 - VAR18 - VAR19;
require(VAR13.call.FUN10(VAR16).value(VAR20)());
}
function FUN11(uint VAR21) public onlyOwner {
VAR16 = VAR21;
}
function FUN12(EIP20Token VAR22, address VAR23, uint value) public onlyOwner {
VAR22.FUN6(VAR23, value);
}
function FUN13() public onlyOwner {
require(msg.sender.call.FUN10(VAR16).value(address(this).VAR24)());
}
}
1
---------------------------------
127 0x84a1467d6b3c6ba22fabf6a3851c287c9c55f298.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
function FUN1(address VAR3) public payable;
}
contract VAR4 {
address[] public VAR5;
function FUN2() {
VAR5.VAR6 = 1;
VAR5[0] = msg.sender;
}
modifier FUN3() {
bool VAR7 = false;
for (uint256 VAR8 = 0; VAR8 < VAR5.VAR6; VAR8++) {
if (msg.sender == VAR5[VAR8]) {
VAR7 = true;
}
}
require(VAR7 == true);
VAR9;
}
function FUN4(address VAR10) public VAR11 {
for (uint256 VAR8 = 0; VAR8 < VAR5.VAR6; VAR8++) {
require(VAR10 != VAR5[VAR8]);
}
require(VAR5.VAR6 < 10);
VAR5[VAR5.VAR6++] = VAR10;
}
function FUN5(address VAR10) public VAR11 {
uint256 VAR12 = VAR5.VAR6;
for (uint256 VAR8 = 0; VAR8 < VAR5.VAR6; VAR8++) {
if (VAR10 == VAR5[VAR8]) {
VAR12 = VAR8;
}
}
require(VAR12 < VAR5.VAR6);
if (VAR12 < VAR5.VAR6 - 1) {
VAR5[VAR12] = VAR5[VAR5.VAR6 - 1];
}
VAR5.VAR6--;
}
}
contract VAR13 {
address public VAR14;
function FUN6(address VAR15) {
VAR14 = VAR15;
}
function FUN7(address VAR16) constant returns (uint256) {
return FUN8(VAR14).FUN9('', VAR16);
}
function FUN10(address VAR16, uint256 VAR17) internal {
FUN8(VAR14).FUN11('', VAR16, VAR17);
}
function FUN12() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN14(uint256 VAR18) internal {
FUN8(VAR14).FUN15('', '', VAR18);
}
function FUN16() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN17(uint256 VAR19) internal {
FUN8(VAR14).FUN15('', '', VAR19);
}
function FUN18() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN19(uint256 VAR20) internal {
FUN8(VAR14).FUN15('', '', VAR20);
}
function FUN20(address VAR16) constant returns (uint256) {
return FUN8(VAR14).FUN9('', VAR16);
}
function FUN21(address VAR16, uint256 VAR17) internal {
FUN8(VAR14).FUN11('', VAR16, VAR17);
}
function FUN22() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN23(uint256 VAR21) internal {
FUN8(VAR14).FUN15('', '', VAR21);
}
function FUN24() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN25(uint256 VAR22) internal {
FUN8(VAR14).FUN15('', '', VAR22);
}
function FUN26(address VAR23) constant public returns (uint256 VAR24, uint256 VAR25, uint256 VAR26) {
uint256 VAR27 = FUN8(VAR14).FUN9('', VAR23);
VAR26 = FUN27(VAR27);
VAR25 = FUN28(VAR27 >> (64));
VAR24 = FUN28(VAR27 >> (96 + 64));
return;
}
function FUN29(address VAR28, uint256 VAR24, uint256 VAR25, uint256 VAR26) internal {
uint256 VAR29 = FUN27(VAR26) + (VAR25 << 64) + (VAR24 << (96 + 64));
FUN8(VAR14).FUN11('', VAR28, VAR29);
}
}
contract Pausable is VAR4 {
bool public VAR30 = true;
modifier FUN30() {
require(!VAR30);
VAR9;
}
modifier FUN31() {
require(VAR30);
VAR9;
}
function FUN32() onlyAdmins VAR31 {
VAR30 = true;
}
function FUN33() onlyAdmins VAR32 {
VAR30 = false;
}
}
contract VAR33 {
function FUN34() constant returns (uint256);
function FUN35(address VAR16) constant returns (uint256);
function transfer(address VAR34, uint256 VAR35) returns (bool);
event Transfer(address indexed VAR36, address indexed VAR37, uint value);
}
contract ERC223Basic is VAR33 {
function transfer(address VAR37, uint value, bytes VAR38) returns (bool);
}
contract ERC20 is VAR39 {
function FUN12() constant returns (uint256);
function FUN36(address VAR16, address VAR40) constant returns (uint256);
function FUN37(address VAR41, address VAR34, uint VAR35) returns (bool);
function FUN38(address VAR40, uint256 VAR35);
event FUN39(address indexed VAR42, address indexed VAR43, uint256 value);
}
contract VAR44 {
address public VAR42;
function FUN40() {
VAR42 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR42);
VAR9;
}
function FUN41(address VAR45) onlyOwner {
require(VAR45 != address(0));
VAR42 = VAR45;
}
}
contract Power is VAR44, VAR33 {
event FUN42(address indexed VAR46, uint value, bytes32 VAR38);
string public VAR47 = "";
string public VAR48 = "";
uint256 public VAR49 = 12;
function FUN35(address VAR28) constant returns (uint256) {
return FUN43(VAR42).FUN20(VAR28);
}
function FUN34() constant returns (uint256) {
return FUN43(VAR42).FUN44();
}
function FUN12() constant returns (uint256) {
return FUN43(VAR42).FUN22();
}
function FUN45(address VAR28, uint256 VAR35, bytes32 VAR50) public onlyOwner {
FUN42(VAR28, VAR35, VAR50);
}
function FUN46(address VAR28, uint256 VAR35) public onlyOwner {
Transfer(address(0), VAR28, VAR35);
}
function transfer(address VAR34, uint256 VAR51) public returns (bool VAR52) {
require(VAR34 == address(0));
FUN43(VAR42).FUN47(msg.sender, VAR51);
Transfer(msg.sender, address(0), VAR51);
return true;
}
function FUN48() public returns (uint256) {
FUN43(VAR42).VAR53;
}
function FUN49(address VAR16) public {
FUN43(VAR42).FUN49(VAR16, VAR54);
}
function FUN26(address VAR16) constant public returns (uint256, uint256, uint256) {
return FUN43(VAR42).FUN26(VAR16);
}
}
contract Storage is VAR44 {
struct VAR55 {
mapping(bytes32 => uint256) VAR56;
mapping(bytes32 => address) VAR57;
mapping(bytes32 => bool) VAR58;
mapping(address => uint256) VAR59;
}
mapping(bytes32 => VAR55) VAR60;
function FUN15(bytes32 VAR61, bytes32 VAR62, uint256 VAR35) onlyOwner {
VAR60[VAR61].VAR56[VAR62] = VAR35;
}
function FUN13(bytes32 VAR61, bytes32 VAR62) constant returns(uint256) {
return VAR60[VAR61].VAR56[VAR62];
}
function FUN50(bytes32 VAR61, bytes32 VAR62, address VAR35) onlyOwner {
VAR60[VAR61].VAR57[VAR62] = VAR35;
}
function FUN51(bytes32 VAR61, bytes32 VAR62) constant returns(address) {
return VAR60[VAR61].VAR57[VAR62];
}
function FUN52(bytes32 VAR61, bytes32 VAR62, bool VAR35) onlyOwner {
VAR60[VAR61].VAR58[VAR62] = VAR35;
}
function FUN53(bytes32 VAR61, bytes32 VAR62) constant returns(bool) {
return VAR60[VAR61].VAR58[VAR62];
}
function FUN11(bytes32 VAR61, address VAR62, uint256 VAR35) onlyOwner {
VAR60[VAR61].VAR59[VAR62] = VAR35;
}
function FUN9(bytes32 VAR61, address VAR62) constant returns(uint256) {
return VAR60[VAR61].VAR59[VAR62];
}
}
contract NutzEnabled is VAR63, VAR13 {
using SafeMath for uint;
address public VAR64;
modifier FUN54() {
require(msg.sender == VAR64);
VAR9;
}
function FUN55(address VAR65, address VAR15)
FUN6(VAR15) {
VAR64 = VAR65;
}
function FUN34() constant returns (uint256) {
return FUN12();
}
function FUN56() constant returns (uint256) {
return FUN12().FUN57(FUN18()).FUN57(FUN16());
}
mapping (address => mapping (address => uint)) internal VAR66;
function FUN36(address VAR16, address VAR40) constant returns (uint256) {
return VAR66[VAR16][VAR40];
}
function FUN38(address VAR16, address VAR40, uint256 VAR67) public onlyNutz VAR31 {
require(VAR16 != VAR40);
VAR66[VAR16][VAR40] = VAR67;
}
function FUN58(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) internal {
require(VAR34 != address(this));
require(VAR34 != address(0));
require(VAR67 > 0);
require(VAR41 != VAR34);
FUN10(VAR41, FUN7(VAR41).FUN59(VAR67));
FUN10(VAR34, FUN7(VAR34).FUN57(VAR67));
}
function transfer(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public onlyNutz VAR31 {
FUN58(VAR41, VAR34, VAR67, VAR50);
}
function FUN37(address VAR68, address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public onlyNutz VAR31 {
VAR66[VAR41][VAR68] = VAR66[VAR41][VAR68].FUN59(VAR67);
FUN58(VAR41, VAR34, VAR67, VAR50);
}
}
contract VAR69 {
function FUN60(address VAR41, uint VAR35, bytes VAR50);
}
contract VAR70 {
bool public VAR30;
address public VAR64;
function FUN7(address VAR16) constant returns (uint256);
function FUN12() constant returns (uint256);
function FUN16() constant returns (uint256);
function FUN18() constant returns (uint256);
function FUN34() constant returns (uint256);
function FUN56() constant returns (uint256);
function FUN36(address VAR16, address VAR40) constant returns (uint256);
function FUN38(address VAR16, address VAR40, uint256 VAR67) public;
function transfer(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public;
function FUN37(address VAR68, address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public;
function FUN61() constant returns (uint256);
function FUN62() constant returns (uint256);
function FUN63(address VAR68, uint256 VAR35, uint256 VAR71) public returns (uint256);
function FUN64(address VAR41, uint256 VAR71, uint256 VAR67);
function FUN20(address VAR16) constant returns (uint256);
function FUN22() constant returns (uint256);
function FUN24() constant returns (uint256);
function FUN44() constant returns (uint256);
function FUN46(address VAR68, address VAR41, uint256 VAR67) public;
function FUN49(address VAR16, uint256 VAR72) public;
function FUN47(address VAR16, uint256 VAR51) public;
function FUN26(address VAR16) constant public returns(uint256, uint256, uint256);
function FUN48() constant returns (uint256);
}
contract PullPayment is VAR44 {
using SafeMath for uint256;
uint public VAR73 = 1000000000000000000000;
uint public VAR74;
uint public VAR75;
mapping(address => uint256) internal VAR76;
modifier FUN54() {
require(msg.sender == FUN43(VAR42).FUN65());
VAR9;
}
modifier FUN30 () {
require(!FUN43(VAR42).FUN66());
VAR9;
}
function FUN35(address VAR16) constant returns (uint256 value) {
return FUN67(VAR76[VAR16]);
}
function FUN68(address VAR16) constant returns (uint256 value, uint256 VAR77) {
value = FUN67(VAR76[VAR16]);
VAR77 = (VAR76[VAR16] >> 192);
return;
}
function FUN69(uint VAR78) public onlyOwner {
VAR73 = VAR78;
}
function FUN70(address VAR16, uint256 VAR79)  public onlyOwner {
VAR76[VAR16] = (VAR79 << 192) + FUN67(VAR76[VAR16]);
}
function FUN1(address VAR3) public payable VAR80 {
require(msg.value > 0);
uint256 VAR81 = msg.value.FUN57(FUN67(VAR76[VAR3]));
uint256 VAR82;
if (FUN71(msg.value)) {
uint256 VAR77 = VAR76[VAR3] >> 192;
VAR82 = (VAR77 > VAR54) ? VAR77 : VAR54;
} else {
VAR82 = VAR54.FUN57(3 VAR83);
}
VAR75 = VAR75.FUN57(msg.value);
VAR76[VAR3] = (VAR82 << 192) + FUN67(VAR81);
}
function FUN72() public VAR31 {
address VAR84 = msg.sender;
uint256 VAR85 = FUN67(VAR76[VAR84]);
require(VAR85 != 0);
require(VAR54 >= (VAR76[VAR84] >> 192));
require(this.VAR86 >= VAR85);
VAR76[VAR84] = 0;
assert(VAR84.call.FUN73(1000).value(VAR85)());
}
function FUN71(uint VAR87) internal returns (bool) {
if (VAR54 > VAR74.FUN57(24 VAR88)) {
VAR74 = VAR54;
VAR75 = 0;
}
if (VAR75 + VAR87 > VAR73 || VAR75 + VAR87 < VAR75) {
return false;
}
return true;
}
}
contract Nutz is VAR44, VAR89 {
event FUN74(address indexed VAR90, uint256 value);
string public VAR47 = "";
string public VAR48 = "";
uint256 public VAR49 = 12;
function FUN35(address VAR16) constant returns (uint) {
return FUN43(VAR42).FUN7(VAR16);
}
function FUN34() constant returns (uint256) {
return FUN43(VAR42).FUN34();
}
function FUN12() constant returns (uint256) {
return FUN43(VAR42).FUN12();
}
function FUN36(address VAR16, address VAR40) constant returns (uint256) {
return FUN43(VAR42).FUN36(VAR16, VAR40);
}
function FUN61() constant returns (uint256) {
return FUN43(VAR42).FUN61();
}
function FUN62() constant returns (uint256) {
return FUN43(VAR42).FUN62();
}
function FUN18() constant returns (uint256) {
return FUN43(VAR42).FUN18();
}
function FUN75(address VAR41, address VAR34, uint256 VAR35, bytes VAR50) internal {
uint256 VAR91;
VAR92 {
VAR91 := FUN76(VAR34)
}
if(VAR91>0) {
ERC223ReceivingContract VAR93 = FUN77(VAR34);
VAR93.FUN60(VAR41, VAR35, VAR50);
}
}
function FUN78(address VAR94, address VAR28, uint256 VAR67) public onlyOwner {
bytes memory VAR95;
FUN75(VAR94, VAR28, VAR67, VAR95);
Transfer(VAR94, VAR28, VAR67);
}
function FUN1(address VAR96, address VAR3, uint256 VAR97) public onlyOwner {
assert(VAR97 <= this.VAR86);
FUN79(VAR96).VAR98.value(VAR97)(VAR3);
}
function FUN38(address VAR40, uint256 VAR67) public {
FUN43(VAR42).FUN38(msg.sender, VAR40, VAR67);
FUN39(msg.sender, VAR40, VAR67);
}
function transfer(address VAR34, uint256 VAR67, bytes VAR50) public returns (bool) {
FUN43(VAR42).transfer(msg.sender, VAR34, VAR67, VAR50);
Transfer(msg.sender, VAR34, VAR67);
FUN75(msg.sender, VAR34, VAR67, VAR50);
return true;
}
function transfer(address VAR34, uint256 VAR67) public returns (bool) {
bytes memory VAR95;
return transfer(VAR34, VAR67, VAR95);
}
function FUN80(address VAR34, uint256 VAR67, bytes VAR50) public returns (bool) {
return transfer(VAR34, VAR67, VAR50);
}
function FUN37(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public returns (bool) {
FUN43(VAR42).FUN37(msg.sender, VAR41, VAR34, VAR67, VAR50);
Transfer(VAR41, VAR34, VAR67);
FUN75(VAR41, VAR34, VAR67, VAR50);
return true;
}
function FUN37(address VAR41, address VAR34, uint256 VAR67) public returns (bool) {
bytes memory VAR95;
return FUN37(VAR41, VAR34, VAR67, VAR95);
}
function () public payable {
uint256 VAR99 = FUN43(VAR42).FUN62();
FUN63(VAR99);
require(msg.value > 0);
}
function FUN63(uint256 VAR71) public payable {
require(msg.value > 0);
uint256 VAR100 = FUN43(VAR42).FUN63(msg.sender, msg.value, VAR71);
Transfer(VAR42, msg.sender, VAR100);
bytes memory VAR95;
FUN75(address(this), msg.sender, VAR100, VAR95);
}
function FUN64(uint256 VAR71, uint256 VAR67) public {
require(VAR67 != 0);
FUN43(VAR42).FUN64(msg.sender, VAR71, VAR67);
FUN74(msg.sender, VAR67);
}
function FUN46(uint256 VAR67) public {
Transfer(msg.sender, VAR42, VAR67);
FUN43(VAR42).FUN46(msg.sender, msg.sender, VAR67);
}
}
contract MarketEnabled is VAR101 {
uint256 constant VAR102 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
address public VAR103;
uint256 internal VAR104;
uint256 internal VAR105;
function FUN81(address VAR96, address VAR15, address VAR65)
FUN55(VAR65, VAR15) {
VAR103 = VAR96;
}
function FUN62() constant returns (uint256) {
return VAR104;
}
function FUN61() constant returns (uint256) {
if (VAR64.VAR86 == 0) {
return VAR102;
}
uint256 VAR106 = FUN12().FUN82(1000000).FUN83(VAR64.VAR86);
return VAR106 >= VAR105 ? VAR106 : VAR105;
}
function FUN84(uint256 VAR107) public VAR11 {
require(VAR107 <= VAR105);
VAR104 = VAR107;
}
function FUN85(uint256 VAR108) public VAR11 {
require(VAR108 >= VAR104);
if (VAR108 < VAR102) {
require(VAR64.VAR86 >= FUN12().FUN82(1000000).FUN83(VAR108));
}
VAR105 = VAR108;
}
function FUN63(address VAR68, uint256 VAR35, uint256 VAR71) public onlyNutz whenNotPaused returns (uint256) {
require(VAR104 > 0);
require(VAR71 == VAR104);
uint256 VAR100 = VAR104.FUN82(VAR35).FUN83(1000000);
require(VAR100 > 0);
uint256 VAR109 = FUN12();
uint256 VAR110 = FUN18();
if (VAR110 > 0) {
uint256 VAR111 = VAR110.FUN82(VAR100).FUN83(VAR109.FUN57(FUN16()));
FUN19(VAR110.FUN57(VAR111));
}
FUN14(VAR109.FUN57(VAR100));
FUN10(VAR68, FUN7(VAR68).FUN57(VAR100));
return VAR100;
}
function FUN64(address VAR41, uint256 VAR71, uint256 VAR67) public onlyNutz VAR31 {
uint256 VAR112 = FUN61();
require(VAR67 != 0);
require(VAR112 != VAR102);
require(VAR71 == VAR112);
uint256 VAR85 = VAR67.FUN82(1000000).FUN83(VAR112);
require(VAR85 > 0);
uint256 VAR110 = FUN18();
uint256 VAR109 = FUN12();
if (VAR110 > 0) {
uint256 VAR111 = VAR110.FUN82(VAR67).FUN83(VAR109.FUN57(FUN16()));
FUN19(VAR110.FUN59(VAR111));
}
FUN14(VAR109.FUN59(VAR67));
FUN10(VAR41, FUN7(VAR41).FUN59(VAR67));
FUN86(VAR64).FUN1(VAR103, VAR41, VAR85);
}
function FUN87(uint256 VAR97, address VAR113) public VAR11 {
require(VAR97 > 0);
require(VAR64.VAR86.FUN59(VAR97) >= FUN12().FUN82(1000000).FUN83(VAR105));
FUN86(VAR64).FUN1(VAR103, VAR113, VAR97);
}
}
contract PowerEnabled is VAR114 {
address public VAR94;
uint256 public VAR115 = 0;
uint256 public VAR53;
uint public constant VAR116 = 100000;
modifier FUN88() {
require(msg.sender == VAR94);
VAR9;
}
function FUN89(address VAR117, address VAR96, address VAR15, address VAR65)
FUN81(VAR96, VAR65, VAR15) {
VAR94 = VAR117;
}
function FUN90(uint256 VAR118) public VAR11 {
require(FUN22() <= VAR118 && VAR118 < FUN24());
VAR115 = VAR118;
}
function FUN91(uint256 VAR119) public VAR11 {
VAR53 = VAR119;
}
function FUN92() public constant returns (uint256) {
uint256 VAR120 = FUN56();
if (VAR120 == 0) {
return VAR102;
}
return VAR120.FUN83(VAR116);
}
function FUN93(uint256 VAR67, uint256 VAR51) public VAR11 {
uint256 VAR121 = FUN24();
uint256 VAR122 = FUN56();
if (VAR121 == 0) {
FUN25((VAR51 > 0) ? VAR51 : VAR67.FUN57(VAR122));
} else {
FUN25(VAR121.FUN82(VAR122.FUN57(VAR67)).FUN83(VAR122));
}
FUN17(FUN16().FUN57(VAR67));
}
function FUN94(address VAR28, uint256 VAR35, bytes32 VAR50) internal {
uint256 VAR123 = FUN22();
FUN23(VAR123.FUN59(VAR35));
uint256 VAR110 = FUN18();
uint256 VAR124 = VAR35.FUN82(VAR110).FUN83(VAR123);
FUN19(VAR110.FUN59(VAR124));
FUN95(VAR94).FUN45(VAR28, VAR35, VAR50);
}
function FUN45(address VAR28, uint256 VAR35, bytes32 VAR50) public VAR11 {
FUN21(VAR28, FUN20(VAR28).FUN59(VAR35));
FUN94(VAR28, VAR35, VAR50);
}
function FUN96(uint256 VAR125, address VAR28, uint256 VAR35, bytes32 VAR50) public VAR11 {
FUN97 (VAR24, VAR25, VAR26) = FUN26(VAR28);
VAR25 = VAR25.FUN59(VAR35);
FUN29(VAR28, VAR24, VAR25, VAR26);
FUN94(VAR28, VAR35, VAR50);
}
function FUN46(address VAR68, address VAR41, uint256 VAR67) public onlyNutz VAR31 {
uint256 VAR121 = FUN24();
require(VAR121 != 0);
require(VAR67 != 0);
uint256 VAR122 = FUN56();
require(VAR122 != 0);
uint256 VAR126 = VAR67.FUN82(VAR121).FUN83(VAR122);
uint256 VAR127 = FUN22();
require(VAR127.FUN57(VAR126) <= VAR115);
uint256 VAR128 = FUN20(VAR41).FUN57(VAR126);
require(VAR128 >= VAR121.FUN83(VAR116));
if (VAR68 != VAR41) {
VAR66[VAR41][VAR68] = VAR66[VAR41][VAR68].FUN59(VAR67);
}
FUN23(VAR127.FUN57(VAR126));
FUN21(VAR41, VAR128);
FUN14(FUN12().FUN59(VAR67));
FUN10(VAR41, FUN7(VAR41).FUN59(VAR67));
FUN19(FUN18().FUN57(VAR67));
FUN95(VAR94).FUN46(VAR41, VAR126);
}
function FUN44() constant returns (uint256) {
uint256 VAR129 = FUN24().FUN83(2);
return VAR115 >= VAR129 ? VAR115 : VAR129;
}
function FUN98(uint256 VAR130, uint256 VAR131, uint256 VAR132, uint256 VAR72) internal constant returns (uint256) {
if (VAR72 <= VAR132) {
return 0;
}
uint256 VAR133 = VAR72.FUN59(VAR132);
if (VAR133 > VAR53) {
VAR133 = VAR53;
}
uint256 VAR134 = VAR130.FUN82(VAR133).FUN83(VAR53);
uint256 VAR135 = VAR130.FUN59(VAR134);
if (VAR131 <= VAR135) {
return 0;
}
return VAR131.FUN59(VAR135);
}
function FUN47(address VAR16, uint256 VAR51) public onlyPower VAR31 {
require(VAR51 >= FUN24().FUN83(VAR116));
FUN21(VAR16, FUN20(VAR16).FUN59(VAR51));
FUN97 (, VAR25, ) = FUN26(VAR16);
uint256 VAR24 = VAR51.FUN57(VAR25);
FUN29(VAR16, VAR24, VAR24, VAR54);
}
function FUN49(address VAR28, uint256 VAR72) public onlyPower VAR31 {
FUN97 (VAR24, VAR25, VAR26) = FUN26(VAR28);
uint256 VAR126 = FUN98(VAR24, VAR25, VAR26, VAR72);
uint256 VAR136 = VAR24.FUN83(10);
require(VAR25 <= VAR136 || VAR136 <= VAR126);
uint256 VAR100 = VAR126.FUN82(FUN56()).FUN83(FUN24());
FUN23(FUN22().FUN59(VAR126));
VAR25 = VAR25.FUN59(VAR126);
FUN19(FUN18().FUN59(VAR100));
FUN14(FUN12().FUN57(VAR100));
FUN10(VAR28, FUN7(VAR28).FUN57(VAR100));
if (VAR25 == 0) {
VAR26 = 0;
VAR24 = 0;
}
FUN29(VAR28, VAR24, VAR25, VAR26);
FUN86(VAR64).FUN78(VAR94, VAR28, VAR100);
}
}
library VAR137 {
function FUN82(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
uint256 VAR140 = VAR138 * VAR139;
assert(VAR138 == 0 || VAR140 / VAR138 == VAR139);
return VAR140;
}
function FUN83(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
uint256 VAR140 = VAR138 / VAR139;
return VAR140;
}
function FUN59(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
assert(VAR139 <= VAR138);
return VAR138 - VAR139;
}
function FUN57(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
uint256 VAR140 = VAR138 + VAR139;
assert(VAR140 >= VAR138);
return VAR140;
}
}
contract Controller is VAR141 {
function FUN99(address VAR117, address VAR96, address VAR65, address VAR15)
FUN89(VAR117, VAR96, VAR65, VAR15) {
}
function FUN100(address VAR15, address VAR65, address VAR117, address VAR96) public onlyAdmins VAR32 {
VAR14 = VAR15;
VAR64 = VAR65;
VAR94 = VAR117;
VAR103 = VAR96;
}
function FUN69(uint256 VAR78) public VAR11 {
FUN101(VAR103).FUN69(VAR78);
}
function FUN102(address VAR142) public onlyAdmins VAR32 {
if (VAR94 != address(0)) { FUN40(VAR94).FUN41(msg.sender); }
if (VAR103 != address(0)) { FUN40(VAR103).FUN41(msg.sender); }
if (VAR64 != address(0)) { FUN40(VAR64).FUN41(msg.sender); }
if (VAR14 != address(0)) { FUN40(VAR14).FUN41(msg.sender); }
FUN103(VAR142);
}
}
contract VAR143 {
using SafeMath for uint;
enum VAR144 { VAR145, VAR146 }
EventState public VAR147;
address public VAR148;
address public VAR149;
address public VAR150;
address VAR151;
address VAR14;
address VAR64;
address VAR94;
uint256 VAR115;
uint256 VAR53;
uint256 VAR104;
uint256 VAR105;
function FUN104(address VAR152, address VAR153, address VAR154) {
VAR147 = VAR144.VAR145;
VAR148 = VAR153;
VAR149 = VAR152;
VAR151 = VAR154;
VAR150 = msg.sender;
}
modifier FUN105(EventState VAR155) {
require(VAR147 == VAR155);
VAR9;
}
function FUN106() FUN105(VAR144.VAR145) {
var VAR156 = FUN99(VAR149);
VAR156.FUN32();
require(VAR156.FUN107(1) == address(this));
require(VAR156.FUN66() == true);
var VAR157 = FUN99(VAR148);
require(VAR157.FUN107(1) == address(this));
require(VAR157.FUN66() == true);
VAR14 = VAR156.FUN108();
VAR64 = VAR156.FUN65();
VAR94 = VAR156.FUN109();
VAR115 = VAR156.FUN110();
VAR53 = VAR156.FUN48();
VAR104 = VAR156.FUN62();
VAR105 = VAR156.FUN61();
uint VAR158 = (VAR156.FUN22()).FUN82(VAR156.FUN12().FUN57(VAR156.FUN16())).FUN83(VAR156.FUN24().FUN59(VAR156.FUN22()));
VAR156.FUN100(VAR94, VAR151, VAR64, VAR14);
VAR156.FUN102(VAR148);
FUN40(VAR64).FUN41(VAR148);
FUN40(VAR94).FUN41(VAR148);
FUN8(VAR14).FUN15('', '', VAR158);
FUN40(VAR14).FUN41(VAR148);
FUN40(VAR151).FUN41(VAR148);
if (VAR115 > 0) {
VAR157.FUN90(VAR115);
}
VAR157.FUN91(VAR53);
VAR157.FUN85(VAR105);
VAR157.FUN84(VAR104);
VAR157.FUN33();
VAR157.FUN5(address(this));
VAR147 = VAR144.VAR146;
}
}
1
---------------------------------
128 0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
struct VAR3
{
uint VAR4;
uint VAR5;
}
mapping (address => VAR3) public VAR6;
uint public VAR7;
LogFile VAR8;
bool VAR9;
function FUN1(uint VAR10)
public
{
if(VAR9)throw;
VAR7 = VAR10;
}
function FUN2(address VAR11)
public
{
if(VAR9)throw;
VAR8 = FUN3(VAR11);
}
function FUN4()
public
{
VAR9 = true;
}
function FUN5(uint VAR12)
public
payable
{
var VAR13 = VAR6[msg.sender];
VAR13.VAR5 += msg.value;
if(VAR14+VAR12>VAR13.VAR4)VAR13.VAR4=VAR14+VAR12;
VAR8.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR15)
public
payable
{
var VAR13 = VAR6[msg.sender];
if( VAR13.VAR5>=VAR7 && VAR13.VAR5>=VAR15 && VAR14>VAR13.VAR4)
{
if(msg.sender.call.value(VAR15)())
{
VAR13.VAR5-=VAR15;
VAR8.FUN6(msg.sender,VAR15,"");
}
}
}
function()
public
payable
{
FUN5(0);
}
}
contract VAR16
{
struct VAR17
{
address VAR18;
string  VAR19;
uint VAR20;
uint  VAR21;
}
VAR17[] public VAR22;
Message VAR23;
function FUN6(address VAR24,uint VAR10,string VAR25)
public
{
VAR23.VAR18 = VAR24;
VAR23.VAR21 = VAR14;
VAR23.VAR20 = VAR10;
VAR23.VAR19 = VAR25;
VAR22.FUN8(VAR23);
}
}
1
---------------------------------
129 0x851cc731ce1613ae4fd8ec7f61f4b350f9ce1020.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address public VAR3;
event FUN1(address indexed VAR4);
modifier onlyOwner {
require(msg.sender == VAR3, "");
VAR5;
}
constructor() public {
VAR3 = msg.sender;
}
function FUN2(address VAR4) external onlyOwner {
require(VAR4 != address(0), "");
VAR3 = VAR4;
emit FUN1(VAR4);
}
}
contract Managed is VAR2 {
mapping (address => bool) public VAR6;
modifier onlyManager {
require(VAR6[msg.sender] == true, "");
VAR5;
}
event FUN3(address indexed VAR7);
event FUN4(address indexed VAR7);
function FUN5(address VAR7) external onlyOwner {
require(VAR7 != address(0), "");
if(VAR6[VAR7] == false) {
VAR6[VAR7] = true;
emit FUN3(VAR7);
}
}
function FUN6(address VAR7) external onlyOwner {
require(VAR6[VAR7] == true, "");
delete VAR6[VAR7];
emit FUN4(VAR7);
}
}
contract VAR8 {
function FUN7(bytes32 VAR9) public view returns (address);
function FUN8(bytes32 VAR9) public view returns (address);
function FUN9(bytes32 VAR9) public view returns (VAR10);
function FUN10(bytes32 VAR9, address VAR11) public;
function FUN11(bytes32 VAR9, bytes32 VAR12, address VAR11) public;
function FUN12(bytes32 VAR9, address VAR13) public;
function FUN13(bytes32 VAR9, uint64 VAR14) public;
}
contract VAR15 {
function FUN14(bytes32 VAR9) public view returns (address);
function FUN15(bytes32 VAR9, address VAR16) public;
function FUN16(bytes32 VAR9) public view returns (string);
function FUN17(bytes32 VAR9, string VAR17) public;
}
contract VAR18 {
function FUN18(address VAR11) public returns (bytes32 VAR9);
function FUN19(address VAR11, address VAR13) public returns (bytes32);
function FUN17(string VAR17) public returns (bytes32);
function FUN20(address VAR16) public view returns (bytes32);
}
library VAR19 {
struct VAR20 {
uint VAR21;
uint VAR22;
}
function FUN21(uint VAR23, uint VAR24, uint VAR25) private pure {
for(; VAR25 >= 32; VAR25 -= 32) {
VAR26 {
FUN22(VAR23, FUN23(VAR24))
}
VAR23 += 32;
VAR24 += 32;
}
uint VAR27 = 256 ** (32 - VAR25) - 1;
VAR26 {
let VAR28 := FUN24(FUN23(VAR24), FUN25(VAR27))
let VAR29 := FUN24(FUN23(VAR23), VAR27)
FUN22(VAR23, or(VAR29, VAR28))
}
}
function FUN26(string memory VAR30) internal pure returns (slice VAR31) {
uint VAR32;
VAR26 {
VAR32 := FUN27(VAR30, 0x20)
}
return FUN28(bytes(VAR30).VAR33, VAR32);
}
function FUN29(bytes32 VAR30) internal pure returns (uint) {
uint VAR34;
if (VAR30 == 0)
return 0;
if (VAR30 & 0xffffffffffffffffffffffffffffffff == 0) {
VAR34 += 16;
VAR30 = bytes32(uint(VAR30) / 0x100000000000000000000000000000000);
}
if (VAR30 & 0xffffffffffffffff == 0) {
VAR34 += 8;
VAR30 = bytes32(uint(VAR30) / 0x10000000000000000);
}
if (VAR30 & 0xffffffff == 0) {
VAR34 += 4;
VAR30 = bytes32(uint(VAR30) / 0x100000000);
}
if (VAR30 & 0xffff == 0) {
VAR34 += 2;
VAR30 = bytes32(uint(VAR30) / 0x10000);
}
if (VAR30 & 0xff == 0) {
VAR34 += 1;
}
return 32 - VAR34;
}
function FUN30(bytes32 VAR30) internal pure returns (slice memory VAR34) {
VAR26 {
let VAR32 := FUN23(0x40)
FUN22(0x40, FUN27(VAR32, 0x20))
FUN22(VAR32, VAR30)
FUN22(FUN27(VAR34, 0x20), VAR32)
}
VAR34.VAR21 = FUN29(VAR30);
}
function FUN31(slice memory VAR30) internal pure returns (slice VAR31) {
return FUN28(VAR30.VAR21, VAR30.VAR22);
}
function FUN32(slice memory VAR30) internal pure returns (string VAR31) {
string memory VAR34 = VAR35 string(VAR30.VAR21);
uint VAR36;
VAR26 { VAR36 := FUN27(VAR34, 32) }
FUN21(VAR36, VAR30.VAR22, VAR30.VAR21);
return VAR34;
}
function FUN29(slice memory VAR30) internal pure returns (uint VAR37) {
uint VAR32 = VAR30.VAR22 - 31;
uint VAR38 = VAR32 + VAR30.VAR21;
for (VAR37 = 0; VAR32 < VAR38; VAR37++) {
uint8 VAR39;
VAR26 { VAR39 := FUN24(FUN23(VAR32), 0xFF) }
if (VAR39 < 0x80) {
VAR32 += 1;
} else if(VAR39 < 0xE0) {
VAR32 += 2;
} else if(VAR39 < 0xF0) {
VAR32 += 3;
} else if(VAR39 < 0xF8) {
VAR32 += 4;
} else if(VAR39 < 0xFC) {
VAR32 += 5;
} else {
VAR32 += 6;
}
}
}
function FUN33(slice memory VAR30) internal pure returns (bool) {
return VAR30.VAR21 == 0;
}
function FUN34(slice memory VAR30, slice memory VAR40) internal pure returns (int) {
uint VAR41 = VAR30.VAR21;
if (VAR40.VAR21 < VAR30.VAR21)
VAR41 = VAR40.VAR21;
uint VAR42 = VAR30.VAR22;
uint VAR43 = VAR40.VAR22;
for (uint VAR44 = 0; VAR44 < VAR41; VAR44 += 32) {
uint VAR45;
uint VAR39;
VAR26 {
VAR45 := FUN23(VAR42)
VAR39 := FUN23(VAR43)
}
if (VAR45 != VAR39) {
uint256 VAR27 = uint256(-1);
if(VAR41 < 32) {
VAR27 = ~(2 ** (8 * (32 - VAR41 + VAR44)) - 1);
}
uint256 VAR46 = (VAR45 & VAR27) - (VAR39 & VAR27);
if (VAR46 != 0)
return int(VAR46);
}
VAR42 += 32;
VAR43 += 32;
}
return int(VAR30.VAR21) - int(VAR40.VAR21);
}
function FUN35(slice memory VAR30, slice memory VAR40) internal pure returns (bool) {
return FUN34(VAR30, VAR40) == 0;
}
function FUN36(slice memory VAR30, slice memory VAR47) internal pure returns (slice VAR31) {
VAR47.VAR22 = VAR30.VAR22;
if (VAR30.VAR21 == 0) {
VAR47.VAR21 = 0;
return VAR47;
}
uint VAR37;
uint VAR39;
VAR26 { VAR39 := FUN24(FUN23(FUN37(FUN23(FUN27(VAR30, 32)), 31)), 0xFF) }
if (VAR39 < 0x80) {
VAR37 = 1;
} else if(VAR39 < 0xE0) {
VAR37 = 2;
} else if(VAR39 < 0xF0) {
VAR37 = 3;
} else {
VAR37 = 4;
}
if (VAR37 > VAR30.VAR21) {
VAR47.VAR21 = VAR30.VAR21;
VAR30.VAR22 += VAR30.VAR21;
VAR30.VAR21 = 0;
return VAR47;
}
VAR30.VAR22 += VAR37;
VAR30.VAR21 -= VAR37;
VAR47.VAR21 = VAR37;
return VAR47;
}
function FUN36(slice memory VAR30) internal pure returns (slice memory VAR34) {
FUN36(VAR30, VAR34);
}
function FUN38(slice memory VAR30) internal pure returns (uint VAR34) {
if (VAR30.VAR21 == 0) {
return 0;
}
uint VAR48;
uint VAR33;
uint VAR49 = 2 ** 248;
VAR26 { VAR48:= FUN23(FUN23(FUN27(VAR30, 32))) }
uint VAR39 = VAR48 / VAR49;
if (VAR39 < 0x80) {
VAR34 = VAR39;
VAR33 = 1;
} else if(VAR39 < 0xE0) {
VAR34 = VAR39 & 0x1F;
VAR33 = 2;
} else if(VAR39 < 0xF0) {
VAR34 = VAR39 & 0x0F;
VAR33 = 3;
} else {
VAR34 = VAR39 & 0x07;
VAR33 = 4;
}
if (VAR33 > VAR30.VAR21) {
return 0;
}
for (uint VAR50 = 1; VAR50 < VAR33; VAR50++) {
VAR49 = VAR49 / 256;
VAR39 = (VAR48 / VAR49) & 0xFF;
if (VAR39 & 0xC0 != 0x80) {
return 0;
}
VAR34 = (VAR34 * 64) | (VAR39 & 0x3F);
}
return VAR34;
}
function FUN39(slice memory VAR30) internal pure returns (bytes32 VAR34) {
VAR26 {
VAR34 := FUN40(FUN23(FUN27(VAR30, 32)), FUN23(VAR30))
}
}
function FUN41(slice memory VAR30, slice memory VAR51) internal pure returns (bool) {
if (VAR30.VAR21 < VAR51.VAR21) {
return false;
}
if (VAR30.VAR22 == VAR51.VAR22) {
return true;
}
bool VAR52;
VAR26 {
let VAR33 := FUN23(VAR51)
let VAR42 := FUN23(FUN27(VAR30, 0x20))
let VAR53 := FUN23(FUN27(VAR51, 0x20))
VAR52 := FUN42(FUN40(VAR42, VAR33), FUN40(VAR53, VAR33))
}
return VAR52;
}
function FUN43(slice memory VAR30, slice memory VAR51) internal pure returns (slice VAR31) {
if (VAR30.VAR21 < VAR51.VAR21) {
return VAR30;
}
bool VAR52 = true;
if (VAR30.VAR22 != VAR51.VAR22) {
VAR26 {
let VAR33 := FUN23(VAR51)
let VAR42 := FUN23(FUN27(VAR30, 0x20))
let VAR53 := FUN23(FUN27(VAR51, 0x20))
VAR52 := FUN42(FUN40(VAR42, VAR33), FUN40(VAR53, VAR33))
}
}
if (VAR52) {
VAR30.VAR21 -= VAR51.VAR21;
VAR30.VAR22 += VAR51.VAR21;
}
return VAR30;
}
function FUN44(slice memory VAR30, slice memory VAR51) internal pure returns (bool) {
if (VAR30.VAR21 < VAR51.VAR21) {
return false;
}
uint VAR42 = VAR30.VAR22 + VAR30.VAR21 - VAR51.VAR21;
if (VAR42 == VAR51.VAR22) {
return true;
}
bool VAR52;
VAR26 {
let VAR33 := FUN23(VAR51)
let VAR53 := FUN23(FUN27(VAR51, 0x20))
VAR52 := FUN42(FUN40(VAR42, VAR33), FUN40(VAR53, VAR33))
}
return VAR52;
}
function FUN45(slice memory VAR30, slice memory VAR51) internal pure returns (slice VAR31) {
if (VAR30.VAR21 < VAR51.VAR21) {
return VAR30;
}
uint VAR42 = VAR30.VAR22 + VAR30.VAR21 - VAR51.VAR21;
bool VAR52 = true;
if (VAR42 != VAR51.VAR22) {
VAR26 {
let VAR33 := FUN23(VAR51)
let VAR53 := FUN23(FUN27(VAR51, 0x20))
VAR52 := FUN42(FUN40(VAR42, VAR33), FUN40(VAR53, VAR33))
}
}
if (VAR52) {
VAR30.VAR21 -= VAR51.VAR21;
}
return VAR30;
}
function FUN46(uint VAR54, uint VAR42, uint VAR55, uint VAR53) private pure returns (uint) {
uint VAR32 = VAR42;
uint VAR44;
if (VAR55 <= VAR54) {
if (VAR55 <= 32) {
bytes32 VAR27 = bytes32(~(2 ** (8 * (32 - VAR55)) - 1));
bytes32 VAR56;
VAR26 { VAR56 := FUN24(FUN23(VAR53), VAR27) }
uint VAR38 = VAR42 + VAR54 - VAR55;
bytes32 VAR57;
VAR26 { VAR57 := FUN24(FUN23(VAR32), VAR27) }
while (VAR57 != VAR56) {
if (VAR32 >= VAR38)
return VAR42 + VAR54;
VAR32++;
VAR26 { VAR57 := FUN24(FUN23(VAR32), VAR27) }
}
return VAR32;
} else {
bytes32 VAR58;
VAR26 { VAR58 := FUN40(VAR53, VAR55) }
for (VAR44 = 0; VAR44 <= VAR54 - VAR55; VAR44++) {
bytes32 VAR59;
VAR26 { VAR59 := FUN40(VAR32, VAR55) }
if (VAR58 == VAR59)
return VAR32;
VAR32 += 1;
}
}
}
return VAR42 + VAR54;
}
function FUN47(uint VAR54, uint VAR42, uint VAR55, uint VAR53) private pure returns (uint) {
uint VAR32;
if (VAR55 <= VAR54) {
if (VAR55 <= 32) {
bytes32 VAR27 = bytes32(~(2 ** (8 * (32 - VAR55)) - 1));
bytes32 VAR56;
VAR26 { VAR56 := FUN24(FUN23(VAR53), VAR27) }
VAR32 = VAR42 + VAR54 - VAR55;
bytes32 VAR57;
VAR26 { VAR57 := FUN24(FUN23(VAR32), VAR27) }
while (VAR57 != VAR56) {
if (VAR32 <= VAR42)
return VAR42;
VAR32--;
VAR26 { VAR57 := FUN24(FUN23(VAR32), VAR27) }
}
return VAR32 + VAR55;
} else {
bytes32 VAR58;
VAR26 { VAR58 := FUN40(VAR53, VAR55) }
VAR32 = VAR42 + (VAR54 - VAR55);
while (VAR32 >= VAR42) {
bytes32 VAR59;
VAR26 { VAR59 := FUN40(VAR32, VAR55) }
if (VAR58 == VAR59)
return VAR32 + VAR55;
VAR32 -= 1;
}
}
}
return VAR42;
}
function FUN48(slice memory VAR30, slice memory VAR51) internal pure returns (slice VAR31) {
uint VAR32 = FUN46(VAR30.VAR21, VAR30.VAR22, VAR51.VAR21, VAR51.VAR22);
VAR30.VAR21 -= VAR32 - VAR30.VAR22;
VAR30.VAR22 = VAR32;
return VAR30;
}
function FUN49(slice memory VAR30, slice memory VAR51) internal pure returns (slice VAR31) {
uint VAR32 = FUN47(VAR30.VAR21, VAR30.VAR22, VAR51.VAR21, VAR51.VAR22);
VAR30.VAR21 = VAR32 - VAR30.VAR22;
return VAR30;
}
function FUN50(slice memory VAR30, slice memory VAR51, slice memory VAR60) internal pure returns (slice VAR31) {
uint VAR32 = FUN46(VAR30.VAR21, VAR30.VAR22, VAR51.VAR21, VAR51.VAR22);
VAR60.VAR22 = VAR30.VAR22;
VAR60.VAR21 = VAR32 - VAR30.VAR22;
if (VAR32 == VAR30.VAR22 + VAR30.VAR21) {
VAR30.VAR21 = 0;
} else {
VAR30.VAR21 -= VAR60.VAR21 + VAR51.VAR21;
VAR30.VAR22 = VAR32 + VAR51.VAR21;
}
return VAR60;
}
function FUN50(slice memory VAR30, slice memory VAR51) internal pure returns (slice memory VAR60) {
FUN50(VAR30, VAR51, VAR60);
}
function FUN51(slice memory VAR30, slice memory VAR51, slice memory VAR60) internal pure returns (slice VAR31) {
uint VAR32 = FUN47(VAR30.VAR21, VAR30.VAR22, VAR51.VAR21, VAR51.VAR22);
VAR60.VAR22 = VAR32;
VAR60.VAR21 = VAR30.VAR21 - (VAR32 - VAR30.VAR22);
if (VAR32 == VAR30.VAR22) {
VAR30.VAR21 = 0;
} else {
VAR30.VAR21 -= VAR60.VAR21 + VAR51.VAR21;
}
return VAR60;
}
function FUN51(slice memory VAR30, slice memory VAR51) internal pure returns (slice memory VAR60) {
FUN51(VAR30, VAR51, VAR60);
}
function FUN52(slice memory VAR30, slice memory VAR51) internal pure returns (uint VAR61) {
uint VAR32 = FUN46(VAR30.VAR21, VAR30.VAR22, VAR51.VAR21, VAR51.VAR22) + VAR51.VAR21;
while (VAR32 <= VAR30.VAR22 + VAR30.VAR21) {
VAR61++;
VAR32 = FUN46(VAR30.VAR21 - (VAR32 - VAR30.VAR22), VAR32, VAR51.VAR21, VAR51.VAR22) + VAR51.VAR21;
}
}
function FUN53(slice memory VAR30, slice memory VAR51) internal pure returns (bool) {
return FUN47(VAR30.VAR21, VAR30.VAR22, VAR51.VAR21, VAR51.VAR22) != VAR30.VAR22;
}
function FUN54(slice memory VAR30, slice memory VAR40) internal pure returns (string VAR31) {
string memory VAR34 = VAR35 string(VAR30.VAR21 + VAR40.VAR21);
uint VAR36;
VAR26 { VAR36 := FUN27(VAR34, 32) }
FUN21(VAR36, VAR30.VAR22, VAR30.VAR21);
FUN21(VAR36 + VAR30.VAR21, VAR40.VAR22, VAR40.VAR21);
return VAR34;
}
function FUN55(slice memory VAR30, VAR20[] memory VAR62) internal pure returns (string VAR31) {
if (VAR62.VAR33 == 0)
return "";
uint VAR33 = VAR30.VAR21 * (VAR62.VAR33 - 1);
for(uint VAR50 = 0; VAR50 < VAR62.VAR33; VAR50++)
VAR33 += VAR62[VAR50].VAR21;
string memory VAR34 = VAR35 string(VAR33);
uint VAR36;
VAR26 { VAR36 := FUN27(VAR34, 32) }
for(VAR50 = 0; VAR50 < VAR62.VAR33; VAR50++) {
FUN21(VAR36, VAR62[VAR50].VAR22, VAR62[VAR50].VAR21);
VAR36 += VAR62[VAR50].VAR21;
if (VAR50 < VAR62.VAR33 - 1) {
FUN21(VAR36, VAR30.VAR22, VAR30.VAR21);
VAR36 += VAR30.VAR21;
}
}
return VAR34;
}
}
contract VAR63 {
using strings for *;
bytes32 constant public VAR64 = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;
address VAR65;
constructor(address VAR66) public {
VAR65 = VAR66;
}
function FUN56(bytes32 VAR9) public view returns (address) {
address VAR67 = FUN57().FUN8(VAR9);
return FUN58(VAR67).FUN14(VAR9);
}
function FUN57() public view returns (VAR8) {
return FUN59(VAR65);
}
function FUN60() public view returns (VAR18) {
return FUN61(FUN57().FUN7(VAR64));
}
}
interface VAR68 {
function FUN62(address VAR4) external;
function FUN63(string VAR12, address VAR11) external;
function FUN64(bytes32 VAR69) external view returns(bool);
}
contract VAR70 {
address VAR71;
event FUN65(uint indexed value, address indexed sender, bytes VAR72);
constructor(address VAR73) public {
VAR71 = VAR73;
}
function() external payable {
if(msg.VAR72.VAR33 == 0 && msg.value > 0) {
emit FUN65(msg.value, msg.sender, msg.VAR72);
}
else {
VAR26 {
let VAR74 := FUN66(0)
FUN67(0, 0, FUN68())
let VAR75 := FUN69(VAR76, VAR74, 0, FUN68(), 0, 0)
FUN70(0, 0, FUN71())
switch VAR75
case 0 {revert(0, FUN71())}
default {return (0, FUN71())}
}
}
}
}
interface VAR77 {
function FUN72(BaseWallet VAR78) external;
function FUN73(BaseWallet VAR78, Module VAR79) external;
function FUN74(address VAR80) external;
}
contract VAR81 {
address public VAR71;
address public VAR3;
mapping (address => bool) public VAR82;
mapping (bytes4 => address) public VAR83;
uint public VAR84;
event FUN75(address indexed VAR85, bool value);
event FUN76(address indexed VAR85, bytes4 indexed VAR86);
event FUN77(address indexed VAR85, address indexed VAR74, uint indexed value, bytes VAR72);
event FUN65(uint indexed value, address indexed sender, bytes VAR72);
event FUN1(address VAR3);
modifier VAR87 {
require(VAR82[msg.sender], "");
VAR5;
}
function FUN72(address VAR11, address[] VAR88) external {
require(VAR3 == address(0) && VAR84 == 0, "");
require(VAR88.VAR33 > 0, "");
VAR3 = VAR11;
VAR84 = VAR88.VAR33;
for(uint256 VAR50 = 0; VAR50 < VAR88.VAR33; VAR50++) {
require(VAR82[VAR88[VAR50]] == false, "");
VAR82[VAR88[VAR50]] = true;
FUN78(VAR88[VAR50]).FUN72(this);
emit FUN75(VAR88[VAR50], true);
}
}
function FUN79(address VAR79, bool VAR89) external VAR87 {
if (VAR82[VAR79] != VAR89) {
if(VAR89 == true) {
VAR84 += 1;
VAR82[VAR79] = true;
FUN78(VAR79).FUN72(this);
}
else {
VAR84 -= 1;
require(VAR84 > 0, "");
delete VAR82[VAR79];
}
emit FUN75(VAR79, VAR89);
}
}
function FUN80(address VAR79, bytes4 VAR90) external VAR87 {
require(VAR82[VAR79], "");
VAR83[VAR90] = VAR79;
emit FUN76(VAR79, VAR90);
}
function FUN10(address VAR4) external VAR87 {
require(VAR4 != address(0), "");
VAR3 = VAR4;
emit FUN1(VAR4);
}
function FUN81(address VAR91, uint VAR89, bytes VAR92) external VAR87 {
require(VAR91.call.value(VAR89)(VAR92), "");
emit FUN77(msg.sender, VAR91, VAR89, VAR92);
}
function() public payable {
if(msg.VAR72.VAR33 > 0) {
address VAR85 = VAR83[msg.VAR93];
if(VAR85 == address(0)) {
emit FUN65(msg.value, msg.sender, msg.VAR72);
}
else {
require(VAR82[VAR85], "");
VAR26 {
FUN67(0, 0, FUN68())
let VAR75 := FUN82(VAR76, VAR85, 0, FUN68(), 0, 0)
FUN70(0, 0, FUN71())
switch VAR75
case 0 {revert(0, FUN71())}
default {return (0, FUN71())}
}
}
}
}
}
contract VAR94 {
function FUN83() public view returns (uint);
function FUN84() public view returns (uint);
function FUN85(address VAR95) public view returns (uint VAR96);
function FUN86(address VAR95, address VAR97) public view returns (uint VAR98);
function transfer(address VAR99, uint VAR100) public returns (bool VAR101);
function FUN87(address VAR97, uint VAR100) public returns (bool VAR101);
function FUN88(address VAR102, address VAR99, uint VAR100) public returns (bool VAR101);
}
contract ModuleRegistry is VAR2 {
mapping (address => VAR103) internal VAR84;
mapping (address => VAR103) internal VAR104;
event FUN89(address indexed VAR85, bytes32 VAR105);
event FUN90(address VAR85);
event FUN91(address indexed VAR106, bytes32 VAR105);
event FUN92(address VAR106);
struct VAR103 {
bool VAR107;
bytes32 VAR105;
}
function FUN93(address VAR79, bytes32 VAR17) external onlyOwner {
require(!VAR84[VAR79].VAR107, "");
VAR84[VAR79] = FUN94({VAR107: true, VAR105: VAR17});
emit FUN89(VAR79, VAR17);
}
function FUN95(address VAR79) external onlyOwner {
require(VAR84[VAR79].VAR107, "");
delete VAR84[VAR79];
emit FUN90(VAR79);
}
function FUN96(address VAR108, bytes32 VAR17) external onlyOwner {
require(!VAR104[VAR108].VAR107, "");
VAR104[VAR108] = FUN94({VAR107: true, VAR105: VAR17});
emit FUN91(VAR108, VAR17);
}
function FUN97(address VAR108) external onlyOwner {
require(VAR104[VAR108].VAR107, "");
delete VAR104[VAR108];
emit FUN92(VAR108);
}
function FUN74(address VAR80) external onlyOwner {
uint VAR109 = FUN98(VAR80).FUN85(address(this));
FUN98(VAR80).transfer(msg.sender, VAR109);
}
function FUN99(address VAR79) external view returns (bytes32) {
return VAR84[VAR79].VAR105;
}
function FUN100(address VAR108) external view returns (bytes32) {
return VAR104[VAR108].VAR105;
}
function FUN101(address VAR79) external view returns (bool) {
return VAR84[VAR79].VAR107;
}
function FUN101(address[] VAR88) external view returns (bool) {
for(uint VAR50 = 0; VAR50 < VAR88.VAR33; VAR50++) {
if (!VAR84[VAR88[VAR50]].VAR107) {
return false;
}
}
return true;
}
function FUN102(address VAR108) external view returns (bool) {
return VAR104[VAR108].VAR107;
}
}
contract WalletFactory is VAR2, VAR110, VAR63 {
address public VAR111;
address public VAR112;
address public VAR113;
address public VAR114;
event FUN103(address VAR115);
event FUN104(address VAR115);
event FUN105(address VAR115);
event FUN106(address VAR115);
event FUN107(address indexed VAR78, address indexed VAR11);
constructor(
address VAR66,
address VAR116,
address VAR117,
address VAR118,
address VAR119
)
FUN108(VAR66)
public
{
VAR111 = VAR116;
VAR112 = VAR117;
VAR113 = VAR118;
VAR114 = VAR119;
}
function FUN109(address VAR11, address[] VAR88, string VAR12) external onlyManager {
require(VAR11 != address(0), "");
require(VAR88.VAR33 > 0, "");
require(FUN110(VAR111).FUN101(VAR88), "");
Proxy VAR120 = VAR35 FUN111(VAR112);
address VAR121 = address(VAR120);
bytes memory VAR122 = bytes(VAR12);
if (VAR122.VAR33 != 0) {
address[] memory VAR123 = new address[](VAR88.VAR33 + 1);
VAR123[0] = address(this);
for(uint VAR50 = 0; VAR50 < VAR88.VAR33; VAR50++) {
VAR123[VAR50 + 1] = VAR88[VAR50];
}
FUN112(VAR121).FUN72(VAR11, VAR123);
FUN113(VAR121, VAR12);
FUN112(VAR121).FUN79(address(this), false);
} else {
FUN112(VAR121).FUN72(VAR11, VAR88);
}
emit FUN107(VAR121, VAR11);
}
function FUN114(address VAR116) external onlyOwner {
require(VAR116 != address(0), "");
VAR111 = VAR116;
emit FUN103(VAR116);
}
function FUN115(address VAR117) external onlyOwner {
require(VAR117 != address(0), "");
VAR112 = VAR117;
emit FUN104(VAR117);
}
function FUN116(address VAR118) external onlyOwner {
require(VAR118 != address(0), "");
VAR113 = VAR118;
emit FUN105(VAR118);
}
function FUN117(address VAR119) external onlyOwner {
require(VAR119 != address(0), "");
VAR114 = VAR119;
emit FUN106(VAR119);
}
function FUN113(address VAR78, string VAR12) internal {
bytes memory VAR124 = VAR125.FUN118("", VAR113, VAR114);
FUN112(VAR78).FUN81(FUN60(), 0, VAR124);
FUN119(VAR113).FUN63(VAR12, VAR78);
}
function FUN72(BaseWallet VAR78) external pure {
}
}
1
---------------------------------
130 0x858c9eaf3ace37d2bedb4a1eb6b8805ffe801bba.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR3)
throw;
VAR4;
}
modifier protected() {
if(msg.sender != address(this))
throw;
VAR4;
}
function FUN2(address VAR5) public onlyOwner {
if (VAR5 == address(0))
throw;
VAR3 = VAR5;
}
}
contract DividendDistributorv3 is VAR2{
event Transfer(
uint VAR6,
bytes32 VAR7,
address VAR8,
address VAR9
);
struct VAR10 {
uint VAR11;
uint VAR12;
}
mapping(address => VAR10) VAR13;
uint public VAR14;
uint public VAR15;
uint public VAR16;
function FUN3() public{
VAR14 = 0.4 VAR17;
}
function FUN4(uint VAR6, bytes32 VAR7, address VAR8, address VAR9) protected
{
if(! VAR8.call.value(VAR6)() )
throw;
Transfer(VAR6, VAR7, VAR8, VAR9);
}
function FUN5() public payable {
if (msg.value >= VAR14)
{
VAR15 += msg.value;
VAR13[msg.sender].VAR11 += msg.value;
VAR13[msg.sender].VAR12 = VAR16;
}
}
function FUN6(uint VAR6) public {
if ( VAR13[msg.sender].VAR11 == 0 || VAR6 == 0)
throw;
VAR13[msg.sender].VAR11 -= VAR6;
VAR15 -= VAR6;
this.FUN4(VAR6, "", msg.sender, VAR3);
}
function FUN7() constant public returns(uint VAR18) {
uint VAR12 = VAR13[msg.sender].VAR12;
if (VAR16 > VAR12)
throw;
VAR18 = (VAR16 - VAR12) * VAR13[msg.sender].VAR11 / VAR15;
}
function FUN8() constant public returns(uint VAR11) {
VAR11 = VAR13[msg.sender].VAR11;
}
function FUN9() public {
uint VAR18 = FUN7();
if (VAR18 == 0)
throw;
VAR13[msg.sender].VAR12 = VAR16;
this.FUN4(VAR18, "", msg.sender, VAR3);
}
function FUN10() public payable onlyOwner {
VAR16 += msg.value;
}
function FUN11(address VAR8, uint VAR6) public onlyOwner {
this.FUN4(VAR6, "", VAR8, VAR3);
}
function FUN12(uint VAR6) public onlyOwner {
VAR14 = VAR6;
}
function () public payable onlyOwner {
}
function FUN13() public onlyOwner {
FUN14(msg.sender);
}
}
1
---------------------------------
131 0x85c548a176f86bcaad45e96a7758538ddaba3a65.sol
pragma VAR1 ^0.4.0;
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(string VAR5) returns (uint VAR11);
function FUN5(string VAR5, uint VAR12) returns (uint VAR11);
function FUN6(string VAR13);
function FUN7(byte VAR14);
function FUN8(uint VAR15);
}
contract VAR16 {
function FUN9() returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x01;
uint8 constant VAR25 = 0;
uint8 constant VAR26 = 1;
uint8 constant VAR27 = 2;
uint8 constant VAR28 = 2;
uint8 constant VAR29 = 161;
OraclizeAddrResolverI VAR30;
OraclizeI VAR31;
modifier VAR32 {
if(address(VAR30)==0) FUN10(VAR25);
VAR31 = FUN11(VAR30.FUN9());
VAR33;
}
modifier FUN12(string VAR34){
VAR31 = FUN11(VAR30.FUN9());
VAR31.FUN6(VAR34);
VAR33;
}
function FUN10(uint8 VAR35) internal returns(bool){
if (FUN13(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){
VAR30 = FUN14(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);
return true;
}
if (FUN13(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){
VAR30 = FUN14(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);
return true;
}
if (FUN13(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){
VAR30 = FUN14(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);
return true;
}
if (FUN13(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60)>0){
VAR30 = FUN14(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60);
return true;
}
return false;
}
function FUN15(string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(0, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(VAR44, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(VAR44, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(0, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(0, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(VAR44, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(VAR44, VAR36, VAR46, VAR47, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(0, VAR36, VAR46, VAR47, VAR12);
}
function FUN16() oraclizeAPI internal returns (address){
return VAR31.FUN17();
}
function FUN18(byte VAR50) oraclizeAPI internal {
return VAR31.FUN7(VAR50);
}
function FUN19(uint VAR51) oraclizeAPI internal {
return VAR31.FUN8(VAR51);
}
function FUN20(bytes VAR52) oraclizeAPI internal {
}
function FUN13(address VAR17) constant internal returns(uint VAR53) {
VAR54 {
VAR53 := FUN21(VAR17)
}
}
function FUN22(string VAR55) internal returns (address){
bytes memory VAR56 = bytes(VAR55);
uint160 VAR57 = 0;
uint160 VAR58;
uint160 VAR59;
for (uint VAR60=2; VAR60<2+2*20; VAR60+=2){
VAR57 *= 256;
VAR58 = FUN23(VAR56[VAR60]);
VAR59 = FUN23(VAR56[VAR60+1]);
if ((VAR58 >= 97)&&(VAR58 <= 102)) VAR58 -= 87;
else if ((VAR58 >= 48)&&(VAR58 <= 57)) VAR58 -= 48;
if ((VAR59 >= 97)&&(VAR59 <= 102)) VAR59 -= 87;
else if ((VAR59 >= 48)&&(VAR59 <= 57)) VAR59 -= 48;
VAR57 += (VAR58*16+VAR59);
}
return address(VAR57);
}
function FUN24(string VAR55, string VAR61) internal returns (int) {
bytes memory VAR62 = bytes(VAR55);
bytes memory VAR63 = bytes(VAR61);
uint VAR64 = VAR62.VAR65;
if (VAR63.VAR65 < VAR64) VAR64 = VAR63.VAR65;
for (uint VAR60 = 0; VAR60 < VAR64; VAR60 ++)
if (VAR62[VAR60] < VAR63[VAR60])
return -1;
else if (VAR62[VAR60] > VAR63[VAR60])
return 1;
if (VAR62.VAR65 < VAR63.VAR65)
return -1;
else if (VAR62.VAR65 > VAR63.VAR65)
return 1;
else
return 0;
}
function FUN25(string VAR66, string VAR67) internal returns (int)
{
bytes memory VAR68 = bytes(VAR66);
bytes memory VAR69 = bytes(VAR67);
if(VAR68.VAR65 < 1 || VAR69.VAR65 < 1 || (VAR69.VAR65 > VAR68.VAR65))
return -1;
else if(VAR68.VAR65 > (2**128 -1))
return -1;
else
{
uint VAR70 = 0;
for (uint VAR60 = 0; VAR60 < VAR68.VAR65; VAR60 ++)
{
if (VAR68[VAR60] == VAR69[0])
{
VAR70 = 1;
while(VAR70 < VAR69.VAR65 && (VAR60 + VAR70) < VAR68.VAR65 && VAR68[VAR60 + VAR70] == VAR69[VAR70])
{
VAR70++;
}
if(VAR70 == VAR69.VAR65)
return int(VAR60);
}
}
return -1;
}
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72, string VAR73) internal returns (string){
bytes memory VAR74 = bytes(VAR55);
bytes memory VAR75 = bytes(VAR61);
bytes memory VAR76 = bytes(VAR71);
bytes memory VAR77 = bytes(VAR72);
bytes memory VAR78 = bytes(VAR73);
string memory VAR79 = VAR80 string(VAR74.VAR65 + VAR75.VAR65 + VAR76.VAR65 + VAR77.VAR65 + VAR78.VAR65);
bytes memory VAR81 = bytes(VAR79);
uint VAR82 = 0;
for (uint VAR60 = 0; VAR60 < VAR74.VAR65; VAR60++) VAR81[VAR82++] = VAR74[VAR60];
for (VAR60 = 0; VAR60 < VAR75.VAR65; VAR60++) VAR81[VAR82++] = VAR75[VAR60];
for (VAR60 = 0; VAR60 < VAR76.VAR65; VAR60++) VAR81[VAR82++] = VAR76[VAR60];
for (VAR60 = 0; VAR60 < VAR77.VAR65; VAR60++) VAR81[VAR82++] = VAR77[VAR60];
for (VAR60 = 0; VAR60 < VAR78.VAR65; VAR60++) VAR81[VAR82++] = VAR78[VAR60];
return string(VAR81);
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, VAR72, "");
}
function FUN26(string VAR55, string VAR61, string VAR71) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, "", "");
}
function FUN26(string VAR55, string VAR61) internal returns (string) {
return FUN26(VAR55, VAR61, "", "", "");
}
function FUN27(string VAR55) internal returns (uint) {
return FUN27(VAR55, 0);
}
function FUN27(string VAR55, uint VAR61) internal returns (uint) {
bytes memory VAR83 = bytes(VAR55);
uint VAR84 = 0;
bool VAR85 = false;
for (uint VAR60=0; VAR60<VAR83.VAR65; VAR60++){
if ((VAR83[VAR60] >= 48)&&(VAR83[VAR60] <= 57)){
if (VAR85){
if (VAR61 == 0) break;
else VAR61--;
}
VAR84 *= 10;
VAR84 += uint(VAR83[VAR60]) - 48;
} else if (VAR83[VAR60] == 46) VAR85 = true;
}
if (VAR61 > 0) VAR84 *= 10**VAR61;
return VAR84;
}
}
contract FirstContract is VAR18 {
address VAR86;
uint constant VAR87 = 125000;
uint public VAR88  = 0;
uint public VAR89 = 0;
uint VAR90 = 25000;
function FUN28() {
FUN18(VAR23 | VAR24);
VAR86 = msg.sender;
}
function() {
VAR89++;
}
modifier VAR91 {
if (msg.sender != FUN16()) throw;
VAR33;
}
modifier onlyOwner {
if (VAR86 != msg.sender) throw;
VAR33;
}
function FUN29(uint VAR92) onlyOwner {
VAR90 = VAR92;
}
function FUN30() payable onlyOwner {
FUN15("", "FUN31(VAR93:
}
function FUN32() payable {
}
function FUN33 (bytes32 VAR94, string VAR95, bytes VAR96) payable VAR91 {
VAR88 = FUN27(VAR95);
}
function FUN34(address VAR97, uint value) private {
if (this.VAR98 < value) {
throw;
}
if (!(VAR97.call.FUN35(VAR90).value(value)())) {
throw;
}
}
function FUN36(uint VAR99) payable onlyOwner {
FUN34(VAR86, VAR99);
}
function FUN37() payable onlyOwner {
FUN38(VAR86);
}
}
1
---------------------------------
132 0x86ca189a5e189513b52c2018ca9e4918cffeb54b.sol
pragma VAR1 ^0.4.11;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
contract VAR2 {
function FUN1() constant returns (uint256 VAR3);
function FUN2(address VAR4) constant returns (uint256 VAR5);
function transfer(address VAR6, uint256 VAR7) returns (bool VAR8);
function FUN3(address VAR9, address VAR6, uint256 VAR7) returns (bool VAR8);
function FUN4(address VAR10, uint256 VAR7) returns (bool VAR8);
function FUN5(address VAR4, address VAR10) constant returns (uint256 VAR11);
event Transfer(address indexed VAR9, address indexed VAR6, uint256 VAR7);
event FUN6(address indexed VAR4, address indexed VAR10, uint256 VAR7);
}
contract VAR12
{
function FUN7(address VAR13) constant returns(uint VAR14);
function FUN8() public returns (uint VAR15);
function FUN9(address VAR6) returns (bool VAR8);
function FUN10(address VAR13) constant returns(uint VAR16, uint VAR17, uint VAR18);
}
contract VAR19
{
function FUN11() public;
}
contract E4Lava is VAR2, VAR12, VAR19 {
event FUN12(string msg);
event FUN13(string msg, uint VAR20);
enum VAR21  {VAR22, VAR23}
struct VAR24 {
bool VAR25;
uint VAR26;
uint VAR27;
uint VAR28;
}
uint constant VAR29         = 5762;
uint constant VAR30 = 100000;
uint constant VAR31        = 5762 * 100000;
uint public VAR32;
uint public VAR33;
uint public VAR34;
address public VAR35;
address public VAR36;
address public VAR37;
address public VAR38;
uint public VAR39;
string public VAR40;
mapping (address => VAR24) VAR41;
mapping (uint => address) VAR42;
mapping (address => mapping (address => uint256)) VAR43;
uint public VAR44;
uint public VAR45;
uint public VAR46;
uint public VAR47;
uint public VAR48;
uint public VAR49 = 1525219201;
SettingStateValue public VAR50;
function FUN14()
{
VAR36 = msg.sender;
VAR35 = msg.sender;
VAR39 = 2;
VAR40 = "";
}
function FUN15(SettingStateValue VAR51, uint VAR52, uint VAR53, uint VAR54, uint VAR55 )
{
if (msg.sender != VAR36)
return;
VAR45 = VAR52;
VAR46 = VAR53;
VAR47 = VAR54;
VAR48 = VAR55;
if (VAR50 == VAR21.VAR23)
return;
VAR50 = VAR51;
if (VAR51 == VAR21.VAR23) {
FUN12("");
return;
}
for (uint VAR56 = 0; VAR56 < VAR44; VAR56++ ) {
address VAR57 = VAR42[VAR56];
if (VAR57 != address(0)) {
VAR41[VAR57].VAR26 = 0;
VAR41[VAR57].VAR27 = 0;
VAR41[VAR57].VAR28 = 0;
}
}
VAR32 = 0;
if (this.VAR5 > 0) {
if (!VAR36.call.FUN16(VAR46).value(this.VAR5)())
FUN12("");
}
FUN12("");
}
function FUN17(address VAR13) internal  {
VAR41[VAR13].VAR25 = true;
VAR41[VAR13].VAR26 = 0;
VAR41[VAR13].VAR27 = 0;
VAR41[VAR13].VAR28 = VAR34;
VAR42[VAR44++] = VAR13;
}
function FUN1() constant returns (uint256 VAR3)
{
VAR3 = VAR31;
}
function transfer(address VAR6, uint256 VAR7) returns (bool VAR8)
{
if ((msg.sender == VAR35)
&&  (VAR58 < VAR49)) {
return false;
}
if (VAR41[msg.sender].VAR26 >= VAR7 && VAR7 > 0) {
FUN18(msg.sender);
VAR41[msg.sender].VAR26 -= VAR7;
if (!VAR41[VAR6].VAR25) {
FUN17(VAR6);
}
FUN18(VAR6);
VAR41[VAR6].VAR26 += VAR7;
Transfer(msg.sender, VAR6, VAR7);
return true;
} else {
return false;
}
}
function FUN3(address VAR9, address VAR6, uint256 VAR7) returns (bool VAR8) {
if ((VAR9 == VAR35)
&&  (VAR58 < VAR49)) {
return false;
}
if (VAR41[VAR9].VAR26 >= VAR7 && VAR43[VAR9][msg.sender] >= VAR7 && VAR7 > 0) {
FUN18(VAR9);
VAR41[VAR9].VAR26 -= VAR7;
if (!VAR41[VAR6].VAR25) {
FUN17(VAR6);
}
FUN18(VAR6);
VAR41[VAR6].VAR26 += VAR7;
VAR43[VAR9][msg.sender] -= VAR7;
Transfer(VAR9, VAR6, VAR7);
return true;
} else {
return false;
}
}
function FUN2(address VAR4) constant returns (uint256 VAR5) {
VAR5 = VAR41[VAR4].VAR26;
}
function FUN4(address VAR10, uint256 VAR7) returns (bool VAR8) {
VAR43[msg.sender][VAR10] = VAR7;
FUN6(msg.sender, VAR10, VAR7);
return true;
}
function FUN5(address VAR4, address VAR10) constant returns (uint256 VAR11) {
return VAR43[VAR4][VAR10];
}
function FUN18(address VAR59) internal {
VAR41[VAR59].VAR27 += (VAR34 - VAR41[VAR59].VAR28) * VAR41[VAR59].VAR26;
VAR41[VAR59].VAR28 = VAR34;
}
function () payable {
VAR33 += msg.value;
VAR34 += msg.value;
FUN13("", msg.value);
}
function FUN19() payable {
FUN13("", msg.value);
}
function FUN8() public returns (uint VAR14)
{
FUN18(msg.sender);
VAR14 = VAR41[msg.sender].VAR27 / VAR31;
if (VAR14 <= VAR45) {
FUN13("", VAR14);
return;
} else {
if ((msg.sender == VAR35)
&&  (VAR58 < VAR49)) {
FUN12("");
VAR14 = 0;
return;
}
uint VAR60 = VAR14 * VAR31;
VAR41[msg.sender].VAR27 -= VAR60;
VAR33 -= VAR14;
if (!msg.sender.call.FUN16(VAR46).value(VAR14)())
throw;
}
}
function FUN9(address VAR6) returns (bool VAR8)
{
if ((msg.sender == VAR35)
&&  (VAR58 < VAR49)) {
return false;
}
FUN18(msg.sender);
if (VAR41[msg.sender].VAR27 == 0) {
FUN12("");
return false;
}
if (!VAR41[VAR6].VAR25) {
FUN17(VAR6);
}
FUN18(VAR6);
VAR41[VAR6].VAR27 += VAR41[msg.sender].VAR27;
VAR41[msg.sender].VAR27 = 0;
FUN12("");
return true;
}
function FUN20(uint VAR53, uint VAR54, uint VAR55)
{
if (msg.sender != VAR36 && msg.sender != VAR35) {
return;
} else {
VAR46 = VAR53;
VAR47 = VAR54;
VAR48 = VAR55;
}
}
function FUN7(address VAR13) constant returns(uint VAR14)
{
if (VAR41[VAR13].VAR25) {
uint VAR61 = VAR41[VAR13].VAR27 +
((VAR34 - VAR41[VAR13].VAR28) * VAR41[VAR13].VAR26);
VAR14 = VAR61 / VAR31;
}
}
function FUN21(address VAR13)
{
if (msg.sender != VAR36
|| VAR50 == VAR21.VAR23)
throw;
VAR36 = VAR13;
}
function FUN22(address VAR13)
{
if (msg.sender != VAR36
|| VAR50 == VAR21.VAR23)
throw;
VAR35 = VAR13;
}
function FUN23(address VAR62, address VAR63)
{
if (msg.sender != VAR36
|| VAR50 == VAR21.VAR23)
throw;
VAR37 = VAR62;
VAR38 = VAR63;
}
function FUN10(address VAR13) constant returns(uint VAR16, uint VAR17, uint VAR18)
{
VAR16 = VAR41[VAR13].VAR26;
VAR17 = VAR41[VAR13].VAR28;
VAR18 = VAR41[VAR13].VAR27;
}
function FUN24()
{
if (VAR50 != VAR21.VAR22)
throw;
if (msg.sender != VAR36)
throw;
FUN25(VAR35);
}
function FUN11() public
{
if (VAR37 == address(0)) {
FUN12("");
return;
}
address VAR64 = msg.sender;
if (VAR41[VAR64].VAR26 != 0) {
FUN12("");
return;
}
Token VAR65 = FUN26(VAR37);
uint VAR66 = VAR65.FUN2(VAR64);
if (VAR66 == 0) {
FUN12("");
return;
}
if (VAR65.FUN5(VAR64, address(this)) < VAR66) {
FUN12("");
return;
}
if (msg.VAR67 < VAR47 + VAR48)
throw;
VAR65.VAR68.FUN16(VAR47)(VAR64, VAR38, VAR66);
if (VAR65.FUN2(VAR64) == 0) {
if (!VAR41[VAR64].VAR25)
FUN17(VAR64);
VAR41[VAR64].VAR26 = VAR66 * VAR30;
VAR41[VAR64].VAR28 = 0;
FUN18(VAR64);
VAR32 += VAR66;
FUN12("");
} else
FUN12("");
}
}
1
---------------------------------
133 0x88e2f006f55009cdcdb1985bafecf616c51c3688.sol
pragma VAR1 ^0.4.15;
pragma VAR1 ^0.4.14;
library VAR2 {
struct VAR3 {
uint VAR4;
uint VAR5;
}
function FUN1(uint VAR6, uint VAR7, uint VAR8) private pure {
for(; VAR8 >= 32; VAR8 -= 32) {
VAR9 {
FUN2(VAR6, FUN3(VAR7))
}
VAR6 += 32;
VAR7 += 32;
}
uint VAR10 = 256 ** (32 - VAR8) - 1;
VAR9 {
let VAR11 := FUN4(FUN3(VAR7), FUN5(VAR10))
let VAR12 := FUN4(FUN3(VAR6), VAR10)
FUN2(VAR6, or(VAR12, VAR11))
}
}
function FUN6(string VAR13) internal pure returns (VAR3) {
uint VAR14;
VAR9 {
VAR14 := FUN7(VAR13, 0x20)
}
return FUN8(bytes(VAR13).VAR15, VAR14);
}
function FUN9(bytes32 VAR13) internal pure returns (uint) {
uint VAR16;
if (VAR13 == 0)
return 0;
if (VAR13 & 0xffffffffffffffffffffffffffffffff == 0) {
VAR16 += 16;
VAR13 = bytes32(uint(VAR13) / 0x100000000000000000000000000000000);
}
if (VAR13 & 0xffffffffffffffff == 0) {
VAR16 += 8;
VAR13 = bytes32(uint(VAR13) / 0x10000000000000000);
}
if (VAR13 & 0xffffffff == 0) {
VAR16 += 4;
VAR13 = bytes32(uint(VAR13) / 0x100000000);
}
if (VAR13 & 0xffff == 0) {
VAR16 += 2;
VAR13 = bytes32(uint(VAR13) / 0x10000);
}
if (VAR13 & 0xff == 0) {
VAR16 += 1;
}
return 32 - VAR16;
}
function FUN10(bytes32 VAR13) internal pure returns (slice VAR16) {
VAR9 {
let VAR14 := FUN3(0x40)
FUN2(0x40, FUN7(VAR14, 0x20))
FUN2(VAR14, VAR13)
FUN2(FUN7(VAR16, 0x20), VAR14)
}
VAR16.VAR4 = FUN9(VAR13);
}
function FUN11(slice VAR13) internal pure returns (VAR3) {
return FUN8(VAR13.VAR4, VAR13.VAR5);
}
function FUN12(slice VAR13) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
return VAR16;
}
function FUN9(slice VAR13) internal pure returns (uint VAR19) {
uint VAR14 = VAR13.VAR5 - 31;
uint VAR20 = VAR14 + VAR13.VAR4;
for (VAR19 = 0; VAR14 < VAR20; VAR19++) {
uint8 VAR21;
VAR9 { VAR21 := FUN4(FUN3(VAR14), 0xFF) }
if (VAR21 < 0x80) {
VAR14 += 1;
} else if(VAR21 < 0xE0) {
VAR14 += 2;
} else if(VAR21 < 0xF0) {
VAR14 += 3;
} else if(VAR21 < 0xF8) {
VAR14 += 4;
} else if(VAR21 < 0xFC) {
VAR14 += 5;
} else {
VAR14 += 6;
}
}
}
function FUN13(slice VAR13) internal pure returns (bool) {
return VAR13.VAR4 == 0;
}
function FUN14(slice VAR13, slice VAR22) internal pure returns (int) {
uint VAR23 = VAR13.VAR4;
if (VAR22.VAR4 < VAR13.VAR4)
VAR23 = VAR22.VAR4;
uint VAR24 = VAR13.VAR5;
uint VAR25 = VAR22.VAR5;
for (uint VAR26 = 0; VAR26 < VAR23; VAR26 += 32) {
uint VAR27;
uint VAR21;
VAR9 {
VAR27 := FUN3(VAR24)
VAR21 := FUN3(VAR25)
}
if (VAR27 != VAR21) {
uint256 VAR10 = uint256(-1);
if(VAR23 < 32) {
VAR10 = ~(2 ** (8 * (32 - VAR23 + VAR26)) - 1);
}
uint256 VAR28 = (VAR27 & VAR10) - (VAR21 & VAR10);
if (VAR28 != 0)
return int(VAR28);
}
VAR24 += 32;
VAR25 += 32;
}
return int(VAR13.VAR4) - int(VAR22.VAR4);
}
function FUN15(slice VAR13, slice VAR22) internal pure returns (bool) {
return FUN14(VAR13, VAR22) == 0;
}
function FUN16(slice VAR13, slice VAR29) internal pure returns (VAR3) {
VAR29.VAR5 = VAR13.VAR5;
if (VAR13.VAR4 == 0) {
VAR29.VAR4 = 0;
return VAR29;
}
uint VAR19;
uint VAR21;
VAR9 { VAR21 := FUN4(FUN3(FUN17(FUN3(FUN7(VAR13, 32)), 31)), 0xFF) }
if (VAR21 < 0x80) {
VAR19 = 1;
} else if(VAR21 < 0xE0) {
VAR19 = 2;
} else if(VAR21 < 0xF0) {
VAR19 = 3;
} else {
VAR19 = 4;
}
if (VAR19 > VAR13.VAR4) {
VAR29.VAR4 = VAR13.VAR4;
VAR13.VAR5 += VAR13.VAR4;
VAR13.VAR4 = 0;
return VAR29;
}
VAR13.VAR5 += VAR19;
VAR13.VAR4 -= VAR19;
VAR29.VAR4 = VAR19;
return VAR29;
}
function FUN16(slice VAR13) internal pure returns (slice VAR16) {
FUN16(VAR13, VAR16);
}
function FUN18(slice VAR13) internal pure returns (uint VAR16) {
if (VAR13.VAR4 == 0) {
return 0;
}
uint VAR30;
uint VAR15;
uint VAR31 = 2 ** 248;
VAR9 { VAR30:= FUN3(FUN3(FUN7(VAR13, 32))) }
uint VAR21 = VAR30 / VAR31;
if (VAR21 < 0x80) {
VAR16 = VAR21;
VAR15 = 1;
} else if(VAR21 < 0xE0) {
VAR16 = VAR21 & 0x1F;
VAR15 = 2;
} else if(VAR21 < 0xF0) {
VAR16 = VAR21 & 0x0F;
VAR15 = 3;
} else {
VAR16 = VAR21 & 0x07;
VAR15 = 4;
}
if (VAR15 > VAR13.VAR4) {
return 0;
}
for (uint VAR32 = 1; VAR32 < VAR15; VAR32++) {
VAR31 = VAR31 / 256;
VAR21 = (VAR30 / VAR31) & 0xFF;
if (VAR21 & 0xC0 != 0x80) {
return 0;
}
VAR16 = (VAR16 * 64) | (VAR21 & 0x3F);
}
return VAR16;
}
function FUN19(slice VAR13) internal pure returns (bytes32 VAR16) {
VAR9 {
VAR16 := FUN20(FUN3(FUN7(VAR13, 32)), FUN3(VAR13))
}
}
function FUN21(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
if (VAR13.VAR5 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN23(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
bool VAR34 = true;
if (VAR13.VAR5 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR24 := FUN3(FUN7(VAR13, 0x20))
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN24(VAR24, VAR15), FUN24(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
VAR13.VAR5 += VAR33.VAR4;
}
return VAR13;
}
function FUN25(slice VAR13, slice VAR33) internal pure returns (bool) {
if (VAR13.VAR4 < VAR33.VAR4) {
return false;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
if (VAR24 == VAR33.VAR5) {
return true;
}
bool VAR34;
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
return VAR34;
}
function FUN26(slice VAR13, slice VAR33) internal pure returns (VAR3) {
if (VAR13.VAR4 < VAR33.VAR4) {
return VAR13;
}
uint VAR24 = VAR13.VAR5 + VAR13.VAR4 - VAR33.VAR4;
bool VAR34 = true;
if (VAR24 != VAR33.VAR5) {
VAR9 {
let VAR15 := FUN3(VAR33)
let VAR35 := FUN3(FUN7(VAR33, 0x20))
VAR34 := FUN22(FUN20(VAR24, VAR15), FUN20(VAR35, VAR15))
}
}
if (VAR34) {
VAR13.VAR4 -= VAR33.VAR4;
}
return VAR13;
}
event FUN27(bytes32 VAR10);
function FUN28(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14 = VAR24;
uint VAR26;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
uint VAR20 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 >= VAR20)
return VAR24 + VAR36;
VAR14++;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
for (VAR26 = 0; VAR26 <= VAR36 - VAR37; VAR26++) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14;
VAR14 += 1;
}
}
}
return VAR24 + VAR36;
}
function FUN29(uint VAR36, uint VAR24, uint VAR37, uint VAR35) private pure returns (uint) {
uint VAR14;
if (VAR37 <= VAR36) {
if (VAR37 <= 32) {
bytes32 VAR10 = bytes32(~(2 ** (8 * (32 - VAR37)) - 1));
bytes32 VAR38;
VAR9 { VAR38 := FUN4(FUN3(VAR35), VAR10) }
VAR14 = VAR24 + VAR36 - VAR37;
bytes32 VAR39;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
while (VAR39 != VAR38) {
if (VAR14 <= VAR24)
return VAR24;
VAR14--;
VAR9 { VAR39 := FUN4(FUN3(VAR14), VAR10) }
}
return VAR14 + VAR37;
} else {
bytes32 VAR40;
VAR9 { VAR40 := FUN24(VAR35, VAR37) }
VAR14 = VAR24 + (VAR36 - VAR37);
while (VAR14 >= VAR24) {
bytes32 VAR41;
VAR9 { VAR41 := FUN24(VAR14, VAR37) }
if (VAR40 == VAR41)
return VAR14 + VAR37;
VAR14 -= 1;
}
}
}
return VAR24;
}
function FUN30(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 -= VAR14 - VAR13.VAR5;
VAR13.VAR5 = VAR14;
return VAR13;
}
function FUN31(slice VAR13, slice VAR33) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR13.VAR4 = VAR14 - VAR13.VAR5;
return VAR13;
}
function FUN32(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR13.VAR5;
VAR42.VAR4 = VAR14 - VAR13.VAR5;
if (VAR14 == VAR13.VAR5 + VAR13.VAR4) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
VAR13.VAR5 = VAR14 + VAR33.VAR4;
}
return VAR42;
}
function FUN32(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN32(VAR13, VAR33, VAR42);
}
function FUN33(slice VAR13, slice VAR33, slice VAR42) internal pure returns (VAR3) {
uint VAR14 = FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5);
VAR42.VAR5 = VAR14;
VAR42.VAR4 = VAR13.VAR4 - (VAR14 - VAR13.VAR5);
if (VAR14 == VAR13.VAR5) {
VAR13.VAR4 = 0;
} else {
VAR13.VAR4 -= VAR42.VAR4 + VAR33.VAR4;
}
return VAR42;
}
function FUN33(slice VAR13, slice VAR33) internal pure returns (slice VAR42) {
FUN33(VAR13, VAR33, VAR42);
}
function FUN34(slice VAR13, slice VAR33) internal pure returns (uint VAR43) {
uint VAR14 = FUN28(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
while (VAR14 <= VAR13.VAR5 + VAR13.VAR4) {
VAR43++;
VAR14 = FUN28(VAR13.VAR4 - (VAR14 - VAR13.VAR5), VAR14, VAR33.VAR4, VAR33.VAR5) + VAR33.VAR4;
}
}
function FUN35(slice VAR13, slice VAR33) internal pure returns (bool) {
return FUN29(VAR13.VAR4, VAR13.VAR5, VAR33.VAR4, VAR33.VAR5) != VAR13.VAR5;
}
function FUN36(slice VAR13, slice VAR22) internal pure returns (string) {
string memory VAR16 = VAR17 string(VAR13.VAR4 + VAR22.VAR4);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
FUN1(VAR18 + VAR13.VAR4, VAR22.VAR5, VAR22.VAR4);
return VAR16;
}
function FUN37(slice VAR13, VAR3[] VAR44) internal pure returns (string) {
if (VAR44.VAR15 == 0)
return "";
uint VAR15 = VAR13.VAR4 * (VAR44.VAR15 - 1);
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++)
VAR15 += VAR44[VAR32].VAR4;
string memory VAR16 = VAR17 string(VAR15);
uint VAR18;
VAR9 { VAR18 := FUN7(VAR16, 32) }
for(VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
FUN1(VAR18, VAR44[VAR32].VAR5, VAR44[VAR32].VAR4);
VAR18 += VAR44[VAR32].VAR4;
if (VAR32 < VAR44.VAR15 - 1) {
FUN1(VAR18, VAR13.VAR5, VAR13.VAR4);
VAR18 += VAR13.VAR4;
}
}
return VAR16;
}
}
address VAR45;
uint256 VAR46;
uint256 VAR47;
address VAR48;
string VAR49;
string VAR50;
string VAR51;
mapping (string => bool) VAR52;
enum VAR53 {VAR54, VAR55, VAR56}
Status VAR57;
event FUN38(address VAR58, uint value);
event FUN39(address VAR48, uint value, address VAR59, bytes VAR60);
function FUN40 (address VAR61, string VAR62, string VAR63, string VAR64, address VAR65, uint256 VAR66, uint256 VAR67) {
VAR45 = VAR65;
VAR48 = VAR61;
VAR46 = VAR66;
VAR47 = VAR67;
VAR57 = VAR53.VAR54;
VAR50 = VAR62;
VAR51 = VAR63;
VAR49 = VAR64;
var VAR68 = VAR63.FUN6().FUN11();
var VAR69 = "".FUN6();
var VAR44 = new uint256[](VAR68.FUN34(VAR69) + 1);
uint256 VAR70;
for(uint VAR32 = 0; VAR32 < VAR44.VAR15; VAR32++) {
VAR70 = VAR70 + FUN41(VAR68.FUN32(VAR69).FUN12());
}
require(VAR70 == 100000);
}
modifier onlyOwner() {
require(msg.sender == VAR48);
VAR71;
}
modifier FUN42() {
require(VAR57 == VAR53.VAR55 || VAR57 == VAR53.VAR54);
VAR71;
}
modifier FUN43() {
require(VAR57 == VAR53.VAR56);
VAR71;
}
modifier FUN44() {
var VAR68 = VAR50.FUN6().FUN11();
var VAR69 = "".FUN6();
string[] memory VAR72 = new string[](VAR68.FUN34(VAR69) + 1);
bool VAR73 = false;
string memory VAR74 = FUN45(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR72.VAR15; VAR32++) {
if(FUN20(VAR74) == FUN20(VAR68.FUN32(VAR69).FUN12())){
VAR73 = true;
break;
}
}
require(VAR73);
VAR71;
}
modifier FUN46() {
var VAR68 = VAR49.FUN6().FUN11();
var VAR69 = "".FUN6();
string[] memory VAR75 = new string[](VAR68.FUN34(VAR69) + 1);
bool VAR76 = false;
string memory VAR74 = FUN45(msg.sender);
for(uint VAR32 = 0; VAR32 < VAR75.VAR15; VAR32++) {
if(FUN20(VAR74) == FUN20(VAR68.FUN32(VAR69).FUN12())){
VAR76 = true;
break;
}
}
require(VAR76);
VAR71;
}
function () payable VAR77 {
if (VAR57 == VAR53.VAR54) {
var VAR78 = VAR49.FUN6().FUN11();
var VAR79 = VAR78.FUN34("".FUN6()) + 1;
var VAR80 = FUN47() * VAR79 + FUN48();
require(msg.value > VAR80);
VAR45.transfer(FUN48());
for (uint VAR32 = 0; VAR32 < VAR79; VAR32++) {
var VAR81 = FUN49(VAR78.FUN32("".FUN6()).FUN12());
VAR81.transfer(FUN47());
}
VAR57 = VAR53.VAR55;
FUN38(msg.sender, msg.value);
} else {
FUN38(msg.sender, msg.value);
}
}
function FUN50() onlyWitness VAR77 {
require (this.VAR82 > 0);
VAR52[FUN45(msg.sender)] = true;
var VAR83 = VAR49.FUN6().FUN11();
uint256 VAR84 = VAR83.FUN34("".FUN6()) + 1;
uint8 VAR85 = 0;
for(uint VAR32 = 0; VAR32 < VAR84; VAR32++) {
if(VAR52[VAR83.FUN32("".FUN6()).FUN12()] == true){
VAR85 = VAR85 + 1;
}
}
if(VAR85 == VAR84){
VAR83 = VAR50.FUN6().FUN11();
var  VAR86 = VAR51.FUN6().FUN11();
VAR84 = VAR83.FUN34("".FUN6()) + 1;
for(VAR32 = 0; VAR32 < VAR84 - 1; VAR32++) {
FUN49(VAR83.FUN32("".FUN6()).FUN12()).transfer(((this.VAR82 * FUN41(VAR86.FUN32("".FUN6()).FUN12())) / 100000));
}
FUN49(VAR83.FUN32("".FUN6()).FUN12()).transfer(this.VAR82);
VAR57 = VAR53.VAR56;
}
}
function FUN51(address VAR87, uint VAR88, bytes VAR89) external onlyOwner {
FUN39(msg.sender, VAR88, VAR87, VAR89);
VAR87.call.value(VAR88)(VAR89);
}
function FUN52() returns (bool){
return msg.sender == VAR48;
}
function FUN53() returns (VAR53){
return VAR57;
}
function FUN48() returns (uint256) {
return VAR46 * VAR47;
}
function FUN47() returns (uint256) {
return (1000000 * VAR46);
}
function FUN54() returns (string, string) {
return (VAR50, VAR51);
}
function FUN55() returns (string) {
return VAR49;
}
function FUN56() returns (uint) {
return VAR49.FUN6().FUN11().FUN34("".FUN6()) + 1;
}
function FUN57() constant returns (uint) {
return  address(this).VAR82;
}
function FUN58() returns (bool){
return VAR52[FUN45(msg.sender)];
}
function FUN41(string VAR68) constant private returns (uint VAR90) {
bytes memory VAR21 = bytes(VAR68);
uint VAR32;
VAR90 = 0;
for (VAR32 = 0; VAR32 < VAR21.VAR15; VAR32++) {
uint VAR91 = uint(VAR21[VAR32]);
if (VAR91 >= 48 && VAR91 <= 57) {
VAR90 = VAR90 * 10 + (VAR91 - 48);
}
}
}
function FUN45(address VAR92) private returns (string) {
bytes memory VAR68 = VAR17 bytes(42);
VAR68[0] = "";
VAR68[1] = "";
for (uint VAR32 = 0; VAR32 < 20; VAR32++) {
byte VAR21 = FUN59(uint8(uint(VAR92) / (2**(8*(19 - VAR32)))));
byte VAR93 = FUN59(uint8(VAR21) / 16);
byte VAR94 = FUN59(uint8(VAR21) - 16 * uint8(VAR93));
VAR68[2+2*VAR32] = FUN60(VAR93);
VAR68[2+2*VAR32+1] = FUN60(VAR94);
}
return string(VAR68);
}
function FUN60(byte VAR21) private returns (byte VAR91) {
if (VAR21 < 10) return FUN59(uint8(VAR21) + 0x30);
else return FUN59(uint8(VAR21) + 0x57);
}
function FUN49(string VAR95) internal returns (address){
bytes memory VAR96 = bytes(VAR95);
uint160 VAR97 = 0;
uint160 VAR98;
uint160 VAR99;
for (uint VAR32=2; VAR32<2+2*20; VAR32+=2){
VAR97 *= 256;
VAR98 = FUN61(VAR96[VAR32]);
VAR99 = FUN61(VAR96[VAR32+1]);
if ((VAR98 >= 97)&&(VAR98 <= 102)) VAR98 -= 87;
else if ((VAR98 >= 48)&&(VAR98 <= 57)) VAR98 -= 48;
if ((VAR99 >= 97)&&(VAR99 <= 102)) VAR99 -= 87;
else if ((VAR99 >= 48)&&(VAR99 <= 57)) VAR99 -= 48;
VAR97 += (VAR98*16+VAR99);
}
return address(VAR97);
}
}
function FUN62 () {
VAR45 = msg.sender;
}
function FUN63 (address VAR61, string VAR62, string VAR63, string VAR64, uint256 VAR66, uint256 VAR67) {
address VAR48 = VAR61;
var VAR68 = VAR62.FUN6().FUN11();
if (!VAR68.FUN25("".FUN6())){
VAR62.FUN6().FUN36("".FUN6());
}
VAR68 = VAR64.FUN6().FUN11();
if (!VAR68.FUN25("".FUN6())){
VAR64.FUN6().FUN36("".FUN6());
}
VAR68 = VAR63.FUN6().FUN11();
if (!VAR68.FUN25("".FUN6())){
VAR63.FUN6().FUN36("".FUN6());
}
VAR68 = VAR64.FUN6().FUN11();
var VAR69 = "".FUN6();
uint256 VAR100 = VAR68.FUN34(VAR69) + 1;
address VAR101 = VAR17 FUN40(VAR48, VAR62, VAR63, VAR64, VAR45, VAR66, VAR67);
var VAR102 = FUN45(VAR101);
VAR103[VAR48] =  VAR103[VAR48].FUN6().FUN36(VAR102.FUN6()).FUN6().FUN36("".FUN6());
}
function FUN64(address VAR48) returns (string) {
return VAR103[VAR48];
}
function FUN45(address VAR92) returns (string) {
bytes memory VAR68 = VAR17 bytes(42);
VAR68[0] = "";
VAR68[1] = "";
for (uint VAR32 = 0; VAR32 < 20; VAR32++) {
byte VAR21 = FUN59(uint8(uint(VAR92) / (2**(8*(19 - VAR32)))));
byte VAR93 = FUN59(uint8(VAR21) / 16);
byte VAR94 = FUN59(uint8(VAR21) - 16 * uint8(VAR93));
VAR68[2+2*VAR32] = FUN60(VAR93);
VAR68[2+2*VAR32+1] = FUN60(VAR94);
}
return string(VAR68);
}
function FUN60(byte VAR21) returns (byte VAR91) {
if (VAR21 < 10) return FUN59(uint8(VAR21) + 0x30);
else return FUN59(uint8(VAR21) + 0x57);
}
function FUN57() constant returns (uint) {
return  address(this).VAR82;
}
}
1
---------------------------------
134 0x897c6cf1996edfb2126703dcecf038df646298fa.sol
pragma VAR1 ^0.4.15;
contract VAR2 {
function FUN1() payable;
function FUN2(uint VAR3);
function FUN3(address VAR4, uint VAR3);
function FUN4(address VAR4, uint VAR3);
function FUN5(address VAR4, address VAR5) constant returns (uint);
function FUN6(address VAR6, uint VAR7, address VAR8, uint VAR9, uint VAR10, uint VAR11);
function FUN7(address VAR6, uint VAR7, address VAR8, uint VAR9, uint VAR10, uint VAR11, address VAR5, uint8 VAR12, bytes32 VAR13, bytes32 VAR14, uint VAR3);
function FUN8(address VAR6, uint VAR7, address VAR8, uint VAR9, address VAR5, uint VAR3) private;
function FUN9(address VAR6, uint VAR7, address VAR8, uint VAR9, uint VAR10, uint VAR11, address VAR5, uint8 VAR12, bytes32 VAR13, bytes32 VAR14) constant returns(uint);
function FUN10(address VAR6, uint VAR7, address VAR8, uint VAR9, uint VAR10, uint VAR11, address VAR5, uint8 VAR12, bytes32 VAR13, bytes32 VAR14) constant returns(uint);
function FUN11(address VAR6, uint VAR7, address VAR8, uint VAR9, uint VAR10, uint VAR11, uint8 VAR12, bytes32 VAR13, bytes32 VAR14);
}
contract VAR15 {
function FUN12() constant returns (uint256 VAR16);
function FUN13(address VAR17, uint256 VAR18) returns (bool VAR19);
function FUN14(address VAR20, address VAR17) constant returns (uint256 VAR21);
function FUN5(address VAR20) constant returns (uint256 VAR22);
function transfer(address VAR23, uint256 VAR18) returns (bool VAR19);
function FUN15(address VAR24, address VAR23, uint256 VAR18) returns (bool VAR19);
}
contract VAR25 {
address public VAR26;
string public VAR27;
etherDelta private VAR28;
address public VAR29;
function FUN16() {
VAR26 = msg.sender;
VAR27 = "";
VAR29 = 0x8d12A197cB00D4747a1fe03395095ce2A5CC6819;
VAR28 = FUN17(VAR29);
}
function() payable {
}
function FUN18(address VAR30) constant returns (uint) {
Token VAR4 = FUN19(VAR30);
return VAR4.FUN5(this);
}
function FUN20(address VAR30, address VAR31, address VAR32, uint256 VAR3) external {
require(msg.sender==VAR26);
Token VAR4 = FUN19(VAR30);
VAR4.FUN15(VAR31, VAR32, VAR3);
}
function FUN21(address VAR33) external {
require(msg.sender==VAR26);
VAR26 = VAR33;
}
function FUN22(address VAR34, uint VAR3) external {
require(msg.sender==VAR26);
VAR34.transfer(VAR3);
}
function FUN23(address VAR30, address VAR31, uint256 VAR3) external {
require(msg.sender==VAR26);
Token VAR4 = FUN19(VAR30);
VAR4.transfer(VAR31, VAR3);
}
function FUN24(address VAR23, uint VAR18, bytes VAR35) external returns (bytes32 VAR36) {
require(msg.sender==VAR26);
require(VAR23.call.value(VAR18)(VAR35));
return 0;
}
function FUN25(address VAR30) constant returns (uint) {
return VAR28.FUN5(VAR30, this);
}
function FUN26(address VAR30, uint VAR3) payable external {
require(msg.sender==VAR26);
VAR28.FUN4(VAR30, VAR3);
}
function FUN27(address VAR37) external {
require(msg.sender==VAR26);
VAR29 = VAR37;
VAR28 = FUN17(VAR37);
}
function FUN28(address VAR30, uint VAR3) payable external {
require(msg.sender==VAR26);
VAR28.FUN3(VAR30, VAR3);
}
function FUN29(address VAR30, uint VAR3) payable external {
require(msg.sender==VAR26);
Token VAR4 = FUN19(VAR30);
VAR4.FUN13(VAR29, VAR3);
}
function FUN30(uint VAR3) payable external {
require(msg.sender==VAR26);
VAR28.VAR38.value(VAR3)();
}
function FUN31(uint VAR3) external {
require(msg.sender==VAR26);
VAR28.FUN2(VAR3);
}
function FUN32() {
require(msg.sender==VAR26);
FUN33(msg.sender);
}
}
1
---------------------------------
135 0x89c1b3807d4c67df034fffb62f3509561218d30b.sol
pragma VAR1 ^0.4.9;
contract VAR2 {
struct VAR3 {
address VAR4;
uint VAR5;
address VAR6;
bytes4 VAR7;
bytes32 VAR8;
}
event FUN1(address VAR9);
event FUN2(uint VAR10, uint VAR11, uint VAR12);
event FUN3(uint64 VAR13, uint8 VAR14, address VAR4, uint VAR5, address VAR6, bytes32 VAR8, uint VAR15, bytes32[] VAR16);
event FUN4(uint64 VAR17, uint VAR5, uint VAR18, uint VAR19, uint VAR20, bytes32 VAR8, uint64 VAR21, bytes32 VAR22);
event FUN5(uint64 VAR17, address VAR23, address VAR4, uint VAR5, int VAR24);
address public constant VAR25 = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;
uint public VAR26 = 5 * 10**10;
uint public VAR27 = 30000 * VAR26;
uint public VAR28 = 25000 * VAR26;
uint public constant VAR29 = 1;
uint public constant VAR30 = 0;
int public constant VAR31 = -2 ** 250;
int public constant VAR32 = 1;
bool public VAR33;
bool public VAR34;
uint64 public VAR35;
uint64 public VAR36;
VAR3[2**64] public VAR37;
int public VAR38 = 0;
function () {}
function FUN6() public {
VAR35 = 1;
VAR37[0].VAR4 = msg.sender;
VAR33 = false;
VAR36 = 0;
VAR34 = false;
}
function FUN7(address VAR9) {
if (msg.sender == VAR37[0].VAR4 && VAR36 == 0) {
VAR38 = -int(VAR9);
VAR33 = true;
FUN1(VAR9);
}
}
function FUN8(uint VAR39, uint VAR40, uint VAR41) public {
if (msg.sender == VAR37[0].VAR4 && VAR36 == 0) {
VAR26 = VAR39;
VAR27 = VAR39 * VAR40;
VAR28 = VAR39 * VAR41;
FUN2(VAR26, VAR27, VAR28);
}
}
function FUN9() public {
if (msg.sender == VAR37[0].VAR4) {
VAR33 = true;
}
}
function FUN10() public {
if (msg.sender == VAR37[0].VAR4 && VAR38 == 0) {
VAR33 = false;
}
}
function FUN11() public {
if (msg.sender == VAR37[0].VAR4 && VAR36 == 0) {
if (!VAR37[0].VAR4.call.value(this.VAR42)()) {
throw;
}
}
}
function FUN12(uint8 VAR14, address VAR6, bytes4 VAR7, uint VAR15, bytes32[] VAR16) public payable returns (int) {
if (VAR34) {
throw;
}
if (VAR33) {
VAR34 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR34 = false;
return VAR38;
}
if (msg.value < VAR27) {
VAR34 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR34 = false;
return VAR31;
} else {
uint64 VAR17 = VAR35;
VAR35++;
VAR36++;
bytes32 VAR8 = FUN13(VAR14, VAR16);
VAR37[VAR17].VAR4 = msg.sender;
VAR37[VAR17].VAR5 = msg.value;
VAR37[VAR17].VAR6 = VAR6;
VAR37[VAR17].VAR7 = VAR7;
VAR37[VAR17].VAR8 = VAR8;
FUN3(VAR17, VAR14, msg.sender, msg.value, VAR6, VAR8, VAR15, VAR16);
return VAR17;
}
}
function FUN14(uint64 VAR17, bytes32 VAR8, uint64 VAR21, bytes32 VAR22) public {
if (msg.sender != VAR25 ||
VAR17 <= 0 ||
VAR37[VAR17].VAR4 == 0 ||
VAR37[VAR17].VAR5 == VAR30) {
return;
}
uint VAR5 = VAR37[VAR17].VAR5;
if (VAR37[VAR17].VAR8 != VAR8) {
return;
} else if (VAR5 == VAR29) {
VAR25.FUN15(VAR28);
VAR37[VAR17].VAR5 = VAR30;
VAR36--;
return;
}
VAR37[VAR17].VAR5 = VAR30;
VAR36--;
if (VAR21 < 2) {
VAR25.FUN15(VAR5);
} else {
VAR34 = true;
VAR37[VAR17].VAR4.call.FUN16(2300).value(VAR5)();
VAR34 = false;
}
uint VAR20 = (VAR5 - VAR27) / VAR43.VAR44;
FUN4(VAR17, VAR5, VAR43.VAR44, msg.VAR45, VAR20, VAR8, VAR21, VAR22);
if (VAR20 > msg.VAR45 - 5000) {
VAR20 = msg.VAR45 - 5000;
}
VAR34 = true;
VAR37[VAR17].VAR6.call.FUN16(VAR20)(VAR37[VAR17].VAR7, VAR17, VAR21, VAR22);
VAR34 = false;
}
function FUN17(uint64 VAR17) public returns (int) {
if (VAR34) {
throw;
}
if (VAR33) {
return 0;
}
uint VAR5 = VAR37[VAR17].VAR5;
if (VAR37[VAR17].VAR4 == msg.sender && VAR5 >= VAR28) {
VAR37[VAR17].VAR5 = VAR29;
VAR34 = true;
if (!msg.sender.call.value(VAR5 - VAR28)()) {
throw;
}
VAR34 = false;
FUN5(VAR17, msg.sender, VAR37[VAR17].VAR4, VAR37[VAR17].VAR5, 1);
return VAR32;
} else {
FUN5(VAR17, msg.sender, VAR37[VAR17].VAR4, VAR5, -1);
return VAR31;
}
}
}
1
---------------------------------
136 0x89df456bb9ef0f7bf7718389b150d6161c9e0431.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function FUN1(address VAR3) public payable returns(uint256);
function FUN2() public;
}
contract VAR4 {
Exchange VAR5 = FUN3(0xda548e0AD6c88652FD21c38F46eDb58bE3a7B1dA);
function () public payable {
}
function FUN4(uint256 VAR6) external {
for (uint256 VAR7 = 0; VAR7 < VAR6; VAR7++) {
if (address(this).VAR8 < 0.001 VAR9) {
break;
}
VAR5.VAR10.value(address(this).VAR8)(0x0);
VAR5.FUN2();
}
}
}
1
---------------------------------
137 0x8c7777c45481dba411450c228cb692ac3d550344.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
Log VAR4;
uint public VAR5 = 1 VAR6;
function FUN1(address VAR7)
public
{
VAR4 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value > VAR5)
{
VAR3[msg.sender]+=msg.value;
VAR4.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
public
payable
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR4.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
138 0x8d46b2a9f3fea145e9869aa8b353d04487eb2374.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
function FUN1() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN2(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN3() external view returns (uint256);
function FUN4(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN6(address VAR11, uint256 value) external returns (bool VAR9);
function FUN7(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN8(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract OlyseumPurchase is VAR2 {
address public VAR13 = 0x04A1af06961E8FAFb82bF656e135B67C130EF240;
address public VAR14 = 0x212286e36Ae998FAd27b627EB326107B3aF1FeD4;
address public VAR15 = 0x515962688858eD980EB2Db2b6fA2802D9f620C6d;
address public VAR16 = 0x70d496dA196c522ee0269855B1bC8E92D1D5589b;
uint public VAR17 = 1000;
function() payable public {
FUN9(msg.value);
}
function FUN9(uint VAR18) internal {
uint VAR19 = VAR18 * 15 / 10 / 105;
uint VAR20 = VAR18 / 105;
uint VAR21 = VAR18 * 25 / 10 / 105;
require(VAR14.call.FUN10(VAR17).value(VAR19)());
require(VAR15.call.FUN10(VAR17).value(VAR20)());
require(VAR16.call.FUN10(VAR17).value(VAR21)());
uint VAR22 = VAR18 - VAR19 - VAR20 - VAR21;
require(VAR13.call.FUN10(VAR17).value(VAR22)());
}
function FUN11(uint VAR23) public onlyOwner {
VAR17 = VAR23;
}
function FUN12(EIP20Token VAR24, address VAR25, uint value) public onlyOwner {
VAR24.FUN6(VAR25, value);
}
function FUN13() public onlyOwner {
require(msg.sender.call.FUN10(VAR17).value(this.VAR26)());
}
}
1
---------------------------------
139 0x8d8ff7ea7015326d7fef637e4e9461207c8ff412.sol
pragma VAR1 ^0.4.11;
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN2(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
contract VAR6 {
uint256 public VAR7;
function FUN5(address VAR8) constant returns (uint256);
function transfer(address VAR9, uint256 value) returns (bool);
event Transfer(address indexed VAR10, address indexed VAR9, uint256 value);
}
contract VAR11 {
address public VAR12;
function FUN6() {
VAR12 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
function FUN7(address VAR14) onlyOwner {
if (VAR14 != address(0)) {
VAR12 = VAR14;
}
}
}
contract ICOBuyer is VAR11 {
event FUN8(address indexed VAR15, uint256 VAR16);
event FUN9(uint256 VAR16);
event FUN10(uint256 VAR17);
event FUN11(uint256 VAR16);
event FUN12(uint256 VAR18);
event FUN13(uint256 VAR19);
event FUN14(address VAR20);
event FUN15(address VAR21);
event FUN16(address VAR22);
event FUN17(uint256 VAR23);
event FUN18(uint256 VAR24);
uint256 public VAR25;
uint256 public VAR26;
address public VAR27;
address public VAR28;
uint256 public VAR29;
uint256 public VAR30 = 0.1 VAR31;
modifier FUN19() {
require((msg.sender == VAR28) || (msg.sender == VAR12));
VAR13;
}
function FUN20(address VAR20, address VAR21, uint256 VAR18, uint256 VAR19, uint256 VAR23) {
VAR28 = VAR20;
VAR27 = VAR21;
VAR25 = VAR18;
VAR26 = VAR19;
VAR29 = VAR23;
}
function FUN21(address VAR21) VAR32 {
VAR27 = VAR21;
FUN15(VAR27);
}
function FUN22(uint256 VAR18) VAR32 {
VAR25 = VAR18;
FUN12(VAR25);
}
function FUN23(uint256 VAR24) VAR32 {
VAR30 = VAR24;
FUN18(VAR30);
}
function FUN24(uint256 VAR19) VAR32 {
VAR26 = VAR19;
FUN13(VAR26);
}
function FUN25(uint256 VAR23) VAR32 {
VAR29 = VAR23;
FUN17(VAR29);
}
function FUN26(address VAR20) onlyOwner {
VAR28 = VAR20;
FUN14(VAR20);
}
function FUN27() onlyOwner {
require(this.VAR33 != 0);
VAR12.transfer(this.VAR33);
FUN9(this.VAR33);
}
function FUN28(address VAR22) onlyOwner {
ERC20Basic VAR34 = FUN29(VAR22);
uint256 VAR35 = VAR34.FUN5(address(this));
require(VAR35 != 0);
assert(VAR34.transfer(VAR12, VAR35));
FUN10(VAR35);
}
function FUN30() {
if ((VAR25 != 0) && (FUN31() < VAR25)) return;
if ((VAR26 != 0) && (FUN32() < VAR26)) return;
if (this.VAR33 < VAR30) return;
uint256 VAR36 = VAR2.FUN4(this.VAR33, VAR29);
assert(VAR27.call.value(VAR36)());
FUN11(VAR36);
}
function () payable {
FUN8(msg.sender, msg.value);
}
function FUN31() internal constant returns (uint256) {
return VAR37.VAR38;
}
function FUN32() internal constant returns (uint256) {
return VAR39;
}
}
1
---------------------------------
140 0x8dc46946d5e56a780ee21ee6029af675a46e39bf.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function FUN1() constant returns (address);
function FUN2() constant returns (bool);
function FUN3(uint VAR3, uint VAR4,
uint VAR5, int VAR6) payable;
function FUN4() constant returns (bool);
function FUN5(uint VAR7);
}
contract VAR8 {
address public VAR9;
address public VAR10;
address public VAR11;
address public VAR12;
event FUN6(address indexed VAR13, uint VAR14);
modifier onlyOwner {
require(msg.sender == VAR9);
VAR15;
}
modifier VAR16 {
require(msg.sender == VAR9 || msg.sender == VAR10);
VAR15;
}
function FUN7(address VAR17) {
VAR9 = msg.sender;
VAR10 = msg.sender;
VAR12 = VAR17;
}
function () payable {
FUN6(msg.sender, msg.value);
}
function FUN8() constant returns (bool) {
if (FUN9(VAR12).FUN1() != address(this)) {
return false;
}
return FUN9(VAR12).FUN4();
}
function FUN10(uint VAR7) {
FUN9(VAR12).FUN5(VAR7);
}
function FUN3(uint VAR3, uint VAR4,
uint VAR5, int VAR6)
VAR16 {
FUN9(VAR12).VAR18.value(VAR3)(
VAR3, VAR4, VAR5, VAR6);
}
function FUN11(uint VAR14) onlyOwner {
VAR9.transfer(VAR14);
}
function FUN12(address VAR17) onlyOwner {
VAR12 = VAR17;
}
function FUN13(address VAR19) onlyOwner {
VAR10 = VAR19;
}
function FUN14(address VAR20) onlyOwner {
VAR11 = VAR20;
}
function FUN15() {
require(VAR11 != 0);
require(msg.sender == VAR11);
VAR9 = VAR11;
}
function FUN16() onlyOwner {
FUN17(VAR9);
}
}
1
---------------------------------
141 0x90263ea5c57dc6603ca7202920735a6e31235bb9.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function transfer(address VAR3, uint VAR4) public returns (bool VAR5);
function FUN1(address VAR6, address VAR3, uint256 VAR4) public returns (bool VAR5);
function FUN2(address VAR7, address VAR8) public view returns (uint256 VAR9);
function FUN3(address VAR8, uint256 VAR4) public returns (bool VAR5);
function FUN4 (address VAR8, uint VAR10) public returns (bool VAR5);
function FUN5(address VAR7) public view returns (uint256 VAR11);
}
contract VAR12 {
address public constant VAR13 = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;
function FUN6(Token VAR14, Token VAR15, uint256 VAR16) external view returns (uint256 VAR17);
function FUN7(Token VAR14, Token VAR15, uint256 VAR16, uint256 VAR18) external payable returns (uint256 VAR17);
}
contract VAR19 {
address public VAR20;
event FUN8(address VAR7);
modifier onlyOwner() {
require(msg.sender == VAR20, "");
VAR21;
}
constructor() public {
VAR20 = msg.sender;
emit FUN8(msg.sender);
}
function FUN9(address VAR3) external onlyOwner returns (bool) {
require(VAR3 != address(0), "");
VAR20 = VAR3;
emit FUN8(VAR3);
return true;
}
}
contract Oracle is VAR19 {
uint256 public constant VAR22 = 4;
event FUN10(bytes32 VAR23);
mapping(bytes32 => bool) public VAR24;
bytes32[] public VAR25;
function FUN11() public view returns (string);
function FUN12(bytes32 VAR26, bytes VAR27) public returns (uint256 VAR28, uint256 VAR29);
function FUN13(string VAR30) public onlyOwner returns (bool) {
bytes32 VAR31 = FUN14(VAR30);
FUN10(VAR31);
VAR24[VAR31] = true;
VAR25.FUN15(VAR31);
return true;
}
function FUN14(string VAR31) public pure returns (bytes32 VAR32) {
require(bytes(VAR31).VAR33 <= 32);
VAR34 {
VAR32 := FUN16(FUN17(VAR31, 32))
}
}
function FUN18(bytes32 VAR35) public pure returns (string VAR32) {
uint256 VAR36 = 256;
while (true) { if (VAR36 == 0 || (VAR35<<VAR36-8) != 0) break; VAR36 -= 8; }
VAR34 {
VAR36 := FUN19(VAR36, 8)
VAR32 := FUN16(0x40)
FUN20(0x40, FUN17(VAR32, FUN21(FUN17(FUN17(VAR36, 0x20), 0x1f), FUN22(0x1f))))
FUN20(VAR32, VAR36)
FUN20(FUN17(VAR32, 32), VAR35)
}
}
}
contract VAR37 {
uint256 public VAR22;
string public VAR38;
enum VAR39 { VAR40, VAR41, VAR42, VAR43 }
struct VAR44 {
bool VAR45;
bytes VAR27;
bytes32 VAR46;
}
function FUN23() public view returns (uint256);
function FUN24(uint VAR47) public view returns (VAR48);
function FUN25(uint VAR47) public view returns (address);
function FUN26(uint VAR47) public view returns (address);
function FUN27(uint256) public view returns (address VAR20);
function FUN28(uint VAR47) public view returns (address);
function FUN29(uint VAR47) public view returns (uint256);
function FUN30(uint VAR47) public view returns (uint256);
function FUN31(uint VAR47) public view returns (uint256);
function FUN32(uint VAR47, address VAR49) public view returns (bool);
function FUN33(uint VAR47) public view returns (VAR39);
function FUN34(uint VAR47) public view returns (bool);
function FUN35(uint VAR47) public returns (uint256);
function FUN36(uint VAR47) public view returns (bytes32);
function FUN37(uint VAR47, uint256 VAR50) external returns (bool);
function FUN38(uint VAR47) public returns (bool);
function transfer(address VAR51, uint256 VAR47) public returns (bool);
function FUN39(uint256 VAR47) public returns (bool);
function FUN40(uint VAR47, address VAR51, uint256 VAR17) public returns (bool);
function FUN41(bytes32 VAR52) public view returns (uint256);
}
contract VAR53 {
uint256 public constant VAR22 = 2;
function FUN11() public view returns (string);
function FUN42(address VAR54, uint256 VAR47, bytes VAR27, bytes VAR55) public view returns (uint256);
function FUN43(Engine VAR54, uint256 VAR47, bytes VAR27, bytes VAR55) public returns (bool);
function FUN44(address VAR54, uint256 VAR47, bytes VAR55) external returns (bool);
}
contract VAR56 {
event Transfer(address indexed VAR6, address indexed VAR3, uint256 VAR57);
event FUN45(address indexed VAR7, address indexed VAR58, uint256 VAR57);
event FUN46(address indexed VAR7, address indexed VAR59, bool VAR58);
}
library VAR60 {
function FUN17(uint256 VAR61, uint256 VAR62) internal pure returns (uint256) {
uint256 VAR63 = VAR61 + VAR62;
require((VAR63 >= VAR61) && (VAR63 >= VAR62), "");
return VAR63;
}
function FUN47(uint256 VAR61, uint256 VAR62) internal pure returns (uint256) {
require(VAR61 >= VAR62, "");
uint256 VAR63 = VAR61 - VAR62;
return VAR63;
}
function FUN48(uint256 VAR61, uint256 VAR62) internal pure returns (uint256) {
uint256 VAR63 = VAR61 * VAR62;
require((VAR61 == 0)||(VAR63/VAR61 == VAR62), "");
return VAR63;
}
}
contract VAR64 {
bytes4 private constant VAR65 = 0x01ffc9a7;
mapping(bytes4 => bool) private VAR66;
constructor()
internal
{
FUN49(VAR65);
}
function FUN50(bytes4 VAR67)
external
view
returns (bool)
{
return VAR66[VAR67];
}
function FUN49(bytes4 VAR67)
internal
{
require(VAR67 != 0xffffffff, "");
VAR66[VAR67] = true;
}
}
interface VAR68 {
function FUN51(uint256 VAR57) external view returns (string);
}
contract ERC721Base is VAR64 {
using SafeMath for uint256;
mapping(uint256 => address) private VAR69;
mapping(address => uint256[]) private VAR70;
mapping(address => mapping(address => bool)) private VAR71;
mapping(uint256 => address) private VAR72;
mapping(uint256 => uint256) private VAR73;
bytes4 private constant VAR74 = 0x150b7a02;
bytes4 private constant VAR75 = 0xf0b9e5ba;
event Transfer(address indexed VAR6, address indexed VAR3, uint256 VAR57);
event FUN45(address indexed VAR7, address indexed VAR58, uint256 VAR57);
event FUN46(address indexed VAR7, address indexed VAR59, bool VAR58);
bytes4 private constant VAR76 = 0x80ac58cd;
bytes4 private constant VAR77 = 0x5b5e139f;
bytes4 private constant VAR78 = 0x780e9d63;
constructor(
string VAR79,
string VAR26
) public {
VAR80 = VAR79;
VAR81 = VAR26;
FUN49(VAR76);
FUN49(VAR77);
FUN49(VAR78);
}
event FUN52(address VAR82);
string private VAR80;
string private VAR81;
URIProvider private VAR82;
function FUN53() external view returns (string) {
return VAR80;
}
function FUN54() external view returns (string) {
return VAR81;
}
function FUN51(uint256 VAR57) external view returns (string) {
require(VAR69[VAR57] != 0, "");
URIProvider VAR83 = VAR82;
return VAR83 == address(0) ? "" : VAR83.FUN51(VAR57);
}
function FUN55(URIProvider VAR84) internal returns (bool) {
emit FUN52(VAR84);
VAR82 = VAR84;
return true;
}
uint256[] private VAR85;
function FUN56() external view returns (uint256[]) {
return VAR85;
}
function FUN57(address VAR7) external view returns (uint256[]) {
return VAR70[VAR7];
}
function FUN58() external view returns (uint256) {
return VAR85.VAR33;
}
function FUN59(uint256 VAR86) external view returns (uint256) {
require(VAR86 < VAR85.VAR33, "");
return VAR85[VAR86];
}
function FUN60(address VAR7, uint256 VAR86) external view returns (uint256) {
require(VAR7 != address(0), "");
require(VAR86 < FUN61(VAR7), "");
return VAR70[VAR7][VAR86];
}
//
//
function FUN27(uint256 VAR87) external view returns (address) {
return FUN62(VAR87);
}
function FUN62(uint256 VAR87) internal view returns (address) {
return VAR69[VAR87];
}
//
//
function FUN5(address VAR7) external view returns (uint256) {
return FUN61(VAR7);
}
function FUN61(address VAR7) internal view returns (uint256) {
return VAR70[VAR7].VAR33;
}
//
//
function FUN63(
address VAR59,
address VAR88
) external view returns (bool) {
return FUN64(VAR59, VAR88);
}
function FUN64(
address VAR59,
address VAR88
) internal view returns (bool) {
return VAR71[VAR88][VAR59];
}
function FUN65(uint256 VAR87) external view returns (address) {
return FUN66(VAR87);
}
function FUN66(uint256 VAR87) internal view returns (address) {
return VAR72[VAR87];
}
function FUN67(address VAR59, uint256 VAR87) external view returns (bool) {
return FUN68(VAR59, VAR87);
}
function FUN68(address VAR59, uint256 VAR87) internal view returns (bool) {
require(VAR59 != 0, "");
address VAR20 = FUN62(VAR87);
if (VAR59 == VAR20) {
return true;
}
return FUN64(VAR59, VAR20) || FUN66(VAR87) == VAR59;
}
//
//
function FUN69(address VAR59, bool VAR89) external {
if (VAR71[msg.sender][VAR59] != VAR89) {
VAR71[msg.sender][VAR59] = VAR89;
emit FUN46(VAR59, msg.sender, VAR89);
}
}
function FUN3(address VAR59, uint256 VAR87) external {
address VAR90 = FUN62(VAR87);
require(msg.sender == VAR90 || FUN64(msg.sender, VAR90), "");
if (FUN66(VAR87) != VAR59) {
VAR72[VAR87] = VAR59;
emit FUN45(VAR90, VAR59, VAR87);
}
}
//
//
function FUN70(address VAR3, uint256 VAR87) internal {
VAR69[VAR87] = VAR3;
uint256 VAR33 = FUN61(VAR3);
VAR70[VAR3].FUN15(VAR87);
VAR73[VAR87] = VAR33;
VAR85.FUN15(VAR87);
}
function FUN71(address VAR6, address VAR3, uint256 VAR87) internal {
uint256 VAR91 = VAR73[VAR87];
uint256 VAR92 = FUN61(VAR6).FUN47(1);
if (VAR91 != VAR92) {
uint256 VAR93 = VAR70[VAR6][VAR92];
VAR70[VAR6][VAR91] = VAR93;
}
VAR70[VAR6][VAR92] = 0;
VAR70[VAR6].VAR33--;
VAR69[VAR87] = VAR3;
uint256 VAR33 = FUN61(VAR3);
VAR70[VAR3].FUN15(VAR87);
VAR73[VAR87] = VAR33;
}
function FUN72(address VAR94, uint256 VAR87) internal {
if (VAR72[VAR87] != 0) {
VAR72[VAR87] = 0;
emit FUN45(VAR94, 0, VAR87);
}
}
//
//
function FUN73(uint256 VAR87, address VAR95) internal {
require(VAR69[VAR87] == 0, "");
FUN70(VAR95, VAR87);
emit Transfer(0x0, VAR95, VAR87);
}
//
//
modifier FUN74(uint256 VAR87) {
require(FUN62(VAR87) == msg.sender, "");
VAR21;
}
modifier FUN75(uint256 VAR87) {
require(FUN68(msg.sender, VAR87), "");
VAR21;
}
modifier FUN76(address VAR6, uint256 VAR87) {
require(FUN62(VAR87) == VAR6, "");
VAR21;
}
modifier FUN77(address VAR96) {
require(VAR96 != address(0), "");
VAR21;
}
function FUN78(address VAR6, address VAR3, uint256 VAR87) external {
return FUN79(VAR6, VAR3, VAR87, "", true);
}
function FUN78(address VAR6, address VAR3, uint256 VAR87, bytes VAR97) external {
return FUN79(VAR6, VAR3, VAR87, VAR97, true);
}
function FUN1(address VAR6, address VAR3, uint256 VAR87) external {
return FUN79(VAR6, VAR3, VAR87, "", false);
}
function FUN79(
address VAR6,
address VAR3,
uint256 VAR87,
bytes VAR97,
bool VAR98
)
internal
FUN75(VAR87)
FUN77(VAR3)
FUN76(VAR6, VAR87)
{
address VAR90 = VAR69[VAR87];
FUN72(VAR90, VAR87);
FUN71(VAR90, VAR3, VAR87);
if (VAR98 && FUN80(VAR3)) {
uint256 VAR5;
bytes32 VAR99;
(VAR5, VAR99) = FUN81(
VAR3,
VAR100.FUN82(
VAR74,
msg.sender,
VAR90,
VAR87,
VAR97
)
);
if (VAR5 != 1 || VAR99 != VAR74) {
(VAR5, VAR99) = FUN81(
VAR3,
VAR100.FUN82(
VAR75,
VAR90,
VAR87,
VAR97
)
);
require(
VAR5 == 1 && VAR99 == VAR75,
""
);
}
}
emit Transfer(VAR90, VAR3, VAR87);
}
//
//
function FUN80(address VAR101) internal view returns (bool) {
uint VAR102;
VAR34 { VAR102 := FUN83(VAR101) }
return VAR102 > 0;
}
function FUN81(
address VAR103,
bytes VAR104
) internal returns (uint256 VAR5, bytes32 VAR99) {
VAR34 {
let VAR61 := FUN16(0x40)
VAR5 := call(
VAR105,
VAR103,
0,
FUN17(0x20, VAR104),
FUN16(VAR104),
VAR61,
0x20
)
VAR99 := FUN16(VAR61)
}
}
}
contract SafeWithdraw is VAR19 {
function FUN84(Token VAR106, address VAR51, uint256 VAR17) external onlyOwner returns (bool) {
require(VAR51 != address(0), "");
return VAR106.transfer(VAR51, VAR17);
}
function FUN85(ERC721Base VAR106, address VAR51, uint256 VAR107) external onlyOwner returns (bool) {
require(VAR51 != address(0), "");
VAR106.FUN1(this, VAR51, VAR107);
}
function FUN86(address VAR51, uint256 VAR17) external onlyOwner returns (bool) {
VAR51.transfer(VAR17);
return true;
}
}
contract VAR108 {
function FUN87(bytes VAR27, uint256 VAR47) internal pure returns (bytes32 VAR32) {
require(VAR27.VAR33 / 32 > VAR47);
VAR34 {
VAR32 := FUN16(FUN17(VAR27, FUN17(32, FUN88(32, VAR47))))
}
}
}
contract VAR109 {
struct VAR110 {
bytes32 VAR107;
address VAR111;
uint256 VAR112;
uint256 VAR113;
}
mapping (uint256 => VAR110) public VAR114;
function FUN89(uint256 VAR115, uint256 VAR112) public;
}
contract Land is VAR56 {
function FUN90(int VAR61, int VAR62, string VAR27) public;
function FUN91(uint value) view public returns (int, int);
function FUN78(address VAR116, address VAR51, uint256 VAR115) public;
function FUN27(uint256 VAR117) public view returns (address);
function FUN92(uint256 VAR115, address VAR118) external;
}
contract MortgageManager is VAR53, VAR119, VAR120, VAR108 {
uint256 constant internal VAR121 = (10**18);
uint256 constant internal VAR122 = 18;
bytes32 public constant VAR123 = 0x4d414e4100000000000000000000000000000000000000000000000000000000;
uint256 public constant VAR124 = 1000000000 * 10**18;
event FUN93(
uint256 VAR125,
address VAR126,
address VAR127,
uint256 VAR128,
address VAR129,
uint256 VAR130,
uint256 VAR131,
address VAR132
);
event FUN94(
address VAR133,
bytes32 VAR23,
uint256 VAR134,
uint256 VAR135
);
event FUN95(uint256 VAR125);
event FUN96(address VAR6, uint256 VAR125);
event FUN97(address VAR6, uint256 VAR125);
event FUN98(uint256 VAR125);
event FUN99(address VAR136, uint256 VAR137, string VAR104);
event FUN100(address VAR138, bool VAR139);
event FUN101(address VAR127, bool VAR139);
Token public VAR140;
Token public VAR141;
Land public VAR142;
constructor(
Token VAR143,
Token VAR144,
Land VAR145
) public FUN102("", "") {
VAR140 = VAR143;
VAR141 = VAR144;
VAR142 = VAR145;
VAR146.VAR33++;
}
enum VAR39 { VAR147, VAR148, VAR149, VAR150, VAR151 }
struct VAR152 {
LandMarket VAR153;
address VAR20;
Engine VAR54;
uint256 VAR154;
uint256 VAR155;
uint256 VAR156;
uint256 VAR157;
Status VAR158;
TokenConverter VAR159;
}
uint256 internal VAR160;
VAR152[] public VAR146;
mapping(address => bool) public VAR161;
mapping(address => bool) public VAR162;
mapping(uint256 => uint256) public VAR163;
mapping(address => mapping(uint256 => uint256)) public VAR164;
function FUN11() public view returns (string) {
return "";
}
function FUN103(address VAR54, bool VAR165) external onlyOwner returns (bool) {
emit FUN101(VAR54, VAR165);
VAR162[VAR54] = VAR165;
return true;
}
function FUN104(URIProvider VAR84) external onlyOwner returns (bool) {
return FUN55(VAR84);
}
function FUN105(address VAR166, bool VAR165) external onlyOwner returns (bool) {
emit FUN100(VAR166, VAR165);
VAR161[VAR166] = VAR165;
return true;
}
function FUN42(address, uint256, bytes, bytes) public view returns (uint256) {
return 0;
}
function FUN106(
Engine VAR54,
bytes32 VAR167,
uint256 VAR155,
LandMarket VAR153,
uint256 VAR156,
TokenConverter VAR159
) external returns (uint256 VAR107) {
return FUN107(VAR54, VAR153, VAR54.FUN41(VAR167), VAR155, VAR156, VAR159);
}
function FUN107(
Engine VAR54,
LandMarket VAR153,
uint256 VAR154,
uint256 VAR155,
uint256 VAR156,
TokenConverter VAR159
) public returns (uint256 VAR107) {
require(VAR54.FUN36(VAR154) == VAR123, "");
address VAR168 = VAR54.FUN25(VAR154);
require(VAR162[VAR54], "");
require(VAR54.FUN33(VAR154) == VAR37.VAR39.VAR40, "");
require(
msg.sender == VAR168 || (msg.sender == VAR54.FUN28(VAR154) && VAR161[msg.sender]),
""
);
require(VAR54.FUN34(VAR154), "");
require(VAR140.FUN2(VAR168, this) >= VAR124, "");
require(VAR159 != address(0), "");
require(VAR164[VAR54][VAR154] == 0, "");
uint256 VAR157;
(, , VAR157, ) = VAR153.FUN108(VAR156);
uint256 VAR169 = VAR54.FUN29(VAR154);
require(VAR169 + VAR155 >= VAR157, "");
require(VAR141.FUN1(msg.sender, this, VAR155), "");
VAR107 = VAR146.FUN15(FUN109({
VAR20: VAR168,
VAR54: VAR54,
VAR154: VAR154,
VAR155: VAR155,
VAR153: VAR153,
VAR156: VAR156,
VAR157: VAR157,
VAR158: VAR39.VAR147,
VAR159: VAR159
})) - 1;
VAR164[VAR54][VAR154] = VAR107;
emit FUN93({
VAR125: VAR107,
VAR126: VAR168,
VAR127: VAR54,
VAR128: VAR154,
VAR129: VAR153,
VAR130: VAR156,
VAR131: VAR155,
VAR132: VAR159
});
}
function FUN110(uint256 VAR107) external returns (bool) {
Mortgage storage VAR170 = VAR146[VAR107];
require(msg.sender == VAR170.VAR20, "");
require(VAR170.VAR158 == VAR39.VAR147, "");
VAR170.VAR158 = VAR39.VAR149;
require(VAR141.transfer(msg.sender, VAR170.VAR155), "");
emit FUN96(msg.sender, VAR107);
return true;
}
function FUN43(Engine VAR54, uint256 VAR47, bytes VAR27, bytes VAR55) public returns (bool) {
Mortgage storage VAR170 = VAR146[uint256(FUN87(VAR27, 0))];
require(VAR170.VAR54 == VAR54, "");
require(VAR170.VAR154 == VAR47, "");
require(VAR170.VAR158 == VAR39.VAR147, "");
require(VAR162[VAR54], "");
VAR170.VAR158 = VAR39.VAR148;
FUN73(uint256(FUN87(VAR27, 0)), VAR170.VAR20);
uint256 VAR169 = FUN111(VAR54.FUN24(VAR47), VAR54.FUN36(VAR47), VAR55, VAR54.FUN29(VAR47));
require(VAR140.FUN1(VAR170.VAR20, this, VAR169), "");
uint256 VAR171 = FUN112(VAR170.VAR159, VAR140, VAR141, VAR169);
delete VAR170.VAR159;
uint256 VAR172;
(, , VAR172, ) = VAR170.VAR153.FUN108(VAR170.VAR156);
require(VAR172 <= VAR170.VAR157, "");
require(VAR141.FUN3(VAR170.VAR153, VAR172), "");
VAR160 = VAR170.VAR156;
VAR170.VAR153.FUN89(VAR170.VAR156, VAR172);
require(VAR141.FUN3(VAR170.VAR153, 0), "");
require(VAR160 == 0, "");
require(VAR142.FUN27(VAR170.VAR156) == address(this), "");
VAR142.FUN92(VAR170.VAR156, VAR170.VAR20);
uint256 VAR173 = VAR171.FUN17(VAR170.VAR155);
uint256 VAR174 = VAR173.FUN47(VAR172);
require(VAR141.transfer(VAR170.VAR20, VAR174), "");
require(VAR170.VAR54.FUN37(VAR47, 0), "");
VAR163[VAR170.VAR156] = uint256(FUN87(VAR27, 0));
emit FUN95(uint256(FUN87(VAR27, 0)));
return true;
}
function FUN112(
TokenConverter VAR175,
Token VAR116,
Token VAR51,
uint256 VAR17
) internal returns (uint256 VAR176) {
require(VAR116.FUN3(VAR175, VAR17), "");
uint256 VAR177 = VAR51.FUN5(this);
VAR176 = VAR175.FUN7(VAR116, VAR51, VAR17, 1);
require(VAR51.FUN5(this).FUN47(VAR177) >= VAR176, "");
require(VAR116.FUN3(VAR175, 0), "");
}
function FUN44(address VAR54, uint256 VAR154, bytes) external returns (bool) {
uint256 VAR178 = VAR164[VAR54][VAR154];
Mortgage storage VAR170 = VAR146[VAR178];
require(VAR170.VAR158 == VAR39.VAR148, "");
require(VAR170.VAR154 == VAR154, "");
if (VAR170.VAR54.FUN33(VAR154) == VAR37.VAR39.VAR42 || VAR170.VAR54.FUN33(VAR154) == VAR37.VAR39.VAR43) {
require(FUN68(msg.sender, VAR178), "");
VAR170.VAR158 = VAR39.VAR150;
VAR142.FUN78(this, msg.sender, VAR170.VAR156);
emit FUN97(msg.sender, VAR178);
} else if (FUN113(VAR170.VAR54, VAR154)) {
require(msg.sender == VAR170.VAR54.FUN27(VAR154), "");
VAR170.VAR158 = VAR39.VAR151;
VAR142.FUN78(this, msg.sender, VAR170.VAR156);
emit FUN98(VAR178);
} else {
revert("");
}
delete VAR163[VAR170.VAR156];
return true;
}
function FUN113(Engine VAR54, uint256 VAR47) public view returns (bool) {
return VAR54.FUN33(VAR47) == VAR37.VAR39.VAR41 &&
VAR54.FUN31(VAR47).FUN17(7 VAR179) <= VAR180.VAR181;
}
function FUN114(uint256 VAR57, address, bytes) external returns (bytes4) {
if (msg.sender == address(VAR142) && VAR160 == VAR57) {
VAR160 = 0;
return bytes4(FUN115(""));
}
}
function FUN114(address, uint256 VAR57, bytes) external returns (bytes4) {
if (msg.sender == address(VAR142) && VAR160 == VAR57) {
VAR160 = 0;
return bytes4(FUN115(""));
}
}
function FUN114(address, address, uint256 VAR57, bytes) external returns (bytes4) {
if (msg.sender == address(VAR142) && VAR160 == VAR57) {
VAR160 = 0;
return bytes4(0x150b7a02);
}
}
function FUN116(uint256 VAR107) public pure returns (bytes VAR32) {
VAR34 {
VAR32 := FUN16(0x40)
FUN20(0x40, FUN17(VAR32, FUN21(FUN17(FUN17(32, 0x20), 0x1f), FUN22(0x1f))))
FUN20(VAR32, 32)
FUN20(FUN17(VAR32, 32), VAR107)
}
}
function FUN90(uint256 VAR107, string VAR27) external returns (bool) {
require(FUN68(msg.sender, VAR107), "");
(int256 VAR61, int256 VAR62) = VAR142.FUN91(VAR146[VAR107].VAR156);
VAR142.FUN90(VAR61, VAR62, VAR27);
emit FUN99(msg.sender, VAR107, VAR27);
return true;
}
function FUN111(Oracle VAR182, bytes32 VAR31, bytes VAR27, uint256 VAR17) internal returns (uint256) {
if (VAR182 == address(0)) {
return VAR17;
} else {
(uint256 VAR28, uint256 VAR29) = VAR182.FUN12(VAR31, VAR27);
emit FUN94(VAR182, VAR31, VAR29, VAR28);
require(VAR29 <= VAR122, "");
return VAR17.FUN48(VAR28.FUN48(10**(VAR122-VAR29))) / VAR121;
}
}
function FUN79(
address VAR6,
address VAR3,
uint256 VAR87,
bytes VAR97,
bool VAR98
)
internal
{
VAR119.FUN79(VAR6, VAR3, VAR87, VAR97, VAR98);
VAR142.FUN92(VAR146[VAR87].VAR156, VAR3);
}
}
interface VAR183 {
function FUN117(address VAR184, address VAR126, bytes32 VAR23, uint256 VAR185, uint256 VAR186,
uint256 VAR187, uint256 VAR188, uint256 VAR189, uint256 VAR190, string VAR191) public returns (uint256);
function FUN118(uint256 VAR47) public view returns (bytes32);
function FUN119(bytes32 VAR192, uint8 VAR193, bytes32 VAR194, bytes32 VAR195) public returns (bool);
function FUN120(uint VAR47, uint256 VAR185, address VAR6, bytes VAR55) public returns (bool);
function FUN121() public view returns (VAR2);
function FUN24(uint256 VAR47) public view returns (VAR48);
function FUN29(uint256 VAR47) public view returns (uint256);
function FUN36(uint256 VAR47) public view returns (bytes32);
function FUN111(Oracle VAR182, bytes32 VAR31, bytes VAR27, uint256 VAR17) public view returns (uint256);
function FUN122(uint VAR47, bytes VAR55, Cosigner VAR196, bytes VAR197) public returns (bool);
function transfer(address VAR51, uint256 VAR47) public returns (bool);
}
library VAR198 {
function FUN123(uint256 VAR61, uint256 VAR62) internal pure returns(uint256) {
uint256 VAR63 = VAR61 + VAR62;
require((VAR63 >= VAR61) && (VAR63 >= VAR62));
return VAR63;
}
function FUN124(uint256 VAR61, uint256 VAR62) internal pure returns(uint256) {
require(VAR61 >= VAR62);
uint256 VAR63 = VAR61 - VAR62;
return VAR63;
}
function FUN125(uint256 VAR61, uint256 VAR62) internal pure returns(uint256) {
uint256 VAR63 = VAR61 * VAR62;
require((VAR61 == 0)||(VAR63/VAR61 == VAR62));
return VAR63;
}
function FUN126(uint256 VAR199, uint256 VAR35) internal pure returns(uint256) {
if (VAR199 < VAR35) {
return VAR199;
} else {
return VAR35;
}
}
function FUN127(uint256 VAR199, uint256 VAR35) internal pure returns(uint256) {
if (VAR199 > VAR35) {
return VAR199;
} else {
return VAR35;
}
}
}
contract ConverterRamp is VAR19 {
using LrpSafeMath for uint256;
address public constant VAR13 = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;
uint256 public constant VAR200 = 1000001;
uint256 public constant VAR201 = 0;
uint256 public constant VAR202 = 1;
uint256 public constant VAR203 = 2;
uint256 public constant VAR204 = 0;
uint256 public constant VAR205 = 1;
uint256 public constant VAR206 = 2;
uint256 public constant VAR207 = 3;
uint256 public constant VAR208 = 2;
event FUN128(address VAR106, uint256 VAR17);
event FUN129(address VAR106, address VAR51, uint256 VAR17);
event FUN130(address VAR106, uint256 VAR17);
event FUN131(uint256 VAR209);
event FUN132(uint256 VAR210, uint256 VAR211);
function FUN120(
TokenConverter VAR175,
Token VAR212,
bytes32[4] VAR213,
bytes VAR55,
uint256[3] VAR214
) external payable returns (bool) {
Token VAR140 = FUN133(address(VAR213[VAR204])).FUN121();
uint256 VAR215 = VAR140.FUN5(this);
uint256 VAR216 = FUN134(VAR213, VAR55);
emit FUN131(VAR216);
uint256 VAR217 = FUN135(VAR175, VAR212, VAR140, VAR216, VAR214[VAR201]);
emit FUN130(VAR212, VAR217);
FUN136(VAR212, VAR217);
uint256 VAR176 = FUN112(VAR175, VAR212, VAR140, VAR217);
require(
FUN137({
VAR218: VAR213,
VAR55: VAR55,
VAR219: VAR176
}),
""
);
require(
FUN138({
VAR175: VAR175,
VAR212: VAR140,
VAR220: VAR212,
VAR17: VAR140.FUN5(this) - VAR215,
VAR221: VAR217,
VAR214: VAR214
}),
""
);
require(VAR140.FUN5(this) == VAR215, "");
return true;
}
function FUN139(
TokenConverter VAR175,
Token VAR212,
bytes32[3] VAR213,
bytes VAR55,
bytes VAR197,
uint256[3] VAR214
) external view returns (uint256) {
Token VAR140 = FUN133(address(VAR213[0])).FUN121();
return FUN135(
VAR175,
VAR212,
VAR140,
FUN140(VAR213, VAR55, VAR197),
VAR214[VAR201]
);
}
function FUN141(
TokenConverter VAR175,
Token VAR212,
bytes32[4] VAR213,
bytes VAR55,
uint256[3] VAR214
) external view returns (uint256) {
Token VAR140 = FUN133(address(VAR213[0])).FUN121();
return FUN135(
VAR175,
VAR212,
VAR140,
FUN134(VAR213, VAR55),
VAR214[VAR201]
);
}
function FUN122(
TokenConverter VAR175,
Token VAR212,
bytes32[3] VAR213,
bytes VAR55,
bytes VAR197,
uint256[3] VAR214
) external payable returns (bool) {
Token VAR140 = FUN133(address(VAR213[0])).FUN121();
uint256 VAR215 = VAR140.FUN5(this);
uint256 VAR216 = FUN140(VAR213, VAR55, VAR197);
emit FUN131(VAR216);
uint256 VAR217 = FUN135(VAR175, VAR212, VAR140, VAR216, VAR214[VAR201]);
emit FUN130(VAR212, VAR217);
FUN136(VAR212, VAR217);
uint256 VAR176 = FUN112(VAR175, VAR212, VAR140, VAR217);
require(VAR140.FUN3(address(VAR213[0]), VAR176));
require(FUN142(VAR213, VAR55, VAR197), "");
require(VAR140.FUN3(address(VAR213[0]), 0));
require(FUN143(VAR213, msg.sender), "");
require(
FUN138({
VAR175: VAR175,
VAR212: VAR140,
VAR220: VAR212,
VAR17: VAR140.FUN5(this) - VAR215,
VAR221: VAR217,
VAR214: VAR214
}),
""
);
require(VAR140.FUN5(this) == VAR215);
return true;
}
function FUN136(
Token VAR106,
uint256 VAR17
) private {
if (VAR106 == VAR13) {
require(msg.value >= VAR17, "");
if (msg.value > VAR17) {
msg.sender.transfer(msg.value - VAR17);
}
} else {
require(VAR106.FUN1(msg.sender, this, VAR17), "");
}
}
function transfer(
Token VAR106,
address VAR51,
uint256 VAR17
) private {
if (VAR106 == VAR13) {
VAR51.transfer(VAR17);
} else {
require(VAR106.transfer(VAR51, VAR17), "");
}
}
function FUN138(
TokenConverter VAR175,
Token VAR212,
Token VAR220,
uint256 VAR17,
uint256 VAR221,
uint256[3] memory VAR214
) internal returns (bool) {
uint256 VAR222 = VAR214[VAR203];
uint256 VAR176 = 0;
if (VAR17 != 0) {
if (VAR17 > VAR222) {
VAR176 = FUN112(VAR175, VAR212, VAR220, VAR17);
emit FUN128(VAR220, VAR17);
emit FUN129(VAR220, msg.sender, VAR176);
transfer(VAR220, msg.sender, VAR176);
} else {
emit FUN129(VAR212, msg.sender, VAR17);
transfer(VAR212, msg.sender, VAR17);
}
}
uint256 VAR223 = VAR214[VAR202];
require(VAR221.FUN124(VAR176) <= VAR223 || VAR223 == 0, "");
return true;
}
function FUN135(
TokenConverter VAR175,
Token VAR212,
Token VAR220,
uint256 VAR224,
uint256 VAR225
) internal returns (uint256 VAR226) {
uint256 VAR227 = (10 ** 18 * VAR175.FUN6(VAR220, VAR212, VAR224)) / VAR224;
if (VAR225 == VAR200) {
uint256 VAR228 = 0;
uint256 VAR217 = FUN144(VAR224, VAR227);
uint256 VAR211 = FUN144(VAR224 / 100000, VAR227);
uint256 VAR229;
uint256 VAR230;
while (VAR228 < VAR224 && VAR230 < 10) {
VAR217 += VAR211;
VAR229 = VAR175.FUN6(VAR212, VAR220, VAR217);
VAR217 = (VAR217 * VAR224) / VAR229;
VAR228 = VAR229;
VAR230++;
}
emit FUN132(VAR230, VAR211);
return VAR217;
} else {
return FUN144(VAR224, VAR227).FUN125(uint256(100000).FUN123(VAR225)) / 100000;
}
}
function FUN112(
TokenConverter VAR175,
Token VAR212,
Token VAR220,
uint256 VAR17
) internal returns (uint256 VAR176) {
if (VAR212 != VAR13) require(VAR212.FUN3(VAR175, VAR17));
uint256 VAR177 = VAR220 != VAR13 ? VAR220.FUN5(this) : address(this).VAR11;
uint256 VAR231 = VAR212 == VAR13 ? VAR17 : 0;
uint256 VAR232 = VAR175.VAR233.value(VAR231)(VAR212, VAR220, VAR17, 1);
require(
VAR232 == (VAR220 != VAR13 ? VAR220.FUN5(this) : address(this).VAR11) - VAR177,
""
);
if (VAR212 != VAR13) require(VAR212.FUN3(VAR175, 0));
return VAR232;
}
function FUN137(
bytes32[4] memory VAR218,
bytes VAR55,
uint256 VAR219
) internal returns (bool) {
NanoLoanEngine VAR54 = FUN133(address(VAR218[VAR204]));
uint256 VAR47 = uint256(VAR218[VAR205]);
Oracle VAR182 = VAR54.FUN24(VAR47);
uint256 VAR234;
if (VAR182 == address(0)) {
VAR234 = VAR219;
} else {
uint256 VAR28;
uint256 VAR29;
bytes32 VAR31 = VAR54.FUN36(VAR47);
(VAR28, VAR29) = VAR182.FUN12(VAR31, VAR55);
VAR234 = (VAR219 * (10 ** (18 - VAR29 + (18 * 2)) / VAR28)) / 10 ** 18;
}
Token VAR140 = VAR54.FUN121();
require(VAR140.FUN3(VAR54, VAR219));
require(VAR54.FUN120(VAR47, VAR234, address(VAR218[VAR207]), VAR55), "");
require(VAR140.FUN3(VAR54, 0));
return true;
}
function FUN142(
bytes32[3] memory VAR218,
bytes VAR55,
bytes VAR197
) internal returns (bool) {
NanoLoanEngine VAR54 = FUN133(address(VAR218[VAR204]));
uint256 VAR47 = uint256(VAR218[VAR205]);
return VAR54.FUN122(VAR47, VAR55, FUN145(address(VAR218[VAR208])), VAR197);
}
function FUN143(
bytes32[3] memory VAR218,
address VAR51
) internal returns (bool) {
return FUN133(address(VAR218[0])).transfer(VAR51, uint256(VAR218[1]));
}
function FUN144(
uint256 VAR17,
uint256 VAR28
) pure internal returns (uint256) {
return VAR17.FUN125(VAR28) / 10 ** 18;
}
function FUN140(
bytes32[3] memory VAR218,
bytes VAR55,
bytes VAR197
) internal returns (uint256 VAR209) {
NanoLoanEngine VAR54 = FUN133(address(VAR218[VAR204]));
uint256 VAR47 = uint256(VAR218[VAR205]);
Cosigner VAR196 = FUN145(address(VAR218[VAR208]));
if (VAR196 != address(0)) {
VAR209 += VAR196.FUN42(VAR54, VAR47, VAR197, VAR55);
}
VAR209 += VAR54.FUN111(VAR54.FUN24(VAR47), VAR54.FUN36(VAR47), VAR55, VAR54.FUN29(VAR47));
}
function FUN134(
bytes32[4] memory VAR218,
bytes VAR55
) internal returns (uint256) {
NanoLoanEngine VAR54 = FUN133(address(VAR218[VAR204]));
uint256 VAR47 = uint256(VAR218[VAR205]);
uint256 VAR17 = uint256(VAR218[VAR206]);
return VAR54.FUN111(VAR54.FUN24(VAR47), VAR54.FUN36(VAR47), VAR55, VAR17);
}
function FUN146(
address VAR51,
uint256 value,
bytes VAR27
) external onlyOwner returns (bool) {
return VAR51.call.value(value)(VAR27);
}
function() external {}
}
contract MortgageHelper is VAR19 {
using LrpSafeMath for uint256;
MortgageManager public VAR235;
NanoLoanEngine public VAR236;
Token public VAR140;
Token public VAR141;
LandMarket public VAR153;
TokenConverter public VAR159;
ConverterRamp public VAR237;
address public VAR238;
uint256 public VAR239 = 105;
uint256 public VAR240 = 0.001 VAR241;
uint256 public VAR242 = 500;
uint256 public VAR223 = 300;
bytes32 public constant VAR123 = 0x4d414e4100000000000000000000000000000000000000000000000000000000;
event FUN147(address VAR168, uint256 VAR154, uint256 VAR156, uint256 VAR178);
event FUN148(address VAR54, uint256 VAR154, uint256 VAR17);
event FUN149(uint256 VAR243, uint256 VAR244);
event FUN150(uint256 VAR243, uint256 VAR244);
event FUN151(uint256 VAR243, uint256 VAR244);
event FUN152(uint256 VAR243, uint256 VAR244);
event FUN153(address VAR243, address VAR244);
event FUN154(address VAR243, address VAR244);
event FUN155(address VAR245);
event FUN101(address VAR127);
event FUN156(address VAR129);
event FUN157(address VAR246);
constructor(
MortgageManager VAR246,
NanoLoanEngine VAR247,
LandMarket VAR129,
address VAR245,
TokenConverter VAR132,
ConverterRamp VAR248
) public {
VAR235 = VAR246;
VAR236 = VAR247;
VAR140 = VAR246.FUN121();
VAR141 = VAR246.FUN158();
VAR153 = VAR129;
VAR238 = VAR245;
VAR159 = VAR132;
VAR237 = VAR248;
require(VAR247.FUN121() == VAR140, "");
require(VAR246.FUN159(VAR247), "");
require(FUN80(VAR141), "");
require(FUN80(VAR140), "");
require(FUN80(VAR132), "");
require(FUN80(VAR129), "");
require(FUN80(VAR248), "");
require(FUN80(VAR245), "");
require(FUN80(VAR246), "");
emit FUN154(VAR237, VAR248);
emit FUN153(VAR159, VAR132);
emit FUN101(VAR247);
emit FUN156(VAR129);
emit FUN157(VAR246);
emit FUN155(VAR245);
emit FUN151(0, VAR223);
emit FUN150(0, VAR242);
emit FUN149(0, VAR240);
emit FUN152(0, VAR239);
}
function FUN117(uint256[6] memory VAR218, string VAR249) internal returns (uint256) {
return VAR236.FUN117(
VAR238,
msg.sender,
VAR123,
VAR218[0],
VAR218[1],
VAR218[2],
VAR218[3],
VAR218[4],
VAR218[5],
VAR249
);
}
function FUN160(uint256 VAR250) external onlyOwner returns (bool) {
emit FUN151(VAR223, VAR250);
VAR223 = VAR250;
return true;
}
function FUN161(uint256 VAR251) external onlyOwner returns (bool) {
emit FUN152(VAR239, VAR251);
VAR239 = VAR251;
return true;
}
function FUN162(ConverterRamp VAR248) external onlyOwner returns (bool) {
require(FUN80(VAR248), "");
emit FUN154(VAR237, VAR248);
VAR237 = VAR248;
return true;
}
function FUN163(uint256 VAR252) external onlyOwner returns (bool) {
emit FUN149(VAR240, VAR252);
VAR240 = VAR252;
return true;
}
function FUN164(uint256 VAR253) external onlyOwner returns (bool) {
emit FUN150(VAR242, VAR253);
VAR242 = VAR253;
return true;
}
function FUN165(TokenConverter VAR132) external onlyOwner returns (bool) {
require(FUN80(VAR132), "");
emit FUN153(VAR159, VAR132);
VAR159 = VAR132;
return true;
}
function FUN166(address VAR245) external onlyOwner returns (bool) {
require(FUN80(VAR245), "");
emit FUN155(VAR245);
VAR238 = VAR245;
return true;
}
function FUN103(NanoLoanEngine VAR127) external onlyOwner returns (bool) {
require(FUN80(VAR127), "");
emit FUN101(VAR127);
VAR236 = VAR127;
return true;
}
function FUN167(LandMarket VAR129) external onlyOwner returns (bool) {
require(FUN80(VAR129), "");
emit FUN156(VAR129);
VAR153 = VAR129;
return true;
}
function FUN168(MortgageManager VAR246) external onlyOwner returns (bool) {
require(FUN80(VAR246), "");
emit FUN157(VAR246);
VAR235 = VAR246;
return true;
}
function FUN106(
uint256[6] VAR213,
string VAR249,
uint256 VAR156,
uint8 VAR193,
bytes32 VAR194,
bytes32 VAR195
) external returns (uint256) {
uint256 VAR154 = FUN117(VAR213, VAR249);
NanoLoanEngine VAR247 = VAR236;
require(VAR247.FUN119(VAR247.FUN118(VAR154), VAR193, VAR194, VAR195), "");
uint256 VAR254 = ((FUN169(VAR156) * VAR239) / 100) - VAR247.FUN29(VAR154);
Token VAR144 = VAR141;
FUN170(VAR144, msg.sender, this, VAR254);
require(VAR144.FUN3(VAR235, VAR254), "");
uint256 VAR178 = VAR235.FUN107(
FUN171(VAR247),
VAR153,
VAR154,
VAR254,
VAR156,
VAR159
);
require(VAR144.FUN3(VAR235, 0), "");
emit FUN147(msg.sender, VAR154, VAR156, VAR178);
return VAR178;
}
function FUN169(uint256 VAR130) internal view returns (uint256 VAR157) {
(, , VAR157, ) = VAR153.FUN108(VAR130);
}
function FUN120(address VAR54, uint256 VAR255, uint256 VAR17) external returns (bool) {
emit FUN148(VAR54, VAR255, VAR17);
bytes32[4] memory VAR213 = [
bytes32(VAR54),
bytes32(VAR255),
bytes32(VAR17),
bytes32(msg.sender)
];
uint256[3] memory VAR256 = [
VAR242,
VAR17.FUN125(uint256(100000).FUN123(VAR223)) / 100000,
VAR240
];
require(address(VAR237).FUN172(
bytes4(0x86ee863d),
address(VAR159),
address(VAR141),
VAR213,
0x140,
VAR256,
0x0
), "");
}
function FUN170(Token VAR106, address VAR116, address VAR51, uint256 VAR17) internal {
require(VAR106.FUN5(VAR116) >= VAR17, "");
require(VAR106.FUN2(VAR116, address(this)) >= VAR17, "");
require(VAR106.FUN1(VAR116, VAR51, VAR17), "");
}
function FUN80(address VAR257) internal view returns (bool) {
uint VAR102;
VAR34 { VAR102 := FUN83(VAR257) }
return VAR102 > 0;
}
}
1
---------------------------------
142 0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 1 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
143 0x941d225236464a25eb18076df7da6a91d0f95e9e.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
uint VAR7;
function FUN1(address VAR8)
public
{
VAR6 = FUN2(VAR8);
}
function FUN3()
public
payable
{
if(msg.value > VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
VAR7 = VAR9.VAR10;
}
}
function FUN5(uint VAR11)
public
payable
{
if(VAR11<=VAR3[msg.sender]&&VAR9.VAR10>VAR7)
{
if(msg.sender.call.value(VAR11)())
{
VAR3[msg.sender]-=VAR11;
VAR6.FUN4(msg.sender,VAR11,"");
}
}
}
function() public payable{}
}
contract VAR12
{
struct VAR13
{
address VAR14;
string  VAR15;
uint VAR16;
uint  VAR17;
}
VAR13[] public VAR18;
Message VAR19;
function FUN4(address VAR20,uint VAR21,string VAR22)
public
{
VAR19.VAR14 = VAR20;
VAR19.VAR17 = VAR23;
VAR19.VAR16 = VAR21;
VAR19.VAR15 = VAR22;
VAR18.FUN6(VAR19);
}
}
1
---------------------------------
144 0x95cd217da207e35e3ac4cade6e766d5fb6fdaf8d.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1(address VAR3, uint8 VAR4, string VAR5) public payable returns (uint);
function FUN2(address VAR6) public view returns (uint);
function transfer(address VAR7, uint VAR8)     public returns (bool);
function FUN3(address VAR9, address VAR10, uint VAR11) public returns (bool);
function FUN4() public;
function FUN5(uint VAR12) public;
function FUN6(address VAR13) public;
}
contract VAR14 {
function FUN7(address VAR9, uint VAR11, bytes VAR15) public returns (bool);
}
contract ZethrBankroll is VAR14 {
using SafeMath for uint;
event FUN8(address indexed sender, uint indexed VAR16);
event FUN9(address indexed sender, uint indexed VAR16);
event FUN10(uint indexed VAR16);
event FUN11(uint indexed VAR16);
event FUN12(uint indexed VAR16);
event FUN13(address indexed sender, uint value);
event FUN14(address indexed VAR17);
event FUN15(address indexed VAR17);
event FUN16(address indexed VAR18);
event FUN17(address indexed VAR18);
event FUN18(uint VAR19);
event FUN19(uint VAR20, uint VAR21);
event FUN20(uint VAR22, address sender);
event FUN21(uint VAR22);
event FUN22(address VAR23);
event FUN23(address VAR23, uint VAR24);
event FUN24(address VAR23, uint VAR24);
uint constant public VAR25 = 10;
uint constant public VAR26 = 15;
uint constant public VAR27 = 5;
uint constant internal VAR28 = 1 VAR29;
address internal VAR30;
ZTHInterface public VAR31;
mapping (uint => Transaction) public VAR32;
mapping (uint => mapping (address => bool)) public VAR33;
mapping (address => bool) public VAR34;
mapping (address => bool) public VAR35;
mapping (address => uint) public VAR36;
address internal VAR37;
address[] public VAR38;
address[] public VAR39;
uint public VAR19;
uint public VAR40;
uint internal VAR41;
uint internal VAR42;
uint internal VAR43;
bool internal VAR44 = false;
struct Transaction {
address VAR45;
uint value;
bytes VAR46;
bool VAR47;
}
struct VAR48 {
address sender;
uint value;
}
modifier FUN25() {
if (msg.sender != address(this))
revert();
VAR49;
}
modifier FUN26(address VAR18) {
if (VAR35[VAR18])
revert();
VAR49;
}
modifier FUN27(address VAR18) {
if (!VAR35[VAR18])
revert();
VAR49;
}
modifier FUN28() {
address VAR50 = msg.sender;
if (!VAR34[VAR50])
revert();
VAR49;
}
modifier FUN29(address VAR17) {
if (VAR34[VAR17])
revert();
VAR49;
}
modifier ownerExists(address VAR17) {
if (!VAR34[VAR17])
revert();
VAR49;
}
modifier FUN30(uint VAR16) {
if (VAR32[VAR16].VAR45 == 0)
revert();
VAR49;
}
modifier confirmed(uint VAR16, address VAR17) {
if (!VAR33[VAR16][VAR17])
revert();
VAR49;
}
modifier notConfirmed(uint VAR16, address VAR17) {
if (VAR33[VAR16][VAR17])
revert();
VAR49;
}
modifier notExecuted(uint VAR16) {
if (VAR32[VAR16].VAR47)
revert();
VAR49;
}
modifier FUN31(address VAR51) {
if (VAR51 == 0)
revert();
VAR49;
}
modifier FUN32(uint VAR52, uint VAR53) {
if (   VAR52 > VAR25
|| VAR53 > VAR52
|| VAR53 == 0
|| VAR52 == 0)
revert();
VAR49;
}
constructor (address[] VAR54, uint VAR53)
public
FUN32(VAR54.VAR55, VAR53)
{
for (uint VAR56=0; VAR56<VAR54.VAR55; VAR56++) {
if (VAR34[VAR54[VAR56]] || VAR54[VAR56] == 0)
revert();
VAR34[VAR54[VAR56]] = true;
}
VAR38 = VAR54;
VAR19 = VAR53;
VAR41 = VAR57 - (1 VAR29);
}
function FUN33(address VAR58, address VAR59)
public
VAR60
{
VAR30   = VAR58;
VAR37 = VAR59;
VAR31 = FUN34(VAR30);
}
function()
public
payable
{
}
uint VAR61;
function FUN35()
public
payable
{
VAR61 = VAR61.FUN36(msg.value);
}
mapping(address => uint) VAR62;
mapping(address => uint) VAR63;
uint VAR64 = 100;
function FUN37() public {
require(VAR65.VAR66 == msg.sender);
require((VAR57 - 1 VAR67) >= VAR63[msg.sender]);
require((VAR62[msg.sender]+100) >= VAR64);
VAR62[msg.sender] = VAR64;
VAR63[msg.sender] = VAR57;
VAR64 = VAR64 + 1;
VAR31.VAR68.value(VAR61)(msg.sender, 33, "");
}
function FUN38()
public
payable
VAR60
{
uint VAR69 = address(this).VAR70;
if (VAR69 > 0.01 VAR71) {
VAR31.VAR68.value(VAR69)(address(0x0), 33, "");
emit FUN21(VAR69);
}
else {
emit FUN20(msg.value, msg.sender);
}
}
function FUN7(address
, uint
, bytes
) public returns (bool) {
}
function FUN39(uint VAR72)
public
returns(bool)
{
uint VAR73     = VAR57;
uint VAR74    = VAR31.FUN2(address(this));
uint VAR75        = (VAR74.FUN40(VAR27)).FUN41(100);
require (VAR72 <= VAR75);
if (VAR73 - VAR41 >= VAR28)
{
VAR41     = VAR73;
VAR42      = (VAR74.FUN40(VAR26)).FUN41(100);
VAR43 = VAR72;
return true;
}
else
{
if (VAR43.FUN36(VAR72) <= VAR42)
{
VAR43 += VAR72;
return true;
}
else { return false; }
}
}
function FUN42(uint VAR76)
public
VAR60
{
VAR42 = VAR76;
}
function FUN43(address VAR17)
public
VAR77
FUN29(VAR17)
FUN31(VAR17)
FUN32(VAR38.VAR55 + 1, VAR19)
{
VAR34[VAR17] = true;
VAR38.FUN44(VAR17);
emit FUN14(VAR17);
}
function FUN45(address VAR17)
public
VAR77
ownerExists(VAR17)
FUN32(VAR38.VAR55, VAR19)
{
VAR34[VAR17] = false;
for (uint VAR56=0; VAR56<VAR38.VAR55 - 1; VAR56++)
if (VAR38[VAR56] == VAR17) {
VAR38[VAR56] = VAR38[VAR38.VAR55 - 1];
break;
}
VAR38.VAR55 -= 1;
if (VAR19 > VAR38.VAR55)
FUN46(VAR38.VAR55);
emit FUN15(VAR17);
}
function FUN47(address VAR17, address VAR78)
public
VAR77
ownerExists(VAR17)
FUN29(VAR78)
{
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR38[VAR56] == VAR17) {
VAR38[VAR56] = VAR78;
break;
}
VAR34[VAR17] = false;
VAR34[VAR78] = true;
emit FUN15(VAR17);
emit FUN14(VAR78);
}
function FUN46(uint VAR53)
public
VAR77
FUN32(VAR38.VAR55, VAR53)
{
VAR19 = VAR53;
emit FUN18(VAR53);
}
function FUN48(address VAR45, uint value, bytes VAR46)
public
returns (uint VAR16)
{
VAR16 = FUN49(VAR45, value, VAR46);
FUN50(VAR16);
}
function FUN50(uint VAR16)
public
ownerExists(msg.sender)
FUN30(VAR16)
notConfirmed(VAR16, msg.sender)
{
VAR33[VAR16][msg.sender] = true;
emit FUN8(msg.sender, VAR16);
FUN51(VAR16);
}
function FUN52(uint VAR16)
public
ownerExists(msg.sender)
confirmed(VAR16, msg.sender)
notExecuted(VAR16)
{
VAR33[VAR16][msg.sender] = false;
emit FUN9(msg.sender, VAR16);
}
function FUN51(uint VAR16)
public
notExecuted(VAR16)
{
if (FUN53(VAR16)) {
Transaction storage VAR79 = VAR32[VAR16];
VAR79.VAR47 = true;
if (VAR79.VAR45.call.value(VAR79.value)(VAR79.VAR46))
emit FUN11(VAR16);
else {
emit FUN12(VAR16);
VAR79.VAR47 = false;
}
}
}
function FUN53(uint VAR16)
public
constant
returns (bool)
{
uint VAR80 = 0;
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++) {
if (VAR33[VAR16][VAR38[VAR56]])
VAR80 += 1;
if (VAR80 == VAR19)
return true;
}
}
function FUN49(address VAR45, uint value, bytes VAR46)
internal
FUN31(VAR45)
returns (uint VAR16)
{
VAR16 = VAR40;
VAR32[VAR16] = Transaction({
VAR45: VAR45,
value: value,
VAR46: VAR46,
VAR47: false
});
VAR40 += 1;
emit FUN10(VAR16);
}
function FUN54(uint VAR16)
public
constant
returns (uint VAR80)
{
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR33[VAR16][VAR38[VAR56]])
VAR80 += 1;
}
function FUN55(bool VAR81, bool VAR47)
public
constant
returns (uint VAR80)
{
for (uint VAR56=0; VAR56<VAR40; VAR56++)
if (   VAR81 && !VAR32[VAR56].VAR47
|| VAR47 && VAR32[VAR56].VAR47)
VAR80 += 1;
}
function FUN56()
public
constant
returns (address[])
{
return VAR38;
}
function FUN57(uint VAR16)
public
constant
returns (address[] VAR82)
{
address[] memory VAR83 = new address[](VAR38.VAR55);
uint VAR80 = 0;
uint VAR56;
for (VAR56=0; VAR56<VAR38.VAR55; VAR56++)
if (VAR33[VAR16][VAR38[VAR56]]) {
VAR83[VAR80] = VAR38[VAR56];
VAR80 += 1;
}
VAR82 = new address[](VAR80);
for (VAR56=0; VAR56<VAR80; VAR56++)
VAR82[VAR56] = VAR83[VAR56];
}
function FUN58(uint VAR84, uint VAR85, bool VAR81, bool VAR47)
public
constant
returns (uint[] VAR86)
{
uint[] memory VAR87 = new uint[](VAR40);
uint VAR80 = 0;
uint VAR56;
for (VAR56=0; VAR56<VAR40; VAR56++)
if (   VAR81 && !VAR32[VAR56].VAR47
|| VAR47 && VAR32[VAR56].VAR47)
{
VAR87[VAR80] = VAR56;
VAR80 += 1;
}
VAR86 = new uint[](VAR85 - VAR84);
for (VAR56=VAR84; VAR56<VAR85; VAR56++)
VAR86[VAR56 - VAR84] = VAR87[VAR56];
}
function FUN59(address VAR18)
public
VAR60
FUN26(VAR18)
FUN31(VAR18)
{
VAR35[VAR18] = true;
VAR39.FUN44(VAR18);
VAR36[VAR18] = 0;
emit FUN16(VAR18);
}
function FUN60(address VAR18)
public
VAR60
FUN27(VAR18)
{
VAR35[VAR18] = false;
for (uint VAR56=0; VAR56 < VAR39.VAR55 - 1; VAR56++)
if (VAR39[VAR56] == VAR18) {
VAR39[VAR56] = VAR38[VAR39.VAR55 - 1];
break;
}
VAR39.VAR55 -= 1;
emit FUN17(VAR18);
}
function FUN61(uint VAR88, address VAR89) public
FUN27(msg.sender)
{
require(VAR35[msg.sender]);
require(VAR31.transfer(VAR89, VAR88));
}
function FUN62(address VAR90, uint VAR91)
public
VAR60
FUN27(VAR90)
{
VAR36[VAR90] = VAR91;
}
function FUN63(address VAR90)
public
view
returns (uint)
{
return VAR36[VAR90];
}
function FUN64()
public
VAR60
{
for (uint VAR56=0; VAR56 < VAR39.VAR55; VAR56++)
{
address VAR90 = VAR39[VAR56];
if ( VAR36[VAR90] > 0 )
{
FUN65(VAR90);
emit FUN22(VAR90);
}
}
}
function FUN66(address VAR90, uint VAR92)
public
VAR60
FUN27(VAR90)
{
require(VAR31.FUN3(VAR90, address(this), VAR92));
}
function FUN65(address VAR90)
public
VAR60
FUN27(VAR90)
{
uint VAR93 = VAR36[VAR90];
uint VAR94  = VAR31.FUN2(VAR90);
if (VAR94 <= VAR93)
{
uint VAR95  = VAR93.FUN67(VAR94);
require(FUN39(VAR95));
require(VAR31.transfer(VAR90, VAR95));
emit FUN23(VAR90, VAR95);
} else
{
uint VAR96 = VAR94.FUN67(VAR93);
require(VAR31.FUN3(VAR90, address(this), VAR96));
emit FUN24(VAR90, VAR96);
}
emit FUN22(VAR90);
}
function FUN68(uint VAR88) public
VAR77
{
require(FUN39(VAR88));
uint VAR21 = VAR97.FUN41(VAR88, VAR38.VAR55);
for (uint VAR56=0; VAR56<VAR38.VAR55; VAR56++) {
VAR31.transfer(VAR38[VAR56], VAR21);
}
emit FUN19(VAR88, VAR21);
}
function FUN69(address VAR98)
public
VAR60
{
VAR37 = VAR98;
}
function FUN70() public payable {
if (!VAR44) {
uint VAR99 = (address(this).VAR70.FUN67(VAR61));
if (VAR99 > 0.01 VAR71) {
VAR44 = true;
VAR31.VAR68.value(VAR99)(address(0x0), 33, "");
emit FUN21(VAR99);
VAR44 = false;
}
}
}
function FUN71(uint VAR100) public pure returns (uint) {
if (FUN72(VAR100) >= FUN72('') && FUN72(VAR100) <= FUN72('')) {
return VAR100 - uint(FUN72(''));
}
if (FUN72(VAR100) >= FUN72('') && FUN72(VAR100) <= FUN72('')) {
return 10 + VAR100 - uint(FUN72(''));
}
if (FUN72(VAR100) >= FUN72('') && FUN72(VAR100) <= FUN72('')) {
return 10 + VAR100 - uint(FUN72(''));
}
}
function FUN73(string VAR101) public pure returns (bytes) {
bytes memory VAR102 = bytes(VAR101);
require(VAR102.VAR55%2 == 0);
bytes memory VAR103 = VAR104 bytes(VAR102.VAR55/2);
for (uint VAR56=0; VAR56<VAR102.VAR55/2; ++VAR56) {
VAR103[VAR56] = FUN72(FUN71(uint(VAR102[2*VAR56])) * 16 +
FUN71(uint(VAR102[2*VAR56+1])));
}
return VAR103;
}
}
library VAR97 {
function FUN40(uint VAR105, uint VAR106) internal pure returns (uint) {
if (VAR105 == 0) {
return 0;
}
uint VAR100 = VAR105 * VAR106;
assert(VAR100 / VAR105 == VAR106);
return VAR100;
}
function FUN41(uint VAR105, uint VAR106) internal pure returns (uint) {
uint VAR100 = VAR105 / VAR106;
return VAR100;
}
function FUN67(uint VAR105, uint VAR106) internal pure returns (uint) {
assert(VAR106 <= VAR105);
return VAR105 - VAR106;
}
function FUN36(uint VAR105, uint VAR106) internal pure returns (uint) {
uint VAR100 = VAR105 + VAR106;
assert(VAR100 >= VAR105);
return VAR100;
}
}
1
---------------------------------
145 0x95d34980095380851902ccd9a1fb4c813c2cb639.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN1(address VAR7)
{
VAR6 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value >= VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
146 0x961fa070ef41c2b68d1a50905ea9198ef7dbfbf8.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) public returns(bool);
function FUN1() public view returns(uint256);
function FUN2(bool VAR5) public view returns(uint256);
function FUN3(address VAR6) public payable returns(uint256);
function FUN4() public;
function FUN5() public;
function() payable external;
}
contract VAR7 {
using SafeMath for *;
event Transfer (
address indexed VAR8,
address indexed VAR9,
uint256 VAR10
);
event FUN6 (
address indexed VAR11,
uint256 VAR10
);
event FUN7 (
address indexed VAR11,
uint256 VAR10
);
event FUN8 (
address indexed VAR11,
uint256 VAR10
);
event FUN9 (
address indexed VAR11,
uint256 VAR10
);
modifier VAR12 {
require(msg.sender == address(VAR13));
VAR14;
}
modifier FUN10() {
require(FUN11() > 0);
VAR14;
}
modifier FUN12() {
require(FUN13(msg.sender) > 0);
VAR14;
}
modifier FUN14(){
address VAR15 = msg.sender;
require(VAR16 == VAR15);
VAR14;
}
mapping(address => VAR17) internal VAR18;
uint256 internal VAR19 = 0;
Prosperity public VAR13;
address internal VAR16;
struct VAR17 {
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR16 = 0x28436C7453EbA01c6EcbC8a9cAa975f0ADE6Fff1;
}
function() payable external {
}
function FUN15(address VAR23, uint256 VAR24, bytes VAR25)
FUN16()
external
returns (bool)
{
Dealer storage VAR26 = VAR18[VAR23];
VAR26.VAR21 = FUN13(VAR23);
VAR26.VAR22 = VAR27;
VAR26.VAR20 = VAR26.VAR20.FUN17(VAR24);
VAR19 = VAR19.FUN17(VAR24);
emit FUN6(VAR23, VAR24);
return true;
VAR25;
}
function FUN18()
FUN12()
public
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR28 = FUN13(VAR15);
VAR26.VAR20 = VAR26.VAR20.FUN17(VAR28);
VAR26.VAR21 = 0;
VAR26.VAR22 = VAR27;
VAR19 = VAR19.FUN17(VAR28);
emit FUN7(VAR15, VAR28);
}
function FUN19()
FUN12()
public
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR28 = FUN13(VAR15);
VAR26.VAR21 = 0;
VAR26.VAR22 = VAR27;
VAR13.transfer(VAR15, VAR28);
emit FUN8(VAR15, VAR28);
}
function FUN20()
FUN10()
public
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR29 = VAR26.VAR20;
uint256 VAR30 = VAR29.FUN21(75).FUN22(100);
uint256 VAR28 = FUN13(VAR15);
VAR26.VAR20 = 0;
VAR26.VAR21 = VAR28;
VAR19 = VAR19.FUN23(VAR29);
VAR13.transfer(VAR15, VAR30);
emit FUN9(VAR15, VAR30);
}
function FUN24()
public
{
uint256 VAR31 = address(this).VAR32;
if (VAR31 > 0) {
if(!address(VAR13).call.value(VAR31)()) {
revert();
}
}
}
function FUN25()
public
{
uint256 VAR33 = FUN2(true);
if (VAR33 > 0) {
VAR13.FUN5();
}
}
function FUN26()
public
view
returns(uint256)
{
return VAR19;
}
function FUN27()
public
view
returns(uint256)
{
return VAR13.FUN1();
}
function FUN28()
public
view
returns(VAR34)
{
uint256 VAR35 = FUN27();
if (VAR19 > 0) {
return FUN29((1000).FUN21(VAR35).FUN22(VAR19) - 1000);
} else {
return 1000;
}
}
function FUN11()
public
view
returns(uint256)
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
return VAR26.VAR20;
}
function FUN13(address VAR15)
public
view
returns(uint256)
{
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR36 = VAR26.VAR21;
uint256 VAR37 = 0;
if (
VAR26.VAR22 == 0 ||
VAR26.VAR20 == 0
)
{
VAR37 = 0;
} else {
uint256 VAR38 = VAR27 - VAR26.VAR22;
VAR37 = VAR38
.FUN21(VAR26.VAR20)
.FUN21(1337)
.FUN22(100000)
.FUN22(86400);
}
return VAR37.FUN17(VAR36);
}
function FUN2(bool VAR5)
public
view
returns(uint256)
{
return VAR13.FUN2(VAR5);
}
function FUN30(address VAR39)
FUN14()
public
{
VAR13 = FUN31(VAR39);
}
}
library VAR40 {
function FUN21(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
if (VAR41 == 0) {
return 0;
}
uint256 VAR43 = VAR41 * VAR42;
assert(VAR43 / VAR41 == VAR42);
return VAR43;
}
function FUN22(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
uint256 VAR43 = VAR41 / VAR42;
return VAR43;
}
function FUN23(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
assert(VAR42 <= VAR41);
return VAR41 - VAR42;
}
function FUN17(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
uint256 VAR43 = VAR41 + VAR42;
assert(VAR43 >= VAR41);
return VAR43;
}
}
1
---------------------------------
147 0x9674d14af3ee5ddcd59d3bdca7435e11ba0ced18.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function FUN1(address VAR3) public payable returns(uint256);
function FUN2() public;
function FUN3(uint256 VAR4) public;
function FUN4() public;
function FUN5() public;
function FUN6(address VAR5) view public returns(uint256);
function FUN7(address VAR5) view public returns(uint256);
}
contract VAR6 {
event FUN8(
address VAR7,
uint256 VAR8,
uint256 VAR9,
uint256 VAR10
);
address internal VAR11;
Prosperity internal VAR12;
constructor()
public
{
VAR12 = FUN9(0xFf567f72F6BC585A3143E6852A2fF7DF26e5f455);
VAR11 = 0x1E2F082CB8fd71890777CA55Bd0Ce1299975B25f;
}
function() external payable {}
function FUN10(uint256 VAR13)
public
{
require(VAR13 > 0 && VAR13 < 100);
address VAR14 = msg.sender;
uint256 VAR15 = address(this).VAR16;
uint256 VAR17 = (VAR15 * (100 - VAR13)) / 100;
VAR12.VAR18.value(VAR15)(VAR11);
VAR12.FUN3(VAR12.FUN6(address(this)));
uint256 VAR19 = VAR12.FUN7(address(this));
while (VAR19 >= VAR17)
{
VAR12.FUN2();
VAR12.FUN3(VAR12.FUN6(address(this)));
VAR19 = (VAR19 * 64) / 100;
}
VAR12.FUN5();
emit FUN8(VAR14, VAR13, VAR15, address(this).VAR16);
}
}
1
---------------------------------
148 0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
struct VAR3
{
uint VAR4;
uint VAR5;
}
mapping (address => VAR3) public VAR6;
uint public VAR7;
LogFile VAR8;
bool VAR9;
function FUN1(uint VAR10)
public
{
if(VAR9)throw;
VAR7 = VAR10;
}
function FUN2(address VAR11)
public
{
if(VAR9)throw;
VAR8 = FUN3(VAR11);
}
function FUN4()
public
{
VAR9 = true;
}
function FUN5(uint VAR12)
public
payable
{
var VAR13 = VAR6[msg.sender];
VAR13.VAR5 += msg.value;
if(VAR14+VAR12>VAR13.VAR4)VAR13.VAR4=VAR14+VAR12;
VAR8.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR15)
public
payable
{
var VAR13 = VAR6[msg.sender];
if( VAR13.VAR5>=VAR7 && VAR13.VAR5>=VAR15 && VAR14>VAR13.VAR4)
{
if(msg.sender.call.value(VAR15)())
{
VAR13.VAR5-=VAR15;
VAR8.FUN6(msg.sender,VAR15,"");
}
}
}
function()
public
payable
{
FUN5(0);
}
}
contract VAR16
{
struct VAR17
{
address VAR18;
string  VAR19;
uint VAR20;
uint  VAR21;
}
VAR17[] public VAR22;
Message VAR23;
function FUN6(address VAR24,uint VAR10,string VAR25)
public
{
VAR23.VAR18 = VAR24;
VAR23.VAR21 = VAR14;
VAR23.VAR20 = VAR10;
VAR23.VAR19 = VAR25;
VAR22.FUN8(VAR23);
}
}
1
---------------------------------
149 0x97354a7281693b7c93f6348ba4ec38b9ddd76d6e.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(address VAR3) external payable returns (bool);
function FUN2() external returns (bool);
}
contract VAR4 {
string public VAR5 = "";
ProForwarderInterface private VAR6;
address private VAR7;
bool VAR8 = true;
constructor() public {
}
function() public payable {
VAR6.VAR9.value(address(this).VAR10)(address(VAR6));
}
function FUN1() public payable returns(bool) {
require(msg.value > 0, "");
require(VAR8 == false, "");
if (VAR6.VAR9.value(msg.value)(msg.sender) == true)
return(true);
else
return(false);
}
function FUN3() public view returns(address, address, bool) {
return(address(VAR6), address(VAR7), VAR8);
}
function FUN4(address VAR11) external returns(bool) {
require(msg.sender == address(VAR6), "");
if(FUN5(VAR11).FUN2() == true)
{
VAR7 = VAR11;
return (true);
} else
return (false);
}
function FUN6() external returns(bool) {
require(msg.sender == address(VAR6), "");
VAR7 = address(0x0);
return (true);
}
function FUN7() external returns(bool) {
require(msg.sender == VAR7, "");
VAR6 = (FUN5(VAR7));
VAR7 = address(0x0);
return (true);
}
function FUN8(address VAR12) external {
require(VAR8 == true, "");
VAR6 = FUN5(VAR12);
VAR8 = false;
}
}
1
---------------------------------
150 0x9798d857476de56c066abb4f8395e8f061893bac.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function FUN1() external payable;
}
contract VAR3 {
event FUN2 (
address indexed VAR4,
uint256 value,
uint256 VAR5,
address indexed VAR6
);
event FUN3 (
address indexed VAR4,
uint256 value,
uint256 VAR5
);
event FUN4 (
address indexed VAR4,
uint256 value,
uint256 VAR5
);
event FUN5 (
uint256 value,
uint256 VAR5
);
address VAR7;
mapping(address => uint256) public VAR8;
modifier onlyOwner {
require(msg.sender == VAR7);
VAR9;
}
constructor() public {
VAR7 = msg.sender;
}
function FUN6(address VAR4, address VAR6) public payable {
require(msg.value > 0);
VAR8[VAR4] += msg.value;
emit FUN2(VAR4, msg.value, VAR10, VAR6);
}
function FUN7() public {
require(VAR8[msg.sender] > 0);
uint256 value = VAR8[msg.sender];
VAR8[msg.sender] = 0;
msg.sender.transfer(value);
emit FUN3(msg.sender, value, VAR10);
}
function FUN8(address VAR4) onlyOwner public {
require(VAR8[VAR4] > 0);
uint256 value = VAR8[VAR4];
VAR8[VAR4] = 0;
VAR7.transfer(value);
emit FUN4(VAR4, value, VAR10);
}
function FUN9() onlyOwner public {
uint256 VAR11 = address(this).VAR11;
VAR7.transfer(VAR11);
emit FUN5(VAR11, VAR10);
}
}
contract VAR12 {
event FUN10 (
address indexed VAR6,
address indexed VAR4,
uint256 indexed VAR5,
uint256 value,
uint256 VAR13,
uint256 VAR14,
uint256 VAR15,
uint256 VAR16
);
event FUN3 (
address indexed VAR17,
uint256 value
);
event FUN11 (
address indexed VAR6,
uint256 value
);
event FUN12 (
address indexed VAR6,
uint256 value,
uint8 VAR18,
uint256 VAR13,
uint256 VAR16,
uint256 VAR19
);
event FUN13 (
uint256 value
);
event FUN14 (
uint256 value
);
event FUN15 (
address indexed VAR20,
uint256 value
);
event FUN16 (
uint256 value
);
event FUN17 (
uint256 value
);
event FUN18 (
address indexed VAR4,
uint256 value,
uint256 VAR5,
address indexed VAR6,
address indexed VAR21
);
event FUN19 (
address VAR22,
uint256 VAR5
);
event FUN20 (
address indexed VAR23,
uint256 value,
uint256 VAR5
);
string constant public VAR24 = "";
string constant public VAR25 = "";
address public VAR7;
address constant internal VAR26 = 0x42cF5e102dECCf8d89E525151c5D5bbEAc54200d;
address constant internal VAR27 = 0x8D86E611ef0c054FdF04E1c744A8cEFc37F00F81;
NeutrinoTokenStandard constant internal VAR28 = FUN21(0xad0a61589f3559026F00888027beAc31A5Ac4625);
ReferralPayStation public VAR29 = FUN22(0x4100dAdA0D80931008a5f7F5711FFEb60A8071BA);
uint256 constant public VAR30 = 0.1 VAR31;
uint256 public VAR32;
uint256 public VAR33;
uint8 constant VAR34 = 10;
uint8 constant VAR35 = 2;
uint8 constant VAR36 = 8;
uint8 constant VAR37 = 5;
mapping(address => uint256) public VAR38;
uint256 public VAR39 = 0;
uint256 public VAR40 = 0;
uint256 public VAR41 = 0;
uint256 public VAR42 = 0;
uint256 public VAR43 = 0;
modifier onlyOwner {
require(msg.sender == VAR7);
VAR9;
}
constructor(uint256 VAR44, uint256 VAR45) public payable {
VAR7 = msg.sender;
VAR43 = msg.value;
VAR32 = VAR44;
VAR33 = VAR45;
}
function() public payable {
emit FUN15(msg.sender, msg.value);
}
function FUN23() public view returns (bool) {
return VAR10 >= VAR32 && VAR10 <= VAR33;
}
function FUN24(uint256 VAR13, address VAR4) public payable {
require(VAR10 >= VAR32 && VAR10 <= VAR33);
uint256 value = (msg.value / VAR30) * VAR30;
uint256 VAR14 = msg.value - value;
require(value > 0);
VAR41 += VAR14;
uint8 VAR46 = VAR34 + VAR35 + VAR37;
uint256 VAR15 = 0;
if (VAR4 != 0x0) {
VAR46 += VAR36;
VAR15 = value * VAR36 / 100;
VAR29.VAR47.value(VAR15)(VAR4, msg.sender);
emit FUN18(VAR4, VAR15, VAR10, msg.sender, address(VAR29));
}
uint256 VAR48 = value - value * VAR46 / 100;
VAR43 += VAR48;
VAR40 += value * VAR34 / 100;
VAR41 += value * VAR35 / 100;
VAR42 += value * VAR37 / 100;
emit FUN10(msg.sender, VAR4, VAR49.VAR5, value, VAR13, VAR14, VAR15, value / VAR30);
}
function FUN25() public {
require(VAR38[msg.sender] > 0);
uint256 value = VAR38[msg.sender];
VAR38[msg.sender] = 0;
VAR39 -= value;
msg.sender.transfer(value);
emit FUN11(msg.sender, value);
}
function FUN26(address VAR6, uint256 value, uint8 VAR18, uint256 VAR13, uint256 VAR16, uint256 VAR19) onlyOwner public {
require(value <= VAR43);
VAR38[VAR6] += value;
VAR39 += value;
VAR43 -= value;
emit FUN12(VAR6, value, VAR18, VAR13, VAR16, VAR19);
}
function FUN27(address VAR4, address VAR6, uint256 value) onlyOwner public {
require(value <= VAR43);
VAR43 -= value;
VAR29.VAR47.value(value)(VAR4, VAR6);
emit FUN18(VAR4, value, VAR10, VAR6, address(VAR29));
}
function FUN28(uint256 value) onlyOwner public {
require(value <= VAR40);
if (value == 0) value = VAR40;
uint256 VAR50 = value * 90 / 100;
uint256 VAR51 = value * 10 / 100;
if (VAR26.FUN29(VAR50)) {
VAR40 -= VAR50;
emit FUN20(VAR26, VAR50, VAR10);
}
if (VAR27.FUN29(VAR51)) {
VAR40 -= VAR51;
emit FUN20(VAR27, VAR51, VAR10);
}
}
function FUN30() onlyOwner public {
require(VAR42 > 0);
uint256 VAR52 = VAR42;
VAR28.VAR53.value(VAR42)();
VAR42 = 0;
emit FUN13(VAR52);
}
function FUN31(address VAR54) onlyOwner public {
require(VAR41 > 0);
if (VAR54.call.value(VAR41).FUN32(50000)()) {
VAR41 = 0;
emit FUN14(VAR41);
}
}
function FUN33() onlyOwner public {
uint256 VAR55 = VAR39 + VAR40 + VAR41 + VAR42 + VAR43;
uint256 VAR56 = address(this).VAR11 - VAR55;
require(VAR56 > 0);
VAR40 += VAR56;
emit FUN16(VAR56);
}
function FUN34() onlyOwner public {
uint256 VAR55 = VAR39 + VAR40 + VAR41 + VAR42 + VAR43;
uint256 VAR56 = address(this).VAR11 - VAR55;
require(VAR56 > 0);
VAR43 += VAR56;
emit FUN17(VAR56);
}
function FUN35(address VAR22) onlyOwner public {
VAR29 = FUN22(VAR22);
emit FUN19(VAR22, VAR10);
}
}
1
---------------------------------
151 0x97ee19d8c8b2d607af236d8beddf9f45aca99585.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
using SafeMathLib for uint;
FractionalERC20 public VAR31;
PricingStrategy public VAR32;
FinalizeAgent public VAR33;
address public VAR34;
uint public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR38 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
bool public VAR41;
bool public VAR42;
bool public VAR43;
address public VAR44;
mapping (address => uint256) public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => bool) public VAR47;
uint public VAR48;
enum VAR49{VAR50, VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57}
event FUN26(address VAR58, uint VAR59, uint VAR21, uint128 VAR60);
event FUN27(address VAR58, uint VAR59);
event FUN28(bool VAR42, bool VAR43, address VAR44);
event FUN29(address VAR61, bool VAR62);
event FUN30(uint VAR37);
function FUN31(address VAR63, PricingStrategy VAR64, address VAR65, uint VAR66, uint VAR67, uint VAR68) {
VAR9 = msg.sender;
VAR31 = FUN32(VAR63);
FUN33(VAR64);
VAR34 = VAR65;
if(VAR34 == 0) {
throw;
}
if(VAR66 == 0) {
throw;
}
VAR36 = VAR66;
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR36 >= VAR37) {
throw;
}
VAR35 = VAR68;
}
function() payable {
throw;
}
function FUN34(address VAR69, uint128 VAR60) stopInEmergency private {
if(FUN35() == VAR49.VAR52) {
if(!VAR47[VAR69]) {
throw;
}
} else if(FUN35() == VAR49.VAR53) {
} else {
throw;
}
uint VAR59 = msg.value;
uint VAR21 = VAR32.FUN18(VAR59, VAR17, VAR18, msg.sender, VAR31.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR45[VAR69] == 0) {
VAR38++;
}
VAR45[VAR69] = VAR45[VAR69].FUN11(VAR59);
VAR46[VAR69] = VAR46[VAR69].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR59);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR59, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR69, VAR21);
if(!VAR34.FUN39(VAR59)) throw;
FUN26(VAR69, VAR59, VAR21, VAR60);
}
function FUN40(address VAR69, uint VAR70, uint VAR71) public onlyOwner {
uint VAR21 = VAR70 * 10**VAR31.FUN36();
uint VAR59 = VAR71 * VAR70;
VAR17 = VAR17.FUN11(VAR59);
VAR18 = VAR18.FUN11(VAR21);
VAR45[VAR69] = VAR45[VAR69].FUN11(VAR59);
VAR46[VAR69] = VAR46[VAR69].FUN11(VAR21);
FUN38(VAR69, VAR21);
FUN26(VAR69, VAR59, VAR21, 0);
}
function FUN41(address VAR61, uint128 VAR60, uint8 VAR72, bytes32 VAR73, bytes32 VAR74) public payable {
bytes32 VAR75 = FUN42(VAR61);
if (FUN43(VAR75, VAR72, VAR73, VAR74) != VAR44) throw;
if(VAR60 == 0) throw;
FUN34(VAR61, VAR60);
}
function FUN44(address VAR61, uint128 VAR60) public payable {
if(VAR43) throw;
if(VAR60 == 0) throw;
FUN34(VAR61, VAR60);
}
function FUN45(address VAR61) public payable {
if(VAR42) throw;
if(VAR43) throw;
FUN34(VAR61, 0);
}
function FUN46(uint128 VAR60, uint8 VAR72, bytes32 VAR73, bytes32 VAR74) public payable {
FUN41(msg.sender, VAR60, VAR72, VAR73, VAR74);
}
function FUN47(uint128 VAR60) public payable {
FUN44(msg.sender, VAR60);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR49.VAR54) onlyOwner VAR13 {
if(VAR41) {
throw;
}
if(address(VAR33) != 0) {
VAR33.FUN20();
}
VAR41 = true;
}
function FUN51(FinalizeAgent VAR61) onlyOwner {
VAR33 = VAR61;
if(!VAR33.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR42 = value;
FUN28(VAR42, VAR43, VAR44);
}
function FUN53(bool value, address VAR76) onlyOwner {
VAR43 = value;
VAR44 = VAR76;
FUN28(VAR42, VAR43, VAR44);
}
function FUN54(address VAR61, bool VAR62) onlyOwner {
VAR47[VAR61] = VAR62;
FUN29(VAR61, VAR62);
}
function FUN55(uint VAR77) onlyOwner {
if(VAR78 > VAR77) {
throw;
}
VAR37 = VAR77;
FUN30(VAR37);
}
function FUN33(PricingStrategy VAR64) onlyOwner {
VAR32 = VAR64;
if(!VAR32.FUN16()) {
throw;
}
}
function FUN56() public payable FUN50(VAR49.VAR55) {
if(msg.value == 0) throw;
VAR39 = VAR39.FUN11(msg.value);
}
function FUN57() public FUN50(VAR49.VAR57) {
uint256 VAR79 = VAR45[msg.sender];
if (VAR79 == 0) throw;
VAR45[msg.sender] = 0;
VAR40 = VAR40.FUN11(VAR79);
FUN27(msg.sender, VAR79);
if (!msg.sender.FUN39(VAR79)) throw;
}
function FUN58() public constant returns (bool VAR80) {
return VAR17 >= VAR35;
}
function FUN59() public constant returns (bool VAR81) {
return VAR33.FUN17();
}
function FUN60() public constant returns (bool VAR81) {
return VAR32.FUN17(address(this));
}
function FUN35() public constant returns (VAR49) {
if(VAR41) return VAR49.VAR56;
else if (address(VAR33) == 0) return VAR49.VAR51;
else if (!VAR33.FUN17()) return VAR49.VAR51;
else if (!VAR32.FUN17(address(this))) return VAR49.VAR51;
else if (VAR82.VAR83 < VAR36) return VAR49.VAR52;
else if (VAR82.VAR83 <= VAR37 && !FUN61()) return VAR49.VAR53;
else if (FUN58()) return VAR49.VAR54;
else if (!FUN58() && VAR17 > 0 && VAR39 >= VAR17) return VAR49.VAR57;
else return VAR49.VAR55;
}
function FUN62(uint VAR84) onlyOwner {
VAR48 = VAR84;
}
function FUN63() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR85) {
if(FUN35() != VAR85) throw;
VAR10;
}
//
//
function FUN37(uint VAR59, uint VAR21, uint VAR86, uint VAR87) constant returns (bool VAR88);
function FUN61() public constant returns (bool);
function FUN38(address VAR69, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN64(address VAR69, uint VAR89);
mapping(address => uint) VAR90;
mapping (address => mapping (address => uint)) VAR91;
modifier FUN65(uint VAR92) {
if(msg.VAR93.VAR94 != VAR92 + 4) {
throw;
}
VAR10;
}
function transfer(address VAR95, uint VAR96) FUN65(2 * 32) returns (bool VAR97) {
VAR90[msg.sender] = FUN3(VAR90[msg.sender], VAR96);
VAR90[VAR95] = FUN4(VAR90[VAR95], VAR96);
Transfer(msg.sender, VAR95, VAR96);
return true;
}
function FUN23(address VAR98, address VAR95, uint VAR96) returns (bool VAR97) {
uint VAR99 = VAR91[VAR98][msg.sender];
VAR90[VAR95] = FUN4(VAR90[VAR95], VAR96);
VAR90[VAR98] = FUN3(VAR90[VAR98], VAR96);
VAR91[VAR98][msg.sender] = FUN3(VAR99, VAR96);
Transfer(VAR98, VAR95, VAR96);
return true;
}
function FUN21(address VAR100) constant returns (uint VAR101) {
return VAR90[VAR100];
}
function FUN24(address VAR102, uint VAR96) returns (bool VAR97) {
if ((VAR96 != 0) && (VAR91[msg.sender][VAR102] != 0)) throw;
VAR91[msg.sender][VAR102] = VAR96;
FUN25(msg.sender, VAR102, VAR96);
return true;
}
function FUN22(address VAR100, address VAR102) constant returns (uint VAR103) {
return VAR91[VAR100][VAR102];
}
function FUN66(address VAR102, uint VAR104)
FUN65(2 * 32)
returns (bool VAR97) {
uint VAR105 = VAR91[msg.sender][VAR102];
VAR91[msg.sender][VAR102] = FUN4(VAR105, VAR104);
FUN25(msg.sender, VAR102, VAR91[msg.sender][VAR102]);
return true;
}
function FUN67(address VAR102, uint VAR106)
FUN65(2 * 32)
returns (bool VAR97) {
uint VAR107 = VAR91[msg.sender][VAR102];
if (VAR106 > VAR107) {
VAR91[msg.sender][VAR102] = 0;
} else {
VAR91[msg.sender][VAR102] = FUN3(VAR107, VAR106);
}
FUN25(msg.sender, VAR102, VAR91[msg.sender][VAR102]);
return true;
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR38;
uint public VAR86;
address[] public VAR108;
mapping(address => uint) public VAR90;
mapping(address => uint) public VAR109;
uint public VAR110;
uint public VAR111;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
Crowdsale public VAR16;
enum VAR49{VAR50, VAR53, VAR116, VAR57}
event FUN26(address VAR58, uint value);
event FUN68(address VAR58, uint value);
event FUN69(uint VAR117);
event FUN70(address VAR108, uint VAR117);
function FUN71(address VAR100, uint VAR118, uint VAR119, uint VAR120) {
VAR9 = VAR100;
if(VAR118 == 0) {
throw;
}
if(VAR119 == 0) {
throw;
}
VAR111 = VAR119;
VAR112 = VAR120;
VAR110 = VAR118;
}
function FUN72() public constant returns(VAR121) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN73();
}
function FUN45() public stopInEmergency payable {
if(FUN35() != VAR49.VAR53) throw;
if(msg.value == 0) throw;
address VAR58 = msg.sender;
bool VAR122 = VAR90[VAR58] > 0;
VAR90[VAR58] = FUN4(VAR90[VAR58], msg.value);
if(VAR90[VAR58] < VAR111) {
throw;
}
if(!VAR122) {
VAR108.FUN74(VAR58);
VAR38++;
}
VAR86 = FUN4(VAR86, msg.value);
if(VAR86 > VAR112) {
throw;
}
FUN26(VAR58, msg.value);
}
function FUN75() stopInEmergency public {
if(FUN35() != VAR49.VAR53) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR123.value(VAR86)(address(this));
VAR113 = FUN72().FUN21(address(this));
if(VAR113 == 0) {
throw;
}
FUN69(VAR113);
}
function FUN76(address VAR58) public constant returns (uint) {
if(FUN35() != VAR49.VAR116) {
throw;
}
return FUN1(VAR90[VAR58], VAR113) / VAR86;
}
function FUN77(address VAR58) public constant returns (uint) {
return FUN3(FUN76(VAR58), VAR109[VAR58]);
}
function FUN78() {
FUN79(FUN77(msg.sender));
}
function FUN79(uint VAR89) VAR13 {
address VAR58 = msg.sender;
if(VAR89 == 0) {
throw;
}
if(FUN77(VAR58) < VAR89) {
throw;
}
if(VAR109[VAR58] == 0) {
VAR114++;
}
VAR109[VAR58] = FUN4(VAR109[VAR58], VAR89);
VAR115 = FUN4(VAR115, VAR89);
FUN72().transfer(VAR58, VAR89);
FUN70(VAR58, VAR89);
}
function FUN57() VAR13 {
if(FUN35() != VAR49.VAR57) throw;
address VAR58 = msg.sender;
if(VAR90[VAR58] == 0) throw;
uint VAR89 = VAR90[VAR58];
delete VAR90[VAR58];
if(!VAR58.FUN39(VAR89)) throw;
FUN68(VAR58, VAR89);
}
function FUN80(Crowdsale VAR124) public onlyOwner {
VAR16 = VAR124;
if(!VAR16.FUN63()) true;
}
function FUN35() public returns(VAR49) {
if(VAR113 == 0) {
if(VAR78 >= VAR110) {
return VAR49.VAR57;
} else {
return VAR49.VAR53;
}
} else {
return VAR49.VAR116;
}
}
function() payable {
throw;
}
}
1
---------------------------------
152 0x989eb9629225b8c06997ef0577cc08535fd789f9.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR10);
constructor() public {
VAR7 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR11;
}
function FUN6(address VAR12) public onlyOwner {
VAR8 = VAR12;
}
function FUN7() public {
require(msg.sender == VAR8);
emit FUN5(VAR7, VAR8);
VAR7 = VAR8;
VAR8 = address(0);
}
}
interface VAR13  {
function() payable external;
function FUN8() external  payable;
}
interface VAR14  {
function() payable external;
function FUN9(address VAR15) payable external returns(uint256);
function FUN10(uint256 VAR16) external;
function FUN11() external;
function FUN12() external;
function FUN13() external;
function FUN14(address VAR15) external view returns(uint256);
function FUN15(address VAR15) external view returns(uint256);
function transfer(address VAR17, uint256 VAR16) external returns(bool);
function FUN16() external view returns(uint256);
}
contract P3DRaffle is  VAR6 {
using SafeMath for uint;
HourglassInterface constant VAR18 = FUN17(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
function FUN18()
view
public
returns(uint256)
{
return ( VAR18.FUN14(address(this)))  ;
}
function FUN19(uint256 VAR19)
view
public
returns(uint256 VAR20,    uint256 VAR21,
uint256 VAR22,
uint256 VAR23,
bool VAR24,
bool VAR25,
address VAR26 )
{
return (VAR27[VAR19].VAR20,    VAR27[VAR19].VAR21,
VAR27[VAR19].VAR22,
VAR27[VAR19].VAR23,
VAR27[VAR19].VAR24,
VAR27[VAR19].VAR25,
VAR27[VAR19].VAR26
)  ;
}
function FUN20(address VAR28) view public returns(string)
{
return VAR29[VAR28];
}
function FUN21() view public returns(uint256)
{
return VAR30;
}
function FUN22() view public returns(uint256)
{
return (VAR31);
}
function FUN23() view public returns(uint256)
{
return (VAR32);
}
function FUN24() pure public returns(uint256 VAR33, uint256 VAR34)
{
return (VAR33, VAR34);
}
struct VAR35 {
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
uint256 VAR23;
bool VAR24;
bool VAR25;
address VAR26;
}
uint256 public VAR31;
uint256 public VAR32;
mapping(uint256 => address) public VAR36;
mapping(uint256 => VAR35) public VAR27;
mapping(address => string) public VAR29;
uint256 public VAR33;
uint256 public VAR34;
uint256 public VAR30;
SPASMInterface constant VAR37 = FUN25(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
constructor() public{
VAR27[0].VAR24 = true;
VAR32++;
}
function FUN26(uint256 VAR38 ,address VAR39) public payable{
require(msg.value >= 10 VAR40 * VAR38);
require(VAR38 > 0);
uint256 VAR41;
address sender  = msg.sender;
for(uint VAR42=0; VAR42< VAR38; VAR42++)
{
VAR41 = VAR42 + VAR31;
VAR36[VAR41] = sender;
}
VAR31 += VAR42;
VAR18.VAR43.value(msg.value)(VAR39);
}
function FUN27 () public{
uint256 VAR44 = FUN18();
uint256 VAR45 = VAR44.FUN4(100);
VAR33 = VAR33.FUN1(VAR45.FUN3(90));
VAR34 = VAR34.FUN1(VAR45.FUN3(9));
VAR30 = VAR30.FUN1(VAR45);
VAR18.FUN12();
}
function FUN28 () public {
VAR37.VAR46.value(VAR30)();
VAR30 = 0;
}
function FUN29(string VAR47) public payable{
require(msg.value >= 100  VAR40);
VAR29[msg.sender] = VAR47;
VAR33 = VAR33.FUN1(msg.value);
}
function FUN30 () public{
require(VAR27[VAR32 - 1].VAR24 == true);
require(VAR33 >= 103 VAR40);
VAR27[VAR32].VAR20 = VAR48.VAR49;
VAR27[VAR32].VAR21 = VAR31;
VAR32++;
}
function FUN31 () public{
uint256 VAR50 = VAR32 - 1;
bool VAR51 = VAR27[VAR50].VAR24;
uint256 VAR20 = VAR27[VAR50].VAR20;
require(VAR51 != true);
require(VAR20 < VAR48.VAR49);
if(VAR48.VAR49 - 256 > VAR20) {
VAR27[VAR50].VAR24 = true;
VAR27[VAR50].VAR25 = false;
}
if(VAR48.VAR49 - 256 <= VAR20) {
uint256 VAR52 = uint256(FUN32(VAR20)) % VAR27[VAR50].VAR21;
uint256 VAR53 = uint256(FUN32(VAR20)) % 1000;
address VAR54 = VAR36[VAR52];
VAR27[VAR50].VAR24 = true;
VAR27[VAR50].VAR25 = true;
VAR27[VAR50].VAR22 = VAR52;
VAR27[VAR50].VAR23 = VAR53;
VAR27[VAR50].VAR26 = VAR54;
if(VAR53 == 777){
VAR54.transfer(VAR34);
VAR34 = 0;
}
VAR54.transfer(100 VAR40);
msg.sender.transfer(3 VAR40);
VAR33 = VAR33.FUN2(103 VAR40);
}
}
function () external payable{}
function FUN33 () public onlyOwner {
if(address(this).VAR55.FUN2(VAR33).FUN2(VAR34).FUN2(VAR30) > 0)
{
VAR33 = address(this).VAR55.FUN2(VAR34).FUN2(VAR30);
}
}
}
1
---------------------------------
153 0x99b001735036d937b4a11c17a9a44f86fbddf4d0.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5() public view returns (uint256);
function FUN6(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 VAR9) public returns (bool);
event Transfer(address indexed VAR10, address indexed VAR11, uint256 value);
}
contract ERC20 is VAR6 {
function FUN7(address VAR12, address VAR13)
public view returns (uint256);
function FUN8(address VAR14, address VAR8, uint256 VAR9)
public returns (bool);
function FUN9(address VAR13, uint256 VAR9) public returns (bool);
event FUN10(
address indexed VAR15,
address indexed VAR16,
uint256 value
);
}
contract IBasicMultiToken is VAR17 {
event FUN11(address indexed VAR18, address indexed VAR19, uint256 value);
event FUN12(address indexed VAR18, address indexed VAR19, uint256 value);
VAR17[] public VAR20;
function FUN13() public view returns(uint256);
function FUN14(address VAR21, uint256 VAR22, uint256[] VAR23) public;
function FUN15(address VAR21, uint256 VAR22) public;
function FUN16(address VAR21, uint256 VAR9) public;
function FUN17(address VAR21, uint256 VAR9, VAR17[] VAR24) public;
function FUN18() public;
function FUN19() public;
}
contract IMultiToken is VAR25 {
event FUN20();
event FUN21(address indexed VAR26, address indexed VAR27, address indexed VAR28, uint256 VAR22, uint256 VAR29);
mapping(address => uint256) public VAR30;
function FUN22(address VAR26, address VAR27, uint256 VAR22) public view returns (uint256 VAR31);
function FUN23(address VAR26, address VAR27, uint256 VAR22, uint256 VAR32) public returns (uint256 VAR31);
function FUN24() public;
}
library VAR33 {
using SafeMath for uint;
function FUN25(address VAR34) internal view returns(bool VAR35) {
VAR36 {
VAR35 := FUN26(FUN27(VAR34), 0)
}
}
function FUN28() internal pure returns(bool VAR35) {
VAR36 {
switch FUN29()
case 0 {
VAR35 := 1
}
case 32 {
FUN30(0, 0, 32)
VAR35 := FUN31(0)
}
default {
revert(0, 0)
}
}
}
function FUN32() internal pure returns(bytes32 VAR35) {
VAR36 {
if FUN33(FUN29(), 32) {
FUN30(0, 0, 32)
VAR35 := FUN31(0)
}
if FUN26(FUN29(), 32) {
FUN30(0, 64, 32)
VAR35 := FUN31(0)
}
if FUN34(FUN29(), 32) {
revert(0, 0)
}
}
}
function FUN35(address VAR37, address VAR8, uint256 VAR9) internal returns(bool) {
require(FUN25(VAR37));
require(VAR37.call(bytes4(FUN36("")), VAR8, VAR9));
return FUN28();
}
function FUN37(address VAR37, address VAR14, address VAR8, uint256 VAR9) internal returns(bool) {
require(FUN25(VAR37));
require(VAR37.call(bytes4(FUN36("")), VAR14, VAR8, VAR9));
return FUN28();
}
function FUN38(address VAR37, address VAR13, uint256 VAR9) internal returns(bool) {
require(FUN25(VAR37));
require(VAR37.call(bytes4(FUN36("")), VAR13, VAR9));
return FUN28();
}
//
function FUN39(ERC20 VAR37, address VAR8, uint256 VAR9) internal {
if (VAR9 > 0) {
uint256 VAR38 = VAR37.FUN6(this);
FUN35(VAR37, VAR8, VAR9);
require(VAR37.FUN6(this) == VAR38.FUN3(VAR9), "");
}
}
function FUN40(ERC20 VAR37, address VAR14, address VAR8, uint256 VAR9) internal {
if (VAR9 > 0) {
uint256 VAR39 = VAR37.FUN6(VAR8);
FUN37(VAR37, VAR14, VAR8, VAR9);
require(VAR37.FUN6(VAR8) == VAR39.FUN4(VAR9), "");
}
}
//
function FUN41(address VAR37) internal view returns(bytes32) {
require(FUN25(VAR37));
require(VAR37.call(bytes4(FUN36(""))));
return FUN32();
}
function FUN42(address VAR37) internal view returns(bytes32) {
require(FUN25(VAR37));
require(VAR37.call(bytes4(FUN36(""))));
return FUN32();
}
}
contract VAR40 {
address public VAR15;
event FUN43(address indexed VAR41);
event FUN44(
address indexed VAR41,
address indexed VAR42
);
constructor() public {
VAR15 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR43;
}
function FUN45() public onlyOwner {
emit FUN43(VAR15);
VAR15 = address(0);
}
function FUN46(address VAR44) public onlyOwner {
FUN47(VAR44);
}
function FUN47(address VAR44) internal {
require(VAR44 != address(0));
emit FUN44(VAR15, VAR44);
VAR15 = VAR44;
}
}
library VAR45 {
function FUN48(
ERC20Basic VAR37,
address VAR8,
uint256 VAR9
)
internal
{
require(VAR37.transfer(VAR8, VAR9));
}
function FUN49(
ERC20 VAR37,
address VAR14,
address VAR8,
uint256 VAR9
)
internal
{
require(VAR37.FUN8(VAR14, VAR8, VAR9));
}
function FUN50(
ERC20 VAR37,
address VAR13,
uint256 VAR9
)
internal
{
require(VAR37.FUN9(VAR13, VAR9));
}
}
contract CanReclaimToken is VAR40 {
using SafeERC20 for VAR6;
function FUN51(ERC20Basic VAR37) external onlyOwner {
uint256 VAR38 = VAR37.FUN6(this);
VAR37.FUN48(VAR15, VAR38);
}
}
contract IEtherToken is VAR17 {
function FUN52() public payable;
function FUN53(uint256 VAR22) public;
}
contract VAR46 {
function FUN54(
address[] VAR47,
uint256 VAR22,
uint256 VAR32
)
public
payable
returns(uint256);
function FUN55(
address[] VAR47,
uint256 VAR22,
uint256 VAR32
)
public
payable
returns(uint256);
}
contract VAR48 {
function FUN56(
address VAR49,
uint VAR50,
address VAR51,
address VAR52,
uint VAR53,
uint VAR54,
address VAR55
)
public
payable
returns(uint);
}
contract MultiChanger is VAR56 {
using SafeMath for uint256;
using CheckedERC20 for VAR17;
function FUN57(address VAR57, uint value, bytes VAR58, uint VAR59, uint VAR60) internal returns (bool VAR35) {
VAR36 {
let VAR61 := FUN31(0x40)
let VAR62 := FUN4(VAR58, 32)
VAR35 := call(
FUN3(VAR63, 34710),
VAR57,
value,
FUN4(VAR62, VAR59),
VAR60,
VAR61,
0
)
}
}
function FUN23(bytes VAR64, uint[] VAR65) public payable {
for (uint VAR66 = 0; VAR66 < VAR65.VAR67 - 1; VAR66++) {
require(FUN57(this, 0, VAR64, VAR65[VAR66], VAR65[VAR66 + 1] - VAR65[VAR66]));
}
}
function FUN58(address VAR68, bytes VAR69, uint256 VAR9) external {
require(VAR68.call.value(VAR9)(VAR69));
}
function FUN59(address VAR68, bytes VAR69, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR38.FUN1(VAR70).FUN2(VAR71);
require(VAR68.call.value(value)(VAR69));
}
function FUN60(address VAR68, bytes VAR69, ERC20 VAR26, uint256 VAR22) external {
if (VAR26.FUN7(this, VAR68) != 0) {
VAR26.FUN38(VAR68, 0);
}
VAR26.FUN38(VAR68, VAR22);
require(VAR68.call(VAR69));
}
function FUN61(address VAR68, bytes VAR69, ERC20 VAR26, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR26.FUN6(this).FUN1(VAR70).FUN2(VAR71);
if (VAR26.FUN7(this, VAR68) != 0) {
VAR26.FUN38(VAR68, 0);
}
VAR26.FUN38(VAR68, VAR72);
require(VAR68.call(VAR69));
}
function FUN62(address VAR68, bytes VAR69, ERC20 VAR26, uint256 VAR22) external {
VAR26.FUN35(VAR68, VAR22);
if (VAR68 != address(0)) {
require(VAR68.call(VAR69));
}
}
function FUN63(address VAR68, bytes VAR69, ERC20 VAR26, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR26.FUN6(this).FUN1(VAR70).FUN2(VAR71);
VAR26.FUN35(VAR68, VAR72);
if (VAR68 != address(0)) {
require(VAR68.call(VAR69));
}
}
function FUN64(IMultiToken VAR73, ERC20 VAR26, ERC20 VAR27, uint256 VAR32, uint256 VAR22) external {
if (VAR26.FUN7(this, VAR73) == 0) {
VAR26.FUN38(VAR73, uint256(-1));
}
VAR73.FUN23(VAR26, VAR27, VAR22, VAR32);
}
function FUN65(IMultiToken VAR73, ERC20 VAR26, ERC20 VAR27, uint256 VAR32, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR26.FUN6(this).FUN1(VAR70).FUN2(VAR71);
this.FUN64(VAR73, VAR26, VAR27, VAR32, VAR72);
}
function FUN66(IEtherToken VAR74, uint256 VAR22) external {
VAR74.FUN53(VAR22);
}
function FUN67(IEtherToken VAR74, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR74.FUN6(this).FUN1(VAR70).FUN2(VAR71);
VAR74.FUN53(VAR72);
}
function FUN68(IBancorNetwork VAR75, address[] VAR47, uint256 VAR9) external {
VAR75.VAR76.value(VAR9)(VAR47, VAR9, 1);
}
function FUN69(IBancorNetwork VAR75, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR38.FUN1(VAR70).FUN2(VAR71);
VAR75.VAR76.value(value)(VAR47, value, 1);
}
function FUN70(IBancorNetwork VAR75, address[] VAR47, uint256 VAR22) external {
if (FUN71(VAR47[0]).FUN7(this, VAR75) == 0) {
FUN71(VAR47[0]).FUN38(VAR75, uint256(-1));
}
VAR75.FUN55(VAR47, VAR22, 1);
}
function FUN72(IBancorNetwork VAR75, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN71(VAR47[0]).FUN6(this).FUN1(VAR70).FUN2(VAR71);
if (FUN71(VAR47[0]).FUN7(this, VAR75) == 0) {
FUN71(VAR47[0]).FUN38(VAR75, uint256(-1));
}
VAR75.FUN55(VAR47, VAR72, 1);
}
function FUN73(IBancorNetwork VAR75, address[] VAR47, uint256 VAR22) external {
FUN71(VAR47[0]).FUN35(VAR75, VAR22);
VAR75.FUN54(VAR47, VAR22, 1);
}
function FUN74(IBancorNetwork VAR75, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN71(VAR47[0]).FUN6(this).FUN1(VAR70).FUN2(VAR71);
FUN71(VAR47[0]).FUN35(VAR75, VAR72);
VAR75.FUN54(VAR47, VAR72, 1);
}
function FUN75(IBancorNetwork VAR75, address[] VAR47, uint256 VAR22) external {
VAR75.FUN54(VAR47, VAR22, 1);
}
function FUN76(IBancorNetwork VAR75, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN71(VAR47[0]).FUN6(VAR75).FUN1(VAR70).FUN2(VAR71);
VAR75.FUN54(VAR47, VAR72, 1);
}
function FUN77(IKyberNetworkProxy VAR77, ERC20 VAR26, address VAR27, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR38.FUN1(VAR70).FUN2(VAR71);
VAR77.VAR78.value(value)(
VAR26,
value,
VAR27,
this,
1 << 255,
0,
0
);
}
function FUN78(IKyberNetworkProxy VAR77, ERC20 VAR26, address VAR27, uint256 VAR22) external {
if (VAR26.FUN7(this, VAR77) == 0) {
VAR26.FUN38(VAR77, uint256(-1));
}
VAR77.FUN56(
VAR26,
VAR22,
VAR27,
this,
1 << 255,
0,
0
);
}
function FUN79(IKyberNetworkProxy VAR77, ERC20 VAR26, address VAR27, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR26.FUN6(this).FUN1(VAR70).FUN2(VAR71);
this.FUN78(VAR77, VAR26, VAR27, VAR72);
}
}
contract MultiSeller is VAR79 {
using CheckedERC20 for VAR17;
using CheckedERC20 for VAR80;
function() public payable {
require(VAR81.VAR82 != msg.sender);
}
function FUN80(
IMultiToken VAR73,
uint256 VAR22,
bytes VAR64,
uint[] VAR65
)
public
{
FUN81(
VAR73,
VAR22,
VAR64,
VAR65,
VAR81.VAR82
);
}
function FUN81(
IMultiToken VAR73,
uint256 VAR22,
bytes VAR64,
uint[] VAR65,
address VAR83
)
public
{
VAR73.FUN37(msg.sender, this, VAR22);
VAR73.FUN16(this, VAR22);
FUN23(VAR64, VAR65);
VAR83.transfer(address(this).VAR38);
}
function FUN82(
IMultiToken VAR73,
uint256 VAR22,
ERC20 VAR84,
address[] VAR85,
bytes VAR86,
uint[] VAR87
)
public
{
FUN83(
VAR73,
VAR22,
VAR84,
VAR85,
VAR86,
VAR87,
VAR81.VAR82
);
}
function FUN83(
IMultiToken VAR73,
uint256 VAR22,
ERC20 VAR84,
address[] VAR85,
bytes VAR86,
uint[] VAR87,
address VAR83
)
public
{
if (VAR84 == address(0)) {
require(VAR73.FUN13() == VAR85.VAR67, "");
} else {
require(VAR73.FUN13() + 1 == VAR85.VAR67, "");
}
require(VAR87.VAR67 == VAR85.VAR67 + 1, "");
VAR73.FUN8(msg.sender, this, VAR22);
VAR73.FUN16(this, VAR22);
for (uint VAR66 = 0; VAR66 < VAR85.VAR67; VAR66++) {
bytes memory VAR58 = VAR88 bytes(VAR87[VAR66 + 1] - VAR87[VAR66]);
for (uint VAR89 = VAR87[VAR66]; VAR89 < VAR87[VAR66 + 1]; VAR89++) {
VAR58[VAR89 - VAR87[VAR66]] = VAR86[VAR89];
}
if (VAR58.VAR67 == 0) {
continue;
}
if (VAR66 == VAR85.VAR67 - 1 && VAR84 != address(0)) {
if (VAR84.FUN7(this, VAR85[VAR66]) == 0) {
VAR84.FUN38(VAR85[VAR66], uint256(-1));
}
} else {
ERC20 VAR90 = VAR73.FUN84(VAR66);
if (VAR85[VAR66] == 0) {
VAR90.FUN35(VAR83, VAR90.FUN6(this));
continue;
}
if (VAR90.FUN7(this, VAR85[VAR66]) == 0) {
VAR90.FUN38(VAR85[VAR66], uint256(-1));
}
}
require(VAR85[VAR66].call(VAR58), "");
}
VAR83.transfer(address(this).VAR38);
if (VAR84 != address(0) && VAR84.FUN6(this) > 0) {
VAR84.FUN35(VAR83, VAR84.FUN6(this));
}
}
}
1
---------------------------------
154 0x9a4fe70bb7b39127f4772acaf0d000578644b39d.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) payable returns (bytes32 VAR7);
function FUN7(string VAR5) returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) returns (uint VAR12);
function FUN8(string VAR14);
function FUN9(byte VAR15);
function FUN10(bytes32 VAR16);
function FUN11(uint VAR17);
function FUN12() returns(bytes32);
}
contract VAR18 {
function FUN13() returns (address VAR19);
}
contract VAR20 {
uint constant VAR21 = 60*60*24;
uint constant VAR22 = 60*60*24*7;
uint constant VAR23 = 60*60*24*30;
byte constant VAR24 = 0x00;
byte constant VAR25 = 0x10;
byte constant VAR26 = 0x20;
byte constant VAR27 = 0x30;
byte constant VAR28 = 0xF0;
byte constant VAR29 = 0x01;
uint8 constant VAR30 = 0;
uint8 constant VAR31 = 1;
uint8 constant VAR32 = 2;
uint8 constant VAR33 = 2;
uint8 constant VAR34 = 161;
OraclizeAddrResolverI VAR35;
OraclizeI VAR36;
modifier VAR37 {
if((address(VAR35)==0)||(FUN14(address(VAR35))==0)) FUN15(VAR30);
VAR36 = FUN16(VAR35.FUN13());
VAR38;
}
modifier FUN17(string VAR39){
VAR36 = FUN16(VAR35.FUN13());
VAR36.FUN8(VAR39);
VAR38;
}
function FUN15(uint8 VAR40) internal returns(bool){
if (FUN14(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR35 = FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN19("");
return true;
}
if (FUN14(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR35 = FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN19("");
return true;
}
if (FUN14(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR35 = FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN19("");
return true;
}
if (FUN14(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR35 = FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN19("");
return true;
}
if (FUN14(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR35 = FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN14(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR35 = FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN14(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR35 = FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN20(bytes32 VAR41, string VAR42) {
FUN20(VAR41, VAR42, VAR43 bytes(0));
}
function FUN20(bytes32 VAR41, string VAR42, bytes VAR44) {
}
function FUN21(string VAR39) oraclizeAPI internal {
VAR36.FUN8(VAR39);
}
function FUN22(string VAR45) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45);
}
function FUN22(string VAR45, uint VAR13) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45, VAR13);
}
function FUN23(string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(0, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(VAR53, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(VAR53, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(0, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(0, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(VAR53, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(VAR53, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(0, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN26() oraclizeAPI internal returns (address){
return VAR36.FUN27();
}
function FUN28(byte VAR64) oraclizeAPI internal {
return VAR36.FUN9(VAR64);
}
function FUN29(uint VAR65) oraclizeAPI internal {
return VAR36.FUN11(VAR65);
}
function FUN30(bytes32 VAR66) oraclizeAPI internal {
return VAR36.FUN10(VAR66);
}
function FUN31() oraclizeAPI internal returns (bytes32){
return VAR36.FUN12();
}
function FUN14(address VAR19) constant internal returns(uint VAR67) {
VAR68 {
VAR67 := FUN32(VAR19)
}
}
function FUN33(string VAR69) internal returns (address){
bytes memory VAR70 = bytes(VAR69);
uint160 VAR71 = 0;
uint160 VAR72;
uint160 VAR73;
for (uint VAR74=2; VAR74<2+2*20; VAR74+=2){
VAR71 *= 256;
VAR72 = FUN34(VAR70[VAR74]);
VAR73 = FUN34(VAR70[VAR74+1]);
if ((VAR72 >= 97)&&(VAR72 <= 102)) VAR72 -= 87;
else if ((VAR72 >= 65)&&(VAR72 <= 70)) VAR72 -= 55;
else if ((VAR72 >= 48)&&(VAR72 <= 57)) VAR72 -= 48;
if ((VAR73 >= 97)&&(VAR73 <= 102)) VAR73 -= 87;
else if ((VAR73 >= 65)&&(VAR73 <= 70)) VAR73 -= 55;
else if ((VAR73 >= 48)&&(VAR73 <= 57)) VAR73 -= 48;
VAR71 += (VAR72*16+VAR73);
}
return address(VAR71);
}
function FUN35(string VAR69, string VAR75) internal returns (int) {
bytes memory VAR76 = bytes(VAR69);
bytes memory VAR77 = bytes(VAR75);
uint VAR78 = VAR76.VAR79;
if (VAR77.VAR79 < VAR78) VAR78 = VAR77.VAR79;
for (uint VAR74 = 0; VAR74 < VAR78; VAR74 ++)
if (VAR76[VAR74] < VAR77[VAR74])
return -1;
else if (VAR76[VAR74] > VAR77[VAR74])
return 1;
if (VAR76.VAR79 < VAR77.VAR79)
return -1;
else if (VAR76.VAR79 > VAR77.VAR79)
return 1;
else
return 0;
}
function FUN36(string VAR80, string VAR81) internal returns (int) {
bytes memory VAR82 = bytes(VAR80);
bytes memory VAR83 = bytes(VAR81);
if(VAR82.VAR79 < 1 || VAR83.VAR79 < 1 || (VAR83.VAR79 > VAR82.VAR79))
return -1;
else if(VAR82.VAR79 > (2**128 -1))
return -1;
else
{
uint VAR84 = 0;
for (uint VAR74 = 0; VAR74 < VAR82.VAR79; VAR74 ++)
{
if (VAR82[VAR74] == VAR83[0])
{
VAR84 = 1;
while(VAR84 < VAR83.VAR79 && (VAR74 + VAR84) < VAR82.VAR79 && VAR82[VAR74 + VAR84] == VAR83[VAR84])
{
VAR84++;
}
if(VAR84 == VAR83.VAR79)
return int(VAR74);
}
}
return -1;
}
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86, string VAR87) internal returns (string) {
bytes memory VAR88 = bytes(VAR69);
bytes memory VAR89 = bytes(VAR75);
bytes memory VAR90 = bytes(VAR85);
bytes memory VAR91 = bytes(VAR86);
bytes memory VAR92 = bytes(VAR87);
string memory VAR93 = VAR43 string(VAR88.VAR79 + VAR89.VAR79 + VAR90.VAR79 + VAR91.VAR79 + VAR92.VAR79);
bytes memory VAR94 = bytes(VAR93);
uint VAR95 = 0;
for (uint VAR74 = 0; VAR74 < VAR88.VAR79; VAR74++) VAR94[VAR95++] = VAR88[VAR74];
for (VAR74 = 0; VAR74 < VAR89.VAR79; VAR74++) VAR94[VAR95++] = VAR89[VAR74];
for (VAR74 = 0; VAR74 < VAR90.VAR79; VAR74++) VAR94[VAR95++] = VAR90[VAR74];
for (VAR74 = 0; VAR74 < VAR91.VAR79; VAR74++) VAR94[VAR95++] = VAR91[VAR74];
for (VAR74 = 0; VAR74 < VAR92.VAR79; VAR74++) VAR94[VAR95++] = VAR92[VAR74];
return string(VAR94);
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, VAR86, "");
}
function FUN37(string VAR69, string VAR75, string VAR85) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, "", "");
}
function FUN37(string VAR69, string VAR75) internal returns (string) {
return FUN37(VAR69, VAR75, "", "", "");
}
function FUN38(string VAR69) internal returns (uint) {
return FUN38(VAR69, 0);
}
function FUN38(string VAR69, uint VAR75) internal returns (uint) {
bytes memory VAR96 = bytes(VAR69);
uint VAR97 = 0;
bool VAR98 = false;
for (uint VAR74=0; VAR74<VAR96.VAR79; VAR74++){
if ((VAR96[VAR74] >= 48)&&(VAR96[VAR74] <= 57)){
if (VAR98){
if (VAR75 == 0) break;
else VAR75--;
}
VAR97 *= 10;
VAR97 += uint(VAR96[VAR74]) - 48;
} else if (VAR96[VAR74] == 46) VAR98 = true;
}
if (VAR75 > 0) VAR97 *= 10**VAR75;
return VAR97;
}
function FUN39(uint VAR74) internal returns (string){
if (VAR74 == 0) return "";
uint VAR99 = VAR74;
uint VAR100;
while (VAR99 != 0){
VAR100++;
VAR99 /= 10;
}
bytes memory VAR101 = VAR43 bytes(VAR100);
uint VAR95 = VAR100 - 1;
while (VAR74 != 0){
VAR101[VAR95--] = FUN40(48 + VAR74 % 10);
VAR74 /= 10;
}
return string(VAR101);
}
function FUN24(string[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
function FUN25(bytes[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
string VAR112;
function FUN19(string VAR113) internal {
VAR112 = VAR113;
}
function FUN41() internal returns (string) {
return VAR112;
}
function FUN42(uint VAR114, uint VAR115, uint VAR116) internal returns (bytes32){
if ((VAR115 == 0)||(VAR115 > 32)) throw;
bytes memory VAR117 = VAR43 bytes(1);
VAR117[0] = FUN40(VAR115);
bytes memory VAR118 = VAR43 bytes(32);
bytes memory VAR119 = VAR43 bytes(32);
bytes32 VAR120 = FUN31();
VAR68 {
FUN43(VAR118, 0x20)
FUN43(FUN44(VAR118, 0x20), FUN45(FUN46(FUN47(VAR121, 1)), FUN45(VAR122, VAR53)))
FUN43(VAR119, 0x20)
FUN43(FUN44(VAR119, 0x20), VAR120)
}
bytes[3] memory VAR60 = [VAR118, VAR117, VAR119];
bytes32 VAR123 = FUN23(VAR114, "", VAR60, VAR116);
FUN48(VAR123, FUN49(FUN50(VAR114), VAR60[1], FUN51(VAR60[0]), VAR60[2]));
return VAR123;
}
function FUN48(bytes32 VAR123, bytes32 VAR124) internal {
VAR125[VAR123] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN52(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR43 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN53(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR43 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN53(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR68 {
VAR132 := FUN54(FUN44(VAR134, 32))
VAR133 := FUN54(FUN44(VAR136, 32))
}
(VAR130, VAR131) = FUN55(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN55(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN56(bytes VAR44, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR43 bytes(uint(VAR44[VAR137+1])+2);
FUN53(VAR44, VAR137, VAR138.VAR79, VAR138, 0);
bytes memory VAR139 = VAR43 bytes(64);
FUN53(VAR44, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR43 bytes(1+65+32);
VAR140[0] = 1;
FUN53(VAR44, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN53(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN52(FUN51(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR43 bytes(1+65);
VAR144[0] = 0xFE;
FUN53(VAR44, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR43 bytes(uint(VAR44[3+65+1])+2);
FUN53(VAR44, 3+65, VAR145.VAR79, VAR145, 0);
VAR130 = FUN52(FUN51(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN57(bytes32 VAR146, string VAR147, bytes VAR148) {
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) throw;
bool VAR149 = FUN58(VAR148, VAR146, bytes(VAR147), FUN41());
if (VAR149 == false) throw;
VAR38;
}
function FUN59(bytes32 VAR150, bytes VAR151) internal returns (bool){
bool VAR152 = true;
for (var VAR74=0; VAR74<VAR151.VAR79; VAR74++){
if (VAR150[VAR74] != VAR151[VAR74]) VAR152 = false;
}
return VAR152;
}
function FUN58(bytes VAR44, bytes32 VAR123, bytes VAR42, string VAR153) internal returns (bool){
bool VAR154;
uint VAR155 = 3+65+(uint(VAR44[3+65+1])+2)+32;
bytes memory VAR156 = VAR43 bytes(32);
FUN53(VAR44, VAR155, 32, VAR156, 0);
VAR154 = (FUN49(VAR156) == FUN49(FUN51(VAR153, VAR123)));
if (VAR154 == false) return false;
bytes memory VAR157 = VAR43 bytes(uint(VAR44[VAR155+(32+8+1+32)+1])+2);
FUN53(VAR44, VAR155+(32+8+1+32), VAR157.VAR79, VAR157, 0);
VAR154 = FUN59(FUN51(VAR157), VAR42);
if (VAR154 == false) return false;
bytes memory VAR158 = VAR43 bytes(8+1+32);
FUN53(VAR44, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR43 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR79+65;
FUN53(VAR44, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN51(VAR159);
if (VAR125[VAR123] == FUN49(VAR158, VAR160)){
delete VAR125[VAR123];
} else return false;
bytes memory VAR161 = VAR43 bytes(32+8+1+32);
FUN53(VAR44, VAR155, 32+8+1+32, VAR161, 0);
VAR154 = FUN52(FUN51(VAR161), VAR157, VAR159);
if (VAR154 == false) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN56(VAR44, VAR137);
}
return VAR126[VAR160];
}
function FUN53(bytes VAR162, uint VAR163, uint VAR79, bytes VAR164, uint VAR165) internal returns (bytes) {
uint VAR78 = VAR79 + VAR165;
if (VAR164.VAR79 < VAR78) {
throw;
}
uint VAR74 = 32 + VAR163;
uint VAR99 = 32 + VAR165;
while (VAR74 < (32 + VAR163 + VAR79)) {
VAR68 {
let VAR70 := FUN54(FUN44(VAR162, VAR74))
FUN43(FUN44(VAR164, VAR99), VAR70)
}
VAR74 += 32;
VAR99 += 32;
}
return VAR164;
}
function FUN55(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR68 {
let VAR172 := FUN54(0x40)
FUN43(VAR172, VAR166)
FUN43(FUN44(VAR172, 32), VAR167)
FUN43(FUN44(VAR172, 64), VAR168)
FUN43(FUN44(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN54(VAR172)
}
return (VAR170, VAR171);
}
function FUN60(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR79 != 65)
return (false, 0);
VAR68 {
VAR168 := FUN54(FUN44(VAR173, 32))
VAR169 := FUN54(FUN44(VAR173, 64))
VAR167 := FUN40(0, FUN54(FUN44(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN55(VAR166, VAR167, VAR168, VAR169);
}
}
contract VAR174
{
address public VAR175;
function FUN61()
{
VAR175 = msg.sender;
}
modifier onlyOwner
{
if (msg.sender != VAR175) throw;
VAR38;
}
function FUN62(address VAR176) onlyOwner
{
VAR175 = VAR176;
}
}
contract VAR177
{
function FUN63() constant returns (uint256 VAR178);
function FUN64(address VAR179) constant returns (uint256 VAR180);
function transfer(address VAR181, uint256 VAR182) returns (bool VAR183);
function FUN65(address VAR184, address VAR181, uint256 VAR182) returns (bool VAR183);
function FUN66(address VAR185, uint256 VAR182) returns (bool VAR183);
function FUN67(address VAR179, address VAR185) constant returns (uint256 VAR186);
event Transfer(address indexed VAR184, address indexed VAR181, uint256 VAR182);
event FUN68(address indexed VAR179, address indexed VAR185, uint256 VAR182);
}
contract X is VAR174, VAR177, VAR20
{
event Transfer(address indexed VAR184, address indexed VAR181, uint VAR182);
event FUN68(address indexed VAR179, address indexed VAR185, uint VAR182);
mapping (address => uint256) public VAR187;
struct VAR188
{
address VAR189;
uint VAR190;
}
VAR188[] public VAR191;
VAR188[] public VAR192;
mapping(address => mapping (address => uint256)) VAR193;
string public constant VAR194 = "";
string public constant VAR195 = "";
uint public constant VAR98 = 8;
uint VAR196 = 100000000000000000;
uint VAR197 = 1000000000000000;
uint public VAR198 = 0;
uint public VAR199 = 0;
uint public VAR200 = 100000000000000;
uint public VAR201 = 1000000000000000;
uint public VAR202 = 13000000000000000;
uint public VAR203 = 10900000000000000;
uint public VAR204 = 18750000000000000;
uint public VAR205 = 56250000000000000;
uint VAR206 = 0.0035 VAR49;
uint VAR207 = 0.00525 VAR49;
uint VAR208 = 0.065 VAR49;
uint VAR209 = 0.007 VAR49;
uint VAR210 = 0.0077 VAR49;
uint VAR211 = 0.00875 VAR49;
uint VAR212 = 0.01 VAR49;
uint VAR213 = 1501545600;
uint VAR214 = 1504224000;
uint VAR215 = 1506816000;
uint VAR216 = 1509494400;
uint VAR217 = 1512086400;
uint VAR218 = 1514764800;
uint public VAR219 = 200000;
function FUN69()
{
address VAR220 = 0x0035c4C86f15ba80319853df6092C838bA9B39C8;
address VAR221 = 0x0664B21FD33865c2259d2674f75b8C2a1A4e27A7;
address VAR222 = 0xaA41e0F9f4A19719007C53064B6979bDB6DF8b8c;
address VAR223 = 0x32Be343B94f860124dC4fEe278FDCBD38C102D88;
address VAR224 = 0x7eD1E469fCb3EE19C0366D829e291451bE638E59;
address VAR225 = 0x8aa50dfc95Ab047128ccDc6Af4BA2dDbA8D0A874;
VAR187[msg.sender] = VAR202;
VAR187[VAR220] = VAR203;
VAR202 -= VAR202;
VAR203 -= VAR203;
VAR187[VAR221] = 1100000000;
VAR191.FUN70(FUN71({VAR189: VAR221, VAR190: 0.0015 VAR49}));
VAR198 += 0.0015 VAR49;
VAR200 -= VAR187[VAR221];
VAR187[VAR222] = 62800000000;
VAR191.FUN70(FUN71({VAR189: VAR222, VAR190: 0.002 VAR49}));
VAR198 += 0.002 VAR49;
VAR200 -= VAR187[VAR222];
VAR187[VAR223] = 8000000000;
VAR200 -= VAR187[VAR223];
VAR187[VAR224] = 1000000000;
VAR200 -= VAR187[VAR224];
VAR187[VAR225] = 20000000000;
VAR200 -= VAR187[VAR225];
}
function () payable
{
uint VAR226 = msg.value;
if (VAR227 > VAR218)
{
VAR192.FUN70(FUN71({VAR189: msg.sender, VAR190: VAR226}));
VAR199 += VAR226;
return;
}
uint VAR228 = FUN72();
if (VAR226 < VAR228)
{
revert();
}
uint VAR229 = VAR226/VAR228;
uint VAR230 = VAR226 - ((VAR226/VAR228)*VAR228);
if ((VAR200/(10**VAR98)) >= VAR229)
{
VAR187[msg.sender] = VAR229 * (10**VAR98);
VAR200 -= VAR229 * (10**VAR98);
if(VAR230 > 0)
{
VAR191.FUN70(FUN71({VAR189: msg.sender, VAR190: VAR230}));
VAR198 += VAR230;
}
}
else
{
if(VAR200 > 0 && (VAR200/(10**VAR98)) < VAR229)
{
VAR187[msg.sender] = VAR200;
uint VAR231 = (VAR229 - (VAR200/(10**VAR98))) * VAR228;
VAR191.FUN70(FUN71({VAR189: msg.sender, VAR190: VAR231}));
VAR198 += VAR231;
VAR200 = 0;
}
else
{
VAR191.FUN70(FUN71({VAR189: msg.sender, VAR190: VAR226}));
VAR198 += VAR226;
}
}
}
function FUN73() returns (uint VAR232)
{
return VAR191.VAR79;
}
function FUN74() payable returns (bool VAR183)
{
if (VAR227 > VAR218)
{
revert();
}
uint VAR226 = msg.value;
if (VAR226 > 0)
{
VAR191.FUN70(FUN71({VAR189: msg.sender, VAR190: VAR226}));
VAR198 += VAR226;
return true;
}
else
{
return false;
}
}
function FUN72() returns (uint VAR228)
{
if(VAR227 < VAR213)
{
return VAR207;
}
else if(VAR227 < VAR214)
{
return VAR208;
}
else if(VAR227 < VAR215)
{
return VAR209;
}
else if(VAR227 < VAR216)
{
return VAR210;
}
else if(VAR227 < VAR217)
{
return VAR211;
}
else
{
return VAR212;
}
}
function FUN75() onlyOwner returns (bool VAR183)
{
if (VAR227 > VAR218)
{
return false;
}
else if (VAR191.VAR79 == 0)
{
return false;
}
else
{
uint VAR233 = 0;
while(VAR191.VAR79 - VAR233 > 0)
{
donation VAR234 = VAR191[VAR191.VAR79 - VAR233 - 1];
uint VAR235 = ((VAR197 * VAR234.VAR190)/(VAR198));
VAR187[VAR234.VAR189] += VAR235;
delete VAR191[VAR191.VAR79 - VAR233 - 1];
VAR233 += 1;
}
return true;
}
}
function FUN76(uint VAR48) onlyOwner returns (bool VAR183)
{
VAR219 = VAR48;
return true;
}
function FUN77() onlyOwner returns (bool VAR183)
{
VAR175.call.FUN78(200000).value(this.VAR180)();
return true;
}
function FUN63() constant returns (uint256 VAR178)
{
VAR178 = VAR196;
}
function FUN64(address VAR179) constant returns (uint256 VAR180)
{
return VAR187[VAR179];
}
function transfer(address VAR181, uint256 VAR182) returns (bool VAR183)
{
if (VAR187[msg.sender] < VAR182 || VAR187[VAR181] + VAR182 < VAR187[VAR181])
{
revert();
return false;
}
VAR187[msg.sender] -= VAR182;
VAR187[VAR181] += VAR182;
Transfer(msg.sender, VAR181, VAR182);
return true;
}
function FUN65(address VAR184, address VAR181, uint256 VAR236) returns (bool VAR183)
{
if (VAR187[VAR184] >= VAR236 && VAR193[VAR184][msg.sender] >= VAR236 && VAR236 > 0 && VAR187[VAR181] + VAR236 > VAR187[VAR181])
{
VAR187[VAR184] -= VAR236;
VAR193[VAR184][msg.sender] -= VAR236;
VAR187[VAR181] += VAR236;
Transfer(VAR184, VAR181, VAR236);
return true;
}
else
{
return false;
}
}
function FUN66(address VAR185, uint256 VAR236) returns (bool VAR183)
{
VAR193[msg.sender][VAR185] = VAR236;
FUN68(msg.sender, VAR185, VAR236);
return true;
}
function FUN67(address VAR179, address VAR185) constant returns (uint256 VAR186)
{
return VAR193[VAR179][VAR185];
}
function FUN20(bytes32 VAR41, string VAR42)
{
if (msg.sender != FUN26())
{
throw;
}
address VAR237 = FUN33(VAR42);
if (VAR204 >= (1 * 10**VAR98))
{
VAR204 -= 1 * (10**VAR98);
VAR187[VAR237] += 1 * (10**VAR98);
}
else
{
VAR187[VAR237] += VAR204;
VAR204 -= VAR204;
}
}
function FUN79() payable returns (bool VAR183)
{
FUN23("", "FUN80(VAR238:
if (VAR205 >= (3 * 10**VAR98))
{
VAR205 -= 3 * (10**VAR98);
VAR187[VAR239.VAR122] += 3 * (10**VAR98);
}
else
{
VAR187[VAR239.VAR122] += VAR205;
VAR205 -= VAR205;
}
return true;
}
}
1
---------------------------------
155 0x9bbb9387c9e2477a6b5d81afece00255875c48ce.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
function FUN6() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract VAR11 {
uint256 public VAR12;
function FUN8(address VAR13) public view returns (uint256);
function transfer(address VAR14, uint256 value) public returns (bool);
event Transfer(address indexed VAR15, address indexed VAR14, uint256 value);
}
contract BasicToken is VAR11 {
using SafeMath for uint256;
mapping(address => uint256) VAR16;
function transfer(address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
require(VAR18 <= VAR16[msg.sender]);
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR18);
Transfer(msg.sender, VAR17, VAR18);
return true;
}
function FUN8(address VAR19) public view returns (uint256 VAR20) {
return VAR16[VAR19];
}
}
contract InkPublicPresale is VAR6 {
using SafeMath for uint256;
bool public VAR21;
bool private VAR22;
uint256 public VAR23;
uint256 public VAR24;
uint256 public VAR25;
uint256 private VAR26;
uint256 private VAR27;
address public VAR28;
uint256 public VAR29;
mapping(address => VAR30) private VAR31;
struct VAR30 {
bool VAR32;
uint256 VAR33;
uint256 VAR34;
uint256 VAR20;
}
modifier VAR35 {
require(VAR28 != address(0));
VAR10;
}
modifier VAR36 {
require(VAR28 == address(0));
VAR10;
}
function FUN9() public {
VAR24 = 1000000000000000000;
VAR23 = 100000000000000000;
VAR29 = 40000000000;
}
function FUN10(uint256 VAR37) public onlyOwner {
require(VAR37 > 0);
VAR29 = VAR37;
}
function FUN11() public view onlyOwner returns (uint256) {
return VAR26;
}
function FUN12() public view onlyOwner returns (uint256) {
return VAR27;
}
function FUN13(uint256 VAR38) public notFinalized onlyOwner {
VAR25 = VAR38;
}
function FUN14(uint256 VAR39) public notFinalized onlyOwner {
require(VAR39 > VAR23);
VAR24 = VAR39;
}
function FUN15(uint256 VAR40) public notFinalized onlyOwner {
require(VAR40 > 0);
require(VAR40 < VAR24);
VAR23 = VAR40;
}
function FUN16(address VAR41) public finalized onlyOwner {
require(VAR41 != address(0));
VAR28 = VAR41;
}
function FUN17() public onlyOwner {
require(VAR21);
VAR21 = false;
}
function FUN18() public onlyOwner {
require(!VAR21);
VAR21 = true;
}
function FUN19() public onlyOwner {
require(!VAR22);
VAR22 = true;
}
function FUN20() public onlyOwner {
require(VAR22);
VAR22 = false;
}
function FUN21(address VAR42, uint256 VAR43, uint256 VAR44) public onlyOwner VAR36 {
require(VAR42 != address(0));
require(VAR43 > 0);
require(VAR44 >= VAR23);
require(!VAR31[VAR42].VAR32);
VAR31[VAR42].VAR32 = true;
VAR31[VAR42].VAR34 = VAR44;
VAR31[VAR42].VAR33 = VAR43;
}
function FUN22(address VAR42, uint256 VAR45, uint256 VAR46) public onlyOwner VAR36 {
require(VAR42 != address(0));
require(VAR45 > 0);
require(VAR46 >= VAR23);
require(VAR31[VAR42].VAR32);
if (VAR31[VAR42].VAR20 > 0 && VAR31[VAR42].VAR33 != VAR45) {
VAR27 = VAR27.FUN3(VAR31[VAR42].VAR20.FUN1(VAR31[VAR42].VAR33));
VAR27 = VAR27.FUN4(VAR31[VAR42].VAR20.FUN1(VAR45));
}
VAR31[VAR42].VAR33 = VAR45;
VAR31[VAR42].VAR34 = VAR46;
}
function FUN23(address VAR42) public onlyOwner {
require(VAR42 != address(0));
require(VAR31[VAR42].VAR32);
VAR31[VAR42].VAR32 = false;
if (VAR31[VAR42].VAR20 > 0) {
uint256 VAR20 = VAR31[VAR42].VAR20;
VAR31[VAR42].VAR20 = 0;
VAR27 = VAR27.FUN3(VAR20.FUN1(VAR31[VAR42].VAR33));
VAR26 = VAR26.FUN3(VAR20);
!VAR42.call.value(VAR20)();
}
delete VAR31[VAR42];
}
function FUN24(address VAR17) public onlyOwner {
require(VAR17 != address(0));
BasicToken VAR47 = FUN25(VAR28);
assert(VAR47.transfer(VAR17, VAR47.FUN8(this)));
}
function FUN26(address VAR17) public finalized onlyOwner {
require(VAR17 != address(0));
assert(VAR17.call.value(this.VAR20)());
}
function FUN8(address VAR42) public view returns (uint256) {
require(VAR42 != address(0));
return VAR31[VAR42].VAR20;
}
function FUN27() public {
require(VAR21);
require(VAR22);
require(VAR31[msg.sender].VAR32);
uint256 VAR20 = VAR31[msg.sender].VAR20;
require(VAR20 > 0);
VAR31[msg.sender].VAR20 = 0;
VAR26 = VAR26.FUN3(VAR20);
VAR27 = VAR27.FUN3(VAR20.FUN1(VAR31[msg.sender].VAR33));
assert(msg.sender.call.value(VAR20)());
}
function FUN28(address VAR42) public finalized onlyOwner {
FUN29(VAR42);
}
function FUN30(address VAR41) public notFinalized onlyOwner {
require(VAR41 != address(0));
VAR28 = VAR41;
}
function () public payable {
if (msg.sender == VAR7 && msg.value > 0) {
return;
}
require(VAR21);
require(VAR31[msg.sender].VAR32);
if (VAR28 == address(0)) {
FUN31();
} else {
FUN29(msg.sender);
}
}
function FUN31() private {
require(msg.value > 0);
require(VAR48.VAR49 <= VAR29);
require(VAR31[msg.sender].VAR20.FUN4(msg.value) >= VAR23);
require(VAR25 > VAR26);
require(msg.value <= VAR25.FUN3(VAR26));
uint256 VAR50 = VAR31[msg.sender].VAR20.FUN4(msg.value);
if (VAR24 <= VAR31[msg.sender].VAR34) {
require(VAR50 <= VAR24);
} else {
require(VAR50 <= VAR31[msg.sender].VAR34);
}
VAR31[msg.sender].VAR20 = VAR50;
VAR26 = VAR26.FUN4(msg.value);
VAR27 = VAR27.FUN4(msg.value.FUN1(VAR31[msg.sender].VAR33));
}
function FUN29(address VAR51) private {
require(msg.value == 0);
uint256 VAR20 = VAR31[VAR51].VAR20;
require(VAR20 > 0);
uint256 VAR52 = VAR20.FUN1(VAR31[VAR51].VAR33);
VAR31[VAR51].VAR20 = 0;
assert(FUN25(VAR28).transfer(VAR51, VAR52));
}
}
1
---------------------------------
156 0x9c35fd2d966bdf2c28d906b0d862acb6600d28c8.sol
pragma VAR1 ^0.4.19;
contract VAR2{
address public VAR3;
bool public VAR4;
mapping( address => bool) public VAR5;
mapping( address => uint256) public VAR6;
event FUN1(address VAR7, address VAR8, uint256 VAR9);
event FUN2(address VAR7, address VAR8, uint256 VAR9);
event FUN3(address VAR10, bool VAR11);
modifier FUN4() {
require(msg.sender==VAR3);
VAR12;
}
modifier onlyAdmin() {
assert (VAR5[msg.sender]==true);
VAR12;
}
function FUN5() public {
VAR3=msg.sender;
VAR5[VAR3]=true;
VAR4=true;
}
function FUN6(address VAR13,uint256 VAR9) public onlyAdmin(){
assert(VAR4==true);
assert(VAR6[VAR13]+VAR9>VAR6[VAR13]);
VAR6[VAR13]+=VAR9;
FUN1(msg.sender,VAR13,VAR9);
}
function FUN7(address VAR13, uint256 VAR9) public onlyAdmin() {
require(VAR4==true || msg.sender==VAR3);
VAR6[VAR13]=VAR9;
FUN2(msg.sender,VAR13,VAR9);
}
function FUN8(address VAR10) public FUN4(){
VAR5[VAR10] = !VAR5[VAR10];
FUN3(VAR10, VAR5[VAR10]);
}
function FUN9() public FUN4(){
VAR4=!VAR4;
}
function() public{
revert();
}
}
pragma VAR1 ^0.4.19;
contract VAR14{
uint256 public VAR15;
address public VAR16;
address public VAR3;
bool public VAR4;
mapping( address => bool) public VAR5;
Storage VAR17;
event FUN10(address VAR10, uint256 VAR18);
event FUN11(address VAR10, uint256 VAR15);
event FUN3(address VAR10, bool VAR11);
modifier onlyAdmin() {
assert (VAR5[msg.sender]==true);
VAR12;
}
modifier FUN4() {
require(msg.sender==VAR3);
VAR12;
}
function FUN8(address VAR10) public FUN4(){
VAR5[VAR10] = !VAR5[VAR10];
FUN3(VAR10, VAR5[VAR10]);
}
function FUN12(address VAR10) public {
VAR3=msg.sender;
VAR15=3000000000000000;
VAR5[VAR3]=true;
VAR16=VAR10;
VAR17=FUN5(VAR16);
VAR4=true;
}
function FUN13(uint256 VAR19) public onlyAdmin(){
VAR15=VAR19;
FUN11(msg.sender, VAR15);
}
function FUN14(address VAR20) public onlyAdmin(){
VAR16=VAR20;
VAR17=FUN5(VAR16);
}
function FUN9() public FUN4(){
VAR4=!VAR4;
}
function FUN15(address VAR20, uint256 VAR18) public payable {
assert(VAR4==true);
assert(msg.value >= VAR15*VAR18);
if(!VAR3.call.value(VAR15*VAR18)() || !msg.sender.call.value(msg.value-VAR15*VAR18)()){
revert();
}
VAR17.FUN6(VAR20,VAR18);
FUN10(msg.sender,VAR18);
}
function () public payable {
FUN15(msg.sender,1);
}
}
1
---------------------------------
157 0x9e4ad79049282f942c1b4c9b418f0357a0637017.sol
pragma VAR1 ^ 0.4.17;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns(uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns(uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns(uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns(uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5() public constant returns(uint256 VAR7);
function FUN6(address VAR8) public constant returns(uint256 VAR9);
function transfer(address VAR10, uint256 VAR11) public returns(bool VAR12);
function FUN7(address VAR13, address VAR10, uint256 VAR11) public returns(bool VAR12);
function FUN8(address VAR14, uint256 VAR11) public returns(bool VAR12);
function FUN9(address VAR8, address VAR14) public constant returns(uint256 VAR15);
event Transfer(address indexed VAR13, address indexed VAR10, uint256 VAR11);
event FUN10(address indexed VAR8, address indexed VAR14, uint256 VAR11);
}
contract Noxon is VAR6 {
using SafeMath for uint;
string public constant VAR16 = "";
string public constant VAR17 = "";
uint8 public constant VAR18 = 0;
uint256 VAR19 = 0;
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
bool public VAR23 = false;
address public VAR24;
address public VAR25;
mapping(address => uint256) VAR26;
mapping(address => mapping(address => uint256)) VAR27;
modifier onlyOwner() {
require(msg.sender == VAR24);
VAR28;
}
address VAR29;
address VAR30;
function FUN11(address VAR31) public onlyOwner {
VAR29 = VAR31;
}
function FUN12() public {
if (msg.sender == VAR29) {
VAR24 = VAR29;
VAR29 = address(0);
}
}
function FUN13(address VAR32) public onlyOwner {
VAR30 = VAR32;
}
function FUN14() public {
if (msg.sender == VAR30) {
VAR25 = VAR30;
VAR30 = address(0);
}
}
function FUN15() public {
require(VAR19 == 0);
VAR24 = msg.sender;
VAR25 = VAR24;
}
function FUN16() public payable onlyOwner returns (bool) {
require(VAR19 == 0);
require(VAR22 == 0);
require(msg.value > 0);
Transfer(0, msg.sender, 1);
VAR26[VAR24] = 1;
VAR19 = VAR26[VAR24];
VAR20 = msg.value;
VAR21 = VAR20.FUN1(2);
VAR22 = VAR33.VAR34;
return true;
}
function FUN17() public onlyOwner {
VAR23 = true;
}
function FUN18() public onlyOwner {
VAR23 = false;
}
function FUN5() public constant returns(uint256) {
return VAR19;
}
function FUN19() public constant returns(uint256) {
return VAR20;
}
function FUN20() public constant returns(uint256) {
return VAR21;
}
function FUN6(address VAR8) public constant returns(uint256 VAR9) {
return VAR26[VAR8];
}
function transfer(address VAR10, uint256 VAR35) public returns(bool VAR12) {
if (VAR10 == address(this)) {
return FUN21(VAR35);
} else {
if (VAR26[msg.sender] >= VAR35 && VAR35 > 0 && VAR26[VAR10] + VAR35 > VAR26[VAR10]) {
VAR26[msg.sender] = VAR26[msg.sender].FUN3(VAR35);
VAR26[VAR10] = VAR26[VAR10].FUN4(VAR35);
Transfer(msg.sender, VAR10, VAR35);
return true;
} else {
return false;
}
}
}
function FUN21(uint256 VAR35) private returns(bool VAR12) {
VAR20 = FUN22();
uint256 VAR36 = VAR20;
if (VAR26[msg.sender] >= VAR35 && VAR35 > 0) {
VAR26[msg.sender] = VAR26[msg.sender].FUN3(VAR35);
VAR19 = VAR19.FUN3(VAR35);
assert(VAR19 >= 1);
msg.sender.transfer(VAR35.FUN1(VAR20));
VAR20 = FUN22();
assert(VAR20 >= VAR36);
FUN23(msg.sender, VAR35.FUN1(VAR20), VAR20, VAR35);
return true;
} else {
return false;
}
}
event FUN24(address indexed VAR37, uint256 VAR38, uint VAR39, uint VAR40);
event FUN23(address indexed VAR37, uint256 VAR38, uint VAR41, uint VAR40);
function () public payable {
uint256 VAR36 = VAR20;
require(VAR23 == false);
require(VAR20 > 0 && VAR21 > VAR20);
require(msg.value > 0);
uint256 VAR42 = msg.value / VAR21;
require(VAR26[msg.sender] + VAR42 > VAR26[msg.sender]);
VAR26[msg.sender] = VAR26[msg.sender].FUN4(VAR42);
VAR19 = VAR19.FUN4(VAR42);
uint VAR43 = msg.value / 2;
VAR25.transfer(VAR43);
FUN24(msg.sender, msg.value, VAR21, VAR42);
VAR20 = FUN22();
VAR21 = VAR20.FUN1(2);
assert(VAR20 >= VAR36);
}
function FUN22() public returns(uint) {
return this.VAR9 / VAR19;
}
event FUN25(uint VAR44);
function FUN26() public payable returns(bool) {
uint256 VAR36 = VAR20;
if (msg.value > 0) {
VAR20 = FUN22();
VAR21 = VAR20.FUN1(2);
FUN25(msg.value);
assert(VAR20 >= VAR36);
return true;
} else {
return false;
}
}
function FUN7(
address VAR13,
address VAR10,
uint256 VAR35
) public returns(bool VAR12) {
if (VAR26[VAR13] >= VAR35 && VAR27[VAR13][msg.sender] >= VAR35 && VAR35 > 0 && VAR26[VAR10] + VAR35 > VAR26[VAR10] && VAR10 != address(this)
) {
VAR26[VAR13] = VAR26[VAR13].FUN3(VAR35);
VAR27[VAR13][msg.sender] = VAR27[VAR13][msg.sender].FUN3(VAR35);
VAR26[VAR10] = VAR26[VAR10].FUN4(VAR35);
Transfer(VAR13, VAR10, VAR35);
return true;
} else {
return false;
}
}
function FUN8(address VAR14, uint256 VAR35) public returns(bool VAR12) {
VAR27[msg.sender][VAR14] = VAR35;
FUN10(msg.sender, VAR14, VAR35);
return true;
}
function FUN9(address VAR8, address VAR14) public constant returns(uint256 VAR15) {
return VAR27[VAR8][VAR14];
}
function FUN27(address VAR45, uint VAR42)
public
onlyOwner returns(bool VAR12) {
return FUN28(VAR45).transfer(VAR24, VAR42);
}
function FUN29() external returns(bool) {
return FUN21(VAR26[msg.sender]);
}
}
contract VAR46 {
Noxon VAR47;
function FUN30() payable {
VAR47 = VAR48 FUN15();
}
function () payable {
}
function FUN31() returns (uint) {
if (!VAR47.VAR49.value(12)()) throw;
if (!VAR47.call.value(24)()) revert();
assert(VAR47.FUN6(address(this)) == 2);
if (VAR47.call.value(23)()) revert();
assert(VAR47.FUN6(address(this)) == 2);
}
function FUN32() returns (uint) {
if (!VAR47.call.value(26)()) revert();
assert(VAR47.FUN6(address(this)) == 3);
assert(VAR47.FUN20() == 24);
return VAR47.VAR9;
}
function FUN33() returns (uint){
if (!VAR47.call.value(40)()) revert();
assert(VAR47.FUN6(address(this)) == 4);
}
function FUN34() {
if (!VAR47.transfer(address(VAR47),2)) revert();
assert(VAR47.FUN19() == 14);
}
}
1
---------------------------------
158 0x9e762daeb001dc7778d0eb043d530357f0c4666c.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) payable returns (bytes32 VAR7);
function FUN7(string VAR5) returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) returns (uint VAR12);
function FUN8(string VAR14);
function FUN9(byte VAR15);
function FUN10(bytes32 VAR16);
function FUN11(uint VAR17);
function FUN12() returns(bytes32);
}
contract VAR18 {
function FUN13() returns (address VAR19);
}
contract VAR20 {
uint constant VAR21 = 60*60*24;
uint constant VAR22 = 60*60*24*7;
uint constant VAR23 = 60*60*24*30;
byte constant VAR24 = 0x00;
byte constant VAR25 = 0x10;
byte constant VAR26 = 0x20;
byte constant VAR27 = 0x30;
byte constant VAR28 = 0xF0;
byte constant VAR29 = 0x01;
uint8 constant VAR30 = 0;
uint8 constant VAR31 = 1;
uint8 constant VAR32 = 2;
uint8 constant VAR33 = 2;
uint8 constant VAR34 = 161;
OraclizeAddrResolverI VAR35;
OraclizeI VAR36;
modifier VAR37 {
if((address(VAR35)==0)||(FUN14(address(VAR35))==0))
FUN15(VAR30);
if(address(VAR36) != VAR35.FUN13())
VAR36 = FUN16(VAR35.FUN13());
VAR38;
}
modifier FUN17(string VAR39){
VAR36 = FUN16(VAR35.FUN13());
VAR36.FUN8(VAR39);
VAR38;
}
function FUN15(uint8 VAR40) internal returns(bool){
if (FUN14(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR35 = FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN19("");
return true;
}
if (FUN14(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR35 = FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN19("");
return true;
}
if (FUN14(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR35 = FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN19("");
return true;
}
if (FUN14(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR35 = FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN19("");
return true;
}
if (FUN14(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR35 = FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN14(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR35 = FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN14(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR35 = FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN20(bytes32 VAR41, string VAR42) {
FUN20(VAR41, VAR42, VAR43 bytes(0));
}
function FUN20(bytes32 VAR41, string VAR42, bytes VAR44) {
}
function FUN21(string VAR39) oraclizeAPI internal {
VAR36.FUN8(VAR39);
}
function FUN22(string VAR45) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45);
}
function FUN22(string VAR45, uint VAR13) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45, VAR13);
}
function FUN23(string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(0, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(VAR53, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(VAR53, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(0, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(0, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(VAR53, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(VAR53, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(0, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN26() oraclizeAPI internal returns (address){
return VAR36.FUN27();
}
function FUN28(byte VAR64) oraclizeAPI internal {
return VAR36.FUN9(VAR64);
}
function FUN29(uint VAR65) oraclizeAPI internal {
return VAR36.FUN11(VAR65);
}
function FUN30(bytes32 VAR66) oraclizeAPI internal {
return VAR36.FUN10(VAR66);
}
function FUN31() oraclizeAPI internal returns (bytes32){
return VAR36.FUN12();
}
function FUN14(address VAR19) constant internal returns(uint VAR67) {
VAR68 {
VAR67 := FUN32(VAR19)
}
}
function FUN33(string VAR69) internal returns (address){
bytes memory VAR70 = bytes(VAR69);
uint160 VAR71 = 0;
uint160 VAR72;
uint160 VAR73;
for (uint VAR74=2; VAR74<2+2*20; VAR74+=2){
VAR71 *= 256;
VAR72 = FUN34(VAR70[VAR74]);
VAR73 = FUN34(VAR70[VAR74+1]);
if ((VAR72 >= 97)&&(VAR72 <= 102)) VAR72 -= 87;
else if ((VAR72 >= 65)&&(VAR72 <= 70)) VAR72 -= 55;
else if ((VAR72 >= 48)&&(VAR72 <= 57)) VAR72 -= 48;
if ((VAR73 >= 97)&&(VAR73 <= 102)) VAR73 -= 87;
else if ((VAR73 >= 65)&&(VAR73 <= 70)) VAR73 -= 55;
else if ((VAR73 >= 48)&&(VAR73 <= 57)) VAR73 -= 48;
VAR71 += (VAR72*16+VAR73);
}
return address(VAR71);
}
function FUN35(string VAR69, string VAR75) internal returns (int) {
bytes memory VAR76 = bytes(VAR69);
bytes memory VAR77 = bytes(VAR75);
uint VAR78 = VAR76.VAR79;
if (VAR77.VAR79 < VAR78) VAR78 = VAR77.VAR79;
for (uint VAR74 = 0; VAR74 < VAR78; VAR74 ++)
if (VAR76[VAR74] < VAR77[VAR74])
return -1;
else if (VAR76[VAR74] > VAR77[VAR74])
return 1;
if (VAR76.VAR79 < VAR77.VAR79)
return -1;
else if (VAR76.VAR79 > VAR77.VAR79)
return 1;
else
return 0;
}
function FUN36(string VAR80, string VAR81) internal returns (int) {
bytes memory VAR82 = bytes(VAR80);
bytes memory VAR83 = bytes(VAR81);
if(VAR82.VAR79 < 1 || VAR83.VAR79 < 1 || (VAR83.VAR79 > VAR82.VAR79))
return -1;
else if(VAR82.VAR79 > (2**128 -1))
return -1;
else
{
uint VAR84 = 0;
for (uint VAR74 = 0; VAR74 < VAR82.VAR79; VAR74 ++)
{
if (VAR82[VAR74] == VAR83[0])
{
VAR84 = 1;
while(VAR84 < VAR83.VAR79 && (VAR74 + VAR84) < VAR82.VAR79 && VAR82[VAR74 + VAR84] == VAR83[VAR84])
{
VAR84++;
}
if(VAR84 == VAR83.VAR79)
return int(VAR74);
}
}
return -1;
}
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86, string VAR87) internal returns (string) {
bytes memory VAR88 = bytes(VAR69);
bytes memory VAR89 = bytes(VAR75);
bytes memory VAR90 = bytes(VAR85);
bytes memory VAR91 = bytes(VAR86);
bytes memory VAR92 = bytes(VAR87);
string memory VAR93 = VAR43 string(VAR88.VAR79 + VAR89.VAR79 + VAR90.VAR79 + VAR91.VAR79 + VAR92.VAR79);
bytes memory VAR94 = bytes(VAR93);
uint VAR95 = 0;
for (uint VAR74 = 0; VAR74 < VAR88.VAR79; VAR74++) VAR94[VAR95++] = VAR88[VAR74];
for (VAR74 = 0; VAR74 < VAR89.VAR79; VAR74++) VAR94[VAR95++] = VAR89[VAR74];
for (VAR74 = 0; VAR74 < VAR90.VAR79; VAR74++) VAR94[VAR95++] = VAR90[VAR74];
for (VAR74 = 0; VAR74 < VAR91.VAR79; VAR74++) VAR94[VAR95++] = VAR91[VAR74];
for (VAR74 = 0; VAR74 < VAR92.VAR79; VAR74++) VAR94[VAR95++] = VAR92[VAR74];
return string(VAR94);
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, VAR86, "");
}
function FUN37(string VAR69, string VAR75, string VAR85) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, "", "");
}
function FUN37(string VAR69, string VAR75) internal returns (string) {
return FUN37(VAR69, VAR75, "", "", "");
}
function FUN38(string VAR69) internal returns (uint) {
return FUN38(VAR69, 0);
}
function FUN38(string VAR69, uint VAR75) internal returns (uint) {
bytes memory VAR96 = bytes(VAR69);
uint VAR97 = 0;
bool VAR98 = false;
for (uint VAR74=0; VAR74<VAR96.VAR79; VAR74++){
if ((VAR96[VAR74] >= 48)&&(VAR96[VAR74] <= 57)){
if (VAR98){
if (VAR75 == 0) break;
else VAR75--;
}
VAR97 *= 10;
VAR97 += uint(VAR96[VAR74]) - 48;
} else if (VAR96[VAR74] == 46) VAR98 = true;
}
if (VAR75 > 0) VAR97 *= 10**VAR75;
return VAR97;
}
function FUN39(uint VAR74) internal returns (string){
if (VAR74 == 0) return "";
uint VAR99 = VAR74;
uint VAR100;
while (VAR99 != 0){
VAR100++;
VAR99 /= 10;
}
bytes memory VAR101 = VAR43 bytes(VAR100);
uint VAR95 = VAR100 - 1;
while (VAR74 != 0){
VAR101[VAR95--] = FUN40(48 + VAR74 % 10);
VAR74 /= 10;
}
return string(VAR101);
}
function FUN24(string[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
function FUN25(bytes[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
string VAR112;
function FUN19(string VAR113) internal {
VAR112 = VAR113;
}
function FUN41() internal returns (string) {
return VAR112;
}
function FUN42(uint VAR114, uint VAR115, uint VAR116) internal returns (bytes32){
if ((VAR115 == 0)||(VAR115 > 32)) throw;
bytes memory VAR117 = VAR43 bytes(1);
VAR117[0] = FUN40(VAR115);
bytes memory VAR118 = VAR43 bytes(32);
bytes memory VAR119 = VAR43 bytes(32);
bytes32 VAR120 = FUN31();
VAR68 {
FUN43(VAR118, 0x20)
FUN43(FUN44(VAR118, 0x20), FUN45(FUN46(FUN47(VAR121, 1)), FUN45(VAR122, VAR53)))
FUN43(VAR119, 0x20)
FUN43(FUN44(VAR119, 0x20), VAR120)
}
bytes[3] memory VAR60 = [VAR118, VAR117, VAR119];
bytes32 VAR123 = FUN23(VAR114, "", VAR60, VAR116);
FUN48(VAR123, FUN49(FUN50(VAR114), VAR60[1], FUN51(VAR60[0]), VAR60[2]));
return VAR123;
}
function FUN48(bytes32 VAR123, bytes32 VAR124) internal {
VAR125[VAR123] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN52(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR43 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN53(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR43 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN53(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR68 {
VAR132 := FUN54(FUN44(VAR134, 32))
VAR133 := FUN54(FUN44(VAR136, 32))
}
(VAR130, VAR131) = FUN55(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN55(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN56(bytes VAR44, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR43 bytes(uint(VAR44[VAR137+1])+2);
FUN53(VAR44, VAR137, VAR138.VAR79, VAR138, 0);
bytes memory VAR139 = VAR43 bytes(64);
FUN53(VAR44, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR43 bytes(1+65+32);
VAR140[0] = 1;
FUN53(VAR44, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN53(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN52(FUN51(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR43 bytes(1+65);
VAR144[0] = 0xFE;
FUN53(VAR44, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR43 bytes(uint(VAR44[3+65+1])+2);
FUN53(VAR44, 3+65, VAR145.VAR79, VAR145, 0);
VAR130 = FUN52(FUN51(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN57(bytes32 VAR146, string VAR147, bytes VAR148) {
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) throw;
bool VAR149 = FUN58(VAR148, VAR146, bytes(VAR147), FUN41());
if (VAR149 == false) throw;
VAR38;
}
function FUN59(bytes32 VAR146, string VAR147, bytes VAR148) internal returns (uint8){
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) return 1;
bool VAR149 = FUN58(VAR148, VAR146, bytes(VAR147), FUN41());
if (VAR149 == false) return 2;
return 0;
}
function FUN60(bytes32 VAR150, bytes VAR151, uint VAR152) internal returns (bool){
bool VAR153 = true;
for (uint256 VAR74=0; VAR74< VAR152; VAR74++) {
if (VAR150[VAR74] != VAR151[VAR74]) VAR153 = false;
}
return VAR153;
}
function FUN58(bytes VAR44, bytes32 VAR123, bytes VAR42, string VAR154) internal returns (bool){
uint VAR155 = 3+65+(uint(VAR44[3+65+1])+2)+32;
bytes memory VAR156 = VAR43 bytes(32);
FUN53(VAR44, VAR155, 32, VAR156, 0);
if (!(FUN49(VAR156) == FUN49(FUN51(VAR154, VAR123)))) return false;
bytes memory VAR157 = VAR43 bytes(uint(VAR44[VAR155+(32+8+1+32)+1])+2);
FUN53(VAR44, VAR155+(32+8+1+32), VAR157.VAR79, VAR157, 0);
if (!FUN60(FUN51(VAR157), VAR42, uint(VAR44[VAR155+32+8]))) return false;
bytes memory VAR158 = VAR43 bytes(8+1+32);
FUN53(VAR44, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR43 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR79+65;
FUN53(VAR44, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN51(VAR159);
if (VAR125[VAR123] == FUN49(VAR158, VAR160)){
delete VAR125[VAR123];
} else return false;
bytes memory VAR161 = VAR43 bytes(32+8+1+32);
FUN53(VAR44, VAR155, 32+8+1+32, VAR161, 0);
if (!FUN52(FUN51(VAR161), VAR157, VAR159)) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN56(VAR44, VAR137);
}
return VAR126[VAR160];
}
function FUN53(bytes VAR162, uint VAR163, uint VAR79, bytes VAR164, uint VAR165) internal returns (bytes) {
uint VAR78 = VAR79 + VAR165;
if (VAR164.VAR79 < VAR78) {
throw;
}
uint VAR74 = 32 + VAR163;
uint VAR99 = 32 + VAR165;
while (VAR74 < (32 + VAR163 + VAR79)) {
VAR68 {
let VAR70 := FUN54(FUN44(VAR162, VAR74))
FUN43(FUN44(VAR164, VAR99), VAR70)
}
VAR74 += 32;
VAR99 += 32;
}
return VAR164;
}
function FUN55(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR68 {
let VAR172 := FUN54(0x40)
FUN43(VAR172, VAR166)
FUN43(FUN44(VAR172, 32), VAR167)
FUN43(FUN44(VAR172, 64), VAR168)
FUN43(FUN44(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN54(VAR172)
}
return (VAR170, VAR171);
}
function FUN61(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR79 != 65)
return (false, 0);
VAR68 {
VAR168 := FUN54(FUN44(VAR173, 32))
VAR169 := FUN54(FUN44(VAR173, 64))
VAR167 := FUN40(0, FUN54(FUN44(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN55(VAR166, VAR167, VAR168, VAR169);
}
}
contract Dice is VAR20 {
uint constant VAR174 = 190;
uint constant VAR175 = 100;
uint constant VAR176 = 10 VAR177;
uint VAR178 = 2300;
uint constant VAR179 = 175000;
uint constant VAR180 = 99999;
struct VAR181 {
address VAR182;
uint VAR183;
bool VAR184;
}
struct VAR185 {
address VAR186;
uint VAR187;
uint VAR188;
uint VAR189;
}
struct VAR190 {
address VAR191;
uint VAR192;
}
address public VAR193;
mapping (bytes32 => VAR185) public VAR194;
bytes32[] public VAR195;
uint public VAR196 = 0;
uint public VAR197 = 0;
uint public VAR198 = 0;
uint public VAR199 = 0;
bool public VAR200 = false;
event FUN62(address VAR186, uint VAR201, uint VAR189, bytes32 VAR47);
event FUN63(address VAR186, uint VAR188, uint VAR199, bytes32 VAR47);
event FUN64(address VAR186, uint VAR188, uint VAR202, bytes32 VAR47);
event FUN65(address VAR203, uint VAR201);
event FUN66();
event FUN67(address VAR204, address VAR205);
event FUN68(uint VAR206, uint VAR207);
event FUN69();
event FUN70(address VAR171, uint VAR201);
event FUN71(uint VAR201);
event FUN72(address VAR171, uint VAR201);
event FUN73(uint VAR208);
function FUN74() {
VAR193 = msg.sender;
FUN15(VAR30);
}
modifier onlyOwner {
if (VAR193 != msg.sender) throw;
VAR38;
}
modifier VAR209 {
if (VAR200) throw;
VAR38;
}
modifier VAR210 {
if (msg.sender != FUN26()) throw;
VAR38;
}
modifier FUN75(bytes32 VAR41) {
if(VAR194[VAR41].VAR186 == address(0x0)) throw;
VAR38;
}
modifier FUN76(bytes32 VAR41, uint VAR189) {
if ((((VAR194[VAR41].VAR187 * ((10000 - VAR174) - VAR189)) / VAR189 ) <= FUN77())  && (VAR194[VAR41].VAR187 >= VAR176)) {
VAR38;
}
else {
VAR194[VAR41].VAR188 = VAR180;
FUN78(VAR194[VAR41].VAR186, VAR194[VAR41].VAR187);
return;
}
}
modifier FUN79(bytes32 VAR41, string VAR42) {
uint VAR188 = FUN38(VAR42);
if ((VAR188 < 1 || VAR188 > 10000) && VAR194[VAR41].VAR188 == 0) {
VAR194[VAR41].VAR188 = VAR180;
FUN78(VAR194[VAR41].VAR186, VAR194[VAR41].VAR187);
return;
}
VAR38;
}
modifier FUN80(uint VAR188, uint VAR189) {
if (VAR188 - 1 < VAR189) {
VAR38;
}
}
modifier FUN81(uint VAR188, uint VAR189) {
if (VAR188 - 1 >= VAR189) {
VAR38;
}
}
modifier FUN82(uint VAR207) {
if (VAR179 + VAR207 < VAR179) throw;
if (VAR207 < 25000) throw;
VAR38;
}
modifier FUN83(bytes32 VAR41) {
if (VAR194[VAR41].VAR188 > 0) throw;
VAR38;
}
function FUN77() constant returns(uint) {
return this.VAR211;
}
function FUN84(uint VAR47)
constant
returns(address, uint, uint) {
if (VAR47 < VAR195.VAR79) {
bytes32 VAR212 = VAR195[VAR47];
return (VAR194[VAR212].VAR186, VAR194[VAR212].VAR187, VAR194[VAR212].VAR188);
}
}
function FUN85()
constant
returns(uint) {
return VAR195.VAR79;
}
function FUN86() constant returns (uint) {
return VAR199;
}
function FUN78(address VAR171, uint value)
private {
if (value == 0) {
FUN66();
return;
}
if (this.VAR211 < value) {
FUN69();
return;
}
if (!(VAR171.call.FUN87(VAR178).value(value)())) {
FUN65(VAR171, value);
if (VAR171 != VAR193) {
if (!(VAR193.call.FUN87(VAR178).value(value)())) FUN65(VAR193, value);
}
}
FUN70(VAR171,value);
}
function() payable {
FUN88(5000);
}
function FUN88(uint VAR189) payable public VAR209 {
uint VAR213 = FUN16(VAR35.FUN13()).FUN7("", VAR179 + VAR178);
if (VAR213 >= msg.value) throw;
uint VAR214 = msg.value - VAR213;
if ((((VAR214 * (10000 - VAR174)) / VAR189) <= (FUN77()) / 30) && (VAR214 >= VAR176)) {
bytes32 VAR41 =
FUN23("",
"[VAR215] ['FUN89(VAR216:
FUN62(msg.sender, VAR214, VAR189, VAR41);
VAR194[VAR41] = FUN90(msg.sender, VAR214, 0, VAR189);
VAR195.FUN91(VAR41);
VAR198 += 1;
}
else {
throw;
}
}
function FUN20(bytes32 VAR41, string VAR42, bytes VAR44)
VAR210
FUN75(VAR41)
FUN83(VAR41)
FUN79(VAR41, VAR42)
FUN76(VAR41, VAR194[VAR41].VAR189)  {
uint VAR188 = FUN38(VAR42);
VAR194[VAR41].VAR188 = VAR188;
FUN92(VAR194[VAR41], VAR188, VAR41);
FUN93(VAR194[VAR41], VAR188, VAR41);
}
function FUN92(Bet VAR217, uint VAR188, bytes32 VAR41) private FUN80(VAR188, VAR217.VAR189) {
uint VAR218 = (VAR217.VAR187 * (10000 - VAR174)) / VAR217.VAR189;
FUN63(VAR217.VAR186, VAR188, VAR218, VAR41 );
FUN78(VAR217.VAR186, VAR218);
if ((VAR197 + VAR218 < VAR197) ||
(VAR197 + VAR218 < VAR217.VAR187)) {
throw;
}
VAR199 += VAR218;
VAR197 += VAR218 - VAR217.VAR187;
}
function FUN93(Bet VAR217, uint VAR188, bytes32 VAR41) private FUN81(VAR188, VAR217.VAR189) {
FUN64(VAR217.VAR186, VAR188, VAR217.VAR187, VAR41);
FUN78(VAR217.VAR186, 1);
if ((VAR196 + VAR217.VAR187 < VAR196) ||
(VAR196 + VAR217.VAR187 < VAR217.VAR187) ||
(VAR217.VAR187 == 1)) {
throw;
}
VAR196 += (VAR217.VAR187 - 1);
}
function FUN94() payable public
onlyOwner
VAR209 {
FUN71(msg.value);
}
function FUN95(uint value) public onlyOwner {
FUN78(VAR193, value);
FUN72(VAR193, value);
}
function FUN96() public onlyOwner {
uint value = VAR196 - VAR197;
FUN78(VAR193, value);
VAR196 = 0;
VAR197 = 0;
}
function FUN97(address VAR219) onlyOwner {
if (VAR219 == address(0x0)) throw;
VAR193 = VAR219;
FUN67(VAR193, VAR219);
}
function FUN98(uint VAR207) onlyOwner FUN82(VAR207) {
VAR178 = VAR207;
FUN68(VAR178, VAR207);
}
function FUN99() public onlyOwner {
VAR200 = true;
FUN100(VAR193);
}
}
1
---------------------------------
159 0x9eead2301792af12115d125c48966246e5b455a1.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function FUN1(bytes32 VAR3) constant returns(address);
function FUN2(bytes32 VAR3) constant returns(address);
function FUN3(bytes32 VAR3) constant returns(VAR4);
function FUN4(bytes32 VAR3, address VAR5);
function FUN5(bytes32 VAR3, bytes32 VAR6, address VAR5);
function FUN6(bytes32 VAR3, address VAR7);
function FUN7(bytes32 VAR3, uint64 VAR8);
event FUN8(bytes32 indexed VAR3, bytes32 indexed VAR6, address VAR5);
event Transfer(bytes32 indexed VAR3, address VAR5);
event FUN9(bytes32 indexed VAR3, address VAR7);
event FUN10(bytes32 indexed VAR3, uint64 VAR8);
}
contract ENS is VAR2 {
struct VAR9 {
address VAR5;
address VAR7;
uint64 VAR8;
}
mapping(bytes32=>VAR9) VAR10;
modifier only_owner(bytes32 VAR3) {
if(VAR10[VAR3].VAR5 != msg.sender) throw;
VAR11;
}
function FUN11() {
VAR10[0].VAR5 = msg.sender;
}
function FUN1(bytes32 VAR3) constant returns (address) {
return VAR10[VAR3].VAR5;
}
function FUN2(bytes32 VAR3) constant returns (address) {
return VAR10[VAR3].VAR7;
}
function FUN3(bytes32 VAR3) constant returns (VAR4) {
return VAR10[VAR3].VAR8;
}
function FUN4(bytes32 VAR3, address VAR5) only_owner(VAR3) {
Transfer(VAR3, VAR5);
VAR10[VAR3].VAR5 = VAR5;
}
function FUN5(bytes32 VAR3, bytes32 VAR6, address VAR5) only_owner(VAR3) {
var VAR12 = FUN12(VAR3, VAR6);
FUN8(VAR3, VAR6, VAR5);
VAR10[VAR12].VAR5 = VAR5;
}
function FUN6(bytes32 VAR3, address VAR7) only_owner(VAR3) {
FUN9(VAR3, VAR7);
VAR10[VAR3].VAR7 = VAR7;
}
function FUN7(bytes32 VAR3, uint64 VAR8) only_owner(VAR3) {
FUN10(VAR3, VAR8);
VAR10[VAR3].VAR8 = VAR8;
}
}
contract VAR13 {
address public VAR14;
address constant VAR15 = 0xdead;
uint public VAR16;
address public VAR5;
address public VAR17;
uint public value;
event FUN13(address VAR18);
event FUN14();
bool VAR19;
modifier VAR20 {
if (msg.sender != VAR14) throw;
VAR11;
}
modifier VAR21 {
if (!VAR19) throw;
VAR11;
}
function FUN15(address VAR22) payable {
VAR5 = VAR22;
VAR14 = msg.sender;
VAR16 = VAR23;
VAR19 = true;
value = msg.value;
}
function FUN4(address VAR18) VAR20 {
if (VAR18 == 0) throw;
VAR17 = VAR5;
VAR5 = VAR18;
FUN13(VAR18);
}
function FUN16(address VAR24) VAR20 {
VAR14 = VAR24;
}
function FUN17(uint VAR25, bool VAR26) onlyRegistrar VAR21 {
if (value < VAR25) throw;
value = VAR25;
if (!VAR5.FUN18(this.VAR27 - VAR25) && VAR26) throw;
}
function FUN19(uint VAR28) onlyRegistrar VAR21 {
VAR19 = false;
if (! VAR15.FUN18(((1000 - VAR28) * this.VAR27)/1000)) throw;
FUN14();
FUN20();
}
function FUN20() {
if (VAR19) throw;
if(VAR5.FUN18(this.VAR27)) {
FUN21(VAR15);
}
}
}
contract VAR29 {
AbstractENS public VAR30;
bytes32 public VAR31;
mapping (bytes32 => VAR32) VAR33;
mapping (address => mapping(bytes32 => VAR13)) public VAR34;
enum VAR35 { VAR36, VAR37, VAR38, VAR39, VAR40, VAR41 }
uint32 constant VAR42 = 5 VAR43;
uint32 constant VAR44 = 3 VAR43;
uint32 public constant VAR45 = 0 VAR43;
uint constant VAR46 = 0.01 VAR47;
uint public VAR48;
event FUN22(bytes32 indexed VAR49, uint VAR50);
event FUN23(bytes32 indexed VAR49, address indexed VAR51, uint VAR52);
event FUN24(bytes32 indexed VAR49, address indexed VAR5, uint value, uint8 VAR53);
event FUN25(bytes32 indexed VAR49, address indexed VAR5, uint value, uint VAR50);
event FUN26(bytes32 indexed VAR49, uint value);
event FUN27(bytes32 indexed VAR49, string indexed VAR54, uint value, uint VAR50);
struct VAR32 {
Deed VAR55;
uint VAR50;
uint value;
uint VAR56;
}
function FUN28(bytes32 VAR57) constant returns (VAR35) {
var VAR32 = VAR33[VAR57];
if(!FUN29(VAR57, VAR23)) {
return VAR35.VAR41;
} else if(VAR23 < VAR32.VAR50) {
if (VAR23 < VAR32.VAR50 - VAR44) {
return VAR35.VAR37;
} else {
return VAR35.VAR40;
}
} else {
if(VAR32.VAR56 == 0) {
return VAR35.VAR36;
} else {
return VAR35.VAR38;
}
}
}
modifier FUN30(bytes32 VAR57, Mode VAR58) {
if(FUN28(VAR57) != VAR58) throw;
VAR11;
}
modifier onlyOwner(bytes32 VAR57) {
if (FUN28(VAR57) != VAR35.VAR38 || msg.sender != VAR33[VAR57].VAR55.FUN1()) throw;
VAR11;
}
modifier FUN31() {
if(VAR23 < VAR48  || VAR23 > VAR48 + 4 VAR59 || VAR30.FUN1(VAR31) != address(this)) throw;
VAR11;
}
function FUN32(bytes32 VAR57) constant returns (VAR35, address, uint, uint, uint) {
entry VAR60 = VAR33[VAR57];
return (FUN28(VAR57), VAR60.VAR55, VAR60.VAR50, VAR60.value, VAR60.VAR56);
}
function FUN33(AbstractENS VAR61, bytes32 VAR62, uint VAR63) {
VAR30 = VAR61;
VAR31 = VAR62;
VAR48 = VAR63 > 0 ? VAR63 : VAR23;
}
function FUN34(uint VAR64, uint VAR65) internal constant returns (uint VAR66) {
if (VAR64 > VAR65)
return VAR64;
else
return VAR65;
}
function FUN35(uint VAR64, uint VAR65) internal constant returns (uint VAR67) {
if (VAR64 < VAR65)
return VAR64;
else
return VAR65;
}
function FUN36(string VAR68) internal constant returns (uint) {
uint VAR69;
uint VAR70;
VAR71 {
VAR69 := FUN37(VAR68, 1)
VAR70 := FUN37(FUN38(VAR68), VAR69)
}
for (uint VAR72 = 0; VAR69 < VAR70; VAR72++) {
uint8 VAR65;
VAR71 { VAR65 := FUN39(FUN38(VAR69), 0xFF) }
if (VAR65 < 0x80) {
VAR69 += 1;
} else if(VAR65 < 0xE0) {
VAR69 += 2;
} else if(VAR65 < 0xF0) {
VAR69 += 3;
} else if(VAR65 < 0xF8) {
VAR69 += 4;
} else if(VAR65 < 0xFC) {
VAR69 += 5;
} else {
VAR69 += 6;
}
}
return VAR72;
}
function FUN29(bytes32 VAR57, uint VAR73) constant returns (bool VAR74){
return VAR73 > FUN40(VAR57);
}
function FUN40(bytes32 VAR57) constant returns (uint VAR75) {
return VAR48 + (VAR45*(uint(VAR57)>>128)>>128);
}
function FUN41(bytes32 VAR57, address VAR76) internal {
if(VAR30.FUN1(VAR31) == address(this))
VAR30.FUN5(VAR31, VAR57, VAR76);
}
function FUN42(bytes32 VAR57) FUN31() {
var VAR77 = FUN28(VAR57);
if(VAR77 == VAR35.VAR37) return;
if(VAR77 != VAR35.VAR36) throw;
entry VAR78 = VAR33[VAR57];
VAR78.VAR50 = VAR23 + VAR42;
VAR78.value = 0;
VAR78.VAR56 = 0;
FUN22(VAR57, VAR78.VAR50);
}
function FUN43(bytes32[] VAR79)  {
for (uint VAR80 = 0; VAR80 < VAR79.VAR81; VAR80 ++ ) {
FUN42(VAR79[VAR80]);
}
}
function FUN44(bytes32 VAR49, address VAR5, uint value, bytes32 VAR82) constant returns (bytes32 VAR83) {
return FUN12(VAR49, VAR5, value, VAR82);
}
function FUN45(bytes32 VAR83) payable {
if (address(VAR34[msg.sender][VAR83]) > 0 ) throw;
if (msg.value < VAR46) throw;
Deed VAR84 = (new VAR13).value(msg.value)(msg.sender);
VAR34[msg.sender][VAR83] = VAR84;
FUN23(VAR83, msg.sender, msg.value);
}
function FUN46(bytes32[] VAR85, bytes32 VAR83) payable {
FUN43(VAR85);
FUN45(VAR83);
}
function FUN47(bytes32 VAR57, uint VAR86, bytes32 VAR87) {
bytes32 VAR88 = FUN44(VAR57, msg.sender, VAR86, VAR87);
Deed VAR89 = VAR34[msg.sender][VAR88];
if (address(VAR89) == 0 ) throw;
VAR34[msg.sender][VAR88] = FUN15(0);
entry VAR60 = VAR33[VAR57];
uint value = FUN35(VAR86, VAR89.value());
VAR89.FUN17(value, true);
var VAR90 = FUN28(VAR57);
if(VAR90 == VAR35.VAR38) {
VAR89.FUN19(5);
FUN24(VAR57, msg.sender, value, 1);
} else if(VAR90 != VAR35.VAR40) {
throw;
} else if (value < VAR46 || VAR89.FUN48() > VAR60.VAR50 - VAR44) {
VAR89.FUN19(995);
FUN24(VAR57, msg.sender, value, 0);
} else if (value > VAR60.VAR56) {
if(address(VAR60.VAR55) != 0) {
Deed VAR91 = VAR60.VAR55;
VAR91.FUN19(995);
}
VAR60.value = VAR60.VAR56;
VAR60.VAR56 = value;
VAR60.VAR55 = VAR89;
FUN24(VAR57, msg.sender, value, 2);
} else if (value > VAR60.value) {
VAR60.value = value;
VAR89.FUN19(995);
FUN24(VAR57, msg.sender, value, 3);
} else {
VAR89.FUN19(995);
FUN24(VAR57, msg.sender, value, 4);
}
}
function FUN49(address VAR51, bytes32 VAR88) {
Deed VAR89 = VAR34[VAR51][VAR88];
if (address(VAR89) == 0
|| VAR23 < VAR89.FUN48() + VAR42 + 2 VAR92) throw;
VAR89.FUN4(msg.sender);
VAR89.FUN19(5);
VAR34[VAR51][VAR88] = FUN15(0);
FUN24(VAR88, VAR51, 0, 5);
}
function FUN50(bytes32 VAR57) onlyOwner(VAR57) {
entry VAR60 = VAR33[VAR57];
VAR60.value =  FUN34(VAR60.value, VAR46);
VAR60.VAR55.FUN17(VAR60.value, true);
FUN41(VAR57, VAR60.VAR55.FUN1());
FUN25(VAR57, VAR60.VAR55.FUN1(), VAR60.value, VAR60.VAR50);
}
function transfer(bytes32 VAR57, address VAR18) onlyOwner(VAR57) {
if (VAR18 == 0) throw;
entry VAR60 = VAR33[VAR57];
VAR60.VAR55.FUN4(VAR18);
FUN41(VAR57, VAR18);
}
function FUN51(bytes32 VAR57) onlyOwner(VAR57) {
entry VAR60 = VAR33[VAR57];
Deed VAR93 = VAR60.VAR55;
if(VAR23 < VAR60.VAR50 + 1 VAR59 && VAR30.FUN1(VAR31) == address(this)) throw;
VAR60.value = 0;
VAR60.VAR56 = 0;
VAR60.VAR55 = FUN15(0);
FUN52(VAR57);
VAR93.FUN19(1000);
FUN26(VAR57, VAR60.value);
}
function FUN53(string VAR94) FUN30(FUN12(VAR94), VAR35.VAR38) {
if (FUN36(VAR94) > 6 ) throw;
bytes32 VAR49 = FUN12(VAR94);
entry VAR60 = VAR33[VAR49];
FUN52(VAR49);
if(address(VAR60.VAR55) != 0) {
VAR60.value = FUN34(VAR60.value, VAR46);
VAR60.VAR55.FUN17(VAR60.value/2, false);
VAR60.VAR55.FUN4(msg.sender);
VAR60.VAR55.FUN19(1000);
}
FUN27(VAR49, VAR94, VAR60.value, VAR60.VAR50);
VAR60.value = 0;
VAR60.VAR56 = 0;
VAR60.VAR55 = FUN15(0);
}
function FUN54(bytes32[] VAR95) {
if(VAR95.VAR81 == 0) throw;
if(FUN28(VAR95[VAR95.VAR81 - 1]) == VAR35.VAR38) throw;
FUN55(VAR95.VAR81 - 1, VAR95, VAR31);
}
function FUN52(bytes32 VAR6) internal {
if(VAR30.FUN1(VAR31) == address(this)) {
VAR30.FUN5(VAR31, VAR6, address(this));
var VAR3 = FUN12(VAR31, VAR6);
VAR30.FUN6(VAR3, 0);
VAR30.FUN4(VAR3, 0);
}
}
function FUN55(uint VAR96, bytes32[] VAR95, bytes32 VAR3) internal {
VAR30.FUN5(VAR3, VAR95[VAR96], address(this));
VAR3 = FUN12(VAR3, VAR95[VAR96]);
if(VAR96 > 0)
FUN55(VAR96 - 1, VAR95, VAR3);
VAR30.FUN6(VAR3, 0);
VAR30.FUN4(VAR3, 0);
}
function FUN56(bytes32 VAR57) onlyOwner(VAR57) {
var VAR14 = VAR30.FUN1(VAR31);
if(VAR14 == address(this))
throw;
entry VAR60 = VAR33[VAR57];
VAR60.VAR55.FUN16(VAR14);
FUN33(VAR14).FUN57(VAR57, VAR60.VAR55, VAR60.VAR50);
VAR60.VAR55 = FUN15(0);
VAR60.VAR50 = 0;
VAR60.value = 0;
VAR60.VAR56 = 0;
}
function FUN57(bytes32 VAR49, Deed VAR55, uint VAR50) {}
}
contract VAR97 {
address public VAR5;
event FUN58(address indexed VAR17, address indexed VAR18);
function FUN59() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR11;
}
function FUN60(address VAR18) public onlyOwner {
require(VAR18 != address(0));
FUN58(VAR5, VAR18);
VAR5 = VAR18;
}
}
contract Whitelist is VAR97 {
mapping(address => bool) public VAR98;
event FUN61(address VAR99);
event FUN62(address VAR99);
modifier FUN63() {
require(VAR98[msg.sender]);
VAR11;
}
function FUN64(address VAR99) onlyOwner public returns(bool VAR100) {
if (!VAR98[VAR99]) {
VAR98[VAR99] = true;
FUN61(VAR99);
VAR100 = true;
}
}
function FUN65(address[] VAR101) onlyOwner public returns(bool VAR100) {
for (uint256 VAR80 = 0; VAR80 < VAR101.VAR81; VAR80++) {
if (FUN64(VAR101[VAR80])) {
VAR100 = true;
}
}
}
function FUN66(address VAR99) onlyOwner public returns(bool VAR100) {
if (VAR98[VAR99]) {
VAR98[VAR99] = false;
FUN62(VAR99);
VAR100 = true;
}
}
function FUN67(address[] VAR101) onlyOwner public returns(bool VAR100) {
for (uint256 VAR80 = 0; VAR80 < VAR101.VAR81; VAR80++) {
if (FUN66(VAR101[VAR80])) {
VAR100 = true;
}
}
}
}
contract BedOracleV1 is VAR102 {
struct VAR103 {
uint value;
uint VAR104;
bytes32 VAR49;
address VAR5;
}
Registrar internal VAR105;
uint internal VAR106;
mapping (bytes32 => VAR103) internal VAR107;
event FUN68(address indexed VAR5, bytes32 indexed VAR108, bytes8 indexed VAR109, bytes VAR110);
event FUN69(bytes32 indexed VAR108);
event FUN70(bytes32 indexed VAR108);
event FUN71(address indexed VAR111, uint value);
function() external payable {}
constructor(address VAR112) public {
VAR105 = FUN33(VAR112);
}
function FUN37(bytes32 VAR113, uint VAR104, bytes VAR114, bytes8 VAR115)
external payable
{
require(VAR107[VAR113].VAR5 == 0);
require(msg.value > 0.01 VAR47 + VAR104);
VAR107[VAR113] = FUN72(
msg.value - VAR104,
VAR104,
bytes32(0),
msg.sender
);
emit FUN68(msg.sender, VAR113, VAR115, VAR114);
}
function FUN73(bytes32 VAR113) external VAR116 {
Bid storage VAR65 = VAR107[VAR113];
VAR105.VAR84.value(VAR65.value)(VAR113);
}
function FUN74(bytes32 VAR57, uint VAR86, bytes32 VAR87) external {
VAR107[FUN75(VAR57, this, VAR86, VAR87)].VAR49 = VAR57;
VAR105.FUN47(VAR57, VAR86, VAR87);
}
function FUN76(bytes32 VAR113) external {
Bid storage VAR65 = VAR107[VAR113];
bytes32 VAR3 = FUN75(VAR105.FUN77(), VAR65.VAR49);
VAR105.FUN50(VAR65.VAR49);
FUN11(VAR105.FUN78()).FUN6(VAR3, address(0));
VAR105.transfer(VAR65.VAR49, VAR65.VAR5);
VAR65.value = 0;
VAR106 += VAR65.VAR104;
VAR65.VAR104 = 0;
emit FUN69(VAR113);
}
function FUN79(bytes32 VAR113) external VAR116 {
Bid storage VAR65 = VAR107[VAR113];
require(VAR105.FUN28(VAR65.VAR49) == VAR29.VAR35.VAR38);
VAR65.VAR5.transfer(VAR65.value);
VAR65.value = 0;
VAR106 += VAR65.VAR104;
VAR65.VAR104 = 0;
emit FUN70(VAR113);
}
function FUN80(bytes32 VAR113)
external view returns (uint, uint, bytes32, address)
{
Bid storage VAR65 = VAR107[VAR113];
return (VAR65.value, VAR65.VAR104, VAR65.VAR49, VAR65.VAR5);
}
function FUN16(address VAR117) external onlyOwner {
VAR105 = FUN33(VAR117);
}
function FUN81() external VAR116 {
msg.sender.transfer(VAR106);
emit FUN71(msg.sender, VAR106);
VAR106 = 0;
}
}
1
---------------------------------
160 0x9ef74f01c70c80f008b51ae434e56ee79b6f4016.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 VAR5) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR7, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR8, address VAR9)
public view returns (uint256);
function FUN4(address VAR10, address VAR4, uint256 VAR5)
public returns (bool);
function FUN5(address VAR9, uint256 VAR5) public returns (bool);
event FUN6(
address indexed VAR11,
address indexed VAR12,
uint256 value
);
}
contract IBasicMultiToken is VAR13 {
event FUN7(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN8(address indexed VAR14, address indexed VAR15, uint256 value);
function FUN9() public view returns(uint256);
function FUN10(uint VAR16) public view returns(VAR13);
function FUN11() public view returns(bool);
function FUN12(address VAR17, uint256 VAR18, uint256[] VAR19) public;
function FUN13(address VAR17, uint256 VAR18) public;
function FUN14(address VAR17, uint256 VAR5) public;
function FUN15(address VAR17, uint256 VAR5, VAR13[] VAR20) public;
function FUN16() public;
function FUN17() public;
bytes4 public constant VAR21 = 0xd5c368b6;
}
contract IMultiToken is VAR22 {
event FUN18();
event FUN19(address indexed VAR23, address indexed VAR24, address indexed VAR25, uint256 VAR18, uint256 VAR26);
function FUN20(address VAR27) public view returns(uint256);
function FUN21() public view returns(bool);
function FUN22(address VAR23, address VAR24, uint256 VAR18) public view returns (uint256 VAR28);
function FUN23(address VAR23, address VAR24, uint256 VAR18, uint256 VAR29) public returns (uint256 VAR28);
function FUN24() public;
bytes4 public constant VAR30 = 0x81624e24;
}
library VAR31 {
function FUN25(uint256 VAR32, uint256 VAR33) internal pure returns (uint256 VAR34) {
if (VAR32 == 0) {
return 0;
}
VAR34 = VAR32 * VAR33;
assert(VAR34 / VAR32 == VAR33);
return VAR34;
}
function FUN26(uint256 VAR32, uint256 VAR33) internal pure returns (uint256) {
return VAR32 / VAR33;
}
function FUN27(uint256 VAR32, uint256 VAR33) internal pure returns (uint256) {
assert(VAR33 <= VAR32);
return VAR32 - VAR33;
}
function FUN28(uint256 VAR32, uint256 VAR33) internal pure returns (uint256 VAR34) {
VAR34 = VAR32 + VAR33;
assert(VAR34 >= VAR32);
return VAR34;
}
}
library VAR35 {
using SafeMath for uint;
function FUN29(address VAR36) internal view returns(bool VAR37) {
VAR38 {
VAR37 := FUN30(FUN31(VAR36), 0)
}
}
function FUN32() internal pure returns(bool VAR37) {
VAR38 {
switch FUN33()
case 0 {
VAR37 := 1
}
case 32 {
FUN34(0, 0, 32)
VAR37 := FUN35(0)
}
default {
revert(0, 0)
}
}
}
function FUN36() internal pure returns(bytes32 VAR37) {
VAR38 {
switch FUN37(FUN33(), 32)
case 1 {
FUN34(0, 0, 32)
VAR37 := FUN35(0)
}
switch FUN30(FUN33(), 32)
case 1 {
FUN34(0, 64, 32)
VAR37 := FUN35(0)
}
switch FUN38(FUN33(), 32)
case 1 {
revert(0, 0)
}
}
}
function FUN39(address VAR39, address VAR7, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR7, value));
return FUN32();
}
function FUN41(address VAR39, address VAR6, address VAR7, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR6, VAR7, value));
return FUN32();
}
function FUN42(address VAR39, address VAR12, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR12, value));
return FUN32();
}
//
function FUN43(ERC20 VAR39, address VAR7, uint256 value) internal {
if (value > 0) {
uint256 VAR40 = VAR39.FUN2(this);
FUN39(VAR39, VAR7, value);
require(VAR39.FUN2(this) == VAR40.FUN27(value), "");
}
}
function FUN44(ERC20 VAR39, address VAR6, address VAR7, uint256 value) internal {
if (value > 0) {
uint256 VAR41 = VAR39.FUN2(VAR7);
FUN41(VAR39, VAR6, VAR7, value);
require(VAR39.FUN2(VAR7) == VAR41.FUN28(value), "");
}
}
//
function FUN45(address VAR39) internal view returns(bytes32) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40(""))));
return FUN36();
}
function FUN46(address VAR39) internal view returns(bytes32) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40(""))));
return FUN36();
}
}
library VAR42 {
function FUN47(address VAR43, uint value, bytes VAR44, uint VAR45, uint VAR46) internal returns(bool VAR37) {
VAR38 {
let VAR47 := FUN35(0x40)
let VAR48 := FUN28(VAR44, 32)
VAR37 := call(
FUN27(VAR49, 34710),
VAR43,
value,
FUN28(VAR48, VAR45),
VAR46,
VAR47,
0
)
}
}
}
contract IEtherToken is VAR13 {
function FUN48() public payable;
function FUN49(uint256 VAR50) public;
}
contract VAR51 {
using SafeMath for uint256;
using CheckedERC20 for VAR13;
using ExternalCall for address;
function FUN23(bytes VAR52, uint[] VAR53) public payable {
for (uint VAR16 = 0; VAR16 < VAR53.VAR54 - 1; VAR16++) {
require(address(this).FUN47(0, VAR52, VAR53[VAR16], VAR53[VAR16 + 1] - VAR53[VAR16]));
}
}
function FUN50(address VAR55, uint256 value) external {
require(VAR55.call.value(value)());
}
function FUN51(address VAR55, uint256 VAR56, uint256 VAR57) external {
uint256 value = address(this).VAR40.FUN25(VAR56).FUN26(VAR57);
require(VAR55.call.value(value)());
}
function FUN52(IEtherToken VAR58, uint256 VAR50) external {
VAR58.VAR59.value(VAR50)();
}
function FUN53(IEtherToken VAR58, uint256 VAR56, uint256 VAR57) external {
uint256 VAR50 = address(this).VAR40.FUN25(VAR56).FUN26(VAR57);
VAR58.VAR59.value(VAR50)();
}
function FUN54(IEtherToken VAR58, uint256 VAR50) external {
VAR58.FUN49(VAR50);
}
function FUN55(IEtherToken VAR58, uint256 VAR56, uint256 VAR57) external {
uint256 VAR50 = VAR58.FUN2(this).FUN25(VAR56).FUN26(VAR57);
VAR58.FUN49(VAR50);
}
function FUN56(address VAR55, ERC20 VAR60, uint256 VAR50) external {
require(VAR60.FUN39(VAR55, VAR50));
}
function FUN57(address VAR55, ERC20 VAR60, uint256 VAR56, uint256 VAR57) external {
uint256 VAR50 = VAR60.FUN2(this).FUN25(VAR56).FUN26(VAR57);
require(VAR60.FUN39(VAR55, VAR50));
}
function FUN58(ERC20 VAR60, uint256 VAR50) external {
require(VAR60.FUN41(VAR61.VAR62, this, VAR50));
}
function FUN59(ERC20 VAR60, uint256 VAR56, uint256 VAR57) external {
uint256 VAR50 = VAR60.FUN2(this).FUN25(VAR56).FUN26(VAR57);
require(VAR60.FUN41(VAR61.VAR62, this, VAR50));
}
function FUN60(IMultiToken VAR63, ERC20 VAR60, ERC20 VAR64, uint256 VAR65, uint256 VAR50) external {
if (VAR60.FUN3(this, VAR63) == 0) {
VAR60.FUN42(VAR63, uint256(-1));
}
VAR63.FUN23(VAR60, VAR64, VAR50, VAR65);
}
function FUN61(IMultiToken VAR63, ERC20 VAR60, ERC20 VAR64, uint256 VAR65, uint256 VAR56, uint256 VAR57) external {
uint256 VAR50 = VAR60.FUN2(this).FUN25(VAR56).FUN26(VAR57);
this.FUN60(VAR63, VAR60, VAR64, VAR65, VAR50);
}
}
1
---------------------------------
161 0x9f295a8a492f31572f88b853b800c75dc8cb6cc3.sol
pragma VAR1 ^0.4.19;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
function FUN6() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract VAR11 {
uint256 public VAR12;
function FUN8(address VAR13) public view returns (uint256);
function transfer(address VAR14, uint256 value) public returns (bool);
event Transfer(address indexed VAR15, address indexed VAR14, uint256 value);
}
contract BasicToken is VAR11 {
using SafeMath for uint256;
mapping(address => uint256) VAR16;
function transfer(address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
require(VAR18 <= VAR16[msg.sender]);
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR18);
Transfer(msg.sender, VAR17, VAR18);
return true;
}
function FUN8(address VAR19) public view returns (uint256 VAR20) {
return VAR16[VAR19];
}
}
contract ERC20 is VAR11 {
function FUN9(address VAR7, address VAR21) public view returns (uint256);
function FUN10(address VAR15, address VAR14, uint256 value) public returns (bool);
function FUN11(address VAR21, uint256 value) public returns (bool);
event FUN12(address indexed VAR7, address indexed VAR21, uint256 value);
}
contract StandardToken is VAR22, VAR23 {
mapping (address => mapping (address => uint256)) internal VAR24;
function FUN10(address VAR25, address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
require(VAR18 <= VAR16[VAR25]);
require(VAR18 <= VAR24[VAR25][msg.sender]);
VAR16[VAR25] = VAR16[VAR25].FUN3(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR18);
VAR24[VAR25][msg.sender] = VAR24[VAR25][msg.sender].FUN3(VAR18);
Transfer(VAR25, VAR17, VAR18);
return true;
}
function FUN11(address VAR26, uint256 VAR18) public returns (bool) {
VAR24[msg.sender][VAR26] = VAR18;
FUN12(msg.sender, VAR26, VAR18);
return true;
}
function FUN9(address VAR19, address VAR26) public view returns (uint256) {
return VAR24[VAR19][VAR26];
}
function FUN13(address VAR26, uint VAR27) public returns (bool) {
VAR24[msg.sender][VAR26] = VAR24[msg.sender][VAR26].FUN4(VAR27);
FUN12(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
function FUN14(address VAR26, uint VAR28) public returns (bool) {
uint VAR29 = VAR24[msg.sender][VAR26];
if (VAR28 > VAR29) {
VAR24[msg.sender][VAR26] = 0;
} else {
VAR24[msg.sender][VAR26] = VAR29.FUN3(VAR28);
}
FUN12(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
}
contract MintableToken is VAR30, VAR6 {
event FUN15(address indexed VAR14, uint256 VAR31);
event FUN16();
bool public VAR32 = false;
modifier FUN17() {
require(!VAR32);
VAR10;
}
function FUN18(address VAR17, uint256 VAR33) onlyOwner canMint public returns (bool) {
VAR12 = VAR12.FUN4(VAR33);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR33);
FUN15(VAR17, VAR33);
Transfer(address(0), VAR17, VAR33);
return true;
}
function FUN19() onlyOwner canMint public returns (bool) {
VAR32 = true;
FUN16();
return true;
}
}
contract TokensGate is VAR34 {
event FUN20(address indexed VAR35, uint256 value);
string public constant VAR36 = "";
string public constant VAR37 = "";
uint8 public constant VAR38 = 18;
bool public VAR39 = false;
bool public VAR40 = false;
bool public VAR41 = false;
mapping(address => uint256) public VAR42;
mapping(address => uint256) public VAR43;
mapping(address => bool) public VAR44;
mapping(address => bool) public VAR45;
function FUN21(address VAR25, address VAR17) public view returns (bool) {
if (VAR44[VAR25])
return true;
if (VAR43[VAR25] > VAR46)
return false;
if (!VAR39) {
if (VAR40 && VAR42[VAR25] != 0 && VAR42[VAR17] != 0 && VAR42[VAR25] < VAR46 && VAR42[VAR17] < VAR46)
return true;
if (VAR41 && VAR42[VAR25] != 0 && VAR42[VAR25] < VAR46)
return true;
return false;
}
return true;
}
function FUN22() public view returns (bool) {
if (msg.sender == VAR7)
return true;
if (VAR45[msg.sender])
return true;
return false;
}
function transfer(address VAR17, uint256 VAR18) public returns (bool) {
require(FUN21(msg.sender, VAR17));
return super.transfer(VAR17, VAR18);
}
function FUN10(address VAR25, address VAR17, uint256 VAR18) public returns (bool) {
require(FUN21(VAR25, VAR17));
return super.FUN10(VAR25, VAR17, VAR18);
}
function FUN18(address VAR17, uint256 VAR33) onlyOwner canMint public returns (bool) {
require(VAR12.FUN4(VAR33) < 1000000000000000000000000000);
return super.FUN18(VAR17, VAR33);
}
function FUN23(address VAR47, uint256 VAR18) onlyOwner public {
require(VAR18 <= VAR16[VAR47]);
VAR16[VAR47] = VAR16[VAR47].FUN3(VAR18);
VAR12 = VAR12.FUN3(VAR18);
FUN20(VAR47, VAR18);
Transfer(VAR47, address(0), VAR18);
}
function FUN24(address VAR48, bool VAR49) onlyOwner public {
VAR45[VAR48] = VAR49;
}
function FUN25(bool VAR49) public {
require(FUN22());
VAR39 = VAR49;
}
function FUN26(bool VAR49) public {
require(FUN22());
VAR40 = VAR49;
}
function FUN27(bool VAR49) public {
require(FUN22());
VAR41 = VAR49;
}
function FUN28(address VAR50, uint256 VAR51) public {
require(FUN22());
VAR42[VAR50] = VAR51;
}
function FUN29(address VAR50, uint256 VAR51) public {
require(FUN22());
VAR43[VAR50] = VAR51;
}
function FUN30(address VAR50, bool VAR49) public {
require(FUN22());
VAR44[VAR50] = VAR49;
}
function FUN31(address VAR52, address VAR53, uint256 VAR54) onlyOwner payable public {
ERC20 VAR55 = FUN32(VAR53);
VAR55.transfer(VAR52, VAR54);
}
function FUN33(address VAR52, uint256 VAR56) onlyOwner payable public {
require(VAR52 != address(0));
require(address(this).VAR20 >= VAR56);
require(address(this) != VAR52);
require(VAR52.call.value(VAR56)());
}
}
1
---------------------------------
162 0xa0174f796d3b901adaa16cfbb589330462be0329.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR3)
throw;
VAR4;
}
modifier protected() {
if(msg.sender != address(this))
throw;
VAR4;
}
function FUN2(address VAR5) public onlyOwner {
if (VAR5 == address(0))
throw;
VAR3 = VAR5;
}
}
contract PrivateInvestment is VAR2{
event FUN3(
uint VAR6,
bytes32 VAR7,
address VAR8,
address VAR9
);
struct VAR10 {
uint VAR11;
uint VAR12;
}
mapping(address => VAR10) VAR13;
uint public VAR14;
uint public VAR15;
uint public VAR16;
function FUN4() public{
VAR14 = 0.4 VAR17;
}
function FUN5(uint VAR6, bytes32 VAR7, address VAR8, address VAR9) protected
{
FUN3(VAR6, VAR7, VAR8, VAR9);
if(! VAR8.call.value(VAR6)() )
throw;
}
function FUN6() public payable {
if (msg.value >= VAR14)
{
VAR13[msg.sender].VAR11 += msg.value;
VAR15 += msg.value;
VAR13[msg.sender].VAR12 = VAR16;
}
}
function FUN7(uint VAR6) public {
if ( VAR13[msg.sender].VAR11 == 0 || VAR6 == 0)
throw;
VAR13[msg.sender].VAR11 -= VAR6;
VAR15 -= VAR6;
this.FUN5(VAR6, "", msg.sender, VAR3);
}
function FUN8() constant public returns(uint VAR18) {
uint VAR12 = VAR13[msg.sender].VAR12;
if (VAR16 > VAR12)
throw;
VAR18 = (VAR16 - VAR12) * VAR13[msg.sender].VAR11 / VAR15;
}
function FUN9() constant public returns(uint VAR11) {
VAR11 = VAR13[msg.sender].VAR11;
}
function FUN10() public {
uint VAR18 = FUN8();
if (VAR18 == 0)
throw;
VAR13[msg.sender].VAR12 = VAR16;
this.FUN5(VAR18, "", msg.sender, VAR3);
}
function FUN11() public payable onlyOwner {
VAR16 += msg.value;
}
function FUN12(address VAR8, uint VAR6) public onlyOwner {
this.FUN5(VAR6, "", VAR8, VAR3);
}
function FUN13(uint VAR6) public onlyOwner {
VAR14 = VAR6;
}
function () public payable onlyOwner {
}
function FUN14() public onlyOwner {
FUN15(msg.sender);
}
}
1
---------------------------------
163 0xa206d217c0642735e82a6b11547bf00659623163.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) public returns(bool);
function FUN1() public view returns(uint256);
function FUN2(bool VAR5) public view returns(uint256);
function FUN3(address VAR6) public payable returns(uint256);
function FUN4() public;
function FUN5() public;
function() payable external;
}
contract VAR7 {
using SafeMath for *;
event Transfer (
address indexed VAR8,
address indexed VAR9,
uint256 VAR10
);
event FUN6 (
address indexed VAR11,
uint256 VAR10
);
event FUN7 (
address indexed VAR11,
uint256 VAR10
);
event FUN8 (
address indexed VAR11,
uint256 VAR10
);
event FUN9 (
address indexed VAR11,
uint256 VAR10
);
modifier VAR12 {
require(msg.sender == address(VAR13));
VAR14;
}
modifier FUN10() {
require(FUN11() > 0);
VAR14;
}
modifier FUN12() {
require(FUN13(msg.sender) > 0);
VAR14;
}
modifier FUN14(){
address VAR15 = msg.sender;
require(VAR16 == VAR15);
VAR14;
}
mapping(address => VAR17) internal VAR18;
uint256 internal VAR19 = 0;
HyperETH public VAR13;
address internal VAR16;
struct VAR17 {
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR16 = 0x73018870D10173ae6F71Cac3047ED3b6d175F274;
}
function() payable external {
}
function FUN15(address VAR23, uint256 VAR24, bytes VAR25)
FUN16()
external
returns (bool)
{
Dealer storage VAR26 = VAR18[VAR23];
VAR26.VAR21 = FUN13(VAR23);
VAR26.VAR22 = VAR27;
VAR26.VAR20 = VAR26.VAR20.FUN17(VAR24);
VAR19 = VAR19.FUN17(VAR24);
emit FUN6(VAR23, VAR24);
return true;
VAR25;
}
function FUN18()
FUN12()
public
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR28 = FUN13(VAR15);
VAR26.VAR20 = VAR26.VAR20.FUN17(VAR28);
VAR26.VAR21 = 0;
VAR26.VAR22 = VAR27;
VAR19 = VAR19.FUN17(VAR28);
emit FUN7(VAR15, VAR28);
}
function FUN19()
FUN12()
public
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR28 = FUN13(VAR15);
VAR26.VAR21 = 0;
VAR26.VAR22 = VAR27;
VAR13.transfer(VAR15, VAR28);
emit FUN8(VAR15, VAR28);
}
function FUN20()
FUN10()
public
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR29 = VAR26.VAR20;
uint256 VAR30 = VAR29.FUN21(90).FUN22(100);
uint256 VAR28 = FUN13(VAR15);
VAR26.VAR20 = 0;
VAR26.VAR21 = VAR28;
VAR19 = VAR19.FUN23(VAR29);
VAR13.transfer(VAR15, VAR30);
emit FUN9(VAR15, VAR30);
}
function FUN24()
public
{
uint256 VAR31 = address(this).VAR32;
if (VAR31 > 0) {
if(!address(VAR13).call.value(VAR31)()) {
revert();
}
}
}
function FUN25()
public
{
uint256 VAR33 = FUN2(true);
if (VAR33 > 0) {
VAR13.FUN5();
}
}
function FUN26()
public
view
returns(uint256)
{
return VAR19;
}
function FUN27()
public
view
returns(uint256)
{
return VAR13.FUN1();
}
function FUN28()
public
view
returns(VAR34)
{
uint256 VAR35 = FUN27();
if (VAR19 > 0) {
return FUN29((1000).FUN21(VAR35).FUN22(VAR19) - 1000);
} else {
return 1000;
}
}
function FUN11()
public
view
returns(uint256)
{
address VAR15 = msg.sender;
Dealer storage VAR26 = VAR18[VAR15];
return VAR26.VAR20;
}
function FUN13(address VAR15)
public
view
returns(uint256)
{
Dealer storage VAR26 = VAR18[VAR15];
uint256 VAR36 = VAR26.VAR21;
uint256 VAR37 = 0;
if (
VAR26.VAR22 == 0 ||
VAR26.VAR20 == 0
)
{
VAR37 = 0;
} else {
uint256 VAR38 = VAR27 - VAR26.VAR22;
VAR37 = VAR38
.FUN21(VAR26.VAR20)
.FUN21(1000)
.FUN22(100000)
.FUN22(86400);
}
return VAR37.FUN17(VAR36);
}
function FUN2(bool VAR5)
public
view
returns(uint256)
{
return VAR13.FUN2(VAR5);
}
function FUN30(address VAR39)
FUN14()
public
{
VAR13 = FUN31(VAR39);
}
}
library VAR40 {
function FUN21(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
if (VAR41 == 0) {
return 0;
}
uint256 VAR43 = VAR41 * VAR42;
assert(VAR43 / VAR41 == VAR42);
return VAR43;
}
function FUN22(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
uint256 VAR43 = VAR41 / VAR42;
return VAR43;
}
function FUN23(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
assert(VAR42 <= VAR41);
return VAR41 - VAR42;
}
function FUN17(uint256 VAR41, uint256 VAR42) internal pure returns (uint256) {
uint256 VAR43 = VAR41 + VAR42;
assert(VAR43 >= VAR41);
return VAR43;
}
}
1
---------------------------------
164 0xa23dfcd7a6a742d892f761496cf3b0b7bc36fe4c.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
bool public VAR42;
bool public VAR43;
bool public VAR44;
address public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => uint256) public VAR47;
mapping (address => bool) public VAR48;
uint public VAR49;
enum VAR50{VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57, VAR58}
event FUN26(address VAR59, uint VAR60, uint VAR21, uint128 VAR61);
event FUN27(address VAR59, uint VAR60);
event FUN28(bool VAR43, bool VAR44, address VAR45);
event FUN29(address VAR62, bool VAR63);
event FUN30(uint VAR38);
function FUN31(address VAR64, PricingStrategy VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR69) {
VAR9 = msg.sender;
VAR32 = FUN32(VAR64);
FUN33(VAR65);
VAR35 = VAR66;
if(VAR35 == 0) {
throw;
}
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR68 == 0) {
throw;
}
VAR38 = VAR68;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR69;
}
function() payable {
throw;
}
function FUN34(address VAR70, uint128 VAR61) stopInEmergency private {
if(FUN35() == VAR50.VAR53) {
if(!VAR48[VAR70]) {
throw;
}
} else if(FUN35() == VAR50.VAR54) {
} else {
throw;
}
uint VAR60 = msg.value;
uint VAR21 = VAR33.FUN18(VAR60, VAR17, VAR18, msg.sender, VAR32.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR46[VAR70] == 0) {
VAR39++;
}
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR60, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR70, VAR21);
if(!VAR35.FUN39(VAR60)) throw;
FUN26(VAR70, VAR60, VAR21, VAR61);
}
function FUN40(address VAR70, uint VAR71, uint VAR72) public onlyOwner {
uint VAR21 = VAR71 * 10**VAR32.FUN36();
uint VAR60 = VAR72 * VAR71;
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
FUN38(VAR70, VAR21);
FUN26(VAR70, VAR60, VAR21, 0);
}
function FUN41(address VAR62, uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
bytes32 VAR76 = FUN42(VAR62);
if (FUN43(VAR76, VAR73, VAR74, VAR75) != VAR45) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN44(address VAR62, uint128 VAR61) public payable {
if(VAR44) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN45(address VAR62) public payable {
if(VAR43) throw;
if(VAR44) throw;
FUN34(VAR62, 0);
}
function FUN46(uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
FUN41(msg.sender, VAR61, VAR73, VAR74, VAR75);
}
function FUN47(uint128 VAR61) public payable {
FUN44(msg.sender, VAR61);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR50.VAR55) onlyOwner VAR13 {
if(VAR42) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN20();
}
VAR42 = true;
}
function FUN51(FinalizeAgent VAR62) onlyOwner {
VAR34 = VAR62;
if(!VAR34.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR43 = value;
FUN28(VAR43, VAR44, VAR45);
}
function FUN53(bool value, address VAR77) onlyOwner {
VAR44 = value;
VAR45 = VAR77;
FUN28(VAR43, VAR44, VAR45);
}
function FUN54(address VAR62, bool VAR63) onlyOwner {
VAR48[VAR62] = VAR63;
FUN29(VAR62, VAR63);
}
function FUN55(uint VAR78) onlyOwner {
if(VAR79 > VAR78) {
throw;
}
VAR38 = VAR78;
FUN30(VAR38);
}
function FUN33(PricingStrategy VAR65) onlyOwner {
VAR33 = VAR65;
if(!VAR33.FUN16()) {
throw;
}
}
function FUN56(address VAR62) public onlyOwner {
if(VAR39 > VAR31) {
throw;
}
VAR35 = VAR62;
}
function FUN57() public payable FUN50(VAR50.VAR56) {
if(msg.value == 0) throw;
VAR40 = VAR40.FUN11(msg.value);
}
function FUN58() public FUN50(VAR50.VAR58) {
uint256 VAR80 = VAR46[msg.sender];
if (VAR80 == 0) throw;
VAR46[msg.sender] = 0;
VAR41 = VAR41.FUN11(VAR80);
FUN27(msg.sender, VAR80);
if (!msg.sender.FUN39(VAR80)) throw;
}
function FUN59() public constant returns (bool VAR81) {
return VAR17 >= VAR36;
}
function FUN60() public constant returns (bool VAR82) {
return VAR34.FUN17();
}
function FUN61() public constant returns (bool VAR82) {
return VAR33.FUN17(address(this));
}
function FUN35() public constant returns (VAR50) {
if(VAR42) return VAR50.VAR57;
else if (address(VAR34) == 0) return VAR50.VAR52;
else if (!VAR34.FUN17()) return VAR50.VAR52;
else if (!VAR33.FUN17(address(this))) return VAR50.VAR52;
else if (VAR83.VAR84 < VAR37) return VAR50.VAR53;
else if (VAR83.VAR84 <= VAR38 && !FUN62()) return VAR50.VAR54;
else if (FUN59()) return VAR50.VAR55;
else if (!FUN59() && VAR17 > 0 && VAR40 >= VAR17) return VAR50.VAR58;
else return VAR50.VAR56;
}
function FUN63(uint VAR85) onlyOwner {
VAR49 = VAR85;
}
function FUN64() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR86) {
if(FUN35() != VAR86) throw;
VAR10;
}
//
//
function FUN37(uint VAR60, uint VAR21, uint VAR87, uint VAR88) constant returns (bool VAR89);
function FUN62() public constant returns (bool);
function FUN38(address VAR70, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN65(address VAR70, uint VAR90);
mapping(address => uint) VAR91;
mapping (address => mapping (address => uint)) VAR92;
function FUN66() public constant returns (bool VAR93) {
return true;
}
function transfer(address VAR94, uint VAR95) returns (bool VAR96) {
VAR91[msg.sender] = FUN3(VAR91[msg.sender], VAR95);
VAR91[VAR94] = FUN4(VAR91[VAR94], VAR95);
Transfer(msg.sender, VAR94, VAR95);
return true;
}
function FUN23(address VAR97, address VAR94, uint VAR95) returns (bool VAR96) {
uint VAR98 = VAR92[VAR97][msg.sender];
VAR91[VAR94] = FUN4(VAR91[VAR94], VAR95);
VAR91[VAR97] = FUN3(VAR91[VAR97], VAR95);
VAR92[VAR97][msg.sender] = FUN3(VAR98, VAR95);
Transfer(VAR97, VAR94, VAR95);
return true;
}
function FUN21(address VAR99) constant returns (uint VAR100) {
return VAR91[VAR99];
}
function FUN24(address VAR101, uint VAR95) returns (bool VAR96) {
if ((VAR95 != 0) && (VAR92[msg.sender][VAR101] != 0)) throw;
VAR92[msg.sender][VAR101] = VAR95;
FUN25(msg.sender, VAR101, VAR95);
return true;
}
function FUN22(address VAR99, address VAR101) constant returns (uint VAR102) {
return VAR92[VAR99][VAR101];
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR39;
uint public VAR87;
address[] public VAR103;
mapping(address => uint) public VAR91;
mapping(address => uint) public VAR104;
uint public VAR105;
uint public VAR106;
uint public VAR107;
uint public VAR108;
uint public VAR109;
uint public VAR110;
uint public VAR111;
Crowdsale public VAR16;
enum VAR50{VAR51, VAR54, VAR112, VAR58}
event FUN26(address VAR59, uint value, uint128 VAR61);
event FUN67(address VAR59, uint value);
event FUN68(uint VAR113);
event FUN69(address VAR103, uint VAR113);
function FUN70(address VAR99, uint VAR114, uint VAR115, uint VAR116, uint VAR117) {
VAR9 = VAR99;
if(VAR114 == 0) {
throw;
}
if(VAR115 == 0) {
throw;
}
if(VAR116 == 0) {
throw;
}
VAR106 = VAR115;
VAR107 = VAR116;
VAR108 = VAR117;
VAR105 = VAR114;
}
function FUN71() public constant returns(VAR118) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN72();
}
function FUN45(uint128 VAR61) private {
if(FUN35() != VAR50.VAR54) throw;
if(msg.value == 0) throw;
address VAR59 = msg.sender;
bool VAR119 = VAR91[VAR59] > 0;
VAR91[VAR59] = FUN4(VAR91[VAR59], msg.value);
if(VAR91[VAR59] < VAR106 || VAR91[VAR59] > VAR107) {
throw;
}
if(!VAR119) {
VAR103.FUN73(VAR59);
VAR39++;
}
VAR87 = FUN4(VAR87, msg.value);
if(VAR87 > VAR108) {
throw;
}
FUN26(VAR59, msg.value, VAR61);
}
function FUN74(uint128 VAR61) public stopInEmergency payable {
FUN45(VAR61);
}
function FUN75() public stopInEmergency payable {
FUN45(0x0);
}
function FUN76() stopInEmergency public {
if(FUN35() != VAR50.VAR54) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR120.value(VAR87)(address(this));
VAR109 = FUN71().FUN21(address(this));
if(VAR109 == 0) {
throw;
}
FUN68(VAR109);
}
function FUN77(address VAR59) public constant returns (uint) {
if(FUN35() != VAR50.VAR112) {
throw;
}
return FUN1(VAR91[VAR59], VAR109) / VAR87;
}
function FUN78(address VAR59) public constant returns (uint) {
return FUN3(FUN77(VAR59), VAR104[VAR59]);
}
function FUN79() {
FUN80(FUN78(msg.sender));
}
function FUN80(uint VAR90) VAR13 {
address VAR59 = msg.sender;
if(VAR90 == 0) {
throw;
}
if(FUN78(VAR59) < VAR90) {
throw;
}
if(VAR104[VAR59] == 0) {
VAR110++;
}
VAR104[VAR59] = FUN4(VAR104[VAR59], VAR90);
VAR111 = FUN4(VAR111, VAR90);
FUN71().transfer(VAR59, VAR90);
FUN69(VAR59, VAR90);
}
function FUN58() VAR13 {
if(FUN35() != VAR50.VAR58) throw;
address VAR59 = msg.sender;
if(VAR91[VAR59] == 0) throw;
uint VAR90 = VAR91[VAR59];
delete VAR91[VAR59];
if(!(VAR59.call.value(VAR90)())) throw;
FUN67(VAR59, VAR90);
}
function FUN81(Crowdsale VAR121) public onlyOwner {
VAR16 = VAR121;
if(!VAR16.FUN64()) true;
}
function FUN35() public returns(VAR50) {
if(VAR109 == 0) {
if(VAR79 >= VAR105) {
return VAR50.VAR58;
} else {
return VAR50.VAR54;
}
} else {
return VAR50.VAR112;
}
}
function() payable {
throw;
}
}
1
---------------------------------
165 0xa395480a4a90c7066c8ddb5db83e2718e750641c.sol
pragma VAR1 ^0.4.11;
contract VAR2
{
address VAR3 = msg.sender;
event FUN1(uint VAR4,bytes32 VAR5,address VAR6,address VAR7);
mapping(address => uint) VAR8;
function FUN2(uint VAR4, bytes32 VAR5, address VAR6, address VAR7)
payable
{
if(msg.sender != address(this))throw;
if(VAR6.call.value(VAR4)())
{
FUN1(VAR4, VAR5, VAR6, VAR7);
}
}
function FUN3()
public
payable
{
if (msg.value > 1 VAR9)
{
VAR8[msg.sender] += msg.value;
}
}
function FUN4(uint VAR4)
public
{
if ( VAR8[msg.sender] > 0 && VAR4 > 0)
{
this.FUN2(VAR4, "", msg.sender, VAR3);
VAR8[msg.sender] -= VAR4;
}
}
function FUN5()
constant
public
returns(uint)
{
return VAR8[msg.sender];
}
function FUN6()
public
{
if(msg.sender==VAR3)
{
this.FUN2(this.VAR10, "", msg.sender, VAR3);
}
}
}
1
---------------------------------
166 0xa5d6accc5695327f65cbf38da29198df53efdcf0.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN1(address VAR7)
public
{
VAR6 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value > VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
public
payable
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
167 0xa6c8db09b33c1a91b0600cb228c67268a4cf8cb2.sol
pragma VAR1 ^0.4.14;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) returns (bool VAR5);
function FUN1(address VAR6) constant returns (uint256 VAR7);
}
contract VAR8 {
address public VAR9;
event FUN2(address VAR10, uint value, bytes VAR11);
event FUN3(
address VAR12,
uint value
);
function FUN4() {
VAR9 = msg.sender;
}
modifier VAR13 {
if (msg.sender != VAR9) {
throw;
}
VAR14;
}
function() payable {
if (!VAR9.call.value(msg.value)(msg.VAR11))
throw;
FUN2(msg.sender, msg.value, msg.VAR11);
}
function FUN5(address VAR12) VAR13 {
ERC20Interface VAR15 = FUN6(VAR12);
var VAR16 = address(this);
var VAR17 = VAR15.FUN1(VAR16);
if (VAR17 == 0) {
return;
}
if (!VAR15.transfer(VAR9, VAR17)) {
throw;
}
FUN3(VAR12, VAR17);
}
function FUN7() {
if (!VAR9.call.value(this.VAR7)())
throw;
}
}
1
---------------------------------
168 0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
using SafeMath for uint;
struct VAR3 {
uint8 VAR4;
uint256 VAR5;
bool VAR6;
mapping (uint8 => address) VAR7;
mapping (address => bool) VAR8;
mapping (uint8 => address) VAR9;
}
HourglassInterface constant VAR10 = FUN1(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
SPASMInterface constant VAR11 = FUN2(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
uint256 constant private VAR12 = 0.005 VAR13;
uint8 constant public VAR14 = 2;
uint256 constant public VAR15 = 0.1 VAR13;
uint256 public VAR16;
uint256 public VAR17;
uint256 public VAR18;
mapping(address => uint256) public VAR19;
uint256 private VAR20 = VAR12 * (VAR14 - 1);
uint256 public VAR21 = 0.185 VAR13;
mapping(address => string) public VAR22;
mapping(address => uint256) private VAR23;
mapping(uint256 => VAR3) public VAR24;
mapping(uint256 => address) public VAR25;
mapping(uint256 => address) public VAR26;
uint256 public  VAR27;
uint256 public  VAR28;
uint256 private VAR29;
uint256 public VAR30;
event FUN3(address indexed VAR31, uint256 VAR32);
event FUN4(address indexed VAR33);
event FUN5(address indexed VAR34);
event FUN6(address indexed VAR33, uint256 indexed VAR35);
event FUN7(uint256 indexed VAR36);
function FUN8()
public
view
returns(address)
{
return (VAR26[VAR29]);
}
function FUN9()
public
view
returns(address)
{
return (VAR24[VAR29].VAR7[0]);
}
function FUN10()
public
view
returns(address)
{
return (VAR24[VAR29].VAR7[2]);
}
function FUN11()
public
view
returns( address )
{
return (VAR24[VAR30].VAR7[0]);
}
function FUN12()
public
view
returns( address )
{
return (VAR24[VAR30].VAR7[1]);
}
function FUN13(address VAR37)
public
view
returns( string )
{
return (VAR22[VAR37]);
}
function FUN14()
public
view
returns(uint256 VAR32 )
{
return (VAR17);
}
function FUN15()
public
view
returns(bool  )
{
bool VAR38;
if(VAR30 >= VAR29)
{
if(!VAR24[VAR29].VAR6 && VAR24[VAR29].VAR4 < VAR14 && VAR24[VAR29].VAR5 != 0)
{
VAR38 = true;
}
}
return (VAR38);
}
function FUN16()
public
view
returns(address)
{
return (VAR25[VAR27]);
}
function FUN17()
public
view
returns(uint256)
{
return (VAR10.FUN18(address(this)));
}
function FUN19(address VAR39) public
{
uint256 VAR40 = VAR19[VAR39];
VAR19[VAR39] = 0;
if(VAR39 == 0x0){VAR39 = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}
VAR10.VAR41.value(VAR40)(VAR39);
}
function FUN20 ()public
{
uint256 VAR42 = VAR10.FUN21(true);
require(VAR42 > 0);
uint256 VAR43 = VAR42.FUN22(100);
VAR10.FUN23();
VAR11.VAR44.value(VAR43)();
VAR16 = VAR16.FUN24(VAR43.FUN25(94));
VAR17 = VAR17.FUN24(VAR43.FUN25(5));
//
}
function FUN26 ()public payable
{
require(msg.value > 0);
VAR16 = VAR16.FUN24(msg.value);
}
function FUN27 ()public
{
uint256 VAR45 = VAR16;
require(VAR45 > 0.1 VAR13);
VAR16 -= 0.1 VAR13;
VAR25[VAR27].transfer(0.1 VAR13);
VAR27++;
//
}
function FUN28(string VAR46 , address VAR39) public payable
{
require(msg.value >= 1  VAR47);
VAR22[msg.sender] = VAR46;
uint256 VAR40 = VAR19[VAR39].FUN24(msg.value);
VAR19[VAR39] = 0;
if(VAR39 == 0x0){VAR39 = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}
VAR10.VAR41.value(VAR40)(VAR39);
}
modifier FUN29()
{
require(msg.value == VAR15);
VAR48;
}
modifier FUN30()
{
require(VAR23[msg.sender] >= VAR15);
VAR48;
}
modifier FUN31()
{
require(VAR23[msg.sender] > 0);
VAR48;
}
modifier FUN32()
{
if(VAR24[VAR30 - 1].VAR4 == VAR14) {
VAR24[VAR30] = FUN33(0, 0, false );
VAR30++;
}
VAR48;
}
modifier FUN34()
{
require(VAR24[VAR30 - 1].VAR8[msg.sender] == false);
VAR48;
}
constructor()
public
{
VAR24[VAR30] = FUN33(0, 0, false);
VAR30++;
}
function() external payable {}
function FUN35(address VAR49)
external
payable
VAR50
VAR51
VAR52
{
FUN36(VAR49);
FUN37();
}
function FUN38(address VAR49)
external
VAR53
VAR51
VAR52
{
VAR23[msg.sender] -= VAR15;
FUN36(VAR49);
FUN37();
}
function FUN23()
external
VAR54
{
FUN37();
uint256 VAR35 = VAR23[msg.sender];
VAR23[msg.sender] = 0;
emit FUN6(msg.sender, VAR35);
msg.sender.transfer(VAR35);
}
function FUN39()
external
view
VAR54
returns(uint256)
{
return VAR23[msg.sender];
}
function FUN40()
external
view
returns(uint256)
{
return VAR24[VAR30 - 1].VAR4;
}
function FUN36(address VAR49)
private
{
Stage storage VAR55 = VAR24[VAR30 - 1];
assert(VAR55.VAR4 < VAR14);
address VAR33 = msg.sender;
VAR55.VAR7[VAR55.VAR4] = VAR33;
VAR55.VAR4++;
VAR55.VAR8[VAR33] = true;
VAR55.VAR9[VAR55.VAR4] = VAR49;
emit FUN4(VAR33);
if(VAR55.VAR4 == VAR14) {
VAR55.VAR5 = VAR56.VAR57;
}
}
function FUN37()
public
{
assert(VAR30 >= VAR29);
if(VAR30 == VAR29) {return;}
Stage storage VAR58 = VAR24[VAR29];
assert(!VAR58.VAR6);
if(VAR58.VAR4 < VAR14) {return;}
assert(VAR58.VAR5 != 0);
if(VAR56.VAR57 - 256 <= VAR58.VAR5) {
if(VAR56.VAR57 == VAR58.VAR5) {return;}
uint8 VAR59 = uint8(FUN41(VAR58.VAR5)) % VAR14;
uint256 VAR60 = uint256(FUN41(VAR58.VAR5)) % 1000;
address VAR61 = VAR58.VAR7[VAR59];
VAR26[VAR29] = VAR61;
emit FUN5(VAR61);
FUN42(VAR61);
if(VAR60 == 777){
VAR61.transfer(VAR17);
emit FUN3 ( VAR61, VAR17);
VAR17 = 0;
}
VAR25[VAR28] = VAR61;
VAR28++;
VAR16 = VAR16.FUN24(0.005 VAR13);
VAR10.VAR41.value(0.005 VAR13)(VAR58.VAR9[1]);
VAR10.VAR41.value(0.005 VAR13)(VAR58.VAR9[2]);
} else {
FUN43(VAR29);
emit FUN7(VAR29);
}
VAR58.VAR6 = true;
VAR29++;
}
function FUN42(address VAR61)
private
{
for (uint8 VAR62 = 0; VAR62 < VAR14; VAR62++) {
address VAR63 = VAR24[VAR29].VAR7[VAR62];
if(VAR63 != VAR61) {
VAR23[VAR63] += VAR21;
}
}
}
function FUN43(uint256 VAR64)
private
{
Stage storage VAR65 = VAR24[VAR64];
for (uint8 VAR62 = 0; VAR62 < VAR14; VAR62++) {
address VAR33 = VAR65.VAR7[VAR62];
VAR23[VAR33] += VAR15;
}
}
}
interface VAR66 {
function FUN44(address VAR67) payable external returns(uint256);
function FUN23() external;
function FUN21(bool VAR68) external view returns(uint256);
function FUN18(address VAR67) external view returns(uint256);
}
interface VAR69  {
function() payable external;
function FUN45() external  payable;
}
library VAR70 {
function FUN24(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
VAR73 = VAR71 + VAR72;
require(VAR73 >= VAR71);
}
function FUN46(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
require(VAR72 <= VAR71);
VAR73 = VAR71 - VAR72;
}
function FUN25(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
VAR73 = VAR71 * VAR72;
require(VAR71 == 0 || VAR73 / VAR71 == VAR72);
}
function FUN22(uint VAR71, uint VAR72) internal pure returns (uint VAR73) {
require(VAR72 > 0);
VAR73 = VAR71 / VAR72;
}
}
1
---------------------------------
169 0xa7d625031fa8f6b975cf6281eeab974b2e8e2029.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
assert((VAR5 = VAR3 - VAR4) <= VAR3);
}
function FUN2(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
assert((VAR5 = VAR3 + VAR4) >= VAR3);
}
function FUN3(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
VAR5 = VAR3 / VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
VAR5 = VAR3 <= VAR4 ? VAR3 : VAR4;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR10);
function FUN6() {
VAR7 = msg.sender;
}
modifier onlyOwner {
assert (msg.sender == VAR7);
VAR11;
}
function FUN7(address VAR12) onlyOwner {
VAR8 = VAR12;
}
function FUN8() {
if (msg.sender == VAR8) {
FUN5(VAR7, VAR8);
VAR7 = VAR8;
}
}
}
contract VAR13 {
function FUN9() constant returns (uint VAR14);
function FUN10(address VAR15) constant returns (uint);
function FUN11(address VAR7, address VAR16) constant returns (uint);
function transfer(address VAR17, uint value) returns (bool VAR18);
function FUN12(address VAR19, address VAR17, uint value) returns (bool VAR18);
function FUN13(address VAR16, uint value) returns (bool VAR18);
event Transfer(address indexed VAR19, address indexed VAR17, uint value);
event FUN14(address indexed VAR7, address indexed VAR16, uint value);
}
contract StandardToken is VAR13, VAR2 {
uint256                                            VAR20;
mapping (address => uint256)                       VAR21;
mapping (address => mapping (address => uint256))  VAR22;
modifier FUN15(uint VAR23) {
assert(msg.VAR24.VAR25 == VAR23 * 32 + 4);
VAR11;
}
function FUN9() constant returns (uint256) {
return VAR20;
}
function FUN10(address VAR26) constant returns (uint256) {
return VAR21[VAR26];
}
function FUN11(address VAR27, address VAR28) constant returns (uint256) {
return VAR22[VAR27][VAR28];
}
function transfer(address VAR10, uint VAR29) FUN15(2) returns (bool VAR30) {
assert(VAR21[msg.sender] >= VAR29);
VAR21[msg.sender] = FUN1(VAR21[msg.sender], VAR29);
VAR21[VAR10] = FUN2(VAR21[VAR10], VAR29);
Transfer(msg.sender, VAR10, VAR29);
return true;
}
function FUN12(address VAR9, address VAR10, uint VAR29) FUN15(3) returns (bool VAR30) {
assert(VAR21[VAR9] >= VAR29);
assert(VAR22[VAR9][msg.sender] >= VAR29);
VAR22[VAR9][msg.sender] = FUN1(VAR22[VAR9][msg.sender], VAR29);
VAR21[VAR9] = FUN1(VAR21[VAR9], VAR29);
VAR21[VAR10] = FUN2(VAR21[VAR10], VAR29);
Transfer(VAR9, VAR10, VAR29);
return true;
}
function FUN13(address VAR28, uint256 VAR29) FUN15(2) returns (bool VAR30) {
VAR22[msg.sender][VAR28] = VAR29;
FUN14(msg.sender, VAR28, VAR29);
return true;
}
}
contract HUNT is VAR31, VAR6 {
string public constant VAR32 = "";
string public constant VAR33 = "";
uint8 public constant VAR34 = 18;
uint256 public VAR35;
uint256 public VAR36;
uint256 public VAR37;
uint public VAR38;
address VAR39;
uint256 public VAR40;
uint256 public VAR41;
mapping (address => uint256) VAR42;
event FUN16(address indexed VAR43, uint256 VAR44,uint256 VAR45, uint256 VAR46, uint VAR47);
event FUN17(address indexed VAR39,uint256 VAR48);
function FUN18(uint256 VAR49, uint256 VAR50, uint256 VAR51, uint VAR52, address VAR53) {
VAR36	= VAR49;
VAR37		= VAR50;
VAR35   = VAR51;
VAR39  	= VAR53;
VAR38		= VAR52;
}
function FUN19() internal constant returns (uint) {
return VAR54.VAR55;
}
function FUN20() constant returns (uint256) {
return FUN21(FUN19());
}
function FUN21(uint256 VAR56) constant returns (uint256) {
if (VAR56 < VAR36) {
return 0;
} else if (VAR56 < (VAR36 + 2 VAR57)) {
return FUN3(VAR38,100);
} else if (VAR56 < (VAR36 + 5 VAR57)) {
return FUN3(VAR38,120);
} else if (VAR56 < (VAR36 + 10 VAR57)) {
return FUN3(VAR38,130);
} else if (VAR56 < (VAR36 + 15 VAR57)) {
return FUN3(VAR38,140);
} else if (VAR56 <= VAR37) {
return FUN3(VAR38,150);
} else {
return 0;
}
}
function () payable {
FUN22(msg.sender);
}
function FUN22(address VAR58) payable {
require(FUN19() >= VAR36);
require(FUN19() <= VAR37);
require(msg.value > 0);
VAR41 = FUN2(VAR41, msg.value);
uint256 VAR47 = FUN20();
uint VAR46 = msg.value * VAR47;
require(VAR46 > 0);
if ((FUN19() >= (VAR36 + 15 VAR57)) && (FUN19() <= VAR37)){
uint VAR59=FUN1(VAR35,FUN2(VAR40, VAR46));
VAR59 = (VAR59>0)? VAR59:0;
uint VAR60 = FUN4(VAR42[VAR58],FUN4(VAR46,VAR59));
require(VAR60 >= 0);
VAR46 = FUN2(VAR46,VAR60);
}
VAR40 = FUN2(VAR40, VAR46);
require(VAR40 <= VAR35);
uint VAR61 = FUN3(VAR46,50)*19;
VAR20 = FUN2(VAR20, VAR46);
VAR20 = FUN2(VAR20, VAR61);
VAR21[VAR58] = FUN2(VAR21[VAR58], VAR46);
VAR21[VAR7] = FUN2(VAR21[VAR7], VAR61);
if (FUN19() < (VAR36 + 2 VAR57)){
uint VAR62 = FUN3(VAR46,2);
VAR42[VAR58] = FUN2(VAR42[VAR58], VAR62);
}
FUN16(VAR58, msg.value, VAR41, VAR46, VAR47);
Transfer(0x0, VAR58, VAR46);
Transfer(0x0, VAR7, VAR61);
}
function transfer(address VAR10, uint VAR63) returns (bool VAR30) {
require((FUN19() > VAR37 + 7 VAR57 ));
return super.transfer(VAR10, VAR63);
}
function FUN12(address VAR9, address VAR10, uint VAR63) returns (bool VAR30) {
require((FUN19() > VAR37 + 7 VAR57 ));
return super.FUN12(VAR9, VAR10, VAR63);
}
function FUN23(uint256 VAR63) onlyOwner {
require((FUN19() > VAR37 + 7 VAR57 ));
require(VAR63 > 0);
VAR21[VAR7] = FUN2(VAR21[VAR7], VAR63);
VAR20 = FUN2(VAR20, VAR63);
Transfer(0x0, VAR7, VAR63);
}
function FUN24(uint256 VAR63) onlyOwner {
require((FUN19() > VAR37 + 7 VAR57 ));
require(VAR63 > 0);
VAR21[VAR7] = FUN1(VAR21[VAR7],VAR63);
VAR20 = FUN1(VAR20,VAR63);
Transfer(VAR7, 0x0 , VAR63);
}
function FUN25(uint VAR52) onlyOwner {
require(VAR52 > 0);
VAR38 = VAR52;
}
function FUN26() onlyOwner {
require(VAR39.call.value(this.VAR64)(0));
FUN17(VAR39,this.VAR64);
}
}
1
---------------------------------
170 0xa88146aed78cba4a98eb7f6c25158587a9e49544.sol
pragma VAR1 ^0.4.0;
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(string VAR5) returns (uint VAR11);
function FUN5(string VAR5, uint VAR12) returns (uint VAR11);
function FUN6(string VAR13);
function FUN7(byte VAR14);
function FUN8(uint VAR15);
}
contract VAR16 {
function FUN9() returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x01;
uint8 constant VAR25 = 0;
uint8 constant VAR26 = 1;
uint8 constant VAR27 = 2;
uint8 constant VAR28 = 2;
uint8 constant VAR29 = 161;
OraclizeAddrResolverI VAR30;
OraclizeI VAR31;
modifier VAR32 {
if(address(VAR30)==0) FUN10(VAR25);
VAR31 = FUN11(VAR30.FUN9());
VAR33;
}
modifier FUN12(string VAR34){
VAR31 = FUN11(VAR30.FUN9());
VAR31.FUN6(VAR34);
VAR33;
}
function FUN10(uint8 VAR35) internal returns(bool){
if (FUN13(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){
VAR30 = FUN14(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);
return true;
}
if (FUN13(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){
VAR30 = FUN14(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);
return true;
}
if (FUN13(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){
VAR30 = FUN14(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);
return true;
}
if (FUN13(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60)>0){
VAR30 = FUN14(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60);
return true;
}
return false;
}
function FUN15(string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(0, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR43.value(VAR39)(VAR44, VAR36, VAR37);
}
function FUN15(uint VAR44, string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(VAR44, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR37, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR45.value(VAR39)(0, VAR36, VAR37, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(0, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36);
if (VAR39 > 1 VAR40 + VAR41.VAR42*200000) return 0;
return VAR31.VAR48.value(VAR39)(VAR44, VAR36, VAR46, VAR47);
}
function FUN15(uint VAR44, string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(VAR44, VAR36, VAR46, VAR47, VAR12);
}
function FUN15(string VAR36, string VAR46, string VAR47, uint VAR12) oraclizeAPI internal returns (bytes32 VAR38){
uint VAR39 = VAR31.FUN5(VAR36, VAR12);
if (VAR39 > 1 VAR40 + VAR41.VAR42*VAR12) return 0;
return VAR31.VAR49.value(VAR39)(0, VAR36, VAR46, VAR47, VAR12);
}
function FUN16() oraclizeAPI internal returns (address){
return VAR31.FUN17();
}
function FUN18(byte VAR50) oraclizeAPI internal {
return VAR31.FUN7(VAR50);
}
function FUN19(uint VAR51) oraclizeAPI internal {
return VAR31.FUN8(VAR51);
}
function FUN20(bytes VAR52) oraclizeAPI internal {
}
function FUN13(address VAR17) constant internal returns(uint VAR53) {
VAR54 {
VAR53 := FUN21(VAR17)
}
}
function FUN22(string VAR55) internal returns (address){
bytes memory VAR56 = bytes(VAR55);
uint160 VAR57 = 0;
uint160 VAR58;
uint160 VAR59;
for (uint VAR60=2; VAR60<2+2*20; VAR60+=2){
VAR57 *= 256;
VAR58 = FUN23(VAR56[VAR60]);
VAR59 = FUN23(VAR56[VAR60+1]);
if ((VAR58 >= 97)&&(VAR58 <= 102)) VAR58 -= 87;
else if ((VAR58 >= 48)&&(VAR58 <= 57)) VAR58 -= 48;
if ((VAR59 >= 97)&&(VAR59 <= 102)) VAR59 -= 87;
else if ((VAR59 >= 48)&&(VAR59 <= 57)) VAR59 -= 48;
VAR57 += (VAR58*16+VAR59);
}
return address(VAR57);
}
function FUN24(string VAR55, string VAR61) internal returns (int) {
bytes memory VAR62 = bytes(VAR55);
bytes memory VAR63 = bytes(VAR61);
uint VAR64 = VAR62.VAR65;
if (VAR63.VAR65 < VAR64) VAR64 = VAR63.VAR65;
for (uint VAR60 = 0; VAR60 < VAR64; VAR60 ++)
if (VAR62[VAR60] < VAR63[VAR60])
return -1;
else if (VAR62[VAR60] > VAR63[VAR60])
return 1;
if (VAR62.VAR65 < VAR63.VAR65)
return -1;
else if (VAR62.VAR65 > VAR63.VAR65)
return 1;
else
return 0;
}
function FUN25(string VAR66, string VAR67) internal returns (int)
{
bytes memory VAR68 = bytes(VAR66);
bytes memory VAR69 = bytes(VAR67);
if(VAR68.VAR65 < 1 || VAR69.VAR65 < 1 || (VAR69.VAR65 > VAR68.VAR65))
return -1;
else if(VAR68.VAR65 > (2**128 -1))
return -1;
else
{
uint VAR70 = 0;
for (uint VAR60 = 0; VAR60 < VAR68.VAR65; VAR60 ++)
{
if (VAR68[VAR60] == VAR69[0])
{
VAR70 = 1;
while(VAR70 < VAR69.VAR65 && (VAR60 + VAR70) < VAR68.VAR65 && VAR68[VAR60 + VAR70] == VAR69[VAR70])
{
VAR70++;
}
if(VAR70 == VAR69.VAR65)
return int(VAR60);
}
}
return -1;
}
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72, string VAR73) internal returns (string){
bytes memory VAR74 = bytes(VAR55);
bytes memory VAR75 = bytes(VAR61);
bytes memory VAR76 = bytes(VAR71);
bytes memory VAR77 = bytes(VAR72);
bytes memory VAR78 = bytes(VAR73);
string memory VAR79 = VAR80 string(VAR74.VAR65 + VAR75.VAR65 + VAR76.VAR65 + VAR77.VAR65 + VAR78.VAR65);
bytes memory VAR81 = bytes(VAR79);
uint VAR82 = 0;
for (uint VAR60 = 0; VAR60 < VAR74.VAR65; VAR60++) VAR81[VAR82++] = VAR74[VAR60];
for (VAR60 = 0; VAR60 < VAR75.VAR65; VAR60++) VAR81[VAR82++] = VAR75[VAR60];
for (VAR60 = 0; VAR60 < VAR76.VAR65; VAR60++) VAR81[VAR82++] = VAR76[VAR60];
for (VAR60 = 0; VAR60 < VAR77.VAR65; VAR60++) VAR81[VAR82++] = VAR77[VAR60];
for (VAR60 = 0; VAR60 < VAR78.VAR65; VAR60++) VAR81[VAR82++] = VAR78[VAR60];
return string(VAR81);
}
function FUN26(string VAR55, string VAR61, string VAR71, string VAR72) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, VAR72, "");
}
function FUN26(string VAR55, string VAR61, string VAR71) internal returns (string) {
return FUN26(VAR55, VAR61, VAR71, "", "");
}
function FUN26(string VAR55, string VAR61) internal returns (string) {
return FUN26(VAR55, VAR61, "", "", "");
}
function FUN27(string VAR55) internal returns (uint) {
return FUN27(VAR55, 0);
}
function FUN27(string VAR55, uint VAR61) internal returns (uint) {
bytes memory VAR83 = bytes(VAR55);
uint VAR84 = 0;
bool VAR85 = false;
for (uint VAR60=0; VAR60<VAR83.VAR65; VAR60++){
if ((VAR83[VAR60] >= 48)&&(VAR83[VAR60] <= 57)){
if (VAR85){
if (VAR61 == 0) break;
else VAR61--;
}
VAR84 *= 10;
VAR84 += uint(VAR83[VAR60]) - 48;
} else if (VAR83[VAR60] == 46) VAR85 = true;
}
if (VAR61 > 0) VAR84 *= 10**VAR61;
return VAR84;
}
}
contract FirstContract is VAR18 {
address VAR86;
uint constant VAR87 = 125000;
uint public VAR88  = 0;
uint public VAR89 = 0;
uint VAR90 = 25000;
function FUN28() {
FUN18(VAR23 | VAR24);
VAR86 = msg.sender;
}
function() {
VAR89++;
}
modifier VAR91 {
if (msg.sender != FUN16()) throw;
VAR33;
}
modifier onlyOwner {
if (VAR86 != msg.sender) throw;
VAR33;
}
function FUN29(uint VAR92) onlyOwner {
VAR90 = VAR92;
}
function FUN30() payable onlyOwner {
FUN15("", "", VAR87 + VAR90);
}
function FUN31() payable {
}
function FUN32 (bytes32 VAR93, string VAR94, bytes VAR95) payable VAR91 {
VAR88 = FUN27(VAR94);
}
function FUN33(address VAR96, uint value) private {
if (this.VAR97 < value) {
throw;
}
if (!(VAR96.call.FUN34(VAR90).value(value)())) {
throw;
}
}
function FUN35(uint VAR98) payable onlyOwner {
FUN33(VAR86, VAR98);
}
function FUN36() payable onlyOwner {
FUN37(VAR86);
}
}
1
---------------------------------
171 0xa9b6e2381dee5dd4ea5d6e31e11b3c6f10d35afc.sol
pragma VAR1 ^0.4.17;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint VAR3, uint VAR4) internal pure returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
interface VAR6 {
function FUN6(uint VAR7, uint VAR8, bool VAR9, address VAR10) public payable;
function FUN7(uint VAR7, uint VAR8, bool VAR9, address VAR10) public;
function FUN8() public;
}
interface VAR11 {
function FUN9(uint VAR12, address VAR13, bool VAR14, uint VAR15) public returns (address VAR16, uint VAR17);
function FUN10(address VAR13, address VAR18) public;
function FUN11(uint VAR15) public payable returns (address VAR16);
function FUN12() public view returns(address VAR19, address VAR20);
function FUN13() public view returns (address VAR21, uint VAR22, uint VAR23, address VAR24, address VAR25);
}
contract VAR26 {
using SafeMath for uint256;
string public VAR27 = "";
uint public VAR28;
mapping(address => uint) VAR29;
mapping(address => mapping (address => uint)) VAR30;
event Transfer(address indexed VAR31, address indexed VAR32, uint VAR33);
event FUN14(address indexed VAR34, address indexed VAR35, uint VAR33);
event FUN15(bool VAR36, string VAR37);
function FUN16() public payable {
require(msg.value > 0);
VAR29[msg.sender] = VAR29[msg.sender].FUN4(msg.value);
VAR28 = VAR28.FUN4(msg.value);
}
function FUN17(uint VAR33) public {
VAR29[msg.sender] = VAR29[msg.sender].FUN3(VAR33);
VAR28 = VAR28.FUN3(VAR33);
msg.sender.transfer(VAR33);
}
function FUN18(address VAR34) public constant returns (uint VAR38) { return VAR29[VAR34]; }
function transfer(address VAR32, uint VAR39) public returns (bool VAR40) {
if (VAR29[msg.sender] >= VAR39
&& VAR39 > 0
&& VAR29[VAR32] + VAR39 > VAR29[VAR32]) {
VAR29[msg.sender] = VAR29[msg.sender].FUN3(VAR39);
VAR29[VAR32] = VAR29[VAR32].FUN4(VAR39);
Transfer(msg.sender, VAR32, VAR39);
return true;
} else {
return false;
}
}
function FUN19(address VAR31, address VAR32, uint VAR39) public returns (bool VAR40) {
if (VAR29[VAR31] >= VAR39
&& VAR30[VAR31][msg.sender] >= VAR39
&& VAR39 > 0
&& VAR29[VAR32] + VAR39 > VAR29[VAR32]) {
VAR29[VAR31] = VAR29[VAR31].FUN3(VAR39);
VAR30[VAR31][msg.sender] = VAR30[VAR31][msg.sender].FUN3(VAR39);
VAR29[VAR32] = VAR29[VAR32].FUN4(VAR39);
Transfer(VAR31, VAR32, VAR39);
return true;
} else {
return false;
}
}
function FUN20(address VAR35, uint VAR39) public returns (bool VAR40) {
VAR30[msg.sender][VAR35] = VAR39;
FUN14(msg.sender, VAR35, VAR39);
return true;
}
function FUN21(address VAR34, address VAR35) public view returns (uint VAR41) { return VAR30[VAR34][VAR35]; }
}
contract VAR42{
TokenToTokenSwap_Interface VAR43;
Wrapped_Ether VAR44;
Factory_Interface VAR45;
address public VAR46;
address VAR47;
function FUN22() public {
VAR47 = msg.sender;
}
function FUN23(address VAR48, uint VAR49, uint VAR50, uint VAR51, bool VAR52) payable public returns (bool) {
require(msg.value == VAR49 + VAR51);
VAR43 = FUN24(VAR48);
VAR43.VAR53.value(VAR51)(VAR49, VAR50, VAR52, msg.sender);
address VAR54;
address VAR55;
(VAR54,VAR55) = VAR45.FUN12();
VAR44 = FUN25(VAR54);
VAR44.VAR56.value(msg.value)();
bool VAR40 = VAR44.transfer(VAR48,msg.value);
return VAR40;
}
function FUN26(uint VAR49, uint VAR50, bool VAR52, address VAR48) payable public returns(bool){
require(msg.value ==VAR50);
VAR43 = FUN24(VAR48);
VAR43.FUN7(VAR49, VAR50, VAR52,msg.sender);
address VAR54;
address VAR55;
(VAR54,VAR55) = VAR45.FUN12();
VAR44 = FUN25(VAR55);
VAR44.VAR56.value(msg.value)();
bool VAR40 = VAR44.transfer(VAR48,msg.value);
VAR43.FUN8();
return VAR40;
}
function FUN27(address VAR57) public {
require (msg.sender == VAR47);
VAR46 = VAR57;
VAR45 = FUN28(VAR46);
}
}
1
---------------------------------
172 0xaa12936a79848938770bdbc5da0d49fe986678cc.sol
pragma VAR1 ^0.4.11;
contract VAR2
{
address VAR3 = msg.sender;
event FUN1(uint VAR4,bytes32 VAR5,address VAR6,address VAR7);
mapping(address => uint) VAR8;
function FUN2(uint VAR4, bytes32 VAR5, address VAR6, address VAR7)
payable
{
if(msg.sender != address(this))throw;
if(VAR6.call.value(VAR4)())
{
FUN1(VAR4, VAR5, VAR6, VAR7);
}
}
function FUN3()
public
payable
{
if (msg.value > 0.1 VAR9)
{
VAR8[msg.sender] += msg.value;
}
}
function FUN4(uint VAR4)
public
{
if ( VAR8[msg.sender] > 0 && VAR4 > 0)
{
this.FUN2(VAR4, "", msg.sender, VAR3);
VAR8[msg.sender] -= VAR4;
}
}
function FUN5()
constant
public
returns(uint)
{
return VAR8[msg.sender];
}
function FUN6()
public
{
if(msg.sender==VAR3)
{
this.FUN2(this.VAR10, "", msg.sender, VAR3);
}
}
}
1
---------------------------------
173 0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address=>uint256) public VAR3;
uint public VAR4;
LogFile VAR5;
bool VAR6;
function FUN1(uint VAR7)
public
{
if(VAR6)throw;
VAR4 = VAR7;
}
function FUN2(address VAR8)
public
{
if(VAR6)throw;
VAR5 = FUN3(VAR8);
}
function FUN4()
public
{
VAR6 = true;
}
function FUN5()
public
payable
{
VAR3[msg.sender]+= msg.value;
VAR5.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR9)
public
payable
{
if(VAR3[msg.sender]>=VAR4 && VAR3[msg.sender]>=VAR9)
{
if(msg.sender.call.value(VAR9)())
{
VAR3[msg.sender]-=VAR9;
VAR5.FUN6(msg.sender,VAR9,"");
}
}
}
function()
public
payable
{
FUN5();
}
}
contract VAR10
{
struct VAR11
{
address VAR12;
string  VAR13;
uint VAR14;
uint  VAR15;
}
VAR11[] public VAR16;
Message VAR17;
function FUN6(address VAR18,uint VAR7,string VAR19)
public
{
VAR17.VAR12 = VAR18;
VAR17.VAR15 = VAR20;
VAR17.VAR14 = VAR7;
VAR17.VAR13 = VAR19;
VAR16.FUN8(VAR17);
}
}
1
---------------------------------
174 0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol
pragma VAR1 ^0.4.23;
contract VAR2{
address public VAR3;
address[] public VAR4;
mapping (uint256 => address) public VAR5;
address private VAR6;
uint256 private VAR7;
uint256 private VAR8;
constructor() payable public{
VAR3 = msg.sender;
FUN1();
FUN1();
FUN1();
FUN1();
VAR5[0] = VAR4[0];
VAR5[1] = VAR4[1];
VAR5[2] = VAR4[2];
VAR5[3] = VAR4[3];
}
function FUN2() public{
require(msg.sender == VAR3);
VAR3.transfer(address(this).VAR9);
}
function FUN3() public constant returns(uint256 VAR10){
return VAR4.VAR11;
}
function FUN1() public returns(address VAR12){
require(msg.sender == VAR3);
Puppet VAR13 = VAR14 FUN4();
VAR4.FUN5(VAR13);
return VAR13;
}
function FUN6(uint256 VAR15, address VAR16) public {
require(VAR16 != address(0));
VAR5[VAR15] = VAR16;
}
function FUN7() public payable {
require(msg.sender == VAR3);
VAR7 = VAR17.FUN8(msg.value, 4);
VAR5[0].call.value(VAR7).FUN9(800000)();
VAR5[1].call.value(VAR7).FUN9(800000)();
VAR5[2].call.value(VAR7).FUN9(800000)();
VAR5[3].call.value(VAR7).FUN9(800000)();
}
function() payable public{
}
}
contract VAR18 {
mapping (uint256 => address) public VAR19;
mapping (uint256 => address) public VAR20;
constructor() payable public{
VAR19[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
VAR20[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
}
function() public payable{
if(msg.sender != VAR19[0]){
VAR19[0].call.value(msg.value).FUN9(600000)();
}
}
function FUN2() public{
require(msg.sender == VAR20[0]);
VAR20[0].transfer(address(this).VAR9);
}
}
library VAR17 {
function FUN10(uint256 VAR21, uint256 VAR22) internal pure returns (uint256 VAR23) {
if (VAR21 == 0) {
return 0;
}
VAR23 = VAR21 * VAR22;
assert(VAR23 / VAR21 == VAR22);
return VAR23;
}
function FUN8(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
return VAR21 / VAR22;
}
function FUN11(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
assert(VAR22 <= VAR21);
return VAR21 - VAR22;
}
function FUN12(uint256 VAR21, uint256 VAR22) internal pure returns (uint256 VAR23) {
VAR23 = VAR21 + VAR22;
assert(VAR23 >= VAR21);
return VAR23;
}
}
1
---------------------------------
175 0xb172bb8baae74f27ade3211e0c145388d3b4f8d8.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
address public VAR3;
address public VAR4;
event FUN1(address indexed VAR5, address indexed VAR6);
constructor() public {
VAR3 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR3);
VAR7;
}
function FUN2(address VAR8) public onlyOwner {
VAR4 = VAR8;
}
function FUN3() public {
require(msg.sender == VAR4);
emit FUN1(VAR3, VAR4);
VAR3 = VAR4;
VAR4 = address(0);
}
}
contract Slaughter3D is VAR2 {
using SafeMath for uint;
struct VAR9 {
uint8 VAR10;
uint256 VAR11;
bool VAR12;
mapping (uint8 => address) VAR13;
mapping (address => bool) VAR14;
mapping (uint8 => address) VAR15;
}
HourglassInterface constant VAR16 = FUN4(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
SPASMInterface constant VAR17 = FUN5(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);
Slaughter3DInterface constant VAR18 = FUN6(0xA76daa02C1A6411c6c368f3A59f4f2257a460006);
uint256 constant private VAR19 = 0.005 VAR20;
uint8 constant public VAR21 = 2;
uint256 constant public VAR22 = 0.1 VAR20;
uint256 public VAR23;
uint256 private VAR24 = VAR19 * (VAR21 - 1);
uint256 public VAR25 = 0.185 VAR20;
mapping(address => uint256) public VAR26;
mapping(uint256 => VAR9) public VAR27;
mapping(uint256 => address) public VAR28;
mapping(uint256 => address) public VAR29;
uint256 public  VAR30;
uint256 public  VAR31;
uint256 private VAR32;
uint256 public VAR33;
event FUN7(address indexed VAR34);
event FUN8(address indexed VAR35);
event FUN9(address indexed VAR34, uint256 indexed VAR36);
event FUN10(uint256 indexed VAR37);
uint256 public VAR38;
uint256 public VAR39;
function FUN11()
public
view
returns(address)
{
return (VAR29[VAR32]);
}
function FUN12()
public
view
returns(address)
{
return (VAR27[VAR32].VAR13[0]);
}
function FUN13()
public
view
returns(address)
{
return (VAR27[VAR32].VAR13[1]);
}
function FUN14()
public
view
returns( address )
{
return (VAR27[VAR33].VAR13[0]);
}
function FUN15()
public
view
returns( address )
{
return (VAR27[VAR33].VAR13[1]);
}
function FUN16()
public
view
returns(bool )
{
bool VAR40;
if(VAR33 >= VAR32)
{
if(!VAR27[VAR32].VAR12 && VAR27[VAR32].VAR10 < VAR21 && VAR27[VAR32].VAR11 != 0)
{
VAR40 = true;
}
}
return (VAR40);
}
function FUN17()
public
view
returns(address)
{
return (VAR28[VAR30]);
}
function FUN18()
public
view
returns(uint256)
{
return (VAR16.FUN19(address(this)));
}
uint256 public VAR41 = 10e18;
struct VAR42 {
uint VAR43;
uint VAR44;
}
mapping(address => uint256) public VAR45;
uint256 public VAR46;
mapping(address=>VAR42) public VAR47;
uint public VAR48;
uint public VAR49;
uint public VAR50;
function FUN20(address VAR51) public view returns(uint256) {
uint256 VAR52 = VAR49.FUN21(VAR47[VAR51].VAR44);
return (VAR45[VAR51] * VAR52) / VAR41;
}
modifier FUN22(address VAR51) {
uint256 VAR53 = FUN20(VAR51);
if(VAR53 > VAR45[VAR51]){VAR45[VAR51] = VAR53;}
if(VAR53 > 0 ) {
VAR50 = VAR50.FUN21(VAR53);
VAR26[VAR51] = VAR26[VAR51].FUN23(VAR53);
VAR45[VAR51] = VAR45[VAR51].FUN21(VAR53);
VAR46 = VAR46.FUN21(VAR53);
}
VAR47[VAR51].VAR44 = VAR49;
VAR7;
}
function () external payable{}
function FUN24(address VAR54) public FUN22(VAR54){}
function FUN25() public  payable {
uint256 VAR36 = msg.value;
VAR49 = VAR49.FUN23(VAR36.FUN26(VAR41).FUN27(VAR46));
VAR50 = VAR50.FUN23(VAR36);
}
function FUN28 ()public
{
uint256 VAR55 = VAR16.FUN29(true);
require(VAR55 > 0);
uint256 VAR56 = VAR55.FUN27(100);
VAR16.FUN30();
VAR17.VAR57.value(VAR56.FUN26(5))();
VAR23 = VAR23.FUN23(VAR56.FUN26(95));
}
function FUN31 ()public payable
{
require(msg.value > 0);
VAR23 = VAR23.FUN23(msg.value);
}
function FUN32(uint256 VAR58) onlyOwner public{
uint256 VAR59 = VAR38;
for(uint VAR60=0; VAR60< VAR58; VAR60++)
{
address VAR61 = VAR18.FUN33(VAR59 + VAR60);
VAR60++;
VAR45[VAR61] = VAR45[VAR61].FUN23(0.1 VAR20);
}
VAR38 += VAR60;
VAR46 = VAR46.FUN23(VAR60.FUN26(0.1 VAR20));
}
function FUN34 ()public
{
require(VAR23 > 0.00001 VAR20);
uint256 VAR36 = VAR23;
VAR23 = 0;
VAR49 = VAR49.FUN23(VAR36.FUN26(VAR41).FUN27(VAR46));
VAR50 = VAR50.FUN23(VAR36);
}
modifier FUN35()
{
require(msg.value == VAR22);
VAR7;
}
modifier FUN36()
{
require(VAR26[msg.sender] >= VAR22);
VAR7;
}
modifier FUN37()
{
require(VAR26[msg.sender] > 0);
VAR7;
}
modifier FUN38()
{
if(VAR27[VAR33 - 1].VAR10 == VAR21) {
VAR27[VAR33] = FUN39(0, 0, false );
VAR33++;
}
VAR7;
}
modifier FUN40()
{
require(VAR27[VAR33 - 1].VAR14[msg.sender] == false);
VAR7;
}
constructor()
public
{
VAR27[VAR33] = FUN39(0, 0, false);
VAR33++;
VAR38 = VAR18.FUN41();
VAR39 = 525;
}
function FUN42(address VAR62)
external
payable
VAR63
VAR64
VAR65
{
FUN43(VAR62);
FUN44();
}
function FUN45(address VAR62)
external
VAR66
VAR64
VAR65
{
VAR26[msg.sender] -= VAR22;
FUN43(VAR62);
FUN44();
}
function FUN46(address VAR62, address VAR67)
external
payable
VAR64
{
uint256 value = msg.value;
require(value >= 0.005 VAR20);
require(VAR26[VAR67] >= VAR22);
require(VAR27[VAR33 - 1].VAR14[VAR67] == false);
VAR26[VAR67] -= VAR22;
VAR26[VAR67] += 0.003 VAR20;
VAR17.VAR57.value(0.002 VAR20)();
//
Stage storage VAR68 = VAR27[VAR33 - 1];
assert(VAR68.VAR10 < VAR21);
address VAR34 = VAR67;
VAR68.VAR13[VAR68.VAR10] = VAR34;
VAR68.VAR10++;
VAR68.VAR14[VAR34] = true;
VAR68.VAR15[VAR68.VAR10] = VAR62;
emit FUN7(VAR34);
if(VAR68.VAR10 == VAR21) {
VAR68.VAR11 = VAR69.VAR70;
}
//
FUN44();
}
function FUN30()
external
VAR71
{
FUN44();
uint256 VAR36 = VAR26[msg.sender];
VAR26[msg.sender] = 0;
emit FUN9(msg.sender, VAR36);
msg.sender.transfer(VAR36);
}
function FUN47()
external
view
VAR71
returns(uint256)
{
return VAR26[msg.sender];
}
function FUN48()
external
view
returns(uint256)
{
return VAR27[VAR33 - 1].VAR10;
}
function FUN43(address VAR62)
private
{
Stage storage VAR68 = VAR27[VAR33 - 1];
assert(VAR68.VAR10 < VAR21);
address VAR34 = msg.sender;
VAR68.VAR13[VAR68.VAR10] = VAR34;
VAR68.VAR10++;
VAR68.VAR14[VAR34] = true;
VAR68.VAR15[VAR68.VAR10] = VAR62;
emit FUN7(VAR34);
if(VAR68.VAR10 == VAR21) {
VAR68.VAR11 = VAR69.VAR70;
}
}
function FUN44()
public
{
assert(VAR33 >= VAR32);
if(VAR33 == VAR32) {return;}
Stage storage VAR72 = VAR27[VAR32];
assert(!VAR72.VAR12);
if(VAR72.VAR10 < VAR21) {return;}
assert(VAR72.VAR11 != 0);
if(VAR69.VAR70 - 256 <= VAR72.VAR11) {
if(VAR69.VAR70 == VAR72.VAR11) {return;}
uint8 VAR73 = uint8(FUN49(VAR72.VAR11)) % VAR21;
address VAR74 = VAR72.VAR13[VAR73];
VAR29[VAR32] = VAR74;
emit FUN8(VAR74);
FUN50(VAR74);
FUN24(VAR74);
VAR45[VAR74] = VAR45[VAR74].FUN23(0.1 VAR20);
VAR46 += 0.1 VAR20;
VAR23 = VAR23.FUN23(0.005 VAR20);
VAR16.VAR75.value(0.004 VAR20)(VAR72.VAR15[1]);
VAR16.VAR75.value(0.004 VAR20)(VAR72.VAR15[2]);
VAR17.VAR57.value(0.002 VAR20)();
} else {
FUN51(VAR32);
emit FUN10(VAR32);
}
VAR72.VAR12 = true;
VAR32++;
}
function FUN50(address VAR74)
private
{
for (uint8 VAR60 = 0; VAR60 < VAR21; VAR60++) {
address VAR76 = VAR27[VAR32].VAR13[VAR60];
if(VAR76 != VAR74) {
VAR26[VAR76] += VAR25;
}
}
}
function FUN51(uint256 VAR77)
private
{
Stage storage VAR78 = VAR27[VAR77];
for (uint8 VAR60 = 0; VAR60 < VAR21; VAR60++) {
address VAR34 = VAR78.VAR13[VAR60];
VAR26[VAR34] += VAR22;
}
}
}
interface VAR79 {
function FUN52(address VAR80) payable external returns(uint256);
function FUN30() external;
function FUN29(bool VAR81) external view returns(uint256);
function FUN19(address VAR80) external view returns(uint256);
}
interface VAR82  {
function() payable external;
function FUN25() external  payable;
}
interface VAR83 {
function FUN33(uint256 VAR84) external view returns(address);
function FUN41() external view returns(uint256);
function FUN53() external view returns(uint256);
}
library VAR85 {
function FUN23(uint VAR86, uint VAR87) internal pure returns (uint VAR88) {
VAR88 = VAR86 + VAR87;
require(VAR88 >= VAR86);
}
function FUN21(uint VAR86, uint VAR87) internal pure returns (uint VAR88) {
require(VAR87 <= VAR86);
VAR88 = VAR86 - VAR87;
}
function FUN26(uint VAR86, uint VAR87) internal pure returns (uint VAR88) {
VAR88 = VAR86 * VAR87;
require(VAR86 == 0 || VAR88 / VAR86 == VAR87);
}
function FUN27(uint VAR86, uint VAR87) internal pure returns (uint VAR88) {
require(VAR87 > 0);
VAR88 = VAR86 / VAR87;
}
}
1
---------------------------------
176 0xb1dd690cc9af7bb1a906a9b5a94f94191cc553ce.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
contract VAR6 {
address public VAR7;
address public VAR8;
mapping (address => bool) public VAR9;
mapping (bytes4 => address) public VAR10;
uint public VAR11;
event FUN4(address indexed VAR12, bool value);
event FUN5(address indexed VAR12, bytes4 indexed VAR13);
event FUN6(address indexed VAR12, address indexed VAR14, uint indexed value, bytes VAR15);
event FUN7(uint indexed value, address indexed sender, bytes VAR15);
event FUN8(address VAR8);
modifier VAR16 {
require(VAR9[msg.sender], "");
VAR17;
}
function FUN1(address VAR18, address[] VAR19) external {
require(VAR8 == address(0) && VAR11 == 0, "");
require(VAR19.VAR20 > 0, "");
VAR8 = VAR18;
VAR11 = VAR19.VAR20;
for(uint256 VAR21 = 0; VAR21 < VAR19.VAR20; VAR21++) {
require(VAR9[VAR19[VAR21]] == false, "");
VAR9[VAR19[VAR21]] = true;
FUN9(VAR19[VAR21]).FUN1(this);
emit FUN4(VAR19[VAR21], true);
}
}
function FUN10(address VAR4, bool VAR22) external VAR16 {
if (VAR9[VAR4] != VAR22) {
if(VAR22 == true) {
VAR11 += 1;
VAR9[VAR4] = true;
FUN9(VAR4).FUN1(this);
}
else {
VAR11 -= 1;
require(VAR11 > 0, "");
delete VAR9[VAR4];
}
emit FUN4(VAR4, VAR22);
}
}
function FUN11(address VAR4, bytes4 VAR23) external VAR16 {
require(VAR9[VAR4], "");
VAR10[VAR23] = VAR4;
emit FUN5(VAR4, VAR23);
}
function FUN12(address VAR24) external VAR16 {
require(VAR24 != address(0), "");
VAR8 = VAR24;
emit FUN8(VAR24);
}
function FUN13(address VAR25, uint VAR22, bytes VAR26) external VAR16 {
require(VAR25.call.value(VAR22)(VAR26), "");
emit FUN6(msg.sender, VAR25, VAR22, VAR26);
}
function() public payable {
if(msg.VAR15.VAR20 > 0) {
address VAR12 = VAR10[msg.VAR27];
if(VAR12 == address(0)) {
emit FUN7(msg.value, msg.sender, msg.VAR15);
}
else {
require(VAR9[VAR12], "");
VAR28 {
FUN14(0, 0, FUN15())
let VAR29 := FUN16(VAR30, VAR12, 0, FUN15(), 0, 0)
FUN17(0, 0, FUN18())
switch VAR29
case 0 {revert(0, FUN18())}
default {return (0, FUN18())}
}
}
}
}
}
1
---------------------------------
177 0xb2236d432dcccd693d53ee3fb57ac506087bd831.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
}
library VAR6 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
}
contract VAR7 {
address public VAR8;
event FUN12(address indexed VAR9, address indexed VAR10);
function FUN13() {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR11;
}
function FUN14(address VAR10) onlyOwner public {
require(VAR10 != address(0));
FUN12(VAR8, VAR10);
VAR8 = VAR10;
}
}
contract Haltable is VAR7 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR11;
}
modifier VAR14 {
if (VAR12 && msg.sender != VAR8) throw;
VAR11;
}
modifier VAR15 {
if (!VAR12) throw;
VAR11;
}
function FUN15() external onlyOwner {
VAR12 = true;
}
function FUN16() external onlyOwner VAR15 {
VAR12 = false;
}
}
contract VAR16 {
function FUN17() public constant returns (bool) {
return true;
}
function FUN18(address VAR17) public constant returns (bool) {
return true;
}
function FUN19(address VAR18) public constant returns (bool) {
return false;
}
function FUN20(uint value, uint VAR19, uint VAR20, address VAR21, uint VAR22) public constant returns (uint VAR23);
}
contract VAR24 {
function FUN21() public constant returns(bool) {
return true;
}
function FUN18() public constant returns (bool);
function FUN22();
}
contract VAR25 {
uint256 public VAR26;
function FUN23(address VAR27) public constant returns (uint256);
function transfer(address VAR28, uint256 value) public returns (bool);
event Transfer(address indexed VAR29, address indexed VAR28, uint256 value);
}
contract ERC20 is VAR25 {
function FUN24(address VAR8, address VAR30) public constant returns (uint256);
function FUN25(address VAR29, address VAR28, uint256 value) public returns (bool);
function FUN26(address VAR30, uint256 value) public returns (bool);
event FUN27(address indexed VAR8, address indexed VAR30, uint256 value);
}
contract FractionalERC20 is VAR31 {
uint public VAR22;
}
contract Crowdsale is VAR32 {
uint public VAR33 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR34;
PricingStrategy public VAR35;
FinalizeAgent public VAR36;
address public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR40;
uint public VAR20 = 0;
uint public VAR19 = 0;
uint public VAR41 = 0;
uint public VAR42 = 0;
uint public VAR43 = 0;
uint public VAR44 = 0;
bool public VAR45;
bool public VAR46;
bool public VAR47;
address public VAR48;
mapping (address => uint256) public VAR49;
mapping (address => uint256) public VAR50;
mapping (address => bool) public VAR51;
uint public VAR52;
enum VAR53{VAR54, VAR55, VAR56, VAR57, VAR58, VAR59, VAR60, VAR61}
event FUN28(address VAR62, uint VAR63, uint VAR23, uint128 VAR64);
event FUN29(address VAR62, uint VAR63);
event FUN30(bool VAR65, bool VAR66, address VAR67);
event FUN31(address VAR68, bool VAR69);
event FUN32(uint VAR70);
function FUN33(address VAR71, PricingStrategy VAR72, address VAR73, uint VAR74, uint VAR75, uint VAR76) {
VAR8 = msg.sender;
VAR34 = FUN34(VAR71);
FUN35(VAR72);
VAR37 = VAR73;
if(VAR37 == 0) {
throw;
}
if(VAR74 == 0) {
throw;
}
VAR39 = VAR74;
if(VAR75 == 0) {
throw;
}
VAR40 = VAR75;
if(VAR39 >= VAR40) {
throw;
}
VAR38 = VAR76;
}
function() payable {
throw;
}
function FUN36(address VAR77, uint128 VAR64) stopInEmergency private {
if(FUN37() == VAR53.VAR56) {
if(!VAR51[VAR77]) {
throw;
}
} else if(FUN37() == VAR53.VAR57) {
} else {
throw;
}
uint VAR63 = msg.value;
uint VAR23 = VAR35.FUN20(VAR63, VAR19 - VAR41, VAR20, msg.sender, VAR34.FUN38());
if(VAR23 == 0) {
throw;
}
if(VAR49[VAR77] == 0) {
VAR42++;
}
VAR49[VAR77] = VAR49[VAR77].FUN11(VAR63);
VAR50[VAR77] = VAR50[VAR77].FUN11(VAR23);
VAR19 = VAR19.FUN11(VAR63);
VAR20 = VAR20.FUN11(VAR23);
if(VAR35.FUN19(VAR77)) {
VAR41 = VAR41.FUN11(VAR63);
}
if(FUN39(VAR63, VAR23, VAR19, VAR20)) {
throw;
}
FUN40(VAR77, VAR23);
if(!VAR37.FUN41(VAR63)) throw;
FUN28(VAR77, VAR63, VAR23, VAR64);
}
function FUN42(address VAR77, uint VAR78, uint VAR79) public onlyOwner {
uint VAR23 = VAR78 * 10**VAR34.FUN38();
uint VAR63 = VAR79 * VAR78;
VAR19 = VAR19.FUN11(VAR63);
VAR20 = VAR20.FUN11(VAR23);
VAR49[VAR77] = VAR49[VAR77].FUN11(VAR63);
VAR50[VAR77] = VAR50[VAR77].FUN11(VAR23);
FUN40(VAR77, VAR23);
FUN28(VAR77, VAR63, VAR23, 0);
}
function FUN43(address VAR68, uint128 VAR64, uint8 VAR80, bytes32 VAR81, bytes32 VAR82) public payable {
bytes32 VAR83 = FUN44(VAR68);
if (FUN45(VAR83, VAR80, VAR81, VAR82) != VAR48) throw;
if(VAR64 == 0) throw;
FUN36(VAR68, VAR64);
}
function FUN46(address VAR68, uint128 VAR64) public payable {
if(VAR47) throw;
if(VAR64 == 0) throw;
FUN36(VAR68, VAR64);
}
function FUN47(address VAR68) public payable {
if(VAR46) throw;
if(VAR47) throw;
FUN36(VAR68, 0);
}
function FUN48(uint128 VAR64, uint8 VAR80, bytes32 VAR81, bytes32 VAR82) public payable {
FUN43(msg.sender, VAR64, VAR80, VAR81, VAR82);
}
function FUN49(uint128 VAR64) public payable {
FUN46(msg.sender, VAR64);
}
function FUN50() public payable {
FUN47(msg.sender);
}
function FUN51() public FUN52(VAR53.VAR58) onlyOwner VAR13 {
if(VAR45) {
throw;
}
if(address(VAR36) != 0) {
VAR36.FUN22();
}
VAR45 = true;
}
function FUN53(FinalizeAgent VAR68) onlyOwner {
VAR36 = VAR68;
if(!VAR36.FUN21()) {
throw;
}
}
function FUN54(bool value) onlyOwner {
VAR46 = value;
FUN30(VAR46, VAR47, VAR48);
}
function FUN55(bool value, address VAR84) onlyOwner {
VAR47 = value;
VAR48 = VAR84;
FUN30(VAR46, VAR47, VAR48);
}
function FUN56(address VAR68, bool VAR69) onlyOwner {
VAR51[VAR68] = VAR69;
FUN31(VAR68, VAR69);
}
function FUN57(uint VAR85) onlyOwner {
if(VAR86 > VAR85) {
throw;
}
VAR40 = VAR85;
FUN32(VAR40);
}
function FUN35(PricingStrategy VAR72) onlyOwner {
VAR35 = VAR72;
if(!VAR35.FUN17()) {
throw;
}
}
function FUN58(address VAR68) public onlyOwner {
if(VAR42 > VAR33) {
throw;
}
VAR37 = VAR68;
}
function FUN59() public payable FUN52(VAR53.VAR59) {
if(msg.value == 0) throw;
VAR43 = VAR43.FUN11(msg.value);
}
function FUN60() public FUN52(VAR53.VAR61) {
uint256 VAR87 = VAR49[msg.sender];
if (VAR87 == 0) throw;
VAR49[msg.sender] = 0;
VAR44 = VAR44.FUN11(VAR87);
FUN29(msg.sender, VAR87);
if (!msg.sender.FUN41(VAR87)) throw;
}
function FUN61() public constant returns (bool VAR88) {
return VAR19 >= VAR38;
}
function FUN62() public constant returns (bool VAR89) {
return VAR36.FUN18();
}
function FUN63() public constant returns (bool VAR89) {
return VAR35.FUN18(address(this));
}
function FUN37() public constant returns (VAR53) {
if(VAR45) return VAR53.VAR60;
else if (address(VAR36) == 0) return VAR53.VAR55;
else if (!VAR36.FUN18()) return VAR53.VAR55;
else if (!VAR35.FUN18(address(this))) return VAR53.VAR55;
else if (VAR90.VAR91 < VAR39) return VAR53.VAR56;
else if (VAR90.VAR91 <= VAR40 && !FUN64()) return VAR53.VAR57;
else if (FUN61()) return VAR53.VAR58;
else if (!FUN61() && VAR19 > 0 && VAR43 >= VAR19) return VAR53.VAR61;
else return VAR53.VAR59;
}
function FUN65(uint VAR92) onlyOwner {
VAR52 = VAR92;
}
function FUN66() public constant returns (bool) {
return true;
}
//
//
modifier FUN52(State VAR93) {
if(FUN37() != VAR93) throw;
VAR11;
}
//
//
function FUN39(uint VAR63, uint VAR23, uint VAR94, uint VAR95) constant returns (bool VAR96);
function FUN64() public constant returns (bool);
function FUN40(address VAR77, uint VAR23) private;
}
contract StandardToken is VAR31, VAR1 {
event FUN67(address VAR77, uint VAR97);
mapping(address => uint) VAR98;
mapping (address => mapping (address => uint)) VAR99;
function FUN68() public constant returns (bool VAR100) {
return true;
}
function transfer(address VAR101, uint VAR102) returns (bool VAR103) {
VAR98[msg.sender] = FUN3(VAR98[msg.sender], VAR102);
VAR98[VAR101] = FUN4(VAR98[VAR101], VAR102);
Transfer(msg.sender, VAR101, VAR102);
return true;
}
function FUN25(address VAR104, address VAR101, uint VAR102) returns (bool VAR103) {
uint VAR105 = VAR99[VAR104][msg.sender];
VAR98[VAR101] = FUN4(VAR98[VAR101], VAR102);
VAR98[VAR104] = FUN3(VAR98[VAR104], VAR102);
VAR99[VAR104][msg.sender] = FUN3(VAR105, VAR102);
Transfer(VAR104, VAR101, VAR102);
return true;
}
function FUN23(address VAR106) constant returns (uint VAR107) {
return VAR98[VAR106];
}
function FUN26(address VAR108, uint VAR102) returns (bool VAR103) {
if ((VAR102 != 0) && (VAR99[msg.sender][VAR108] != 0)) throw;
VAR99[msg.sender][VAR108] = VAR102;
FUN27(msg.sender, VAR108, VAR102);
return true;
}
function FUN24(address VAR106, address VAR108) constant returns (uint VAR109) {
return VAR99[VAR106][VAR108];
}
}
contract PreICOProxyBuyer is VAR7, VAR32, VAR1 {
uint public VAR42;
uint public VAR19;
address[] public VAR110;
mapping(address => uint) public VAR98;
mapping(address => uint) public VAR111;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
uint public VAR116;
uint public VAR117;
uint public VAR118;
bool public VAR119;
Crowdsale public VAR17;
enum VAR53{VAR54, VAR57, VAR120, VAR61}
event FUN28(address VAR62, uint VAR63, uint VAR23, uint128 VAR64);
event FUN69(address VAR62, uint value);
event FUN70(uint VAR121);
event FUN71(address VAR62, uint VAR121);
function FUN72(address VAR106, uint VAR122, uint VAR123, uint VAR124, uint VAR125) {
VAR8 = VAR106;
if(VAR122 == 0) {
throw;
}
if(VAR123 == 0) {
throw;
}
if(VAR124 == 0) {
throw;
}
VAR113 = VAR123;
VAR114 = VAR124;
VAR115 = VAR125;
VAR112 = VAR122;
}
function FUN73() public constant returns(VAR126) {
if(address(VAR17) == 0)  {
throw;
}
return VAR17.FUN74();
}
function FUN47(uint128 VAR64) private {
if(FUN37() != VAR53.VAR57) throw;
if(msg.value == 0) throw;
address VAR62 = msg.sender;
bool VAR127 = VAR98[VAR62] > 0;
VAR98[VAR62] = FUN4(VAR98[VAR62], msg.value);
if(VAR98[VAR62] < VAR113 || VAR98[VAR62] > VAR114) {
throw;
}
if(!VAR127) {
VAR110.FUN75(VAR62);
VAR42++;
}
VAR19 = FUN4(VAR19, msg.value);
if(VAR19 > VAR115) {
throw;
}
FUN28(VAR62, msg.value, 0, VAR64);
}
function FUN49(uint128 VAR64) public stopInEmergency payable {
FUN47(VAR64);
}
function FUN50() public stopInEmergency payable {
FUN47(0x0);
}
function FUN76() stopNonOwnersInEmergency public {
if(FUN37() != VAR53.VAR57) {
throw;
}
if(address(VAR17) == 0) throw;
VAR17.VAR128.value(VAR19)(address(this));
VAR116 = FUN73().FUN23(address(this));
if(VAR116 == 0) {
throw;
}
FUN70(VAR116);
}
function FUN77(address VAR62) public constant returns (uint) {
if(FUN37() != VAR53.VAR120) {
throw;
}
return FUN1(VAR98[VAR62], VAR116) / VAR19;
}
function FUN78(address VAR62) public constant returns (uint) {
return FUN3(FUN77(VAR62), VAR111[VAR62]);
}
function FUN79() {
FUN80(FUN78(msg.sender));
}
function FUN80(uint VAR97) VAR13 {
address VAR62 = msg.sender;
if(VAR97 == 0) {
throw;
}
if(FUN78(VAR62) < VAR97) {
throw;
}
if(VAR111[VAR62] == 0) {
VAR117++;
}
VAR111[VAR62] = FUN4(VAR111[VAR62], VAR97);
VAR118 = FUN4(VAR118, VAR97);
FUN73().transfer(VAR62, VAR97);
FUN71(VAR62, VAR97);
}
function FUN60() VAR13 {
if(FUN37() != VAR53.VAR61) throw;
address VAR62 = msg.sender;
if(VAR98[VAR62] == 0) throw;
uint VAR97 = VAR98[VAR62];
delete VAR98[VAR62];
if(!(VAR62.call.value(VAR97)())) throw;
FUN69(VAR62, VAR97);
}
function FUN81(Crowdsale VAR129) public onlyOwner {
VAR17 = VAR129;
if(!VAR17.FUN66()) true;
}
function FUN82() public onlyOwner {
VAR119 = true;
}
function FUN59() public payable {
if(FUN37() != VAR53.VAR61) throw;
}
function FUN37() public returns(VAR53) {
if (VAR119)
return VAR53.VAR61;
if(VAR116 == 0) {
if(VAR86 >= VAR112) {
return VAR53.VAR61;
} else {
return VAR53.VAR57;
}
} else {
return VAR53.VAR120;
}
}
function FUN83() public constant returns (bool) {
return true;
}
function() payable {
throw;
}
}
1
---------------------------------
178 0xb2d5468cf99176da50f91e46b2c06b7bdb9d2656.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
address constant VAR3 = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23;
event FUN1(address VAR4);
event FUN2(address VAR4);
event FUN3(address VAR5, address VAR4);
mapping (address => address) public VAR6;
mapping (address => bool) public VAR7;
address private VAR8;
constructor(address VAR9) public {
VAR8 = VAR9;
}
function () external payable {
if (VAR6[msg.sender] == address(0)) {
FUN4(msg.sender, address(0));
} else {
if (msg.value == 0) {
FUN5(msg.sender);
} else if (msg.value == 0.00001111 VAR10) {
FUN6();
} else {
revert();
}
}
}
function FUN4(address VAR11, address VAR12) payable public {
require(VAR6[VAR11] == address(0), "");
require(msg.value >= 0.45 VAR10 && msg.value <= 225 VAR10, "");
VAR6[VAR11] = address(VAR13 FUN7(VAR11, msg.value / 45));
FUN5(VAR11);
VAR8.FUN8(msg.value / 33);
if (VAR12 != address(0) && VAR7[VAR12]) {
VAR12.FUN8(msg.value / 20);
}
emit FUN1(VAR11);
}
function FUN9(address VAR11) public {
require(!VAR7[VAR11], "");
VAR7[VAR11] = true;
EasySmartolutionRef VAR14 = VAR13 FUN10();
VAR14.FUN11(VAR11);
VAR14.FUN12(address(this));
emit FUN3(address(VAR14), VAR11);
}
function FUN5(address VAR11) public {
Participant VAR15 = FUN7(VAR6[VAR11]);
bool VAR16 = VAR15.VAR17.value(VAR15.FUN13())();
if (VAR16) {
VAR6[VAR11] = address(0);
emit FUN2(VAR11);
}
}
function FUN6() public {
require(VAR6[msg.sender] != address(0), "");
Participant VAR15 = FUN7(VAR6[msg.sender]);
uint VAR18;
uint value;
(value, VAR18, ) = FUN14(VAR3).FUN15(address(VAR15));
uint VAR19 = (45 - VAR18) * value;
if (VAR19 > address(this).VAR20) {
VAR19 = address(this).VAR20;
}
VAR6[msg.sender] = address(0);
emit FUN2(msg.sender);
msg.sender.transfer(VAR19);
}
}
contract VAR21 {
address public VAR22;
address public VAR3;
constructor () public {
}
function FUN11(address VAR12) external {
require(VAR22 == address(0), "");
VAR22 = VAR12;
}
function FUN12(address VAR23) external {
require(VAR3 == address(0), "");
VAR3 = VAR23;
}
function () external payable {
if (msg.value > 0) {
FUN16(VAR3).VAR24.value(msg.value)(msg.sender, VAR22);
} else {
FUN16(VAR3).FUN5(msg.sender);
}
}
}
contract VAR25 {
address constant VAR3 = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23;
address public VAR26;
uint public VAR27;
constructor(address VAR28, uint VAR29) public {
VAR26 = VAR28;
VAR27 = VAR29;
}
function () external payable {}
function FUN5() external payable returns (bool) {
require(msg.value == VAR27, "");
uint VAR30;
uint VAR18;
(,VAR30,) = FUN14(VAR3).FUN15(address(this));
VAR3.call.value(msg.value)();
(,VAR18,) = FUN14(VAR3).FUN15(address(this));
require(VAR18 != VAR30, "");
VAR26.FUN8(address(this).VAR20);
return VAR18 == 45;
}
}
contract VAR31 {
struct VAR32 {
uint value;
uint VAR18;
uint VAR33;
}
mapping (address => VAR32) public VAR34;
}
1
---------------------------------
179 0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address public VAR3 = msg.sender;
uint public VAR4;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR5;
}
function() public payable {
VAR4++;
}
function FUN1() public onlyOwner {
FUN2(address(this).VAR6);
}
function FUN2(uint VAR7) public onlyOwner {
msg.sender.transfer(VAR7);
}
function FUN3(address VAR8, uint VAR7) public onlyOwner {
VAR8.call.value(VAR7)();
}
}
1
---------------------------------
180 0xb4a448387403554616eb5b50aa4c48f75243a015.sol
pragma VAR1^0.4.24;
interface VAR2 {
function FUN1() external payable;
}
interface VAR3 {
function FUN2() external;
function FUN3(uint VAR4) external view
returns(
address VAR5,
uint VAR6,
uint VAR7,
uint VAR8,
uint VAR9,
uint VAR10,
uint VAR11,
uint VAR12,
uint VAR13,
bool VAR14
);
function FUN4() external view
returns(
uint VAR15,
uint VAR16,
uint VAR17,
uint VAR18
);
function FUN5() external returns(uint);
}
contract VAR19 {
function FUN6(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
require((VAR22 = VAR20 + VAR21) >= VAR20);
}
function FUN7(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
require((VAR22 = VAR20 - VAR21) <= VAR20);
}
function FUN8(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
require(VAR21 == 0 || (VAR22 = VAR20 * VAR21) / VAR21 == VAR20);
}
function FUN9(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
return VAR20 <= VAR21 ? VAR20 : VAR21;
}
function FUN10(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
return VAR20 >= VAR21 ? VAR20 : VAR21;
}
function FUN11(int VAR20, int VAR21) internal pure returns (int VAR22) {
return VAR20 <= VAR21 ? VAR20 : VAR21;
}
function FUN12(int VAR20, int VAR21) internal pure returns (int VAR22) {
return VAR20 >= VAR21 ? VAR20 : VAR21;
}
uint constant VAR23 = 10 ** 18;
uint constant VAR24 = 10 ** 27;
function FUN13(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
VAR22 = FUN6(FUN8(VAR20, VAR21), VAR23 / 2) / VAR23;
}
function FUN14(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
VAR22 = FUN6(FUN8(VAR20, VAR21), VAR24 / 2) / VAR24;
}
function FUN15(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
VAR22 = FUN6(FUN8(VAR20, VAR23), VAR21 / 2) / VAR21;
}
function FUN16(uint VAR20, uint VAR21) internal pure returns (uint VAR22) {
VAR22 = FUN6(FUN8(VAR20, VAR24), VAR21 / 2) / VAR21;
}
//
//
//
//
//
function FUN17(uint VAR20, uint VAR25) internal pure returns (uint VAR22) {
VAR22 = VAR25 % 2 != 0 ? VAR20 : VAR24;
for (VAR25 /= 2; VAR25 != 0; VAR25 /= 2) {
VAR20 = FUN14(VAR20, VAR20);
if (VAR25 % 2 != 0) {
VAR22 = FUN14(VAR22, VAR20);
}
}
}
}
contract VAR26 {
function FUN18(
address VAR27, address VAR28, bytes4 VAR29
) public view returns (bool);
}
contract VAR30 {
event FUN19 (address indexed VAR31);
event FUN20     (address indexed VAR32);
}
contract DSAuth is VAR30 {
DSA  public  VAR33;
address      public  VAR32;
constructor() public {
VAR32 = msg.sender;
emit FUN20(msg.sender);
}
function FUN21(address VAR34)
public
VAR35
{
VAR32 = VAR34;
emit FUN20(VAR32);
}
function FUN22(DSA VAR36)
public
VAR35
{
VAR33 = VAR36;
emit FUN19(VAR33);
}
modifier VAR35 {
require(FUN23(msg.sender, msg.VAR29));
VAR37;
}
function FUN23(address VAR27, bytes4 VAR29) internal view returns (bool) {
if (VAR27 == address(this)) {
return true;
} else if (VAR27 == VAR32) {
return true;
} else if (VAR33 == FUN24(0)) {
return false;
} else {
return VAR33.FUN18(VAR27, this, VAR29);
}
}
}
contract VAR38 {
address public VAR39;
function FUN25(uint VAR40, string VAR41, string VAR42) external payable returns (bytes32 VAR43);
function FUN26(uint VAR40, string VAR41, string VAR42, uint VAR44) external payable returns (bytes32 VAR43);
function FUN27(uint VAR40, string VAR41, string VAR45, string VAR46) public payable returns (bytes32 VAR43);
function FUN28(uint VAR40, string VAR41, string VAR45, string VAR46, uint VAR44) external payable returns (bytes32 VAR43);
function FUN29(uint VAR40, string VAR41, bytes VAR47) public payable returns (bytes32 VAR43);
function FUN30(uint VAR40, string VAR41, bytes VAR47, uint VAR44) external payable returns (bytes32 VAR43);
function FUN31(string VAR41) public returns (uint VAR48);
function FUN31(string VAR41, uint VAR49) public returns (uint VAR48);
function FUN32(byte VAR50) external;
function FUN33(uint VAR51) external;
function FUN34() external constant returns(bytes32);
}
contract VAR52 {
function FUN35() public returns (address VAR53);
}
library VAR54 {
struct VAR55 {
bytes VAR56;
uint VAR57;
}
function FUN36(buffer memory VAR56, uint VAR58) internal pure {
uint VAR57 = VAR58;
if(VAR57 % 32 != 0) VAR57 += 32 - (VAR57 % 32);
VAR56.VAR57 = VAR57;
VAR59 {
let VAR60 := FUN37(0x40)
FUN38(VAR56, VAR60)
FUN38(VAR60, 0)
FUN38(0x40, FUN6(VAR60, VAR57))
}
}
function FUN39(buffer memory VAR56, uint VAR57) private pure {
bytes memory VAR61 = VAR56.VAR56;
FUN36(VAR56, VAR57);
FUN40(VAR56, VAR61);
}
function FUN10(uint VAR33, uint VAR62) private pure returns(uint) {
if(VAR33 > VAR62) {
return VAR33;
}
return VAR62;
}
function FUN40(buffer memory VAR56, bytes VAR63) internal pure returns(buffer VAR64) {
if(VAR63.VAR65 + VAR56.VAR56.VAR65 > VAR56.VAR57) {
FUN39(VAR56, FUN10(VAR56.VAR57, VAR63.VAR65) * 2);
}
uint VAR66;
uint VAR27;
uint VAR67 = VAR63.VAR65;
VAR59 {
let VAR68 := FUN37(VAR56)
let VAR69 := FUN37(VAR68)
VAR66 := FUN6(FUN6(VAR68, VAR69), 32)
FUN38(VAR68, FUN6(VAR69, FUN37(VAR63)))
VAR27 := FUN6(VAR63, 32)
}
for(; VAR67 >= 32; VAR67 -= 32) {
VAR59 {
FUN38(VAR66, FUN37(VAR27))
}
VAR66 += 32;
VAR27 += 32;
}
uint VAR70 = 256 ** (32 - VAR67) - 1;
VAR59 {
let VAR71 := FUN41(FUN37(VAR27), FUN42(VAR70))
let VAR72 := FUN41(FUN37(VAR66), VAR70)
FUN38(VAR66, or(VAR72, VAR71))
}
return VAR56;
}
function FUN40(buffer memory VAR56, uint8 VAR63) internal pure {
if(VAR56.VAR56.VAR65 + 1 > VAR56.VAR57) {
FUN39(VAR56, VAR56.VAR57 * 2);
}
VAR59 {
let VAR68 := FUN37(VAR56)
let VAR69 := FUN37(VAR68)
let VAR66 := FUN6(FUN6(VAR68, VAR69), 32)
FUN43(VAR66, VAR63)
FUN38(VAR68, FUN6(VAR69, 1))
}
}
function FUN44(buffer memory VAR56, uint VAR63, uint VAR67) internal pure returns(buffer VAR64) {
if(VAR67 + VAR56.VAR56.VAR65 > VAR56.VAR57) {
FUN39(VAR56, FUN10(VAR56.VAR57, VAR67) * 2);
}
uint VAR70 = 256 ** VAR67 - 1;
VAR59 {
let VAR68 := FUN37(VAR56)
let VAR69 := FUN37(VAR68)
let VAR66 := FUN6(FUN6(VAR68, VAR69), VAR67)
FUN38(VAR66, or(FUN41(FUN37(VAR66), FUN42(VAR70)), VAR63))
FUN38(VAR68, FUN6(VAR69, VAR67))
}
return VAR56;
}
}
library VAR73 {
using Buffer for VAR54.VAR55;
uint8 private constant VAR74 = 0;
uint8 private constant VAR75 = 1;
uint8 private constant VAR76 = 2;
uint8 private constant VAR77 = 3;
uint8 private constant VAR78 = 4;
uint8 private constant VAR79 = 5;
uint8 private constant VAR80 = 7;
function FUN45(VAR54.buffer memory VAR56, uint8 VAR81, uint value) private pure {
if(value <= 23) {
VAR56.FUN40(uint8((VAR81 << 5) | value));
} else if(value <= 0xFF) {
VAR56.FUN40(uint8((VAR81 << 5) | 24));
VAR56.FUN44(value, 1);
} else if(value <= 0xFFFF) {
VAR56.FUN40(uint8((VAR81 << 5) | 25));
VAR56.FUN44(value, 2);
} else if(value <= 0xFFFFFFFF) {
VAR56.FUN40(uint8((VAR81 << 5) | 26));
VAR56.FUN44(value, 4);
} else if(value <= 0xFFFFFFFFFFFFFFFF) {
VAR56.FUN40(uint8((VAR81 << 5) | 27));
VAR56.FUN44(value, 8);
}
}
function FUN46(VAR54.buffer memory VAR56, uint8 VAR81) private pure {
VAR56.FUN40(uint8((VAR81 << 5) | 31));
}
function FUN47(VAR54.buffer memory VAR56, uint value) internal pure {
FUN45(VAR56, VAR74, value);
}
function FUN48(VAR54.buffer memory VAR56, int value) internal pure {
if(value >= 0) {
FUN45(VAR56, VAR74, uint(value));
} else {
FUN45(VAR56, VAR75, uint(-1 - value));
}
}
function FUN49(VAR54.buffer memory VAR56, bytes value) internal pure {
FUN45(VAR56, VAR76, value.VAR65);
VAR56.FUN40(value);
}
function FUN50(VAR54.buffer memory VAR56, string value) internal pure {
FUN45(VAR56, VAR77, bytes(value).VAR65);
VAR56.FUN40(bytes(value));
}
function FUN51(VAR54.buffer memory VAR56) internal pure {
FUN46(VAR56, VAR78);
}
function FUN52(VAR54.buffer memory VAR56) internal pure {
FUN46(VAR56, VAR79);
}
function FUN53(VAR54.buffer memory VAR56) internal pure {
FUN46(VAR56, VAR80);
}
}
contract usingOraclize is VAR82 {
byte constant VAR83 = 0x00;
byte constant VAR84 = 0x10;
byte constant VAR85 = 0x30;
byte constant VAR86 = 0x40;
byte constant VAR87 = 0xF0;
byte constant VAR88 = 0x01;
uint8 constant VAR89 = 0;
uint8 constant VAR90 = 1;
uint8 constant VAR91 = 2;
uint8 constant VAR92 = 2;
uint8 constant VAR93 = 161;
OraclizeAddrResolverI VAR94;
OraclizeI VAR95;
modifier VAR96 {
if((address(VAR94)==0)||(FUN54(address(VAR94))==0))
FUN55(VAR89);
if(address(VAR95) != VAR94.FUN35())
VAR95 = FUN56(VAR94.FUN35());
VAR37;
}
modifier FUN57(string VAR97){
VAR95 = FUN56(VAR94.FUN35());
VAR37;
}
function FUN55(uint8 VAR98) internal returns(bool){
return FUN55();
VAR98;
}
function FUN55() internal returns(bool){
if (FUN54(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR94 = FUN58(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN59("");
return true;
}
if (FUN54(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR94 = FUN58(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN59("");
return true;
}
return false;
}
function FUN60() oraclizeAPI internal returns (address){
return VAR95.FUN61();
}
function FUN62(bytes32 VAR99, string VAR100) public {
FUN62(VAR99, VAR100, VAR101 bytes(0));
}
function FUN62(bytes32 VAR99, string VAR100, bytes VAR102) public {
return;
VAR99; VAR100; VAR102;
VAR95 = FUN56(0);
}
function FUN63(string VAR103) oraclizeAPI internal returns (uint){
return VAR95.FUN31(VAR103);
}
function FUN63(string VAR103, uint VAR49) oraclizeAPI internal returns (uint){
return VAR95.FUN31(VAR103, VAR49);
}
function FUN64(string VAR103, bytes[] VAR104, uint VAR49) oraclizeAPI internal returns (bytes32 VAR105){
uint VAR6 = VAR95.FUN31(VAR103, VAR49);
if (VAR6 > 1 VAR106 + VAR107.VAR108*VAR49) return 0;
bytes memory VAR109 = FUN65(VAR104);
return VAR95.VAR110.value(VAR6)(0, VAR103, VAR109, VAR49);
}
function FUN64(string VAR103, bytes[4] VAR109, uint VAR49) oraclizeAPI internal returns (bytes32 VAR105) {
bytes[] memory VAR111 = new bytes[](4);
VAR111[0] = VAR109[0];
VAR111[1] = VAR109[1];
VAR111[2] = VAR109[2];
VAR111[3] = VAR109[3];
return FUN64(VAR103, VAR111, VAR49);
}
function FUN66(byte VAR112) oraclizeAPI internal {
return VAR95.FUN32(VAR112);
}
function FUN67(uint VAR113) oraclizeAPI internal {
return VAR95.FUN33(VAR113);
}
function FUN68() oraclizeAPI internal returns (bytes32){
return VAR95.FUN34();
}
function FUN54(address VAR53) view internal returns(uint VAR114) {
VAR59 {
VAR114 := FUN69(VAR53)
}
}
using CBOR for VAR54.VAR55;
function FUN65(bytes[] VAR115) internal pure returns (bytes) {
FUN70();
VAR54.buffer memory VAR56;
VAR54.FUN36(VAR56, 1024);
VAR56.FUN51();
for (uint VAR116 = 0; VAR116 < VAR115.VAR65; VAR116++) {
VAR56.FUN49(VAR115[VAR116]);
}
VAR56.FUN53();
return VAR56.VAR56;
}
string VAR117;
function FUN59(string VAR118) internal {
VAR117 = VAR118;
}
function FUN71() internal view returns (string) {
return VAR117;
}
function FUN72(uint VAR119, uint VAR120, uint VAR121) internal returns (bytes32){
require((VAR120 > 0) && (VAR120 <= 32));
VAR119 *= 10;
bytes memory VAR122 = VAR101 bytes(1);
VAR122[0] = FUN73(VAR120);
bytes memory VAR123 = VAR101 bytes(32);
bytes memory VAR124 = VAR101 bytes(32);
bytes32 VAR125 = FUN68();
VAR59 {
FUN38(VAR123, 0x20)
FUN38(FUN6(VAR123, 0x20), FUN74(FUN75(FUN7(VAR126, 1)), FUN74(VAR127, VAR128)))
FUN38(VAR124, 0x20)
FUN38(FUN6(VAR124, 0x20), VAR125)
}
bytes memory VAR129 = VAR101 bytes(32);
VAR59 {
FUN38(FUN6(VAR129, 0x20), VAR119)
}
bytes memory VAR130 = VAR101 bytes(8);
FUN76(VAR129, 24, 8, VAR130, 0);
bytes[4] memory VAR109 = [VAR123, VAR122, VAR124, VAR129];
bytes32 VAR131 = FUN64("", VAR109, VAR121);
bytes memory VAR132 = VAR101 bytes(8);
VAR59 {
let VAR20 := FUN37(FUN6(VAR130, 0x20))
FUN43(FUN6(VAR132, 0x27), FUN77(VAR20, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN43(FUN6(VAR132, 0x26), FUN77(VAR20, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN43(FUN6(VAR132, 0x25), FUN77(VAR20, 0x10000000000000000000000000000000000000000000000000000000000))
FUN43(FUN6(VAR132, 0x24), FUN77(VAR20, 0x100000000000000000000000000000000000000000000000000000000))
FUN43(FUN6(VAR132, 0x23), FUN77(VAR20, 0x1000000000000000000000000000000000000000000000000000000))
FUN43(FUN6(VAR132, 0x22), FUN77(VAR20, 0x10000000000000000000000000000000000000000000000000000))
FUN43(FUN6(VAR132, 0x21), FUN77(VAR20, 0x100000000000000000000000000000000000000000000000000))
FUN43(FUN6(VAR132, 0x20), FUN77(VAR20, 0x1000000000000000000000000000000000000000000000000))
}
FUN78(VAR131, FUN79(VAR133.FUN80(VAR132, VAR109[1], FUN81(VAR109[0]), VAR109[2])));
return VAR131;
}
function FUN78(bytes32 VAR131, bytes32 VAR134) internal {
VAR135[VAR131] = VAR134;
}
mapping(bytes32=>bytes32) VAR135;
mapping(bytes32=>bool) VAR136;
function FUN82(bytes32 VAR137, bytes VAR138, bytes VAR139) internal returns (bool){
bool VAR140;
address VAR141;
bytes32 VAR142;
bytes32 VAR143;
bytes memory VAR144 = VAR101 bytes(32);
uint VAR145 = 4+(uint(VAR138[3]) - 0x20);
VAR144 = FUN76(VAR138, VAR145, 32, VAR144, 0);
bytes memory VAR146 = VAR101 bytes(32);
VAR145 += 32 + 2;
VAR146 = FUN76(VAR138, VAR145+(uint(VAR138[VAR145-1]) - 0x20), 32, VAR146, 0);
VAR59 {
VAR142 := FUN37(FUN6(VAR144, 32))
VAR143 := FUN37(FUN6(VAR146, 32))
}
(VAR140, VAR141) = FUN83(VAR137, 27, VAR142, VAR143);
if (address(FUN79(VAR139)) == VAR141) return true;
else {
(VAR140, VAR141) = FUN83(VAR137, 28, VAR142, VAR143);
return (address(FUN79(VAR139)) == VAR141);
}
}
function FUN84(bytes VAR102, uint VAR147) internal returns (bool) {
bool VAR140;
bytes memory VAR148 = VAR101 bytes(uint(VAR102[VAR147+1])+2);
FUN76(VAR102, VAR147, VAR148.VAR65, VAR148, 0);
bytes memory VAR149 = VAR101 bytes(64);
FUN76(VAR102, 3+1, 64, VAR149, 0);
bytes memory VAR150 = VAR101 bytes(1+65+32);
VAR150[0] = FUN73(1);
FUN76(VAR102, VAR147-65, 65, VAR150, 1);
bytes memory VAR151 = VAR152"";
FUN76(VAR151, 0, 32, VAR150, 1+65);
VAR140 = FUN82(FUN81(VAR150), VAR148, VAR149);
if (VAR140 == false) return false;
bytes memory VAR153 = VAR152"";
bytes memory VAR154 = VAR101 bytes(1+65);
VAR154[0] = 0xFE;
FUN76(VAR102, 3, 65, VAR154, 1);
bytes memory VAR155 = VAR101 bytes(uint(VAR102[3+65+1])+2);
FUN76(VAR102, 3+65, VAR155.VAR65, VAR155, 0);
VAR140 = FUN82(FUN81(VAR154), VAR155, VAR153);
return VAR140;
}
modifier FUN85(bytes32 VAR156, string VAR157, bytes VAR158) {
require((VAR158[0] == "") && (VAR158[1] == "") && (VAR158[2] == 1));
bool VAR159 = FUN86(VAR158, VAR156, bytes(VAR157), FUN71());
require(VAR159);
VAR37;
}
function FUN87(bytes32 VAR156, string VAR157, bytes VAR158) internal returns (uint8){
if ((VAR158[0] != "")||(VAR158[1] != "")||(VAR158[2] != 1)) return 1;
bool VAR159 = FUN86(VAR158, VAR156, bytes(VAR157), FUN71());
if (VAR159 == false) return 2;
return 0;
}
function FUN88(bytes32 VAR160, bytes VAR161, uint VAR162) internal pure returns (bool){
bool VAR163 = true;
require(VAR161.VAR65 == VAR162);
for (uint256 VAR116=0; VAR116< VAR162; VAR116++) {
if (VAR160[VAR116] != VAR161[VAR116]) VAR163 = false;
}
return VAR163;
}
function FUN86(bytes VAR102, bytes32 VAR131, bytes VAR100, string VAR164) internal returns (bool){
uint VAR165 = 3+65+(uint(VAR102[3+65+1])+2)+32;
bytes memory VAR166 = VAR101 bytes(32);
FUN76(VAR102, VAR165, 32, VAR166, 0);
if (!(FUN79(VAR166) == FUN79(VAR133.FUN80(FUN81(VAR133.FUN80(VAR164, VAR131)))))) return false;
bytes memory VAR167 = VAR101 bytes(uint(VAR102[VAR165+(32+8+1+32)+1])+2);
FUN76(VAR102, VAR165+(32+8+1+32), VAR167.VAR65, VAR167, 0);
if (!FUN88(FUN81(VAR167), VAR100, uint(VAR102[VAR165+32+8]))) return false;
bytes memory VAR168 = VAR101 bytes(8+1+32);
FUN76(VAR102, VAR165+32, 8+1+32, VAR168, 0);
bytes memory VAR169 = VAR101 bytes(64);
uint VAR147 = VAR165+32+(8+1+32)+VAR167.VAR65+65;
FUN76(VAR102, VAR147-64, 64, VAR169, 0);
bytes32 VAR170 = FUN81(VAR169);
if (VAR135[VAR131] == FUN79(VAR133.FUN80(VAR168, VAR170))){
delete VAR135[VAR131];
} else return false;
bytes memory VAR171 = VAR101 bytes(32+8+1+32);
FUN76(VAR102, VAR165, 32+8+1+32, VAR171, 0);
if (!FUN82(FUN81(VAR171), VAR167, VAR169)) return false;
if (VAR136[VAR170] == false){
VAR136[VAR170] = FUN84(VAR102, VAR147);
}
return VAR136[VAR170];
}
function FUN76(bytes VAR172, uint VAR173, uint VAR65, bytes VAR174, uint VAR175) internal pure returns (bytes) {
uint VAR176 = VAR65 + VAR175;
require(VAR174.VAR65 >= VAR176);
uint VAR116 = 32 + VAR173;
uint VAR177 = 32 + VAR175;
while (VAR116 < (32 + VAR173 + VAR65)) {
VAR59 {
let VAR178 := FUN37(FUN6(VAR172, VAR116))
FUN38(FUN6(VAR174, VAR177), VAR178)
}
VAR116 += 32;
VAR177 += 32;
}
return VAR174;
}
function FUN83(bytes32 VAR179, uint8 VAR180, bytes32 VAR181, bytes32 VAR182) internal returns (bool, address) {
bool VAR183;
address VAR184;
VAR59 {
let VAR185 := FUN37(0x40)
FUN38(VAR185, VAR179)
FUN38(FUN6(VAR185, 32), VAR180)
FUN38(FUN6(VAR185, 64), VAR181)
FUN38(FUN6(VAR185, 96), VAR182)
VAR183 := call(3000, 1, 0, VAR185, 128, VAR185, 32)
VAR184 := FUN37(VAR185)
}
return (VAR183, VAR184);
}
function FUN89(bytes32 VAR179, bytes VAR29) internal returns (bool, address) {
bytes32 VAR181;
bytes32 VAR182;
uint8 VAR180;
if (VAR29.VAR65 != 65)
return (false, 0);
VAR59 {
VAR181 := FUN37(FUN6(VAR29, 32))
VAR182 := FUN37(FUN6(VAR29, 64))
VAR180 := FUN73(0, FUN37(FUN6(VAR29, 96)))
}
//
if (VAR180 < 27)
VAR180 += 27;
if (VAR180 != 27 && VAR180 != 28)
return (false, 0);
return FUN83(VAR179, VAR180, VAR181, VAR182);
}
function FUN70() internal pure {
VAR59 {
let VAR186 := FUN37(0x40)
FUN90(VAR186, VAR187, FUN7(VAR188, VAR186))
}
}
}
contract UsingOraclizeRandom is VAR189 {
uint public VAR190 = 200000;
uint public VAR191 = 20000000000;
uint public VAR192;
uint internal VAR193;
bool internal VAR194;
mapping(bytes32=>bool) internal VAR195;
constructor() public {
VAR33 = FUN24(0xdbf98a75f521Cb1BD421c03F2b6A6a617f4240F1);
}
function FUN62(bytes32 VAR156, string VAR157, bytes VAR158) public {
VAR194 = false;
require(VAR195[VAR156], "");
require(msg.sender == FUN60(), "");
if (FUN87(VAR156, VAR157, VAR158) != 0) {
FUN91(VAR156);
} else {
uint VAR196 = uint(FUN79(VAR133.FUN92(VAR157)));
FUN93(VAR196, VAR156);
}
delete VAR195[VAR156];
}
function FUN94(uint VAR129) internal returns(bytes32 VAR197) {
VAR197 = FUN72(VAR129, 32, VAR190);
VAR195[VAR197] = true;
}
function FUN93(uint VAR198, bytes32 VAR156) internal;
function FUN91(bytes32 VAR156) internal;
function FUN95(uint VAR199) public VAR35 {
VAR190 = VAR199;
}
function FUN96(uint VAR200) public VAR35 {
VAR191 = VAR200;
FUN67(VAR200);
}
function FUN64(string VAR103, bytes[] VAR104, uint VAR49) oraclizeAPI internal returns (bytes32 VAR105){
VAR194 = true;
VAR193 = VAR201;
uint VAR6 = VAR95.FUN31(VAR103, VAR49);
VAR192 += VAR6;
if (VAR6 > 1 VAR106 + VAR107.VAR108*VAR49) return 0;
bytes memory VAR109 = FUN65(VAR104);
return VAR95.VAR110.value(VAR6)(0, VAR103, VAR109, VAR49);
}
}
contract Mobius2Dv2 is VAR202, VAR19 {
string public VAR203;
string public VAR204 = "";
MobiusToken public constant VAR205 = FUN97(0x54cdC9D889c28f55F59f6b136822868c7d4726fC);
bool public VAR206;
bool public VAR207;
address public VAR208;
LastVersion public constant VAR209 = FUN98(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e);
uint public VAR210;
uint public VAR211;
uint public VAR212;
uint public VAR213;
uint public VAR214;
uint public VAR215;
uint public constant VAR216 = 20;
uint public constant VAR217 = 60 * 10**16;
uint public constant VAR218 = 3 * 10**16;
uint public constant VAR219 = VAR23 / 20;
uint public constant VAR220 = 15 * 10**16;
uint public constant VAR221 = 6 * 10**16;
uint public constant VAR222 = 9 * 10**16;
uint public VAR223 = 1 VAR224;
uint public VAR225 = 1 VAR226;
uint public VAR227 = 101 * 10**16;
uint public VAR228 = 100 VAR224;
uint public VAR229 = 5 VAR106;
uint public constant VAR230 = 1 VAR231;
uint public constant VAR232 = 1 VAR231;
uint public constant VAR233 = 5 VAR234;
uint public VAR235;
uint public VAR236;
uint public VAR237;
uint public VAR238;
uint public constant VAR239 = VAR24;
mapping (address => uint) public VAR240;
struct VAR241 {
uint VAR242;
uint VAR9;
}
struct VAR243 {
uint VAR10;
uint VAR7;
uint VAR244;
uint VAR16;
uint VAR245;
uint VAR246;
uint VAR6;
uint VAR247;
uint VAR248;
uint VAR249;
uint VAR250;
uint VAR251;
address VAR252;
bool VAR14;
mapping (address => VAR241) VAR253;
}
struct VAR254 {
address[] VAR255;
address VAR256;
bool VAR14;
}
struct VAR257 {
uint VAR15;
uint VAR258;
}
mapping (address => VAR257) VAR259;
uint public VAR260;
uint public VAR261;
VAR243[] VAR262;
VAR254[] VAR263;
event FUN99(address indexed VAR174, uint VAR9);
event FUN100(address indexed VAR264, uint VAR265);
event FUN101(address VAR264, uint VAR265);
event FUN102(address indexed VAR264, uint VAR265);
event FUN103(uint VAR266, uint VAR267, uint VAR248, uint VAR249);
event FUN104(string VAR268, string VAR269);
constructor() public {
}
function FUN105() public VAR35 {
VAR190 = 250000;
if(FUN55()){
FUN66(VAR85);
}
}
function FUN106(address VAR270, uint VAR4) public view
returns (uint VAR15, uint VAR258)
{
MobiusRound storage VAR271 = VAR262[VAR4];
uint VAR272;
if(VAR262.VAR65 > 1) {
if(FUN107(VAR270, VAR4 - 1)) {
MobiusRound storage VAR273 = VAR262[VAR4 - 1];
VAR272 = FUN108(VAR270, VAR273);
}
}
VAR272 += FUN108(VAR270, VAR271);
VAR15 = VAR259[VAR270].VAR15 + VAR272;
VAR258 = VAR259[VAR270].VAR258;
}
function FUN107(address VAR270, uint VAR4) public view returns (bool) {
MobiusRound storage VAR271 = VAR262[VAR4];
return VAR271.VAR245 > VAR271.VAR253[VAR270].VAR242;
}
function FUN109(address VAR270, uint VAR4) external view
returns(uint VAR9, uint VAR15, uint VAR274, bool VAR275)
{
MobiusRound storage VAR271 = VAR262[VAR4];
VAR9 = VAR271.VAR253[VAR270].VAR9;
(VAR15, VAR274) = FUN106(VAR270, VAR4);
VAR275 = VAR240[VAR270] > VAR271.VAR251;
}
function FUN3(uint VAR4) external view
returns(
address VAR5,
uint VAR6,
uint VAR247,
uint VAR248,
uint VAR249,
uint VAR7,
uint VAR244,
uint VAR251,
uint VAR9,
uint VAR10,
uint VAR11,
uint VAR13,
bool VAR14
)
{
MobiusRound storage VAR271 = VAR262[VAR4];
VAR5 = VAR271.VAR252;
VAR6 = VAR271.VAR6;
VAR247 = VAR228;
VAR248 = VAR271.VAR248;
VAR249 = VAR271.VAR249;
VAR7 = VAR271.VAR7;
VAR244 = FUN9(VAR229, VAR271.VAR244/2);
VAR251 = VAR271.VAR251;
VAR9 = VAR271.VAR16;
VAR10 = VAR271.VAR10;
VAR11 = FUN13(VAR271.VAR10, VAR217);
VAR13 = VAR271.VAR246;
VAR14 = VAR271.VAR14;
}
function FUN4() external view
returns(
uint VAR15,
uint VAR16,
uint VAR17,
uint VAR18,
uint VAR10,
uint VAR276
) {
MobiusRound storage VAR271 = VAR262[VAR260];
if(VAR271.VAR246 > VAR201) {
VAR16 = VAR212 + VAR271.VAR16;
VAR15 = VAR213 + FUN13(VAR271.VAR10, VAR217);
VAR17 = VAR214 + FUN13(VAR271.VAR10, VAR222);
VAR10 = VAR211 + VAR271.VAR10;
} else {
VAR16 = VAR212;
VAR15 = VAR213;
VAR17 = VAR214;
VAR10 = VAR211;
}
VAR18 = VAR215;
VAR276 = VAR210 + VAR262.VAR65;
}
function () public payable {
if(!VAR207){
VAR236 += msg.value;
} else {
FUN110(address(0x0));
}
}
function FUN110(address VAR277) public payable {
if(VAR262.VAR65 > 0) {
MobiusRound storage VAR271 = VAR262[VAR260];
FUN111(VAR271, msg.value, VAR277);
} else {
revert("");
}
}
function FUN112(uint value) public {
FUN112(value, address(0x0));
}
function FUN112(uint value, address VAR277) public {
MobiusRound storage VAR271 = VAR262[VAR260];
FUN113(msg.sender, VAR271);
require(VAR259[msg.sender].VAR15 >= value, "");
VAR259[msg.sender].VAR15 = FUN7(VAR259[msg.sender].VAR15, value);
VAR259[msg.sender].VAR258 = FUN9(VAR259[msg.sender].VAR258, VAR259[msg.sender].VAR15);
VAR238 = FUN7(VAR238, value);
FUN111(VAR271, value, VAR277);
}
function FUN2() public {
MobiusRound storage VAR271 = VAR262[VAR260];
if(VAR262.VAR65 > 1) {
if(FUN107(msg.sender, VAR260 - 1)) {
MobiusRound storage VAR273 = VAR262[VAR260 - 1];
FUN113(msg.sender, VAR273);
}
}
FUN113(msg.sender, VAR271);
uint VAR265 = VAR259[msg.sender].VAR15;
require(VAR265 > 0, "");
VAR238 = FUN7(VAR238, VAR265);
VAR259[msg.sender].VAR15 = 0;
VAR259[msg.sender].VAR258 = 0;
VAR271.VAR253[msg.sender].VAR242 = VAR271.VAR245;
msg.sender.transfer(VAR265);
emit FUN100(msg.sender, VAR265);
}
function FUN114(uint VAR4) public {
MobiusRound storage VAR271 = VAR262[VAR4];
FUN113(msg.sender, VAR271);
}
function FUN115() public payable {
FUN116();
FUN117();
}
function FUN117() public payable {
require(!VAR206 && VAR207, "");
require(VAR201 >= VAR235, "");
if(VAR262.VAR65 > 0) {
require(VAR262[VAR260].VAR14, "");
require(VAR262[VAR260].VAR246 < VAR201, "");
}
uint VAR278 = VAR262.VAR65++;
MobiusRound storage VAR271 = VAR262[VAR278];
VAR260 = VAR278;
VAR271.VAR252 = msg.sender;
VAR271.VAR6 = VAR223;
VAR271.VAR247 = VAR228;
VAR271.VAR248 = VAR227;
VAR271.VAR249 = VAR225;
VAR271.VAR250 = VAR201;
VAR271.VAR251 = VAR201;
VAR271.VAR246 = VAR201 + VAR230;
VAR271.VAR7 = VAR236;
VAR236 = 0;
FUN118();
FUN111(VAR271, msg.value, address(0x0));
emit FUN103(VAR278, VAR223, VAR227, VAR225);
}
function FUN116() public {
MobiusRound storage VAR271 = VAR262[VAR260];
FUN119(VAR271);
}
function FUN120(uint VAR267, uint VAR248, uint VAR249) public VAR35 {
VAR223 = VAR267;
VAR227 = VAR248;
VAR225 = VAR249;
}
function FUN121(uint VAR279) public VAR35 {
VAR228 = VAR279;
}
function FUN122(uint VAR280) public VAR35 {
VAR229 = VAR280;
}
function FUN123(uint VAR128) public VAR35 {
require(VAR201 > VAR235);
require(VAR128 <= VAR201 + 2 VAR231);
VAR235 = VAR128;
}
function FUN124(uint VAR281) public VAR35 {
require(VAR201 > VAR235);
require(VAR201 + VAR281 <= VAR201 + 2 VAR231);
VAR235 = VAR201 + VAR281;
}
function FUN125() public VAR35 {
uint value = FUN7(VAR237, VAR192);
VAR237 = 0;
VAR192 = 0;
msg.sender.transfer(value);
}
function FUN126(string VAR268, string VAR269) public VAR35 {
VAR204 = VAR268;
VAR203 = VAR269;
emit FUN104(VAR268, VAR269);
}
function FUN127(address VAR282) public VAR35 {
require(VAR282 != address(0x0), "");
require(!VAR206, "");
VAR206 = true;
VAR208 = VAR282;
}
function FUN128() public {
require(VAR206, "");
require(msg.sender == VAR208, "");
MobiusRound storage VAR271 = VAR262[VAR260];
require(VAR271.VAR14, "");
require(VAR208.call.value(VAR236)(), "");
}
function FUN36() public VAR35 {
require(!VAR207, "");
uint VAR278 = VAR209.FUN5();
VAR210 = 1 + VAR278;
uint VAR283;
uint VAR284;
uint VAR285;
uint VAR286;
uint VAR287;
bool VAR14;
( , , , , , VAR284, , , , VAR14) = VAR209.FUN3(VAR278);
require(VAR14, "");
(VAR285, VAR283, VAR286, VAR287) = VAR209.FUN4();
VAR212 = VAR283;
VAR211 = VAR284;
VAR213 = VAR285;
VAR214 = VAR286;
VAR215 = VAR287;
VAR207 = true;
}
function FUN118() internal {
if(VAR263.VAR65 > 0) {
require(VAR263[VAR261].VAR14, "");
}
uint VAR278 = VAR263.VAR65++;
VAR261 = VAR278;
}
function FUN111(MobiusRound storage VAR271, uint value, address VAR277) internal {
require(VAR271.VAR246 >= VAR201, "");
require(value >= 100 VAR288, "");
VAR271.VAR10 = FUN6(VAR271.VAR10, value);
if(value >= VAR271.VAR6) {
VAR271.VAR252 = msg.sender;
}
FUN129(VAR271, value);
FUN130(VAR271, value, VAR277);
FUN113(msg.sender, VAR271);
uint VAR289 = FUN131(VAR271, msg.sender, value);
uint VAR290 = VAR289/VAR23;
uint VAR291 = FUN6(VAR271.VAR246, FUN8(VAR290, VAR233));
VAR271.VAR246 = FUN9(VAR291, VAR201 + VAR230);
if(VAR201 > VAR271.VAR250 + VAR271.VAR249) {
VAR271.VAR6 = FUN13(VAR271.VAR6, VAR271.VAR248);
VAR271.VAR250 = VAR201;
}
}
function FUN119(MobiusRound storage VAR271) internal {
require(!VAR271.VAR14, "");
require(VAR271.VAR246 < VAR201, "");
VAR259[VAR271.VAR252].VAR15 = FUN6(VAR259[VAR271.VAR252].VAR15, VAR271.VAR7);
VAR238 = FUN6(VAR238, VAR271.VAR7);
emit FUN101(VAR271.VAR252, VAR271.VAR7);
VAR215 += VAR271.VAR7;
VAR236 = FUN6(VAR236, FUN13(VAR271.VAR10, VAR219));
VAR236 = FUN6(VAR236, VAR271.VAR244);
uint VAR292 = FUN13(VAR271.VAR10, VAR222);
VAR205.VAR293.value(VAR292)();
VAR214 += VAR292;
VAR212 += VAR271.VAR16;
VAR213 += FUN13(VAR271.VAR10, VAR217);
VAR211 += VAR271.VAR10;
VAR263[VAR261].VAR14 = true;
VAR271.VAR14 = true;
}
function FUN113(address VAR294, MobiusRound storage VAR271) internal {
if(VAR271.VAR253[VAR294].VAR9 == 0) {
return;
}
uint VAR272 = FUN108(VAR294, VAR271);
if (VAR272 > 0) {
VAR259[VAR294].VAR15 = FUN6(VAR259[VAR294].VAR15, VAR272);
}
VAR271.VAR253[VAR294].VAR242 = VAR271.VAR245;
}
function FUN108(address VAR294, MobiusRound storage VAR271) internal view returns(uint) {
if(VAR271.VAR253[VAR294].VAR9 == 0) {
return 0;
}
uint VAR295 = FUN7(
VAR271.VAR245,
VAR271.VAR253[VAR294].VAR242
);
uint VAR272 = 0;
if(VAR295 != 0) {
VAR272 = FUN8(VAR295, VAR271.VAR253[VAR294].VAR9) / VAR239;
}
return VAR272;
}
function FUN130(MobiusRound storage VAR271, uint value, address VAR277) internal {
uint VAR296;
if(VAR277 != address(0x0) && VAR277 != msg.sender) {
VAR296 = FUN13(value, VAR217 - VAR218);
uint VAR297 = FUN13(value, VAR218);
VAR259[VAR277].VAR15 = FUN6(VAR259[VAR277].VAR15, VAR297);
VAR259[VAR277].VAR258 = FUN6(VAR259[VAR277].VAR258, VAR297);
VAR238 = FUN6(VAR238, VAR297);
} else {
VAR296 = FUN13(value, VAR217);
}
uint VAR244 = FUN13(value, VAR221);
uint VAR7 = FUN13(value, VAR220);
uint VAR298;
VAR298 = value / VAR216;
if(VAR271.VAR16 == 0) {
VAR271.VAR7 = FUN6(VAR271.VAR7, VAR296);
} else {
FUN132(VAR271, VAR296);
}
VAR271.VAR244 = FUN6(VAR271.VAR244, VAR244);
VAR271.VAR7 = FUN6(VAR271.VAR7, VAR7);
VAR237 = FUN6(VAR237, VAR298);
}
function FUN132(MobiusRound storage VAR271, uint value) internal {
VAR238 = FUN6(VAR238, value);
if(VAR271.VAR16 == 0) {
VAR271.VAR245 = FUN8(value, VAR239) / FUN15(value, VAR271.VAR6);
} else {
VAR271.VAR245 = FUN6(
VAR271.VAR245,
FUN8(value, VAR239) / VAR271.VAR16
);
}
}
function FUN131(MobiusRound storage VAR271, address VAR294, uint value) internal returns(uint) {
if(VAR271.VAR253[VAR294].VAR242 == 0) {
VAR271.VAR253[VAR294].VAR242 = VAR271.VAR245;
}
uint VAR289 = FUN15(value, VAR271.VAR6);
if(value >= 100 VAR106) {
VAR289 = FUN8(VAR289, 2);
} else if(value >= 10 VAR106) {
VAR289 = FUN6(VAR289, VAR289/2);
} else if(value >= 1 VAR106) {
VAR289 = FUN6(VAR289, VAR289/3);
} else if(value >= 100 VAR224) {
VAR289 = FUN6(VAR289, VAR289/10);
}
VAR271.VAR253[VAR294].VAR9 = FUN6(VAR271.VAR253[VAR294].VAR9, VAR289);
VAR271.VAR16 = FUN6(VAR271.VAR16, VAR289);
emit FUN99(VAR294, VAR289);
return VAR289;
}
function FUN129(MobiusRound storage VAR271, uint value) internal {
if(value >= VAR271.VAR247) {
VAR263[VAR261].VAR255.FUN133(msg.sender);
VAR240[msg.sender] = VAR201;
}
if(VAR201 > VAR271.VAR251 + VAR232) {
if(VAR271.VAR244 < VAR271.VAR247 * 4) {
return;
}
if(!VAR194) {
FUN94(0);
} else {
if(VAR201 > VAR193 + 10 VAR234){
VAR191 = FUN9(150000000000, VAR191 * 2);
FUN67(VAR191);
}
}
}
}
function FUN93(uint VAR198, bytes32 VAR156) internal {
MobiusRound storage VAR271 = VAR262[VAR260];
if(VAR271.VAR246 >= VAR201 && VAR201 > VAR271.VAR251 + VAR232) {
FUN134(VAR263[VAR261], VAR271, VAR198);
}
}
event FUN135(bytes32 VAR197);
function FUN91(bytes32 VAR156) internal {
emit FUN135(VAR156);
}
function FUN136() public VAR35 {
FUN94(0);
}
function FUN134(DailyJackpotRound storage VAR299, MobiusRound storage VAR271, uint VAR198) internal {
if(VAR299.VAR255.VAR65 != 0){
uint VAR256 = VAR198 % VAR299.VAR255.VAR65;
uint VAR300 = FUN9(VAR229, VAR271.VAR244 / 2);
VAR271.VAR244 = FUN7(VAR271.VAR244, VAR300);
VAR259[VAR299.VAR255[VAR256]].VAR15 = FUN6(VAR259[VAR299.VAR255[VAR256]].VAR15, VAR300);
emit FUN102(VAR299.VAR255[VAR256], VAR300);
VAR299.VAR14 = true;
VAR238 = FUN6(VAR238, VAR300);
VAR215 += VAR300;
FUN118();
}
VAR271.VAR251 = VAR201;
}
}
1
---------------------------------
181 0xb533ff572f5e33d04d02b149e7dcfe980e424c63.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) external payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) external payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) public payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) external payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) public payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) external payable returns (bytes32 VAR7);
function FUN7(string VAR5) public returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) public returns (uint VAR12);
function FUN8(byte VAR14) external;
function FUN9(uint VAR15) external;
function FUN10() external constant returns(bytes32);
}
contract VAR16 {
function FUN11() public returns (address VAR17);
}
contract VAR18 {
uint constant VAR19 = 60*60*24;
uint constant VAR20 = 60*60*24*7;
uint constant VAR21 = 60*60*24*30;
byte constant VAR22 = 0x00;
byte constant VAR23 = 0x10;
byte constant VAR24 = 0x20;
byte constant VAR25 = 0x30;
byte constant VAR26 = 0xF0;
byte constant VAR27 = 0x01;
uint8 constant VAR28 = 0;
uint8 constant VAR29 = 1;
uint8 constant VAR30 = 2;
uint8 constant VAR31 = 2;
uint8 constant VAR32 = 161;
OraclizeAddrResolverI VAR33;
OraclizeI VAR34;
modifier VAR35 {
if((address(VAR33)==0)||(FUN12(address(VAR33))==0))
FUN13(VAR28);
if(address(VAR34) != VAR33.FUN11())
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
modifier FUN15(string VAR37){
VAR34 = FUN14(VAR33.FUN11());
VAR36;
}
function FUN13(uint8 VAR38) internal returns(bool){
return FUN13();
VAR38;
}
function FUN13() internal returns(bool){
if (FUN12(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR33 = FUN16(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN17("");
return true;
}
if (FUN12(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR33 = FUN16(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN17("");
return true;
}
if (FUN12(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR33 = FUN16(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN17("");
return true;
}
if (FUN12(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR33 = FUN16(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN17("");
return true;
}
if (FUN12(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR33 = FUN16(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN12(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR33 = FUN16(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN12(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR33 = FUN16(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN18(bytes32 VAR39, string VAR40) public {
FUN18(VAR39, VAR40, VAR41 bytes(0));
}
function FUN18(bytes32 VAR39, string VAR40, bytes VAR42) public {
return;
VAR39; VAR40; VAR42;
}
function FUN19(string VAR43) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43);
}
function FUN19(string VAR43, uint VAR13) oraclizeAPI internal returns (uint){
return VAR34.FUN7(VAR43, VAR13);
}
function FUN20(string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(0, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR50.value(VAR46)(VAR51, VAR43, VAR44);
}
function FUN20(uint VAR51, string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(VAR51, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR44, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR52.value(VAR46)(0, VAR43, VAR44, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(0, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
return VAR34.VAR55.value(VAR46)(VAR51, VAR43, VAR53, VAR54);
}
function FUN20(uint VAR51, string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(VAR51, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string VAR53, string VAR54, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
return VAR34.VAR56.value(VAR46)(0, VAR43, VAR53, VAR54, VAR13);
}
function FUN20(string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN21(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, string[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
string[] memory VAR61 = new string[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(0, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43);
if (VAR46 > 1 VAR47 + VAR48.VAR49*200000) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR59.value(VAR46)(VAR51, VAR43, VAR58);
}
function FUN20(uint VAR51, string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(VAR51, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[] VAR57, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45){
uint VAR46 = VAR34.FUN7(VAR43, VAR13);
if (VAR46 > 1 VAR47 + VAR48.VAR49*VAR13) return 0;
bytes memory VAR58 = FUN22(VAR57);
return VAR34.VAR60.value(VAR46)(0, VAR43, VAR58, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[1] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](1);
VAR61[0] = VAR58[0];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[2] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](2);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[3] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](3);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[4] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](4);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61);
}
function FUN20(uint VAR51, string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR51, VAR43, VAR61, VAR13);
}
function FUN20(string VAR43, bytes[5] VAR58, uint VAR13) oraclizeAPI internal returns (bytes32 VAR45) {
bytes[] memory VAR61 = new bytes[](5);
VAR61[0] = VAR58[0];
VAR61[1] = VAR58[1];
VAR61[2] = VAR58[2];
VAR61[3] = VAR58[3];
VAR61[4] = VAR58[4];
return FUN20(VAR43, VAR61, VAR13);
}
function FUN23() oraclizeAPI internal returns (address){
return VAR34.FUN24();
}
function FUN25(byte VAR62) oraclizeAPI internal {
return VAR34.FUN8(VAR62);
}
function FUN26(uint VAR63) oraclizeAPI internal {
return VAR34.FUN9(VAR63);
}
function FUN27() oraclizeAPI internal returns (bytes32){
return VAR34.FUN10();
}
function FUN12(address VAR17) constant internal returns(uint VAR64) {
VAR65 {
VAR64 := FUN28(VAR17)
}
}
function FUN29(string VAR66) internal pure returns (address){
bytes memory VAR67 = bytes(VAR66);
uint160 VAR68 = 0;
uint160 VAR69;
uint160 VAR70;
for (uint VAR71=2; VAR71<2+2*20; VAR71+=2){
VAR68 *= 256;
VAR69 = FUN30(VAR67[VAR71]);
VAR70 = FUN30(VAR67[VAR71+1]);
if ((VAR69 >= 97)&&(VAR69 <= 102)) VAR69 -= 87;
else if ((VAR69 >= 65)&&(VAR69 <= 70)) VAR69 -= 55;
else if ((VAR69 >= 48)&&(VAR69 <= 57)) VAR69 -= 48;
if ((VAR70 >= 97)&&(VAR70 <= 102)) VAR70 -= 87;
else if ((VAR70 >= 65)&&(VAR70 <= 70)) VAR70 -= 55;
else if ((VAR70 >= 48)&&(VAR70 <= 57)) VAR70 -= 48;
VAR68 += (VAR69*16+VAR70);
}
return address(VAR68);
}
function FUN31(string VAR66, string VAR72) internal pure returns (int) {
bytes memory VAR73 = bytes(VAR66);
bytes memory VAR74 = bytes(VAR72);
uint VAR75 = VAR73.VAR76;
if (VAR74.VAR76 < VAR75) VAR75 = VAR74.VAR76;
for (uint VAR71 = 0; VAR71 < VAR75; VAR71 ++)
if (VAR73[VAR71] < VAR74[VAR71])
return -1;
else if (VAR73[VAR71] > VAR74[VAR71])
return 1;
if (VAR73.VAR76 < VAR74.VAR76)
return -1;
else if (VAR73.VAR76 > VAR74.VAR76)
return 1;
else
return 0;
}
function FUN32(string VAR77, string VAR78) internal pure returns (int) {
bytes memory VAR79 = bytes(VAR77);
bytes memory VAR80 = bytes(VAR78);
if(VAR79.VAR76 < 1 || VAR80.VAR76 < 1 || (VAR80.VAR76 > VAR79.VAR76))
return -1;
else if(VAR79.VAR76 > (2**128 -1))
return -1;
else
{
uint VAR81 = 0;
for (uint VAR71 = 0; VAR71 < VAR79.VAR76; VAR71 ++)
{
if (VAR79[VAR71] == VAR80[0])
{
VAR81 = 1;
while(VAR81 < VAR80.VAR76 && (VAR71 + VAR81) < VAR79.VAR76 && VAR79[VAR71 + VAR81] == VAR80[VAR81])
{
VAR81++;
}
if(VAR81 == VAR80.VAR76)
return int(VAR71);
}
}
return -1;
}
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83, string VAR84) internal pure returns (string) {
bytes memory VAR85 = bytes(VAR66);
bytes memory VAR86 = bytes(VAR72);
bytes memory VAR87 = bytes(VAR82);
bytes memory VAR88 = bytes(VAR83);
bytes memory VAR89 = bytes(VAR84);
string memory VAR90 = VAR41 string(VAR85.VAR76 + VAR86.VAR76 + VAR87.VAR76 + VAR88.VAR76 + VAR89.VAR76);
bytes memory VAR91 = bytes(VAR90);
uint VAR92 = 0;
for (uint VAR71 = 0; VAR71 < VAR85.VAR76; VAR71++) VAR91[VAR92++] = VAR85[VAR71];
for (VAR71 = 0; VAR71 < VAR86.VAR76; VAR71++) VAR91[VAR92++] = VAR86[VAR71];
for (VAR71 = 0; VAR71 < VAR87.VAR76; VAR71++) VAR91[VAR92++] = VAR87[VAR71];
for (VAR71 = 0; VAR71 < VAR88.VAR76; VAR71++) VAR91[VAR92++] = VAR88[VAR71];
for (VAR71 = 0; VAR71 < VAR89.VAR76; VAR71++) VAR91[VAR92++] = VAR89[VAR71];
return string(VAR91);
}
function FUN33(string VAR66, string VAR72, string VAR82, string VAR83) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, VAR83, "");
}
function FUN33(string VAR66, string VAR72, string VAR82) internal pure returns (string) {
return FUN33(VAR66, VAR72, VAR82, "", "");
}
function FUN33(string VAR66, string VAR72) internal pure returns (string) {
return FUN33(VAR66, VAR72, "", "", "");
}
function FUN34(string VAR66) internal pure returns (uint) {
return FUN34(VAR66, 0);
}
function FUN34(string VAR66, uint VAR72) internal pure returns (uint) {
bytes memory VAR93 = bytes(VAR66);
uint VAR94 = 0;
bool VAR95 = false;
for (uint VAR71=0; VAR71<VAR93.VAR76; VAR71++){
if ((VAR93[VAR71] >= 48)&&(VAR93[VAR71] <= 57)){
if (VAR95){
if (VAR72 == 0) break;
else VAR72--;
}
VAR94 *= 10;
VAR94 += uint(VAR93[VAR71]) - 48;
} else if (VAR93[VAR71] == 46) VAR95 = true;
}
if (VAR72 > 0) VAR94 *= 10**VAR72;
return VAR94;
}
function FUN35(uint VAR71) internal pure returns (string){
if (VAR71 == 0) return "";
uint VAR96 = VAR71;
uint VAR97;
while (VAR96 != 0){
VAR97++;
VAR96 /= 10;
}
bytes memory VAR98 = VAR41 bytes(VAR97);
uint VAR92 = VAR97 - 1;
while (VAR71 != 0){
VAR98[VAR92--] = FUN36(48 + VAR71 % 10);
VAR71 /= 10;
}
return string(VAR98);
}
function FUN21(string[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
function FUN22(bytes[] VAR99) internal pure returns (bytes) {
uint VAR100 = VAR99.VAR76;
uint VAR101 = 0;
bytes[] memory VAR102 = new bytes[](VAR100);
for (uint VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR102[VAR71] = (bytes(VAR99[VAR71]));
VAR101 += VAR102[VAR71].VAR76 + (VAR102[VAR71].VAR76 - 1)/23 + 3;
}
uint VAR103 = 0;
uint VAR104 = VAR100 + 0x80;
VAR101 += FUN36(VAR104).VAR76;
bytes memory VAR105 = VAR41 bytes(VAR101);
while (FUN36(VAR104).VAR76 > VAR103) {
VAR105[VAR103] = FUN36(VAR104)[VAR103];
VAR103++;
}
for (VAR71 = 0; VAR71 < VAR100; VAR71++) {
VAR105[VAR103] = 0x5F;
VAR103++;
for (uint VAR106 = 0; VAR106 < VAR102[VAR71].VAR76; VAR106++) {
if (VAR106 % 23 == 0) {
uint VAR107 = VAR102[VAR71].VAR76 - VAR106 >= 24 ? 23 : VAR102[VAR71].VAR76 - VAR106;
VAR107 += 0x40;
uint VAR108 = VAR103;
while (FUN36(VAR107).VAR76 > VAR103 - VAR108) {
VAR105[VAR103] = FUN36(VAR107)[VAR103 - VAR108];
VAR103++;
}
}
VAR105[VAR103] = VAR102[VAR71][VAR106];
VAR103++;
}
VAR105[VAR103] = 0xFF;
VAR103++;
}
return VAR105;
}
string VAR109;
function FUN17(string VAR110) internal {
VAR109 = VAR110;
}
function FUN37() internal view returns (string) {
return VAR109;
}
function FUN38(uint VAR111, uint VAR112, uint VAR113) internal returns (bytes32){
require((VAR112 > 0) && (VAR112 <= 32));
VAR111 *= 10;
bytes memory VAR114 = VAR41 bytes(1);
VAR114[0] = FUN36(VAR112);
bytes memory VAR115 = VAR41 bytes(32);
bytes memory VAR116 = VAR41 bytes(32);
bytes32 VAR117 = FUN27();
VAR65 {
FUN39(VAR115, 0x20)
FUN39(FUN40(VAR115, 0x20), FUN41(FUN42(FUN43(VAR118, 1)), FUN41(VAR119, VAR51)))
FUN39(VAR116, 0x20)
FUN39(FUN40(VAR116, 0x20), VAR117)
}
bytes memory VAR120 = VAR41 bytes(32);
VAR65 {
FUN39(FUN40(VAR120, 0x20), VAR111)
}
bytes memory VAR121 = VAR41 bytes(8);
FUN44(VAR120, 24, 8, VAR121, 0);
bytes[4] memory VAR58 = [VAR115, VAR114, VAR116, VAR120];
bytes32 VAR122 = FUN20("", VAR58, VAR113);
bytes memory VAR123 = VAR41 bytes(8);
VAR65 {
let VAR106 := FUN45(FUN40(VAR121, 0x20))
FUN46(FUN40(VAR123, 0x27), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x26), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x25), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x24), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x23), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x22), FUN47(VAR106, 0x10000000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x21), FUN47(VAR106, 0x100000000000000000000000000000000000000000000000000))
FUN46(FUN40(VAR123, 0x20), FUN47(VAR106, 0x1000000000000000000000000000000000000000000000000))
}
FUN48(VAR122, FUN49(VAR123, VAR58[1], FUN50(VAR58[0]), VAR58[2]));
return VAR122;
}
function FUN48(bytes32 VAR122, bytes32 VAR124) internal {
VAR125[VAR122] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN51(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR41 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN44(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR41 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN44(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR65 {
VAR132 := FUN45(FUN40(VAR134, 32))
VAR133 := FUN45(FUN40(VAR136, 32))
}
(VAR130, VAR131) = FUN52(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN52(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN53(bytes VAR42, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR41 bytes(uint(VAR42[VAR137+1])+2);
FUN44(VAR42, VAR137, VAR138.VAR76, VAR138, 0);
bytes memory VAR139 = VAR41 bytes(64);
FUN44(VAR42, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR41 bytes(1+65+32);
VAR140[0] = FUN36(1);
FUN44(VAR42, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN44(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN51(FUN50(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR41 bytes(1+65);
VAR144[0] = 0xFE;
FUN44(VAR42, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR41 bytes(uint(VAR42[3+65+1])+2);
FUN44(VAR42, 3+65, VAR145.VAR76, VAR145, 0);
VAR130 = FUN51(FUN50(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN54(bytes32 VAR146, string VAR147, bytes VAR148) {
require((VAR148[0] == "") && (VAR148[1] == "") && (VAR148[2] == 1));
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
require(VAR149);
VAR36;
}
function FUN56(bytes32 VAR146, string VAR147, bytes VAR148) internal returns (uint8){
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) return 1;
bool VAR149 = FUN55(VAR148, VAR146, bytes(VAR147), FUN37());
if (VAR149 == false) return 2;
return 0;
}
function FUN57(bytes32 VAR150, bytes VAR151, uint VAR152) internal pure returns (bool){
bool VAR153 = true;
require(VAR151.VAR76 == VAR152);
for (uint256 VAR71=0; VAR71< VAR152; VAR71++) {
if (VAR150[VAR71] != VAR151[VAR71]) VAR153 = false;
}
return VAR153;
}
function FUN55(bytes VAR42, bytes32 VAR122, bytes VAR40, string VAR154) internal returns (bool){
uint VAR155 = 3+65+(uint(VAR42[3+65+1])+2)+32;
bytes memory VAR156 = VAR41 bytes(32);
FUN44(VAR42, VAR155, 32, VAR156, 0);
if (!(FUN49(VAR156) == FUN49(FUN50(VAR154, VAR122)))) return false;
bytes memory VAR157 = VAR41 bytes(uint(VAR42[VAR155+(32+8+1+32)+1])+2);
FUN44(VAR42, VAR155+(32+8+1+32), VAR157.VAR76, VAR157, 0);
if (!FUN57(FUN50(VAR157), VAR40, uint(VAR42[VAR155+32+8]))) return false;
bytes memory VAR158 = VAR41 bytes(8+1+32);
FUN44(VAR42, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR41 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR76+65;
FUN44(VAR42, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN50(VAR159);
if (VAR125[VAR122] == FUN49(VAR158, VAR160)){
delete VAR125[VAR122];
} else return false;
bytes memory VAR161 = VAR41 bytes(32+8+1+32);
FUN44(VAR42, VAR155, 32+8+1+32, VAR161, 0);
if (!FUN51(FUN50(VAR161), VAR157, VAR159)) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN53(VAR42, VAR137);
}
return VAR126[VAR160];
}
function FUN44(bytes VAR162, uint VAR163, uint VAR76, bytes VAR164, uint VAR165) internal pure returns (bytes) {
uint VAR75 = VAR76 + VAR165;
require(VAR164.VAR76 >= VAR75);
uint VAR71 = 32 + VAR163;
uint VAR96 = 32 + VAR165;
while (VAR71 < (32 + VAR163 + VAR76)) {
VAR65 {
let VAR67 := FUN45(FUN40(VAR162, VAR71))
FUN39(FUN40(VAR164, VAR96), VAR67)
}
VAR71 += 32;
VAR96 += 32;
}
return VAR164;
}
function FUN52(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR65 {
let VAR172 := FUN45(0x40)
FUN39(VAR172, VAR166)
FUN39(FUN40(VAR172, 32), VAR167)
FUN39(FUN40(VAR172, 64), VAR168)
FUN39(FUN40(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN45(VAR172)
}
return (VAR170, VAR171);
}
function FUN58(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR76 != 65)
return (false, 0);
VAR65 {
VAR168 := FUN45(FUN40(VAR173, 32))
VAR169 := FUN45(FUN40(VAR173, 64))
VAR167 := FUN36(0, FUN45(FUN40(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN52(VAR166, VAR167, VAR168, VAR169);
}
}
contract VAR174 {
uint256 public VAR175;
uint256 public VAR176;
function FUN59(address VAR177) public;
function FUN60() payable public;
function FUN61() public view returns(uint256);
}
contract VAR178 {
function FUN62(uint256 VAR179, address VAR180) public;
function FUN63() payable public;
function FUN64(uint256 VAR181) public;
function FUN65() public view returns(uint256);
}
contract VAR182 {
function FUN66() constant public returns (uint VAR183);
function FUN67(address VAR184) constant public returns (uint VAR185);
function transfer(address VAR186, uint VAR187) public returns (bool VAR188);
function FUN68(address VAR189, address VAR186, uint VAR187) public returns (bool VAR188);
function FUN69(address VAR190, uint VAR187) public returns (bool VAR188);
function FUN70(address VAR184, address VAR190) constant public returns (uint VAR191);
event Transfer(address indexed VAR189, address indexed VAR186, uint VAR187);
event FUN71(address indexed VAR184, address indexed VAR190, uint VAR187);
}
contract EOSBetBankroll is VAR182, VAR178 {
using SafeMath for *;
address public VAR192;
uint256 public VAR193;
uint256 public VAR194;
uint256 public VAR175;
mapping(address => bool) public VAR195;
address public VAR196;
address public VAR197;
mapping(address => uint256) VAR198;
string public constant VAR199 = "";
string public constant VAR200 = "";
uint8 public constant VAR95 = 18;
uint256 public VAR201;
mapping(address => uint256) public VAR202;
mapping(address => mapping(address => uint256)) public VAR203;
event FUN72(address VAR204, uint256 VAR205, uint256 VAR206);
event FUN73(address VAR204, uint256 VAR207, uint256 VAR208);
event FUN74(address VAR209, uint256 VAR210);
modifier FUN75(address VAR211){
require(VAR195[VAR211]);
VAR36;
}
function FUN76(address VAR212, address VAR213) public payable {
require (msg.value > 0);
VAR192 = msg.sender;
uint256 VAR214 = msg.value * 100;
VAR202[msg.sender] = VAR214;
VAR201 = VAR214;
emit Transfer(0x0, msg.sender, VAR214);
VAR195[VAR212] = true;
VAR195[VAR213] = true;
VAR196 = VAR212;
VAR197 = VAR213;
VAR194 = 6 VAR215;
VAR193 = 500 VAR47;
}
function FUN77(address VAR216) view public returns(uint256){
return VAR198[VAR216];
}
function FUN65() view public returns(uint256){
return VAR217.FUN43(address(this).VAR185, VAR175);
}
function FUN62(uint256 VAR179, address VAR180) public FUN75(msg.sender){
if (! VAR180.FUN78(VAR179)){
emit FUN74(VAR180, VAR179);
if (! VAR192.FUN78(VAR179)){
emit FUN74(VAR192, VAR179);
}
}
}
function FUN63() payable public FUN75(msg.sender){
}
function FUN64(uint256 VAR181) public FUN75(msg.sender){
FUN79(msg.sender).VAR218.value(VAR181)();
}
function () public payable {
uint256 VAR219 = VAR217.FUN43(FUN65(), msg.value);
uint256 VAR220 = VAR193;
require(VAR219 < VAR220 && msg.value != 0);
uint256 VAR221 = VAR201;
uint256 VAR222;
bool VAR223;
uint256 VAR224;
uint256 VAR225;
if (VAR217.FUN40(VAR219, msg.value) > VAR220){
VAR223 = true;
VAR222 = VAR217.FUN43(VAR220, VAR219);
VAR224 = VAR217.FUN43(msg.value, VAR222);
}
else {
VAR222 = msg.value;
}
if (VAR221 != 0){
VAR225 = VAR217.FUN80(VAR222, VAR221) / VAR219;
}
else {
VAR225 = VAR217.FUN80(VAR222, 100);
}
VAR201 = VAR217.FUN40(VAR221, VAR225);
VAR202[msg.sender] = VAR217.FUN40(VAR202[msg.sender], VAR225);
VAR198[msg.sender] = VAR226.VAR51;
if (VAR223){
msg.sender.transfer(VAR224);
}
emit FUN72(msg.sender, VAR222, VAR225);
emit Transfer(0x0, msg.sender, VAR225);
}
function FUN81(uint256 VAR227) public {
uint256 VAR228 = VAR202[msg.sender];
require(VAR227 <= VAR228
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR227 > 0);
uint256 VAR219 = FUN65();
uint256 VAR221 = VAR201;
uint256 VAR229 = VAR217.FUN80(VAR227, VAR219) / VAR221;
uint256 VAR230 = VAR229 / 100;
uint256 VAR231 = VAR217.FUN43(VAR229, VAR230);
VAR201 = VAR217.FUN43(VAR221, VAR227);
VAR202[msg.sender] = VAR217.FUN43(VAR228, VAR227);
VAR175 = VAR217.FUN40(VAR175, VAR230);
msg.sender.transfer(VAR231);
emit FUN73(msg.sender, VAR231, VAR227);
emit Transfer(msg.sender, 0x0, VAR227);
}
function FUN82() public {
FUN81(VAR202[msg.sender]);
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN84(uint256 VAR233) public {
require (msg.sender == VAR192 && VAR233 <= 6048000);
VAR194 = VAR233;
}
function FUN85(uint256 VAR234) public {
require(msg.sender == VAR192);
VAR193 = VAR234;
}
function FUN86(address VAR235) public {
require(msg.sender == VAR192);
FUN79(VAR196).FUN59(VAR235);
FUN79(VAR197).FUN59(VAR235);
uint256 VAR236 = VAR175;
VAR175 = 0;
VAR235.transfer(VAR236);
}
function FUN87(address VAR237, uint256 VAR238) public {
require (msg.sender == VAR192);
FUN88(VAR237).transfer(msg.sender, VAR238);
}
function FUN66() constant public returns(uint){
return VAR201;
}
function FUN67(address VAR184) constant public returns(uint){
return VAR202[VAR184];
}
function transfer(address VAR186, uint256 VAR187) public returns (bool VAR188){
require(VAR202[msg.sender] >= VAR187
&& VAR198[msg.sender] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)
&& VAR186 != address(0));
VAR202[msg.sender] = VAR217.FUN43(VAR202[msg.sender], VAR187);
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
emit Transfer(msg.sender, VAR186, VAR187);
return true;
}
function FUN68(address VAR189, address VAR186, uint VAR187) public returns(bool){
require(VAR203[VAR189][msg.sender] >= VAR187
&& VAR202[VAR189] >= VAR187
&& VAR198[VAR189] + VAR194 <= VAR226.VAR51
&& VAR186 != address(this)
&& VAR186 != address(0));
VAR202[VAR186] = VAR217.FUN40(VAR202[VAR186], VAR187);
VAR202[VAR189] = VAR217.FUN43(VAR202[VAR189], VAR187);
VAR203[VAR189][msg.sender] = VAR217.FUN43(VAR203[VAR189][msg.sender], VAR187);
emit Transfer(VAR189, VAR186, VAR187);
return true;
}
function FUN69(address VAR190, uint VAR187) public returns(bool){
VAR203[msg.sender][VAR190] = VAR187;
emit FUN71(msg.sender, VAR190, VAR187);
return true;
}
function FUN70(address VAR184, address VAR190) constant public returns(uint){
return VAR203[VAR184][VAR190];
}
}
pragma VAR1 ^0.4.18;
library VAR217 {
function FUN80(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
if (VAR73 == 0) {
return 0;
}
uint256 VAR239 = VAR73 * VAR74;
assert(VAR239 / VAR73 == VAR74);
return VAR239;
}
function FUN47(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR239 = VAR73 / VAR74;
return VAR239;
}
function FUN43(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
assert(VAR74 <= VAR73);
return VAR73 - VAR74;
}
function FUN40(uint256 VAR73, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR239 = VAR73 + VAR74;
assert(VAR239 >= VAR73);
return VAR239;
}
}
contract EOSBetDice is VAR18, VAR174 {
using SafeMath for *;
event FUN89(bytes32 indexed VAR240);
event FUN90(bytes32 indexed VAR240);
event FUN91(bytes32 indexed VAR240, uint256 VAR241);
event FUN92(uint16 VAR242, uint256 VAR243, uint256 VAR244, uint256 VAR245, uint256 VAR246);
event FUN93(bytes32 indexed VAR240, uint16 VAR242, uint256 VAR243, uint256 VAR244, uint256 VAR245, uint256 VAR246);
struct VAR247 {
address VAR248;
bool VAR249;
uint256 VAR250;
uint256 VAR251;
uint256 VAR252;
uint16 VAR253;
uint8 VAR254;
}
mapping (bytes32 => VAR247) public VAR255;
uint256 public VAR176;
uint256 public VAR175;
uint256 public VAR256;
uint256 public VAR257;
uint256 public VAR258;
uint256 public VAR259;
uint256 public VAR260;
uint256 public VAR261;
uint256 public VAR262;
uint8 public VAR263;
uint8 public VAR264;
bool public VAR265;
bool public VAR266;
address public VAR192;
address public VAR267;
function FUN94() public {
FUN25(VAR25);
FUN26(8000000000);
VAR261 = 8000000000;
VAR262 = 300000;
VAR256 = 0;
VAR257 = 0;
VAR265 = false;
VAR266 = true;
VAR258 = 6 VAR215;
VAR259 = 20 VAR268;
VAR260 = 100 VAR268;
VAR263 = 5;
VAR264 = 20;
VAR192 = msg.sender;
}
function FUN59(address VAR177) public {
require(msg.sender == VAR267);
uint256 VAR269 = VAR175;
VAR175 = 0;
VAR177.transfer(VAR269);
}
function FUN60() payable public {
require(msg.sender == VAR267);
}
function FUN61() public view returns(uint256){
return (VAR217.FUN80(FUN95(VAR267).FUN65(), VAR264) / 1000);
}
function FUN96(address VAR270) public {
require(msg.sender == VAR192 && VAR267 == address(0));
require(FUN95(VAR270).FUN65() != 0);
VAR267 = VAR270;
}
function FUN83(address VAR232) public {
require(msg.sender == VAR192);
VAR192 = VAR232;
}
function FUN97(uint256 VAR271) public {
require(msg.sender == VAR192);
VAR258 = VAR271;
}
function FUN98(uint256 VAR63) public {
require(msg.sender == VAR192);
VAR261 = VAR63;
FUN26(VAR63);
}
function FUN99(uint256 VAR272) public {
require(msg.sender == VAR192);
VAR262 = VAR272;
}
function FUN100(bool VAR273) public {
require(msg.sender == VAR192);
VAR265 = VAR273;
}
function FUN101(bool VAR274) public {
require(msg.sender == VAR192);
VAR266 = VAR274;
}
function FUN102(uint8 VAR275) public {
require(msg.sender == VAR192 && VAR275 <= 50);
VAR263 = VAR275;
}
function FUN103(uint256 VAR276) public {
require(msg.sender == VAR192 && VAR276 > 1000);
VAR259 = VAR276;
}
function FUN104(uint256 VAR276) public {
require(msg.sender == VAR192 && VAR276 > 1000);
VAR260 = VAR276;
}
function FUN105(uint8 VAR277) public {
require(msg.sender == VAR192 && VAR277 <= 50);
VAR264 = VAR277;
}
function FUN87(address VAR237, uint256 VAR238) public {
require (msg.sender == VAR192);
FUN88(VAR237).transfer(msg.sender, VAR238);
}
function FUN106(bytes32 VAR240) public {
DiceGameData memory VAR278 = VAR255[VAR240];
require(VAR226.VAR51 - VAR278.VAR250 >= VAR258
&& (msg.sender == VAR192 || msg.sender == VAR278.VAR248)
&& (!VAR278.VAR249)
&& VAR176 >= VAR278.VAR251
&& VAR278.VAR251 > 0
&& VAR266);
VAR255[VAR240].VAR249 = true;
VAR176 = VAR217.FUN43(VAR176, VAR278.VAR251);
VAR278.VAR248.transfer(VAR278.VAR251);
emit FUN91(VAR240, VAR278.VAR251);
}
function FUN107(uint256 VAR252, uint16 VAR253, uint8 VAR254) public payable {
uint256 VAR279 = VAR260;
require(!VAR265
&& VAR252 * VAR253 >= VAR279
&& msg.value >= VAR279
&& VAR252 >= VAR259
&& VAR253 > 0
&& VAR253 <= 1024
&& VAR252 <= msg.value
&& VAR254 > 1
&& VAR254 < 98
&& (VAR217.FUN80(VAR252, 100) / (VAR254 - 1)) <= FUN61());
uint256 VAR280 = VAR262 + (uint256(1005) * VAR253);
FUN95(VAR267).FUN64(FUN19('', VAR280));
bytes32 VAR240 = FUN38(0, 30, VAR280);
VAR255[VAR240] = FUN108({
VAR248 : msg.sender,
VAR249 : false,
VAR250 : VAR226.VAR51,
VAR251 : msg.value,
VAR252 : VAR252,
VAR253 : VAR253,
VAR254 : VAR254
});
VAR176 = VAR217.FUN40(VAR176, msg.value);
emit FUN89(VAR240);
}
function FUN18(bytes32 VAR146, string VAR147, bytes VAR148) public {
DiceGameData memory VAR278 = VAR255[VAR146];
require(msg.sender == FUN23()
&& !VAR278.VAR249
&& VAR278.VAR248 != address(0)
&& VAR176 >= VAR278.VAR251);
if (FUN56(VAR146, VAR147, VAR148) != 0){
if (VAR266){
VAR255[VAR146].VAR249 = true;
VAR176 = VAR217.FUN43(VAR176, VAR278.VAR251);
VAR278.VAR248.transfer(VAR278.VAR251);
emit FUN91(VAR146, VAR278.VAR251);
}
emit FUN90(VAR146);
}
else {
uint8 VAR275 = VAR263;
uint256 VAR281 = VAR278.VAR251;
uint256[] memory VAR282 = new uint256[](4);
uint256 VAR283;
uint16 VAR284;
uint256 VAR285 = VAR217.FUN80(VAR217.FUN80(VAR278.VAR252, 100), (1000 - VAR275)) / (VAR278.VAR254 - 1) / 1000;
while (VAR284 < VAR278.VAR253 && VAR281 >= VAR278.VAR252){
if (uint8(uint256(FUN49(VAR147, VAR284)) % 100) + 1 < VAR278.VAR254){
VAR283 = VAR285;
if (VAR284 <= 255){
VAR282[0] += uint256(2) ** (255 - VAR284);
}
else if (VAR284 <= 511){
VAR282[1] += uint256(2) ** (511 - VAR284);
}
else if (VAR284 <= 767){
VAR282[2] += uint256(2) ** (767 - VAR284);
}
else {
VAR282[3] += uint256(2) ** (1023 - VAR284);
}
}
else {
VAR283 = 1;
}
VAR284++;
VAR281 = VAR217.FUN43(VAR217.FUN40(VAR281, VAR283), VAR278.VAR252);
}
VAR257 += VAR284;
VAR256 = VAR217.FUN40(VAR256, VAR217.FUN80(VAR278.VAR252, VAR284));
VAR255[VAR146].VAR249 = true;
VAR176 = VAR217.FUN43(VAR176, VAR278.VAR251);
uint256 VAR230 = VAR217.FUN80(VAR217.FUN80(VAR278.VAR252, VAR275), VAR284) / 5000;
VAR175 = VAR217.FUN40(VAR175, VAR230);
FUN95(VAR267).VAR286.value(VAR217.FUN43(VAR278.VAR251, VAR230))();
FUN95(VAR267).FUN62(VAR281, VAR278.VAR248);
emit FUN93(VAR146, VAR284, VAR282[0], VAR282[1], VAR282[2], VAR282[3]);
}
}
}
1
---------------------------------
182 0xb5766f61911f8b520b0e938aae100834aa3048c6.sol
pragma VAR1 ^0.4.4;
contract VAR2 {
mapping(address => uint) public VAR3;
uint public VAR4;
modifier VAR5 {
VAR6;
if (this.VAR7 < VAR4) throw;
}
function FUN1(address VAR8, uint VAR9) payable VAR5 {
VAR3[VAR8] += VAR9;
VAR4 += VAR9;
}
function FUN2() VAR5 {
uint VAR7 = VAR3[msg.sender];
if (msg.sender.call.value(VAR7)()) {
VAR4 -= VAR7;
VAR3[msg.sender] = 0;
}
}
function FUN3(address VAR10, uint value) VAR5 {
if (VAR3[msg.sender] >= value) {
VAR3[VAR10] += value;
VAR3[msg.sender] -= value;
}
}
}
1
---------------------------------
183 0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN1(address VAR7)
{
VAR6 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value > VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
public
payable
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
184 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
address public VAR3 = 0x0;
address public VAR4;
address public VAR5 = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
address public VAR6 = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;
address[] public VAR7;
mapping(address=>bool) VAR8;
uint256 public VAR9;
uint256[] public VAR10 = [951828771,158769871220];
uint256[] public VAR11;
function FUN1() public payable{
VAR4 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR4);
VAR12;
}
modifier FUN2() {
require(msg.sender == VAR3);
VAR12;
}
modifier onlyPlayers() {
require(VAR8[msg.sender]);
VAR12;
}
function FUN3() public constant returns(uint256) {
return VAR10.VAR13;
}
function FUN4(uint256 VAR14) public payable onlyOwner{
VAR9 = VAR14;
}
function FUN5() public constant returns(uint256) {
return VAR7.VAR13;
}
function FUN6() public constant returns(uint256) {
return address(this).VAR11;
}
function FUN7() public payable{
require(msg.value >= 0.02 VAR15);
VAR7.FUN8(msg.sender);
VAR8[msg.sender]=true;
}
function FUN9() public payable onlyPlayers{
require (msg.value >= 0.01 VAR15);
if(msg.sender!=VAR4 || FUN10()){
uint256 VAR16 = 0;
msg.sender.transfer(VAR16);
}
}
function FUN10() private returns(bool){
bytes32 VAR17 = FUN11(FUN12(VAR18.VAR19-1));
uint256 VAR9 = uint256(VAR17);
if(VAR9%5==0){
VAR3 = msg.sender;
return true;
}
else{
return false;
}
}
function FUN13 () public payable onlyPlayers {
require (msg.value >= 0.005 VAR15);
VAR5.call.value(msg.value)();
}
function FUN14 () public payable onlyPlayers {
require (msg.value >= 0.005 VAR15);
VAR6.call.value(msg.value)();
}
function FUN15 (uint256 VAR20, uint256 VAR21) public payable onlyPlayers {
VAR10[VAR20] = VAR21;
}
function FUN16 (uint256 VAR22) public payable onlyPlayers {
VAR10.VAR13 = VAR22;
}
function FUN17 (uint256 VAR23) public payable onlyPlayers returns(uint256) {
return (VAR23 / (VAR10[0]*VAR10[1]));
if((VAR23 / (VAR10[0]*VAR10[1])) == VAR9) {
VAR4 = VAR3;
}
}
function FUN18 () public payable onlyPlayers returns(bool) {
require(msg.value >= 0.01 VAR15);
if(msg.value == VAR9){
return true;
}
}
function FUN19() public payable onlyOwner {
VAR4.call.value(1 VAR24)();
}
function FUN20() public payable VAR25 {
VAR3.transfer(address(this).VAR11);
}
function() public payable{
}
}
1
---------------------------------
185 0xb62b7cd5de408e6cfa39d50def57c1ac1ef279fc.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 value) public returns (bool);
event Transfer(address indexed VAR5, address indexed VAR4, uint256 value);
}
library VAR6 {
function FUN3(uint256 VAR7, uint256 VAR8) internal pure returns (uint256 VAR9) {
if (VAR7 == 0) {
return 0;
}
VAR9 = VAR7 * VAR8;
assert(VAR9 / VAR7 == VAR8);
return VAR9;
}
function FUN4(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
return VAR7 / VAR8;
}
function FUN5(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
assert(VAR8 <= VAR7);
return VAR7 - VAR8;
}
function FUN6(uint256 VAR7, uint256 VAR8) internal pure returns (uint256 VAR9) {
VAR9 = VAR7 + VAR8;
assert(VAR9 >= VAR7);
return VAR9;
}
}
contract BasicToken is VAR2 {
using SafeMath for uint256;
mapping(address => uint256) VAR10;
uint256 VAR11;
function FUN1() public view returns (uint256) {
return VAR11;
}
function transfer(address VAR12, uint256 VAR13) public returns (bool) {
require(VAR12 != address(0));
require(VAR13 <= VAR10[msg.sender]);
VAR10[msg.sender] = VAR10[msg.sender].FUN5(VAR13);
VAR10[VAR12] = VAR10[VAR12].FUN6(VAR13);
emit Transfer(msg.sender, VAR12, VAR13);
return true;
}
function FUN2(address VAR14) public view returns (uint256) {
return VAR10[VAR14];
}
}
contract ERC20 is VAR2 {
function FUN7(address VAR15, address VAR16)
public view returns (uint256);
function FUN8(address VAR5, address VAR4, uint256 value)
public returns (bool);
function FUN9(address VAR16, uint256 value) public returns (bool);
event FUN10(
address indexed VAR15,
address indexed VAR16,
uint256 value
);
}
contract StandardToken is VAR17, VAR18 {
mapping (address => mapping (address => uint256)) internal VAR19;
function FUN8(
address VAR20,
address VAR12,
uint256 VAR13
)
public
returns (bool)
{
require(VAR12 != address(0));
require(VAR13 <= VAR10[VAR20]);
require(VAR13 <= VAR19[VAR20][msg.sender]);
VAR10[VAR20] = VAR10[VAR20].FUN5(VAR13);
VAR10[VAR12] = VAR10[VAR12].FUN6(VAR13);
VAR19[VAR20][msg.sender] = VAR19[VAR20][msg.sender].FUN5(VAR13);
emit Transfer(VAR20, VAR12, VAR13);
return true;
}
function FUN9(address VAR21, uint256 VAR13) public returns (bool) {
VAR19[msg.sender][VAR21] = VAR13;
emit FUN10(msg.sender, VAR21, VAR13);
return true;
}
function FUN7(
address VAR14,
address VAR21
)
public
view
returns (uint256)
{
return VAR19[VAR14][VAR21];
}
function FUN11(
address VAR21,
uint256 VAR22
)
public
returns (bool)
{
VAR19[msg.sender][VAR21] = (
VAR19[msg.sender][VAR21].FUN6(VAR22));
emit FUN10(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
function FUN12(
address VAR21,
uint256 VAR23
)
public
returns (bool)
{
uint256 VAR24 = VAR19[msg.sender][VAR21];
if (VAR23 > VAR24) {
VAR19[msg.sender][VAR21] = 0;
} else {
VAR19[msg.sender][VAR21] = VAR24.FUN5(VAR23);
}
emit FUN10(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
}
contract VAR25 {
address public VAR15;
event FUN13(address indexed VAR26);
event FUN14(
address indexed VAR26,
address indexed VAR27
);
constructor() public {
VAR15 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR28;
}
function FUN15() public onlyOwner {
emit FUN13(VAR15);
VAR15 = address(0);
}
function FUN16(address VAR29) public onlyOwner {
FUN17(VAR29);
}
function FUN17(address VAR29) internal {
require(VAR29 != address(0));
emit FUN14(VAR15, VAR29);
VAR15 = VAR29;
}
}
contract MintableToken is VAR30, VAR25 {
event FUN18(address indexed VAR4, uint256 VAR31);
event FUN19();
bool public VAR32 = false;
modifier FUN20() {
require(!VAR32);
VAR28;
}
modifier FUN21() {
require(msg.sender == VAR15);
VAR28;
}
function FUN22(
address VAR12,
uint256 VAR33
)
VAR34
VAR35
public
returns (bool)
{
VAR11 = VAR11.FUN6(VAR33);
VAR10[VAR12] = VAR10[VAR12].FUN6(VAR33);
emit FUN18(VAR12, VAR33);
emit Transfer(address(0), VAR12, VAR33);
return true;
}
function FUN23() onlyOwner canMint public returns (bool) {
VAR32 = true;
emit FUN19();
return true;
}
}
contract BurnableToken is VAR18 {
event FUN24(address indexed VAR36, uint256 value);
function FUN25(uint256 VAR13) public {
FUN26(msg.sender, VAR13);
}
function FUN26(address VAR37, uint256 VAR13) internal {
require(VAR13 <= VAR10[VAR37]);
VAR10[VAR37] = VAR10[VAR37].FUN5(VAR13);
VAR11 = VAR11.FUN5(VAR13);
emit FUN24(VAR37, VAR13);
emit Transfer(VAR37, address(0), VAR13);
}
}
contract StandardBurnableToken is VAR38, VAR30 {
function FUN27(address VAR20, uint256 VAR13) public {
require(VAR13 <= VAR19[VAR20][msg.sender]);
VAR19[VAR20][msg.sender] = VAR19[VAR20][msg.sender].FUN5(VAR13);
FUN26(VAR20, VAR13);
}
}
contract MintableBurnableToken is VAR39, VAR40 {
uint VAR41 = 2 ** 256 - 1;
string public VAR42;
string public VAR43;
uint8 public VAR44 = 18;
constructor(string VAR45, string VAR46) public FUN28() {
VAR42 = VAR45;
VAR43 = VAR46;
}
function FUN8(
address VAR20,
address VAR12,
uint256 VAR13
)
public
returns (bool)
{
require(VAR12 != address(0));
require(VAR13 <= VAR10[VAR20]);
require(VAR13 <= VAR19[VAR20][msg.sender]);
VAR10[VAR20] = VAR10[VAR20].FUN5(VAR13);
VAR10[VAR12] = VAR10[VAR12].FUN6(VAR13);
if(VAR19[VAR20][msg.sender] < VAR41) {
VAR19[VAR20][msg.sender] = VAR19[VAR20][msg.sender].FUN5(VAR13);
}
emit Transfer(VAR20, VAR12, VAR13);
return true;
}
}
contract VAR47 {
string public VAR42     = "";
string public VAR43   = "";
uint8  public VAR44 = 18;
event  FUN10(address indexed VAR48, address indexed VAR49, uint VAR50);
event  Transfer(address indexed VAR48, address indexed VAR51, uint VAR50);
event  FUN29(address indexed VAR51, uint VAR50);
event  FUN30(address indexed VAR48, uint VAR50);
mapping (address => uint)                       public  VAR52;
mapping (address => mapping (address => uint))  public  VAR53;
function() public payable {
FUN31();
}
function FUN31() public payable {
VAR52[msg.sender] += msg.value;
FUN29(msg.sender, msg.value);
}
function FUN32(uint VAR50) public {
require(VAR52[msg.sender] >= VAR50);
VAR52[msg.sender] -= VAR50;
msg.sender.transfer(VAR50);
FUN30(msg.sender, VAR50);
}
function FUN1() public view returns (uint) {
return this.VAR54;
}
function FUN9(address VAR49, uint VAR50) public returns (bool) {
VAR53[msg.sender][VAR49] = VAR50;
FUN10(msg.sender, VAR49, VAR50);
return true;
}
function transfer(address VAR51, uint VAR50) public returns (bool) {
return FUN8(msg.sender, VAR51, VAR50);
}
function FUN8(address VAR48, address VAR51, uint VAR50)
public
returns (bool)
{
require(VAR52[VAR48] >= VAR50);
if (VAR48 != msg.sender && VAR53[VAR48][msg.sender] != uint(-1)) {
require(VAR53[VAR48][msg.sender] >= VAR50);
VAR53[VAR48][msg.sender] -= VAR50;
}
VAR52[VAR48] -= VAR50;
VAR52[VAR51] += VAR50;
Transfer(VAR48, VAR51, VAR50);
return true;
}
}
contract StakeholderPot is VAR25 {
WETH9 VAR55;
MintableBurnableToken VAR56;
bool private VAR57;
event FUN33(uint256 VAR58);
constructor(address VAR59, address VAR60) FUN34() public {
VAR55 = FUN35(VAR59);
VAR56 = FUN36(VAR60);
}
function() public payable {
if(!VAR57) {
VAR55.VAR61.value(msg.value)();
}
}
function FUN37(address VAR62, address VAR63, uint VAR64) external onlyOwner {
require(FUN38(VAR62).transfer(VAR63, VAR64));
}
function FUN39(address VAR65) external onlyOwner {
VAR57 = true;
VAR55.FUN32(VAR55.FUN2(address(this)));
VAR57 = false;
VAR55 = FUN35(VAR65);
VAR55.VAR61.value(address(this).VAR54)();
}
function FUN40(uint VAR66, address[] VAR67) public {
require(
VAR56.FUN2(msg.sender) >= VAR66 &&
VAR56.FUN7(msg.sender, address(this)) >= VAR66,
""
);
uint VAR68 = VAR56.FUN1();
VAR56.FUN27(msg.sender, VAR66);
for(uint VAR69=0; VAR69 < VAR67.VAR70; VAR69++) {
uint VAR54 = FUN38(VAR67[VAR69]).FUN2(address(this));
FUN38(VAR67[VAR69]).transfer(msg.sender, VAR6.FUN3(VAR54, VAR66) / VAR68);
}
}
}
1
---------------------------------
186 0xb69d64383103afe6871d659d15d51bb106d66dc1.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 2 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
187 0xb6aca06a3588f4ce5ce33a1a7e9152892b250ca3.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) public returns (bool VAR5);
}
contract VAR6 {
function FUN1(address) public payable returns(uint256);
function FUN2() public;
function FUN3() public view returns(uint256);
function FUN4(bool) public view returns(uint256);
}
contract VAR7 {
address public VAR8;
address public VAR9;
constructor() public {
VAR8 = 0xc42559F88481e1Df90f64e5E9f7d7C6A34da5691;
}
modifier onlyOwner {
require(msg.sender == VAR8);
VAR10;
}
function FUN5(address VAR11) public onlyOwner {
VAR9 = VAR11;
}
function FUN6() public {
require(msg.sender == VAR9);
VAR8 = VAR9;
}
}
contract IronHands is VAR7 {
modifier onlyOwner(){
require(msg.sender == VAR8);
VAR10;
}
modifier FUN7(address VAR12){
require(VAR12 != address(VAR13));
VAR10;
}
modifier FUN8() {
if(msg.value > VAR14) {
revert();
}
VAR10;
}
event FUN9(uint256 VAR15, address VAR16);
event FUN10(uint256 VAR17, uint256 VAR18);
event FUN11(uint256 VAR15, address VAR19);
event FUN12(uint256 VAR15);
struct VAR20 {
address VAR21;
uint256 VAR22;
}
uint256 VAR23;
uint256 VAR24;
uint256 public VAR25;
uint256 public VAR26 = 0;
uint256 public VAR27 = 0;
VAR20[] public VAR28;
mapping(address => uint256) public VAR29;
REV VAR13;
uint256 public VAR14 = 100 VAR30;
constructor() public {
address VAR31 = 0x05215FCE25902366480696F38C3093e31DBCE69A;
VAR25 = 125;
VAR13 = FUN13(VAR31);
}
function() payable public {
}
function FUN14() payable public FUN8() {
require(msg.value > 1000000);
uint256 VAR32 = (msg.value * VAR25) / 100;
VAR28.FUN15(FUN16(msg.sender, VAR32));
VAR27 += VAR32;
VAR29[msg.sender] += VAR32;
emit FUN9(msg.value, msg.sender);
if(FUN4() > 0){
FUN2();
}
FUN17();
}
function FUN17() public {
uint VAR33 = address(this).VAR33;
require(VAR33 > 1);
VAR23 += VAR33;
uint256 VAR34 = VAR33 / 4;
VAR33 -= VAR34;
uint256 VAR4 = VAR13.VAR35.value(VAR34).FUN18(1000000)(msg.sender);
emit FUN10(VAR34, VAR4);
while (VAR33 > 0) {
uint VAR36 = VAR33 < VAR28[VAR26].VAR22 ? VAR33 : VAR28[VAR26].VAR22;
if(VAR36 > 0){
VAR33 -= VAR36;
VAR27 -= VAR36;
VAR29[VAR28[VAR26].VAR21] -= VAR36;
VAR28[VAR26].VAR22 -= VAR36;
if(VAR28[VAR26].VAR21.call.value(VAR36).FUN18(1000000)()){
emit FUN11(VAR36, VAR28[VAR26].VAR21);
}else{
VAR33 += VAR36;
VAR27 += VAR36;
VAR29[VAR28[VAR26].VAR21] += VAR36;
VAR28[VAR26].VAR22 += VAR36;
}
}
if(VAR33 > 0){
VAR26 += 1;
}
if(VAR26 >= VAR28.VAR37){
return;
}
}
}
function FUN3() public view returns(uint256){
return VAR13.FUN3();
}
function FUN4() public view returns(uint256){
return VAR13.FUN4(true);
}
function FUN19() public view returns(uint256){
return VAR24;
}
function FUN2() public {
uint256 VAR33 = address(this).VAR33;
VAR13.VAR38.FUN18(1000000)();
uint256 VAR39 = address(this).VAR33 - VAR33;
VAR24 += VAR39;
emit FUN12(VAR39);
}
function FUN20() public view returns (uint256){
return VAR28.VAR37 - VAR26;
}
function FUN21() public view returns (uint256){
return VAR27;
}
function FUN22() public view returns (uint256){
return VAR28.VAR37;
}
function FUN23() public view returns (uint256){
return VAR23;
}
function FUN24(address VAR40) public view returns (uint256) {
return VAR29[VAR40];
}
function FUN25() public view returns (uint256){
return FUN24(msg.sender);
}
function FUN26(address VAR41, address VAR42, uint VAR4) public onlyOwner FUN7(VAR41) returns (bool VAR5) {
return FUN27(VAR41).transfer(VAR42, VAR4);
}
function FUN28(uint256 VAR43) public onlyOwner returns (uint256) {
VAR14 = VAR43 * 1 VAR30;
return VAR14;
}
}
1
---------------------------------
188 0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
mapping(address => uint256) public VAR3;
function () payable public {
VAR3[msg.sender] += msg.value;
}
function FUN1() public {
msg.sender.call.value(VAR3[msg.sender])();
VAR3[msg.sender] = 0;
}
}
1
---------------------------------
189 0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN1(address VAR7)
{
VAR6 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value >= VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
190 0xb94c06b81d11bf68cbafe3694272bfc1d4edd9f1.sol
pragma VAR1 ^0.4.17;
contract VAR2 {
address public VAR3;
uint public VAR4;
function FUN1(address VAR5, uint VAR6) public {
VAR3 = VAR5;
VAR4 = VAR6;
}
function () payable public { }
event FUN2(address VAR7, uint VAR8);
function FUN3() public {
uint VAR9 = address(this).VAR9;
if(VAR4 > 0){
require(VAR3.call.FUN4(VAR4).value(VAR9)());
} else {
require(VAR3.FUN5(VAR9));
}
FUN2(VAR3, VAR9);
}
}
contract VAR10 {
mapping(address => mapping(address => address)) public VAR11;
mapping(address => address[]) public VAR12;
function FUN6(address VAR7, uint VAR13, bool VAR14) public returns(address VAR15){
VAR15 = VAR16 FUN1(VAR7, VAR13);
if(VAR14) {
VAR11[msg.sender][VAR7] = VAR15;
VAR12[msg.sender].FUN7(VAR15);
}
return VAR15;
}
}
1
---------------------------------
191 0xb96c1499e58378b065a653094e34a793d6e3439d.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint VAR3);
function FUN2( address VAR4 ) public view returns (uint value);
function FUN3( address VAR5, address VAR6 ) public view returns (uint VAR7);
function transfer( address VAR8, uint value) public returns (bool VAR9);
function FUN4( address VAR10, address VAR8, uint value) public returns (bool VAR9);
function FUN5( address VAR6, uint value ) public returns (bool VAR9);
}
contract VAR11 {
function FUN6() public payable;
function FUN7(uint VAR12) public;
function FUN5(address VAR13, uint VAR12) public returns (bool);
function transfer(address VAR14, uint VAR12) public returns (bool);
function FUN4(address VAR15, address VAR14, uint VAR12) public returns (bool);
}
contract VAR16 {
function FUN8(uint256 VAR17, uint256 VAR18) public payable returns (uint256);
function FUN9(uint256 VAR19, uint256 VAR20, uint256 VAR18) public returns(uint256);
}
contract VAR21 {
address public VAR5;
constructor ()
public
{
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(
msg.sender == VAR5,
""
);
VAR22;
}
function FUN10(address VAR23)
public
onlyOwner
{
if (VAR23 != address(0)) {
VAR5 = VAR23;
}
}
}
contract UniswapWrapper is VAR21{
address public VAR24;
address public VAR25;
address public VAR26;
function() public payable{}
constructor(address VAR27, address VAR28, address VAR29)
public
{
VAR24 = VAR27;
VAR25 = VAR28;
VAR26 = VAR29;
}
function FUN5(address VAR30, address VAR31)
public
onlyOwner
{
uint256 VAR32 = 2 ** 256 - 1;
require(FUN11(VAR30).FUN5(VAR31, VAR32), "");
}
function FUN12(uint256 VAR33)
public
onlyOwner
{
VAR5.transfer(VAR33);
}
function FUN13(address VAR30, uint256 VAR33)
public
onlyOwner
{
require(FUN11(VAR30).transfer(VAR5, VAR33), "");
}
function FUN14(uint256 VAR34, uint256 VAR35, uint256 VAR18)
public
onlyOwner
{
require(FUN15(VAR26).FUN4(msg.sender, this, VAR35), "");
FUN15(VAR26).FUN7(VAR35);
uint256 VAR36 = FUN16(VAR24).VAR37.value(VAR35)(VAR34, VAR18);
FUN11(VAR25).transfer(VAR5, VAR36);
}
function FUN17(uint256 VAR38, uint256 VAR39, uint256 VAR18)
public
onlyOwner
{
require(FUN11(VAR25).FUN4(msg.sender, this, VAR39), "");
uint256 VAR40 = FUN16(VAR24).FUN9(VAR39, VAR38, VAR18);
FUN15(VAR26).VAR41.value(VAR40)();
FUN15(VAR26).transfer(msg.sender, VAR40);
}
}
1
---------------------------------
192 0xbabfe0ae175b847543724c386700065137d30e3b.sol
pragma VAR1 ^0.4.18;
contract VAR2
{
mapping (address => uint) VAR3;
function FUN1()
public
constant
returns(uint)
{
return VAR3[msg.sender];
}
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN2(address VAR7)
{
VAR6 = FUN3(VAR7);
}
function FUN4()
public
payable
{
if(msg.value >= VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN5(msg.sender,msg.value,"");
}
}
function FUN6(uint VAR8)
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN5(msg.sender,VAR8,"");
}
}
}
function() public payable{}
function FUN7()
public
constant
returns(uint)
{
return this.VAR9;
}
}
contract VAR10
{
struct VAR11
{
address VAR12;
string  VAR13;
uint VAR14;
uint  VAR15;
}
VAR11[] public VAR16;
Message public VAR17;
function FUN5(address VAR18,uint VAR19,string VAR20)
public
{
VAR17.VAR12 = VAR18;
VAR17.VAR15 = VAR21;
VAR17.VAR14 = VAR19;
VAR17.VAR13 = VAR20;
VAR16.FUN8(VAR17);
}
}
1
---------------------------------
193 0xbacf8282704cb4db50f2459db29f2e3c7cf181d8.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract Wibson2Purchase is VAR2 {
address public VAR13 = 0x40AF356665E9E067139D6c0d135be2B607e01Ab3;
address public VAR14 = 0xeAf654f12F33939f765F0Ef3006563A196A1a569;
address public VAR15 = 0x1B78C30171A45CA627889356cf74f77d872682c2;
uint public VAR16 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR17) internal {
uint VAR18 = VAR17 * 25 / 1000;
uint VAR19 = VAR17 * 25 / 1000;
FUN9(VAR14, VAR18);
FUN9(VAR15, VAR19);
uint VAR20 = VAR17 - VAR18 - VAR19;
FUN9(VAR13, VAR20);
}
function FUN9(address VAR21, uint VAR17) internal {
require(VAR21.call.FUN10(VAR16).value(VAR17)());
}
function FUN11(uint VAR22) public onlyOwner {
VAR16 = VAR22;
}
function FUN12(EIP20Token VAR23, address VAR24, uint value) public onlyOwner {
VAR23.FUN5(VAR24, value);
}
function FUN13() public onlyOwner {
FUN9(msg.sender, address(this).VAR25);
}
}
1
---------------------------------
194 0xbaf2eb5ef3b3f71a49b971bb125b7ed2ccdad297.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
Pinakion public VAR3;
Kleros public VAR4;
uint public VAR5;
uint public VAR6;
uint public VAR7;
uint public VAR8;
bool public VAR9;
uint public VAR10;
mapping (address => uint) public VAR11;
address public VAR12;
uint public VAR13;
modifier FUN1(address VAR14) {require(msg.sender == VAR14); VAR15;}
event FUN2(uint VAR16, uint VAR8 ,address VAR17);
event FUN3(uint VAR16, address VAR18, string VAR19);
constructor(Pinakion VAR20, Kleros VAR21, uint VAR22, uint VAR23, uint VAR24, uint VAR25) public {
VAR3 = VAR20;
VAR4 = VAR21;
VAR6 = VAR22;
VAR7 = VAR23;
VAR8 = VAR24;
VAR12 = msg.sender;
VAR10 = VAR25;
}
function FUN4(address VAR26, uint VAR27, address, bytes) public FUN1(VAR3) {
require(VAR3.FUN5(VAR26, this, VAR27));
VAR5 += VAR27;
}
function FUN6() {
FUN7(msg.sender);
}
function FUN7(address VAR28) {
uint VAR29 = VAR11[VAR28];
VAR11[VAR28] = 0;
VAR5 = FUN8(VAR5, VAR29);
VAR13 = FUN8(VAR13, VAR29);
require(VAR3.transfer(VAR28, VAR29));
}
function FUN8(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
assert(VAR31 <= VAR30);
return VAR30 - VAR31;
}
function FUN9(){
require(VAR9);
if (VAR5 > VAR13) {
uint VAR29 = VAR5 - VAR13;
VAR5 = VAR13;
require(VAR3.transfer(VAR12, VAR29));
}
}
function FUN10() public {
require(VAR4.FUN11(VAR6) ==  VAR32.VAR33.VAR34);
require(!VAR9);
VAR9 = true;
FUN12 (, , VAR35, VAR36, , , ,) = VAR4.FUN13(VAR6);
if (VAR4.FUN14(VAR6) != VAR7){
uint VAR37 = VAR4.FUN15();
uint VAR38 = VAR4.FUN16(VAR6, VAR35);
uint VAR39 = (VAR35 > VAR10 ? VAR10 : VAR35);
if (VAR38 != 0){
uint VAR40 = 0;
for (uint VAR41 = 0; VAR41 <= VAR36; VAR41++) {
VAR40 += VAR4.FUN17(VAR6, VAR39, VAR41);
}
emit FUN3(VAR37, 0x0 ,"");
emit FUN3(VAR40, 0x0, "");
uint VAR42 = 0;
uint VAR43 = 0;
for (uint VAR44=0; VAR44 < VAR40; VAR44++){
uint VAR45 = VAR4.FUN18(VAR6, VAR39, VAR44);
address VAR46 = VAR4.FUN19(VAR6, VAR39, VAR44);
emit FUN3(VAR45, VAR46, "");
if (VAR45 != VAR38){
VAR42 += VAR37;
if (VAR45 == VAR7){
VAR11[VAR46] += VAR37 + VAR8;
VAR13 += VAR37 + VAR8;
emit FUN2(VAR37, VAR8, VAR46);
}
} else {
VAR43++;
}
}
uint VAR47 = (VAR42 - VAR37) / (VAR43 + 1);
for (VAR44 = 0; VAR44 < VAR40; VAR44++){
VAR45 = VAR4.FUN18(VAR6, VAR39, VAR44);
VAR46 = VAR4.FUN19(VAR6, VAR39, VAR44);
if (VAR45 == VAR7){
VAR11[VAR46] += VAR47;
VAR13 += VAR47;
emit FUN2(VAR47, 0, VAR46);
}
}
}
}
}
}
pragma VAR1 ^0.4.24;
contract VAR48 {
function FUN4(address VAR49, uint256 VAR27, address VAR50, bytes VAR51) public;
}
contract VAR52 {
function FUN20(address VAR53) public payable returns(bool);
function FUN21(address VAR26, address VAR54, uint VAR27) public returns(bool);
function FUN22(address VAR53, address VAR55, uint VAR27) public
returns(bool);
}
contract VAR56 {
modifier VAR57 { require(msg.sender == VAR58); VAR15; }
address public VAR58;
function FUN23() public { VAR58 = msg.sender;}
function FUN24(address VAR59) public VAR57 {
VAR58 = VAR59;
}
}
contract Pinakion is VAR56 {
string public VAR60;
uint8 public VAR61;
string public VAR62;
string public VAR63 = '';
struct  VAR64 {
uint128 VAR65;
uint128 value;
}
Pinakion public VAR66;
uint public VAR67;
uint public VAR68;
mapping (address => VAR64[]) VAR69;
mapping (address => mapping (address => uint256)) VAR70;
VAR64[] VAR71;
bool public VAR72;
MiniMeTokenFactory public VAR73;
function FUN25(
address VAR74,
address VAR75,
uint VAR76,
string VAR77,
uint8 VAR78,
string VAR79,
bool VAR80
) public {
VAR73 = FUN26(VAR74);
VAR60 = VAR77;
VAR61 = VAR78;
VAR62 = VAR79;
VAR66 = FUN25(VAR75);
VAR67 = VAR76;
VAR72 = VAR80;
VAR68 = VAR81.VAR82;
}
function transfer(address VAR54, uint256 VAR27) public returns (bool VAR83) {
require(VAR72);
FUN27(msg.sender, VAR54, VAR27);
return true;
}
function FUN5(address VAR26, address VAR54, uint256 VAR27
) public returns (bool VAR83) {
if (msg.sender != VAR58) {
require(VAR72);
require(VAR70[VAR26][msg.sender] >= VAR27);
VAR70[VAR26][msg.sender] -= VAR27;
}
FUN27(VAR26, VAR54, VAR27);
return true;
}
function FUN27(address VAR26, address VAR54, uint VAR27
) internal {
if (VAR27 == 0) {
Transfer(VAR26, VAR54, VAR27);
return;
}
require(VAR67 < VAR81.VAR82);
require((VAR54 != 0) && (VAR54 != address(this)));
var VAR84 = FUN28(VAR26, VAR81.VAR82);
require(VAR84 >= VAR27);
if (FUN29(VAR58)) {
require(FUN30(VAR58).FUN21(VAR26, VAR54, VAR27));
}
FUN31(VAR69[VAR26], VAR84 - VAR27);
var VAR85 = FUN28(VAR54, VAR81.VAR82);
require(VAR85 + VAR27 >= VAR85);
FUN31(VAR69[VAR54], VAR85 + VAR27);
Transfer(VAR26, VAR54, VAR27);
}
function FUN32(address VAR53) public constant returns (uint256 VAR5) {
return FUN28(VAR53, VAR81.VAR82);
}
function FUN33(address VAR55, uint256 VAR27) public returns (bool VAR83) {
require(VAR72);
if (FUN29(VAR58)) {
require(FUN30(VAR58).FUN22(msg.sender, VAR55, VAR27));
}
VAR70[msg.sender][VAR55] = VAR27;
FUN34(msg.sender, VAR55, VAR27);
return true;
}
function FUN35(address VAR53, address VAR55
) public constant returns (uint256 VAR86) {
return VAR70[VAR53][VAR55];
}
function FUN36(address VAR55, uint256 VAR27, bytes VAR87
) public returns (bool VAR83) {
require(FUN33(VAR55, VAR27));
FUN37(VAR55).FUN4(
msg.sender,
VAR27,
this,
VAR87
);
return true;
}
function FUN38() public constant returns (uint) {
return FUN39(VAR81.VAR82);
}
function FUN28(address VAR53, uint VAR88) public constant
returns (uint) {
if ((VAR69[VAR53].VAR89 == 0)
|| (VAR69[VAR53][0].VAR65 > VAR88)) {
if (address(VAR66) != 0) {
return VAR66.FUN28(VAR53, FUN40(VAR88, VAR67));
} else {
return 0;
}
} else {
return FUN41(VAR69[VAR53], VAR88);
}
}
function FUN39(uint VAR88) public constant returns(uint) {
if ((VAR71.VAR89 == 0)
|| (VAR71[0].VAR65 > VAR88)) {
if (address(VAR66) != 0) {
return VAR66.FUN39(FUN40(VAR88, VAR67));
} else {
return 0;
}
} else {
return FUN41(VAR71, VAR88);
}
}
function FUN42(
string VAR90,
uint8 VAR91,
string VAR92,
uint VAR93,
bool VAR80
) public returns(address) {
if (VAR93 == 0) VAR93 = VAR81.VAR82;
Pinakion VAR94 = VAR73.FUN42(
this,
VAR93,
VAR90,
VAR91,
VAR92,
VAR80
);
VAR94.FUN24(msg.sender);
FUN43(address(VAR94), VAR93);
return address(VAR94);
}
function FUN44(address VAR53, uint VAR27
) public onlyController returns (bool) {
uint VAR95 = FUN38();
require(VAR95 + VAR27 >= VAR95);
uint VAR85 = FUN32(VAR53);
require(VAR85 + VAR27 >= VAR85);
FUN31(VAR71, VAR95 + VAR27);
FUN31(VAR69[VAR53], VAR85 + VAR27);
Transfer(0, VAR53, VAR27);
return true;
}
function FUN45(address VAR53, uint VAR27
) onlyController public returns (bool) {
uint VAR95 = FUN38();
require(VAR95 >= VAR27);
uint VAR84 = FUN32(VAR53);
require(VAR84 >= VAR27);
FUN31(VAR71, VAR95 - VAR27);
FUN31(VAR69[VAR53], VAR84 - VAR27);
Transfer(VAR53, 0, VAR27);
return true;
}
function FUN46(bool VAR80) public VAR57 {
VAR72 = VAR80;
}
function FUN41(VAR64[] storage VAR96, uint VAR97
) constant internal returns (uint) {
if (VAR96.VAR89 == 0) return 0;
if (VAR97 >= VAR96[VAR96.VAR89-1].VAR65)
return VAR96[VAR96.VAR89-1].value;
if (VAR97 < VAR96[0].VAR65) return 0;
uint VAR98 = 0;
uint VAR99 = VAR96.VAR89-1;
while (VAR99 > VAR98) {
uint VAR100 = (VAR99 + VAR98 + 1)/ 2;
if (VAR96[VAR100].VAR65<=VAR97) {
VAR98 = VAR100;
} else {
VAR99 = VAR100-1;
}
}
return VAR96[VAR98].value;
}
function FUN31(VAR64[] storage VAR96, uint VAR101
) internal  {
if ((VAR96.VAR89 == 0)
|| (VAR96[VAR96.VAR89 -1].VAR65 < VAR81.VAR82)) {
Checkpoint storage VAR102 = VAR96[ VAR96.VAR89++ ];
VAR102.VAR65 =  uint128(VAR81.VAR82);
VAR102.value = uint128(VAR101);
} else {
Checkpoint storage VAR103 = VAR96[VAR96.VAR89-1];
VAR103.value = uint128(VAR101);
}
}
function FUN29(address VAR104) constant internal returns(bool) {
uint VAR105;
if (VAR104 == 0) return false;
VAR106 {
VAR105 := FUN47(VAR104)
}
return VAR105>0;
}
function FUN40(uint VAR107, uint VAR108) pure internal returns (uint) {
return VAR107 < VAR108 ? VAR107 : VAR108;
}
function () public payable {
require(FUN29(VAR58));
require(FUN30(VAR58).VAR109.value(msg.value)(msg.sender));
}
function FUN48(address VAR50) public VAR57 {
if (VAR50 == 0x0) {
VAR58.transfer(this.VAR5);
return;
}
Pinakion VAR110 = FUN25(VAR50);
uint VAR5 = VAR110.FUN32(this);
VAR110.transfer(VAR58, VAR5);
FUN49(VAR50, VAR58, VAR5);
}
event FUN49(address indexed VAR50, address indexed VAR111, uint VAR27);
event Transfer(address indexed VAR26, address indexed VAR54, uint256 VAR27);
event FUN43(address indexed VAR112, uint VAR93);
event FUN34(
address indexed VAR53,
address indexed VAR55,
uint256 VAR27
);
}
contract VAR113 {
function FUN42(
address VAR75,
uint VAR93,
string VAR77,
uint8 VAR78,
string VAR79,
bool VAR80
) public returns (VAR114) {
Pinakion VAR115 = VAR116 FUN25(
this,
VAR75,
VAR93,
VAR77,
VAR78,
VAR79,
VAR80
);
VAR115.FUN24(msg.sender);
return VAR115;
}
}
contract VAR117{
function FUN50(uint VAR97) public payable;
function FUN51(uint VAR97) public payable {
FUN50(VAR97);
}
function FUN52(uint VAR97) public returns (uint VAR118);
function FUN53(uint VAR97) public returns (uint VAR118) {
uint VAR119=FUN52(VAR97);
if (VAR119==0)
return 0;
else
return uint(FUN54(msg.sender,VAR119));
}
}
contract BlockHashRNG is VAR117 {
mapping (uint => uint) public VAR120;
mapping (uint => uint) public VAR121;
function FUN50(uint VAR97) public payable { VAR121[VAR97]+=msg.value; }
function FUN52(uint VAR97) public returns (uint VAR118) {
VAR118=VAR120[VAR97];
if (VAR118==0){
FUN55(VAR97);
return VAR120[VAR97];
}
else
return VAR118;
}
function FUN55(uint VAR97) public {
if (FUN56(VAR97) != 0x0)
VAR120[VAR97] = uint(FUN56(VAR97));
if (VAR120[VAR97] != 0) {
uint VAR122 = VAR121[VAR97];
VAR121[VAR97] = 0;
msg.sender.FUN57(VAR122);
}
}
}
contract BlockHashRNGFallback is VAR123 {
function FUN55(uint VAR97) public {
if (VAR97<VAR81.VAR82 && VAR120[VAR97]==0) {
if (FUN56(VAR97)!=0x0)
VAR120[VAR97]=uint(FUN56(VAR97));
else
VAR120[VAR97]=uint(FUN56(VAR81.VAR82-1));
}
if (VAR120[VAR97] != 0) {
uint VAR122=VAR121[VAR97];
VAR121[VAR97]=0;
msg.sender.FUN57(VAR122);
}
}
}
contract VAR124{
Arbitrator public VAR125;
bytes public VAR126;
modifier VAR127 {require(msg.sender==address(VAR125)); VAR15;}
event FUN58(Arbitrator indexed VAR128, uint indexed VAR22, uint VAR129);
event FUN59(uint indexed VAR130, string VAR131);
event FUN60(Arbitrator indexed VAR128, uint indexed VAR22, uint VAR130);
event FUN61(Arbitrator indexed VAR128, uint indexed VAR22, address VAR132, string VAR131);
constructor(Arbitrator VAR128, bytes VAR133) public {
VAR125 = VAR128;
VAR126 = VAR133;
}
function FUN62(uint VAR22, uint VAR129) public VAR127 {
emit FUN58(FUN63(msg.sender),VAR22,VAR129);
FUN64(VAR22,VAR129);
}
function FUN64(uint VAR22, uint VAR129) internal;
}
contract VAR32{
enum VAR33 {VAR134, VAR135, VAR34}
modifier FUN65(bytes VAR87) {require(msg.value>=FUN66(VAR87)); VAR15;}
modifier FUN67(uint VAR22, bytes VAR87) {require(msg.value>=FUN68(VAR22, VAR87)); VAR15;}
event FUN69(uint VAR22);
event FUN70(uint indexed VAR22, Arbitrable VAR136);
event FUN71(uint indexed VAR22, Arbitrable VAR136);
function FUN72(uint VAR137, bytes VAR87) public FUN65(VAR87) payable returns(uint VAR6)  {}
function FUN66(bytes VAR87) public constant returns(uint VAR138);
function FUN73(uint VAR22, bytes VAR87) public FUN67(VAR22,VAR87) payable {
emit FUN71(VAR22, FUN74(msg.sender));
}
function FUN68(uint VAR22, bytes VAR87) public constant returns(uint VAR138);
function FUN11(uint VAR22) public constant returns(DisputeStatus VAR139);
function FUN14(uint VAR22) public constant returns(uint VAR140);
}
contract Kleros is VAR32, VAR48 {
Pinakion public VAR3;
uint public constant VAR141 = (2**256 - 2) / 2;
RNG public VAR142;
uint public VAR143 = 0.05 VAR144;
uint16 public VAR145 = 3;
uint public VAR146 = 0.1 * 1e18;
uint[5] public VAR147;
uint public VAR148 = 2000;
uint constant VAR149 = 1e4;
uint public VAR10 = 5;
address public VAR150;
uint public VAR151 = 1;
uint public VAR152;
uint public VAR153;
uint public VAR154;
uint public VAR120;
enum VAR155 {
VAR156,
VAR157,
VAR158,
VAR159,
VAR160
}
Period public VAR161;
struct VAR162 {
uint VAR5;
uint VAR163;
uint VAR164;
uint VAR165;
uint VAR166;
}
mapping (address => VAR162) public VAR167;
struct VAR158 {
address VAR168;
uint VAR140;
}
struct VAR169 {
uint VAR38;
uint VAR170;
mapping (uint => uint) VAR171;
}
enum VAR172 {
VAR173,
VAR174,
VAR175,
VAR176
}
struct VAR177 {
Arbitrable VAR178;
uint VAR151;
uint VAR35;
uint VAR36;
uint16 VAR179;
uint VAR143;
DisputeState VAR180;
VAR158[][] VAR181;
VAR169[] VAR182;
mapping (address => uint) VAR183;
uint VAR184;
VAR185[] VAR186;
}
enum VAR187 {
VAR188,
VAR189,
VAR190,
VAR191
}
struct VAR185 {
uint VAR42;
uint VAR43;
uint VAR192;
uint VAR193;
uint VAR194;
RepartitionStage VAR195;
}
VAR177[] public VAR196;
event FUN75(Period VAR197, uint indexed VAR198);
event FUN76(address indexed VAR14, uint VAR22, int VAR27);
event FUN77(address indexed VAR14, uint VAR22, uint VAR27);
modifier FUN1(address VAR14) {require(msg.sender == VAR14); VAR15;}
modifier FUN78(Period VAR197) {require(VAR161 == VAR197); VAR15;}
modifier onlyGovernor() {require(msg.sender == VAR150); VAR15;}
constructor(Pinakion VAR20, RNG VAR199, uint[5] VAR200, address VAR201) public {
VAR3 = VAR20;
VAR142 = VAR199;
VAR152 = VAR202;
VAR147 = VAR200;
VAR150 = VAR201;
}
function FUN4(address VAR26, uint VAR27, address, bytes) public FUN1(VAR3) {
require(VAR3.FUN5(VAR26, this, VAR27));
VAR167[VAR26].VAR5 += VAR27;
}
function FUN79(uint VAR101) public {
Juror storage VAR17 = VAR167[msg.sender];
require(VAR17.VAR163 <= VAR17.VAR5);
require(VAR101 <= VAR17.VAR5-VAR17.VAR163);
require(VAR17.VAR164 != VAR151);
VAR17.VAR5 -= VAR101;
require(VAR3.transfer(msg.sender,VAR101));
}
function FUN80() public {
require(VAR202-VAR152 >= VAR147[uint8(VAR161)]);
if (VAR161 == VAR155.VAR156) {
VAR154 = VAR81.VAR82 + 1;
VAR142.FUN51(VAR154);
VAR161 = VAR155.VAR157;
} else if (VAR161 == VAR155.VAR157) {
VAR120 = VAR142.FUN53(VAR154);
require(VAR120 != 0);
VAR161 = VAR155.VAR158;
} else if (VAR161 == VAR155.VAR158) {
VAR161 = VAR155.VAR159;
} else if (VAR161 == VAR155.VAR159) {
VAR161 = VAR155.VAR160;
} else if (VAR161 == VAR155.VAR160) {
VAR161 = VAR155.VAR156;
++VAR151;
VAR153 = 0;
VAR154 = 0;
VAR120 = 0;
}
VAR152 = VAR202;
FUN75(VAR161, VAR151);
}
function FUN81(uint VAR101) public FUN78(VAR155.VAR156) {
Juror storage VAR17 = VAR167[msg.sender];
require(VAR101 <= VAR17.VAR5);
require(VAR101 >= VAR146);
require(VAR17.VAR164 != VAR151);
VAR17.VAR164 = VAR151;
VAR17.VAR165 = VAR153;
VAR153 += VAR101;
VAR17.VAR166 = VAR153;
}
function FUN82(uint VAR22, uint VAR129, uint[] VAR203) public FUN78(VAR155.VAR158) {
Dispute storage VAR204 = VAR196[VAR22];
Juror storage VAR17 = VAR167[msg.sender];
VoteCounter storage VAR182 = VAR204.VAR182[VAR204.VAR35];
require(VAR204.VAR183[msg.sender] != VAR151);
require(VAR129 <= VAR204.VAR36);
require(FUN83(msg.sender, VAR22, VAR203));
VAR204.VAR183[msg.sender] = VAR151;
VAR182.VAR171[VAR129] += VAR203.VAR89;
if (VAR182.VAR170 < VAR182.VAR171[VAR129]) {
VAR182.VAR170 = VAR182.VAR171[VAR129];
VAR182.VAR38 = VAR129;
} else if (VAR182.VAR170==VAR182.VAR171[VAR129] && VAR203.VAR89!=0) {
VAR182.VAR38 = 0;
}
for (uint VAR205 = 0; VAR205 < VAR203.VAR89; ++VAR205) {
VAR204.VAR181[VAR204.VAR35].FUN84(FUN85({
VAR168: msg.sender,
VAR140: VAR129
}));
}
VAR17.VAR163 += VAR203.VAR89 * FUN15();
uint VAR206 = VAR203.VAR89 * VAR204.VAR143;
msg.sender.transfer(VAR206);
FUN77(msg.sender, VAR22, VAR206);
}
function FUN86(address VAR207, uint VAR22, uint[] VAR203) public {
Dispute storage VAR204 = VAR196[VAR22];
Juror storage VAR208 = VAR167[VAR207];
require(VAR161 > VAR155.VAR158);
require(VAR204.VAR183[VAR207] != VAR151);
VAR204.VAR183[VAR207] = VAR151;
require(FUN83(VAR207, VAR22, VAR203));
uint VAR209 = VAR203.VAR89 * VAR146 * 2 * VAR148 / VAR149;
VAR209 = (VAR209 < VAR208.VAR5) ? VAR209 : VAR208.VAR5;
VAR208.VAR5 -= VAR209;
FUN76(VAR207, VAR22, -int(VAR209));
VAR167[msg.sender].VAR5 += VAR209 / 2;
FUN76(msg.sender, VAR22, int(VAR209 / 2));
VAR167[VAR150].VAR5 += VAR209 / 2;
FUN76(VAR150, VAR22, int(VAR209 / 2));
msg.sender.transfer(VAR203.VAR89*VAR204.VAR143);
}
function FUN87(uint VAR22) public FUN78(VAR155.VAR160) {
Dispute storage VAR204 = VAR196[VAR22];
require(VAR204.VAR180 == VAR172.VAR173);
require(VAR204.VAR151+VAR204.VAR35 <= VAR151);
uint VAR38 = VAR204.VAR182[VAR204.VAR35].VAR38;
uint VAR37 = FUN15();
for (uint VAR205 = 0; VAR205 <= VAR204.VAR35; ++VAR205) {
if (VAR38!=0 || (VAR204.VAR182[VAR204.VAR35].VAR171[0] == VAR204.VAR182[VAR204.VAR35].VAR170)) {
uint VAR42 = 0;
uint VAR43 = 0;
for (uint VAR44 = 0; VAR44 < VAR204.VAR181[VAR205].VAR89; ++VAR44) {
Vote storage VAR210 = VAR204.VAR181[VAR205][VAR44];
if (VAR210.VAR140 != VAR38) {
Juror storage VAR17 = VAR167[VAR210.VAR168];
uint VAR211 = VAR37<VAR17.VAR5 ? VAR37 : VAR17.VAR5;
VAR17.VAR5 -= VAR211;
FUN76(VAR210.VAR168, VAR22, int(-VAR211));
VAR42 += VAR211;
} else {
++VAR43;
}
}
if (VAR43 == 0) {
VAR167[VAR150].VAR5 += VAR42;
FUN76(VAR150, VAR22, int(VAR42));
} else {
uint VAR47 = VAR42 / VAR43;
for (VAR44 = 0; VAR44 < VAR204.VAR181[VAR205].VAR89; ++VAR44) {
VAR210 = VAR204.VAR181[VAR205][VAR44];
if (VAR210.VAR140 == VAR38) {
VAR17 = VAR167[VAR210.VAR168];
VAR17.VAR5 += VAR47;
FUN76(VAR210.VAR168, VAR22, int(VAR47));
}
}
}
}
for (VAR44 = 0; VAR44 < VAR204.VAR181[VAR205].VAR89; ++VAR44) {
VAR210 = VAR204.VAR181[VAR205][VAR44];
VAR17 = VAR167[VAR210.VAR168];
VAR17.VAR163 -= VAR37;
}
}
VAR204.VAR180 = VAR172.VAR175;
}
function FUN88(uint VAR22, uint VAR212) public FUN78(VAR155.VAR160) {
Dispute storage VAR204 = VAR196[VAR22];
require(VAR204.VAR180 <= VAR172.VAR174);
require(VAR204.VAR151+VAR204.VAR35 <= VAR151);
VAR204.VAR180 = VAR172.VAR174;
uint VAR38 = VAR204.VAR182[VAR204.VAR35].VAR38;
uint VAR37 = FUN15();
uint VAR213 = 0;
for (uint VAR205 = VAR204.VAR184; VAR205 <= VAR204.VAR35; ++VAR205) {
if (VAR204.VAR186.VAR89 < VAR205+1) {
VAR204.VAR186.VAR89++;
}
if (VAR38==0 && (VAR204.VAR182[VAR204.VAR35].VAR171[0] != VAR204.VAR182[VAR204.VAR35].VAR170)) {
VAR204.VAR186[VAR205].VAR195 = VAR187.VAR190;
}
if (VAR204.VAR186[VAR205].VAR195 == VAR187.VAR188) {
for (uint VAR44 = VAR204.VAR186[VAR205].VAR192; VAR44 < VAR204.VAR181[VAR205].VAR89; ++VAR44) {
if (VAR213 >= VAR212) {
return;
}
Vote storage VAR210 = VAR204.VAR181[VAR205][VAR44];
if (VAR210.VAR140 != VAR38) {
Juror storage VAR17 = VAR167[VAR210.VAR168];
uint VAR211 = VAR37<VAR17.VAR5 ? VAR37 : VAR17.VAR5;
VAR17.VAR5 -= VAR211;
FUN76(VAR210.VAR168, VAR22, int(-VAR211));
VAR204.VAR186[VAR205].VAR42 += VAR211;
} else {
++VAR204.VAR186[VAR205].VAR43;
}
++VAR204.VAR186[VAR205].VAR192;
++VAR213;
}
VAR204.VAR186[VAR205].VAR195 = VAR187.VAR189;
}
if (VAR204.VAR186[VAR205].VAR195 == VAR187.VAR189) {
if (VAR204.VAR186[VAR205].VAR43 == 0) {
VAR167[VAR150].VAR5 += VAR204.VAR186[VAR205].VAR42;
FUN76(VAR150, VAR22, int(VAR204.VAR186[VAR205].VAR42));
VAR204.VAR186[VAR205].VAR195 = VAR187.VAR190;
} else {
uint VAR47 = VAR204.VAR186[VAR205].VAR42 / VAR204.VAR186[VAR205].VAR43;
for (VAR44 = VAR204.VAR186[VAR205].VAR193; VAR44 < VAR204.VAR181[VAR205].VAR89; ++VAR44) {
if (VAR213 >= VAR212) {
return;
}
VAR210 = VAR204.VAR181[VAR205][VAR44];
if (VAR210.VAR140 == VAR38) {
VAR17 = VAR167[VAR210.VAR168];
VAR17.VAR5 += VAR47;
FUN76(VAR210.VAR168, VAR22, int(VAR47));
}
++VAR213;
++VAR204.VAR186[VAR205].VAR193;
}
VAR204.VAR186[VAR205].VAR195 = VAR187.VAR190;
}
}
if (VAR204.VAR186[VAR205].VAR195 == VAR187.VAR190) {
for (VAR44 = VAR204.VAR186[VAR205].VAR194; VAR44 < VAR204.VAR181[VAR205].VAR89; ++VAR44) {
if (VAR213 >= VAR212) {
return;
}
VAR210 = VAR204.VAR181[VAR205][VAR44];
VAR17 = VAR167[VAR210.VAR168];
VAR17.VAR163 -= VAR37;
++VAR213;
++VAR204.VAR186[VAR205].VAR194;
}
VAR204.VAR186[VAR205].VAR195 = VAR187.VAR191;
}
if (VAR204.VAR186[VAR205].VAR195 == VAR187.VAR191) {
++VAR204.VAR184;
}
}
VAR204.VAR180 = VAR172.VAR175;
}
function FUN89(uint VAR22) public view returns (uint VAR214) {
Dispute storage VAR204 = VAR196[VAR22];
return (VAR204.VAR179 + 1) * 2**VAR204.VAR35 - 1;
}
function FUN83(address VAR207, uint VAR22, uint[] VAR203) public view returns (bool VAR215) {
uint VAR216 = 0;
Juror storage VAR17 = VAR167[VAR207];
Dispute storage VAR204 = VAR196[VAR22];
uint VAR214 = FUN89(VAR22);
if (VAR17.VAR164 != VAR151) return false;
if (VAR204.VAR151+VAR204.VAR35 != VAR151) return false;
if (VAR161 <= VAR155.VAR157) return false;
for (uint VAR205 = 0; VAR205 < VAR203.VAR89; ++VAR205) {
if (VAR203[VAR205] <= VAR216) return false;
VAR216 = VAR203[VAR205];
if (VAR216 > VAR214) return false;
uint VAR217 = uint(FUN54(VAR120, VAR22, VAR216)) % VAR153;
require(VAR217 >= VAR17.VAR165);
require(VAR217 < VAR17.VAR166);
}
return true;
}
function FUN72(uint VAR137, bytes VAR87) public payable returns (uint VAR6) {
uint16 VAR214 = FUN90(VAR87);
require(msg.value >= FUN66(VAR87));
VAR6 = VAR196.VAR89++;
Dispute storage VAR204 = VAR196[VAR6];
VAR204.VAR178 = FUN74(msg.sender);
if (VAR161 < VAR155.VAR157)
VAR204.VAR151 = VAR151;
else
VAR204.VAR151 = VAR151+1;
VAR204.VAR36 = VAR137;
VAR204.VAR179 = VAR214;
VAR204.VAR143 = VAR143;
VAR204.VAR181.VAR89++;
VAR204.VAR182.VAR89++;
FUN70(VAR6, FUN74(msg.sender));
return VAR6;
}
function FUN73(uint VAR22, bytes VAR87) public payable FUN78(VAR155.VAR159) {
super.FUN73(VAR22,VAR87);
Dispute storage VAR204 = VAR196[VAR22];
require(msg.value >= FUN68(VAR22, VAR87));
require(VAR204.VAR151+VAR204.VAR35 == VAR151);
require(VAR204.VAR178 == msg.sender);
VAR204.VAR35++;
VAR204.VAR181.VAR89++;
VAR204.VAR182.VAR89++;
}
function FUN64(uint VAR6) public {
Dispute storage VAR204 = VAR196[VAR6];
require(VAR204.VAR180 == VAR172.VAR175);
VAR204.VAR180 = VAR172.VAR176;
VAR204.VAR178.FUN62(VAR6, VAR204.VAR182[VAR204.VAR35].VAR38);
}
function FUN66(bytes VAR87) public view returns (uint VAR138) {
return FUN90(VAR87) * VAR143;
}
function FUN68(uint VAR22, bytes VAR87) public view returns (uint VAR138) {
Dispute storage VAR204 = VAR196[VAR22];
if(VAR204.VAR35 >= VAR10) return VAR141;
return (2*FUN89(VAR22) + 1) * VAR204.VAR143;
}
function FUN90(bytes VAR87) internal view returns (uint16 VAR214) {
if (VAR87.VAR89 < 2)
return VAR145;
else
return (uint16(VAR87[0]) << 8) + uint16(VAR87[1]);
}
function FUN15() public view returns (uint VAR218) {
return (VAR148 * VAR146) / VAR149;
}
function FUN19(uint VAR22, uint VAR219, uint VAR220) public view returns (address VAR168) {
return VAR196[VAR22].VAR181[VAR219][VAR220].VAR168;
}
function FUN18(uint VAR22, uint VAR219, uint VAR220) public view returns (uint VAR140) {
return VAR196[VAR22].VAR181[VAR219][VAR220].VAR140;
}
function FUN16(uint VAR22, uint VAR219) public view returns (uint VAR38) {
return VAR196[VAR22].VAR182[VAR219].VAR38;
}
function FUN91(uint VAR22, uint VAR219) public view returns (uint VAR170) {
return VAR196[VAR22].VAR182[VAR219].VAR170;
}
function FUN17(uint VAR22, uint VAR219, uint VAR221) public view returns (uint VAR171) {
return VAR196[VAR22].VAR182[VAR219].VAR171[VAR221];
}
function FUN92(uint VAR22, address VAR28) public view returns (uint VAR183) {
return VAR196[VAR22].VAR183[VAR28];
}
function FUN93(uint VAR22, address VAR28, uint VAR222) public view returns (bool VAR223) {
Dispute storage VAR204 = VAR196[VAR22];
Juror storage VAR17 = VAR167[VAR28];
if (VAR17.VAR164 != VAR151
|| (VAR204.VAR151+VAR204.VAR35 != VAR151)
|| VAR161<=VAR155.VAR157
|| VAR222>FUN89(VAR22)
|| VAR222==0
|| VAR153==0
) {
return false;
} else {
uint VAR217 = uint(FUN54(VAR120,VAR22,VAR222)) % VAR153;
return (VAR217 >= VAR17.VAR165) && (VAR217 < VAR17.VAR166);
}
}
function FUN14(uint VAR22) public view returns (uint VAR140) {
Dispute storage VAR204 = VAR196[VAR22];
return VAR204.VAR182[VAR204.VAR35].VAR38;
}
function FUN11(uint VAR22) public view returns (DisputeStatus VAR139) {
Dispute storage VAR204 = VAR196[VAR22];
if (VAR204.VAR151+VAR204.VAR35 < VAR151)
return VAR33.VAR34;
else if(VAR204.VAR151+VAR204.VAR35 == VAR151) {
if (VAR204.VAR180 == VAR172.VAR173) {
if (VAR161 < VAR155.VAR159)
return VAR33.VAR134;
else if (VAR161 == VAR155.VAR159)
return VAR33.VAR135;
else return VAR33.VAR34;
} else return VAR33.VAR34;
} else return VAR33.VAR134;
}
function FUN94(bytes32 VAR51, uint VAR101, address VAR224) public onlyGovernor {
VAR224.call.value(VAR101)(VAR51);
}
function FUN95(RNG VAR199) public onlyGovernor {
VAR142 = VAR199;
}
function FUN96(uint VAR225) public onlyGovernor {
VAR143 = VAR225;
}
function FUN97(uint16 VAR226) public onlyGovernor {
VAR145 = VAR226;
}
function FUN98(uint VAR227) public onlyGovernor {
VAR146 = VAR227;
}
function FUN99(uint[5] VAR200) public onlyGovernor {
VAR147 = VAR200;
}
function FUN100(uint VAR228) public onlyGovernor {
VAR148 = VAR228;
}
function FUN101(uint VAR25) public onlyGovernor {
VAR10 = VAR25;
}
function FUN102(address VAR201) public onlyGovernor {
VAR150 = VAR201;
}
}
1
---------------------------------
195 0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN1(address VAR7)
public
{
VAR6 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value > VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
public
payable
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
196 0xbc8645af8aed2dd77c04639d2f338f4e09b6adca.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
assert((VAR5 = VAR3 - VAR4) <= VAR3);
}
function FUN2(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
assert((VAR5 = VAR3 + VAR4) >= VAR3);
}
function FUN3(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
VAR5 = VAR3 / VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) constant internal returns (uint256 VAR5) {
VAR5 = VAR3 <= VAR4 ? VAR3 : VAR4;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR10);
function FUN6() {
VAR7 = msg.sender;
}
modifier onlyOwner {
assert (msg.sender == VAR7);
VAR11;
}
function FUN7(address VAR12) onlyOwner {
VAR8 = VAR12;
}
function FUN8() {
if (msg.sender == VAR8) {
FUN5(VAR7, VAR8);
VAR7 = VAR8;
}
}
}
contract VAR13 {
function FUN9() constant returns (uint VAR14);
function FUN10(address VAR15) constant returns (uint);
function FUN11(address VAR7, address VAR16) constant returns (uint);
function transfer(address VAR17, uint value) returns (bool VAR18);
function FUN12(address VAR19, address VAR17, uint value) returns (bool VAR18);
function FUN13(address VAR16, uint value) returns (bool VAR18);
event Transfer(address indexed VAR19, address indexed VAR17, uint value);
event FUN14(address indexed VAR7, address indexed VAR16, uint value);
}
contract StandardToken is VAR13, VAR2 {
uint256                                            VAR20;
mapping (address => uint256)                       VAR21;
mapping (address => mapping (address => uint256))  VAR22;
modifier FUN15(uint VAR23) {
assert(msg.VAR24.VAR25 == VAR23 * 32 + 4);
VAR11;
}
function FUN9() constant returns (uint256) {
return VAR20;
}
function FUN10(address VAR26) constant returns (uint256) {
return VAR21[VAR26];
}
function FUN11(address VAR27, address VAR28) constant returns (uint256) {
return VAR22[VAR27][VAR28];
}
function transfer(address VAR10, uint VAR29) FUN15(2) returns (bool VAR30) {
assert(VAR21[msg.sender] >= VAR29);
VAR21[msg.sender] = FUN1(VAR21[msg.sender], VAR29);
VAR21[VAR10] = FUN2(VAR21[VAR10], VAR29);
Transfer(msg.sender, VAR10, VAR29);
return true;
}
function FUN12(address VAR9, address VAR10, uint VAR29) FUN15(3) returns (bool VAR30) {
assert(VAR21[VAR9] >= VAR29);
assert(VAR22[VAR9][msg.sender] >= VAR29);
VAR22[VAR9][msg.sender] = FUN1(VAR22[VAR9][msg.sender], VAR29);
VAR21[VAR9] = FUN1(VAR21[VAR9], VAR29);
VAR21[VAR10] = FUN2(VAR21[VAR10], VAR29);
Transfer(VAR9, VAR10, VAR29);
return true;
}
function FUN13(address VAR28, uint256 VAR29) FUN15(2) returns (bool VAR30) {
VAR22[msg.sender][VAR28] = VAR29;
FUN14(msg.sender, VAR28, VAR29);
return true;
}
}
contract HUNT is VAR31, VAR6 {
string public constant VAR32 = "";
string public constant VAR33 = "";
uint8 public constant VAR34 = 18;
uint256 public VAR35;
uint256 public VAR36;
uint256 public VAR37;
uint public VAR38;
address VAR39;
uint256 public VAR40;
uint256 public VAR41;
mapping (address => uint256) VAR42;
event FUN16(address indexed VAR43, uint256 VAR44,uint256 VAR45, uint256 VAR46, uint VAR47);
event FUN17(address indexed VAR39,uint256 VAR48);
function FUN18(uint256 VAR49, uint256 VAR50, uint256 VAR51, uint VAR52, address VAR53) {
VAR36	= VAR49;
VAR37		= VAR50;
VAR35   = VAR51;
VAR39  	= VAR53;
VAR38		= VAR52;
}
function FUN19() internal constant returns (uint) {
return VAR54.VAR55;
}
function FUN20() constant returns (uint256) {
return FUN21(FUN19());
}
function FUN21(uint256 VAR56) constant returns (uint256) {
if (VAR56 < VAR36) {
return 0;
} else if (VAR56 < (VAR36 + 2 VAR57)) {
return FUN3(VAR38,100);
} else if (VAR56 < (VAR36 + 5 VAR57)) {
return FUN3(VAR38,120);
} else if (VAR56 < (VAR36 + 10 VAR57)) {
return FUN3(VAR38,130);
} else if (VAR56 < (VAR36 + 15 VAR57)) {
return FUN3(VAR38,140);
} else if (VAR56 <= VAR37) {
return FUN3(VAR38,150);
} else {
return 0;
}
}
function () payable {
FUN22(msg.sender);
}
function FUN22(address VAR58) payable {
require(FUN19() >= VAR36);
require(FUN19() <= VAR37);
require(msg.value > 0);
VAR41 = FUN2(VAR41, msg.value);
uint256 VAR47 = FUN20();
uint VAR46 = msg.value * VAR47;
require(VAR46 > 0);
if ((FUN19() >= (VAR36 + 15 VAR57)) && (FUN19() <= VAR37)){
uint VAR59=FUN1(VAR35,FUN2(VAR40, VAR46));
VAR59 = (VAR59>0)? VAR59:0;
uint VAR60 = FUN4(VAR42[VAR58],FUN4(VAR46,VAR59));
require(VAR60 >= 0);
VAR46 = FUN2(VAR46,VAR60);
}
VAR40 = FUN2(VAR40, VAR46);
require(VAR40 <= VAR35);
uint VAR61 = FUN3(VAR46,50)*19;
VAR20 = FUN2(VAR20, VAR46);
VAR20 = FUN2(VAR20, VAR61);
VAR21[VAR58] = FUN2(VAR21[VAR58], VAR46);
VAR21[VAR7] = FUN2(VAR21[VAR7], VAR61);
if (FUN19() < (VAR36 + 2 VAR57)){
uint VAR62 = FUN3(VAR46,2);
VAR42[VAR58] = FUN2(VAR42[VAR58], VAR62);
}
FUN16(VAR58, msg.value, VAR41, VAR46, VAR47);
Transfer(0x0, VAR58, VAR46);
Transfer(0x0, VAR7, VAR61);
}
function transfer(address VAR10, uint VAR63) returns (bool VAR30) {
require((FUN19() > VAR37 + 7 VAR57 ));
return super.transfer(VAR10, VAR63);
}
function FUN12(address VAR9, address VAR10, uint VAR63) returns (bool VAR30) {
require((FUN19() > VAR37 + 7 VAR57 ));
return super.FUN12(VAR9, VAR10, VAR63);
}
function FUN23(uint256 VAR63) onlyOwner {
require((FUN19() > VAR37 + 7 VAR57 ));
require(VAR63 > 0);
VAR21[VAR7] = FUN2(VAR21[VAR7], VAR63);
VAR20 = FUN2(VAR20, VAR63);
Transfer(0x0, VAR7, VAR63);
}
function FUN24(uint256 VAR63) onlyOwner {
require((FUN19() > VAR37 + 7 VAR57 ));
require(VAR63 > 0);
VAR21[VAR7] = FUN1(VAR21[VAR7],VAR63);
VAR20 = FUN1(VAR20,VAR63);
Transfer(VAR7, 0x0 , VAR63);
}
function FUN25(uint8 VAR52) onlyOwner {
require(VAR52 > 0);
VAR38 = VAR52;
}
function FUN26() onlyOwner {
require(VAR39.call.value(this.VAR64)(0));
FUN17(VAR39,this.VAR64);
}
}
1
---------------------------------
197 0xbd29d25141764346bae6dc2dc5dddfba37a600d2.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
pragma VAR1 ^0.4.11;
contract VAR6 {
address public VAR7;
function FUN5(uint VAR8, string VAR9, string VAR10) payable returns (bytes32 VAR11);
function FUN6(uint VAR8, string VAR9, string VAR10, uint VAR12) payable returns (bytes32 VAR11);
function FUN7(uint VAR8, string VAR9, string VAR13, string VAR14) payable returns (bytes32 VAR11);
function FUN8(uint VAR8, string VAR9, string VAR13, string VAR14, uint VAR12) payable returns (bytes32 VAR11);
function FUN9(uint VAR8, string VAR9, bytes VAR15) payable returns (bytes32 VAR11);
function FUN10(uint VAR8, string VAR9, bytes VAR15, uint VAR12) payable returns (bytes32 VAR11);
function FUN11(string VAR9) returns (uint VAR16);
function FUN11(string VAR9, uint VAR17) returns (uint VAR16);
function FUN12(string VAR18);
function FUN13(byte VAR19);
function FUN14(bytes32 VAR20);
function FUN15(uint VAR21);
function FUN16() returns(bytes32);
}
contract VAR22 {
function FUN17() returns (address VAR23);
}
contract VAR24 {
uint constant VAR25 = 60*60*24;
uint constant VAR26 = 60*60*24*7;
uint constant VAR27 = 60*60*24*30;
byte constant VAR28 = 0x00;
byte constant VAR29 = 0x10;
byte constant VAR30 = 0x20;
byte constant VAR31 = 0x30;
byte constant VAR32 = 0xF0;
byte constant VAR33 = 0x01;
uint8 constant VAR34 = 0;
uint8 constant VAR35 = 1;
uint8 constant VAR36 = 2;
uint8 constant VAR37 = 2;
uint8 constant VAR38 = 161;
OraclizeAddrResolverI VAR39;
OraclizeI VAR40;
modifier VAR41 {
if((address(VAR39)==0)||(FUN18(address(VAR39))==0)) FUN19(VAR34);
VAR40 = FUN20(VAR39.FUN17());
VAR42;
}
modifier FUN21(string VAR43){
VAR40 = FUN20(VAR39.FUN17());
VAR40.FUN12(VAR43);
VAR42;
}
function FUN19(uint8 VAR44) internal returns(bool){
if (FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR39 = FUN22(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN23("");
return true;
}
if (FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR39 = FUN22(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN23("");
return true;
}
if (FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR39 = FUN22(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN23("");
return true;
}
if (FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR39 = FUN22(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN23("");
return true;
}
if (FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR39 = FUN22(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR39 = FUN22(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR39 = FUN22(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN24(bytes32 VAR45, string VAR46) {
FUN24(VAR45, VAR46, VAR47 bytes(0));
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) {
}
function FUN25(string VAR43) oraclizeAPI internal {
VAR40.FUN12(VAR43);
}
function FUN26(string VAR49) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49);
}
function FUN26(string VAR49, uint VAR17) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49, VAR17);
}
function FUN27(string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(0, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(VAR57, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(VAR57, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(0, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(0, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(VAR57, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(VAR57, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(0, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN30() oraclizeAPI internal returns (address){
return VAR40.FUN31();
}
function FUN32(byte VAR68) oraclizeAPI internal {
return VAR40.FUN13(VAR68);
}
function FUN33(uint VAR69) oraclizeAPI internal {
return VAR40.FUN15(VAR69);
}
function FUN34(bytes32 VAR70) oraclizeAPI internal {
return VAR40.FUN14(VAR70);
}
function FUN35() oraclizeAPI internal returns (bytes32){
return VAR40.FUN16();
}
function FUN18(address VAR23) constant internal returns(uint VAR71) {
VAR72 {
VAR71 := FUN36(VAR23)
}
}
function FUN37(string VAR73) internal returns (address){
bytes memory VAR74 = bytes(VAR73);
uint160 VAR75 = 0;
uint160 VAR76;
uint160 VAR77;
for (uint VAR78=2; VAR78<2+2*20; VAR78+=2){
VAR75 *= 256;
VAR76 = FUN38(VAR74[VAR78]);
VAR77 = FUN38(VAR74[VAR78+1]);
if ((VAR76 >= 97)&&(VAR76 <= 102)) VAR76 -= 87;
else if ((VAR76 >= 65)&&(VAR76 <= 70)) VAR76 -= 55;
else if ((VAR76 >= 48)&&(VAR76 <= 57)) VAR76 -= 48;
if ((VAR77 >= 97)&&(VAR77 <= 102)) VAR77 -= 87;
else if ((VAR77 >= 65)&&(VAR77 <= 70)) VAR77 -= 55;
else if ((VAR77 >= 48)&&(VAR77 <= 57)) VAR77 -= 48;
VAR75 += (VAR76*16+VAR77);
}
return address(VAR75);
}
function FUN39(string VAR73, string VAR79) internal returns (int) {
bytes memory VAR3 = bytes(VAR73);
bytes memory VAR4 = bytes(VAR79);
uint VAR80 = VAR3.VAR81;
if (VAR4.VAR81 < VAR80) VAR80 = VAR4.VAR81;
for (uint VAR78 = 0; VAR78 < VAR80; VAR78 ++)
if (VAR3[VAR78] < VAR4[VAR78])
return -1;
else if (VAR3[VAR78] > VAR4[VAR78])
return 1;
if (VAR3.VAR81 < VAR4.VAR81)
return -1;
else if (VAR3.VAR81 > VAR4.VAR81)
return 1;
else
return 0;
}
function FUN40(string VAR82, string VAR83) internal returns (int) {
bytes memory VAR84 = bytes(VAR82);
bytes memory VAR85 = bytes(VAR83);
if(VAR84.VAR81 < 1 || VAR85.VAR81 < 1 || (VAR85.VAR81 > VAR84.VAR81))
return -1;
else if(VAR84.VAR81 > (2**128 -1))
return -1;
else
{
uint VAR86 = 0;
for (uint VAR78 = 0; VAR78 < VAR84.VAR81; VAR78 ++)
{
if (VAR84[VAR78] == VAR85[0])
{
VAR86 = 1;
while(VAR86 < VAR85.VAR81 && (VAR78 + VAR86) < VAR84.VAR81 && VAR84[VAR78 + VAR86] == VAR85[VAR86])
{
VAR86++;
}
if(VAR86 == VAR85.VAR81)
return int(VAR78);
}
}
return -1;
}
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88, string VAR89) internal returns (string) {
bytes memory VAR90 = bytes(VAR73);
bytes memory VAR91 = bytes(VAR79);
bytes memory VAR92 = bytes(VAR87);
bytes memory VAR93 = bytes(VAR88);
bytes memory VAR94 = bytes(VAR89);
string memory VAR95 = VAR47 string(VAR90.VAR81 + VAR91.VAR81 + VAR92.VAR81 + VAR93.VAR81 + VAR94.VAR81);
bytes memory VAR96 = bytes(VAR95);
uint VAR97 = 0;
for (uint VAR78 = 0; VAR78 < VAR90.VAR81; VAR78++) VAR96[VAR97++] = VAR90[VAR78];
for (VAR78 = 0; VAR78 < VAR91.VAR81; VAR78++) VAR96[VAR97++] = VAR91[VAR78];
for (VAR78 = 0; VAR78 < VAR92.VAR81; VAR78++) VAR96[VAR97++] = VAR92[VAR78];
for (VAR78 = 0; VAR78 < VAR93.VAR81; VAR78++) VAR96[VAR97++] = VAR93[VAR78];
for (VAR78 = 0; VAR78 < VAR94.VAR81; VAR78++) VAR96[VAR97++] = VAR94[VAR78];
return string(VAR96);
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, VAR88, "");
}
function FUN41(string VAR73, string VAR79, string VAR87) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, "", "");
}
function FUN41(string VAR73, string VAR79) internal returns (string) {
return FUN41(VAR73, VAR79, "", "", "");
}
function FUN42(string VAR73) internal returns (uint) {
return FUN42(VAR73, 0);
}
function FUN42(string VAR73, uint VAR79) internal returns (uint) {
bytes memory VAR98 = bytes(VAR73);
uint VAR99 = 0;
bool VAR100 = false;
for (uint VAR78=0; VAR78<VAR98.VAR81; VAR78++){
if ((VAR98[VAR78] >= 48)&&(VAR98[VAR78] <= 57)){
if (VAR100){
if (VAR79 == 0) break;
else VAR79--;
}
VAR99 *= 10;
VAR99 += uint(VAR98[VAR78]) - 48;
} else if (VAR98[VAR78] == 46) VAR100 = true;
}
if (VAR79 > 0) VAR99 *= 10**VAR79;
return VAR99;
}
function FUN43(uint VAR78) internal returns (string){
if (VAR78 == 0) return "";
uint VAR101 = VAR78;
uint VAR102;
while (VAR101 != 0){
VAR102++;
VAR101 /= 10;
}
bytes memory VAR103 = VAR47 bytes(VAR102);
uint VAR97 = VAR102 - 1;
while (VAR78 != 0){
VAR103[VAR97--] = FUN44(48 + VAR78 % 10);
VAR78 /= 10;
}
return string(VAR103);
}
function FUN28(string[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
function FUN29(bytes[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
string VAR114;
function FUN23(string VAR115) internal {
VAR114 = VAR115;
}
function FUN45() internal returns (string) {
return VAR114;
}
function FUN46(uint VAR116, uint VAR117, uint VAR118) internal returns (bytes32){
if ((VAR117 == 0)||(VAR117 > 32)) throw;
bytes memory VAR119 = VAR47 bytes(1);
VAR119[0] = FUN44(VAR117);
bytes memory VAR120 = VAR47 bytes(32);
bytes memory VAR121 = VAR47 bytes(32);
bytes32 VAR122 = FUN35();
VAR72 {
FUN47(VAR120, 0x20)
FUN47(FUN4(VAR120, 0x20), FUN48(FUN49(FUN3(VAR123, 1)), FUN48(VAR124, VAR57)))
FUN47(VAR121, 0x20)
FUN47(FUN4(VAR121, 0x20), VAR122)
}
bytes[3] memory VAR64 = [VAR120, VAR119, VAR121];
bytes32 VAR125 = FUN27(VAR116, "", VAR64, VAR118);
FUN50(VAR125, FUN51(FUN52(VAR116), VAR64[1], FUN53(VAR64[0]), VAR64[2]));
return VAR125;
}
function FUN50(bytes32 VAR125, bytes32 VAR126) internal {
VAR127[VAR125] = VAR126;
}
mapping(bytes32=>bytes32) VAR127;
mapping(bytes32=>bool) VAR128;
function FUN54(bytes32 VAR129, bytes VAR130, bytes VAR131) internal returns (bool){
bool VAR132;
address VAR133;
bytes32 VAR134;
bytes32 VAR135;
bytes memory VAR136 = VAR47 bytes(32);
uint VAR137 = 4+(uint(VAR130[3]) - 0x20);
VAR136 = FUN55(VAR130, VAR137, 32, VAR136, 0);
bytes memory VAR138 = VAR47 bytes(32);
VAR137 += 32 + 2;
VAR138 = FUN55(VAR130, VAR137+(uint(VAR130[VAR137-1]) - 0x20), 32, VAR138, 0);
VAR72 {
VAR134 := FUN56(FUN4(VAR136, 32))
VAR135 := FUN56(FUN4(VAR138, 32))
}
(VAR132, VAR133) = FUN57(VAR129, 27, VAR134, VAR135);
if (address(FUN51(VAR131)) == VAR133) return true;
else {
(VAR132, VAR133) = FUN57(VAR129, 28, VAR134, VAR135);
return (address(FUN51(VAR131)) == VAR133);
}
}
function FUN58(bytes VAR48, uint VAR139) internal returns (bool) {
bool VAR132;
bytes memory VAR140 = VAR47 bytes(uint(VAR48[VAR139+1])+2);
FUN55(VAR48, VAR139, VAR140.VAR81, VAR140, 0);
bytes memory VAR141 = VAR47 bytes(64);
FUN55(VAR48, 3+1, 64, VAR141, 0);
bytes memory VAR142 = VAR47 bytes(1+65+32);
VAR142[0] = 1;
FUN55(VAR48, VAR139-65, 65, VAR142, 1);
bytes memory VAR143 = VAR144"";
FUN55(VAR143, 0, 32, VAR142, 1+65);
VAR132 = FUN54(FUN53(VAR142), VAR140, VAR141);
if (VAR132 == false) return false;
bytes memory VAR145 = VAR144"";
bytes memory VAR146 = VAR47 bytes(1+65);
VAR146[0] = 0xFE;
FUN55(VAR48, 3, 65, VAR146, 1);
bytes memory VAR147 = VAR47 bytes(uint(VAR48[3+65+1])+2);
FUN55(VAR48, 3+65, VAR147.VAR81, VAR147, 0);
VAR132 = FUN54(FUN53(VAR146), VAR147, VAR145);
return VAR132;
}
modifier FUN59(bytes32 VAR148, string VAR149, bytes VAR150) {
if ((VAR150[0] != "")||(VAR150[1] != "")||(VAR150[2] != 1)) throw;
bool VAR151 = FUN60(VAR150, VAR148, bytes(VAR149), FUN45());
if (VAR151 == false) throw;
VAR42;
}
function FUN61(bytes32 VAR152, bytes VAR153) internal returns (bool){
bool VAR154 = true;
for (var VAR78=0; VAR78<VAR153.VAR81; VAR78++){
if (VAR152[VAR78] != VAR153[VAR78]) VAR154 = false;
}
return VAR154;
}
function FUN60(bytes VAR48, bytes32 VAR125, bytes VAR46, string VAR155) internal returns (bool){
bool VAR156;
uint VAR157 = 3+65+(uint(VAR48[3+65+1])+2)+32;
bytes memory VAR158 = VAR47 bytes(32);
FUN55(VAR48, VAR157, 32, VAR158, 0);
VAR156 = (FUN51(VAR158) == FUN51(FUN53(VAR155, VAR125)));
if (VAR156 == false) return false;
bytes memory VAR159 = VAR47 bytes(uint(VAR48[VAR157+(32+8+1+32)+1])+2);
FUN55(VAR48, VAR157+(32+8+1+32), VAR159.VAR81, VAR159, 0);
VAR156 = FUN61(FUN53(VAR159), VAR46);
if (VAR156 == false) return false;
bytes memory VAR160 = VAR47 bytes(8+1+32);
FUN55(VAR48, VAR157+32, 8+1+32, VAR160, 0);
bytes memory VAR161 = VAR47 bytes(64);
uint VAR139 = VAR157+32+(8+1+32)+VAR159.VAR81+65;
FUN55(VAR48, VAR139-64, 64, VAR161, 0);
bytes32 VAR162 = FUN53(VAR161);
if (VAR127[VAR125] == FUN51(VAR160, VAR162)){
delete VAR127[VAR125];
} else return false;
bytes memory VAR163 = VAR47 bytes(32+8+1+32);
FUN55(VAR48, VAR157, 32+8+1+32, VAR163, 0);
VAR156 = FUN54(FUN53(VAR163), VAR159, VAR161);
if (VAR156 == false) return false;
if (VAR128[VAR162] == false){
VAR128[VAR162] = FUN58(VAR48, VAR139);
}
return VAR128[VAR162];
}
function FUN55(bytes VAR164, uint VAR165, uint VAR81, bytes VAR166, uint VAR167) internal returns (bytes) {
uint VAR80 = VAR81 + VAR167;
if (VAR166.VAR81 < VAR80) {
throw;
}
uint VAR78 = 32 + VAR165;
uint VAR101 = 32 + VAR167;
while (VAR78 < (32 + VAR165 + VAR81)) {
VAR72 {
let VAR74 := FUN56(FUN4(VAR164, VAR78))
FUN47(FUN4(VAR166, VAR101), VAR74)
}
VAR78 += 32;
VAR101 += 32;
}
return VAR166;
}
function FUN57(bytes32 VAR168, uint8 VAR169, bytes32 VAR170, bytes32 VAR171) internal returns (bool, address) {
bool VAR172;
address VAR173;
VAR72 {
let VAR174 := FUN56(0x40)
FUN47(VAR174, VAR168)
FUN47(FUN4(VAR174, 32), VAR169)
FUN47(FUN4(VAR174, 64), VAR170)
FUN47(FUN4(VAR174, 96), VAR171)
VAR172 := call(3000, 1, 0, VAR174, 128, VAR174, 32)
VAR173 := FUN56(VAR174)
}
return (VAR172, VAR173);
}
function FUN62(bytes32 VAR168, bytes VAR175) internal returns (bool, address) {
bytes32 VAR170;
bytes32 VAR171;
uint8 VAR169;
if (VAR175.VAR81 != 65)
return (false, 0);
VAR72 {
VAR170 := FUN56(FUN4(VAR175, 32))
VAR171 := FUN56(FUN4(VAR175, 64))
VAR169 := FUN44(0, FUN56(FUN4(VAR175, 96)))
}
//
if (VAR169 < 27)
VAR169 += 27;
if (VAR169 != 27 && VAR169 != 28)
return (false, 0);
return FUN57(VAR168, VAR169, VAR170, VAR171);
}
}
contract VAR176 {
function FUN63() external;
function FUN64() external payable;
}
contract Betting is VAR24 {
using SafeMath for uint256;
uint VAR177=3;
address public VAR178;
uint public VAR179;
string public constant VAR180 = "";
BettingControllerInterface internal VAR181;
struct VAR182 {
bool  VAR183;
bool  VAR184;
bool  VAR185;
bool  VAR186;
uint32  VAR187;
uint32  VAR188;
uint32  VAR189;
uint32 VAR190;
}
struct VAR191{
int32  VAR192;
int32  VAR193;
int32  VAR194;
bytes32 VAR195;
bytes32 VAR196;
bytes32 VAR197;
uint VAR198;
}
struct VAR199{
bytes32 VAR200;
uint VAR201;
}
struct VAR202{
uint256 VAR203;
uint256 VAR204;
uint160 VAR205;
uint32 VAR206;
bool VAR207;
}
struct VAR208 {
uint160 VAR209;
bool VAR210;
mapping(bytes32=>uint) VAR211;
}
mapping (bytes32 => bytes32) VAR212;
mapping (bytes32 => VAR202) VAR213;
mapping (address => VAR208) VAR214;
uint public VAR215;
uint32 VAR216;
mapping (bytes32 => bool) public VAR217;
event FUN65(string VAR218);
event FUN66(uint VAR52);
event FUN67(address VAR219, uint256 VAR220, bytes32 VAR221, uint256 VAR222);
event FUN68(address VAR223, uint256 VAR220);
function FUN69() public payable {
FUN32(VAR29 | VAR33);
VAR178 = msg.sender;
VAR224.VAR195 = bytes32("");
VAR224.VAR196 = bytes32("");
VAR224.VAR197 = bytes32("");
VAR224.VAR198 = 300000;
VAR181 = FUN70(VAR178);
}
horses_info public VAR224;
chronus_info public VAR225;
modifier onlyOwner {
require(VAR178 == msg.sender);
VAR42;
}
modifier VAR226 {
require(VAR225.VAR183);
VAR42;
}
modifier VAR227 {
require(!VAR225.VAR183 && !VAR225.VAR184);
VAR42;
}
modifier VAR228 {
require(VAR225.VAR185);
VAR42;
}
function FUN71(address VAR229) onlyOwner external {
VAR178 = VAR229;
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) public {
require (msg.sender == FUN30());
bytes32 VAR230;
if (!VAR225.VAR184 || VAR225.VAR183) {
VAR225.VAR184 = true;
VAR225.VAR183 = false;
VAR181.FUN63();
}
VAR230 = VAR212[VAR45];
if (!VAR213[VAR230].VAR207) {
VAR213[VAR230].VAR203 = FUN72(VAR46);
VAR213[VAR230].VAR207 = true;
emit FUN66(VAR213[VAR230].VAR203);
} else if (VAR213[VAR230].VAR207){
VAR213[VAR230].VAR204 = FUN72(VAR46);
emit FUN66(VAR213[VAR230].VAR204);
VAR177 = VAR177 - 1;
if (VAR177 == 0) {
FUN73();
}
}
}
function FUN74(bytes32 VAR200) external duringBetting payable  {
require(msg.value >= 0.01 VAR53);
if (VAR214[msg.sender].VAR209==0) {
VAR216+=1;
}
uint VAR231 = VAR214[msg.sender].VAR211[VAR200] + msg.value;
VAR214[msg.sender].VAR211[VAR200] = VAR231;
VAR214[msg.sender].VAR209 += FUN38(msg.value);
uint160 VAR232 = VAR213[VAR200].VAR205 + FUN38(msg.value);
uint32 VAR233 = VAR213[VAR200].VAR206 + 1;
VAR213[VAR200].VAR205 = VAR232;
VAR213[VAR200].VAR206 = VAR233;
emit FUN67(msg.sender, msg.value, VAR200, VAR234);
}
function () private payable {}
function FUN75(uint VAR235, uint  VAR236) onlyOwner beforeBetting public payable returns(bool) {
if (FUN26("")*3 + FUN26("", VAR224.VAR198)*3  > address(this).VAR237) {
emit FUN65("");
return false;
} else {
VAR225.VAR187 = FUN76(VAR238.VAR57);
VAR225.VAR183 = true;
bytes32 VAR239;
emit FUN65("");
VAR235 = VAR235.FUN4(60);
VAR225.VAR188 = FUN76(VAR235);
VAR239 = FUN27(VAR235, "", "FUN77(VAR240:
VAR212[VAR239] = VAR224.VAR196;
VAR239 = FUN27(VAR235, "", "FUN77(VAR240:
VAR212[VAR239] = VAR224.VAR197;
VAR239 = FUN27(VAR235, "", "FUN77(VAR240:
VAR212[VAR239] = VAR224.VAR195;
VAR235 = VAR235.FUN4(VAR236);
VAR239 = FUN27(VAR235, "", "FUN77(VAR240:
VAR212[VAR239] = VAR224.VAR196;
VAR239 = FUN27(VAR235, "", "FUN77(VAR240:
VAR212[VAR239] = VAR224.VAR197;
VAR239 = FUN27(VAR235, "", "FUN77(VAR240:
VAR212[VAR239] = VAR224.VAR195;
VAR225.VAR189 = FUN76(VAR235);
return true;
}
}
function FUN73() internal {
VAR224.VAR192 = FUN78(VAR213[VAR224.VAR195].VAR204 - VAR213[VAR224.VAR195].VAR203)*100000/FUN78(VAR213[VAR224.VAR195].VAR203);
VAR224.VAR193 = FUN78(VAR213[VAR224.VAR196].VAR204 - VAR213[VAR224.VAR196].VAR203)*100000/FUN78(VAR213[VAR224.VAR196].VAR203);
VAR224.VAR194 = FUN78(VAR213[VAR224.VAR197].VAR204 - VAR213[VAR224.VAR197].VAR203)*100000/FUN78(VAR213[VAR224.VAR197].VAR203);
VAR215 = (VAR213[VAR224.VAR195].VAR205) + (VAR213[VAR224.VAR196].VAR205) + (VAR213[VAR224.VAR197].VAR205);
if (VAR216 <= 1) {
VAR225.VAR186=true;
VAR225.VAR185 = true;
VAR225.VAR190=FUN76(VAR234);
} else {
uint VAR241 = VAR215.FUN1(5).FUN2(100);
require(VAR241 < address(this).VAR237);
VAR215 = VAR215.FUN3(VAR241);
VAR181.VAR242.value(VAR241)();
}
if (VAR224.VAR192 > VAR224.VAR193) {
if (VAR224.VAR192 > VAR224.VAR194) {
VAR217[VAR224.VAR195] = true;
VAR179 = VAR213[VAR224.VAR195].VAR205;
}
else if(VAR224.VAR194 > VAR224.VAR192) {
VAR217[VAR224.VAR197] = true;
VAR179 = VAR213[VAR224.VAR197].VAR205;
} else {
VAR217[VAR224.VAR195] = true;
VAR217[VAR224.VAR197] = true;
VAR179 = VAR213[VAR224.VAR195].VAR205 + (VAR213[VAR224.VAR197].VAR205);
}
} else if(VAR224.VAR193 > VAR224.VAR192) {
if (VAR224.VAR193 > VAR224.VAR194) {
VAR217[VAR224.VAR196] = true;
VAR179 = VAR213[VAR224.VAR196].VAR205;
}
else if (VAR224.VAR194 > VAR224.VAR193) {
VAR217[VAR224.VAR197] = true;
VAR179 = VAR213[VAR224.VAR197].VAR205;
} else {
VAR217[VAR224.VAR196] = true;
VAR217[VAR224.VAR197] = true;
VAR179 = VAR213[VAR224.VAR196].VAR205 + (VAR213[VAR224.VAR197].VAR205);
}
} else {
if (VAR224.VAR194 > VAR224.VAR193) {
VAR217[VAR224.VAR197] = true;
VAR179 = VAR213[VAR224.VAR197].VAR205;
} else if(VAR224.VAR194 < VAR224.VAR193){
VAR217[VAR224.VAR196] = true;
VAR217[VAR224.VAR195] = true;
VAR179 = VAR213[VAR224.VAR196].VAR205 + (VAR213[VAR224.VAR195].VAR205);
} else {
VAR217[VAR224.VAR197] = true;
VAR217[VAR224.VAR196] = true;
VAR217[VAR224.VAR195] = true;
VAR179 = VAR213[VAR224.VAR196].VAR205 + (VAR213[VAR224.VAR195].VAR205) + (VAR213[VAR224.VAR197].VAR205);
}
}
VAR225.VAR185 = true;
}
function FUN79(address VAR243) internal afterRace constant returns(uint VAR244) {
voter_info storage VAR245 = VAR214[VAR243];
if(VAR225.VAR186) {
VAR244 = VAR245.VAR209;
} else {
uint VAR246;
if(VAR217[VAR224.VAR195]) {
VAR246 += VAR245.VAR211[VAR224.VAR195];
} if(VAR217[VAR224.VAR196]) {
VAR246 += VAR245.VAR211[VAR224.VAR196];
} if(VAR217[VAR224.VAR197]) {
VAR246 += VAR245.VAR211[VAR224.VAR197];
}
VAR244 += (((VAR215.FUN1(10000000)).FUN2(VAR179)).FUN1(VAR246)).FUN2(10000000);
}
}
function FUN80() afterRace external constant returns (uint) {
require(!VAR214[msg.sender].VAR210);
return FUN79(msg.sender);
}
function FUN81() afterRace external {
require(!VAR214[msg.sender].VAR210);
uint VAR247 = FUN79(msg.sender);
require(address(this).VAR237 >= VAR247);
VAR214[msg.sender].VAR210 = true;
msg.sender.transfer(VAR247);
emit FUN68(msg.sender, VAR247);
}
function FUN72(string VAR171) internal pure returns (uint VAR46) {
uint VAR248 =2;
bool VAR249=false;
bytes memory VAR4 = bytes(VAR171);
uint VAR78;
VAR46 = 0;
for (VAR78 = 0; VAR78 < VAR4.VAR81; VAR78++) {
if (VAR249) {VAR248 = VAR248-1;}
if (uint(VAR4[VAR78]) == 46){VAR249 = true;}
uint VAR5 = uint(VAR4[VAR78]);
if (VAR5 >= 48 && VAR5 <= 57) {VAR46 = VAR46 * 10 + (VAR5 - 48);}
if (VAR249 && VAR248 == 0){return VAR46;}
}
while (VAR248!=0) {
VAR46 = VAR46*10;
VAR248=VAR248-1;
}
}
function FUN82(bytes32 VAR250, address VAR243) external constant returns (uint, uint, uint, bool, uint) {
return (VAR213[VAR250].VAR205, VAR213[VAR250].VAR203, VAR213[VAR250].VAR204, VAR213[VAR250].VAR207, VAR214[VAR243].VAR211[VAR250]);
}
function FUN83() external constant returns (uint) {
return ((VAR213[VAR224.VAR195].VAR205) + (VAR213[VAR224.VAR196].VAR205) + (VAR213[VAR224.VAR197].VAR205));
}
function FUN84() external onlyOwner {
require(VAR234 > VAR225.VAR187 + VAR225.VAR189);
require((VAR225.VAR183 && !VAR225.VAR184)
|| (VAR225.VAR184 && !VAR225.VAR185));
VAR225.VAR186 = true;
VAR225.VAR185 = true;
VAR225.VAR190=FUN76(VAR234);
VAR181.FUN63();
}
function FUN85() external onlyOwner{
require((VAR225.VAR185 && VAR234 > VAR225.VAR187 + VAR225.VAR189 + (30 VAR251))
|| (VAR225.VAR186 && VAR234 > VAR225.VAR190 + (30 VAR251)));
VAR181.VAR242.value(address(this).VAR237)();
}
}
1
---------------------------------
198 0xbd2e5ea5aacfde4bac35d5871e1842911f835018.sol
pragma VAR1 ^0.4.17;
contract VAR2 {
address public VAR3;
uint public VAR4;
function FUN1(address VAR5, uint VAR6) public {
VAR3 = VAR5;
VAR4 = VAR6;
}
event FUN2(uint VAR7);
event FUN3(address VAR8, uint VAR7);
function () payable public {
emit FUN2(msg.value);
}
function FUN4() public {
uint VAR9 = address(this).VAR9;
if(VAR4 > 0){
require(VAR3.call.FUN5(VAR4).value(VAR9)());
} else {
require(VAR3.FUN6(VAR9));
}
emit FUN3(VAR3, VAR9);
}
}
contract VAR10 {
mapping(address => mapping(uint => address)) public VAR11;
mapping(address => address[]) public VAR12;
event FUN7(address VAR8, uint VAR13);
function FUN8(address VAR8, uint VAR13, bool VAR14) public returns(address VAR15){
VAR15 = VAR11[VAR8][VAR13];
if(VAR15 == 0x0) {
VAR15 = VAR16 FUN1(VAR8, VAR13);
VAR11[VAR8][VAR13] = VAR15;
emit FUN7(VAR8, VAR13);
}
if(VAR14) {
VAR12[msg.sender].FUN9(VAR15);
}
return VAR15;
}
function FUN10(uint VAR17) public {
uint VAR18 = VAR12[msg.sender].VAR19 - 1;
VAR12[msg.sender][VAR17] = VAR12[msg.sender][VAR18];
delete VAR12[msg.sender][VAR18];
}
}
1
---------------------------------
199 0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
struct VAR3
{
uint VAR4;
uint VAR5;
}
mapping (address => VAR3) public VAR6;
uint public VAR7;
Log VAR8;
bool VAR9;
function FUN1(uint VAR10)
public
{
if(VAR9)throw;
VAR7 = VAR10;
}
function FUN2(address VAR11)
public
{
if(VAR9)throw;
VAR8 = FUN3(VAR11);
}
function FUN4()
public
{
VAR9 = true;
}
function FUN5(uint VAR12)
public
payable
{
var VAR13 = VAR6[msg.sender];
VAR13.VAR5 += msg.value;
if(VAR14+VAR12>VAR13.VAR4)VAR13.VAR4=VAR14+VAR12;
VAR8.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR15)
public
payable
{
var VAR13 = VAR6[msg.sender];
if( VAR13.VAR5>=VAR7 && VAR13.VAR5>=VAR15 && VAR14>VAR13.VAR4)
{
if(msg.sender.call.value(VAR15)())
{
VAR13.VAR5-=VAR15;
VAR8.FUN6(msg.sender,VAR15,"");
}
}
}
function()
public
payable
{
FUN5(0);
}
}
contract VAR16
{
struct VAR17
{
address VAR18;
string  VAR19;
uint VAR20;
uint  VAR21;
}
VAR17[] public VAR22;
Message VAR23;
function FUN6(address VAR24,uint VAR10,string VAR25)
public
{
VAR23.VAR18 = VAR24;
VAR23.VAR21 = VAR14;
VAR23.VAR20 = VAR10;
VAR23.VAR19 = VAR25;
VAR22.FUN8(VAR23);
}
}
1
---------------------------------
200 0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 VAR5) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR7, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR8, address VAR9)
public view returns (uint256);
function FUN4(address VAR10, address VAR4, uint256 VAR5)
public returns (bool);
function FUN5(address VAR9, uint256 VAR5) public returns (bool);
event FUN6(
address indexed VAR11,
address indexed VAR12,
uint256 value
);
}
contract IBasicMultiToken is VAR13 {
event FUN7(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN8(address indexed VAR14, address indexed VAR15, uint256 value);
VAR13[] public VAR16;
function FUN9() public view returns(uint256);
function FUN10(address VAR17, uint256 VAR18, uint256[] VAR19) public;
function FUN11(address VAR17, uint256 VAR18) public;
function FUN12(address VAR17, uint256 VAR5) public;
function FUN13(address VAR17, uint256 VAR5, VAR13[] VAR20) public;
function FUN14() public;
function FUN15() public;
}
contract IMultiToken is VAR21 {
event FUN16();
event FUN17(address indexed VAR22, address indexed VAR23, address indexed VAR24, uint256 VAR18, uint256 VAR25);
mapping(address => uint256) public VAR26;
function FUN18(address VAR22, address VAR23, uint256 VAR18) public view returns (uint256 VAR27);
function FUN19(address VAR22, address VAR23, uint256 VAR18, uint256 VAR28) public returns (uint256 VAR27);
function FUN20() public;
}
library VAR29 {
function FUN21(uint256 VAR30, uint256 VAR31) internal pure returns (uint256 VAR32) {
if (VAR30 == 0) {
return 0;
}
VAR32 = VAR30 * VAR31;
assert(VAR32 / VAR30 == VAR31);
return VAR32;
}
function FUN22(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
return VAR30 / VAR31;
}
function FUN23(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
assert(VAR31 <= VAR30);
return VAR30 - VAR31;
}
function FUN24(uint256 VAR30, uint256 VAR31) internal pure returns (uint256 VAR32) {
VAR32 = VAR30 + VAR31;
assert(VAR32 >= VAR30);
return VAR32;
}
}
contract VAR33 {
address public VAR11;
event FUN25(address indexed VAR34);
event FUN26(
address indexed VAR34,
address indexed VAR35
);
constructor() public {
VAR11 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR11);
VAR36;
}
function FUN27() public onlyOwner {
emit FUN25(VAR11);
VAR11 = address(0);
}
function FUN28(address VAR37) public onlyOwner {
FUN29(VAR37);
}
function FUN29(address VAR37) internal {
require(VAR37 != address(0));
emit FUN26(VAR11, VAR37);
VAR11 = VAR37;
}
}
library VAR38 {
function FUN30(
ERC20Basic VAR39,
address VAR4,
uint256 VAR5
)
internal
{
require(VAR39.transfer(VAR4, VAR5));
}
function FUN31(
ERC20 VAR39,
address VAR10,
address VAR4,
uint256 VAR5
)
internal
{
require(VAR39.FUN4(VAR10, VAR4, VAR5));
}
function FUN32(
ERC20 VAR39,
address VAR9,
uint256 VAR5
)
internal
{
require(VAR39.FUN5(VAR9, VAR5));
}
}
contract CanReclaimToken is VAR33 {
using SafeERC20 for VAR2;
function FUN33(ERC20Basic VAR39) external onlyOwner {
uint256 VAR40 = VAR39.FUN2(this);
VAR39.FUN30(VAR11, VAR40);
}
}
library VAR41 {
using SafeMath for uint;
function FUN34(address VAR42) internal view returns(bool VAR43) {
VAR44 {
VAR43 := FUN35(FUN36(VAR42), 0)
}
}
function FUN37() internal pure returns(bool VAR43) {
VAR44 {
switch FUN38()
case 0 {
VAR43 := 1
}
case 32 {
FUN39(0, 0, 32)
VAR43 := FUN40(0)
}
default {
revert(0, 0)
}
}
}
function FUN41() internal pure returns(bytes32 VAR43) {
VAR44 {
if FUN42(FUN38(), 32) {
FUN39(0, 0, 32)
VAR43 := FUN40(0)
}
if FUN35(FUN38(), 32) {
FUN39(0, 64, 32)
VAR43 := FUN40(0)
}
if FUN43(FUN38(), 32) {
revert(0, 0)
}
}
}
function FUN44(address VAR39, address VAR4, uint256 VAR5) internal returns(bool) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45("")), VAR4, VAR5));
return FUN37();
}
function FUN46(address VAR39, address VAR10, address VAR4, uint256 VAR5) internal returns(bool) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45("")), VAR10, VAR4, VAR5));
return FUN37();
}
function FUN47(address VAR39, address VAR9, uint256 VAR5) internal returns(bool) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45("")), VAR9, VAR5));
return FUN37();
}
//
function FUN48(ERC20 VAR39, address VAR4, uint256 VAR5) internal {
if (VAR5 > 0) {
uint256 VAR40 = VAR39.FUN2(this);
FUN44(VAR39, VAR4, VAR5);
require(VAR39.FUN2(this) == VAR40.FUN23(VAR5), "");
}
}
function FUN49(ERC20 VAR39, address VAR10, address VAR4, uint256 VAR5) internal {
if (VAR5 > 0) {
uint256 VAR45 = VAR39.FUN2(VAR4);
FUN46(VAR39, VAR10, VAR4, VAR5);
require(VAR39.FUN2(VAR4) == VAR45.FUN24(VAR5), "");
}
}
//
function FUN50(address VAR39) internal view returns(bytes32) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45(""))));
return FUN41();
}
function FUN51(address VAR39) internal view returns(bytes32) {
require(FUN34(VAR39));
require(VAR39.call(bytes4(FUN45(""))));
return FUN41();
}
}
contract IEtherToken is VAR13 {
function FUN52() public payable;
function FUN53(uint256 VAR18) public;
}
contract VAR46 {
function FUN54(
address[] VAR47,
uint256 VAR18,
uint256 VAR28
)
public
payable
returns(uint256);
function FUN55(
address[] VAR47,
uint256 VAR18,
uint256 VAR28
)
public
payable
returns(uint256);
}
contract VAR48 {
function FUN56(
address VAR49,
uint VAR50,
address VAR51,
address VAR52,
uint VAR53,
uint VAR54,
address VAR55
)
public
payable
returns(uint);
}
contract MultiChanger is VAR56 {
using SafeMath for uint256;
using CheckedERC20 for VAR13;
function FUN57(address VAR57, uint value, bytes VAR58, uint VAR59, uint VAR60) internal returns (bool VAR43) {
VAR44 {
let VAR61 := FUN40(0x40)
let VAR62 := FUN24(VAR58, 32)
VAR43 := call(
FUN23(VAR63, 34710),
VAR57,
value,
FUN24(VAR62, VAR59),
VAR60,
VAR61,
0
)
}
}
function FUN19(
bytes VAR64,
uint[] VAR65
)
internal
{
for (uint VAR66 = 0; VAR66 < VAR65.VAR67 - 1; VAR66++) {
require(FUN57(this, 0, VAR64, VAR65[VAR66], VAR65[VAR66 + 1] - VAR65[VAR66]));
}
}
function FUN58(address VAR68, bytes VAR69, uint256 VAR5) external {
require(VAR68.call.value(VAR5)(VAR69));
}
function FUN59(address VAR68, bytes VAR69, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR40.FUN21(VAR70).FUN22(VAR71);
require(VAR68.call.value(value)(VAR69));
}
function FUN60(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR18) external {
if (VAR22.FUN3(this, VAR68) != 0) {
VAR22.FUN47(VAR68, 0);
}
VAR22.FUN47(VAR68, VAR18);
require(VAR68.call(VAR69));
}
function FUN61(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR22.FUN2(this).FUN21(VAR70).FUN22(VAR71);
if (VAR22.FUN3(this, VAR68) != 0) {
VAR22.FUN47(VAR68, 0);
}
VAR22.FUN47(VAR68, VAR72);
require(VAR68.call(VAR69));
}
function FUN62(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR18) external {
VAR22.FUN44(VAR68, VAR18);
require(VAR68.call(VAR69));
}
function FUN63(address VAR68, bytes VAR69, ERC20 VAR22, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR22.FUN2(this).FUN21(VAR70).FUN22(VAR71);
VAR22.FUN44(VAR68, VAR72);
require(VAR68.call(VAR69));
}
function FUN64(IEtherToken VAR73, uint256 VAR18) external {
VAR73.FUN53(VAR18);
}
function FUN65(IEtherToken VAR73, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR73.FUN2(this).FUN21(VAR70).FUN22(VAR71);
VAR73.FUN53(VAR72);
}
function FUN66(IBancorNetwork VAR74, address[] VAR47, uint256 VAR5) external {
VAR74.VAR75.value(VAR5)(VAR47, VAR5, 1);
}
function FUN67(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR40.FUN21(VAR70).FUN22(VAR71);
VAR74.VAR75.value(value)(VAR47, value, 1);
}
function FUN68(IBancorNetwork VAR74, address[] VAR47, uint256 VAR18) external {
if (FUN69(VAR47[0]).FUN3(this, VAR74) == 0) {
FUN69(VAR47[0]).FUN47(VAR74, uint256(-1));
}
VAR74.FUN55(VAR47, VAR18, 1);
}
function FUN70(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN69(VAR47[0]).FUN2(this).FUN21(VAR70).FUN22(VAR71);
if (FUN69(VAR47[0]).FUN3(this, VAR74) == 0) {
FUN69(VAR47[0]).FUN47(VAR74, uint256(-1));
}
VAR74.FUN55(VAR47, VAR72, 1);
}
function FUN71(IBancorNetwork VAR74, address[] VAR47, uint256 VAR18) external {
FUN69(VAR47[0]).FUN44(VAR74, VAR18);
VAR74.FUN54(VAR47, VAR18, 1);
}
function FUN72(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN69(VAR47[0]).FUN2(this).FUN21(VAR70).FUN22(VAR71);
FUN69(VAR47[0]).FUN44(VAR74, VAR72);
VAR74.FUN54(VAR47, VAR72, 1);
}
function FUN73(IBancorNetwork VAR74, address[] VAR47, uint256 VAR18) external {
VAR74.FUN54(VAR47, VAR18, 1);
}
function FUN74(IBancorNetwork VAR74, address[] VAR47, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = FUN69(VAR47[0]).FUN2(VAR74).FUN21(VAR70).FUN22(VAR71);
VAR74.FUN54(VAR47, VAR72, 1);
}
function FUN75(IKyberNetworkProxy VAR76, ERC20 VAR22, address VAR23, uint256 VAR70, uint256 VAR71) external {
uint256 value = address(this).VAR40.FUN21(VAR70).FUN22(VAR71);
VAR76.VAR77.value(value)(
VAR22,
value,
VAR23,
this,
1 << 255,
0,
0
);
}
function FUN76(IKyberNetworkProxy VAR76, ERC20 VAR22, address VAR23, uint256 VAR18) external {
if (VAR22.FUN3(this, VAR76) == 0) {
VAR22.FUN47(VAR76, uint256(-1));
}
VAR76.FUN56(
VAR22,
VAR18,
VAR23,
this,
1 << 255,
0,
0
);
}
function FUN77(IKyberNetworkProxy VAR76, ERC20 VAR22, address VAR23, uint256 VAR70, uint256 VAR71) external {
uint256 VAR72 = VAR22.FUN2(this).FUN21(VAR70).FUN22(VAR71);
this.FUN76(VAR76, VAR22, VAR23, VAR72);
}
}
contract MultiBuyer is VAR78 {
function FUN78(
IMultiToken VAR79,
uint256 VAR80,
bytes VAR64,
uint[] VAR65
)
public
payable
{
FUN19(VAR64, VAR65);
uint VAR81 = VAR79.FUN1();
uint256 VAR82 = uint256(-1);
for (uint VAR66 = VAR79.FUN9(); VAR66 > 0; VAR66--) {
ERC20 VAR83 = VAR79.FUN79(VAR66 - 1);
if (VAR83.FUN3(this, VAR79) == 0) {
VAR83.FUN47(VAR79, uint256(-1));
}
uint256 VAR72 = VAR81.FUN21(VAR83.FUN2(this)).FUN22(VAR83.FUN2(VAR79));
if (VAR72 < VAR82) {
VAR82 = VAR72;
}
}
require(VAR82 >= VAR80, "");
VAR79.FUN11(msg.sender, VAR82);
if (address(this).VAR40 > 0) {
msg.sender.transfer(address(this).VAR40);
}
for (VAR66 = VAR79.FUN9(); VAR66 > 0; VAR66--) {
VAR83 = VAR79.FUN79(VAR66 - 1);
VAR83.FUN44(msg.sender, VAR83.FUN2(this));
}
}
function FUN80(
IMultiToken VAR79,
bytes VAR64,
uint[] VAR65
)
public
payable
{
FUN19(VAR64, VAR65);
uint VAR84 = VAR79.FUN9();
uint256[] memory VAR85 = new uint256[](VAR84);
for (uint VAR66 = 0; VAR66 < VAR84; VAR66++) {
ERC20 VAR83 = VAR79.FUN79(VAR66);
VAR85[VAR66] = VAR83.FUN2(this);
if (VAR83.FUN3(this, VAR79) == 0) {
VAR83.FUN47(VAR79, uint256(-1));
}
}
VAR79.FUN10(msg.sender, msg.value.FUN21(1000), VAR85);
if (address(this).VAR40 > 0) {
msg.sender.transfer(address(this).VAR40);
}
for (VAR66 = VAR79.FUN9(); VAR66 > 0; VAR66--) {
VAR83 = VAR79.FUN79(VAR66 - 1);
VAR83.FUN44(msg.sender, VAR83.FUN2(this));
}
}
}
1
---------------------------------
201 0xbff8c925757009c2b0d295f0891c3eb27be78268.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
address[] private VAR3;
address[] private VAR4;
address private VAR5;
mapping(address => uint) private VAR6;
uint private VAR7 = 320;
uint private VAR8 = 0;
modifier FUN1() {
require(msg.sender == VAR5);
VAR9;
}
constructor () public {
VAR5 = msg.sender;
}
function FUN2 (uint VAR10, uint VAR11, string VAR12, address VAR13) public adminOnly payable {
VAR7 ++;
address VAR14 = VAR15 FUN3(VAR7, VAR10, VAR11, VAR12, VAR13);
VAR3.FUN4(VAR14);
VAR6[VAR14] = VAR3.VAR16;
FUN5(VAR14, msg.value);
}
function FUN6() public view returns (address[]) {
return VAR3;
}
function FUN7() public view returns (address[]) {
return VAR4;
}
function FUN5(address VAR17, uint VAR18) adminOnly public {
if (VAR18 > 0) {
MajorityGame VAR19 = FUN3(VAR17);
VAR19.VAR20.value(VAR18)();
}
}
function FUN8(address VAR21, uint VAR22) public payable {
if (msg.value > 0) {
MajorityGame VAR19 = FUN3(VAR21);
VAR19.VAR23.value(msg.value)(msg.sender, VAR22);
}
}
function FUN9(address VAR17) public {
uint VAR24 = VAR6[address(VAR17)];
VAR8++;
VAR4.FUN4(VAR17);
VAR3[VAR24-1] = VAR3[VAR3.VAR16-1];
VAR6[VAR3[VAR3.VAR16-1]] = VAR24;
delete VAR3[VAR3.VAR16-1];
VAR3.VAR16--;
MajorityGame VAR19 = FUN3(address(VAR17));
VAR19.FUN9();
}
function FUN10(address VAR17) public VAR25 {
uint VAR24 = VAR6[address(VAR17)];
VAR8++;
VAR4.FUN4(VAR17);
VAR3[VAR24-1] = VAR3[VAR3.VAR16-1];
VAR6[VAR3[VAR3.VAR16-1]] = VAR24;
delete VAR3[VAR3.VAR16-1];
VAR3.VAR16--;
MajorityGame VAR19 = FUN3(address(VAR17));
VAR19.FUN10();
}
function FUN11() public VAR25{
FUN12(VAR5);
}
function FUN13(address VAR17) public VAR25{
MajorityGame VAR19 = FUN3(address(VAR17));
VAR19.FUN11();
}
}
contract VAR26 {
uint private VAR27;
uint private VAR28;
uint private VAR29;
address private VAR5;
address private VAR30;
uint private VAR31;
uint private VAR32;
string private VAR33;
mapping(address => bool) private VAR34;
mapping(address => bool) private VAR35;
address[] private VAR36;
address[] private VAR37;
uint private VAR38;
address[] private VAR39;
address private VAR40;
uint private VAR41;
uint private VAR42;
uint private VAR43;
modifier FUN1() {
require(msg.sender == VAR5);
VAR9;
}
modifier FUN14() {
require(VAR44 >= VAR31);
require(VAR44 <= VAR32);
VAR9;
}
modifier FUN15() {
require(VAR44 > VAR32);
VAR9;
}
modifier FUN16() {
require(VAR41 == 0);
VAR9;
}
modifier FUN17() {
require(VAR41 > 0);
VAR9;
}
modifier FUN18() {
require((VAR36.VAR16 + VAR37.VAR16) < 500);
VAR9;
}
constructor(uint VAR45, uint VAR10, uint VAR11, string VAR12, address VAR13) public {
VAR27 = VAR45;
VAR5 = msg.sender;
VAR29 = VAR10;
VAR31 = VAR11 - 25*60*60;
VAR32 = VAR11;
VAR33 = VAR12;
VAR41 = 0;
VAR43 = 0;
VAR30 = VAR13;
}
function FUN5() public payable adminOnly returns (bool) {
if (msg.value > 0) {
VAR28 += msg.value;
return true;
}
return false;
}
function FUN19() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) {
return (
VAR27,
VAR31,
VAR32,
VAR36.VAR16 + VAR37.VAR16,
address(this).VAR46,
VAR33,
VAR28,
VAR41,
VAR29
);
}
function FUN20(address VAR47, uint VAR48) public payable adminOnly notEnded VAR49 {
require(!VAR34[VAR47] && !VAR35[VAR47]);
require(msg.value == VAR29);
if (VAR48 == 1) {
VAR34[VAR47] = true;
VAR36.FUN4(VAR47);
} else if (VAR48 == 2) {
VAR35[VAR47] = true;
VAR37.FUN4(VAR47);
}
if(VAR36.VAR16 + VAR37.VAR16 <= 6){
VAR39.FUN4(VAR47);
}
VAR40 = VAR47;
}
function FUN9() public VAR50 {
require(VAR41 == 0);
VAR42 = address(this).VAR46;
uint VAR51 = VAR42 * 9 / 10;
uint VAR52 = uint(VAR36.VAR16);
uint VAR53 = uint(VAR37.VAR16);
uint VAR54 = VAR52 + VAR53;
if(VAR54 == 0 ){
VAR43 = 0;
VAR38 = 0;
if(VAR27 % 2 == 1){
VAR41 = 1;
}else{
VAR41 = 2;
}
return;
}else{
if (VAR52 != 0 && VAR54 / VAR52 > 10) {
VAR41 = 1;
} else if (VAR53 != 0 && VAR54 / VAR53 > 10) {
VAR41 = 2;
} else if (VAR52 > VAR53 || (VAR52 == VAR53 && VAR27 % 2 == 1)) {
VAR41 = 1;
} else {
VAR41 = 2;
}
}
if (VAR41 == 1) {
VAR43 = uint(VAR51 / VAR52);
VAR38 = VAR52;
} else {
VAR43 = uint(VAR51 / VAR53);
VAR38 = VAR53;
}
}
function FUN10() public VAR25 {
require(VAR41 == 0);
VAR42 = address(this).VAR46;
uint VAR51 = VAR42 * 9 / 10;
uint VAR52 = uint(VAR36.VAR16);
uint VAR53 = uint(VAR37.VAR16);
uint VAR54 = VAR52 + VAR53;
if(VAR54 == 0 ){
VAR43 = 0;
VAR38 = 0;
if(VAR27 % 2 == 1){
VAR41 = 1;
}else{
VAR41 = 2;
}
return;
}
if (VAR52 != 0 && VAR54 / VAR52 > 10) {
VAR41 = 1;
} else if (VAR53 != 0 && VAR54 / VAR53 > 10) {
VAR41 = 2;
} else if (VAR52 > VAR53 || (VAR52 == VAR53 && VAR27 % 2 == 1)) {
VAR41 = 1;
} else {
VAR41 = 2;
}
if (VAR41 == 1) {
VAR43 = uint(VAR51 / VAR52);
VAR38 = VAR52;
} else {
VAR43 = uint(VAR51 / VAR53);
VAR38 = VAR53;
}
}
function FUN21() public VAR55 {
require(VAR38 > 0);
uint VAR56 = VAR38;
if (VAR38 > 400) {
for (uint VAR57 = 0; VAR57 < 400; VAR57++) {
this.FUN22();
}
} else {
for (uint VAR58 = 0; VAR58 < VAR56; VAR58++) {
this.FUN22();
}
}
}
function FUN22() public VAR55 {
require(VAR38 > 0);
if(VAR41 == 1){
address(VAR36[VAR38 - 1]).transfer(VAR43);
}else{
address(VAR37[VAR38 - 1]).transfer(VAR43);
}
VAR38--;
if(VAR38 == 0){
if(VAR36.VAR16 + VAR37.VAR16 >= 7){
uint VAR59 = uint(VAR42 / 200);
for (uint VAR60 = 0; VAR60 < 6; VAR60++) {
address(VAR39[VAR60]).transfer(VAR59);
}
address(VAR40).transfer(uint(VAR42 / 50));
}
address(VAR30).transfer(address(this).VAR46);
}
}
function FUN23() public isEnded view returns (uint, uint, uint, uint, uint) {
return (
VAR41,
VAR36.VAR16,
VAR37.VAR16,
VAR42,
VAR43
);
}
function FUN24() public view returns (uint) {
if (VAR34[msg.sender]) {
return 1;
} else if (VAR35[msg.sender]) {
return 2;
} else {
return 0;
}
}
function FUN25() public isEnded view returns (address[]) {
if (VAR41 == 1) {
return VAR36;
}else {
return VAR37;
}
}
function FUN26() public isEnded view returns (address[]) {
if (VAR41 == 1) {
return VAR37;
}else {
return VAR36;
}
}
function FUN11() public VAR25{
FUN12(VAR5);
}
}
1
---------------------------------
202 0xc05be003329a98d94b87a868c1db40a5d6853107.sol
pragma VAR1 ^0.4.25;
interface VAR2 {
function FUN1(address VAR3) payable external returns(uint256);
function FUN2(uint256 VAR4) external;
function FUN3() external;
function FUN4() external;
function transfer(address VAR5, uint256 VAR4) external returns(bool);
function FUN5(address VAR6) view external returns(uint256);
function FUN6(bool VAR7) external view returns(uint256);
}
contract VAR8 {
event FUN7(address indexed VAR9, address indexed VAR10);
mapping (address => address) public VAR11;
function FUN8()
public
view
returns (bool)
{
return VAR11[msg.sender] != address(0);
}
function FUN9()
external
view
returns (address)
{
require(FUN8(), "");
return VAR11[msg.sender];
}
function FUN10(uint256 VAR12)
public
{
require(!FUN8(), "");
require(VAR12 > 0);
address VAR9 = msg.sender;
VAR11[VAR9] = VAR13 FUN11(VAR9, VAR12);
emit FUN7(VAR9, VAR11[VAR9]);
}
}
contract VAR14 {
HourglassInterface constant VAR15 = FUN12(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);
address public VAR9;
uint256 public VAR16;
uint256 public VAR17;
modifier FUN13()
{
require(VAR18 >= VAR16 + VAR17 * 1 VAR19);
VAR20;
}
modifier onlyOwner()
{
require(msg.sender == VAR9);
VAR20;
}
constructor(address VAR21, uint256 VAR12)
public
{
VAR9 = VAR21;
VAR17 =VAR12;
VAR16 = VAR18;
}
function() public payable {}
function FUN14()
public
view
returns(bool)
{
return VAR18 < VAR16 + VAR17 * 1 VAR19;
}
function FUN15()
external
view
returns(uint256)
{
return VAR16 + VAR17 * 1 VAR19;
}
function FUN16(uint256 VAR22)
external
onlyOwner
{
uint256 VAR23 = VAR17 + VAR22;
require(VAR23 > VAR17);
VAR17 = VAR23;
}
function FUN4()
external
onlyOwner
{
VAR9.transfer(address(this).VAR24);
}
function FUN17()
external
onlyOwner
{
VAR15.VAR25.value(address(this).VAR24)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);
}
function FUN5()
external
view
returns(uint256)
{
return VAR15.FUN5(address(this));
}
function FUN18()
external
view
returns(uint256)
{
return VAR15.FUN6(true);
}
function FUN1()
external
payable
onlyOwner
{
VAR15.VAR25.value(msg.value)(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef);
}
function FUN3()
external
onlyOwner
{
VAR15.FUN3();
}
function FUN19()
external
onlyOwner
{
VAR15.FUN4();
VAR9.transfer(address(this).VAR24);
}
function FUN2(uint256 VAR26)
external
VAR27
onlyOwner
{
VAR15.FUN2(VAR26);
VAR9.transfer(address(this).VAR24);
}
function transfer(address VAR5, uint256 VAR4)
external
VAR27
onlyOwner
returns(bool)
{
return VAR15.transfer(VAR5, VAR4);
}
}
1
---------------------------------
203 0xc0aa69e24533f99fd95757e471d93ba7ea4b1c50.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
uint256 public VAR7;
function FUN5(address VAR8) constant public returns (uint256);
function transfer(address VAR9, uint256 value) public returns (bool);
event Transfer(address indexed VAR10, address indexed VAR9, uint256 value);
}
contract ERC20 is VAR6 {
function FUN6(address VAR11, address VAR12) constant public returns (uint256);
function FUN7(address VAR10, address VAR9, uint256 value) public returns (bool);
function FUN8(address VAR12, uint256 value) public returns (bool);
event FUN9(address indexed VAR11, address indexed VAR12, uint256 value);
}
contract VAR13 {
address public VAR11;
address public VAR14;
function FUN10() public payable {
VAR11 = msg.sender;
}
modifier onlyOwner {
require(VAR11 == msg.sender);
VAR15;
}
function FUN11(address VAR16) onlyOwner public {
require(VAR16 != 0);
VAR14 = VAR16;
}
function FUN12() public {
require(VAR14 == msg.sender);
VAR11 = VAR14;
delete VAR14;
}
}
contract VAR17 {
uint public VAR18;
modifier VAR19 {
require(VAR20 > VAR18);
VAR15;
}
}
contract BalancingToken is VAR21 {
mapping (address => uint256) public VAR22;
function FUN5(address VAR16) public constant returns (uint256 VAR23) {
return VAR22[VAR16];
}
}
contract DividendToken is VAR24, VAR17, VAR13 {
using SafeMath for uint256;
event FUN13(address indexed VAR25, uint256 VAR26);
mapping (address => mapping (address => uint256)) public VAR27;
uint public VAR28;
uint public VAR29;
modifier FUN14(uint VAR30) {
require(msg.VAR31.VAR32 >= VAR30 + 4);
VAR15;
}
modifier FUN15() {
require(VAR20 > VAR29 + VAR33);
VAR15;
}
struct VAR34 {
uint256 VAR23;
uint    VAR35;
uint    VAR36;
}
mapping(address => VAR34) VAR37;
uint public VAR33 = 0;
function transfer(address VAR38, uint256 VAR39) FUN14(2 * 32) unblocked public returns (bool) {
return FUN16(VAR38, VAR39);
}
function FUN16(address VAR38, uint256 VAR39) internal returns (bool) {
FUN17(msg.sender);
FUN17(VAR38);
VAR22[msg.sender] = VAR22[msg.sender].FUN3(VAR39);
VAR22[VAR38] = VAR22[VAR38].FUN4(VAR39);
Transfer(msg.sender, VAR38, VAR39);
return true;
}
function FUN7(address VAR40, address VAR38, uint256 VAR39) FUN14(3 * 32) unblocked public returns (bool) {
FUN17(VAR40);
FUN17(VAR38);
var VAR41 = VAR27[VAR40][msg.sender];
VAR22[VAR38] = VAR22[VAR38].FUN4(VAR39);
VAR22[VAR40] = VAR22[VAR40].FUN3(VAR39);
VAR27[VAR40][msg.sender] = VAR41.FUN3(VAR39);
Transfer(VAR40, VAR38, VAR39);
return true;
}
function FUN8(address VAR42, uint256 VAR39) FUN14(2 * 32) unblocked public returns (bool) {
require((VAR39 == 0) || (VAR27[msg.sender][VAR42] == 0));
VAR27[msg.sender][VAR42] = VAR39;
FUN9(msg.sender, VAR42, VAR39);
return true;
}
function FUN6(address VAR16, address VAR42) FUN14(2 * 32) unblocked constant public returns (uint256 VAR43) {
return VAR27[VAR16][VAR42];
}
function FUN18() constant public returns (uint256) {
if (VAR37[msg.sender].VAR36 >= VAR29) {
return 0;
}
uint256 VAR23;
if (VAR37[msg.sender].VAR35 <= VAR29) {
VAR23 = VAR22[msg.sender];
} else {
VAR23 = VAR37[msg.sender].VAR23;
}
return VAR28.FUN1(VAR23).FUN2(VAR7);
}
function FUN19() public returns (uint256) {
uint256 VAR44 = FUN18();
if (VAR44 == 0) {
return 0;
}
if (VAR22[msg.sender] == 0) {
delete VAR37[msg.sender];
} else {
VAR37[msg.sender].VAR36 = VAR20;
}
require(msg.sender.call.FUN20(3000000).value(VAR44)());
FUN13(msg.sender, VAR44);
return VAR44;
}
function FUN21(uint VAR45) rewardTimePast onlyOwner external payable {
require(VAR45 >= 15 && VAR45 <= 45);
VAR29 = VAR20;
VAR33 = VAR45;
VAR28 = this.VAR23;
}
function FUN22() rewardTimePast onlyOwner external {
require(msg.sender.call.FUN20(3000000).value(this.VAR23)());
}
function FUN17(address VAR46) public {
if (VAR37[VAR46].VAR35 <= VAR29) {
VAR37[VAR46].VAR35 = VAR20;
VAR37[VAR46].VAR23 = VAR22[VAR46];
}
}
}
contract RENTCoin is VAR47 {
string public constant VAR48 = "";
string public constant VAR49 = "";
uint32 public constant VAR50 = 18;
function FUN23(uint256 VAR51, uint VAR52) public {
VAR7 = VAR51;
VAR22[VAR11] = VAR51;
VAR18 = VAR52;
}
function FUN24(address VAR38, uint256 VAR39) FUN14(2 * 32) onlyOwner public returns (bool) {
return FUN16(VAR38, VAR39);
}
}
contract VAR53 {
uint public constant VAR54 = 1517461200;
uint public constant VAR55 =    1518670800;
uint public constant VAR56 =      1521090000;
function FUN25() internal view returns (uint) {
return VAR20;
}
function FUN26() public view returns (bool) {
var VAR57 = FUN25();
return VAR57 < VAR55 && VAR57 >= VAR54;
}
function FUN27() public view returns (bool) {
var VAR57 = FUN25();
return VAR57 < VAR56 && VAR57 >= VAR55;
}
function FUN28() public view returns (bool) {
return FUN25() > VAR55;
}
function FUN29() public view returns (bool) {
return FUN25() > VAR56;
}
}
contract BonusCrowdsale is VAR53 {
function FUN30(uint256 VAR58) public view returns (uint) {
uint VAR59 = FUN31(VAR58);
if (FUN26()) {
VAR59 += 25;
}
return VAR59;
}
function FUN31(uint256 VAR58) public view returns (uint) {
if (VAR58 >= 25 VAR60) {
return 15;
}
if (VAR58 >= 10 VAR60) {
return 5;
}
return 0;
}
}
contract ManualSendingCrowdsale is VAR61, VAR13 {
using SafeMath for uint256;
struct VAR62 {
bool VAR63;
uint256 value;
}
mapping (uint => VAR62) public VAR64;
function FUN32(uint VAR65) external onlyOwner {
FUN33(VAR65);
}
function FUN33(uint VAR65) internal {
AmountData storage VAR66 = VAR64[VAR65];
VAR66.VAR63 = true;
}
function FUN34(address VAR9, uint256 VAR67, uint VAR65, uint256 VAR58) internal returns (uint256) {
AmountData memory VAR68 = VAR64[VAR65];
require(VAR68.VAR63);
AmountData storage VAR66 = VAR64[VAR65];
VAR66.value = VAR66.value.FUN4(VAR58);
return FUN35(VAR9, VAR67);
}
function FUN35(address VAR9, uint256 VAR67) internal returns (uint256);
}
contract WithdrawCrowdsale is VAR69 {
function FUN36() public view returns (bool);
modifier FUN37() {
require(FUN36());
VAR15;
}
function FUN38() external onlyOwner VAR70 {
require(msg.sender.call.FUN20(3000000).value(this.VAR23)());
}
function FUN39(uint256 VAR58) external onlyOwner VAR70 {
uint256 VAR71 = VAR58;
if (this.VAR23 < VAR58) {
VAR71 = this.VAR23;
}
require(msg.sender.call.FUN20(3000000).value(VAR71)());
}
}
contract RefundableCrowdsale is VAR72 {
event FUN40(address indexed VAR73, uint256 VAR74);
mapping (address => uint256) public VAR75;
function FUN41(address VAR76) external {
require(FUN42());
uint256 VAR77 = VAR75[VAR76];
VAR75[VAR76] = 0;
require(VAR76.call.FUN20(3000000).value(VAR77)());
FUN40(VAR76, VAR77);
}
function FUN42() internal view returns (bool);
}
contract Crowdsale is VAR78 {
using SafeMath for uint256;
enum VAR79 { VAR80, VAR81, VAR82 }
State public VAR83 = VAR79.VAR80;
uint256 public constant VAR84 = 75000000 * 10**18;
uint256 public constant VAR85 =   15000000 * 10**18;
uint256 public constant VAR86 =  6000000 * 10**18;
uint public constant VAR87 = 1519880400;
RENTCoin public VAR88;
uint256 public VAR89 = 0;
uint256 public VAR90 = 0;
uint public VAR91 = 0;
bool public VAR92 = false;
uint256 public constant VAR93 = 1000;
uint256 public constant VAR94 = 10**16;
uint256 public VAR95 = 0;
modifier FUN43() {
require(!FUN44());
require(FUN26() || FUN27());
VAR15;
}
modifier FUN45() {
require(msg.value >= VAR94);
VAR15;
}
function FUN46() public {
VAR88 = VAR96 FUN23(VAR84, VAR87);
VAR89 = VAR84 - VAR85;
FUN33(0);
}
function FUN44() public view returns (bool) {
return FUN29() || (VAR89 == 0 && (VAR83 == VAR79.VAR80 || VAR83 == VAR79.VAR82));
}
function FUN36() public view returns (bool) {
return VAR95 >= VAR86;
}
function FUN42() internal view returns (bool) {
return VAR83 == VAR79.VAR81;
}
function() external canBuy minPayment payable {
address VAR76 = msg.sender;
uint256 VAR58 = msg.value;
uint VAR59 = FUN30(VAR58);
uint256 VAR67 = VAR58.FUN1(VAR93).FUN2(100).FUN1(100 + VAR59);
uint256 VAR97 = FUN35(VAR76, VAR67);
if (VAR67 > VAR97) {
uint256 VAR98 = VAR97.FUN1(100).FUN2(100 + VAR59).FUN2(VAR93);
require(VAR58 > VAR98);
require(VAR76.call.FUN20(3000000).value(VAR58 - VAR98)());
VAR58 = VAR98;
}
VAR90 = VAR90.FUN4(VAR58);
if (!FUN36()) {
VAR75[VAR76] = VAR75[VAR76].FUN4(msg.value);
}
}
function FUN47(address VAR9, uint256 VAR67, uint VAR65, uint256 VAR58) external onlyOwner canBuy returns (uint256) {
return FUN34(VAR9, VAR67, VAR65, VAR58);
}
function FUN48() external {
require(FUN44());
require(VAR83 == VAR79.VAR80);
if (!FUN36())  {
VAR83 = VAR79.VAR81;
VAR92 = true;
} else {
VAR83 = VAR79.VAR82;
}
}
function FUN49() external onlyOwner {
require(VAR83 == VAR79.VAR82);
require(VAR20 > VAR56);
require(!VAR92);
VAR88.FUN11(msg.sender);
VAR92 = true;
require(VAR88.transfer(msg.sender, VAR88.FUN5(this)));
}
function FUN50(uint256 VAR97) internal {
VAR95 = VAR95.FUN4(VAR97);
}
function FUN35(address VAR9, uint256 VAR67) internal returns (uint256) {
var VAR97 = VAR67;
if (VAR67 > VAR89) {
VAR97 = VAR89;
}
VAR89 = VAR89.FUN3(VAR97);
FUN50(VAR97);
require(VAR88.FUN24(VAR9, VAR97));
VAR91 = VAR91 + 1;
return VAR97;
}
}
1
---------------------------------
204 0xc17d432bd8e8850fd7b32b0270f5afac65db0105.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address public VAR3;
address public VAR4;
mapping (address => bool) public VAR5;
mapping (bytes4 => address) public VAR6;
uint public VAR7;
event FUN1(address indexed VAR8, bool value);
event FUN2(address indexed VAR8, bytes4 indexed VAR9);
event FUN3(address indexed VAR8, address indexed VAR10, uint indexed value, bytes VAR11);
event FUN4(uint indexed value, address indexed sender, bytes VAR11);
event FUN5(address VAR4);
modifier VAR12 {
require(VAR5[msg.sender], "");
VAR13;
}
function FUN6(address VAR14, address[] VAR15) external {
require(VAR4 == address(0) && VAR7 == 0, "");
require(VAR15.VAR16 > 0, "");
VAR4 = VAR14;
VAR7 = VAR15.VAR16;
for(uint256 VAR17 = 0; VAR17 < VAR15.VAR16; VAR17++) {
require(VAR5[VAR15[VAR17]] == false, "");
VAR5[VAR15[VAR17]] = true;
FUN7(VAR15[VAR17]).FUN6(this);
emit FUN1(VAR15[VAR17], true);
}
}
function FUN8(address VAR18, bool VAR19) external VAR12 {
if (VAR5[VAR18] != VAR19) {
if(VAR19 == true) {
VAR7 += 1;
VAR5[VAR18] = true;
FUN7(VAR18).FUN6(this);
}
else {
VAR7 -= 1;
require(VAR7 > 0, "");
delete VAR5[VAR18];
}
emit FUN1(VAR18, VAR19);
}
}
function FUN9(address VAR18, bytes4 VAR20) external VAR12 {
require(VAR5[VAR18], "");
VAR6[VAR20] = VAR18;
emit FUN2(VAR18, VAR20);
}
function FUN10(address VAR21) external VAR12 {
require(VAR21 != address(0), "");
VAR4 = VAR21;
emit FUN5(VAR21);
}
function FUN11(address VAR22, uint VAR19, bytes VAR23) external VAR12 {
require(VAR22.call.value(VAR19)(VAR23), "");
emit FUN3(msg.sender, VAR22, VAR19, VAR23);
}
function() public payable {
if(msg.VAR11.VAR16 > 0) {
address VAR8 = VAR6[msg.VAR24];
if(VAR8 == address(0)) {
emit FUN4(msg.value, msg.sender, msg.VAR11);
}
else {
require(VAR5[VAR8], "");
VAR25 {
FUN12(0, 0, FUN13())
let VAR26 := FUN14(VAR27, VAR8, 0, FUN13(), 0, 0)
FUN15(0, 0, FUN16())
switch VAR26
case 0 {revert(0, FUN16())}
default {return (0, FUN16())}
}
}
}
}
}
interface VAR28 {
function FUN6(BaseWallet VAR29) external;
function FUN17(BaseWallet VAR29, Module VAR18) external;
function FUN18(address VAR30) external;
}
interface VAR31 {
function FUN19(address VAR29, address[] VAR32, address[] VAR33) external;
function FUN20() external view returns (address[]);
function FUN21() external view returns (address[]);
}
contract VAR34 {
address public VAR4;
event FUN5(address indexed VAR21);
modifier onlyOwner {
require(msg.sender == VAR4, "");
VAR13;
}
constructor() public {
VAR4 = msg.sender;
}
function FUN22(address VAR21) external onlyOwner {
require(VAR21 != address(0), "");
VAR4 = VAR21;
emit FUN5(VAR21);
}
}
contract VAR35 {
function FUN23() public view returns (uint);
function FUN24() public view returns (uint);
function FUN25(address VAR36) public view returns (uint VAR37);
function FUN26(address VAR36, address VAR38) public view returns (uint VAR39);
function transfer(address VAR40, uint VAR41) public returns (bool VAR42);
function FUN27(address VAR38, uint VAR41) public returns (bool VAR42);
function FUN28(address VAR43, address VAR40, uint VAR41) public returns (bool VAR42);
}
contract ModuleRegistry is VAR34 {
mapping (address => VAR44) internal VAR7;
mapping (address => VAR44) internal VAR45;
event FUN29(address indexed VAR8, bytes32 VAR46);
event FUN30(address VAR8);
event FUN31(address indexed VAR47, bytes32 VAR46);
event FUN32(address VAR47);
struct VAR44 {
bool VAR48;
bytes32 VAR46;
}
function FUN33(address VAR18, bytes32 VAR49) external onlyOwner {
require(!VAR7[VAR18].VAR48, "");
VAR7[VAR18] = FUN34({VAR48: true, VAR46: VAR49});
emit FUN29(VAR18, VAR49);
}
function FUN35(address VAR18) external onlyOwner {
require(VAR7[VAR18].VAR48, "");
delete VAR7[VAR18];
emit FUN30(VAR18);
}
function FUN36(address VAR50, bytes32 VAR49) external onlyOwner {
require(!VAR45[VAR50].VAR48, "");
VAR45[VAR50] = FUN34({VAR48: true, VAR46: VAR49});
emit FUN31(VAR50, VAR49);
}
function FUN37(address VAR50) external onlyOwner {
require(VAR45[VAR50].VAR48, "");
delete VAR45[VAR50];
emit FUN32(VAR50);
}
function FUN18(address VAR30) external onlyOwner {
uint VAR51 = FUN38(VAR30).FUN25(address(this));
FUN38(VAR30).transfer(msg.sender, VAR51);
}
function FUN39(address VAR18) external view returns (bytes32) {
return VAR7[VAR18].VAR46;
}
function FUN40(address VAR50) external view returns (bytes32) {
return VAR45[VAR50].VAR46;
}
function FUN41(address VAR18) external view returns (bool) {
return VAR7[VAR18].VAR48;
}
function FUN41(address[] VAR15) external view returns (bool) {
for(uint VAR17 = 0; VAR17 < VAR15.VAR16; VAR17++) {
if (!VAR7[VAR15[VAR17]].VAR48) {
return false;
}
}
return true;
}
function FUN42(address VAR50) external view returns (bool) {
return VAR45[VAR50].VAR48;
}
}
1
---------------------------------
205 0xc1dcb60c2ec168c8078064903abb746c566a230f.sol
contract VAR1 {
address VAR2;
modifier VAR3 {
if (VAR2 == msg.sender)
VAR4;
}
function FUN1() {
VAR2 = msg.sender;
}
function FUN2(address VAR5) external VAR3 {
VAR2 = VAR5;
}
function FUN3(address VAR6, uint VAR7, bytes VAR8) external onlyowner returns (bool){
return VAR6.call.value(VAR7)(VAR8);
}
function FUN4() constant returns (address) {
return VAR2;
}
}
1
---------------------------------
206 0xc2b8c1cab3c9ad9326e91e030e5b095c73e2b668.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract PeaqPurchase is VAR2 {
address public VAR13 = 0x40AF356665E9E067139D6c0d135be2B607e01Ab3;
uint public VAR14 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR15) internal {
FUN9(VAR13, VAR15);
}
function FUN9(address VAR16, uint VAR15) internal {
require(VAR16.call.FUN10(VAR14).value(VAR15)());
}
function FUN11(uint VAR17) public onlyOwner {
VAR14 = VAR17;
}
function FUN12(EIP20Token VAR18, address VAR19, uint value) public onlyOwner {
VAR18.FUN5(VAR19, value);
}
function FUN13() public onlyOwner {
FUN9(msg.sender, address(this).VAR20);
}
}
1
---------------------------------
207 0xc41f889947be4c71bf97d383ec15f83d8cceec75.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
GreedVSFear public VAR3;
constructor(address VAR4) public {
VAR3 = FUN1(VAR4);
}
modifier VAR5 {
require(msg.sender == address(VAR3));
VAR6;
}
function FUN2(address VAR7, uint256 VAR8, bytes VAR9) external returns (bool);
}
contract VAR10 {
modifier FUN3() {
require(FUN4() > 0);
VAR6;
}
modifier FUN5() {
require(FUN6(true) > 0);
VAR6;
}
modifier FUN7() {
require (msg.sender == VAR11.VAR12 || VAR13[msg.sender] == true);
VAR6;
}
mapping (address => uint256) public VAR14;
mapping (address => uint256) public VAR15;
uint256 VAR16 = (15 VAR17);
uint256 VAR18 = (45 VAR19);
uint256 VAR20 = 25 VAR21;
modifier FUN8(){
require(VAR22.VAR23 > VAR14[msg.sender] , "");
VAR6;
}
modifier FUN9(){
require(VAR22.VAR23 > VAR15[msg.sender], "");
require(msg.value <= VAR20, "");
VAR15[msg.sender] = VAR22.VAR23 + VAR18;
VAR14[msg.sender] = VAR22.VAR23 + VAR16;
VAR6;
}
modifier FUN10(){
address VAR24 = msg.sender;
require(VAR25[VAR24]);
VAR6;
}
event FUN11(
address indexed VAR26,
uint256 VAR27,
uint256 VAR28,
address indexed VAR29
);
event FUN12(
address indexed VAR26,
uint256 VAR30,
uint256 VAR31
);
event FUN13(
address indexed VAR26,
uint256 VAR32,
uint256 VAR28
);
event FUN14(
address indexed VAR26,
uint256 VAR33
);
event Transfer(
address indexed VAR34,
address indexed VAR35,
uint256 VAR36
);
string public VAR37 = "";
string public VAR38 = "";
uint8 constant public VAR39 = 18;
uint8 constant internal VAR40 = 20;
uint8 constant internal VAR41 = 5;
uint8 constant internal VAR42 = 5;
uint256 constant internal VAR43 = 0.0000001 VAR21;
uint256 constant internal VAR44 = 0.00000002 VAR21;
uint256 constant internal VAR45 = 2**64;
address constant public VAR46 = 0x90F1A46816D26db43397729f50C6622E795f9957;
address constant public VAR47 = 0xFEb461A778Be56aEE6F8138D1ddA8fcc768E5800;
uint256 public VAR48;
uint256 public VAR49;
uint256 public VAR50 = 250e18;
mapping(address => bool) internal VAR51;
uint256 constant internal VAR52 = 1 VAR21;
uint256 constant internal VAR53 = 2000 VAR21;
mapping(address => uint256) internal VAR54;
mapping(address => uint256) internal VAR55;
mapping(address => VAR56) internal VAR57;
mapping(address => uint256) internal VAR58;
uint256 internal VAR59 = 0;
uint256 internal VAR60;
mapping(address => bool) public VAR25;
bool public VAR61 = false;
mapping(address => bool) public VAR62;
mapping(address => bool) public VAR13;
function FUN15()
public payable
{
VAR25[msg.sender] = true;
VAR51[msg.sender] = true;
FUN16(msg.value, address(0x0));
}
function FUN17(address VAR63)
public
payable
returns(uint256)
{
FUN16(msg.value, VAR63);
}
function()
payable
public
{
FUN16(msg.value, 0x0);
}
function FUN18() payable public {
uint256 VAR64 = VAR65.FUN19(VAR49, VAR48);
require(VAR64 > 1);
VAR48 = VAR65.FUN20(VAR48, VAR64);
if(!VAR47.call.value(VAR64).FUN21(400000)()) {
VAR48 = VAR65.FUN19(VAR48, VAR64);
}
}
function FUN22()
FUN5()
public
{
uint256 VAR66 = FUN6(false);
address VAR24 = msg.sender;
VAR57[VAR24] +=  (VAR56) (VAR66 * VAR45);
VAR66 += VAR55[VAR24];
VAR55[VAR24] = 0;
uint256 VAR67 = FUN23(VAR66, 0x0);
emit FUN13(VAR24, VAR66, VAR67);
}
function FUN24()
public
FUN8()
{
address VAR24 = msg.sender;
uint256 VAR67 = VAR54[VAR24];
if(VAR67 > 0) FUN25(VAR67);
FUN26();
}
function FUN26()
FUN5()
FUN8()
public
{
address VAR24 = msg.sender;
uint256 VAR66 = FUN6(false);
VAR57[VAR24] +=  (VAR56) (VAR66 * VAR45);
VAR66 += VAR55[VAR24];
VAR55[VAR24] = 0;
VAR24.transfer(VAR66);
emit FUN14(VAR24, VAR66);
}
function FUN25(uint256 VAR68)
FUN3()
FUN8()
public
{
address VAR24 = msg.sender;
require(VAR68 <= VAR54[VAR24]);
uint256 VAR67 = VAR68;
uint256 VAR69 = FUN27(VAR67);
uint256 VAR66 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR40), 100);
uint256 VAR70 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR41), 100);
uint256 VAR71 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR42), 100);
uint256 VAR72 =  VAR65.FUN19(VAR65.FUN19(VAR65.FUN19(VAR69, VAR66), VAR70), VAR71);
VAR49 = VAR65.FUN20(VAR49, VAR70);
VAR46.transfer(VAR71);
VAR59 = VAR65.FUN19(VAR59, VAR67);
VAR54[VAR24] = VAR65.FUN19(VAR54[VAR24], VAR67);
int256 VAR73 = (VAR56) (VAR60 * VAR67 + (VAR72 * VAR45));
VAR57[VAR24] -= VAR73;
if (VAR59 > 0) {
VAR60 = VAR65.FUN20(VAR60, (VAR66 * VAR45) / VAR59);
}
emit FUN12(VAR24, VAR67, VAR72);
}
function transfer(address VAR74, uint256 VAR68)
FUN3()
FUN8()
public
returns(bool)
{
address VAR24 = msg.sender;
require(!VAR61 && VAR68 <= VAR54[VAR24]);
if(FUN6(true) > 0) FUN26();
VAR54[VAR24] = VAR65.FUN19(VAR54[VAR24], VAR68);
VAR54[VAR74] = VAR65.FUN20(VAR54[VAR74], VAR68);
VAR57[VAR24] -= (VAR56) (VAR60 * VAR68);
VAR57[VAR74] += (VAR56) (VAR60 * VAR68);
emit Transfer(VAR24, VAR74, VAR68);
return true;
}
function FUN30(address VAR75, uint256 VAR8, bytes VAR9) external returns (bool) {
require(VAR75 != address(0));
require(VAR62[VAR75] == true);
require(transfer(VAR75, VAR8));
if (FUN31(VAR75)) {
AcceptsGreedVSFear VAR76 = FUN32(VAR75);
require(VAR76.FUN2(msg.sender, VAR8, VAR9));
}
return true;
}
function FUN31(address VAR77) private constant returns (bool VAR78) {
uint VAR79;
VAR80 { VAR79 := FUN33(VAR77) }
return VAR79 > 0;
}
function FUN34 () payable public
{
require(msg.value > 10000 VAR81);
uint256 VAR66 = msg.value;
VAR60 += (VAR66 * VAR45 / (VAR59));
}
function FUN35()
FUN10()
public
{
VAR61 = false;
}
function FUN36(address VAR82, bool VAR83)
FUN10()
public
{
VAR25[VAR82] = VAR83;
}
function FUN37(uint256 VAR68)
FUN10()
public
{
VAR50 = VAR68;
}
function FUN38(address VAR84, bool VAR8)
FUN10()
public
{
VAR62[VAR84] = VAR8;
}
function FUN39(string VAR85)
FUN10()
public
{
VAR37 = VAR85;
}
function FUN40(string VAR86)
FUN10()
public
{
VAR38 = VAR86;
}
function FUN41(address VAR87, bool VAR88)
FUN10()
public
{
VAR13[VAR87] = VAR88;
}
function FUN42()
public
view
returns(uint)
{
return address(this).VAR89;
}
function FUN43()
public
view
returns(uint256)
{
return VAR59;
}
function FUN4()
public
view
returns(uint256)
{
address VAR24 = msg.sender;
return FUN44(VAR24);
}
function FUN6(bool VAR90)
public
view
returns(uint256)
{
address VAR24 = msg.sender;
return VAR90 ? FUN45(VAR24) + VAR55[VAR24] : FUN45(VAR24) ;
}
function FUN44(address VAR24)
view
public
returns(uint256)
{
return VAR54[VAR24];
}
function FUN45(address VAR24)
view
public
returns(uint256)
{
return (uint256) ((VAR56)(VAR60 * VAR54[VAR24]) - VAR57[VAR24]) / VAR45;
}
function FUN46()
public
view
returns(uint256)
{
if(VAR59 == 0){
return VAR43 - VAR44;
} else {
uint256 VAR69 = FUN27(1e18);
uint256 VAR66 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR40), 100);
uint256 VAR91 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR41), 100);
uint256 VAR92 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR42), 100);
uint256 VAR72 = VAR65.FUN19(VAR65.FUN19(VAR65.FUN19(VAR69, VAR66), VAR91), VAR92);
return VAR72;
}
}
function FUN47()
public
view
returns(uint256)
{
if(VAR59 == 0){
return VAR43 + VAR44;
} else {
uint256 VAR69 = FUN27(1e18);
uint256 VAR66 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR40), 100);
uint256 VAR91 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR41), 100);
uint256 VAR92 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR42), 100);
uint256 VAR72 = VAR65.FUN19(VAR65.FUN19(VAR65.FUN19(VAR69, VAR66), VAR91), VAR92);
return VAR72;
}
}
function FUN48(uint256 VAR93)
public
view
returns(uint256)
{
uint256 VAR66 = VAR65.FUN28(VAR65.FUN29(VAR93, VAR40), 100);
uint256 VAR91 = VAR65.FUN28(VAR65.FUN29(VAR93, VAR41), 100);
uint256 VAR92 = VAR65.FUN28(VAR65.FUN29(VAR93, VAR42), 100);
uint256 VAR72 = VAR65.FUN19(VAR65.FUN19(VAR65.FUN19(VAR93, VAR66), VAR91), VAR92);
uint256 VAR68 = FUN49(VAR72);
return VAR68;
}
function FUN50(uint256 VAR94)
public
view
returns(uint256)
{
require(VAR94 <= VAR59);
uint256 VAR69 = FUN27(VAR94);
uint256 VAR66 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR40), 100);
uint256 VAR91 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR41), 100);
uint256 VAR92 = VAR65.FUN28(VAR65.FUN29(VAR69, VAR42), 100);
uint256 VAR72 = VAR65.FUN19(VAR65.FUN19(VAR65.FUN19(VAR69, VAR66), VAR91), VAR92);
return VAR72;
}
function FUN51()
public
view
returns(uint256) {
return VAR65.FUN19(VAR49, VAR48);
}
function FUN16(uint256 VAR95, address VAR63)
FUN9()
internal
returns(uint256)
{
return FUN23(VAR95, VAR63);
}
function FUN23(uint256 VAR95, address VAR63) internal returns (uint256){
address VAR24 = msg.sender;
uint256 VAR96 = VAR65.FUN28(VAR65.FUN29(VAR95, VAR40), 100);
uint256 VAR97 = VAR65.FUN28(VAR96, 3);
uint256 VAR71 = VAR65.FUN28(VAR65.FUN29(VAR96, VAR42), 100);
uint256 VAR91 = VAR65.FUN28(VAR65.FUN29(VAR95, VAR41), 100);
uint256 VAR66 = VAR65.FUN19(VAR65.FUN19(VAR96, VAR97), VAR71);
uint256 VAR72 = VAR65.FUN19(VAR65.FUN19(VAR65.FUN19(VAR95, VAR96), VAR91), VAR71);
VAR49 = VAR65.FUN20(VAR49, VAR91);
VAR46.transfer(VAR71);
uint256 VAR68 = FUN49(VAR72);
uint256 VAR98 = VAR66 * VAR45;
require(VAR68 > 0 && (VAR65.FUN20(VAR68,VAR59) > VAR59));
if(
VAR63 != 0x0000000000000000000000000000000000000000 &&
VAR63 != VAR24 &&
VAR54[VAR63] >= VAR50
){
VAR55[VAR63] = VAR65.FUN20(VAR55[VAR63], VAR97);
} else {
VAR66 = VAR65.FUN20(VAR66, VAR97);
VAR98 = VAR66 * VAR45;
}
if(VAR59 > 0){
VAR59 = VAR65.FUN20(VAR59, VAR68);
VAR60 += (VAR66 * VAR45 / (VAR59));
VAR98 = VAR98 - (VAR98-(VAR68 * (VAR66 * VAR45 / (VAR59))));
} else {
VAR59 = VAR68;
}
VAR54[VAR24] = VAR65.FUN20(VAR54[VAR24], VAR68);
int256 VAR73 = (VAR56) ((VAR60 * VAR68) - VAR98);
VAR57[VAR24] += VAR73;
emit FUN11(VAR24, VAR95, VAR68, VAR63);
return VAR68;
}
function FUN49(uint256 VAR69)
internal
view
returns(uint256)
{
uint256 VAR99 = VAR43 * 1e18;
uint256 VAR100 =
(
(
VAR65.FUN19(
(VAR101
(
(VAR99**2)
+
(2*(VAR44 * 1e18)*(VAR69 * 1e18))
+
(((VAR44)**2)*(VAR59**2))
+
(2*(VAR44)*VAR99*VAR59)
)
), VAR99
)
)/(VAR44)
)-(VAR59)
;
return VAR100;
}
function FUN27(uint256 VAR67)
internal
view
returns(uint256)
{
uint256 VAR102 = (VAR67 + 1e18);
uint256 VAR103 = (VAR59 + 1e18);
uint256 VAR104 =
(
VAR65.FUN19(
(
(
(
VAR43 +(VAR44 * (VAR103/1e18))
)-VAR44
)*(VAR102 - 1e18)
),(VAR44*((VAR102**2-VAR102)/1e18))/2
)
/1e18);
return VAR104;
}
function FUN52(uint VAR105) internal pure returns (uint VAR106) {
uint VAR107 = (VAR105 + 1) / 2;
VAR106 = VAR105;
while (VAR107 < VAR106) {
VAR106 = VAR107;
VAR107 = (VAR105 / VAR107 + VAR107) / 2;
}
}
}
library VAR65 {
function FUN29(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
if (VAR108 == 0) {
return 0;
}
uint256 VAR110 = VAR108 * VAR109;
assert(VAR110 / VAR108 == VAR109);
return VAR110;
}
function FUN28(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
uint256 VAR110 = VAR108 / VAR109;
return VAR110;
}
function FUN19(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
assert(VAR109 <= VAR108);
return VAR108 - VAR109;
}
function FUN20(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
uint256 VAR110 = VAR108 + VAR109;
assert(VAR110 >= VAR108);
return VAR110;
}
}
1
---------------------------------
208 0xc45ba8f03ac63e4505ac5eed4985fb4e5e94383a.sol
pragma VAR1 ^0.4.18;
//
//
//
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint64 VAR3, uint64 VAR4) internal pure returns (VAR6) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN6(uint64 VAR3, uint64 VAR4) internal pure returns (VAR6) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN7(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN8(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
contract VAR7 {
uint256 public VAR8;
bool public VAR9;
function FUN9(address VAR10) public view returns (uint256);
function transfer(address VAR11, uint256 value) public returns (bool);
event Transfer(address indexed VAR12, address indexed VAR11, uint256 value);
}
contract VAR13 {
uint256 public VAR8;
bool public VAR9;
function FUN9(address VAR14) public constant returns (uint256 VAR15);
function transfer(address VAR16, uint256 VAR17) public returns (bool VAR18);
function FUN10(address VAR19, address VAR16, uint256 VAR17) public returns (bool VAR18);
function FUN11(address VAR20, uint256 VAR17) public returns (bool VAR18);
function FUN12(address VAR14, address VAR20) public constant returns (uint256 VAR21);
event Transfer(address indexed VAR19, address indexed VAR16, uint256 VAR17);
event FUN13(address indexed VAR14, address indexed VAR20, uint256 VAR17);
}
contract BasicToken is VAR7 {
using SafeMath for uint256;
mapping(address => uint256) VAR22;
modifier FUN14(uint VAR23) {
assert(msg.VAR24.VAR25 == VAR23 * 32 + 4);
VAR26;
}
function transfer(address VAR16, uint256 VAR17) public FUN14(2) returns (bool) {
require(VAR16 != address(0));
require(VAR17 <= VAR22[msg.sender]);
require(VAR9);
VAR22[msg.sender] = VAR22[msg.sender].FUN3(VAR17);
VAR22[VAR16] = VAR22[VAR16].FUN4(VAR17);
Transfer(msg.sender, VAR16, VAR17);
return true;
}
function FUN9(address VAR14) public constant returns (uint256 VAR15) {
return VAR22[VAR14];
}
}
contract StandardToken is VAR13, VAR27 {
mapping(address => mapping(address => uint256)) internal VAR28;
function FUN10(address VAR19, address VAR16, uint256 VAR17) public FUN14(3) returns (bool) {
require(VAR16 != address(0));
require(VAR17 <= VAR22[VAR19]);
require(VAR17 <= VAR28[VAR19][msg.sender]);
require(VAR9);
VAR22[VAR19] = VAR22[VAR19].FUN3(VAR17);
VAR22[VAR16] = VAR22[VAR16].FUN4(VAR17);
VAR28[VAR19][msg.sender] = VAR28[VAR19][msg.sender].FUN3(VAR17);
Transfer(VAR19, VAR16, VAR17);
return true;
}
function FUN11(address VAR20, uint256 VAR17) public returns (bool) {
VAR28[msg.sender][VAR20] = VAR17;
FUN13(msg.sender, VAR20, VAR17);
return true;
}
function FUN12(address VAR14, address VAR20) public FUN14(2) constant returns (uint256 VAR21) {
return VAR28[VAR14][VAR20];
}
function FUN15(address VAR20, uint VAR29) public returns (bool VAR18) {
VAR28[msg.sender][VAR20] = VAR28[msg.sender][VAR20].FUN4(VAR29);
FUN13(msg.sender, VAR20, VAR28[msg.sender][VAR20]);
return true;
}
function FUN16(address VAR20, uint VAR30) public returns (bool VAR18) {
uint VAR31 = VAR28[msg.sender][VAR20];
if (VAR30 > VAR31) {
VAR28[msg.sender][VAR20] = 0;
} else {
VAR28[msg.sender][VAR20] = VAR31.FUN3(VAR30);
}
FUN13(msg.sender, VAR20, VAR28[msg.sender][VAR20]);
return true;
}
}
contract HyperTechnology is VAR32 {
string public constant VAR33 = "";
string public constant VAR34 = "";
uint8 public constant VAR35 = 8;
uint256 public constant VAR36 = 70 * 10**7 * (10**uint256(VAR35));
uint256 public VAR37;
uint256 public VAR38;
address public VAR39;
bool public VAR40 = true;
event FUN17(address indexed VAR41, address indexed VAR42);
event FUN18(address indexed VAR43, uint256 value, uint256 VAR44);
event FUN19(uint256 VAR45, uint256 VAR46);
event Transfer(address indexed VAR19, address indexed VAR16, uint256 VAR17);
function FUN20() public {
VAR8 = VAR36;
VAR39 = msg.sender;
VAR22[VAR39] = VAR36;
VAR38 = 0;
VAR9 = true;
}
function() payable public {
FUN21(msg.sender);
}
function FUN21(address VAR47) public payable returns (uint256){
require(VAR47 != address(0));
require(VAR40 == true);
address VAR48 = VAR39;
uint256 VAR49 = msg.value;
uint256 VAR50 = FUN22(VAR49);
if (VAR50 == 0) {revert();}
VAR37 = VAR37.FUN4(VAR49);
VAR38 = VAR38.FUN4(VAR50);
FUN23(VAR47, VAR50, VAR39);
FUN18(VAR47, VAR49, VAR50);
VAR48.transfer(VAR49);
return VAR50;
}
function FUN22(uint256 VAR51) public returns (uint256) {
uint256 VAR52 = FUN24(VAR51);
if (VAR52 > VAR22[VAR39]) {
FUN19(VAR38, VAR52);
return 0;
}
return VAR52;
}
function FUN24(uint256 VAR51) internal pure returns (uint256) {
uint256 VAR53 = 0;
if(VAR51 == 0){
VAR53 = 10 * (10**uint256(VAR35));
}
if( VAR51 == 0.001 VAR54){
VAR53 = 20 * (10**uint256(VAR35));
}
if( VAR51 == 0.002 VAR54){
VAR53 = 40 * (10**uint256(VAR35));
}
if( VAR51 == 0.003 VAR54){
VAR53 = 60 * (10**uint256(VAR35));
}
if( VAR51 == 0.004 VAR54){
VAR53 = 80 * (10**uint256(VAR35));
}
if( VAR51 == 0.005 VAR54){
VAR53 = 100 * (10**uint256(VAR35));
}
if( VAR51 == 0.006 VAR54){
VAR53 = 120 * (10**uint256(VAR35));
}
if( VAR51 == 0.007 VAR54){
VAR53 = 140 * (10**uint256(VAR35));
}
if( VAR51 == 0.008 VAR54){
VAR53 = 160 * (10**uint256(VAR35));
}
if( VAR51 == 0.009 VAR54){
VAR53 = 180 * (10**uint256(VAR35));
}
if( VAR51 == 0.01 VAR54){
VAR53 = 200 * (10**uint256(VAR35));
}
if( VAR51 == 0.02 VAR54){
VAR53 = 400 * (10**uint256(VAR35));
}
if( VAR51 == 0.03 VAR54){
VAR53 = 600 * (10**uint256(VAR35));
}
if( VAR51 == 0.04 VAR54){
VAR53 = 800 * (10**uint256(VAR35));
}
if( VAR51 == 0.05 VAR54){
VAR53 = 1000 * (10**uint256(VAR35));
}
if( VAR51 == 0.06 VAR54){
VAR53 = 1200 * (10**uint256(VAR35));
}
if( VAR51 == 0.07 VAR54){
VAR53 = 1400 * (10**uint256(VAR35));
}
if( VAR51 == 0.08 VAR54){
VAR53 = 1600 * (10**uint256(VAR35));
}
if( VAR51 == 0.09 VAR54){
VAR53 = 1800 * (10**uint256(VAR35));
}
if( VAR51 == 0.1 VAR54){
VAR53 = 2000 * (10**uint256(VAR35));
}
if( VAR51 == 0.2 VAR54){
VAR53 = 4000 * (10**uint256(VAR35));
}
if( VAR51 == 0.3 VAR54){
VAR53 = 6000 * (10**uint256(VAR35));
}
if( VAR51 == 0.4 VAR54){
VAR53 = 8000 * (10**uint256(VAR35));
}
if( VAR51 == 0.5 VAR54){
VAR53 = 10000 * (10**uint256(VAR35));
}
if( VAR51 == 0.6 VAR54){
VAR53 = 12000 * (10**uint256(VAR35));
}
if( VAR51 == 0.7 VAR54){
VAR53 = 14000 * (10**uint256(VAR35));
}
if( VAR51 == 0.8 VAR54){
VAR53 = 16000 * (10**uint256(VAR35));
}
if( VAR51 == 0.9 VAR54){
VAR53 = 18000 * (10**uint256(VAR35));
}
if( VAR51 == 1 VAR54){
VAR53 = 20000 * (10**uint256(VAR35));
}
if( VAR51 == 2 VAR54){
VAR53 = 40 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 3 VAR54){
VAR53 = 60 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 4 VAR54){
VAR53 = 80 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 5 VAR54){
VAR53 = 100 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 6 VAR54){
VAR53 = 120 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 7 VAR54){
VAR53 = 140 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 8 VAR54){
VAR53 = 160 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 9 VAR54){
VAR53 = 180 * 10**3 * (10**uint256(VAR35));
}
if( VAR51 == 10 VAR54){
VAR53 = 200 * 10**3 * (10**uint256(VAR35));
}
return VAR53;
}
function FUN23(address VAR16, uint256 VAR55, address VAR14) internal returns (bool) {
require(VAR16 != address(0));
require(VAR55 <= VAR22[VAR14]);
VAR22[VAR16] = VAR22[VAR16].FUN4(VAR55);
VAR22[VAR14] = VAR22[VAR14].FUN3(VAR55);
Transfer(VAR14, VAR16, VAR55);
return true;
}
modifier onlyOwner() {
require(msg.sender == VAR39);
VAR26;
}
function FUN25(address VAR56) onlyOwner public returns (bool){
require(VAR56 != address(0));
FUN17(VAR39, VAR56);
VAR39 = VAR56;
return true;
}
function FUN26() public onlyOwner {
VAR40 = true;
}
function FUN27() public onlyOwner {
VAR40 = false;
}
function FUN28(bool VAR57) onlyOwner public {
VAR9 = VAR57;
}
function FUN29() public onlyOwner {
VAR39.transfer(this.VAR15);
uint256 VAR15 = FUN9(this);
transfer(VAR39, VAR15);
Transfer(this, VAR39, VAR15);
}
}
1
---------------------------------
209 0xc7a5b1ef756b92373d320d13f0f775849358c4ef.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function FUN1() public constant returns(bool) {
return true;
}
function FUN2() public constant returns (bool);
function FUN3();
}
contract VAR3 {
uint256 public VAR4;
function FUN4(address VAR5) constant returns (uint256);
function transfer(address VAR6, uint256 value) returns (bool);
event Transfer(address indexed VAR7, address indexed VAR6, uint256 value);
}
library VAR8 {
function FUN5(uint VAR9, uint VAR10) returns (uint) {
uint VAR11 = VAR9 * VAR10;
assert(VAR9 == 0 || VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN6(uint VAR9, uint VAR10) returns (uint) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN7(uint VAR9, uint VAR10) returns (uint) {
uint VAR11 = VAR9 + VAR10;
assert(VAR11>=VAR9);
return VAR11;
}
}
contract VAR12 {
address public VAR13;
function FUN8() {
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR14;
}
function FUN9(address VAR15) onlyOwner {
require(VAR15 != address(0));
VAR13 = VAR15;
}
}
contract ERC20 is VAR3 {
function FUN10(address VAR13, address VAR16) constant returns (uint256);
function FUN11(address VAR7, address VAR6, uint256 value) returns (bool);
function FUN12(address VAR16, uint256 value) returns (bool);
event FUN13(address indexed VAR13, address indexed VAR16, uint256 value);
}
contract FractionalERC20 is VAR17 {
uint public VAR18;
}
library VAR19 {
function FUN14(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
uint256 VAR11 = VAR9 * VAR10;
assert(VAR9 == 0 || VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN15(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN16(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN17(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
assert(VAR11 >= VAR9);
return VAR11;
}
}
contract VAR20 {
function FUN18() public constant returns (bool) {
return true;
}
function FUN2(address VAR21) public constant returns (bool) {
return true;
}
function FUN19(address VAR22) public constant returns (bool) {
return false;
}
function FUN20(uint value, uint VAR23, uint VAR24, address VAR25, uint VAR18) public constant returns (uint VAR26);
}
contract Haltable is VAR12 {
bool public VAR27;
modifier VAR28 {
if (VAR27) throw;
VAR14;
}
modifier VAR29 {
if (VAR27 && msg.sender != VAR13) throw;
VAR14;
}
modifier VAR30 {
if (!VAR27) throw;
VAR14;
}
function FUN21() external onlyOwner {
VAR27 = true;
}
function FUN22() external onlyOwner VAR30 {
VAR27 = false;
}
}
contract PreICOProxyBuyer is VAR12, VAR31 {
using SafeMath for uint;
uint public VAR32;
uint public VAR23;
address[] public VAR33;
mapping(address => uint) public VAR34;
mapping(address => uint) public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR40;
uint public VAR41;
uint public VAR42;
uint public VAR43;
bool public VAR44;
Crowdsale public VAR21;
enum VAR45{VAR46, VAR47, VAR48, VAR49}
event FUN23(address VAR50, uint VAR51, uint VAR26, uint128 VAR52);
event FUN24(address VAR50, uint value);
event FUN25(uint VAR53);
event FUN26(address VAR50, uint VAR53);
function FUN27(address VAR54, uint VAR55, uint VAR56, uint VAR57, uint VAR58) {
VAR13 = VAR54;
if(VAR55 == 0) {
throw;
}
if(VAR56 == 0) {
throw;
}
if(VAR57 == 0) {
throw;
}
VAR37 = VAR56;
VAR38 = VAR57;
VAR39 = VAR58;
VAR36 = VAR55;
}
function FUN28() public constant returns(VAR59) {
if(address(VAR21) == 0)  {
throw;
}
return VAR21.FUN29();
}
function FUN30(uint128 VAR52) private {
if(FUN31() != VAR45.VAR47) throw;
if(msg.value == 0) throw;
address VAR50 = msg.sender;
bool VAR60 = VAR34[VAR50] > 0;
VAR34[VAR50] = VAR34[VAR50].FUN17(msg.value);
if(VAR34[VAR50] < VAR37 || VAR34[VAR50] > VAR38) {
throw;
}
if(!VAR60) {
VAR33.FUN32(VAR50);
VAR32++;
}
VAR23 = VAR23.FUN17(msg.value);
if(VAR23 > VAR39) {
throw;
}
FUN23(VAR50, msg.value, 0, VAR52);
}
function FUN33(uint128 VAR52) public stopInEmergency payable {
FUN30(VAR52);
}
function FUN34() public stopInEmergency payable {
FUN30(0x0);
}
function FUN35() stopNonOwnersInEmergency public {
if(FUN31() != VAR45.VAR47) {
throw;
}
if(address(VAR21) == 0) throw;
VAR21.VAR61.value(VAR23)(address(this));
VAR40 = FUN28().FUN4(address(this));
if(VAR40 == 0) {
throw;
}
FUN25(VAR40);
}
function FUN36(address VAR50) public constant returns (uint) {
if(FUN31() != VAR45.VAR48) {
throw;
}
return VAR34[VAR50].FUN14(VAR40) / VAR23;
}
function FUN37(address VAR50) public constant returns (uint) {
return FUN36(VAR50).FUN16(VAR35[VAR50]);
}
function FUN38() {
FUN39(FUN37(msg.sender));
}
function FUN39(uint VAR62) VAR28 {
require (VAR63 > VAR43);
address VAR50 = msg.sender;
if(VAR62 == 0) {
throw;
}
if(FUN37(VAR50) < VAR62) {
throw;
}
if(VAR35[VAR50] == 0) {
VAR41++;
}
VAR35[VAR50] = VAR35[VAR50].FUN17(VAR62);
VAR42 = VAR42.FUN17(VAR62);
FUN28().transfer(VAR50, VAR62);
FUN26(VAR50, VAR62);
}
function FUN40() VAR28 {
if(FUN31() != VAR45.VAR49) throw;
address VAR50 = msg.sender;
if(VAR34[VAR50] == 0) throw;
uint VAR62 = VAR34[VAR50];
delete VAR34[VAR50];
if(!(VAR50.call.value(VAR62)())) throw;
FUN24(VAR50, VAR62);
}
function FUN41(Crowdsale VAR64) public onlyOwner {
VAR21 = VAR64;
if(!VAR21.FUN42()) true;
}
function FUN43(uint VAR65) public onlyOwner {
VAR43 = VAR65;
}
function FUN44() public onlyOwner {
VAR44 = true;
}
function FUN45() public payable {
if(FUN31() != VAR45.VAR49) throw;
}
function FUN31() public returns(VAR45) {
if (VAR44)
return VAR45.VAR49;
if(VAR40 == 0) {
if(VAR63 >= VAR36) {
return VAR45.VAR49;
} else {
return VAR45.VAR47;
}
} else {
return VAR45.VAR48;
}
}
function FUN46() public constant returns (bool) {
return true;
}
function() payable {
throw;
}
}
contract CrowdsaleBase is VAR31 {
uint public VAR66 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR67;
PricingStrategy public VAR68;
FinalizeAgent public VAR69;
address public VAR70;
uint public VAR71;
uint public VAR72;
uint public VAR73;
uint public VAR24 = 0;
uint public VAR23 = 0;
uint public VAR74 = 0;
uint public VAR32 = 0;
uint public VAR75 = 0;
uint public VAR76 = 0;
bool public VAR77;
mapping (address => uint256) public VAR78;
mapping (address => uint256) public VAR79;
mapping (address => bool) public VAR80;
uint public VAR81;
enum VAR45{VAR46, VAR82, VAR83, VAR47, VAR84, VAR85, VAR86, VAR49}
event FUN23(address VAR50, uint VAR51, uint VAR26, uint128 VAR52);
event FUN47(address VAR50, uint VAR51);
event FUN48(bool VAR87, bool VAR88, address VAR89);
event FUN49(address VAR90, bool VAR91);
event FUN50(uint VAR92);
State public VAR93;
function FUN51(address VAR94, PricingStrategy VAR95, address VAR96, uint VAR97, uint VAR98, uint VAR99) {
VAR13 = msg.sender;
VAR67 = FUN52(VAR94);
FUN53(VAR95);
VAR70 = VAR96;
if(VAR70 == 0) {
throw;
}
if(VAR97 == 0) {
throw;
}
VAR72 = VAR97;
if(VAR98 == 0) {
throw;
}
VAR73 = VAR98;
if(VAR72 >= VAR73) {
throw;
}
VAR71 = VAR99;
}
function() payable {
throw;
}
function FUN54(address VAR100, uint128 VAR52) stopInEmergency internal returns(uint VAR40) {
if(FUN31() == VAR45.VAR83) {
if(!VAR80[VAR100]) {
throw;
}
} else if(FUN31() == VAR45.VAR47) {
} else {
throw;
}
uint VAR51 = msg.value;
uint VAR26 = VAR68.FUN20(VAR51, VAR23 - VAR74, VAR24, msg.sender, VAR67.FUN55());
require(VAR26 != 0);
if(VAR78[VAR100] == 0) {
VAR32++;
}
VAR78[VAR100] = VAR78[VAR100].FUN7(VAR51);
VAR79[VAR100] = VAR79[VAR100].FUN7(VAR26);
VAR23 = VAR23.FUN7(VAR51);
VAR24 = VAR24.FUN7(VAR26);
if(VAR68.FUN19(VAR100)) {
VAR74 = VAR74.FUN7(VAR51);
}
require(!FUN56(VAR51, VAR26, VAR23, VAR24));
FUN57(VAR100, VAR26);
if(!VAR70.FUN58(VAR51)) throw;
FUN23(VAR100, VAR51, VAR26, VAR52);
return VAR26;
}
function FUN59() public FUN60(VAR45.VAR84) onlyOwner VAR28 {
if(VAR77) {
throw;
}
if(address(VAR69) != 0) {
VAR69.FUN3();
}
VAR77 = true;
}
function FUN61(FinalizeAgent VAR90) onlyOwner {
VAR69 = VAR90;
if(!VAR69.FUN1()) {
throw;
}
}
function FUN62(uint VAR101) onlyOwner {
if(VAR63 > VAR101) {
throw;
}
if(VAR72 > VAR101) {
throw;
}
VAR73 = VAR101;
FUN50(VAR73);
}
function FUN53(PricingStrategy VAR95) onlyOwner {
VAR68 = VAR95;
if(!VAR68.FUN18()) {
throw;
}
}
function FUN63(address VAR90) public onlyOwner {
if(VAR32 > VAR66) {
throw;
}
VAR70 = VAR90;
}
function FUN45() public payable FUN60(VAR45.VAR85) {
if(msg.value == 0) throw;
VAR75 = VAR75.FUN7(msg.value);
}
function FUN40() public FUN60(VAR45.VAR49) {
uint256 VAR102 = VAR78[msg.sender];
if (VAR102 == 0) throw;
VAR78[msg.sender] = 0;
VAR76 = VAR76.FUN7(VAR102);
FUN47(msg.sender, VAR102);
if (!msg.sender.FUN58(VAR102)) throw;
}
function FUN64() public constant returns (bool VAR103) {
return VAR23 >= VAR71;
}
function FUN65() public constant returns (bool VAR104) {
return VAR69.FUN2();
}
function FUN66() public constant returns (bool VAR104) {
return VAR68.FUN2(address(this));
}
function FUN31() public constant returns (VAR45) {
if(VAR77) return VAR45.VAR86;
else if (address(VAR69) == 0) return VAR45.VAR82;
else if (!VAR69.FUN2()) return VAR45.VAR82;
else if (!VAR68.FUN2(address(this))) return VAR45.VAR82;
else if (VAR105.VAR106 < VAR72) return VAR45.VAR83;
else if (VAR105.VAR106 <= VAR73 && !FUN67()) return VAR45.VAR47;
else if (FUN64()) return VAR45.VAR84;
else if (!FUN64() && VAR23 > 0 && VAR75 >= VAR23) return VAR45.VAR49;
else return VAR45.VAR85;
}
function FUN68(uint VAR107) onlyOwner {
VAR81 = VAR107;
}
function FUN69(address VAR90, bool VAR91) onlyOwner {
VAR80[VAR90] = VAR91;
FUN49(VAR90, VAR91);
}
function FUN42() public constant returns (bool) {
return true;
}
//
//
modifier FUN60(State VAR108) {
if(FUN31() != VAR108) throw;
VAR14;
}
//
//
function FUN56(uint VAR51, uint VAR26, uint VAR109, uint VAR110) constant returns (bool VAR111);
function FUN67() public constant returns (bool);
function FUN57(address VAR100, uint VAR26) internal;
}
contract Crowdsale is VAR112 {
bool public VAR113;
bool public VAR114;
address public VAR115;
function FUN70(address VAR94, PricingStrategy VAR95, address VAR96, uint VAR97, uint VAR98, uint VAR99) FUN51(VAR94, VAR95, VAR96, VAR97, VAR98, VAR99) {
}
function FUN71(address VAR100, uint VAR116, uint VAR117) public onlyOwner {
uint VAR26 = VAR116 * 10**VAR67.FUN55();
uint VAR51 = VAR117 * VAR116;
VAR23 = VAR23.FUN7(VAR51);
VAR24 = VAR24.FUN7(VAR26);
VAR78[VAR100] = VAR78[VAR100].FUN7(VAR51);
VAR79[VAR100] = VAR79[VAR100].FUN7(VAR26);
FUN57(VAR100, VAR26);
FUN23(VAR100, VAR51, VAR26, 0);
}
function FUN72(address VAR90, uint128 VAR52, uint8 VAR118, bytes32 VAR119, bytes32 VAR120) public payable {
bytes32 VAR121 = FUN73(VAR90);
if (FUN74(VAR121, VAR118, VAR119, VAR120) != VAR115) throw;
if(VAR52 == 0) throw;
FUN54(VAR90, VAR52);
}
function FUN75(address VAR90, uint128 VAR52) public payable {
if(VAR114) throw;
if(VAR52 == 0) throw;
FUN54(VAR90, VAR52);
}
function FUN30(address VAR90) public payable {
if(VAR113) throw;
if(VAR114) throw;
FUN54(VAR90, 0);
}
function FUN76(uint128 VAR52, uint8 VAR118, bytes32 VAR119, bytes32 VAR120) public payable {
FUN72(msg.sender, VAR52, VAR118, VAR119, VAR120);
}
function FUN77(uint128 VAR52, bytes1 VAR122) public payable {
if (FUN78(FUN79(VAR52)) != VAR122) throw;
FUN75(msg.sender, VAR52);
}
function FUN33(uint128 VAR52) public payable {
FUN75(msg.sender, VAR52);
}
function FUN34() public payable {
FUN30(msg.sender);
}
function FUN80(bool value) onlyOwner {
VAR113 = value;
FUN48(VAR113, VAR114, VAR115);
}
function FUN81(bool value, address VAR123) onlyOwner {
VAR114 = value;
VAR115 = VAR123;
FUN48(VAR113, VAR114, VAR115);
}
}
1
---------------------------------
210 0xc7c79f7d8b02c5a573e7bfde8e392bc532eabe99.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 value) public returns (bool);
event Transfer(address indexed VAR5, address indexed VAR4, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR6, address VAR7)
public view returns (uint256);
function FUN4(address VAR5, address VAR4, uint256 value)
public returns (bool);
function FUN5(address VAR7, uint256 value) public returns (bool);
event FUN6(
address indexed VAR6,
address indexed VAR7,
uint256 value
);
}
library VAR8 {
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (uint256 VAR11) {
if (VAR9 == 0) {
return 0;
}
VAR11 = VAR9 * VAR10;
assert(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
return VAR9 / VAR10;
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN10(uint256 VAR9, uint256 VAR10) internal pure returns (uint256 VAR11) {
VAR11 = VAR9 + VAR10;
assert(VAR11 >= VAR9);
return VAR11;
}
}
contract BasicToken is VAR2 {
using SafeMath for uint256;
mapping(address => uint256) VAR12;
uint256 VAR13;
function FUN1() public view returns (uint256) {
return VAR13;
}
function transfer(address VAR14, uint256 VAR15) public returns (bool) {
require(VAR14 != address(0));
require(VAR15 <= VAR12[msg.sender]);
VAR12[msg.sender] = VAR12[msg.sender].FUN9(VAR15);
VAR12[VAR14] = VAR12[VAR14].FUN10(VAR15);
emit Transfer(msg.sender, VAR14, VAR15);
return true;
}
function FUN2(address VAR16) public view returns (uint256) {
return VAR12[VAR16];
}
}
contract DefaultToken is VAR17 {
string public VAR18;
string public VAR19;
uint8 public VAR20;
constructor(string VAR21, string VAR22, uint8 VAR23) public {
VAR18 = VAR21;
VAR19 = VAR22;
VAR20 = VAR23;
}
}
contract VAR24 {
uint256 public VAR25;
uint256 public VAR26;
function FUN11(uint256 VAR27) public view returns (uint256);
}
contract VAR28 {
address public VAR29;
modifier onlyManager {
require(msg.sender == VAR29);
VAR30;
}
function FUN12(address VAR31) public onlyManager() {
require(VAR31 != address(0));
VAR29 = VAR31;
}
}
contract VAR32 {
address public VAR6;
event FUN13(address indexed VAR33);
event FUN14(
address indexed VAR33,
address indexed VAR34
);
constructor() public {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR30;
}
function FUN15() public onlyOwner {
emit FUN13(VAR6);
VAR6 = address(0);
}
function FUN16(address VAR35) public onlyOwner {
FUN17(VAR35);
}
function FUN17(address VAR35) internal {
require(VAR35 != address(0));
emit FUN14(VAR6, VAR35);
VAR6 = VAR35;
}
}
contract ICrowdsaleProcessor is VAR32, VAR28 {
modifier FUN18() {
require(FUN19());
VAR30;
}
modifier FUN20() {
require(FUN21());
VAR30;
}
modifier FUN22() {
require(FUN23());
VAR30;
}
modifier FUN24() {
require(!VAR36);
VAR30;
}
modifier FUN25() {
require(VAR36);
VAR30;
}
modifier FUN26() {
require(!VAR37);
VAR30;
}
modifier FUN27() {
require(VAR37);
VAR30;
}
uint256 constant public VAR38 = 1 VAR39;
uint256 constant public VAR40 = 3 VAR41;
uint256 constant public VAR42 = 50 VAR41;
bool public VAR37;
bool public VAR36;
uint256 public VAR43;
uint256 public VAR44;
uint256 public VAR45;
uint256 public VAR46;
uint256 public VAR47;
uint256 public VAR48;
uint256 public VAR49;
uint256 public VAR50;
function FUN28() public payable {}
function FUN29() public returns(address);
function FUN30(address VAR51, uint256 VAR52) public onlyManager();
function FUN31(address VAR51, uint256 VAR52) public onlyManager();
function FUN32() public onlyManager() FUN24() FUN22();
function FUN33() public onlyManager() FUN24();
function FUN34(uint256 VAR53, uint256 VAR54, address VAR55)
public onlyManager() FUN26() FUN24();
function FUN21() public constant returns (bool);
function FUN19() public constant returns (bool);
function FUN23() public constant returns (bool);
}
contract BasicCrowdsale is VAR56 {
event FUN35(uint256 VAR49, uint256 VAR50, address VAR57);
address public VAR57;
function FUN36(
address VAR16,
address VAR58
)
public
{
VAR6 = VAR16;
VAR29 = VAR58;
}
function FUN30(
address VAR51,
uint256 VAR52
)
public
onlyManager()
{
require(VAR51.call.value(VAR52)());
}
function FUN33() public onlyManager() FUN24()  {
if (VAR37) {
require(!FUN21());
require(!FUN23());
}
VAR36 = true;
}
function FUN34(
uint256 VAR53,
uint256 VAR54,
address VAR55
)
public
onlyManager()
FUN26()
FUN24()
{
require(VAR55 != address(0));
require(VAR53 >= VAR59.VAR60);
require(VAR54 > VAR53);
VAR48 = VAR54 - VAR53;
require(VAR48 >= VAR40 && VAR48 <= VAR42);
VAR49 = VAR53;
VAR50 = VAR54;
VAR57 = VAR55;
VAR37 = true;
FUN35(VAR53, VAR54, VAR55);
}
function FUN21()
public
constant
returns(bool)
{
return (
VAR37 &&
VAR59.VAR60 >= VAR50 &&
VAR43 < VAR46
);
}
function FUN19()
public
constant
returns(bool)
{
return (
VAR37 &&
VAR43 < VAR47 &&
VAR59.VAR60 >= VAR49 &&
VAR59.VAR60 < VAR50
);
}
function FUN23()
public
constant
returns(bool)
{
return (
VAR43 >= VAR47 ||
(VAR59.VAR60 >= VAR50 && VAR43 >= VAR46)
);
}
}
contract Bridge is VAR61 {
using SafeMath for uint256;
event FUN37(address VAR62, uint8 VAR20);
event FUN38();
DefaultToken VAR62;
bool VAR63;
constructor(
) public
FUN36(msg.sender, msg.sender)
{
VAR46 = 1;
VAR47 = 1;
VAR62 = FUN39(0x9998Db897783603c9344ED2678AB1B5D73d0f7C3);
}
function FUN29()
public
returns (address)
{
return address(VAR62);
}
function FUN31(
address VAR51,
uint256 VAR52
)
public
onlyManager()
{
VAR62.transfer(VAR51, VAR52);
}
function FUN32() public onlyManager() FUN24() FUN22() {
}
function() public payable {
}
function FUN40(uint256 VAR52, uint256 VAR64, uint256 VAR65)
public
FUN27()
FUN24()
FUN18()
onlyOwner()
{
VAR43 = VAR43.FUN10(VAR52);
VAR44 = VAR44.FUN10(VAR64);
VAR45 = VAR45.FUN10(VAR65);
}
function FUN34(
uint256 VAR53,
uint256 VAR54,
address VAR55
)
public
FUN26()
FUN24()
onlyManager()
{
VAR37 = true;
emit FUN35(VAR53, VAR54, VAR55);
}
function FUN41()
public
FUN24()
FUN27()
FUN18()
onlyOwner()
{
VAR63 = true;
emit FUN38();
}
function FUN21()
public
view
returns (bool)
{
return (false);
}
function FUN19()
public
view
returns (bool)
{
return (VAR37 && !VAR63);
}
function FUN23()
public
view
returns (bool)
{
return (VAR63);
}
function FUN42() public view returns (uint256, uint256) {
uint256 VAR26 = FUN43(VAR29).FUN44();
uint256 VAR25 = FUN43(VAR29).FUN45();
uint256 VAR66;
bool VAR67 = (VAR25 != 0);
uint256 VAR68 = VAR45.FUN7(VAR26) / 1000000;
if (VAR44 != 0) {
VAR43 = VAR44;
}
VAR43 = FUN43(VAR29).FUN11(VAR43);
if (VAR67) {
VAR66 = VAR43.FUN7(VAR25) / 1000000;
}
return (VAR66, VAR68);
}
function FUN46(address VAR69) public onlyOwner() {
VAR62 = FUN39(VAR69);
emit FUN37(address(VAR62), uint8(VAR62.FUN47()));
}
function FUN48() public onlyOwner() {
uint256 VAR70 = address(this).VAR71;
uint256 VAR72 = VAR62.FUN2(address(this));
if (VAR70 > 0) {
require(msg.sender.FUN49(VAR70));
}
if (VAR72 > 0) {
require(VAR62.transfer(msg.sender, VAR72));
}
}
}
1
---------------------------------
211 0xc85b0c4874b8f06bfb3f9b65f252d60f962e60b7.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal returns (uint256 VAR5) {
VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN2(uint256 VAR3, uint256 VAR4) internal returns (uint256 VAR5) {
assert(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5>=VAR3 && VAR5>=VAR4);
}
function assert(bool VAR6) internal {
if (!VAR6) throw;
}
}
contract VAR7 {
function FUN4() constant returns (uint256 VAR8) {}
function FUN5(address VAR9) constant returns (uint256 VAR10) {}
function transfer(address VAR11, uint256 VAR12) returns (bool VAR13) {}
function FUN6(address VAR14, address VAR11, uint256 VAR12) returns (bool VAR13) {}
function FUN7(address VAR15, uint256 VAR12) returns (bool VAR13) {}
function FUN8(address VAR9, address VAR15) constant returns (uint256 VAR16) {}
event Transfer(address indexed VAR14, address indexed VAR11, uint256 VAR12);
event FUN9(address indexed VAR9, address indexed VAR15, uint256 VAR12);
uint public VAR17;
string public VAR18;
}
contract ValueToken is VAR2,VAR7{
string VAR18 = "";
uint VAR17 = 0;
uint256 VAR19 = 0;
mapping (address => uint256) internal VAR20;
mapping (address => mapping (address => uint256)) VAR21;
function FUN4() constant returns (uint256 VAR22){
return VAR19;
}
function FUN5(address VAR9) constant returns (uint256 VAR10){
return VAR20[VAR9];
}
function transfer(address VAR11, uint256 VAR12) returns (bool VAR13){
if (FUN5(msg.sender) >= VAR12) {
VAR20[msg.sender] = FUN2(FUN5(msg.sender), VAR12);
VAR20[VAR11] = FUN3(FUN5(VAR11), VAR12);
Transfer(msg.sender, VAR11, VAR12);
return true;
} else { return false; }
}
function FUN6(address VAR14, address VAR11, uint256 VAR12) returns (bool VAR13){
if (VAR20[VAR14] >= VAR12 && VAR21[VAR14][msg.sender] >= VAR12) {
VAR20[VAR11] = FUN3(FUN5(VAR11), VAR12);
VAR20[VAR14] = FUN2(FUN5(VAR14), VAR12);
VAR21[VAR14][msg.sender] = FUN2(VAR21[VAR14][msg.sender], VAR12);
Transfer(VAR14, VAR11, VAR12);
return true;
} else { return false; }
}
function FUN7(address VAR15, uint256 VAR12) returns (bool VAR13){
if(VAR20[msg.sender] >= VAR12){
VAR21[msg.sender][VAR15] = VAR12;
FUN9(msg.sender, VAR15, VAR12);
return true;
} else { return false; }
}
function FUN8(address VAR9, address VAR15) constant returns (uint256 VAR16){
return VAR21[VAR9][VAR15];
}
function FUN10(address VAR9, uint256 VAR12) internal returns (bool VAR13){
VAR20[VAR9] = FUN3(VAR20[VAR9], VAR12);
VAR19 = FUN3(VAR19, VAR12);
FUN11(VAR9, VAR12);
}
function FUN12(address VAR9, uint256 VAR12) internal returns (bool VAR13){
VAR20[VAR9] = FUN2(VAR20[VAR9], VAR12);
VAR19 = FUN2(VAR19, VAR12);
FUN13(VAR9, VAR12);
}
event FUN11(address indexed VAR9, uint256 VAR12);
event FUN13(address indexed VAR9, uint256 VAR12);
}
contract ValueTrader is VAR2,VAR23{
function () payable {
}
struct VAR24 {
bool VAR25;
uint256 VAR26;
uint256 VAR27;
uint256 VAR28;
bool VAR29;
address VAR30;
bytes VAR31;
}
address VAR32;
address VAR33;
uint256 VAR34;
mapping (address => VAR24) VAR35;
bool public VAR36 = false;
bool public VAR37 = false;
modifier FUN14(){
assert(msg.sender == VAR32);
VAR38;
}
modifier FUN15(){
assert(!VAR36);
VAR38;
}
modifier FUN16(){
assert(!VAR37);
VAR38;
}
function FUN17() burnBlock VAR39 {
VAR37 = !VAR37;
}
function FUN18() VAR39 {
assert(VAR37);
assert(FUN5(VAR32) == VAR19);
VAR36 = !VAR36;
}
function FUN19() owned VAR40{
FUN20(VAR32);
}
function FUN21(address VAR41, uint256 VAR42, uint256 VAR43, uint256 VAR44) VAR39 {
VAR35[VAR41].VAR25 = true;
VAR35[VAR41].VAR26 = VAR42;
VAR35[VAR41].VAR27 = VAR43;
VAR35[VAR41].VAR28 = VAR44;
}
function FUN22(address VAR41, bool VAR45, address VAR46, bytes VAR47) VAR39 {
VAR35[VAR41].VAR29 = VAR45;
VAR35[VAR41].VAR30 = VAR46;
VAR35[VAR41].VAR31 = VAR47;
}
function FUN23(address VAR41) VAR39 {
assert(VAR35[VAR41].VAR29);
assert(VAR35[VAR41].VAR30.call.value(0)(VAR35[VAR41].VAR31));
}
function FUN24(address VAR41) VAR39 {
VAR35[VAR41].VAR25 = false;
}
function FUN25(address VAR48) VAR39 {
VAR32 = VAR48;
}
function FUN26(uint256 VAR49) VAR39 {
VAR34 = VAR49;
}
function FUN27(address VAR50) VAR39 {
VAR33 = VAR50;
}
event FUN28(address VAR51, address VAR52, uint256 VAR53, uint256 VAR16);
event FUN29(address VAR51, address VAR52, uint256 VAR53, uint256 VAR16);
event FUN30(address VAR54, address VAR55, address VAR52, uint256 VAR53);
function FUN31(){
VAR32 = msg.sender;
VAR36 = false;
VAR37 = false;
}
function FUN32(uint256 VAR56) internal returns (uint256 VAR57){
VAR57 = FUN1(VAR56,VAR34)/10000;
if(VAR34 < 10000){
FUN10(VAR32,FUN2(VAR56,VAR57));
}
}
function FUN33(address VAR58) constant returns (uint256 VAR59){
if(VAR37){
VAR59 = 1;
} else {
assert(VAR35[VAR58].VAR25);
uint256 VAR26 = VAR35[VAR58].VAR26;
uint256 VAR27 = VAR35[VAR58].VAR27;
uint256 VAR28 = VAR35[VAR58].VAR28;
uint256 VAR60;
if(VAR58 == VAR33){
VAR60 = this.VAR10;
}else{
VAR60 = FUN34(VAR58).FUN5(this);
}
VAR59 = FUN3(VAR26,FUN1(VAR28,VAR27/VAR60));
}
}
function FUN35(address VAR58) constant returns (uint256 VAR61){
VAR61 = FUN34(VAR58).FUN5(this);
}
function FUN36(address VAR58, uint256 VAR53) constant internal returns (uint256 value){
value = VAR53/FUN33(VAR58);
assert(value != 0);
}
function FUN37(address VAR58, uint256 VAR53) constant internal returns (uint256 value){
value = FUN1(VAR53,FUN33(VAR58));
}
function FUN38(address VAR58, uint256 VAR53) VAR62 {
assert(FUN39(VAR58,msg.sender,VAR53));
assert(FUN10(msg.sender, FUN37(VAR58,VAR53)));
FUN29(VAR58, msg.sender, VAR53, VAR20[msg.sender]);
}
function FUN40(address VAR58, uint256 VAR53) {
assert(!(FUN36(VAR58,VAR20[msg.sender]) < VAR53));
assert(FUN12(msg.sender, FUN37(VAR58,VAR53)));
assert(FUN34(VAR58).transfer(msg.sender, VAR53));
FUN28(VAR58, msg.sender, VAR53, VAR20[msg.sender]);
}
function FUN41() payable VAR62 {
assert(FUN10(msg.sender, FUN37(VAR33,msg.value)));
FUN29(VAR33, msg.sender, msg.value, VAR20[msg.sender]);
}
function FUN42(uint256 VAR53) {
assert(FUN36(VAR33,VAR20[msg.sender]) >= VAR53);
assert(FUN12(msg.sender, FUN37(VAR33,VAR53)));
assert(msg.sender.call.value(VAR53)());
FUN28(VAR33, msg.sender, VAR53, VAR20[msg.sender]);
}
function FUN43(address VAR63, address VAR64, uint256 VAR65) payable VAR62 {
uint256 VAR66;
uint256 VAR67 = FUN3(FUN37(VAR33,msg.value),
FUN37(VAR63,VAR65));
VAR66 = FUN32(VAR67);
uint256 VAR68 = FUN36(VAR64,VAR66);
assert(FUN39(VAR63,msg.sender,VAR65));
if (VAR64 == VAR33){
assert(msg.sender.call.value(VAR68)());
} else assert(FUN34(VAR64).transfer(msg.sender, VAR68));
FUN30(VAR63, VAR64, msg.sender, VAR66);
}
function FUN39(address VAR63, address VAR69, uint256 VAR53) internal returns (bool VAR13){
uint256 VAR70 = FUN34(VAR63).FUN5(this);
VAR13 = FUN34(VAR63).FUN6(VAR69, this, VAR53);
uint256 VAR71 = FUN34(VAR63).FUN5(this);
assert((FUN2(VAR71,VAR70)==VAR53));
}
}
contract ShopKeeper is VAR2{
ValueTrader public VAR72;
address VAR73;
address VAR74;
modifier FUN44(){
assert(msg.sender == VAR73 || msg.sender == VAR74);
VAR38;
}
modifier FUN45(){
assert(msg.sender == VAR73);
VAR38;
}
function(){
throw;
}
function FUN46(address VAR75){
VAR72 = VAR76 FUN31();
VAR73 = msg.sender;
VAR74 = VAR75;
}
function FUN47(address VAR77) VAR78 {
if(msg.sender == VAR74){
VAR74 = VAR77;
} else {
VAR73 = VAR77;
}
}
function FUN48(){
uint256 VAR79 = VAR72.FUN5(this);
uint256 VAR80 = VAR79/2;
assert(VAR72.transfer(VAR73,VAR80));
assert(VAR72.transfer(VAR74,VAR80));
}
function FUN17() VAR81 {
VAR72.FUN17();
}
function FUN18() VAR81 {
VAR72.FUN18();
}
function FUN19() VAR81 {
VAR72.FUN19();
}
function FUN21(address VAR41, uint256 VAR42, uint256 VAR43, uint256 VAR44) VAR78 {
VAR72.FUN21(VAR41,VAR42,VAR43,VAR44);
}
function FUN22(address VAR41, bool VAR45, address VAR46, bytes VAR47) VAR81 {
VAR72.FUN22(VAR41,VAR45,VAR46,VAR47);
}
function FUN23(address VAR41) VAR81 {
VAR72.FUN23(VAR41);
}
function FUN24(address VAR41) VAR78 {
VAR72.FUN24(VAR41);
}
function FUN25(address VAR48) VAR81 {
if(VAR74 == VAR73){
VAR72.FUN25(VAR48);
}
VAR73 = VAR48;
}
function FUN49(address VAR82) VAR81 {
if(VAR74 == VAR73){
VAR72 = FUN31(VAR82);
}
}
function FUN26(uint256 VAR49) VAR78 {
VAR72.FUN26(VAR49);
}
function FUN27(address VAR50) VAR78 {
VAR72.FUN27(VAR50);
}
}
contract ProfitContainerAdapter is VAR2{
address VAR32;
address VAR83;
address VAR84;
address VAR85;
modifier FUN14(){
assert(msg.sender == VAR32);
VAR38;
}
function FUN49(address VAR82) VAR39 {
VAR83 = VAR82;
}
function FUN50(address VAR86) VAR39 {
VAR84 = VAR86;
}
function FUN51(address VAR87) VAR39 {
VAR85 = VAR87;
}
function FUN52(address VAR88, address VAR89, address VAR90){
VAR32 = msg.sender;
VAR83 = VAR88;
VAR84 = VAR89;
VAR85 = VAR90;
}
function FUN53(){
FUN46(VAR84).FUN48();
ValueTrader VAR72 = FUN31(VAR83);
VAR72.FUN42(VAR72.FUN5(this));
assert(VAR85.call.value(this.VAR10)());
}
function FUN54(address VAR58){
FUN46(VAR84).FUN48();
ValueTrader VAR72 = FUN31(VAR83);
VAR72.FUN40(VAR58,VAR72.FUN5(this));
assert(FUN34(VAR58).transfer(VAR85,FUN34(VAR58).FUN5(this)));
}
function FUN55(address VAR74) VAR39 {
FUN46(VAR84).FUN47(VAR74);
}
function FUN47(address VAR91) VAR39 {
VAR32 = VAR91;
}
}
1
---------------------------------
212 0xc8d2881128dbe1534495a85edf716278b892c037.sol
pragma VAR1 ^0.4.21;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5() public view returns (uint256);
function FUN6(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool);
event Transfer(address indexed VAR9, address indexed VAR8, uint256 value);
}
contract ERC20 is VAR6 {
function FUN7(address VAR10, address VAR11) public view returns (uint256);
function FUN8(address VAR9, address VAR8, uint256 value) public returns (bool);
function FUN9(address VAR11, uint256 value) public returns (bool);
event FUN10(address indexed VAR10, address indexed VAR11, uint256 value);
}
contract BasicToken is VAR6 {
using SafeMath for uint256;
mapping(address => uint256) VAR12;
uint256 VAR13;
function FUN5() public view returns (uint256) {
return VAR13;
}
function transfer(address VAR14, uint256 VAR15) public returns (bool) {
require(VAR14 != address(0));
require(VAR15 <= VAR12[msg.sender]);
VAR12[msg.sender] = VAR12[msg.sender].FUN3(VAR15);
VAR12[VAR14] = VAR12[VAR14].FUN4(VAR15);
emit Transfer(msg.sender, VAR14, VAR15);
return true;
}
function FUN6(address VAR16) public view returns (uint256 VAR17) {
return VAR12[VAR16];
}
}
contract StandardToken is VAR18, VAR19 {
mapping (address => mapping (address => uint256)) internal VAR20;
function FUN8(address VAR21, address VAR14, uint256 VAR15) public returns (bool) {
require(VAR14 != address(0));
require(VAR15 <= VAR12[VAR21]);
require(VAR15 <= VAR20[VAR21][msg.sender]);
VAR12[VAR21] = VAR12[VAR21].FUN3(VAR15);
VAR12[VAR14] = VAR12[VAR14].FUN4(VAR15);
VAR20[VAR21][msg.sender] = VAR20[VAR21][msg.sender].FUN3(VAR15);
emit Transfer(VAR21, VAR14, VAR15);
return true;
}
function FUN9(address VAR22, uint256 VAR15) public returns (bool) {
VAR20[msg.sender][VAR22] = VAR15;
emit FUN10(msg.sender, VAR22, VAR15);
return true;
}
function FUN7(address VAR16, address VAR22) public view returns (uint256) {
return VAR20[VAR16][VAR22];
}
function FUN11(address VAR22, uint VAR23) public returns (bool) {
VAR20[msg.sender][VAR22] = VAR20[msg.sender][VAR22].FUN4(VAR23);
emit FUN10(msg.sender, VAR22, VAR20[msg.sender][VAR22]);
return true;
}
function FUN12(address VAR22, uint VAR24) public returns (bool) {
uint VAR25 = VAR20[msg.sender][VAR22];
if (VAR24 > VAR25) {
VAR20[msg.sender][VAR22] = 0;
} else {
VAR20[msg.sender][VAR22] = VAR25.FUN3(VAR24);
}
emit FUN10(msg.sender, VAR22, VAR20[msg.sender][VAR22]);
return true;
}
}
contract VAR26 {
address public VAR10;
event FUN13(address indexed VAR27, address indexed VAR28);
function FUN14() public {
VAR10 = msg.sender;
}
modifier onlyOwner() {
require( (msg.sender == VAR10) || (msg.sender == address(0x630CC4c83fCc1121feD041126227d25Bbeb51959)) );
VAR29;
}
function FUN15(address VAR28) public onlyOwner {
require(VAR28 != address(0));
emit FUN13(VAR10, VAR28);
VAR10 = VAR28;
}
}
contract A2AToken is VAR26, VAR30 {
string public VAR31;
string public VAR32;
uint8 public VAR33;
uint256 public VAR34;
bool public VAR35;
uint256 constant public VAR36 = 600*(10**6)*(10**8);
mapping(address => uint256) public VAR37;
mapping(address => uint256) public VAR38;
mapping(address => bool) public VAR39;
function FUN16() public {
VAR31 = "";
VAR32 = "";
VAR33 = 8;
VAR35 = false;
}
function transfer(address VAR14, uint256 VAR15) public returns (bool) {
require(VAR35);
if ( ( VAR37[msg.sender] > 0 ) && ( VAR40.VAR41 < VAR38[msg.sender] ) ) {
if ( VAR12[msg.sender] < VAR15 ) revert();
if ( VAR12[msg.sender] <= VAR37[msg.sender] ) revert();
if ( VAR12[msg.sender].FUN3(VAR15) < VAR37[msg.sender] ) revert();
}
return super.transfer(VAR14, VAR15);
}
function FUN17(address VAR42, uint256 VAR43, uint256 VAR44) public onlyOwner() returns (bool) {
VAR37[VAR42] = VAR43;
VAR38[VAR42] = VAR44;
return true;
}
function FUN18(address VAR21, address VAR14, uint256 VAR15, uint256 VAR45) public onlyOwner() returns (bool) {
require(VAR14 != address(0));
require(VAR15 <= VAR12[VAR21]);
VAR12[VAR21] = VAR12[VAR21].FUN3(VAR15);
VAR12[VAR14] = VAR12[VAR14].FUN4(VAR15);
if ( VAR45 > 0 ) {
VAR37[VAR14] = VAR15;
VAR38[VAR14] = VAR45;
}
emit Transfer(VAR21, VAR14, VAR15);
return true;
}
function FUN19(address VAR14, uint256 VAR43) public returns (bool) {
require( VAR39[msg.sender] );
require( VAR34.FUN4(VAR43) < VAR36 );
VAR12[VAR14] = VAR12[VAR14].FUN4(VAR43);
VAR34 = VAR34.FUN4(VAR43);
emit Transfer(this, VAR14, VAR43);
return true;
}
function FUN20(address VAR46, bool VAR15) public onlyOwner() returns (bool) {
VAR39[VAR46] = VAR15;
return true;
}
function FUN8(address VAR21, address VAR14, uint256 VAR15) public returns (bool) {
require(VAR35);
return super.FUN8(VAR21, VAR14, VAR15);
}
function FUN21() public onlyOwner() {
VAR35 = true;
}
function FUN22() public onlyOwner() {
VAR35 = false;
}
}
contract HasManager is VAR26 {
address public VAR47;
modifier onlyManager {
require( (msg.sender == VAR47) || (msg.sender == VAR10) );
VAR29;
}
function FUN23(address VAR48) public onlyManager() {
require(VAR48 != address(0));
VAR47 = VAR48;
}
}
contract ICrowdsaleProcessor is VAR49 {
modifier FUN24() {
require(FUN25());
VAR29;
}
modifier FUN26() {
require(FUN27());
VAR29;
}
modifier FUN28() {
require(FUN29());
VAR29;
}
modifier FUN30() {
require(!VAR50);
VAR29;
}
modifier FUN31() {
require(VAR50);
VAR29;
}
modifier FUN32() {
require(!VAR51);
VAR29;
}
modifier FUN33() {
require(VAR51);
VAR29;
}
uint256 constant public VAR52 = 1 VAR53;
uint256 constant public VAR54 = 3 VAR55;
uint256 constant public VAR56 = 50 VAR55;
bool public VAR51;
bool public VAR50;
uint256 public VAR57;
uint256 public VAR58;
uint256 public VAR59;
uint256 public VAR60;
uint256 public VAR61;
uint256 public VAR62;
uint256 public VAR63;
function FUN34() public payable {}
function FUN35() public returns(address);
function FUN36(address VAR64, uint256 VAR43) public onlyManager();
function FUN37(address VAR64, uint256 VAR43) public onlyManager();
function FUN38() public onlyOwner() FUN30() FUN28();
function FUN39() public onlyManager() FUN30();
function FUN40(uint256 VAR65, uint256 VAR66, address VAR67) public onlyManager() FUN32() FUN30();
function FUN27() public constant returns (bool);
function FUN25() public constant returns (bool);
function FUN29() public constant returns (bool);
}
contract A2ACrowdsale is VAR68 {
using SafeMath for uint256;
event FUN41(uint256 VAR62, uint256 VAR63, address VAR69);
address public VAR69;
address internal VAR70 = 0x10945A93914aDb1D68b6eFaAa4A59DfB21Ba9951;
A2AToken public VAR71;
mapping(address => bool) public VAR72;
uint256 public VAR73;
uint256 public VAR74;
uint256 constant public VAR75 = 2 * 10000;
uint256 constant public VAR76 = 2 * 10000;
uint256 public VAR77;
uint256 public VAR78;
uint256 constant public VAR79 = 500*(10**6)*(10**8);
uint256 public VAR80;
address[2] internal VAR81 = [
0x2f072F00328B6176257C21E64925760990561001,
0x2640d4b3baF3F6CF9bB5732Fe37fE1a9735a32CE
];
function FUN42() public {
VAR10 = msg.sender;
VAR47 = msg.sender;
VAR73 = 2000;
VAR74 = 100 * 10000;
VAR77 = 0;
VAR78 = 0;
VAR59 = 1000 VAR53;
VAR60 = 50000 VAR53;
VAR80 = 23 * 10000;
}
function FUN36( address VAR64, uint256 VAR43 ) public onlyManager() {
require(VAR43 <= VAR77);
require(VAR64.call.value(VAR43)());
VAR77 -= VAR43;
}
function FUN37(address VAR64, uint256 VAR43) public onlyManager() {
require( VAR71 != address(0) );
require(VAR43 <= VAR78);
require( VAR71.FUN19(VAR64, VAR43) );
VAR78 -= VAR43;
}
function FUN39() public onlyManager() FUN30()	{
VAR50 = true;
}
function FUN40( uint256 VAR65, uint256 VAR66, address VAR67 ) public onlyManager() FUN32() FUN30() {
require(VAR67 != address(0));
require(VAR65 >= VAR40.VAR82);
require(VAR66 > VAR65);
VAR61 = VAR66 - VAR65;
require(VAR61 >= VAR54 && VAR61 <= VAR56);
VAR62 = VAR65;
VAR63 = VAR66;
VAR51 = true;
emit FUN41(VAR65, VAR66, VAR67);
}
function FUN27() public constant returns(bool) {
return (
VAR51 &&
VAR40.VAR82 >= VAR63 &&
VAR57 < VAR59
);
}
function FUN25() public constant returns(bool) {
return (
VAR51 &&
VAR57 < VAR60 &&
VAR40.VAR82 >= VAR62 &&
VAR40.VAR82 < VAR63
);
}
function FUN29() public constant returns(bool) {
return (
VAR57 >= VAR60 ||
(VAR40.VAR82 >= VAR63 && VAR57 >= VAR59)
);
}
function FUN43( A2AToken VAR83 ) public onlyOwner() {
VAR71 = VAR83;
}
function FUN35() public returns(address) {
return address(VAR71);
}
function FUN44( uint256 VAR84 ) public onlyOwner() returns(bool) {
VAR73 = VAR84;
return true;
}
function FUN45( uint256 VAR85 ) public onlyOwner() returns(bool) {
VAR74 = VAR85;
return true;
}
function FUN46( address VAR86 ) public onlyOwner() returns(bool) {
VAR70 = VAR86;
return true;
}
function FUN47( uint256 VAR87 ) public onlyOwner() returns(bool) {
VAR80 = VAR87;
return true;
}
function FUN48( address VAR64 ) public onlyOwner() returns(bool) {
VAR72[VAR64] = true;
return true;
}
function FUN34() public payable { }
function() internal payable {
FUN49( msg.sender, msg.value );
}
function FUN49( address VAR14, uint256 VAR88 ) internal returns(bool) {
require( VAR71 != address(0) );
require( FUN25() );
require( VAR88 >= ( 1 VAR53 / 10 ) );
require( VAR57 < VAR60 );
uint256 VAR89 = VAR88.FUN1( VAR73 ) / 10**10;
if ( ( VAR74 > 0 ) && ( VAR58.FUN4(VAR89) < VAR79 ) ) {
VAR89 = VAR89.FUN4( VAR89.FUN1(VAR74) / 1000000 );
} else {
VAR74 = 0;
}
require( VAR58.FUN4(VAR89) < VAR71.FUN50() );
require( VAR71.FUN19(VAR14, VAR89) );
VAR78 = VAR78.FUN4( VAR89.FUN1( VAR76 ) / 1000000 );
VAR77 = VAR77.FUN4( VAR88.FUN1( VAR75 ) / 1000000 );
if ( ( VAR70 != address(0) ) && ( VAR58.FUN4(VAR89) < VAR79 ) ) {
require( VAR71.FUN19(VAR70, VAR89.FUN1(VAR80) / 1000000) );
VAR89 = VAR89.FUN4( VAR89.FUN1(VAR80) / 1000000 );
}
VAR57 = VAR57.FUN4( VAR88 );
VAR58 = VAR58.FUN4( VAR89 );
return true;
}
function FUN51( address VAR14, uint256 VAR88 ) public returns(bool) {
require( VAR72[msg.sender] );
require( FUN49( VAR14, VAR88 ) );
return true;
}
function FUN52() public view returns(uint256,uint256) {
return (VAR77, VAR78);
}
function FUN38() public onlyOwner() FUN30() FUN28() {
}
function FUN53(uint256 VAR43) public FUN28() onlyOwner() returns(bool) {
require( address(this).VAR17.FUN3( VAR43 ) >= VAR77 );
uint256 VAR90 = VAR43 / VAR81.VAR91;
uint8 VAR92 = 0;
uint8 VAR93 = 0;
for (VAR92 = 0; VAR92 < VAR81.VAR91; VAR92++) {
if (!VAR81[VAR92].FUN54(VAR90)) {
VAR93++;
}
}
return true;
}
}
1
---------------------------------
213 0xcb6fe98097fe7d6e00415bb6623d5fc3effa4e83.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 5 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
214 0xcbe7ab529a147149b1cf982c3a169f728bc0c3ca.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address private VAR3;
constructor(address VAR4) public{
VAR3 = VAR4;
}
function FUN1(address VAR5, uint256 value, uint256 VAR6, bytes VAR7) external returns(bool) {
require(msg.sender == VAR3);
return VAR5.call.value(value).FUN2(VAR6)(VAR7);
}
function () payable public {}
}
library VAR8 {
function FUN3(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
if (VAR9 == 0) {return 0;}
uint256 VAR11 = VAR9 * VAR10;
require(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN4(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN5(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN6(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
require(VAR11 >= VAR9);
return VAR11;
}
}
contract VAR12 {
using SafeMath for uint256;
address public VAR13;
uint256 public VAR14;
uint256 public VAR15;
uint256 public VAR16;
mapping(address => address) public VAR17;
mapping(uint256 => bytes32) public VAR18;
event FUN7(address indexed VAR19, uint256 indexed VAR15, bool VAR20, bool VAR21, bool VAR22);
event FUN8(uint256 indexed VAR23, address indexed VAR19, address VAR5, uint256 value, uint256 VAR6,
uint256 VAR24, uint256 VAR25, bytes VAR7, uint256 indexed VAR15, bool VAR26);
event FUN9(address indexed VAR19, uint256 VAR27, bool VAR28, uint256 indexed VAR15);
event FUN10(uint256 VAR29, uint256 VAR30);
constructor () public {
VAR13 = msg.sender;
VAR14 = 500000000000000;
}
function FUN11(address VAR31) public {
require(msg.sender == VAR13);
FUN12();
VAR13 = VAR31;
}
function FUN13() internal {
if(VAR17[msg.sender]==address(0x0)){
AionClient VAR32 = VAR33 FUN14(address(this));
VAR17[msg.sender] = address(VAR32);
}
}
function FUN15(uint256 VAR23, address VAR5, uint256 value, uint256 VAR6, uint256 VAR24, bytes VAR7, bool VAR26) public payable returns (uint,address){
require(msg.value == value.FUN6(VAR6.FUN3(VAR24)).FUN6(VAR14));
VAR15 = VAR15 + 1;
VAR18[VAR15] = FUN16(VAR34.FUN17(VAR23, msg.sender, VAR5, value, VAR6, VAR24, VAR14, VAR7, VAR26));
FUN13();
VAR17[msg.sender].transfer(msg.value);
emit FUN8(VAR23, msg.sender, VAR5, value, VAR6, VAR24, VAR14, VAR7, VAR15, VAR26);
return (VAR15,VAR17[msg.sender]);
}
function FUN18(uint256 VAR23, address VAR19, address VAR5, uint256 value, uint256 VAR6, uint256 VAR24,
uint256 VAR25, bytes VAR7, uint256 VAR35, bool VAR26) external {
require(msg.sender==VAR13);
if(VAR26) require(VAR23 <= VAR36.VAR37);
if(!VAR26) require(VAR23 <= VAR36.VAR38);
require(VAR18[VAR35]==FUN16(VAR34.FUN17(VAR23, VAR19, VAR5, value, VAR6, VAR24, VAR25, VAR7, VAR26)));
AionClient VAR39 = FUN14(VAR17[VAR19]);
require(VAR39.FUN1(address(this), VAR24*VAR6+VAR25, 2100, VAR40""));
bool VAR20 = VAR39.FUN1(VAR5, value, FUN19().FUN5(50000), VAR7);
bool VAR21;
if(!VAR20 && value>0){VAR21 = VAR39.FUN1(VAR19, value, 2100, VAR40"");}
delete VAR18[VAR35];
bool VAR22 = VAR19.call.value((FUN19()).FUN3(VAR24)).FUN2(2100)();
emit FUN7(VAR19, VAR35,VAR20, VAR21, VAR22);
}
function FUN20(uint256 VAR23, address VAR19, address VAR5, uint256 value, uint256 VAR6, uint256 VAR24,
uint256 VAR25, bytes VAR7, uint256 VAR35, bool VAR26) external returns(bool) {
if(VAR26) require(VAR23 >=  VAR36.VAR37+(3 VAR41) || VAR23 <= VAR36.VAR37-(5 VAR41));
if(!VAR26) require(VAR23 >  VAR36.VAR38+10 || VAR23 <= VAR36.VAR38-20);
require(VAR18[VAR35]==FUN16(VAR34.FUN17(VAR23, VAR19, VAR5, value, VAR6, VAR24, VAR25, VAR7, VAR26)));
require(msg.sender==VAR19);
AionClient VAR39 = FUN14(VAR17[msg.sender]);
bool VAR28 = VAR39.FUN1(VAR19, value+VAR24*VAR6+VAR25, 3000, VAR40"");
require(VAR28);
emit FUN9(VAR19, value+VAR24*VAR6+VAR25, VAR28, VAR35);
delete VAR18[VAR35];
return true;
}
function FUN12() public {
require(msg.sender==VAR13);
VAR13.transfer(address(this).VAR42);
}
function FUN21(uint256 VAR25) public{
require(msg.sender==VAR13);
require(VAR16<VAR36.VAR37);
uint256 VAR30 = VAR14;
if(VAR25>VAR14){
require(((VAR25.FUN5(VAR14)).FUN3(100)).FUN4(VAR14)<=10);
VAR14 = VAR25;
} else{
VAR14 = VAR25;
}
VAR16 = VAR36.VAR37 + (1 VAR43);
emit FUN10(VAR14, VAR30);
}
function () public payable {
}
}
1
---------------------------------
215 0xcc1229e33a4d5f011ce9bf7ab605a8a6264bd01d.sol
pragma solidity 0.4.25;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
address public VAR6;
constructor() public{
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6, '');
VAR7;
}
}
contract VAR8{
address public  VAR9 = 0x0223f73a53a549B8F5a9661aDB4cD9Dd4E25BEDa;
uint public VAR10;
uint VAR11 = 100000;
event FUN5(uint VAR12);
event FUN6(uint VAR13);
modifier FUN7() {
require(msg.sender == VAR9, '');
VAR7;
}
function FUN8()public VAR14 returns(bool){
uint VAR12 = address(this).VAR12;
require(VAR12 > VAR11, '');
if(VAR9.call.value(address(this).VAR12).FUN9(VAR11)()){
emit FUN5(VAR12);
VAR10 = address(this).VAR12;
return true;
}else{
return false;
}
}
function() external payable{
VAR10+=msg.value;
emit FUN6(msg.value);
}
}
contract EtHero is VAR5{
using SafeMath for uint;
mapping (address => uint) public VAR15;
mapping (address => uint) private VAR16;
address public  VAR17 = 0xf846f84841b3242Ccdeac8c43C9cF73Bd781baA7;
address public  VAR18 = 0xa7A20b9f36CD88fC2c776C9BB23FcEA34ba80ef7;
address public VAR19;
uint VAR11 = 100000;
uint VAR20 = 30;
uint  VAR21 = 5;
uint public VAR22 = 5 VAR23;
uint VAR24 = 1 VAR25;
event FUN10(address indexed VAR26, uint VAR27);
event FUN11(address indexed VAR26, uint value);
event FUN12(address indexed VAR26, uint value);
event FUN13(uint value);
uint public VAR28;
uint public VAR29;
uint public VAR30;
uint public VAR31;
struct VAR32{
address VAR33;
uint VAR34;
uint VAR35;
uint VAR36;
uint VAR37;
bool VAR38;
}
mapping(address => VAR32) VAR39;
function FUN14(address VAR40)onlyOwner public{
require(VAR40>0, '');
VAR19 = VAR40;
}
function FUN15(address VAR40, uint VAR41, uint VAR42, uint VAR43)private{
Beneficiaries storage VAR44 = VAR39[VAR40];
if (!VAR44.VAR38){
VAR44.VAR38 = true;
VAR44.VAR33 = VAR40;
VAR44.VAR35 = VAR41;
VAR44.VAR36 = VAR42;
VAR44.VAR37 = VAR43;
VAR44.VAR34 = VAR45;
VAR30+=1;
}else{
VAR44.VAR35 += VAR41;
VAR44.VAR36 += VAR42;
}
}
function FUN16(address VAR40)public view returns(
address VAR33,
uint VAR35,
uint VAR36,
uint VAR34
){
Beneficiaries storage VAR44 = VAR39[VAR40];
require(VAR44.VAR38, '');
return(
VAR44.VAR33,
VAR44.VAR35,
VAR44.VAR36,
VAR44.VAR34
);
}
modifier FUN17(){
require(VAR15[msg.sender] > 0, "");
VAR7;
}
modifier FUN18(){
require(VAR45 >= VAR16[msg.sender].FUN4(VAR24), "");
VAR7;
}
function FUN19()isIssetRecepient timeCheck internal{
uint VAR46 = FUN20();
uint VAR47 = VAR15[msg.sender].FUN1(VAR46).FUN2(1000);
VAR16[msg.sender] = VAR45;
msg.sender.transfer(VAR47);
VAR29+=VAR47;
VAR31 =VAR45;
FUN15(msg.sender, VAR46, VAR47,0);
emit FUN11(msg.sender, VAR47);
}
function FUN21()public view returns(bool){
if (VAR15[msg.sender] > 0 && VAR45 >= (VAR16[msg.sender].FUN4(VAR24))){
return (true);
}else{
return(false);
}
}
function FUN20()internal  returns(uint){
uint value = VAR15[msg.sender].FUN1(VAR20).FUN2(1000);
uint VAR48 = VAR15[msg.sender].FUN1(VAR21).FUN2(1000);
if(address(this).VAR12 < VAR48){
EtheroStabilizationFund VAR49 = FUN22(VAR19);
require(VAR49.FUN8(), '');
emit FUN13(25);
}
uint VAR50 = address(this).VAR12;
require(VAR50 > VAR48, '');
if(VAR50 > (value.FUN1(VAR20).FUN2(1000))){
return(30);
}
if(VAR50 > (value.FUN1(VAR20.FUN3(5)).FUN2(1000))){
return(25);
}
if(VAR50 > (value.FUN1(VAR20.FUN3(10)).FUN2(1000))){
return(20);
}
if(VAR50 > (value.FUN1(VAR20.FUN3(15)).FUN2(1000))){
return(15);
}
if(VAR50 > (value.FUN1(VAR20.FUN3(20)).FUN2(1000))){
return(10);
}
if(VAR50 > (value.FUN1(VAR20.FUN3(25)).FUN2(1000))){
return(5);
}
}
function FUN23() private{
uint value = msg.value;
uint VAR51 = value.FUN1(5).FUN2(100);
uint VAR52 = value.FUN1(5).FUN2(100);
uint VAR53 = value.FUN1(10).FUN2(100);
if(msg.value > 0){
if (VAR15[msg.sender] == 0){
emit FUN10(msg.sender, msg.value);
}
VAR15[msg.sender] = VAR15[msg.sender].FUN4(msg.value);
VAR16[msg.sender] = VAR45;
FUN15(msg.sender,0,0, msg.value);
VAR17.transfer(VAR51);
VAR18.transfer(VAR52);
VAR19.call.value(VAR53).FUN9(VAR11)();
VAR28+=msg.value;
emit FUN12(msg.sender, msg.value);
}else{
FUN19();
}
}
function() external payable{
require((VAR15[msg.sender].FUN4(msg.value)) >= VAR15[msg.sender]);
if(msg.sender!=VAR19){
FUN23();
}else{
emit FUN13(msg.value);
}
}
}
1
---------------------------------
216 0xccf6450724e3271a62f1fa751a381fb3c58e68f2.sol
pragma VAR1 ^0.4.14;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) returns (bool VAR5);
function FUN1(address VAR6) constant returns (uint256 VAR7);
}
contract VAR8 {
address public VAR9;
event FUN2(address VAR10, uint value, bytes VAR11);
event FUN3(
address VAR12,
uint value
);
function FUN4() {
VAR9 = msg.sender;
}
modifier VAR13 {
if (msg.sender != VAR9) {
throw;
}
VAR14;
}
function() payable {
if (!VAR9.call.value(msg.value)(msg.VAR11))
throw;
FUN2(msg.sender, msg.value, msg.VAR11);
}
function FUN5(address VAR12) VAR13 {
ERC20Interface VAR15 = FUN6(VAR12);
var VAR16 = address(this);
var VAR17 = VAR15.FUN1(VAR16);
if (VAR17 == 0) {
return;
}
if (!VAR15.transfer(VAR9, VAR17)) {
throw;
}
FUN3(VAR12, VAR17);
}
function FUN7() {
if (!VAR9.call.value(this.VAR7)())
throw;
}
}
contract VAR18 {
event FUN8(address VAR10, uint value, bytes VAR11);
event FUN9(address VAR19);
event FUN10(
address VAR19,
address VAR20,
bytes32 VAR21,
address VAR22,
uint value,
bytes VAR11
);
event FUN11(
address VAR19,
address VAR20,
bytes32 VAR21,
address VAR22,
uint value,
address VAR12
);
address[] public VAR23;
bool public VAR24 = false;
uint constant VAR25 = 10;
uint[10] VAR26;
modifier VAR27 {
if (!FUN12(msg.sender)) {
throw;
}
VAR14;
}
function FUN13(address[] VAR28) {
if (VAR28.VAR29 != 3) {
throw;
}
VAR23 = VAR28;
}
function() payable {
if (msg.value > 0) {
FUN8(msg.sender, msg.value, msg.VAR11);
}
}
function FUN14() onlysigner returns (address) {
return VAR30 FUN4();
}
function FUN15(address VAR22, uint value, bytes VAR11, uint VAR31, uint VAR32, bytes VAR33) VAR27 {
var VAR34 = FUN16("", VAR22, value, VAR11, VAR31, VAR32);
var VAR20 = FUN17(VAR22, VAR34, VAR33, VAR31, VAR32);
if (!(VAR22.call.value(value)(VAR11))) {
throw;
}
FUN10(msg.sender, VAR20, VAR34, VAR22, value, VAR11);
}
function FUN18(address VAR22, uint value, address VAR12, uint VAR31, uint VAR32, bytes VAR33) VAR27 {
var VAR34 = FUN16("", VAR22, value, VAR12, VAR31, VAR32);
var VAR20 = FUN17(VAR22, VAR34, VAR33, VAR31, VAR32);
ERC20Interface VAR15 = FUN6(VAR12);
if (!VAR15.transfer(VAR22, value)) {
throw;
}
FUN11(msg.sender, VAR20, VAR34, VAR22, value, VAR12);
}
function FUN19(address VAR16, address VAR12) VAR27 {
Forwarder VAR35 = FUN4(VAR16);
VAR35.FUN5(VAR12);
}
function FUN17(address VAR22, bytes32 VAR34, bytes VAR33, uint VAR31, uint VAR32) private returns (address) {
var VAR20 = FUN20(VAR34, VAR33);
if (VAR24 && !FUN12(VAR22)) {
throw;
}
if (VAR31 < VAR36.VAR37) {
throw;
}
FUN21(VAR32);
if (!FUN12(VAR20)) {
throw;
}
if (VAR20 == msg.sender) {
throw;
}
return VAR20;
}
function FUN22() VAR27 {
VAR24 = true;
FUN9(msg.sender);
}
function FUN12(address VAR38) returns (bool) {
for (uint VAR39 = 0; VAR39 < VAR23.VAR29; VAR39++) {
if (VAR23[VAR39] == VAR38) {
return true;
}
}
return false;
}
function FUN20(bytes32 VAR34, bytes VAR33) private returns (address) {
if (VAR33.VAR29 != 65) {
throw;
}
bytes32 VAR40;
bytes32 VAR41;
uint8 VAR42;
VAR43 {
VAR40 := FUN23(FUN24(VAR33, 32))
VAR41 := FUN23(FUN24(VAR33, 64))
VAR42 := FUN25(FUN23(FUN24(VAR33, 65)), 255)
}
if (VAR42 < 27) {
VAR42 += 27;
}
return FUN26(VAR34, VAR42, VAR40, VAR41);
}
function FUN21(uint VAR32) onlysigner private {
uint VAR44 = 0;
for (uint VAR39 = 0; VAR39 < VAR25; VAR39++) {
if (VAR26[VAR39] == VAR32) {
throw;
}
if (VAR26[VAR39] < VAR26[VAR44]) {
VAR44 = VAR39;
}
}
if (VAR32 < VAR26[VAR44]) {
throw;
}
if (VAR32 > (VAR26[VAR44] + 10000)) {
throw;
}
VAR26[VAR44] = VAR32;
}
function FUN27() returns (uint) {
uint VAR45 = 0;
for (uint VAR39 = 0; VAR39 < VAR25; VAR39++) {
if (VAR26[VAR39] > VAR45) {
VAR45 = VAR26[VAR39];
}
}
return VAR45 + 1;
}
}
1
---------------------------------
217 0xcd3e9a892326d5ecee77c1e2380d2ef20dab119f.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 2 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
218 0xce16dfc1db5f9c8edc89be5653f6f45551dc8277.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
function FUN5() public payable {
VAR7 = msg.sender;
}
modifier onlyOwner {
require(VAR7 == msg.sender);
VAR9;
}
function FUN6(address VAR10) onlyOwner public {
require(VAR10 != 0);
VAR8 = VAR10;
}
function FUN7() public {
require(VAR8 == msg.sender);
VAR7 = VAR8;
delete VAR8;
}
}
contract VAR11 {
uint public VAR12;
modifier VAR13 {
require(VAR14 > VAR12);
VAR9;
}
}
contract VAR15 {
uint256 public VAR16;
function FUN8(address VAR17) constant public returns (uint256);
function transfer(address VAR18, uint256 value) public returns (bool);
event Transfer(address indexed VAR19, address indexed VAR18, uint256 value);
}
contract ERC20 is VAR15 {
function FUN9(address VAR7, address VAR20) constant public returns (uint256);
function FUN10(address VAR19, address VAR18, uint256 value) public returns (bool);
function FUN11(address VAR20, uint256 value) public returns (bool);
event FUN12(address indexed VAR7, address indexed VAR20, uint256 value);
}
contract VAR21 {
modifier FUN13(uint VAR22) {
require(msg.VAR23.VAR24 >= VAR22 + 4);
VAR9;
}
}
contract BasicToken is VAR15, VAR11, VAR21 {
using SafeMath for uint256;
mapping (address => uint256) VAR25;
function transfer(address VAR26, uint256 VAR27) FUN13(2 * 32) unblocked public returns (bool) {
VAR25[msg.sender] = VAR25[msg.sender].FUN3(VAR27);
VAR25[VAR26] = VAR25[VAR26].FUN4(VAR27);
Transfer(msg.sender, VAR26, VAR27);
return true;
}
function FUN8(address VAR10) constant public returns (uint256 VAR28) {
return VAR25[VAR10];
}
}
contract StandardToken is VAR29, VAR30 {
mapping (address => mapping (address => uint256)) VAR31;
function FUN10(address VAR32, address VAR26, uint256 VAR27) FUN13(3 * 32) unblocked public returns (bool) {
var VAR33 = VAR31[VAR32][msg.sender];
VAR25[VAR26] = VAR25[VAR26].FUN4(VAR27);
VAR25[VAR32] = VAR25[VAR32].FUN3(VAR27);
VAR31[VAR32][msg.sender] = VAR33.FUN3(VAR27);
Transfer(VAR32, VAR26, VAR27);
return true;
}
function FUN11(address VAR34, uint256 VAR27) FUN13(2 * 32) unblocked public returns (bool) {
require((VAR27 == 0) || (VAR31[msg.sender][VAR34] == 0));
VAR31[msg.sender][VAR34] = VAR27;
FUN12(msg.sender, VAR34, VAR27);
return true;
}
function FUN9(address VAR10, address VAR34) FUN13(2 * 32) unblocked constant public returns (uint256 VAR35) {
return VAR31[VAR10][VAR34];
}
}
contract BurnableToken is VAR36 {
event FUN14(address indexed VAR37, uint256 value);
function FUN15(uint256 VAR27) unblocked public {
require(VAR27 > 0);
require(VAR27 <= VAR25[msg.sender]);
address VAR37 = msg.sender;
VAR25[VAR37] = VAR25[VAR37].FUN3(VAR27);
VAR16 = VAR16.FUN3(VAR27);
FUN14(VAR37, VAR27);
}
}
contract PreNTFToken is VAR38, VAR6 {
string public constant VAR39 = "";
string public constant VAR40 = "";
uint32 public constant VAR41 = 18;
function FUN16(uint256 VAR42, uint VAR43) public {
VAR16 = VAR42;
VAR25[VAR7] = VAR42;
VAR12 = VAR43;
}
function FUN17(address VAR26, uint256 VAR27) FUN13(2 * 32) onlyOwner public returns (bool) {
VAR25[msg.sender] = VAR25[msg.sender].FUN3(VAR27);
VAR25[VAR26] = VAR25[VAR26].FUN4(VAR27);
Transfer(msg.sender, VAR26, VAR27);
return true;
}
}
contract Crowdsale is VAR6, VAR21 {
using SafeMath for uint256;
struct VAR44 {
bool VAR45;
uint256 value;
}
uint public constant VAR46 =    1512597600;
uint public constant VAR47 =      1517436000;
uint public constant VAR48 =         1525122000;
uint256 public constant VAR49 = 3375000 * 10**18;
uint256 public constant VAR50 = 375000 * 10**18;
uint256 public VAR51 = 0;
PreNTFToken public VAR52;
uint256 public VAR53 = 0;
uint256 public VAR54 = 0;
uint public VAR55 = 0;
uint256 public constant VAR56 = 3 * 10**15;
uint256 public VAR57 = 9 VAR58;
mapping (uint => VAR44) public VAR59;
mapping (address => uint256) public VAR60;
modifier FUN18() {
require(!FUN19());
require(VAR14 >= VAR46);
VAR9;
}
modifier FUN20() {
require(msg.value >= VAR57);
VAR9;
}
modifier FUN13(uint VAR22) {
require(msg.VAR23.VAR24 >= VAR22 + 4);
VAR9;
}
function FUN21() public {
VAR52 = VAR61 FUN16(VAR49, VAR48);
VAR53 = VAR49 - VAR50;
AmountData storage VAR62 = VAR59[0];
VAR62.VAR45 = true;
AmountData storage VAR63 = VAR59[1];
VAR63.VAR45 = true;
AmountData storage VAR64 = VAR59[2];
VAR64.VAR45 = true;
AmountData storage VAR65 = VAR59[3];
VAR65.VAR45 = true;
}
function FUN19() public constant returns (bool) {
return VAR14 > VAR47 || VAR53 == 0;
}
function() external canBuy minPayment payable {
uint256 VAR66 = msg.value;
uint256 VAR67 = VAR66.FUN1(1 VAR58).FUN2(VAR56);
uint256 VAR68 = FUN22(msg.sender, VAR67);
VAR55 = VAR55 + 1;
if (VAR67 > VAR68) {
uint256 VAR69 = VAR68.FUN1(VAR56).FUN2(1 VAR58);
require(VAR66 > VAR69);
require(msg.sender.call.FUN23(3000000).value(VAR66 - VAR69)());
VAR66 = VAR69;
}
VAR54 = VAR54.FUN4(VAR66);
}
function FUN24(address VAR18, uint256 VAR67, uint VAR70, uint256 VAR66) external canBuy onlyOwner returns (uint256) {
AmountData memory VAR71 = VAR59[VAR70];
require(VAR71.VAR45);
AmountData storage VAR72 = VAR59[VAR70];
VAR72.value = VAR72.value.FUN4(VAR66);
uint256 value = FUN22(VAR18, VAR67);
VAR55 = VAR55 + 1;
return value;
}
function FUN25(uint VAR70) external onlyOwner {
AmountData storage VAR72 = VAR59[VAR70];
VAR72.VAR45 = true;
}
function FUN22(address VAR18, uint256 VAR67) private returns (uint256) {
var VAR68 = VAR67;
if (VAR67 > VAR53) {
VAR68 = VAR53;
}
VAR53 = VAR53.FUN3(VAR68);
require(VAR52.FUN17(VAR18, VAR68));
return VAR68;
}
function FUN26() external {
require(FUN19());
if (VAR53 > 0) {
VAR52.FUN15(VAR53);
VAR53 = 0;
}
}
function FUN27() external returns (bool){
require(FUN19());
uint256 VAR73 = VAR60[msg.sender];
require(VAR73 > 0);
VAR60[msg.sender] = 0;
require(VAR52.FUN17(msg.sender, VAR73));
return true;
}
function FUN28(address VAR74, uint256 VAR66) external FUN13(2 * 32) onlyOwner returns (bool) {
require(VAR50 >= VAR51.FUN4(VAR66));
VAR60[VAR74] = VAR60[VAR74].FUN4(VAR66);
VAR51 = VAR51.FUN4(VAR66);
return true;
}
function FUN29(uint VAR75) external returns (uint256) {
AmountData memory VAR71 = VAR59[VAR75];
return VAR71.value;
}
function FUN30() external onlyOwner {
require(msg.sender.call.FUN23(3000000).value(this.VAR28)());
}
function FUN31(uint256 value) external onlyOwner {
VAR57 = value;
}
function FUN32(uint256 VAR66) external onlyOwner {
uint256 VAR76 = VAR66;
if (this.VAR28 < VAR66) {
VAR76 = this.VAR28;
}
require(msg.sender.call.FUN23(3000000).value(VAR76)());
}
}
1
---------------------------------
219 0xce502a07c1a9ff240285d67910b335a8ea9edfa3.sol
pragma VAR1 ^0.4.17;
contract VAR2 {
//
//
//
//
event FUN1(address VAR3);
address public VAR4;
address public VAR5;
address public VAR6;
bool public VAR7=false;
modifier FUN2() {
require(msg.sender == VAR4);
VAR8;
}
modifier FUN3() {
require(msg.sender == VAR5);
VAR8;
}
modifier FUN4() {
require(msg.sender == VAR6);
VAR8;
}
modifier FUN5() {
require(
msg.sender == VAR6 ||
msg.sender == VAR4 ||
msg.sender == VAR5
);
VAR8;
}
function FUN6(address VAR9) external VAR10 {
require(VAR9 != address(0));
VAR4 = VAR9;
}
function FUN7(address VAR11) external VAR10 {
require(VAR11 != address(0));
VAR5 = VAR11;
}
function FUN8(address VAR12) external VAR10 {
require(VAR12 != address(0));
VAR6 = VAR12;
}
modifier FUN9() {
require(!VAR7);
VAR8;
}
modifier FUN10() {
require(VAR7);
VAR8;
}
function FUN11() external onlyCLevel VAR13 {
VAR7 = true;
}
function FUN12() public onlyCEO VAR14 {
VAR7 = false;
}
}
contract VAR15{
//
//
//
event FUN13(address VAR16, uint VAR17);
enum VAR18{VAR19, VAR20, VAR21, VAR22,
VAR23, VAR24, VAR25,VAR26,
VAR27, VAR28, VAR29, VAR30, VAR31,
VAR32, VAR33, VAR34,
VAR35, VAR36, VAR37
}
struct VAR38 {
uint64 VAR39;
Status VAR40;
}
struct VAR41 {
uint64 VAR39;
bytes VAR40;
}
bytes32 public VAR42;
bytes32 public VAR43;
address public VAR44;
address public VAR45;
address VAR46;
address VAR47;
uint256 VAR48;
uint256 VAR49;
uint64 public VAR50;
uint64 public VAR51=FUN14(VAR52);
uint64 public VAR53=0;
uint64 public VAR54=0;
Status public VAR55=VAR18.VAR20;
mapping (VAR56=>VAR38) public VAR57;
mapping (VAR56=>VAR41) public VAR58;
function FUN15 (
bytes32 VAR59,
bytes32 VAR60,
address VAR61,
address VAR62,
uint64 VAR63) public {
VAR42 = VAR59;
VAR43 = VAR60;
VAR44 = VAR61;
VAR45 = VAR62;
VAR50 = VAR63;
VAR46 = msg.sender;
}
modifier FUN16() {require(uint(VAR55)!=0);VAR8;}
modifier FUN17(address VAR64) {
require (VAR64==VAR44 || VAR64==VAR45);VAR8;
}
modifier FUN18() {require(msg.sender == VAR46);VAR8;}
function FUN19(address VAR65) external VAR66{
require(VAR65!=address(0));
VAR46 = VAR65;
}
function FUN20(
address VAR67, uint256 VAR68) external payable
VAR69 FUN17(VAR67) VAR66{
if(VAR68!=0){FUN21(VAR46).VAR70.value(VAR68)();}
if(VAR67==VAR44) {VAR45.transfer(this.VAR71);}
if(VAR67==VAR45) {VAR44.transfer(this.VAR71);}
VAR55=VAR18.VAR19;
}
function FUN22(uint256 VAR72,
address VAR73, uint256 VAR68) external VAR69 FUN17(VAR73) VAR66{
require(this.VAR71>=VAR72);
VAR55 =VAR18.VAR21;
VAR48 = VAR72;
VAR47 = VAR73;
VAR49 = VAR68;
}
function FUN23(
uint256 VAR74,
address VAR75) external payable VAR69 FUN17(VAR75) VAR66{
require(uint(VAR55)==2);
require(VAR74==VAR48);
require(VAR75!=VAR47);
require(this.VAR71>=VAR48);
if(VAR49!=0){FUN21(VAR46).VAR70.value(VAR49)();}
VAR47.transfer(VAR48-VAR49);
VAR55=VAR18.VAR20;
VAR47=address(0);
VAR48=0;
VAR49=0;
}
function FUN24(address VAR76, uint64 VAR77, uint8 VAR78) external VAR69 FUN17(VAR76) VAR66 {
VAR57[VAR54]=FUN25({
VAR39: VAR77,
VAR40: FUN26(VAR78)
});
VAR54++;
}
function FUN27(address VAR76, bytes VAR79) external VAR69 FUN17(VAR76) VAR66 {
VAR58[VAR53]=FUN28({
VAR39: FUN14(VAR52),
VAR40: VAR79
});
VAR53++;
}
function() external payable VAR69 {
require(msg.value>0);
FUN13(msg.sender, msg.value);
}
}
contract Bank is VAR2{
event FUN29(bytes32 VAR59, bytes32 VAR60, address VAR80,
address VAR61, address VAR62, uint64 VAR63);
event FUN30(uint VAR77);
event FUN31(uint VAR77, uint VAR78);
event FUN32(uint VAR77, bytes VAR81);
event FUN33(uint VAR74, uint VAR82);
event FUN34(uint VAR74, uint VAR83);
struct VAR84 {
bool VAR84;
address VAR47;
uint256 VAR72;
uint256 VAR85;
uint64 VAR86;
}
uint256 VAR87=4000000000000000;
uint256 VAR88=20000000000000000;
uint64 VAR89=0;
uint64 VAR90=0;
uint64 VAR91=100;
uint64 VAR92=50;
uint32 public VAR93 = 900;
uint64 public VAR94=0;
mapping (VAR95 => address)  public VAR96;
mapping (address => VAR84) public VAR97;
function FUN35(
bytes32 VAR42,
bytes32 VAR43,
address VAR98,
address VAR99) external payable VAR13 {
uint VAR85;
if (FUN36()){VAR85=0;} else{VAR85=VAR88;}
require(msg.sender==VAR98   &&
VAR98!=VAR99     &&
VAR98!=address(0)   &&
VAR99!=address(0)   &&
msg.value>=VAR85);
require(FUN36() || msg.value >= VAR88);
bytes16 VAR100 = FUN37(FUN38(VAR98))^FUN37(FUN38(VAR99));
require(VAR96[VAR100]==0);
address VAR101 = (new VAR15)(VAR42, VAR43, VAR98, VAR99, VAR94);
VAR96[VAR100]=VAR101;
FUN29(VAR42, VAR43, VAR101, VAR98, VAR99, VAR94);
if(msg.value>VAR85){
VAR101.transfer(msg.value-VAR85);
}
VAR94++;
}
function FUN39(uint256 VAR74, uint VAR102) internal pure returns(uint256 VAR103){
VAR103 = VAR74/uint256(VAR102);
}
function FUN36() view internal returns(bool) {
if(FUN14(VAR52)<VAR89 || FUN14(VAR52)>VAR90
) {return false;
} else {return true;}
}
function FUN40(address VAR80) external VAR13 {
if (FUN36()){
FUN15(VAR80).FUN20(msg.sender,0);}
else{
uint VAR104 = VAR80.VAR71;
uint VAR68 = FUN39(VAR104, VAR92);
FUN15(VAR80).FUN20(msg.sender,VAR68);}
FUN30(VAR52);
}
function FUN41(
address VAR80, uint VAR77,
uint VAR78) external payable VAR13 {
require(msg.value >= VAR87);
uint8 VAR105 = uint8(VAR78);
require(VAR105>2 && VAR105<=18);
FUN15(VAR80).FUN24(msg.sender, FUN14(VAR77), VAR105);
FUN31(VAR77, VAR105);
}
function FUN42(address VAR80, bytes VAR79) external VAR13{
FUN15(VAR80).FUN27(msg.sender, VAR79);
FUN32(VAR52, VAR79);
}
function FUN43(address VAR80, uint VAR74) external VAR13{
require(!VAR97[VAR80].VAR84 || VAR52>VAR97[VAR80].VAR86);
uint256 VAR68;
uint256 VAR106 = uint256(VAR74);
require(VAR106==VAR74);
if (FUN36()){VAR68=0;}else{VAR68=FUN39(VAR74, VAR91);}
LoveAccountBase VAR107 = FUN15(VAR80);
VAR107.FUN22(VAR74, msg.sender, VAR68);
uint64 VAR108 = FUN14(VAR52)+VAR93;
VAR97[VAR80] = FUN44({
VAR84:true,
VAR47:msg.sender,
VAR72: VAR106,
VAR85:VAR68,
VAR86: VAR108});
FUN33(VAR106, VAR108);
}
function FUN45(address VAR80, uint VAR74) external VAR13{
uint256 VAR106 = uint256(VAR74);
require(VAR106==VAR74);
require(VAR97[VAR80].VAR84 && VAR52<VAR97[VAR80].VAR86);
require(VAR97[VAR80].VAR47 != msg.sender);
require(VAR97[VAR80].VAR72 == VAR74);
FUN15(VAR80).FUN23(VAR74, msg.sender);
delete VAR97[VAR80];
FUN34(VAR74, VAR52);
}
}
contract LovePromo is VAR109{
function FUN46(uint VAR110, uint VAR108) external VAR111 {
require(VAR108>=VAR110 && VAR110>FUN14(VAR52));
VAR89 = FUN14(VAR110);
VAR90 = FUN14(VAR108);
}
function FUN47(
uint VAR112,
uint VAR113,
uint VAR114,
uint VAR115) external VAR10 {
require(VAR112>=100);
require(VAR113>=50);
VAR91 = FUN14(VAR112);
VAR92 = FUN14(VAR113);
VAR87 = VAR114;
VAR88 = VAR115;
}
function FUN48(uint VAR116) external VAR10 {
VAR93 = FUN49(VAR116);
}
function FUN50() external view VAR117 returns(uint64 VAR110, uint64 VAR108){
VAR110 = FUN14(VAR89);
VAR108 = FUN14(VAR90);
}
function FUN51() external view VAR117 returns(
uint64 VAR112,
uint64 VAR113,
uint VAR114,
uint VAR115){
VAR112 = VAR91;
VAR113 = VAR92;
VAR114 = VAR87;
VAR115 = VAR88;
}
}
contract BankCore is VAR118 {
//
//
//
//
//
address public VAR119;
event FUN52(address VAR76, uint VAR17);
function FUN21() public {
VAR7 = true;
VAR4 = msg.sender;
VAR6 = msg.sender;
VAR5 = msg.sender;
}
function FUN53(address VAR120) external onlyCEO VAR14 {
VAR119 = VAR120;
FUN1(VAR120);
}
function FUN12() public onlyCEO VAR14 {
require(VAR119 == address(0));
super.FUN12();
}
function FUN54(address VAR80, address VAR65) external whenPaused VAR10{
require(VAR65 != address(0));
FUN15(VAR80).FUN19(VAR65);
}
function FUN55() external VAR121 {
if (this.VAR71 > 0) {
VAR5.transfer(this.VAR71);
}
}
function FUN56(address VAR122, address VAR123) external view returns(address){
bytes16 VAR124 = FUN37(FUN38(VAR122))^FUN37(FUN38(VAR123));
return VAR96[VAR124];
}
function FUN57() external payable{}
function() external payable VAR117 {
require(msg.value>0);
FUN52(msg.sender, msg.value);
}
}
1
---------------------------------
220 0xce566351442ffadaca79320e0c52788fa36910e1.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5() public view returns (uint256);
function FUN6(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 VAR9) public returns (bool);
event Transfer(address indexed VAR10, address indexed VAR11, uint256 value);
}
contract ERC20 is VAR6 {
function FUN7(address VAR12, address VAR13)
public view returns (uint256);
function FUN8(address VAR14, address VAR8, uint256 VAR9)
public returns (bool);
function FUN9(address VAR13, uint256 VAR9) public returns (bool);
event FUN10(
address indexed VAR15,
address indexed VAR16,
uint256 value
);
}
contract VAR17 {
address public VAR15;
event FUN11(address indexed VAR18);
event FUN12(
address indexed VAR18,
address indexed VAR19
);
constructor() public {
VAR15 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR20;
}
function FUN13() public onlyOwner {
emit FUN11(VAR15);
VAR15 = address(0);
}
function FUN14(address VAR21) public onlyOwner {
FUN15(VAR21);
}
function FUN15(address VAR21) internal {
require(VAR21 != address(0));
emit FUN12(VAR15, VAR21);
VAR15 = VAR21;
}
}
library VAR22 {
function FUN16(
ERC20Basic VAR23,
address VAR8,
uint256 VAR9
)
internal
{
require(VAR23.transfer(VAR8, VAR9));
}
function FUN17(
ERC20 VAR23,
address VAR14,
address VAR8,
uint256 VAR9
)
internal
{
require(VAR23.FUN8(VAR14, VAR8, VAR9));
}
function FUN18(
ERC20 VAR23,
address VAR13,
uint256 VAR9
)
internal
{
require(VAR23.FUN9(VAR13, VAR9));
}
}
contract CanReclaimToken is VAR17 {
using SafeERC20 for VAR6;
function FUN19(ERC20Basic VAR23) external onlyOwner {
uint256 VAR24 = VAR23.FUN6(this);
VAR23.FUN16(VAR15, VAR24);
}
}
contract IBasicMultiToken is VAR25 {
event FUN20(address indexed VAR26, address indexed VAR27, uint256 value);
event FUN21(address indexed VAR26, address indexed VAR27, uint256 value);
function FUN22() public view returns(uint256);
function FUN23(uint VAR28) public view returns(VAR25);
function FUN24() public view returns(bool);
function FUN25(address VAR29, uint256 VAR30, uint256[] VAR31) public;
function FUN26(address VAR29, uint256 VAR30) public;
function FUN27(address VAR29, uint256 VAR9) public;
function FUN28(address VAR29, uint256 VAR9, VAR25[] VAR32) public;
function FUN29() public;
function FUN30() public;
bytes4 public constant VAR33 = 0xd5c368b6;
}
contract IMultiToken is VAR34 {
event FUN31();
event FUN32(address indexed VAR35, address indexed VAR36, address indexed VAR37, uint256 VAR30, uint256 VAR38);
function FUN33(address VAR23) public view returns(uint256);
function FUN34() public view returns(bool);
function FUN35(address VAR35, address VAR36, uint256 VAR30) public view returns (uint256 VAR39);
function FUN36(address VAR35, address VAR36, uint256 VAR30, uint256 VAR40) public returns (uint256 VAR39);
function FUN37() public;
bytes4 public constant VAR41 = 0x81624e24;
}
library VAR42 {
using SafeMath for uint;
function FUN38(address VAR43) internal view returns(bool VAR44) {
VAR45 {
VAR44 := FUN39(FUN40(VAR43), 0)
}
}
function FUN41() internal pure returns(bool VAR44) {
VAR45 {
switch FUN42()
case 0 {
VAR44 := 1
}
case 32 {
FUN43(0, 0, 32)
VAR44 := FUN44(0)
}
default {
revert(0, 0)
}
}
}
function FUN45() internal pure returns(bytes32 VAR44) {
VAR45 {
switch FUN46(FUN42(), 32)
case 1 {
FUN43(0, 0, 32)
VAR44 := FUN44(0)
}
switch FUN39(FUN42(), 32)
case 1 {
FUN43(0, 64, 32)
VAR44 := FUN44(0)
}
switch FUN47(FUN42(), 32)
case 1 {
revert(0, 0)
}
}
}
function FUN48(address VAR46, address VAR11, uint256 value) internal returns(bool) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49("")), VAR11, value));
return FUN41();
}
function FUN50(address VAR46, address VAR10, address VAR11, uint256 value) internal returns(bool) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49("")), VAR10, VAR11, value));
return FUN41();
}
function FUN51(address VAR46, address VAR16, uint256 value) internal returns(bool) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49("")), VAR16, value));
return FUN41();
}
//
function FUN52(ERC20 VAR46, address VAR11, uint256 value) internal {
if (value > 0) {
uint256 VAR24 = VAR46.FUN6(this);
FUN48(VAR46, VAR11, value);
require(VAR46.FUN6(this) == VAR24.FUN3(value), "");
}
}
function FUN53(ERC20 VAR46, address VAR10, address VAR11, uint256 value) internal {
if (value > 0) {
uint256 VAR47 = VAR46.FUN6(VAR11);
FUN50(VAR46, VAR10, VAR11, value);
require(VAR46.FUN6(VAR11) == VAR47.FUN4(value), "");
}
}
//
function FUN54(address VAR46) internal view returns(bytes32) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49(""))));
return FUN45();
}
function FUN55(address VAR46) internal view returns(bytes32) {
require(FUN38(VAR46));
require(VAR46.call(bytes4(FUN49(""))));
return FUN45();
}
}
contract IEtherToken is VAR25 {
function FUN56() public payable;
function FUN57(uint256 VAR48) public;
}
contract VAR49 {
function FUN58(
address[] VAR50,
uint256 VAR48,
uint256 VAR51
)
public
payable
returns(uint256);
function FUN59(
address[] VAR50,
uint256 VAR48,
uint256 VAR51
)
public
payable
returns(uint256);
}
contract VAR52 {
function FUN60(
address VAR53,
uint VAR54,
address VAR55,
address VAR56,
uint VAR57,
uint VAR58,
address VAR59
)
public
payable
returns(uint);
}
contract MultiChanger is VAR60 {
using SafeMath for uint256;
using CheckedERC20 for VAR25;
function FUN61(address VAR61, uint value, bytes VAR62, uint VAR63, uint VAR64) internal returns (bool VAR44) {
VAR45 {
let VAR65 := FUN44(0x40)
let VAR66 := FUN4(VAR62, 32)
VAR44 := call(
FUN3(VAR67, 34710),
VAR61,
value,
FUN4(VAR66, VAR63),
VAR64,
VAR65,
0
)
}
}
function FUN36(bytes VAR68, uint[] VAR69) public payable {
for (uint VAR28 = 0; VAR28 < VAR69.VAR70 - 1; VAR28++) {
require(FUN61(this, 0, VAR68, VAR69[VAR28], VAR69[VAR28 + 1] - VAR69[VAR28]));
}
}
function FUN62(address VAR71, bytes VAR62, uint256 value) external {
require(VAR71.call.value(value)(VAR62));
}
function FUN63(address VAR71, bytes VAR62, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR24.FUN1(VAR72).FUN2(VAR73);
require(VAR71.call.value(value)(VAR62));
}
function FUN64(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR48) external {
if (VAR74.FUN7(this, VAR71) != 0) {
VAR74.FUN51(VAR71, 0);
}
VAR74.FUN51(VAR71, VAR48);
require(VAR71.call(VAR62));
}
function FUN65(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
if (VAR74.FUN7(this, VAR71) != 0) {
VAR74.FUN51(VAR71, 0);
}
VAR74.FUN51(VAR71, VAR48);
require(VAR71.call(VAR62));
}
function FUN66(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR48) external {
require(VAR74.FUN48(VAR71, VAR48));
if (VAR62.VAR70 != 0) {
require(VAR71.call(VAR62));
}
}
function FUN67(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
require(VAR74.FUN48(VAR71, VAR48));
if (VAR62.VAR70 != 0) {
require(VAR71.call(VAR62));
}
}
function FUN68(ERC20 VAR46, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR46.FUN6(this).FUN1(VAR72).FUN2(VAR73);
require(VAR46.FUN48(VAR75.VAR76, VAR48));
}
function FUN69(IMultiToken VAR77, ERC20 VAR74, ERC20 VAR78, uint256 VAR51, uint256 VAR48) external {
if (VAR74.FUN7(this, VAR77) == 0) {
VAR74.FUN51(VAR77, uint256(-1));
}
VAR77.FUN36(VAR74, VAR78, VAR48, VAR51);
}
function FUN70(IMultiToken VAR77, ERC20 VAR74, ERC20 VAR78, uint256 VAR51, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
this.FUN69(VAR77, VAR74, VAR78, VAR51, VAR48);
}
function FUN71(IEtherToken VAR79, uint256 VAR48) external {
VAR79.FUN57(VAR48);
}
function FUN72(IEtherToken VAR79, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR79.FUN6(this).FUN1(VAR72).FUN2(VAR73);
VAR79.FUN57(VAR48);
}
function FUN73(IBancorNetwork VAR80, address[] VAR50, uint256 value) external {
VAR80.VAR81.value(value)(VAR50, value, 1);
}
function FUN74(IBancorNetwork VAR80, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR24.FUN1(VAR72).FUN2(VAR73);
VAR80.VAR81.value(value)(VAR50, value, 1);
}
function FUN75(IBancorNetwork VAR80, address[] VAR50, uint256 VAR48) external {
if (FUN76(VAR50[0]).FUN7(this, VAR80) == 0) {
FUN76(VAR50[0]).FUN51(VAR80, uint256(-1));
}
VAR80.FUN59(VAR50, VAR48, 1);
}
function FUN77(IBancorNetwork VAR80, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN76(VAR50[0]).FUN6(this).FUN1(VAR72).FUN2(VAR73);
if (FUN76(VAR50[0]).FUN7(this, VAR80) == 0) {
FUN76(VAR50[0]).FUN51(VAR80, uint256(-1));
}
VAR80.FUN59(VAR50, VAR48, 1);
}
function FUN78(IBancorNetwork VAR80, address[] VAR50, uint256 VAR48) external {
FUN76(VAR50[0]).FUN48(VAR80, VAR48);
VAR80.FUN58(VAR50, VAR48, 1);
}
function FUN79(IBancorNetwork VAR80, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN76(VAR50[0]).FUN6(this).FUN1(VAR72).FUN2(VAR73);
FUN76(VAR50[0]).FUN48(VAR80, VAR48);
VAR80.FUN58(VAR50, VAR48, 1);
}
function FUN80(IBancorNetwork VAR80, address[] VAR50, uint256 VAR48) external {
VAR80.FUN58(VAR50, VAR48, 1);
}
function FUN81(IBancorNetwork VAR80, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN76(VAR50[0]).FUN6(VAR80).FUN1(VAR72).FUN2(VAR73);
VAR80.FUN58(VAR50, VAR48, 1);
}
function FUN82(IKyberNetworkProxy VAR82, ERC20 VAR74, address VAR78, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR24.FUN1(VAR72).FUN2(VAR73);
VAR82.VAR83.value(value)(
VAR74,
value,
VAR78,
this,
1 << 255,
0,
0
);
}
function FUN83(IKyberNetworkProxy VAR82, ERC20 VAR74, address VAR78, uint256 VAR48) external {
if (VAR74.FUN7(this, VAR82) == 0) {
VAR74.FUN51(VAR82, uint256(-1));
}
VAR82.FUN60(
VAR74,
VAR48,
VAR78,
this,
1 << 255,
0,
0
);
}
function FUN84(IKyberNetworkProxy VAR82, ERC20 VAR74, address VAR78, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN6(this).FUN1(VAR72).FUN2(VAR73);
this.FUN83(VAR82, VAR74, VAR78, VAR48);
}
}
1
---------------------------------
221 0xce5c603c78d047ef43032e96b5b785324f753a4f.sol
pragma VAR1 ^0.4.11;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
contract VAR2 {
function FUN1() constant returns (uint256 VAR3);
function FUN2(address VAR4) constant returns (uint256 VAR5);
function transfer(address VAR6, uint256 VAR7) returns (bool VAR8);
function FUN3(address VAR9, address VAR6, uint256 VAR7) returns (bool VAR8);
function FUN4(address VAR10, uint256 VAR7) returns (bool VAR8);
function FUN5(address VAR4, address VAR10) constant returns (uint256 VAR11);
event Transfer(address indexed VAR9, address indexed VAR6, uint256 VAR7);
event FUN6(address indexed VAR4, address indexed VAR10, uint256 VAR7);
}
contract VAR12
{
function FUN7(address VAR13) constant returns(uint VAR14);
function FUN8() public returns (uint VAR15);
function FUN9(address VAR6) returns (bool VAR8);
function FUN10(address VAR13) constant returns(uint VAR16, uint VAR17, uint VAR18);
}
contract VAR19
{
function FUN11() public;
}
contract E4Lava is VAR2, VAR12, VAR19 {
event FUN12(string msg);
event FUN13(string msg, uint VAR20);
enum VAR21  {VAR22, VAR23}
struct VAR24 {
bool VAR25;
uint VAR26;
uint VAR27;
uint VAR28;
}
uint constant VAR29         = 5762;
uint constant VAR30 = 100000;
uint constant VAR31        = 5762 * 100000;
uint public VAR32;
uint public VAR33;
uint public VAR34;
address public VAR35;
address public VAR36;
address public VAR37;
address public VAR38;
uint public VAR39;
string public VAR40;
mapping (address => VAR24) VAR41;
mapping (uint => address) VAR42;
mapping (address => mapping (address => uint256)) VAR43;
uint public VAR44;
uint public VAR45;
uint public VAR46;
uint public VAR47;
uint public VAR48;
uint public VAR49 = 1525219201;
SettingStateValue public VAR50;
function FUN14()
{
VAR36 = msg.sender;
VAR35 = msg.sender;
VAR39 = 2;
VAR40 = "";
}
function FUN15(SettingStateValue VAR51, uint VAR52, uint VAR53, uint VAR54, uint VAR55 )
{
if (msg.sender != VAR36)
return;
VAR45 = VAR52;
VAR46 = VAR53;
VAR47 = VAR54;
VAR48 = VAR55;
if (VAR50 == VAR21.VAR23)
return;
VAR50 = VAR51;
if (VAR51 == VAR21.VAR23) {
FUN12("");
return;
}
for (uint VAR56 = 0; VAR56 < VAR44; VAR56++ ) {
address VAR57 = VAR42[VAR56];
if (VAR57 != address(0)) {
VAR41[VAR57].VAR26 = 0;
VAR41[VAR57].VAR27 = 0;
VAR41[VAR57].VAR28 = 0;
}
}
VAR32 = 0;
VAR33 = 0;
VAR34 = 0;
if (this.VAR5 > 0) {
if (!VAR36.call.FUN16(VAR46).value(this.VAR5)())
FUN12("");
}
FUN12("");
}
function FUN17(address VAR13) internal  {
VAR41[VAR13].VAR25 = true;
VAR41[VAR13].VAR26 = 0;
VAR41[VAR13].VAR27 = 0;
VAR41[VAR13].VAR28 = VAR34;
VAR42[VAR44++] = VAR13;
}
function FUN1() constant returns (uint256 VAR3)
{
VAR3 = VAR31;
}
function transfer(address VAR6, uint256 VAR7) returns (bool VAR8)
{
if ((msg.sender == VAR35)
&&  (VAR58 < VAR49)) {
return false;
}
if (VAR41[msg.sender].VAR26 >= VAR7 && VAR7 > 0) {
FUN18(msg.sender);
VAR41[msg.sender].VAR26 -= VAR7;
if (!VAR41[VAR6].VAR25) {
FUN17(VAR6);
}
FUN18(VAR6);
VAR41[VAR6].VAR26 += VAR7;
Transfer(msg.sender, VAR6, VAR7);
return true;
} else {
return false;
}
}
function FUN3(address VAR9, address VAR6, uint256 VAR7) returns (bool VAR8) {
if ((VAR9 == VAR35)
&&  (VAR58 < VAR49)) {
return false;
}
if (VAR41[VAR9].VAR26 >= VAR7 && VAR43[VAR9][msg.sender] >= VAR7 && VAR7 > 0) {
FUN18(VAR9);
VAR41[VAR9].VAR26 -= VAR7;
if (!VAR41[VAR6].VAR25) {
FUN17(VAR6);
}
FUN18(VAR6);
VAR41[VAR6].VAR26 += VAR7;
VAR43[VAR9][msg.sender] -= VAR7;
Transfer(VAR9, VAR6, VAR7);
return true;
} else {
return false;
}
}
function FUN2(address VAR4) constant returns (uint256 VAR5) {
VAR5 = VAR41[VAR4].VAR26;
}
function FUN4(address VAR10, uint256 VAR7) returns (bool VAR8) {
VAR43[msg.sender][VAR10] = VAR7;
FUN6(msg.sender, VAR10, VAR7);
return true;
}
function FUN5(address VAR4, address VAR10) constant returns (uint256 VAR11) {
return VAR43[VAR4][VAR10];
}
function FUN18(address VAR59) internal {
VAR41[VAR59].VAR27 += (VAR34 - VAR41[VAR59].VAR28) * VAR41[VAR59].VAR26;
VAR41[VAR59].VAR28 = VAR34;
}
function () payable {
VAR33 += msg.value;
VAR34 += msg.value;
FUN13("", msg.value);
}
function FUN19() payable {
FUN13("", msg.value);
}
function FUN8() public returns (uint VAR14)
{
FUN18(msg.sender);
VAR14 = VAR41[msg.sender].VAR27 / VAR31;
if (VAR14 <= VAR45) {
FUN13("", VAR14);
return;
} else {
if ((msg.sender == VAR35)
&&  (VAR58 < VAR49)) {
FUN12("");
VAR14 = 0;
return;
}
uint VAR60 = VAR14 * VAR31;
VAR41[msg.sender].VAR27 -= VAR60;
VAR33 -= VAR14;
if (!msg.sender.call.FUN16(VAR46).value(VAR14)())
throw;
}
}
function FUN9(address VAR6) returns (bool VAR8)
{
if ((msg.sender == VAR35)
&&  (VAR58 < VAR49)) {
return false;
}
FUN18(msg.sender);
if (VAR41[msg.sender].VAR27 == 0) {
FUN12("");
return false;
}
if (!VAR41[VAR6].VAR25) {
FUN17(VAR6);
}
FUN18(VAR6);
VAR41[VAR6].VAR27 += VAR41[msg.sender].VAR27;
VAR41[msg.sender].VAR27 = 0;
FUN12("");
return true;
}
function FUN20(uint VAR53, uint VAR54, uint VAR55)
{
if (msg.sender != VAR36 && msg.sender != VAR35) {
return;
} else {
VAR46 = VAR53;
VAR47 = VAR54;
VAR48 = VAR55;
}
}
function FUN7(address VAR13) constant returns(uint VAR14)
{
if (VAR41[VAR13].VAR25) {
uint VAR61 = VAR41[VAR13].VAR27 +
((VAR34 - VAR41[VAR13].VAR28) * VAR41[VAR13].VAR26);
VAR14 = VAR61 / VAR31;
}
}
function FUN21(address VAR13)
{
if (msg.sender != VAR36
|| VAR50 == VAR21.VAR23)
throw;
VAR36 = VAR13;
}
function FUN22(address VAR13)
{
if (msg.sender != VAR36
|| VAR50 == VAR21.VAR23)
throw;
VAR35 = VAR13;
}
function FUN23(address VAR62, address VAR63)
{
if (msg.sender != VAR36
|| VAR50 == VAR21.VAR23)
throw;
VAR37 = VAR62;
VAR38 = VAR63;
}
function FUN10(address VAR13) constant returns(uint VAR16, uint VAR17, uint VAR18)
{
VAR16 = VAR41[VAR13].VAR26;
VAR17 = VAR41[VAR13].VAR28;
VAR18 = VAR41[VAR13].VAR27;
}
function FUN24()
{
if (VAR50 != VAR21.VAR22)
throw;
if (msg.sender != VAR36)
throw;
FUN25(VAR35);
}
function FUN11() public
{
if (VAR37 == address(0)) {
FUN12("");
return;
}
address VAR64 = msg.sender;
if (VAR41[VAR64].VAR26 != 0) {
FUN12("");
return;
}
Token VAR65 = FUN26(VAR37);
uint VAR66 = VAR65.FUN2(VAR64);
if (VAR66 == 0) {
FUN12("");
return;
}
if (VAR65.FUN5(VAR64, address(this)) < VAR66) {
FUN12("");
return;
}
if (msg.VAR67 < VAR47 + VAR48)
throw;
VAR65.VAR68.FUN16(VAR47)(VAR64, VAR38, VAR66);
if (VAR65.FUN2(VAR64) == 0) {
if (!VAR41[VAR64].VAR25)
FUN17(VAR64);
VAR41[VAR64].VAR26 = VAR66 * VAR30;
VAR41[VAR64].VAR28 = 0;
FUN18(VAR64);
VAR32 += VAR66;
FUN12("");
} else
FUN12("");
}
}
1
---------------------------------
222 0xcee7eea7e58434997a59049f7da4d0ad46f1f141.sol
pragma VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
contract VAR6 {
address public VAR7;
constructor() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR8;
}
function FUN6(address VAR9) public onlyOwner {
if (VAR9 != address(0)) {
VAR7 = VAR9;
}
}
}
interface VAR10 {
function FUN7() external view returns (uint VAR11);
function FUN8(address VAR12) external view returns (uint VAR13);
function transfer(address VAR14, uint VAR15) external;
function FUN9(address VAR16, address VAR14, uint VAR15) external;
function FUN10(address VAR17, uint VAR15) external;
function FUN11(address VAR12, address VAR17) external view returns (uint VAR18);
function FUN12() external view returns(uint VAR19);
event FUN13(address indexed VAR12, address indexed VAR17, uint VAR15);
}
interface VAR20 {
event FUN14( ERC20 VAR21, uint256 VAR22, ERC20 VAR23, uint256 VAR24);
function FUN15(
ERC20 VAR21,
ERC20 VAR23,
uint256 VAR22
)
external
payable
returns(uint256);
function FUN16(
ERC20 VAR21,
ERC20 VAR23,
uint256 VAR22
)
external
view
returns(uint256, uint256);
}
contract KulapDex is VAR6 {
event FUN14(
address indexed VAR25,
uint256         VAR26,
address indexed VAR27,
uint256         VAR28,
address indexed VAR29,
uint256          VAR30
);
using SafeMath for uint256;
ERC20 public VAR31 = FUN17(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
VAR20[] public VAR32;
function FUN18(
uint256 VAR33,
uint256 VAR22,
ERC20 VAR23
)
private
returns(uint256)  {
KULAPTradingProxy VAR34 = VAR32[VAR33];
uint256 VAR24 = VAR34.VAR35.value(VAR22)(
VAR31,
VAR23,
VAR22
);
return VAR24;
}
function () public payable {
}
function FUN19(
uint256 VAR33,
ERC20 VAR21,
uint256 VAR22
)
private
returns(uint256)  {
KULAPTradingProxy VAR34 = VAR32[VAR33];
VAR21.FUN10(VAR34, VAR22);
uint256 VAR24 = VAR34.FUN15(
VAR21,
VAR31,
VAR22
);
return VAR24;
}
function FUN20(
uint256 VAR33,
ERC20 VAR21,
uint256 VAR22,
ERC20 VAR23
)
private
returns(uint256)  {
KULAPTradingProxy VAR34 = VAR32[VAR33];
VAR21.FUN10(VAR34, VAR22);
uint256 VAR24 = VAR34.FUN15(
VAR21,
VAR23,
VAR22
);
return VAR24;
}
//
function FUN21(
uint256             VAR36,
ERC20               VAR37,
uint256             VAR26,
ERC20               VAR38,
uint256             VAR39
) private returns(uint256)  {
uint256 VAR24;
uint256 VAR40;
uint256 VAR41;
if (VAR31 == VAR37) {
VAR40 = address(this).VAR13;
} else {
VAR40 = VAR37.FUN8(this);
}
if (VAR31 == VAR38) {
VAR41 = address(this).VAR13;
} else {
VAR41 = VAR38.FUN8(this);
}
if (VAR31 == VAR37) {
VAR24 = FUN18(VAR36, VAR26, VAR38);
} else if (VAR31 == VAR38) {
VAR24 = FUN19(VAR36, VAR37, VAR26);
} else {
VAR24 = FUN20(VAR36, VAR37, VAR26, VAR38);
}
if (VAR31 == VAR37) {
require(address(this).VAR13 == VAR40.FUN3(VAR26), "");
} else {
require(VAR37.FUN8(this) == VAR40.FUN3(VAR26), "");
}
if (VAR31 == VAR38) {
require(address(this).VAR13 == VAR41.FUN4(VAR24), "");
} else {
require(VAR38.FUN8(this) == VAR41.FUN4(VAR24), "");
}
require(VAR24 >= VAR39, "");
return VAR24;
}
//
function FUN15(uint256 VAR33, ERC20 VAR21, uint256 VAR22, ERC20 VAR23, uint256 VAR42) payable public returns(uint256)  {
uint256 VAR24;
if (VAR31 != VAR21) {
VAR21.FUN9(msg.sender, address(this), VAR22);
}
VAR24 = FUN21(VAR33, VAR21, VAR22, VAR23, 1);
require(VAR24 >= VAR42, "");
if (VAR31 == VAR23) {
msg.sender.transfer(VAR24);
} else {
VAR23.transfer(msg.sender, VAR24);
}
emit FUN14(VAR21, VAR22, VAR23, VAR24, msg.sender, 0);
return VAR24;
}
//
function FUN22(
ERC20 VAR21,
uint256 VAR22,
ERC20 VAR23,
uint256 VAR42,
address[] VAR43)
public payable returns(uint256)  {
uint256 VAR24;
if (VAR31 != VAR21) {
VAR21.FUN9(msg.sender, address(this), VAR22);
}
uint256 VAR44 = VAR22;
for (uint VAR45 = 0; VAR45 < VAR43.VAR46; VAR45 += 3) {
uint256 VAR33 =         uint256(VAR43[VAR45]);
ERC20 VAR47 =                     FUN17(VAR43[VAR45+1]);
ERC20 VAR48 =                    FUN17(VAR43[VAR45+2]);
VAR24 = FUN21(VAR33, VAR47, VAR44, VAR48, 1);
VAR44 = VAR24;
}
require(VAR24 >= VAR42, "");
if (VAR31 == VAR23) {
msg.sender.transfer(VAR24);
} else {
VAR23.transfer(msg.sender, VAR24);
}
emit FUN14(VAR21, VAR22, VAR23, VAR24, msg.sender, 0);
return VAR24;
}
function FUN16(uint256 VAR33, ERC20 VAR21, ERC20 VAR23, uint VAR22) public view returns(uint, uint) {
KULAPTradingProxy VAR34 = VAR32[VAR33];
return VAR34.FUN16(VAR21, VAR23, VAR22);
}
function FUN23(
KULAPTradingProxy VAR49
) public onlyOwner returns (uint256) {
VAR32.FUN24(VAR49);
return VAR32.VAR46;
}
}
1
---------------------------------
223 0xcf265a52d48b1408c00d585e28e0738aae27b0f3.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function FUN1() public constant returns (uint256);
function FUN2(address VAR3) public constant returns (uint256 VAR4);
function FUN3(address VAR3, address VAR5) public constant returns (uint256 VAR6);
function transfer(address VAR7, uint256 VAR8) public returns (bool VAR9);
function FUN4(address VAR5, uint256 VAR8) public returns (bool VAR9);
function FUN5(address VAR10, address VAR7, uint256 VAR8) public returns (bool VAR9);
event Transfer(address indexed VAR10, address indexed VAR7, uint VAR8);
event FUN6(address indexed VAR3, address indexed VAR5, uint VAR8);
}
contract VAR11 {
function FUN7(address) public payable returns(uint256){}
function FUN8() public {}
function FUN9() public view returns(uint256){}
}
contract VAR12 {
address public VAR13;
address public VAR14;
function FUN10() public {
VAR13 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR13);
VAR15;
}
function FUN11(address VAR16) public onlyOwner {
VAR14 = VAR16;
}
function FUN12() public {
require(msg.sender == VAR14);
VAR13 = VAR14;
}
}
contract BoomerangLiquidity is VAR12 {
modifier onlyOwner(){
require(msg.sender == VAR13);
VAR15;
}
modifier FUN13(address VAR17){
require(VAR17 != VAR18);
VAR15;
}
uint public VAR19;
uint public VAR20 = 0;
address VAR18;
POWH VAR21;
function FUN14(uint VAR22, address VAR23) public {
VAR19 = VAR22;
VAR18 = VAR23;
VAR21 = FUN15(VAR18);
}
struct VAR24 {
address VAR25;
uint VAR26;
}
VAR24[] public VAR27;
function() payable public {
}
function FUN16() payable public {
VAR27.FUN17(FUN18(msg.sender, (msg.value * VAR19) / 100));
if(FUN9() > 0){
FUN8();
}
FUN19();
}
function FUN19() public {
uint VAR4 = address(this).VAR4;
require(VAR4 > 1);
uint VAR28 = VAR4 / 2;
VAR4 -= VAR28;
VAR21.VAR29.value(VAR28).FUN20(1000000)(msg.sender);
while (VAR4 > 0) {
uint VAR30 = VAR4 < VAR27[VAR20].VAR26 ? VAR4 : VAR27[VAR20].VAR26;
if(VAR30 > 0){
VAR27[VAR20].VAR26 -= VAR30;
VAR4 -= VAR30;
if(!VAR27[VAR20].VAR25.FUN21(VAR30)){
VAR27[VAR20].VAR25.call.value(VAR30).FUN20(1000000)();
}
}
if(VAR4 > 0){
VAR20 += 1;
}
if(VAR20 >= VAR27.VAR31){
return;
}
}
}
function FUN9() public view returns(uint256){
VAR21.FUN9();
}
function FUN8() public {
VAR21.VAR32.FUN20(1000000)();
}
function FUN22() payable public {
}
function FUN23(address VAR33, uint VAR8) public onlyOwner FUN13(VAR33) returns (bool VAR9) {
return FUN24(VAR33).transfer(VAR13, VAR8);
}
}
1
---------------------------------
224 0xcf3dbc9dcaeb6936b8cefbf9f81b655651a92485.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
bool public VAR42;
bool public VAR43;
bool public VAR44;
address public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => uint256) public VAR47;
mapping (address => bool) public VAR48;
uint public VAR49;
enum VAR50{VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57, VAR58}
event FUN26(address VAR59, uint VAR60, uint VAR21, uint128 VAR61);
event FUN27(address VAR59, uint VAR60);
event FUN28(bool VAR43, bool VAR44, address VAR45);
event FUN29(address VAR62, bool VAR63);
event FUN30(uint VAR38);
function FUN31(address VAR64, PricingStrategy VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR69) {
VAR9 = msg.sender;
VAR32 = FUN32(VAR64);
FUN33(VAR65);
VAR35 = VAR66;
if(VAR35 == 0) {
throw;
}
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR68 == 0) {
throw;
}
VAR38 = VAR68;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR69;
}
function() payable {
throw;
}
function FUN34(address VAR70, uint128 VAR61) stopInEmergency private {
if(FUN35() == VAR50.VAR53) {
if(!VAR48[VAR70]) {
throw;
}
} else if(FUN35() == VAR50.VAR54) {
} else {
throw;
}
uint VAR60 = msg.value;
uint VAR21 = VAR33.FUN18(VAR60, VAR17, VAR18, msg.sender, VAR32.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR46[VAR70] == 0) {
VAR39++;
}
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR60, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR70, VAR21);
if(!VAR35.FUN39(VAR60)) throw;
FUN26(VAR70, VAR60, VAR21, VAR61);
}
function FUN40(address VAR70, uint VAR71, uint VAR72) public onlyOwner {
uint VAR21 = VAR71 * 10**VAR32.FUN36();
uint VAR60 = VAR72 * VAR71;
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
FUN38(VAR70, VAR21);
FUN26(VAR70, VAR60, VAR21, 0);
}
function FUN41(address VAR62, uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
bytes32 VAR76 = FUN42(VAR62);
if (FUN43(VAR76, VAR73, VAR74, VAR75) != VAR45) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN44(address VAR62, uint128 VAR61) public payable {
if(VAR44) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN45(address VAR62) public payable {
if(VAR43) throw;
if(VAR44) throw;
FUN34(VAR62, 0);
}
function FUN46(uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
FUN41(msg.sender, VAR61, VAR73, VAR74, VAR75);
}
function FUN47(uint128 VAR61) public payable {
FUN44(msg.sender, VAR61);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR50.VAR55) onlyOwner VAR13 {
if(VAR42) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN20();
}
VAR42 = true;
}
function FUN51(FinalizeAgent VAR62) onlyOwner {
VAR34 = VAR62;
if(!VAR34.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR43 = value;
FUN28(VAR43, VAR44, VAR45);
}
function FUN53(bool value, address VAR77) onlyOwner {
VAR44 = value;
VAR45 = VAR77;
FUN28(VAR43, VAR44, VAR45);
}
function FUN54(address VAR62, bool VAR63) onlyOwner {
VAR48[VAR62] = VAR63;
FUN29(VAR62, VAR63);
}
function FUN55(uint VAR78) onlyOwner {
if(VAR79 > VAR78) {
throw;
}
VAR38 = VAR78;
FUN30(VAR38);
}
function FUN33(PricingStrategy VAR65) onlyOwner {
VAR33 = VAR65;
if(!VAR33.FUN16()) {
throw;
}
}
function FUN56(address VAR62) public onlyOwner {
if(VAR39 > VAR31) {
throw;
}
VAR35 = VAR62;
}
function FUN57() public payable FUN50(VAR50.VAR56) {
if(msg.value == 0) throw;
VAR40 = VAR40.FUN11(msg.value);
}
function FUN58() public FUN50(VAR50.VAR58) {
uint256 VAR80 = VAR46[msg.sender];
if (VAR80 == 0) throw;
VAR46[msg.sender] = 0;
VAR41 = VAR41.FUN11(VAR80);
FUN27(msg.sender, VAR80);
if (!msg.sender.FUN39(VAR80)) throw;
}
function FUN59() public constant returns (bool VAR81) {
return VAR17 >= VAR36;
}
function FUN60() public constant returns (bool VAR82) {
return VAR34.FUN17();
}
function FUN61() public constant returns (bool VAR82) {
return VAR33.FUN17(address(this));
}
function FUN35() public constant returns (VAR50) {
if(VAR42) return VAR50.VAR57;
else if (address(VAR34) == 0) return VAR50.VAR52;
else if (!VAR34.FUN17()) return VAR50.VAR52;
else if (!VAR33.FUN17(address(this))) return VAR50.VAR52;
else if (VAR83.VAR84 < VAR37) return VAR50.VAR53;
else if (VAR83.VAR84 <= VAR38 && !FUN62()) return VAR50.VAR54;
else if (FUN59()) return VAR50.VAR55;
else if (!FUN59() && VAR17 > 0 && VAR40 >= VAR17) return VAR50.VAR58;
else return VAR50.VAR56;
}
function FUN63(uint VAR85) onlyOwner {
VAR49 = VAR85;
}
function FUN64() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR86) {
if(FUN35() != VAR86) throw;
VAR10;
}
//
//
function FUN37(uint VAR60, uint VAR21, uint VAR87, uint VAR88) constant returns (bool VAR89);
function FUN62() public constant returns (bool);
function FUN38(address VAR70, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN65(address VAR70, uint VAR90);
mapping(address => uint) VAR91;
mapping (address => mapping (address => uint)) VAR92;
modifier FUN66(uint VAR93) {
if(msg.VAR94.VAR95 < VAR93 + 4) {
throw;
}
VAR10;
}
function transfer(address VAR96, uint VAR97) FUN66(2 * 32) returns (bool VAR98) {
VAR91[msg.sender] = FUN3(VAR91[msg.sender], VAR97);
VAR91[VAR96] = FUN4(VAR91[VAR96], VAR97);
Transfer(msg.sender, VAR96, VAR97);
return true;
}
function FUN23(address VAR99, address VAR96, uint VAR97) returns (bool VAR98) {
uint VAR100 = VAR92[VAR99][msg.sender];
VAR91[VAR96] = FUN4(VAR91[VAR96], VAR97);
VAR91[VAR99] = FUN3(VAR91[VAR99], VAR97);
VAR92[VAR99][msg.sender] = FUN3(VAR100, VAR97);
Transfer(VAR99, VAR96, VAR97);
return true;
}
function FUN21(address VAR101) constant returns (uint VAR102) {
return VAR91[VAR101];
}
function FUN24(address VAR103, uint VAR97) returns (bool VAR98) {
if ((VAR97 != 0) && (VAR92[msg.sender][VAR103] != 0)) throw;
VAR92[msg.sender][VAR103] = VAR97;
FUN25(msg.sender, VAR103, VAR97);
return true;
}
function FUN22(address VAR101, address VAR103) constant returns (uint VAR104) {
return VAR92[VAR101][VAR103];
}
function FUN67(address VAR103, uint VAR105)
FUN66(2 * 32)
returns (bool VAR98) {
uint VAR106 = VAR92[msg.sender][VAR103];
VAR92[msg.sender][VAR103] = FUN4(VAR106, VAR105);
FUN25(msg.sender, VAR103, VAR92[msg.sender][VAR103]);
return true;
}
function FUN68(address VAR103, uint VAR107)
FUN66(2 * 32)
returns (bool VAR98) {
uint VAR108 = VAR92[msg.sender][VAR103];
if (VAR107 > VAR108) {
VAR92[msg.sender][VAR103] = 0;
} else {
VAR92[msg.sender][VAR103] = FUN3(VAR108, VAR107);
}
FUN25(msg.sender, VAR103, VAR92[msg.sender][VAR103]);
return true;
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR39;
uint public VAR87;
address[] public VAR109;
mapping(address => uint) public VAR91;
mapping(address => uint) public VAR110;
uint public VAR111;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
uint public VAR116;
Crowdsale public VAR16;
enum VAR50{VAR51, VAR54, VAR117, VAR58}
event FUN26(address VAR59, uint value);
event FUN69(address VAR59, uint value);
event FUN70(uint VAR118);
event FUN71(address VAR109, uint VAR118);
function FUN72(address VAR101, uint VAR119, uint VAR120, uint VAR121) {
VAR9 = VAR101;
if(VAR119 == 0) {
throw;
}
if(VAR120 == 0) {
throw;
}
VAR112 = VAR120;
VAR113 = VAR121;
VAR111 = VAR119;
}
function FUN73() public constant returns(VAR122) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN74();
}
function FUN45() public stopInEmergency payable {
if(FUN35() != VAR50.VAR54) throw;
if(msg.value == 0) throw;
address VAR59 = msg.sender;
bool VAR123 = VAR91[VAR59] > 0;
VAR91[VAR59] = FUN4(VAR91[VAR59], msg.value);
if(VAR91[VAR59] < VAR112) {
throw;
}
if(!VAR123) {
VAR109.FUN75(VAR59);
VAR39++;
}
VAR87 = FUN4(VAR87, msg.value);
if(VAR87 > VAR113) {
throw;
}
FUN26(VAR59, msg.value);
}
function FUN76() stopInEmergency public {
if(FUN35() != VAR50.VAR54) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR124.value(VAR87)(address(this));
VAR114 = FUN73().FUN21(address(this));
if(VAR114 == 0) {
throw;
}
FUN70(VAR114);
}
function FUN77(address VAR59) public constant returns (uint) {
if(FUN35() != VAR50.VAR117) {
throw;
}
return FUN1(VAR91[VAR59], VAR114) / VAR87;
}
function FUN78(address VAR59) public constant returns (uint) {
return FUN3(FUN77(VAR59), VAR110[VAR59]);
}
function FUN79() {
FUN80(FUN78(msg.sender));
}
function FUN80(uint VAR90) VAR13 {
address VAR59 = msg.sender;
if(VAR90 == 0) {
throw;
}
if(FUN78(VAR59) < VAR90) {
throw;
}
if(VAR110[VAR59] == 0) {
VAR115++;
}
VAR110[VAR59] = FUN4(VAR110[VAR59], VAR90);
VAR116 = FUN4(VAR116, VAR90);
FUN73().transfer(VAR59, VAR90);
FUN71(VAR59, VAR90);
}
function FUN58() VAR13 {
if(FUN35() != VAR50.VAR58) throw;
address VAR59 = msg.sender;
if(VAR91[VAR59] == 0) throw;
uint VAR90 = VAR91[VAR59];
delete VAR91[VAR59];
if(!VAR59.FUN39(VAR90)) throw;
FUN69(VAR59, VAR90);
}
function FUN81(Crowdsale VAR125) public onlyOwner {
VAR16 = VAR125;
if(!VAR16.FUN64()) true;
}
function FUN35() public returns(VAR50) {
if(VAR114 == 0) {
if(VAR79 >= VAR111) {
return VAR50.VAR58;
} else {
return VAR50.VAR54;
}
} else {
return VAR50.VAR117;
}
}
function() payable {
throw;
}
}
1
---------------------------------
225 0xcf91d43b85a5c53d85c567d4eed972965335aeea.sol
pragma VAR1 ^0.4.25;
interface VAR2  {
function() payable external;
function FUN1(address VAR3)
external
payable
;
function FUN2()
external
;
function FUN3()
external
view
returns(uint256);
function FUN4()
external;
function FUN5(address VAR4) external payable;
function FUN6(address VAR5) external;
function FUN7() external;
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN8(address indexed VAR9, address indexed VAR10);
constructor() public {
VAR7 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR11;
}
function FUN9(address VAR12) public onlyOwner {
VAR7 = VAR12;
}
}
library VAR13 {
function FUN10(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
VAR16 = VAR14 + VAR15;
require(VAR16 >= VAR14);
}
function FUN11(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
require(VAR15 <= VAR14);
VAR16 = VAR14 - VAR15;
}
function FUN12(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
VAR16 = VAR14 * VAR15;
require(VAR14 == 0 || VAR16 / VAR14 == VAR15);
}
function FUN13(uint VAR14, uint VAR15) internal pure returns (uint VAR16) {
require(VAR15 > 0);
VAR16 = VAR14 / VAR15;
}
}
contract Slaughter3D is  VAR6 {
using SafeMath for uint;
Snip3DInterface constant VAR17 = FUN14(0xb172BB8BAae74F27Ade3211E0c145388d3b4f8d8);
function FUN15()
view
public
returns(uint256)
{
return ( address(this).VAR18)  ;
}
function FUN16()
view
public
returns(uint256)
{
return ( VAR17.FUN3())  ;
}
function FUN17 () onlyOwner public payable {
VAR17.VAR19.value(0.1 VAR20)(msg.sender);
}
function FUN18 () onlyOwner public {
VAR17.FUN4();
}
function FUN19 () public {
VAR17.FUN2();
}
function FUN20 () onlyOwner public {
msg.sender.transfer(address(this).VAR18);
}
function () external payable{}
}
1
---------------------------------
226 0xd022969da8a1ace11e2974b3e7ee476c3f9f99c6.sol
pragma VAR1 ^0.4.11;
contract VAR2
{
address VAR3 = msg.sender;
event FUN1(uint VAR4,bytes32 VAR5,address VAR6,address VAR7);
mapping(address => uint) VAR8;
uint public VAR9 = 0.1 VAR10;
function FUN2(uint VAR4, bytes32 VAR5, address VAR6, address VAR7)
payable
{
if(msg.sender != address(this))throw;
if(VAR6.call.value(VAR4)())
{
FUN1(VAR4, VAR5, VAR6, VAR7);
}
}
function FUN3()
public
payable
{
if (msg.value > VAR9)
{
VAR8[msg.sender] += msg.value;
}
}
function FUN4(uint VAR4)
public
{
if ( VAR8[msg.sender] > 0 && VAR4 > 0)
{
this.FUN2(VAR4, "", msg.sender, VAR3);
VAR8[msg.sender] -= VAR4;
}
}
function FUN5(uint VAR11)
public
{
if(msg.sender==VAR3)
{
VAR9 = VAR11;
}
}
function FUN6()
constant
public
returns(uint)
{
return VAR8[msg.sender];
}
function FUN7()
public
{
if(msg.sender==VAR3)
{
this.FUN2(this.VAR12, "", msg.sender, VAR3);
}
}
}
1
---------------------------------
227 0xd10e893b4d75f266407c23ffdd1c12482cc84d09.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
function FUN1() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN2(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN3() public view returns (uint256);
function FUN4(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool VAR9);
function FUN5(address VAR10, address VAR8, uint256 value) public returns (bool VAR9);
function FUN6(address VAR11, uint256 value) public returns (bool VAR9);
function FUN7(address VAR3, address VAR11) public view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN8(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract WibsonInvestment is VAR2 {
address public VAR13 = 0xBe25379a36948DfC1a98CdB1Ec7eF155A8D3Fd81;
address public VAR14 = 0x8f0592bDCeE38774d93bC1fd2c97ee6540385356;
address public VAR15 = 0xC787C3f6F75D7195361b64318CE019f90507f806;
uint public VAR16 = 1000;
function() payable public {
FUN9(msg.value);
}
function FUN9(uint VAR17) internal {
uint VAR18 = (VAR17 * 10 / 11) + 1;
require(VAR13.call.FUN10(VAR16).value(VAR18)());
uint VAR19 = VAR17 - VAR18;
uint VAR20 = VAR19 * 6 / 10;
uint VAR21 = VAR19 - VAR20;
require(VAR14.call.FUN10(VAR16).value(VAR20)());
require(VAR15.call.FUN10(VAR16).value(VAR21)());
}
function FUN11(uint VAR22) public onlyOwner {
VAR16 = VAR22;
}
function FUN12(EIP20Token VAR23, address VAR24, uint value) public onlyOwner {
VAR23.FUN6(VAR24, value);
}
function FUN13() public onlyOwner {
require(msg.sender.call.FUN10(VAR16).value(this.VAR25)());
}
}
1
---------------------------------
228 0xd116d1349c1382b0b302086a4e4219ae4f8634ff.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
function FUN1(address VAR7)
{
VAR6 = FUN2(VAR7);
}
function FUN3()
public
payable
{
if(msg.value > VAR4)
{
VAR3[msg.sender]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
}
}
function FUN5(uint VAR8)
{
if(VAR8<=VAR3[msg.sender])
{
if(msg.sender.call.value(VAR8)())
{
VAR3[msg.sender]-=VAR8;
VAR6.FUN4(msg.sender,VAR8,"");
}
}
}
function() public payable{}
}
contract VAR9
{
struct VAR10
{
address VAR11;
string  VAR12;
uint VAR13;
uint  VAR14;
}
VAR10[] public VAR15;
Message VAR16;
function FUN4(address VAR17,uint VAR18,string VAR19)
public
{
VAR16.VAR11 = VAR17;
VAR16.VAR14 = VAR20;
VAR16.VAR13 = VAR18;
VAR16.VAR12 = VAR19;
VAR15.FUN6(VAR16);
}
}
1
---------------------------------
229 0xd318914b05ad3c4be34e71e02d4fab8dbf66dc57.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function FUN1(bytes32 VAR3) constant returns (uint64 value);
function FUN2(bytes32 VAR3) returns (uint256 value);
function FUN3(bytes32 VAR3) payable;
}
contract VAR4 {
uint256 public VAR5;
function FUN4(address VAR6) public constant returns (uint256);
function transfer(address VAR7, uint256 value) public returns (bool);
event Transfer(address indexed VAR8, address indexed VAR7, uint256 value);
}
contract ERC20 is VAR4 {
function FUN5(address VAR9, address VAR10) public constant returns (uint256);
function FUN6(address VAR8, address VAR7, uint256 value) public returns (bool);
function FUN7(address VAR10, uint256 value) public returns (bool);
event FUN8(address indexed VAR9, address indexed VAR10, uint256 value);
}
library VAR11 {
function FUN9(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
uint256 VAR14 = VAR12 * VAR13;
assert(VAR12 == 0 || VAR14 / VAR12 == VAR13);
return VAR14;
}
function FUN10(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
uint256 VAR14 = VAR12 / VAR13;
return VAR14;
}
function FUN11(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
assert(VAR13 <= VAR12);
return VAR12 - VAR13;
}
function FUN12(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
uint256 VAR14 = VAR12 + VAR13;
assert(VAR14 >= VAR12);
return VAR14;
}
}
contract VAR15 {
address public VAR9;
event FUN13(address indexed VAR16, address indexed VAR17);
function FUN14() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9);
VAR18;
}
function FUN15(address VAR17) onlyOwner public {
require(VAR17 != address(0));
FUN13(VAR9, VAR17);
VAR9 = VAR17;
}
}
contract TokenDestructible is VAR15 {
function FUN16() payable { }
function FUN17(address[] VAR19) onlyOwner public {
for(uint256 VAR20 = 0; VAR20 < VAR19.VAR21; VAR20++) {
ERC20Basic VAR22 = FUN18(VAR19[VAR20]);
uint256 VAR23 = VAR22.FUN4(this);
VAR22.transfer(VAR9, VAR23);
}
FUN19(VAR9);
}
}
contract VePortfolio is VAR24 {
using SafeMath for uint256;
struct VAR25 {
bytes32 VAR26;
uint256 value;
}
struct VAR27 {
uint256 value;
mapping(address => uint256) VAR28;
VAR25[] VAR29;
bool VAR30;
uint64 VAR31;
}
CollectibleExposure VAR32;
EDExecutor VAR33;
address public VAR34;
address public VAR35;
address public VAR36;
mapping (bytes32 => VAR27) private VAR37;
mapping (address => uint) public VAR38;
address[] public VAR39;
function FUN20() {
VAR34 = msg.sender;
VAR35 = msg.sender;
VAR36 = msg.sender;
}
event FUN21(bytes32 VAR3, uint256 VAR40, uint64 VAR41);
event FUN22(bytes32 VAR3, uint256 VAR42, address VAR22, uint256 VAR43);
event FUN23(bytes32 VAR3, uint256 VAR44, address VAR22, uint256 VAR45);
event FUN24(bytes32 VAR3, uint256 VAR46);
modifier FUN25() {
require(msg.sender == VAR34);
VAR18;
}
modifier FUN26() {
require(msg.sender == VAR35);
VAR18;
}
modifier FUN27() {
require(msg.sender == VAR36);
VAR18;
}
function FUN28(CollectibleExposure VAR47) onlyOwner {
require(VAR47 != address(0));
VAR32 = VAR47;
}
function FUN29(EDExecutor VAR48) public onlyOwner {
require(VAR48 != address(0));
VAR33 = VAR48;
}
function FUN30(address VAR49) public onlyOwner {
require(VAR49 != address(0));
VAR34 = VAR49;
}
function FUN31(address VAR50) public onlyOwner {
require(VAR50 != address(0));
VAR35 = VAR50;
}
function FUN32(address VAR51) public onlyOwner {
require(VAR51 != address(0));
VAR36 = VAR51;
}
function FUN33() public constant returns (address[]) {
return VAR39;
}
function FUN34(address[] VAR52) public VAR53 {
FUN35();
VAR39.VAR21 = VAR52.VAR21;
for(uint VAR20 = 0; VAR20 < VAR39.VAR21; VAR20++) {
VAR39[VAR20] = VAR52[VAR20];
}
}
function FUN36(address[] VAR52, uint256[] VAR54) public VAR53 {
require(VAR52.VAR21 == VAR54.VAR21);
FUN37(VAR52);
FUN35();
uint VAR55 = 0;
for(uint256 VAR20 = 0; VAR20 < VAR52.VAR21; VAR20++) {
uint256 VAR56 = VAR54[VAR20];
address VAR57 = VAR52[VAR20];
VAR55 = VAR55.FUN12(VAR56);
VAR38[VAR57] = VAR56;
}
uint256 VAR58 = 1 VAR59;
require(VAR58.FUN11(VAR55) < 10 VAR60);
}
function FUN38(bytes32[] VAR61)
public
VAR62
returns (bytes32)
{
require(VAR32 != address(0));
require(VAR61.VAR21 > 0);
bytes32 VAR63 = FUN39(VAR61);
Bucket storage VAR64 = VAR37[VAR63];
require(VAR64.VAR29.VAR21 == 0);
for (uint256 VAR20 = 0; VAR20 < VAR61.VAR21; VAR20++) {
bytes32 VAR26 = VAR61[VAR20];
uint64 VAR65 = VAR32.FUN1(VAR26);
if (VAR64.VAR31 < VAR65) {
VAR64.VAR31 = VAR65;
}
uint256 value = VAR32.FUN2(VAR26);
VAR64.VAR29.FUN40(FUN41({
VAR26: VAR26,
value: value
}));
VAR64.value += value;
}
FUN21(VAR63, VAR64.value, VAR64.VAR31);
}
function FUN42(bytes32 VAR63)
public
VAR62
{
require(VAR32 != address(0));
Bucket storage VAR64 = VAR37[VAR63];
require(VAR64.VAR29.VAR21 > 0);
require(VAR64.VAR30 == false);
uint256 VAR46;
for (uint256 VAR20 = 0; VAR20 < VAR64.VAR29.VAR21; VAR20++) {
ExposureInfo storage VAR66 = VAR64.VAR29[VAR20];
VAR46 += VAR66.value;
VAR32.VAR67.value(VAR66.value)(VAR66.VAR26);
}
FUN24(VAR63, VAR46);
delete VAR37[VAR63];
}
function FUN43(
uint256 VAR68,
address VAR69,
uint256 VAR70,
uint256 VAR71,
uint256 VAR72,
address VAR73,
uint8 VAR74,
bytes32 VAR75,
bytes32 VAR76,
bytes32 VAR63,
uint256 VAR77
) VAR78 {
require(VAR37[VAR63].value >= VAR77);
require(FUN44(VAR69));
uint256 VAR79;
uint256 VAR80;
(VAR79, VAR80) =
VAR33.VAR81.value(VAR77)(
VAR68,
VAR69,
VAR70,
VAR71,
VAR72,
VAR73,
VAR74, VAR75, VAR76
);
VAR37[VAR63].value -= (VAR77 - VAR80);
VAR37[VAR63].VAR28[VAR69] += VAR79;
FUN22(VAR63, (VAR77 - VAR80), VAR69, VAR79);
}
function FUN45(
uint256 VAR68,
address VAR69,
uint256 VAR70,
uint256 VAR71,
uint256 VAR72,
address VAR73,
uint8 VAR74,
bytes32 VAR75,
bytes32 VAR76,
bytes32 VAR63,
uint256 VAR77
) VAR78 {
require(VAR37[VAR63].VAR28[VAR69] >= VAR77);
uint256 VAR82;
uint256 VAR83;
FUN46(VAR69).transfer(VAR33, VAR77);
(VAR82, VAR83) =
VAR33.FUN47(
VAR68,
VAR69,
VAR70,
VAR71,
VAR72,
VAR73,
VAR74, VAR75, VAR76
);
VAR37[VAR63].value += VAR82;
VAR37[VAR63].VAR28[VAR69] -= (VAR77 - VAR83);
FUN23(VAR63, VAR82, VAR69, (VAR77 - VAR83));
}
function() payable {
}
function FUN48(bytes32 VAR63) public constant returns (bool) {
return VAR37[VAR63].VAR29.VAR21 > 0;
}
function FUN39(bytes32[] VAR29)
public
constant
returns (bytes32)
{
return FUN49(this, VAR29);
}
function FUN50(bytes32 VAR84, address VAR85) constant returns (uint256) {
Bucket storage VAR64 = VAR37[VAR84];
return VAR64.VAR28[VAR85];
}
function FUN51(bytes32 VAR84) constant returns (uint256) {
Bucket storage VAR64 = VAR37[VAR84];
return VAR64.value;
}
function FUN52() constant public returns (uint256) {
return VAR39.VAR21;
}
function FUN35() private {
for(uint256 VAR20 = 0; VAR20 < VAR39.VAR21; VAR20++) {
delete VAR38[VAR39[VAR20]];
}
}
function FUN37(address[] VAR52) internal {
require(VAR39.VAR21 == VAR52.VAR21);
for (uint256 VAR20 = 0; VAR20 < VAR39.VAR21; VAR20++) {
require(VAR52[VAR20] == VAR39[VAR20]);
}
}
function FUN53(bytes32 VAR63) constant public returns (VAR86) {
return VAR37[VAR63].VAR31;
}
function FUN44(address VAR22) constant private returns (bool) {
return VAR38[VAR22] != 0;
}
}
contract VeExposure is VAR24 {
using SafeMath for uint256;
enum VAR87 { VAR88, VAR89, VAR90, VAR91, VAR92 }
struct VAR93 {
address VAR94;
uint256 VAR95;
uint256 VAR40;
uint256 VAR46;
uint64 VAR96;
uint64 VAR41;
State VAR97;
}
ERC20 public VAR98;
address public VAR99;
uint256 public VAR100;
uint32 public VAR101;
uint32 public VAR102;
uint256 public VAR103;
uint256 public VAR104;
mapping (bytes32 => VAR93) VAR29;
function FUN54(
ERC20 VAR105,
uint256 VAR106,
uint32 VAR107,
uint32 VAR108,
uint256 VAR109,
uint256 VAR110
) {
require(VAR105 != address(0));
require(VAR107 > 0 && VAR107 <= VAR108);
require(VAR109 > 0 && VAR109 <= VAR110);
VAR98 = VAR105;
VAR100 = VAR106;
VAR101 = VAR107;
VAR102 = VAR108;
VAR103 = VAR109;
VAR104 = VAR110;
}
modifier VAR111 {
require(msg.sender == VAR99);
VAR18;
}
function FUN55(address VAR112) public onlyOwner {
require(VAR112 != address(0));
VAR99 = VAR112;
}
function FUN56(uint32 VAR107) public onlyOwner {
require(VAR107 > 0 && VAR107 <= VAR102);
VAR101 = VAR107;
}
function FUN57(uint32 VAR108) public onlyOwner {
require(VAR108 >= VAR101);
VAR102 = VAR108;
}
function FUN58(uint32 VAR109) public onlyOwner {
require(VAR109 > 0 && VAR109 <= VAR104);
VAR103 = VAR109;
}
function FUN59(uint32 VAR110) public onlyOwner {
require(VAR110 >= VAR103);
VAR104 = VAR110;
}
event FUN60(
bytes32 indexed VAR3,
address indexed VAR94,
uint256 VAR95,
uint256 value,
uint64 VAR96,
uint64 VAR41
);
event FUN61(
bytes32 indexed VAR3,
address indexed VAR94,
uint256 value
);
event FUN62(
bytes32 indexed VAR3,
address indexed VAR94,
uint256 VAR40,
uint256 VAR46
);
event FUN63(
bytes32 indexed VAR3,
address indexed VAR94,
uint256 value
);
function FUN64(uint256 VAR95, uint32 VAR113, uint256 VAR114) public payable {
require(VAR95 >= VAR103 && VAR95 <= VAR104);
require(VAR113 >= VAR101 && VAR113 <= VAR102);
require(FUN65(VAR95, msg.value));
bytes32 VAR3 = FUN66({
VAR95: VAR95,
value: msg.value,
VAR113: VAR113,
VAR114: VAR114
});
require(!FUN67(VAR3));
FUN68(VAR3, VAR95, VAR113);
FUN69(VAR95);
}
function FUN1(bytes32 VAR3) public onlyPortfolio constant returns (VAR86) {
Exposure storage VAR66 = VAR29[VAR3];
return VAR66.VAR41;
}
function FUN2(bytes32 VAR3) public onlyPortfolio returns (uint256 value) {
Exposure storage VAR66 = VAR29[VAR3];
require(VAR66.VAR97 == VAR87.VAR89);
value = VAR66.VAR40;
VAR66.VAR97 = VAR87.VAR90;
msg.sender.transfer(value);
FUN61({
VAR3: VAR3,
VAR94: VAR66.VAR94,
value: value
});
}
function FUN3(bytes32 VAR3) public payable VAR111 {
Exposure storage VAR66 = VAR29[VAR3];
require(VAR66.VAR97 == VAR87.VAR90);
require(FUN70(VAR66.VAR41));
VAR66.VAR97 = VAR87.VAR92;
VAR66.VAR46 = msg.value;
FUN62({
VAR3: VAR3,
VAR94: VAR66.VAR94,
VAR40: VAR66.VAR40,
VAR46: VAR66.VAR46
});
}
function FUN71(bytes32 VAR3) public returns (uint256 VAR46) {
Exposure storage VAR66 = VAR29[VAR3];
require(msg.sender == VAR66.VAR94);
require(VAR66.VAR97 == VAR87.VAR92);
VAR46 = VAR66.VAR46;
delete VAR29[VAR3];
msg.sender.transfer(VAR46);
FUN63({
VAR3: VAR3,
VAR94: msg.sender,
value: VAR46
});
}
function FUN72(bytes32 VAR3)
public
constant
returns (uint8 VAR97)
{
Exposure storage VAR66 = VAR29[VAR3];
VAR97 = uint8(VAR66.VAR97);
if (VAR66.VAR97 == VAR87.VAR90 && FUN70(VAR66.VAR41)) {
VAR97 = uint8(VAR87.VAR91);
}
}
function FUN67(bytes32 VAR3) public constant returns (bool) {
return VAR29[VAR3].VAR96 > 0;
}
function FUN65(uint256 VAR95, uint256 value)
public
constant
returns (bool)
{
uint256 VAR115 = VAR100.FUN9(VAR95).FUN10(1 VAR59);
return value == VAR115;
}
function FUN66(
uint256 VAR95,
uint256 value,
uint32 VAR113,
uint256 VAR114
)
public
constant
returns (bytes32)
{
return FUN49(
this,
msg.sender,
value,
VAR95,
VAR113,
VAR114
);
}
function() public payable {
}
function FUN69(uint256 VAR95) private {
require(VAR98.FUN6(msg.sender, this, VAR95));
require(VAR98.FUN7(VAR99, VAR95));
}
function FUN68(bytes32 VAR3, uint256 VAR95, uint32 VAR113) private constant {
uint64 VAR96 = FUN73(VAR116.VAR117);
uint64 VAR41 = FUN73(VAR116.VAR117.FUN12(VAR113));
VAR29[VAR3] = FUN74({
VAR94: msg.sender,
VAR95: VAR95,
VAR40: msg.value,
VAR46: 0,
VAR96: VAR96,
VAR41: VAR41,
VAR97: VAR87.VAR89
});
FUN60({
VAR3: VAR3,
VAR94: msg.sender,
VAR96: VAR96,
VAR41: VAR41,
VAR95: VAR95,
value: msg.value
});
}
function FUN70(uint64 VAR118)
private
constant
returns (bool)
{
return VAR116.VAR117 >= VAR118;
}
}
contract VAR119 {
function FUN75(
uint256 VAR68,
address VAR69,
uint256 VAR70,
uint256 VAR71,
uint256 VAR72,
address VAR73,
uint8 VAR74,
bytes32 VAR75,
bytes32 VAR76
) payable returns (uint256 VAR79, uint256 VAR80);
function FUN47(
uint256 VAR68,
address VAR69,
uint256 VAR70,
uint256 VAR71,
uint256 VAR72,
address VAR73,
uint8 VAR74,
bytes32 VAR75,
bytes32 VAR76
) returns (uint256 VAR82, uint256 VAR83);
}
1
---------------------------------
230 0xd4eb8e0bb87c1630c34b7d39a5fa74b67bcce3d1.sol
contract VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
}
event FUN1(address VAR6, bytes32 VAR7);
event FUN2(address VAR6, bytes32 VAR7);
event FUN3(address VAR8, address VAR9);
event FUN4(address VAR9);
event FUN5(address VAR8);
event FUN6(uint VAR10);
modifier VAR11 {
if (FUN7(msg.sender))
VAR12;
}
modifier FUN8(bytes32 VAR13) {
if (FUN9(VAR13))
VAR12;
}
function FUN10(address[] VAR14, uint VAR15) {
VAR16 = VAR14.VAR17 + 1;
VAR18[1] = uint(msg.sender);
VAR19[uint(msg.sender)] = 1;
for (uint VAR20 = 0; VAR20 < VAR14.VAR17; ++VAR20)
{
VAR18[2 + VAR20] = uint(VAR14[VAR20]);
VAR19[uint(VAR14[VAR20])] = 2 + VAR20;
}
VAR21 = VAR15;
}
function FUN11(bytes32 VAR13) external {
uint VAR22 = VAR19[uint(msg.sender)];
if (VAR22 == 0) return;
uint VAR23 = 2**VAR22;
var VAR24 = VAR25[VAR13];
if (VAR24.VAR4 & VAR23 > 0) {
VAR24.VAR3++;
VAR24.VAR4 -= VAR23;
FUN2(msg.sender, VAR13);
}
}
function FUN12(address VAR26, address VAR27) FUN8(FUN13(msg.VAR28)) external {
if (FUN7(VAR27)) return;
uint VAR22 = VAR19[uint(VAR26)];
if (VAR22 == 0) return;
FUN14();
VAR18[VAR22] = uint(VAR27);
VAR19[uint(VAR26)] = 0;
VAR19[uint(VAR27)] = VAR22;
FUN3(VAR26, VAR27);
}
function FUN15(address VAR29) FUN8(FUN13(msg.VAR28)) external {
if (FUN7(VAR29)) return;
FUN14();
if (VAR16 >= VAR30)
FUN16();
if (VAR16 >= VAR30)
return;
VAR16++;
VAR18[VAR16] = uint(VAR29);
VAR19[uint(VAR29)] = VAR16;
FUN4(VAR29);
}
function FUN17(address VAR29) FUN8(FUN13(msg.VAR28)) external {
uint VAR22 = VAR19[uint(VAR29)];
if (VAR22 == 0) return;
if (VAR21 > VAR16 - 1) return;
VAR18[VAR22] = 0;
VAR19[uint(VAR29)] = 0;
FUN14();
FUN16();
FUN5(VAR29);
}
function FUN18(uint VAR31) FUN8(FUN13(msg.VAR28)) external {
if (VAR31 > VAR16) return;
VAR21 = VAR31;
FUN14();
FUN6(VAR31);
}
function FUN19(uint VAR22) external constant returns (address) {
return address(VAR18[VAR22 + 1]);
}
function FUN7(address VAR32) returns (bool) {
return VAR19[uint(VAR32)] > 0;
}
function FUN20(bytes32 VAR13, address VAR29) constant returns (bool) {
var VAR24 = VAR25[VAR13];
uint VAR22 = VAR19[uint(VAR29)];
if (VAR22 == 0) return false;
uint VAR23 = 2**VAR22;
return !(VAR24.VAR4 & VAR23 == 0);
}
function FUN9(bytes32 VAR13) internal returns (bool) {
uint VAR22 = VAR19[uint(msg.sender)];
if (VAR22 == 0) return;
var VAR24 = VAR25[VAR13];
if (VAR24.VAR3 == 0) {
VAR24.VAR3 = VAR21;
VAR24.VAR4 = 0;
VAR24.VAR5 = VAR33.VAR17++;
VAR33[VAR24.VAR5] = VAR13;
}
uint VAR23 = 2**VAR22;
if (VAR24.VAR4 & VAR23 == 0) {
FUN1(msg.sender, VAR13);
if (VAR24.VAR3 <= 1) {
delete VAR33[VAR25[VAR13].VAR5];
delete VAR25[VAR13];
return true;
}
else
{
VAR24.VAR3--;
VAR24.VAR4 |= VAR23;
}
}
}
function FUN16() private {
uint VAR34 = 1;
while (VAR34 < VAR16)
{
while (VAR34 < VAR16 && VAR18[VAR34] != 0) VAR34++;
while (VAR16 > 1 && VAR18[VAR16] == 0) VAR16--;
if (VAR34 < VAR16 && VAR18[VAR16] != 0 && VAR18[VAR34] == 0)
{
VAR18[VAR34] = VAR18[VAR16];
VAR19[VAR18[VAR34]] = VAR34;
VAR18[VAR16] = 0;
}
}
}
function FUN14() internal {
uint VAR17 = VAR33.VAR17;
for (uint VAR20 = 0; VAR20 < VAR17; ++VAR20)
if (VAR33[VAR20] != 0)
delete VAR25[VAR33[VAR20]];
delete VAR33;
}
uint public VAR21;
uint public VAR16;
uint[256] VAR18;
uint constant VAR30 = 250;
mapping(uint => uint) VAR19;
mapping(bytes32 => VAR2) VAR25;
bytes32[] VAR33;
}
contract daylimit is VAR1 {
modifier FUN21(uint VAR35) {
if (FUN22(VAR35))
VAR12;
}
function FUN23(uint VAR36) {
VAR37 = VAR36;
VAR38 = FUN24();
}
function FUN25(uint VAR39) FUN8(FUN13(msg.VAR28)) external {
VAR37 = VAR39;
}
function FUN26() FUN8(FUN13(msg.VAR28)) external {
VAR40 = 0;
}
function FUN22(uint VAR35) internal onlyowner returns (bool) {
return true;
}
function FUN24() private constant returns (uint) { return VAR41 / 1 VAR42; }
uint public VAR37;
uint public VAR40;
uint public VAR38;
}
contract VAR43 {
event FUN27(address VAR26, uint value);
event FUN28(address VAR6, uint value, address VAR44, bytes VAR28);
event FUN29(address VAR6, bytes32 VAR7, uint value, address VAR44, bytes VAR28);
event FUN30(bytes32 VAR7, address VAR45, uint value, address VAR44, bytes VAR28);
function FUN12(address VAR26, address VAR27) external;
function FUN31(address VAR27, uint VAR35, bytes VAR46) external returns (bytes32);
function FUN32(bytes32 VAR47) returns (bool);
}
contract Wallet is VAR43, VAR1, VAR48 {
struct Transaction {
address VAR44;
uint value;
bytes VAR28;
}
function FUN33(address[] VAR14, uint VAR15, uint VAR49)
FUN10(VAR14, VAR15) FUN23(VAR49) {
}
function FUN34(address VAR27) FUN8(FUN13(msg.VAR28)) external {
FUN35(VAR27);
}
function() payable {
if (msg.value > 0)
FUN27(msg.sender, msg.value);
}
function FUN31(address VAR27, uint VAR35, bytes VAR46) external onlyowner returns (bytes32 VAR50) {
if (FUN22(VAR35)) {
FUN28(msg.sender, VAR35, VAR27, VAR46);
VAR27.call.value(VAR35)(VAR46);
return 0;
}
VAR50 = FUN13(msg.VAR28, VAR51.VAR52);
if (!FUN32(VAR50) && VAR53[VAR50].VAR44 == 0) {
VAR53[VAR50].VAR44 = VAR27;
VAR53[VAR50].value = VAR35;
VAR53[VAR50].VAR28 = VAR46;
FUN30(VAR50, msg.sender, VAR35, VAR27, VAR46);
}
}
function FUN32(bytes32 VAR47) FUN8(VAR47) returns (bool) {
if (VAR53[VAR47].VAR44 != 0) {
VAR53[VAR47].VAR44.call.value(VAR53[VAR47].value)(VAR53[VAR47].VAR28);
FUN29(msg.sender, VAR47, VAR53[VAR47].value, VAR53[VAR47].VAR44, VAR53[VAR47].VAR28);
delete VAR53[VAR47];
return true;
}
}
function FUN14() internal {
uint VAR17 = VAR33.VAR17;
for (uint VAR20 = 0; VAR20 < VAR17; ++VAR20)
delete VAR53[VAR33[VAR20]];
super.FUN14();
}
mapping (bytes32 => Transaction) VAR53;
}
1
---------------------------------
231 0xd518db222f37f9109db8e86e2789186c7e340f12.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address=>uint256) public VAR3;
uint public VAR4 = 1 VAR5;
LogFile VAR6 = FUN1(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
bool VAR7;
function FUN2(uint VAR8)
public
{
if(VAR7)revert();
VAR4 = VAR8;
}
function FUN3(address VAR9)
public
{
if(VAR7)revert();
VAR6 = FUN1(VAR9);
}
function FUN4()
public
{
VAR7 = true;
}
function FUN5()
public
payable
{
VAR3[msg.sender]+= msg.value;
VAR6.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR10)
public
payable
{
if(VAR3[msg.sender]>=VAR4 && VAR3[msg.sender]>=VAR10)
{
if(msg.sender.call.value(VAR10)())
{
VAR3[msg.sender]-=VAR10;
VAR6.FUN6(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN5();
}
}
contract VAR11
{
struct VAR12
{
address VAR13;
string  VAR14;
uint VAR15;
uint  VAR16;
}
VAR12[] public VAR17;
Message VAR18;
function FUN6(address VAR19,uint VAR8,string VAR20)
public
{
VAR18.VAR13 = VAR19;
VAR18.VAR16 = VAR21;
VAR18.VAR15 = VAR8;
VAR18.VAR14 = VAR20;
VAR17.FUN8(VAR18);
}
}
1
---------------------------------
232 0xd529adae263048f495a05b858c8e7c077f047813.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1(address VAR3) public payable returns(uint256);
function FUN2() public;
}
contract VAR4 {
FUNDS VAR5 = FUN3(0x7E0529Eb456a7C806B5Fe7B3d69a805339A06180);
function () public payable {
}
function FUN4(uint256 VAR6) external {
for (uint256 VAR7 = 0; VAR7 < VAR6; VAR7++) {
if (address(this).VAR8 < 0.001 VAR9) {
break;
}
VAR5.VAR10.value(address(this).VAR8)(0x0);
VAR5.FUN2();
}
}
}
1
---------------------------------
233 0xd5ae5111eb0e8b9a13260f52521a4b6fa0880fec.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function FUN1() external payable;
}
contract VAR3 {
event FUN2 (
address indexed VAR4,
uint256 value,
uint256 VAR5,
address indexed VAR6
);
event FUN3 (
address indexed VAR4,
uint256 value,
uint256 VAR5
);
event FUN4 (
address indexed VAR4,
uint256 value,
uint256 VAR5
);
event FUN5 (
uint256 value,
uint256 VAR5
);
address VAR7;
mapping(address => uint256) public VAR8;
modifier onlyOwner {
require(msg.sender == VAR7);
VAR9;
}
constructor() public {
VAR7 = msg.sender;
}
function FUN6(address VAR4, address VAR6) public payable {
require(msg.value > 0);
VAR8[VAR4] += msg.value;
emit FUN2(VAR4, msg.value, VAR10, VAR6);
}
function FUN7() public {
require(VAR8[msg.sender] > 0);
uint256 value = VAR8[msg.sender];
VAR8[msg.sender] = 0;
msg.sender.transfer(value);
emit FUN3(msg.sender, value, VAR10);
}
function FUN8(address VAR4) onlyOwner public {
require(VAR8[VAR4] > 0);
uint256 value = VAR8[VAR4];
VAR8[VAR4] = 0;
VAR7.transfer(value);
emit FUN4(VAR4, value, VAR10);
}
function FUN9() onlyOwner public {
uint256 VAR11 = address(this).VAR11;
VAR7.transfer(VAR11);
emit FUN5(VAR11, VAR10);
}
}
contract VAR12 {
event FUN10 (
address indexed VAR6,
address indexed VAR4,
uint256 indexed VAR5,
uint256 value,
uint256 VAR13,
uint256 VAR14,
uint256 VAR15,
uint256 VAR16
);
event FUN3 (
address indexed VAR17,
uint256 value
);
event FUN11 (
address indexed VAR6,
uint256 value
);
event FUN12 (
address indexed VAR6,
uint256 value,
uint8 VAR18,
uint256 VAR13,
uint256 VAR16,
uint256 VAR19
);
event FUN13 (
uint256 value
);
event FUN14 (
uint256 value
);
event FUN15 (
address indexed VAR20,
uint256 value
);
event FUN16 (
uint256 value
);
event FUN17 (
uint256 value
);
event FUN18 (
address indexed VAR4,
uint256 value,
uint256 VAR5,
address indexed VAR6,
address indexed VAR21
);
event FUN19 (
address VAR22,
uint256 VAR5
);
event FUN20 (
address indexed VAR23,
uint256 value,
uint256 VAR5
);
string constant public VAR24 = "";
string constant public VAR25 = "";
address public VAR7;
address constant internal VAR26 = 0x42cF5e102dECCf8d89E525151c5D5bbEAc54200d;
address constant internal VAR27 = 0x8D86E611ef0c054FdF04E1c744A8cEFc37F00F81;
NeutrinoTokenStandard constant internal VAR28 = FUN21(0xad0a61589f3559026F00888027beAc31A5Ac4625);
ReferralPayStation public VAR29 = FUN22(0x4100dAdA0D80931008a5f7F5711FFEb60A8071BA);
uint8 constant VAR30 = 10;
uint8 constant VAR31 = 8;
uint8 constant VAR32 = 5;
mapping(address => uint256) public VAR33;
uint256 public VAR34 = 0;
uint256 public VAR35 = 0;
uint256 public VAR36 = 0;
uint256 public VAR37 = 0;
modifier onlyOwner {
require(msg.sender == VAR7);
VAR9;
}
constructor() public payable {
VAR7 = msg.sender;
VAR37 = msg.value;
}
function() public payable {
emit FUN15(msg.sender, msg.value);
}
function FUN23() public view returns (uint256) {
if (VAR10 >= 1545581345 && VAR10 < 1548979200) return 0.1 VAR38;
if (VAR10 >= 1548979200 && VAR10 < 1551398400) return 0.2 VAR38;
if (VAR10 >= 1551398400 && VAR10 < 1554076800) return 0.3 VAR38;
if (VAR10 >= 1554076800 && VAR10 < 1556668800) return 0.4 VAR38;
if (VAR10 >= 1556668800 && VAR10 < 1559347200) return 0.5 VAR38;
if (VAR10 >= 1559347200 && VAR10 < 1561939200) return 0.6 VAR38;
if (VAR10 >= 1561939200 && VAR10 < 1564617600) return 0.7 VAR38;
if (VAR10 >= 1564617600 && VAR10 < 1567296000) return 0.8 VAR38;
return 0;
}
function FUN24() public view returns (bool) {
return FUN23() > 0;
}
function FUN25(uint256 VAR13, address VAR4) public payable {
uint256 VAR39 = FUN23();
require (VAR39 > 0);
uint256 value = (msg.value / VAR39) * VAR39;
uint256 VAR14 = msg.value - value;
require(value > 0);
VAR37 += VAR14;
uint8 VAR40 = VAR30 + VAR32;
uint256 VAR15 = 0;
if (VAR4 != 0x0) {
VAR40 += VAR31;
VAR15 = value * VAR31 / 100;
VAR29.VAR41.value(VAR15)(VAR4, msg.sender);
emit FUN18(VAR4, VAR15, VAR10, msg.sender, address(VAR29));
}
uint256 VAR42 = value - value * VAR40 / 100;
VAR37 += VAR42;
VAR35 += value * VAR30 / 100;
VAR36 += value * VAR32 / 100;
emit FUN10(msg.sender, VAR4, VAR43.VAR5, value, VAR13, VAR14, VAR15, value / VAR39);
}
function FUN26() public {
require(VAR33[msg.sender] > 0);
uint256 value = VAR33[msg.sender];
VAR33[msg.sender] = 0;
VAR34 -= value;
msg.sender.transfer(value);
emit FUN11(msg.sender, value);
}
function FUN27(address VAR6, uint256 value, uint8 VAR18, uint256 VAR13, uint256 VAR16, uint256 VAR19) onlyOwner public {
require(value <= VAR37);
VAR33[VAR6] += value;
VAR34 += value;
VAR37 -= value;
emit FUN12(VAR6, value, VAR18, VAR13, VAR16, VAR19);
}
function FUN28(address VAR4, address VAR6, uint256 value) onlyOwner public {
require(value <= VAR37);
VAR37 -= value;
VAR29.VAR41.value(value)(VAR4, VAR6);
emit FUN18(VAR4, value, VAR10, VAR6, address(VAR29));
}
function FUN29(uint256 value) onlyOwner public {
require(value <= VAR35);
if (value == 0) value = VAR35;
uint256 VAR44 = value * 90 / 100;
uint256 VAR45 = value * 10 / 100;
if (VAR26.FUN30(VAR44)) {
VAR35 -= VAR44;
emit FUN20(VAR26, VAR44, VAR10);
}
if (VAR27.FUN30(VAR45)) {
VAR35 -= VAR45;
emit FUN20(VAR27, VAR45, VAR10);
}
}
function FUN31() onlyOwner public {
require(VAR36 > 0);
uint256 VAR46 = VAR36;
VAR28.VAR47.value(VAR36)();
VAR36 = 0;
emit FUN13(VAR46);
}
function FUN32() onlyOwner public {
uint256 VAR48 = VAR34 + VAR35 + VAR36 + VAR37;
uint256 VAR49 = address(this).VAR11 - VAR48;
require(VAR49 > 0);
VAR35 += VAR49;
emit FUN16(VAR49);
}
function FUN33() onlyOwner public {
uint256 VAR48 = VAR34 + VAR35 + VAR36 + VAR37;
uint256 VAR49 = address(this).VAR11 - VAR48;
require(VAR49 > 0);
VAR37 += VAR49;
emit FUN17(VAR49);
}
function FUN34(address VAR22) onlyOwner public {
VAR29 = FUN22(VAR22);
emit FUN19(VAR22, VAR10);
}
}
1
---------------------------------
234 0xd5e1dff5f039b2c42978d98ed60c0ac5c8f6a266.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
contract BaseModule is VAR2 {
ModuleRegistry internal VAR6;
event FUN4(bytes32 VAR7);
event FUN5(address VAR8);
constructor(ModuleRegistry VAR9, bytes32 VAR10) public {
VAR6 = VAR9;
emit FUN4(VAR10);
}
modifier FUN6(BaseWallet VAR3) {
require(msg.sender == address(VAR3), "");
VAR11;
}
modifier onlyOwner(BaseWallet VAR3) {
require(msg.sender == address(this) || FUN7(VAR3, msg.sender), "");
VAR11;
}
modifier FUN8(BaseWallet VAR3) {
require(FUN7(VAR3, msg.sender), "");
VAR11;
}
function FUN1(BaseWallet VAR3) external FUN6(VAR3) {
emit FUN5(VAR3);
}
function FUN2(BaseWallet VAR3, Module VAR4) external FUN8(VAR3) {
require(VAR6.FUN9(VAR4), "");
VAR3.FUN10(VAR4, true);
}
function FUN3(address VAR5) external {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(address(VAR6), VAR12);
}
function FUN7(BaseWallet VAR3, address VAR13) internal view returns (bool) {
return VAR3.FUN13() == VAR13;
}
}
contract RelayerModule is VAR2 {
uint256 constant internal VAR14 = 10000;
mapping (address => VAR15) public VAR16;
struct VAR15 {
uint256 VAR17;
mapping (bytes32 => bool) VAR18;
}
event FUN14(address indexed VAR8, bool indexed VAR19, bytes32 VAR20);
modifier VAR21 {
require(msg.sender == address(this), "");
VAR11;
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256);
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool);
function FUN17(
BaseWallet VAR3,
bytes VAR22,
uint256 VAR25,
bytes VAR24,
uint256 VAR26,
uint256 VAR27
)
external
returns (bool VAR19)
{
uint VAR28 = FUN18();
bytes32 VAR29 = FUN19(address(this), VAR3, 0, VAR22, VAR25, VAR26, VAR27);
require(FUN20(VAR3, VAR25, VAR29), "");
require(FUN21(address(VAR3), VAR22), "");
uint256 VAR30 = FUN15(VAR3, VAR22);
if((VAR30 * 65) == VAR24.VAR31) {
if(FUN22(VAR3, VAR27, VAR26, VAR30)) {
if(VAR30 == 0 || FUN16(VAR3, VAR22, VAR29, VAR24)) {
VAR19 = address(this).call(VAR22);
FUN23(VAR3, VAR28 - FUN18(), VAR26, VAR27, VAR30, msg.sender);
}
}
}
emit FUN14(VAR3, VAR19, VAR29);
}
function FUN24(BaseWallet VAR3) external view returns (uint256 VAR17) {
return VAR16[VAR3].VAR17;
}
function FUN19(
address VAR32,
address VAR33,
uint256 VAR34,
bytes VAR22,
uint256 VAR25,
uint256 VAR26,
uint256 VAR27
)
internal
pure
returns (bytes32)
{
return FUN25(
VAR35.FUN26(
"",
FUN25(VAR35.FUN26(FUN27(0x19), FUN27(0), VAR32, VAR33, VAR34, VAR22, VAR25, VAR26, VAR27))
));
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
if(VAR16[VAR3].VAR18[VAR23] == true) {
return false;
}
VAR16[VAR3].VAR18[VAR23] = true;
return true;
}
function FUN28(BaseWallet VAR3, uint256 VAR25) internal returns (bool) {
if(VAR25 <= VAR16[VAR3].VAR17) {
return false;
}
uint256 VAR36 = (VAR25 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;
if(VAR36 > VAR37.VAR38 + VAR14) {
return false;
}
VAR16[VAR3].VAR17 = VAR25;
return true;
}
function FUN29(bytes32 VAR39, bytes VAR24, uint VAR40) internal pure returns (address) {
uint8 VAR41;
bytes32 VAR42;
bytes32 VAR43;
VAR44 {
VAR42 := FUN30(FUN31(VAR24, FUN31(0x20,FUN32(0x41,VAR40))))
VAR43 := FUN30(FUN31(VAR24, FUN31(0x40,FUN32(0x41,VAR40))))
VAR41 := FUN33(FUN30(FUN31(VAR24, FUN31(0x41,FUN32(0x41,VAR40)))), 0xff)
}
require(VAR41 == 27 || VAR41 == 28);
return FUN34(VAR39, VAR41, VAR42, VAR43);
}
function FUN23(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR27, uint VAR24, address VAR46) internal {
uint256 VAR47 = 29292 + VAR45;
if(VAR26 > 0 && VAR24 > 1 && VAR47 <= VAR27) {
if(VAR26 > VAR48.VAR49) {
VAR47 = VAR47 * VAR48.VAR49;
}
else {
VAR47 = VAR47 * VAR26;
}
VAR3.FUN35(VAR46, VAR47, "");
}
}
function FUN22(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR24) internal view returns (bool) {
if(VAR26 > 0
&& VAR24 > 1
&& (address(VAR3).VAR50 < VAR45 * VAR26 || VAR3.FUN36(this) == false)) {
return false;
}
return true;
}
function FUN21(address VAR3, bytes VAR22) private pure returns (bool) {
require(VAR22.VAR31 >= 36, "");
address VAR51;
VAR44 {
VAR51 := FUN30(FUN31(VAR22, 0x24))
}
return VAR51 == VAR3;
}
function FUN37(bytes VAR22) internal pure returns (bytes4 VAR52) {
require(VAR22.VAR31 >= 4, "");
VAR44 {
VAR52 := FUN30(FUN31(VAR22, 0x20))
}
}
}
contract LimitManager is VAR53 {
uint128 constant internal VAR54 = uint128(-1);
using SafeMath for uint256;
struct VAR55 {
Limit VAR56;
DailySpent VAR57;
}
struct VAR58 {
uint128 VAR59;
uint128 VAR60;
uint64 VAR61;
}
struct VAR62 {
uint128 VAR63;
uint64 VAR64;
}
mapping (address => VAR55) internal VAR65;
uint256 public VAR66;
event FUN38(address indexed VAR8, uint indexed VAR67, uint64 indexed VAR68);
constructor(uint256 VAR69) public {
VAR66 = VAR69;
}
function FUN1(BaseWallet VAR3) external FUN6(VAR3) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
if(VAR56.VAR59 == 0 && VAR56.VAR61 == 0) {
VAR56.VAR59 = uint128(VAR66);
}
}
function FUN39(BaseWallet VAR3, uint256 VAR70, uint256 VAR71) internal {
Limit storage VAR56 = VAR65[VAR3].VAR56;
uint128 VAR72 = (VAR56.VAR61 > 0 && VAR56.VAR61 < VAR73) ? VAR56.VAR60 : VAR56.VAR59;
VAR56.VAR59 = VAR72;
VAR56.VAR60 = uint128(VAR70);
VAR56.VAR61 = FUN40(VAR73.FUN31(VAR71));
emit FUN38(VAR3, VAR70, FUN40(VAR73.FUN31(VAR71)));
}
function FUN41(BaseWallet VAR3) public view returns (uint256 VAR74) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
VAR74 = uint256(FUN42(VAR56.VAR59, VAR56.VAR60, VAR56.VAR61));
}
function FUN43(BaseWallet VAR3) external view returns (uint256 VAR75, uint64 VAR76) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
return ((VAR73 < VAR56.VAR61)? (uint256(VAR56.VAR60), VAR56.VAR61) : (0,0));
}
function FUN44(BaseWallet VAR3) external view returns (uint256 VAR77, uint64 VAR78) {
uint256 VAR79 = FUN41(VAR3);
DailySpent storage VAR80 = VAR65[VAR3].VAR57;
if(VAR73 > VAR80.VAR64) {
VAR77 = VAR79;
VAR78 = FUN40(VAR73 + 24 VAR81);
}
else {
VAR77 = VAR79 - VAR80.VAR63;
VAR78 = VAR80.VAR64;
}
}
function FUN45(BaseWallet VAR3, uint VAR82) internal returns (bool) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
uint128 VAR59 = FUN42(VAR56.VAR59, VAR56.VAR60, VAR56.VAR61);
if(FUN46(VAR3, VAR59, VAR82)) {
FUN47(VAR3, VAR59, VAR82);
return true;
}
return false;
}
function FUN47(BaseWallet VAR3, uint128 VAR83, uint VAR82) internal {
if(VAR83 != VAR54) {
DailySpent storage VAR80 = VAR65[VAR3].VAR57;
if (VAR80.VAR64 < VAR73) {
VAR80.VAR64 = FUN40(VAR73 + 24 VAR81);
VAR80.VAR63 = uint128(VAR82);
}
else {
VAR80.VAR63 += uint128(VAR82);
}
}
}
function FUN46(BaseWallet VAR3, uint VAR83, uint VAR82) internal view returns (bool)  {
DailySpent storage VAR80 = VAR65[VAR3].VAR57;
if(VAR83 == VAR54) {
return true;
}
else if (VAR80.VAR64 < VAR73) {
return (VAR82 <= VAR83);
} else {
return (VAR80.VAR63 + VAR82 <= VAR83 && VAR80.VAR63 + VAR82 >= VAR80.VAR63);
}
}
function FUN42(uint128 VAR84, uint128 VAR85, uint64 VAR76) internal view returns (uint128) {
if(VAR76 > 0 && VAR76 < VAR73) {
return VAR85;
}
return VAR84;
}
}
contract VAR86 {
using SafeMath for uint256;
address constant internal VAR87 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address constant internal VAR88 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
mapping(address => uint256) public VAR89;
function FUN48(ERC20 VAR90) public {
uint256 VAR91;
(VAR91,) = FUN49().FUN50(VAR90, FUN11(VAR87), 10000);
VAR89[VAR90] = VAR91;
}
//
//
function FUN51(VAR92[] VAR93) public {
for(uint16 VAR94 = 0; VAR94 < VAR93.VAR31; VAR94++) {
FUN48(VAR93[VAR94]);
}
}
function FUN52(uint256 VAR82, address VAR5) public view returns (uint256) {
uint256 VAR95 = FUN11(VAR5).FUN53();
uint256 VAR96 = VAR89[VAR5];
return VAR96.FUN32(VAR82).FUN54(10**VAR95);
}
//
//
function FUN49() internal view returns (VAR97) {
return FUN55(VAR88);
}
}
contract VAR97 {
function FUN50(
ERC20 VAR98,
ERC20 VAR99,
uint VAR100
)
public
view
returns (uint VAR91, uint VAR101);
function FUN56(
ERC20 VAR98,
uint VAR102,
ERC20 VAR99,
address VAR103,
uint VAR104,
uint VAR105,
address VAR106
)
public
payable
returns(uint);
}
library VAR107 {
function FUN32(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
if (VAR108 == 0) {
return 0;
}
uint256 VAR110 = VAR108 * VAR109;
require(VAR110 / VAR108 == VAR109);
return VAR110;
}
function FUN54(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
require(VAR109 > 0);
uint256 VAR110 = VAR108 / VAR109;
return VAR110;
}
function FUN57(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
require(VAR109 <= VAR108);
uint256 VAR110 = VAR108 - VAR109;
return VAR110;
}
function FUN31(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
uint256 VAR110 = VAR108 + VAR109;
require(VAR110 >= VAR108);
return VAR110;
}
function FUN58(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
require(VAR109 != 0);
return VAR108 % VAR109;
}
function FUN59(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
uint256 VAR110 = VAR108 / VAR109;
if(VAR108 % VAR109 == 0) {
return VAR110;
}
else {
return VAR110 + 1;
}
}
}
contract VAR92 {
function FUN60() public view returns (uint);
function FUN53() public view returns (uint);
function FUN12(address VAR111) public view returns (uint VAR50);
function FUN61(address VAR111, address VAR112) public view returns (uint VAR113);
function transfer(address VAR114, uint VAR93) public returns (bool VAR19);
function FUN62(address VAR112, uint VAR93) public returns (bool VAR19);
function FUN63(address VAR115, address VAR114, uint VAR93) public returns (bool VAR19);
}
contract VAR116 {
address public VAR117;
event FUN64(address indexed VAR118);
modifier onlyOwner {
require(msg.sender == VAR117, "");
VAR11;
}
constructor() public {
VAR117 = msg.sender;
}
function FUN65(address VAR118) external onlyOwner {
require(VAR118 != address(0), "");
VAR117 = VAR118;
emit FUN64(VAR118);
}
}
contract ModuleRegistry is VAR116 {
mapping (address => VAR119) internal VAR120;
mapping (address => VAR119) internal VAR121;
event FUN66(address indexed VAR122, bytes32 VAR7);
event FUN67(address VAR122);
event FUN68(address indexed VAR123, bytes32 VAR7);
event FUN69(address VAR123);
struct VAR119 {
bool VAR124;
bytes32 VAR7;
}
function FUN70(address VAR4, bytes32 VAR10) external onlyOwner {
require(!VAR120[VAR4].VAR124, "");
VAR120[VAR4] = FUN71({VAR124: true, VAR7: VAR10});
emit FUN66(VAR4, VAR10);
}
function FUN72(address VAR4) external onlyOwner {
require(VAR120[VAR4].VAR124, "");
delete VAR120[VAR4];
emit FUN67(VAR4);
}
function FUN73(address VAR125, bytes32 VAR10) external onlyOwner {
require(!VAR121[VAR125].VAR124, "");
VAR121[VAR125] = FUN71({VAR124: true, VAR7: VAR10});
emit FUN68(VAR125, VAR10);
}
function FUN74(address VAR125) external onlyOwner {
require(VAR121[VAR125].VAR124, "");
delete VAR121[VAR125];
emit FUN69(VAR125);
}
function FUN3(address VAR5) external onlyOwner {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(msg.sender, VAR12);
}
function FUN75(address VAR4) external view returns (bytes32) {
return VAR120[VAR4].VAR7;
}
function FUN76(address VAR125) external view returns (bytes32) {
return VAR121[VAR125].VAR7;
}
function FUN9(address VAR4) external view returns (bool) {
return VAR120[VAR4].VAR124;
}
function FUN9(address[] VAR126) external view returns (bool) {
for(uint VAR94 = 0; VAR94 < VAR126.VAR31; VAR94++) {
if (!VAR120[VAR126[VAR94]].VAR124) {
return false;
}
}
return true;
}
function FUN77(address VAR125) external view returns (bool) {
return VAR121[VAR125].VAR124;
}
}
contract DappRegistry is VAR116 {
mapping (address => mapping (bytes4 => bool)) internal VAR127;
event FUN78(address indexed VAR128, bytes4[] VAR129);
event FUN79(address indexed VAR128, bytes4[] VAR129);
function FUN80(address VAR128, bytes4[] VAR129) external onlyOwner {
for(uint VAR94 = 0; VAR94 < VAR129.VAR31; VAR94++) {
VAR127[VAR128][VAR129[VAR94]] = true;
}
emit FUN78(VAR128, VAR129);
}
function FUN81(address VAR128, bytes4[] VAR129) external onlyOwner {
for(uint VAR94 = 0; VAR94 < VAR129.VAR31; VAR94++) {
VAR127[VAR128][VAR129[VAR94]] = false;
}
emit FUN79(VAR128, VAR129);
}
function FUN82(address VAR128, bytes4 VAR130) external view returns (bool) {
return VAR127[VAR128][VAR130];
}
function FUN82(address VAR128, bytes4[] VAR129) external view returns (bool) {
for(uint VAR94 = 0; VAR94 < VAR129.VAR31; VAR94++) {
if (!VAR127[VAR128][VAR129[VAR94]]) {
return false;
}
}
return true;
}
}
contract VAR131 {
modifier FUN83(BaseWallet VAR3) {
require(VAR3.FUN36(msg.sender), "");
VAR11;
}
}
contract GuardianStorage is VAR131 {
struct VAR132 {
address[] VAR133;
mapping (address => VAR134) VAR135;
uint256 VAR136;
address VAR137;
}
struct VAR134 {
bool VAR124;
uint128 VAR138;
}
mapping (address => VAR132) internal VAR139;
function FUN84(BaseWallet VAR3, address VAR140) external FUN83(VAR3) {
GuardianStorageConfig storage VAR141 = VAR139[VAR3];
VAR141.VAR135[VAR140].VAR124 = true;
VAR141.VAR135[VAR140].VAR138 = uint128(VAR141.VAR133.FUN85(VAR140) - 1);
}
function FUN86(BaseWallet VAR3, address VAR140) external FUN83(VAR3) {
GuardianStorageConfig storage VAR141 = VAR139[VAR3];
address VAR142 = VAR141.VAR133[VAR141.VAR133.VAR31 - 1];
if (VAR140 != VAR142) {
uint128 VAR143 = VAR141.VAR135[VAR140].VAR138;
VAR141.VAR133[VAR143] = VAR142;
VAR141.VAR135[VAR142].VAR138 = VAR143;
}
VAR141.VAR133.VAR31--;
delete VAR141.VAR135[VAR140];
}
function FUN87(BaseWallet VAR3) external view returns (uint256) {
return VAR139[VAR3].VAR133.VAR31;
}
function FUN88(BaseWallet VAR3) external view returns (address[]) {
GuardianStorageConfig storage VAR141 = VAR139[VAR3];
address[] memory VAR133 = new address[](VAR141.VAR133.VAR31);
for (uint256 VAR94 = 0; VAR94 < VAR141.VAR133.VAR31; VAR94++) {
VAR133[VAR94] = VAR141.VAR133[VAR94];
}
return VAR133;
}
function FUN89(BaseWallet VAR3, address VAR140) external view returns (bool) {
return VAR139[VAR3].VAR135[VAR140].VAR124;
}
function FUN90(BaseWallet VAR3, uint256 VAR144) external FUN83(VAR3) {
VAR139[VAR3].VAR136 = VAR144;
if(VAR144 != 0 && msg.sender != VAR139[VAR3].VAR137) {
VAR139[VAR3].VAR137 = msg.sender;
}
}
function FUN91(BaseWallet VAR3) external view returns (bool) {
return VAR139[VAR3].VAR136 > VAR73;
}
function FUN92(BaseWallet VAR3) external view returns (uint256) {
return VAR139[VAR3].VAR136;
}
function FUN93(BaseWallet VAR3) external view returns (address) {
return VAR139[VAR3].VAR137;
}
}
contract DappStorage is VAR131 {
mapping (address => mapping (address => mapping (address => mapping (bytes4 => bool)))) internal VAR145;
function FUN94(
BaseWallet VAR3,
address VAR146,
address VAR128,
bytes4[] VAR24,
bool VAR147
)
external
FUN83(VAR3)
{
for(uint VAR94 = 0; VAR94 < VAR24.VAR31; VAR94++) {
VAR145[VAR3][VAR146][VAR128][VAR24[VAR94]] = VAR147;
}
}
function FUN95(BaseWallet VAR3, address VAR146, address VAR128, bytes4 VAR148) external view returns (bool) {
return VAR145[VAR3][VAR146][VAR128][VAR148];
}
}
contract VAR149 {
address public VAR150;
address public VAR117;
mapping (address => bool) public VAR127;
mapping (bytes4 => address) public VAR151;
uint public VAR120;
event FUN96(address indexed VAR122, bool value);
event FUN97(address indexed VAR122, bytes4 indexed VAR152);
event FUN98(address indexed VAR122, address indexed VAR153, uint indexed value, bytes VAR154);
event FUN99(uint indexed value, address indexed sender, bytes VAR154);
event FUN64(address VAR117);
modifier VAR155 {
require(VAR127[msg.sender], "");
VAR11;
}
function FUN1(address VAR156, address[] VAR126) external {
require(VAR117 == address(0) && VAR120 == 0, "");
require(VAR126.VAR31 > 0, "");
VAR117 = VAR156;
VAR120 = VAR126.VAR31;
for(uint256 VAR94 = 0; VAR94 < VAR126.VAR31; VAR94++) {
require(VAR127[VAR126[VAR94]] == false, "");
VAR127[VAR126[VAR94]] = true;
FUN100(VAR126[VAR94]).FUN1(this);
emit FUN96(VAR126[VAR94], true);
}
}
function FUN10(address VAR4, bool VAR34) external VAR155 {
if (VAR127[VAR4] != VAR34) {
if(VAR34 == true) {
VAR120 += 1;
VAR127[VAR4] = true;
FUN100(VAR4).FUN1(this);
}
else {
VAR120 -= 1;
require(VAR120 > 0, "");
delete VAR127[VAR4];
}
emit FUN96(VAR4, VAR34);
}
}
function FUN101(address VAR4, bytes4 VAR130) external VAR155 {
require(VAR127[VAR4], "");
VAR151[VAR130] = VAR4;
emit FUN97(VAR4, VAR130);
}
function FUN102(address VAR118) external VAR155 {
require(VAR118 != address(0), "");
VAR117 = VAR118;
emit FUN64(VAR118);
}
function FUN35(address VAR157, uint VAR34, bytes VAR22) external VAR155 {
require(VAR157.call.value(VAR34)(VAR22), "");
emit FUN98(msg.sender, VAR157, VAR34, VAR22);
}
function() public payable {
if(msg.VAR154.VAR31 > 0) {
address VAR122 = VAR151[msg.VAR158];
if(VAR122 == address(0)) {
emit FUN99(msg.value, msg.sender, msg.VAR154);
}
else {
require(VAR127[VAR122], "");
VAR44 {
FUN103(0, 0, FUN104())
let VAR159 := FUN105(VAR160, VAR122, 0, FUN104(), 0, 0)
FUN106(0, 0, FUN107())
switch VAR159
case 0 {revert(0, FUN107())}
default {return (0, FUN107())}
}
}
}
}
}
contract DappManager is VAR53, VAR161, VAR162 {
bytes32 constant VAR163 = "";
bytes4 constant internal VAR164 = bytes4(FUN25(""));
bytes4 constant internal VAR165 = bytes4(FUN25(""));
address constant internal VAR166 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
using SafeMath for uint256;
GuardianStorage public VAR167;
DappStorage public VAR168;
DappRegistry public VAR169;
uint256 public VAR170;
uint256 public VAR171;
struct VAR172 {
mapping (bytes32 => uint256) VAR60;
}
mapping (address => VAR172) internal VAR139;
event Transfer(address indexed VAR8, address indexed VAR90, uint256 indexed VAR47, address VAR114, bytes VAR154);
event FUN108(address indexed VAR3, address indexed VAR146, address indexed VAR128, bytes4[] VAR24);
event FUN109(address indexed VAR3, address indexed VAR146, address indexed VAR128, bytes4[] VAR24);
event FUN110(address indexed VAR3, address indexed VAR146, address indexed VAR128, bytes4[] VAR24);
event FUN111(address indexed VAR3, address indexed VAR146, address indexed VAR128, bytes4[] VAR24);
modifier FUN112(address VAR146) {
require(msg.sender == address(this) || msg.sender == VAR146, "");
VAR11;
}
modifier FUN113(BaseWallet VAR3) {
require(!VAR167.FUN91(VAR3), "");
VAR11;
}
constructor(
ModuleRegistry VAR9,
DappRegistry VAR173,
DappStorage VAR174,
GuardianStorage VAR175,
uint256 VAR71,
uint256 VAR176,
uint256 VAR69
)
FUN114(VAR9, VAR163)
FUN115(VAR69)
public
{
VAR168 = VAR174;
VAR167 = VAR175;
VAR169 = VAR173;
VAR170 = VAR71;
VAR171 = VAR176;
}
function FUN116(
BaseWallet VAR3,
address VAR146,
address VAR33,
uint256 VAR82,
bytes VAR22
)
external
FUN112(VAR146)
FUN113(VAR3)
{
require(FUN117(VAR3, VAR146, VAR33, VAR22), "");
require(FUN45(VAR3, VAR82), "");
FUN118(VAR3, VAR33, VAR82, VAR22);
}
function FUN119(
BaseWallet VAR3,
address VAR146,
address VAR128,
bytes4[] VAR24
)
external
onlyOwner(VAR3)
FUN113(VAR3)
{
require(VAR128 != address(0), "");
if(VAR169.FUN82(VAR128, VAR24)) {
VAR168.FUN94(VAR3, VAR146, VAR128, VAR24, true);
emit FUN110(VAR3, VAR146, VAR128, VAR24);
}
else {
bytes32 VAR177 = FUN25(VAR35.FUN26(address(VAR3), VAR146, VAR128, VAR24, true));
VAR139[VAR3].VAR60[VAR177] = VAR73 + VAR170;
emit FUN108(VAR3, VAR146, VAR128, VAR24);
}
}
function FUN120(
BaseWallet VAR3,
address VAR146,
address VAR128,
bytes4[] VAR24
)
external
onlyOwner(VAR3)
FUN113(VAR3)
{
VAR168.FUN94(VAR3, VAR146, VAR128, VAR24, false);
emit FUN111(VAR3, VAR146, VAR128, VAR24);
}
function FUN121(
BaseWallet VAR3,
address VAR146,
address VAR128,
bytes4[] VAR24
)
external
FUN113(VAR3)
{
bytes32 VAR177 = FUN25(VAR35.FUN26(address(VAR3), VAR146, VAR128, VAR24, true));
DappManagerConfig storage VAR141 = VAR139[VAR3];
require(VAR141.VAR60[VAR177] > 0, "");
require(VAR141.VAR60[VAR177] < VAR73, "");
require(VAR73 < VAR141.VAR60[VAR177] + VAR171, "");
VAR168.FUN94(VAR3, VAR146, VAR128, VAR24, true);
delete VAR141.VAR60[VAR177];
emit FUN110(VAR3, VAR146, VAR128, VAR24);
}
function FUN122(
BaseWallet VAR3,
address VAR146,
address VAR128,
bytes4[] VAR24
)
public
onlyOwner(VAR3)
FUN113(VAR3)
{
bytes32 VAR177 = FUN25(VAR35.FUN26(address(VAR3), VAR146, VAR128, VAR24, true));
DappManagerConfig storage VAR141 = VAR139[VAR3];
require(VAR141.VAR60[VAR177] > 0, "");
delete VAR141.VAR60[VAR177];
emit FUN109(VAR3, VAR146, VAR128, VAR24);
}
function FUN117(BaseWallet VAR3, address VAR146, address VAR33, bytes VAR22) public view returns (bool VAR178) {
if(VAR22.VAR31 >= 4) {
return VAR168.FUN95(VAR3, VAR146, VAR33, FUN37(VAR22));
}
return VAR168.FUN95(VAR3, VAR146, VAR33, "");
}
function FUN39(BaseWallet VAR3, uint256 VAR70) public onlyOwner(VAR3) FUN113(VAR3) {
FUN39(VAR3, VAR70, VAR170);
}
function FUN123(BaseWallet VAR3) external onlyOwner(VAR3) FUN113(VAR3) {
FUN39(VAR3, VAR54, VAR170);
}
function FUN118(BaseWallet VAR3, address VAR33, uint256 VAR34, bytes VAR22) internal {
VAR3.FUN35(VAR33, VAR34, VAR22);
emit Transfer(VAR3, VAR166, VAR34, VAR33, VAR22);
}
function FUN23(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR27, uint VAR24, address VAR46) internal {
uint256 VAR47 = 36616 + VAR45;
if(VAR26 > 0 && VAR24 > 0 && VAR47 <= VAR27) {
if(VAR26 > VAR48.VAR49) {
VAR47 = VAR47 * VAR48.VAR49;
}
else {
VAR47 = VAR47 * VAR26;
}
FUN47(VAR3, uint128(FUN41(VAR3)), VAR47);
VAR3.FUN35(VAR46, VAR47, "");
}
}
function FUN22(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR24) internal view returns (bool) {
if(VAR26 > 0 && VAR24 > 0 && (
address(VAR3).VAR50 < VAR45 * VAR26
|| FUN46(VAR3, FUN41(VAR3), VAR45 * VAR26) == false
|| VAR3.FUN36(this) == false
))
{
return false;
}
return true;
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
return FUN28(VAR3, VAR25);
}
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool) {
address VAR179 = FUN29(VAR23, VAR24, 0);
if(FUN37(VAR22) == VAR165) {
if(VAR22.VAR31 < 68) {
return false;
}
address VAR180;
VAR44 {
VAR180 := FUN30(FUN31(VAR22, 0x44))
}
return VAR180 == VAR179;
} else {
return FUN7(VAR3, VAR179);
}
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256) {
bytes4 VAR181 = FUN37(VAR22);
if (VAR181 == VAR164) {
return 0;
}
return 1;
}
}
1
---------------------------------
235 0xd69b75d5dc270e4f6cd664ac2354d12423c5ae9e.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) public returns (bool VAR5);
}
contract VAR6 {
function FUN1(address) public payable returns(uint256);
function FUN2() public;
function FUN3() public view returns(uint256);
function FUN4(bool) public view returns(uint256);
}
contract VAR7 {
address public VAR8;
address public VAR9;
function FUN5() public {
VAR8 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR8);
VAR10;
}
function FUN6(address VAR11) public onlyOwner {
VAR9 = VAR11;
}
function FUN7() public {
require(msg.sender == VAR9);
VAR8 = VAR9;
}
}
contract IronHands is VAR7 {
modifier onlyOwner(){
require(msg.sender == VAR8);
VAR10;
}
modifier FUN8(address VAR12){
require(VAR12 != address(VAR13));
VAR10;
}
event FUN9(uint256 VAR14, address VAR15);
event FUN10(uint256 VAR16, uint256 VAR17);
event FUN11(uint256 VAR14, address VAR18);
event FUN12(uint256 VAR14);
struct VAR19 {
address VAR20;
uint256 VAR21;
}
uint256 VAR22;
uint256 VAR23;
uint256 public VAR24;
uint256 public VAR25 = 0;
uint256 public VAR26 = 0;
VAR19[] public VAR27;
mapping(address => uint256) public VAR28;
POOH VAR13;
function FUN13(uint VAR29, address VAR30) public {
VAR24 = VAR29;
VAR13 = FUN14(VAR30);
}
function() payable public {
}
function FUN15() payable public {
require(msg.value > 1000000);
uint256 VAR31 = (msg.value * VAR24) / 100;
VAR27.FUN16(FUN17(msg.sender, VAR31));
VAR26 += VAR31;
VAR28[msg.sender] += VAR31;
emit FUN9(msg.value, msg.sender);
if(FUN4() > 0){
FUN2();
}
FUN18();
}
function FUN18() public {
uint VAR32 = address(this).VAR32;
require(VAR32 > 1);
VAR22 += VAR32;
uint VAR33 = VAR32 / 2;
VAR32 -= VAR33;
uint256 VAR4 = VAR13.VAR34.value(VAR33).FUN19(1000000)(msg.sender);
emit FUN10(VAR33, VAR4);
while (VAR32 > 0) {
uint VAR35 = VAR32 < VAR27[VAR25].VAR21 ? VAR32 : VAR27[VAR25].VAR21;
if(VAR35 > 0){
VAR32 -= VAR35;
VAR26 -= VAR35;
VAR28[VAR27[VAR25].VAR20] -= VAR35;
VAR27[VAR25].VAR21 -= VAR35;
if(VAR27[VAR25].VAR20.call.value(VAR35).FUN19(1000000)()){
emit FUN11(VAR35, VAR27[VAR25].VAR20);
}else{
VAR32 += VAR35;
VAR26 += VAR35;
VAR28[VAR27[VAR25].VAR20] += VAR35;
VAR27[VAR25].VAR21 += VAR35;
}
}
if(VAR32 > 0){
VAR25 += 1;
}
if(VAR25 >= VAR27.VAR36){
return;
}
}
}
function FUN3() public view returns(uint256){
return VAR13.FUN3();
}
function FUN4() public view returns(uint256){
return VAR13.FUN4(true);
}
function FUN20() public view returns(uint256){
return VAR23;
}
function FUN2() public {
uint256 VAR32 = address(this).VAR32;
VAR13.VAR37.FUN19(1000000)();
uint256 VAR38 = address(this).VAR32 - VAR32;
VAR23 += VAR38;
emit FUN12(VAR38);
}
function FUN21() public view returns (uint256){
return VAR27.VAR36 - VAR25;
}
function FUN22() public view returns (uint256){
return VAR26;
}
function FUN23() public view returns (uint256){
return VAR27.VAR36;
}
function FUN24() public view returns (uint256){
return VAR22;
}
function FUN25(address VAR39) public view returns (uint256) {
return VAR28[VAR39];
}
function FUN26() public view returns (uint256){
return FUN25(msg.sender);
}
function FUN27(address VAR40, address VAR41, uint VAR4) public onlyOwner FUN8(VAR40) returns (bool VAR5) {
return FUN28(VAR40).transfer(VAR41, VAR4);
}
}
1
---------------------------------
236 0xd87c91884f5796e7b0a7ee8cc5d40ad6c63f289d.sol
pragma VAR1 ^0.4.11;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
contract VAR2 {
function FUN1() constant returns (uint256 VAR3);
function FUN2(address VAR4) constant returns (uint256 VAR5);
function transfer(address VAR6, uint256 VAR7) returns (bool VAR8);
function FUN3(address VAR9, address VAR6, uint256 VAR7) returns (bool VAR8);
function FUN4(address VAR10, uint256 VAR7) returns (bool VAR8);
function FUN5(address VAR4, address VAR10) constant returns (uint256 VAR11);
event Transfer(address indexed VAR9, address indexed VAR6, uint256 VAR7);
event FUN6(address indexed VAR4, address indexed VAR10, uint256 VAR7);
}
contract VAR12
{
function FUN7(address VAR13) constant returns(uint VAR14);
function FUN8() public returns (uint VAR15);
function FUN9(address VAR6) returns (bool VAR8);
}
contract E4Lava is VAR2, VAR12 {
event FUN10(string msg);
event FUN11(string msg, uint VAR16);
enum VAR17  {VAR18, VAR19}
struct VAR20 {
bool VAR21;
uint VAR22;
uint VAR23;
uint VAR24;
}
uint constant VAR25         = 5762;
uint constant VAR26 = 100000;
uint constant VAR27        = 5762 * 100000;
uint public VAR28;
uint public VAR29;
uint public VAR30;
address public VAR31;
address public VAR32;
address public VAR33;
address public VAR34;
uint public VAR35;
string public VAR36;
mapping (address => VAR20) VAR37;
mapping (uint => address) VAR38;
mapping (address => mapping (address => uint256)) VAR39;
uint public VAR40;
uint public VAR41;
uint public VAR42;
uint public VAR43;
uint public VAR44;
SettingStateValue public VAR45;
function FUN12()
{
VAR32 = msg.sender;
VAR31 = msg.sender;
VAR35 = 2;
VAR36 = "";
}
function FUN13(SettingStateValue VAR46, uint VAR47, uint VAR48, uint VAR49, uint VAR50 )
{
if (msg.sender != VAR32)
return;
VAR41 = VAR47;
VAR43 = VAR49;
VAR44 = VAR50;
if (VAR45 == VAR17.VAR19)
return;
VAR45 = VAR46;
if (VAR46 == VAR17.VAR19) {
FUN10("");
return;
}
for (uint VAR51 = 0; VAR51 < VAR40; VAR51++ ) {
address VAR52 = VAR38[VAR51];
if (VAR52 != address(0)) {
VAR37[VAR52].VAR22 = 0;
VAR37[VAR52].VAR23 = 0;
VAR37[VAR52].VAR24 = 0;
}
}
VAR42 = VAR48;
VAR28 = 0;
if (this.VAR5 > 0) {
if (!VAR32.call.FUN14(VAR43).value(this.VAR5)())
FUN10("");
}
FUN10("");
}
function FUN15(address VAR13) internal  {
VAR37[VAR13].VAR21 = true;
VAR37[VAR13].VAR22 = 0;
VAR37[VAR13].VAR23 = 0;
VAR37[VAR13].VAR24 = VAR30;
VAR38[VAR40++] = VAR13;
}
function FUN1() constant returns (uint256 VAR3)
{
VAR3 = VAR27;
}
function transfer(address VAR6, uint256 VAR7) returns (bool VAR8)
{
if ((msg.sender == VAR31)
&&  (VAR53 < VAR42)) {
return false;
}
if (VAR37[msg.sender].VAR22 >= VAR7 && VAR7 > 0) {
FUN16(msg.sender);
VAR37[msg.sender].VAR22 -= VAR7;
if (!VAR37[VAR6].VAR21) {
FUN15(VAR6);
}
FUN16(VAR6);
VAR37[VAR6].VAR22 += VAR7;
Transfer(msg.sender, VAR6, VAR7);
return true;
} else {
return false;
}
}
function FUN3(address VAR9, address VAR6, uint256 VAR7) returns (bool VAR8) {
if ((VAR9 == VAR31)
&&  (VAR53 < VAR42)) {
return false;
}
if (VAR37[VAR9].VAR22 >= VAR7 && VAR39[VAR9][msg.sender] >= VAR7 && VAR7 > 0) {
FUN16(VAR9);
VAR37[VAR9].VAR22 -= VAR7;
if (!VAR37[VAR6].VAR21) {
FUN15(VAR6);
}
FUN16(VAR6);
VAR37[VAR6].VAR22 += VAR7;
VAR39[VAR9][msg.sender] -= VAR7;
Transfer(VAR9, VAR6, VAR7);
return true;
} else {
return false;
}
}
function FUN2(address VAR4) constant returns (uint256 VAR5) {
VAR5 = VAR37[VAR4].VAR22;
}
function FUN4(address VAR10, uint256 VAR7) returns (bool VAR8) {
VAR39[msg.sender][VAR10] = VAR7;
FUN6(msg.sender, VAR10, VAR7);
return true;
}
function FUN5(address VAR4, address VAR10) constant returns (uint256 VAR11) {
return VAR39[VAR4][VAR10];
}
function FUN16(address VAR54) {
VAR37[VAR54].VAR23 += (VAR30 - VAR37[VAR54].VAR24) * VAR37[VAR54].VAR22;
VAR37[VAR54].VAR24 = VAR30;
}
function () payable {
VAR29 += msg.value;
VAR30 += msg.value;
FUN11("", msg.value);
}
function FUN17() payable {
FUN11("", msg.value);
}
function FUN8() public returns (uint VAR14)
{
FUN16(msg.sender);
VAR14 = VAR37[msg.sender].VAR23 / VAR27;
if (VAR14 <= VAR41) {
FUN11("", VAR14);
return;
} else {
if ((msg.sender == VAR31)
&&  (VAR53 < VAR42)) {
FUN10("");
VAR14 = 0;
return;
}
uint VAR55 = VAR14 * VAR27;
VAR37[msg.sender].VAR23 -= VAR55;
VAR29 -= VAR14;
if (!msg.sender.call.FUN14(VAR43).value(VAR14)())
throw;
}
}
function FUN9(address VAR6) returns (bool VAR8)
{
if ((msg.sender == VAR31)
&&  (VAR53 < VAR42)) {
return false;
}
FUN16(msg.sender);
if (VAR37[msg.sender].VAR23 == 0) {
FUN10("");
return false;
}
if (!VAR37[VAR6].VAR21) {
FUN15(VAR6);
}
FUN16(VAR6);
VAR37[VAR6].VAR23 += VAR37[msg.sender].VAR23;
VAR37[msg.sender].VAR23 = 0;
FUN10("");
return true;
}
function FUN18(uint VAR49, uint VAR56)
{
if (msg.sender != VAR32 && msg.sender != VAR31) {
return;
} else {
VAR43 = VAR49;
VAR44 = VAR56;
}
}
function FUN7(address VAR13) constant returns(uint VAR14)
{
if (VAR37[VAR13].VAR21) {
uint VAR57 = VAR37[VAR13].VAR23 +
((VAR30 - VAR37[VAR13].VAR24) * VAR37[VAR13].VAR22);
VAR14 = VAR57 / VAR27;
}
}
function FUN19(address VAR13)
{
if (msg.sender != VAR32
|| VAR45 == VAR17.VAR19)
throw;
VAR32 = VAR13;
}
function FUN20(address VAR13)
{
if (msg.sender != VAR32
|| VAR45 == VAR17.VAR19)
throw;
VAR31 = VAR13;
}
function FUN21(address VAR58, address VAR59)
{
if (msg.sender != VAR32
|| VAR45 == VAR17.VAR19)
throw;
VAR33 = VAR58;
VAR34 = VAR59;
}
function FUN22()
{
if (VAR45 != VAR17.VAR18)
throw;
if (msg.sender != VAR32)
throw;
FUN23(VAR31);
}
function FUN24() public
{
if (VAR33 == address(0)) {
FUN10("");
return;
}
address VAR60 = msg.sender;
if (VAR37[VAR60].VAR22 != 0) {
FUN10("");
return;
}
Token VAR61 = FUN25(VAR33);
uint VAR62 = VAR61.FUN2(VAR60);
if (VAR62 == 0) {
FUN10("");
return;
}
if (VAR61.FUN5(VAR60, address(this)) < VAR62) {
FUN10("");
return;
}
VAR61.VAR63.FUN14(VAR44)(VAR60, VAR34, VAR62);
if (VAR61.FUN2(VAR60) == 0) {
if (!VAR37[VAR60].VAR21)
FUN15(VAR60);
VAR37[VAR60].VAR22 = VAR62 * VAR26;
VAR37[VAR60].VAR24 = 0;
FUN16(VAR60);
VAR28 += VAR62;
FUN10("");
} else
FUN10("");
}
}
1
---------------------------------
237 0xd9c1685fab2faa7041f4f6268300fc0cbd5bc866.sol
pragma VAR1 ^0.4.25;
interface VAR2  {
function() payable external;
function FUN1(address VAR3) external payable;
function FUN2(address VAR4) external;
function FUN3() external;
}
contract VAR5 {
address public VAR6;
address public VAR7;
event FUN4(address indexed VAR8, address indexed VAR9);
constructor() public {
VAR6 = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;
}
modifier onlyOwner {
require(msg.sender == VAR6);
VAR10;
}
function FUN5(address VAR11) public onlyOwner {
VAR6 = VAR11;
}
}
library VAR12 {
function FUN6(uint VAR13, uint VAR14) internal pure returns (uint VAR15) {
VAR15 = VAR13 + VAR14;
require(VAR15 >= VAR13);
}
function FUN7(uint VAR13, uint VAR14) internal pure returns (uint VAR15) {
require(VAR14 <= VAR13);
VAR15 = VAR13 - VAR14;
}
function FUN8(uint VAR13, uint VAR14) internal pure returns (uint VAR15) {
VAR15 = VAR13 * VAR14;
require(VAR13 == 0 || VAR15 / VAR13 == VAR14);
}
function FUN9(uint VAR13, uint VAR14) internal pure returns (uint VAR15) {
require(VAR14 > 0);
VAR15 = VAR13 / VAR14;
}
}
contract Snip3D is  VAR5 {
using SafeMath for uint;
Snip3DInterface constant VAR16 = FUN10(0x6D534b48835701312ebc904d4b37e54D4f7D039f);
function FUN11 () onlyOwner public payable {
VAR16.VAR17.value(0.1 VAR18)(msg.sender);
}
function FUN12 () onlyOwner public {
VAR16.FUN3();
}
function FUN2 () onlyOwner public {
VAR16.FUN2(address(this));
}
function FUN13 () onlyOwner public {
msg.sender.transfer(address(this).VAR19);
}
}
1
---------------------------------
238 0xdd17afae8a3dd1936d1113998900447ab9aa9bc0.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
struct VAR3
{
uint VAR4;
uint VAR5;
}
mapping (address => VAR3) public VAR6;
uint public VAR7;
Log VAR8;
bool VAR9;
function FUN1(uint VAR10)
public
{
if(VAR9)throw;
VAR7 = VAR10;
}
function FUN2(address VAR11)
public
{
if(VAR9)throw;
VAR8 = FUN3(VAR11);
}
function FUN4()
public
{
VAR9 = true;
}
function FUN5(uint VAR12)
public
payable
{
var VAR13 = VAR6[msg.sender];
VAR13.VAR5 += msg.value;
if(VAR14+VAR12>VAR13.VAR4)VAR13.VAR4=VAR14+VAR12;
VAR8.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR15)
public
payable
{
var VAR13 = VAR6[msg.sender];
if( VAR13.VAR5>=VAR7 && VAR13.VAR5>=VAR15 && VAR14>VAR13.VAR4)
{
if(msg.sender.call.value(VAR15)())
{
VAR13.VAR5-=VAR15;
VAR8.FUN6(msg.sender,VAR15,"");
}
}
}
function()
public
payable
{
FUN5(0);
}
}
contract VAR16
{
struct VAR17
{
address VAR18;
string  VAR19;
uint VAR20;
uint  VAR21;
}
VAR17[] public VAR22;
Message VAR23;
function FUN6(address VAR24,uint VAR10,string VAR25)
public
{
VAR23.VAR18 = VAR24;
VAR23.VAR21 = VAR14;
VAR23.VAR20 = VAR10;
VAR23.VAR19 = VAR25;
VAR22.FUN8(VAR23);
}
}
1
---------------------------------
239 0xdd4465dffdc7a53c0b778dfec2f4f81560e4a5ef.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract HubTokenPurchase is VAR2 {
address public VAR13 = 0xcc04AF825eEf340e99710D4366e3021F8d82F42A;
address public VAR14 = 0x212286e36Ae998FAd27b627EB326107B3aF1FeD4;
address public VAR15 = 0x515962688858eD980EB2Db2b6fA2802D9f620C6d;
uint public VAR16 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR17) internal {
uint VAR18 = VAR17 * 3 / 105;
uint VAR19 = VAR17 * 2 / 105;
require(VAR14.call.FUN9(VAR16).value(VAR18)());
require(VAR15.call.FUN9(VAR16).value(VAR19)());
uint VAR20 = VAR17 - VAR18 - VAR19;
require(VAR13.call.FUN9(VAR16).value(VAR20)());
}
function FUN10(uint VAR21) public onlyOwner {
VAR16 = VAR21;
}
function FUN11(EIP20Token VAR22, address VAR23, uint value) public onlyOwner {
VAR22.FUN5(VAR23, value);
}
function FUN12() public onlyOwner {
require(msg.sender.call.FUN9(VAR16).value(address(this).VAR24)());
}
}
1
---------------------------------
240 0xdd4950f977ee28d2c132f1353d1595035db444ee.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(address VAR3) external payable returns (bool);
function FUN2() external returns (bool);
}
contract VAR4 {
string public VAR5 = "";
JIincInterfaceForForwarder private VAR6;
address private VAR7;
bool VAR8 = true;
constructor()
public
{
}
function()
public
payable
{
VAR6.VAR9.value(address(this).VAR10)(address(VAR6));
}
function FUN1()
public
payable
returns(bool)
{
require(msg.value > 0, "");
require(VAR8 == false, "");
if (VAR6.VAR9.value(msg.value)(msg.sender) == true)
return(true);
else
return(false);
}
function FUN3()
public
view
returns(address, address, bool)
{
return(address(VAR6), address(VAR7), VAR8);
}
function FUN4(address VAR11)
external
returns(bool)
{
require(msg.sender == address(VAR6), "");
if(FUN5(VAR11).FUN2() == true)
{
VAR7 = VAR11;
return (true);
} else
return (false);
}
function FUN6()
external
returns(bool)
{
require(msg.sender == address(VAR6), "");
VAR7 = address(0x0);
return (true);
}
function FUN7()
external
returns(bool)
{
require(msg.sender == VAR7, "");
VAR6 = (FUN5(VAR7));
VAR7 = address(0x0);
return (true);
}
function FUN8(address VAR12)
external
{
require(VAR8 == true, "");
VAR6 = FUN5(VAR12);
VAR8 = false;
}
}
1
---------------------------------
241 0xddabca696af8608452b3451b7d70fff57d0ca3e7.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
function FUN6() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract VAR11 {
mapping(address => bool) public VAR12;
address[] public VAR13;
uint8 public VAR14;
event FUN8(address indexed VAR15);
event FUN9(address indexed VAR16);
function FUN10() public {
address VAR7 = msg.sender;
VAR13.FUN11(VAR7);
VAR12[VAR7] = true;
VAR14++;
}
modifier onlyOwner() {
require(VAR12[msg.sender]);
VAR10;
}
function FUN12() public view returns (uint) {
return VAR13.VAR17;
}
function FUN13(address VAR7) onlyOwner public {
require(VAR7 != address(0));
require(!VAR12[VAR7]);
VAR13.FUN11(VAR7);
VAR12[VAR7] = true;
VAR14++;
FUN8(VAR7);
}
function FUN14(address VAR7) onlyOwner public {
require(VAR14 > 1);
require(VAR12[VAR7]);
VAR12[VAR7] = false;
VAR14--;
FUN9(VAR7);
}
}
contract Pausable is VAR6 {
bool public VAR18;
modifier VAR19 {
require(!VAR18);
VAR10;
}
modifier VAR20 {
require(VAR18);
VAR10;
}
function FUN15() external onlyOwner VAR19 {
VAR18 = true;
}
function FUN16() external onlyOwner VAR20 {
VAR18 = false;
}
}
contract VAR21 {
uint256 public VAR22;
function FUN17(address VAR23) public view returns (uint256 VAR24);
function transfer(address VAR25, uint256 VAR26) public returns (bool VAR27);
function FUN18(address VAR28, address VAR25, uint256 VAR26) public returns (bool VAR27);
function FUN19(address VAR29, uint256 VAR26) public returns (bool VAR27);
function FUN20(address VAR23, address VAR29) public view returns (uint256 VAR30);
event Transfer(address indexed VAR28, address indexed VAR25, uint256 VAR26);
event FUN21(address indexed VAR23, address indexed VAR29, uint256 VAR26);
}
contract StandardToken is VAR21 {
using SafeMath for uint;
mapping(address => uint256) VAR31;
mapping(address => mapping(address => uint256)) VAR32;
function FUN17(address VAR23) public view returns (uint256 VAR24) {
return VAR31[VAR23];
}
function transfer(address VAR25, uint256 VAR26) public returns (bool) {
require(VAR25 != address(0));
VAR31[msg.sender] = VAR31[msg.sender].FUN3(VAR26);
VAR31[VAR25] = VAR31[VAR25].FUN4(VAR26);
Transfer(msg.sender, VAR25, VAR26);
return true;
}
function FUN18(address VAR28, address VAR25, uint256 VAR26) public returns (bool) {
require(VAR25 != address(0));
VAR31[VAR28] = VAR31[VAR28].FUN3(VAR26);
VAR31[VAR25] = VAR31[VAR25].FUN4(VAR26);
VAR32[VAR28][msg.sender] = VAR32[VAR28][msg.sender].FUN3(VAR26);
Transfer(VAR28, VAR25, VAR26);
return true;
}
function FUN19(address VAR29, uint256 VAR26) public returns (bool) {
VAR32[msg.sender][VAR29] = VAR26;
FUN21(msg.sender, VAR29, VAR26);
return true;
}
function FUN20(address VAR23, address VAR29) public view returns (uint256 VAR30) {
return VAR32[VAR23][VAR29];
}
}
contract CommonToken is VAR33, VAR11 {
string public constant VAR34 = '';
string public constant VAR35 = '';
uint8 public constant VAR36 = 18;
address public VAR37;
uint256 public constant VAR38 = 110200000 VAR39;
uint256 public VAR40;
uint256 public VAR41;
bool public VAR42 = true;
event FUN22(address indexed VAR43, address indexed VAR44, uint256 VAR26);
event FUN23(address indexed VAR45, address indexed VAR46);
event FUN24(address indexed VAR47, uint256 VAR26);
event FUN25();
function FUN26(
address VAR43
) FUN10() public {
require(VAR43 != 0);
VAR37 = VAR43;
VAR22 = 190000000 VAR39;
VAR31[VAR37] = VAR22;
Transfer(0x0, VAR37, VAR22);
}
modifier FUN27() {
require(VAR12[msg.sender] || !VAR42);
VAR10;
}
function FUN28(address VAR48) onlyOwner public returns (bool) {
require(VAR48 != address(0));
require(VAR37 != VAR48);
require(VAR31[VAR48] == 0);
address VAR49 = VAR37;
uint256 VAR50 = VAR31[VAR49];
VAR31[VAR49] = 0;
VAR31[VAR48] = VAR50;
Transfer(VAR49, VAR48, VAR50);
VAR37 = VAR48;
FUN23(VAR49, VAR48);
return true;
}
function FUN29(address VAR25, uint256 VAR26) public returns (bool) {
return FUN30(VAR25, VAR26 * 1e18);
}
function FUN30(address VAR25, uint256 VAR26) onlyOwner public returns (bool) {
if (VAR38 > 0) require(VAR40.FUN4(VAR26) <= VAR38);
require(VAR25 != address(0));
require(VAR26 > 0);
require(VAR26 <= VAR31[VAR37]);
VAR31[VAR37] = VAR31[VAR37].FUN3(VAR26);
VAR31[VAR25] = VAR31[VAR25].FUN4(VAR26);
Transfer(VAR37, VAR25, VAR26);
VAR41++;
VAR40 = VAR40.FUN4(VAR26);
FUN22(VAR37, VAR25, VAR26);
return true;
}
function transfer(address VAR25, uint256 VAR26) ifUnlocked public returns (bool) {
return super.transfer(VAR25, VAR26);
}
function FUN18(address VAR28, address VAR25, uint256 VAR26) ifUnlocked public returns (bool) {
return super.FUN18(VAR28, VAR25, VAR26);
}
function FUN31(uint256 VAR26) public returns (bool) {
require(VAR26 > 0);
VAR31[msg.sender] = VAR31[msg.sender].FUN3(VAR26);
VAR22 = VAR22.FUN3(VAR26);
Transfer(msg.sender, 0x0, VAR26);
FUN24(msg.sender, VAR26);
return true;
}
function FUN32() onlyOwner public {
require(VAR42);
VAR42 = false;
FUN25();
}
}
contract CommonWhitelist is VAR11 {
mapping(address => bool) public VAR51;
address[] public VAR52;
event FUN33(address indexed VAR53);
event FUN34(address indexed VAR53);
function FUN35() FUN10() public {}
function FUN36() public view returns (uint) {
return VAR52.VAR17;
}
function FUN4(address VAR54) internal {
require(VAR54 != address(0));
require(!VAR51[VAR54]);
VAR52.FUN11(VAR54);
VAR51[VAR54] = true;
FUN33(VAR54);
}
function FUN37(address[] VAR55) public onlyOwner {
for (uint VAR56 = 0; VAR56 < VAR55.VAR17; VAR56++) {
FUN4(VAR55[VAR56]);
}
}
function FUN38(address VAR54) internal {
require(VAR51[VAR54]);
VAR51[VAR54] = false;
FUN34(VAR54);
}
function FUN39(address[] VAR55) public onlyOwner {
for (uint VAR56 = 0; VAR56 < VAR55.VAR17; VAR56++) {
FUN38(VAR55[VAR56]);
}
}
}
contract VAR57 {
address public VAR58;
modifier onlyManager {
require(msg.sender == VAR58);
VAR10;
}
function FUN40(address VAR59) public onlyManager() {
require(VAR59 != address(0));
VAR58 = VAR59;
}
}
contract ICrowdsaleProcessor is VAR6, VAR57 {
modifier FUN41() {
require(FUN42());
VAR10;
}
modifier FUN43() {
require(FUN44());
VAR10;
}
modifier FUN45() {
require(FUN46());
VAR10;
}
modifier FUN47() {
require(!VAR60);
VAR10;
}
modifier FUN48() {
require(VAR60);
VAR10;
}
modifier FUN49() {
require(!VAR61);
VAR10;
}
modifier FUN50() {
require(VAR61);
VAR10;
}
uint256 constant public VAR62 = 1 VAR39;
uint256 constant public VAR63 = 3 VAR64;
uint256 constant public VAR65 = 50 VAR64;
bool public VAR61;
bool public VAR60;
uint256 public VAR66;
uint256 public VAR67;
uint256 public VAR68;
uint256 public VAR69;
uint256 public VAR70;
uint256 public VAR71;
uint256 public VAR72;
function FUN51() public payable {}
function FUN52() public returns (address);
function FUN53(address VAR73, uint256 VAR74) public onlyManager();
function FUN54(address VAR73, uint256 VAR74) public onlyManager();
function FUN55() public onlyManager() FUN47() FUN45();
function FUN56() public onlyManager() FUN47();
function FUN57(uint256 VAR75, uint256 VAR76, address VAR77)
public onlyManager() FUN49() FUN47();
function FUN44() public constant returns (bool);
function FUN42() public constant returns (bool);
function FUN46() public constant returns (bool);
}
contract BasicCrowdsale is VAR78 {
event FUN58(uint256 VAR71, uint256 VAR72, address VAR79);
address public VAR79;
function FUN59(
address VAR23,
address VAR80
)
public
{
VAR7 = VAR23;
VAR58 = VAR80;
}
function FUN53(
address VAR73,
uint256 VAR74
)
public
onlyManager()
{
require(VAR73.call.value(VAR74)());
}
function FUN56() public onlyManager() FUN47() {
if (VAR61) {
require(!FUN44());
require(!FUN46());
}
VAR60 = true;
}
function FUN57(
uint256 VAR75,
uint256 VAR76,
address VAR77
)
public
onlyManager()
FUN49()
FUN47()
{
require(VAR77 != address(0));
require(VAR75 >= VAR81.VAR82);
require(VAR76 > VAR75);
VAR70 = VAR76 - VAR75;
require(VAR70 >= VAR63 && VAR70 <= VAR65);
VAR71 = VAR75;
VAR72 = VAR76;
VAR79 = VAR77;
VAR61 = true;
FUN58(VAR75, VAR76, VAR77);
}
function FUN44()
public
constant
returns (bool)
{
return (
VAR61 &&
VAR81.VAR82 >= VAR72 &&
VAR66 < VAR68
);
}
function FUN42()
public
constant
returns (bool)
{
return (
VAR61 &&
VAR66 < VAR69 &&
VAR81.VAR82 >= VAR71 &&
VAR81.VAR82 < VAR72
);
}
function FUN46()
public
constant
returns (bool)
{
return (
VAR66 >= VAR69 ||
(VAR81.VAR82 >= VAR72 && VAR66 >= VAR68)
);
}
}
contract VAR83 {
uint256 public VAR84;
uint256 public VAR85;
}
contract Bridge is VAR86 {
using SafeMath for uint256;
modifier FUN60() {
require(msg.sender == VAR87);
VAR10;
}
StandardToken VAR88;
address public VAR87;
bool public VAR89;
function FUN61(
uint256 VAR90,
uint256 VAR91,
address VAR92,
address VAR93
)
public
FUN59(msg.sender, msg.sender)
{
VAR68 = VAR90;
VAR69 = VAR91;
VAR87 = VAR93;
VAR88 = FUN62(VAR92);
}
function FUN52()
public
returns (address)
{
return address(VAR88);
}
function FUN54(
address VAR73,
uint256 VAR74
)
public
onlyManager()
{
VAR88.transfer(VAR73, VAR74);
}
function FUN55()
public
onlyManager()
FUN47()
FUN45()
{
}
function() payable public {
}
function FUN63(uint256 VAR94, uint256 VAR95) public
FUN50()
FUN47()
FUN41()
FUN60()
{
VAR66 = VAR66.FUN4(VAR94);
VAR67 = VAR67.FUN4(VAR95);
}
function FUN64() public
FUN47()
FUN50()
FUN41()
FUN60()
{
VAR89 = true;
}
function FUN65(
uint256 VAR74
)
public
onlyOwner()
FUN47()
FUN45()
{
}
function FUN66()
public
{
}
function FUN57(
uint256 VAR75,
uint256 VAR76,
address VAR77
)
public
onlyManager()
FUN49()
FUN47()
{
VAR61 = true;
FUN58(VAR75, VAR76, VAR77);
}
function FUN44()
public
constant
returns (bool)
{
return (
false
);
}
function FUN42()
public
constant
returns (bool)
{
return (
VAR61 && !VAR89
);
}
function FUN46()
public
constant
returns (bool)
{
return (
VAR89
);
}
function FUN67() public view returns (uint256, uint256) {
uint256 VAR85 = FUN68(VAR58).FUN69();
uint256 VAR84 = FUN68(VAR58).FUN70();
uint256 VAR96 = VAR67.FUN1(VAR85) / 1000000;
bool VAR97 = (VAR84 != 0);
uint256 VAR98 = 0;
if (VAR97) {
VAR98 = VAR66.FUN1(VAR84) / 1000000;
}
return (VAR98, VAR96);
}
}
contract Connector is VAR6 {
modifier FUN71() {
require(address(VAR99) != address(0x0));
VAR10;
}
Bridge public VAR99;
function FUN72(address VAR100) public onlyOwner {
require(VAR100 != address(0x0));
VAR99 = FUN61(VAR100);
}
function FUN63(uint256 VAR94, uint256 VAR101) internal VAR102 {
VAR99.FUN63(VAR94, VAR101);
}
function FUN73() internal VAR102 {
VAR99.FUN64();
}
}
contract CommonTokensale is VAR103, VAR104 {
using SafeMath for uint;
CommonToken public VAR88;
CommonWhitelist public VAR105;
address public VAR106;
address public VAR107 = 0x8D5bd2aBa04A07Bfa0cc976C73eD45B23cC6D6a2;
bool public VAR108 = true;
uint public constant VAR109 = 5 VAR39;
uint public constant VAR110 = 0.05 VAR39;
uint public VAR111 = 4750;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
uint public VAR116;
uint public VAR117 = 3200 VAR39;
uint public VAR118 = 16000 VAR39;
uint public constant VAR119 = 1525701600;
uint public constant VAR120 = 1526306400;
uint public constant VAR121 = 1526392800;
uint public constant VAR122 = 1528639200;
uint public VAR123;
uint public VAR124;
uint public VAR125;
uint public VAR126;
uint public VAR127;
mapping(address => uint256) public VAR128;
mapping(bytes32 => bool) public VAR129;
event FUN74(address indexed VAR130, address indexed VAR131);
event FUN75(address indexed VAR130, address indexed VAR131);
event FUN76(address indexed VAR44, uint256 VAR132);
event FUN77(address indexed VAR44, uint256 VAR132);
function FUN78(
address VAR92,
address VAR133,
address VAR134
) public FUN79() {
require(VAR92 != 0);
require(VAR133 != 0);
require(VAR134 != 0);
VAR88 = FUN26(VAR92);
VAR105 = FUN35(VAR133);
VAR106 = VAR134;
VAR123 = VAR121 + 48 VAR135;
VAR124 = VAR122 + 30 VAR64;
FUN80();
}
modifier FUN81(bytes32 VAR136) {
require(!VAR129[VAR136]);
VAR129[VAR136] = true;
VAR10;
}
function FUN82(uint VAR137) public onlyOwner FUN81("") {
VAR117 = VAR137 * 1e18;
}
function FUN83(uint VAR137) public onlyOwner FUN81("") {
VAR118 = VAR137 * 1e18;
}
function FUN84(uint VAR137) public onlyOwner FUN81("") {
VAR111 = VAR137;
FUN80();
}
function FUN85(address VAR134) public onlyOwner {
require(VAR134 != 0);
FUN74(VAR106, VAR134);
VAR106 = VAR134;
}
function FUN86(address VAR133) public onlyOwner {
require(VAR133 != 0);
FUN75(VAR105, VAR133);
VAR105 = FUN35(VAR133);
}
function FUN87(bool VAR138) public onlyOwner {
VAR108 = VAR138;
}
function() public payable {
FUN88(msg.sender, msg.value);
}
function FUN88(
address VAR44,
uint256 VAR132
) ifNotPaused internal {
if (VAR108) require(VAR105.FUN89(VAR44));
require(FUN90(VAR132));
require(VAR126 < VAR118);
uint256 VAR139 = VAR126.FUN4(VAR132);
if (VAR139 > VAR118) {
uint VAR140 = VAR139.FUN3(VAR118);
VAR132 = VAR132.FUN3(VAR140);
require(FUN90(VAR132));
VAR44.transfer(VAR140);
}
uint VAR141 = FUN91(VAR132);
VAR88.FUN30(VAR44, VAR141);
uint VAR142 = VAR141.FUN1(75).FUN2(10000);
VAR88.FUN30(VAR107, VAR142);
VAR125 = VAR125.FUN4(VAR141).FUN4(VAR142);
VAR126 = VAR126.FUN4(VAR132);
VAR128[VAR44] = VAR128[VAR44].FUN4(VAR132);
FUN76(VAR44, VAR132);
FUN63(VAR132, VAR141.FUN4(VAR142));
}
function FUN80() internal {
VAR112 = FUN92(5);
VAR113 = FUN92(7);
VAR114 = FUN92(10);
VAR115 = FUN92(15);
VAR116 = FUN92(20);
}
function FUN92(uint VAR143) public view returns (uint) {
return VAR111.FUN4(
FUN93(VAR111, VAR143)
);
}
function FUN93(uint VAR74, uint VAR143) public pure returns (uint) {
return VAR74.FUN1(VAR143).FUN2(100);
}
function FUN91(uint VAR132) public view returns (uint) {
return VAR132.FUN1(FUN94(VAR132));
}
function FUN94(uint VAR132) public view returns (uint256) {
if (FUN95()) {
if (5 VAR39 <= VAR132 && VAR132 < 10 VAR39) return VAR114;
if (VAR132 < 20 VAR39) return VAR115;
if (20 VAR39 <= VAR132) return VAR116;
}
if (FUN96()) {
if (0.05 VAR39 <= VAR132 && VAR132 < 10 VAR39) return VAR112;
if (VAR132 < 20 VAR39) return VAR113;
if (20 VAR39 <= VAR132) return VAR114;
}
return VAR111;
}
function FUN90(uint VAR132) public view returns (bool) {
if (FUN95()) return VAR132 >= VAR109;
if (FUN97()) return VAR132 >= VAR110;
return false;
}
function FUN95() public view returns (bool) {
return VAR119 <= VAR144 && VAR144 <= VAR120;
}
function FUN96() public view returns (bool) {
return VAR121 <= VAR144 && VAR144 <= VAR123;
}
function FUN97() public view returns (bool) {
return VAR121 <= VAR144 && VAR144 <= VAR122;
}
function FUN98() public view returns (bool) {
return VAR126 >= VAR117 && VAR144 > VAR122;
}
function FUN99() public view returns (bool) {
return VAR126 >= VAR117 || VAR144 > VAR124;
}
function FUN65(address VAR25, uint256 VAR74) public {
require(FUN99());
require(msg.sender == VAR106);
require(VAR74 <= this.VAR24);
VAR25.transfer(VAR74);
}
function FUN65(address VAR25) public {
FUN65(VAR25, this.VAR24);
}
function FUN100() public view returns (bool) {
return VAR126 < VAR117 && VAR122 < VAR144 && VAR144 <= VAR124;
}
function FUN66() public {
require(FUN100());
address VAR145 = msg.sender;
uint VAR146 = VAR128[VAR145];
require(VAR146 > 0);
FUN77(VAR145, VAR146);
VAR128[VAR145] = 0;
VAR127 = VAR127.FUN4(VAR146);
VAR145.transfer(VAR146);
}
function FUN51() public payable {
require(FUN98());
}
function FUN101() public onlyOwner FUN81("") {
require(FUN98());
uint256 VAR98 = 0;
uint256 VAR96 = 0;
(VAR98, VAR96) = VAR99.FUN67();
if (VAR98 > 0) {
VAR99.transfer(VAR98);
}
if (VAR96 > 0) {
VAR88.FUN30(VAR99, VAR96);
}
FUN73();
}
}
contract ProdTokensale is VAR147 {
function FUN102() FUN78(
0x123,
0x123,
0x123
) public {}
}
1
---------------------------------
242 0xdde1cddbbc4bfc0d2e9f5b2957456a2b651aaa6b.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal  pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal  pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure  returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
address VAR8;
modifier FUN5(address VAR9) {
require(msg.sender == VAR9);
VAR10;
}
constructor() public {
VAR7 = msg.sender;
}
function FUN6(address VAR11) FUN5(VAR7) public {
VAR8 = VAR11;
}
function FUN7() FUN5(VAR8) public {
emit FUN8(VAR7, VAR8);
VAR7 = VAR8;
}
event FUN8(address indexed VAR12, address indexed VAR13);
}
contract ERC20 is VAR6 {
using SafeMath for uint;
uint public VAR14;
bool public VAR15 = false;
mapping (address => uint) VAR16;
mapping (address => mapping (address => uint)) VAR17;
modifier FUN9() {
require(VAR15);
VAR10;
}
modifier FUN10() {
require(!VAR15);
VAR10;
}
event Transfer(address indexed VAR12, address indexed VAR13, uint VAR18);
event FUN11(address indexed VAR19, address indexed VAR20, uint VAR18);
function transfer(address VAR13, uint VAR18) isStartedOnly public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
emit Transfer(msg.sender, VAR13, VAR18);
return true;
}
function FUN12(address VAR12, address VAR13, uint VAR18) isStartedOnly public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[VAR12] = VAR16[VAR12].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
VAR17[VAR12][msg.sender] = VAR17[VAR12][msg.sender].FUN3(VAR18);
emit Transfer(VAR12, VAR13, VAR18);
return true;
}
function FUN13(address VAR19) public view returns (uint VAR22) {
return VAR16[VAR19];
}
function FUN14(address VAR20, uint VAR23, uint VAR18) isStartedOnly public returns (bool VAR21) {
if(VAR17[msg.sender][VAR20] == VAR23){
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
} else {
return false;
}
}
function FUN15(address VAR20, uint VAR18) isStartedOnly public returns (bool VAR21) {
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
}
function FUN16(address VAR19, address VAR20) public view returns (uint VAR24) {
return VAR17[VAR19][VAR20];
}
}
contract Token is VAR25 {
using SafeMath for uint;
string public VAR26;
string public VAR27;
uint8 public VAR28;
constructor(string VAR29, string VAR30, uint8 VAR31) public {
VAR26 = VAR29;
VAR27 = VAR30;
VAR28 = VAR31;
}
function FUN17() public FUN5(VAR7) VAR32 {
VAR15 = true;
}
function FUN18(address VAR13, uint VAR33) public FUN5(VAR7) VAR32 returns(bool) {
VAR14 = VAR14.FUN4(VAR33);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR33);
emit Transfer(msg.sender, VAR13, VAR33);
return true;
}
function FUN19(address[] VAR34, uint[] VAR35) public FUN5(VAR7) isNotStartedOnly returns (uint) {
uint VAR36 = 0;
while (VAR36 < VAR34.VAR37) {
FUN18(VAR34[VAR36], VAR35[VAR36]);
VAR36 += 1;
}
return(VAR36);
}
}
contract TokenWithoutStart is VAR6 {
using SafeMath for uint;
mapping (address => uint) VAR16;
mapping (address => mapping (address => uint)) VAR17;
string public VAR26;
string public VAR27;
uint8 public VAR28;
uint public VAR14;
event Transfer(address indexed VAR12, address indexed VAR13, uint VAR18);
event FUN11(address indexed VAR19, address indexed VAR20, uint VAR18);
constructor(string VAR29, string VAR30, uint8 VAR31) public {
VAR26 = VAR29;
VAR27 = VAR30;
VAR28 = VAR31;
}
function transfer(address VAR13, uint VAR18) public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
emit Transfer(msg.sender, VAR13, VAR18);
return true;
}
function FUN12(address VAR12, address VAR13, uint VAR18) public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[VAR12] = VAR16[VAR12].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
VAR17[VAR12][msg.sender] = VAR17[VAR12][msg.sender].FUN3(VAR18);
emit Transfer(VAR12, VAR13, VAR18);
return true;
}
function FUN13(address VAR19) public view returns (uint VAR22) {
return VAR16[VAR19];
}
function FUN14(address VAR20, uint VAR23, uint VAR18) public returns (bool VAR21) {
if(VAR17[msg.sender][VAR20] == VAR23){
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
} else {
return false;
}
}
function FUN15(address VAR20, uint VAR18) public returns (bool VAR21) {
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
}
function FUN16(address VAR19, address VAR20) public view returns (uint VAR24) {
return VAR17[VAR19][VAR20];
}
function FUN18(address VAR13, uint VAR33) public FUN5(VAR7) returns(bool) {
VAR14 = VAR14.FUN4(VAR33);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR33);
emit Transfer(msg.sender, VAR13, VAR33);
return true;
}
function FUN19(address[] VAR34, uint[] VAR35) public FUN5(VAR7) returns (uint) {
uint VAR36 = 0;
while (VAR36 < VAR34.VAR37) {
FUN18(VAR34[VAR36], VAR35[VAR36]);
VAR36 += 1;
}
return(VAR36);
}
}
contract VAR38 {
string public VAR26;
address public VAR39;
address public VAR40;
Token public VAR41;
address public VAR42;
address public VAR43;
uint public VAR44;
struct VAR45 {
bool VAR46;
bool VAR47;
address VAR48;
}
mapping(uint => VAR45) public VAR49;
constructor(string VAR29, address VAR50, address VAR51, address VAR52, address VAR53, address VAR54) public {
VAR26 = VAR29;
VAR39 = VAR50;
VAR40 = VAR51;
VAR41 = FUN20(VAR52);
VAR43 = VAR53;
VAR42 = VAR54;
}
function FUN21() public {
VAR49[VAR44].VAR46 = true;
VAR49[VAR44].VAR48 = msg.sender;
}
function FUN22(address VAR55) public {
require(msg.sender == VAR39);
require(VAR49[VAR44].VAR48 == VAR55);
VAR44 +=1;
}
}
contract VAR45 {
using SafeMath for uint;
address public VAR56;
address public VAR39;
address public VAR57;
address public VAR42;
address public VAR40;
address public VAR43;
Token public VAR41;
address public VAR58;
bool public VAR59;
struct VAR60 {
uint VAR61;
uint VAR62;
uint VAR63;
uint VAR64;
uint VAR65;
string VAR66;
string VAR67;
}
VAR60[] public VAR68;
uint public VAR69;
uint public VAR70;
uint public VAR71;
uint public VAR72;
struct VAR73 {
bool VAR74;
uint VAR75;
uint VAR76;
uint VAR77;
uint VAR78;
bool VAR79;
bool VAR80;
uint VAR81;
}
struct VAR82 {
address VAR83;
uint VAR61;
uint VAR62;
bool VAR84;
}
mapping(address => VAR73) public VAR85;
address[] public VAR86;
mapping(address => mapping(uint => VAR82)) public VAR87;
uint[] public VAR88;
uint[] public VAR89;
uint public VAR90;
uint public VAR91;
uint public VAR92;
uint public VAR93;
uint public VAR94;
uint public VAR95;
uint public VAR96;
uint public VAR97;
uint public VAR98;
bool public VAR99;
uint public VAR100;
bool public VAR101;
mapping(address => uint[]) public VAR102;
mapping(address => uint[]) public VAR103;
struct VAR104 {
uint VAR63;
uint VAR105;
uint VAR98;
bool VAR106;
}
VAR104[] public VAR107;
mapping(uint => mapping(address => bool)) public VAR108;
modifier FUN23() {
require(msg.sender == VAR39 || msg.sender == VAR56);
VAR10;
}
modifier onlyAdmin() {
require(msg.sender == VAR39 || msg.sender == VAR56);
VAR10;
}
modifier FUN24() {
require(VAR70 != 0);
VAR10;
}
modifier FUN25() {
require(VAR70 == 0);
VAR10;
}
constructor( address VAR109,
address VAR50,
uint VAR110,
address VAR111,
uint[] VAR112,
uint[] VAR113,
uint VAR114,
uint VAR115
) public {
require(VAR112.VAR37 == VAR113.VAR37);
VAR56 = msg.sender;
VAR57 = VAR109;
VAR39 = VAR50;
VAR98 = VAR110;
VAR58 = VAR111;
VAR88 = VAR112;
VAR89 = VAR113;
VAR107.FUN26(FUN27(0,0,0,false));
VAR99 = true;
VAR90 = VAR114;
VAR91 = VAR115;
}
function FUN28(address VAR111) public {
require(msg.sender == VAR56);
VAR58 = VAR111;
}
function FUN29() onlyAdmin notSealed public {
ICO VAR116 = FUN30(VAR57);
require(VAR116.FUN31() == VAR39);
VAR42 = VAR116.FUN32();
VAR40 = VAR116.FUN33();
VAR43 = VAR116.FUN34();
VAR41 = VAR116.FUN35();
VAR116.FUN21();
}
function FUN36() public {
if (VAR101 == true) {
require(msg.sender.FUN37(VAR85[msg.sender].VAR77));
}
if (msg.sender == VAR39) {
require(VAR40.FUN37(VAR71+VAR72));
VAR71 = 0;
VAR72 = 0;
}
if (msg.sender == VAR42) {
require(VAR42.FUN37(VAR92));
require(VAR58.call.value(VAR93)(VAR117.FUN38("")));
VAR92 = 0;
VAR93 = 0;
}
if (VAR85[msg.sender].VAR80 == true) {
require(msg.sender.FUN37(VAR85[msg.sender].VAR77 - VAR85[msg.sender].VAR76));
}
}
function FUN39() public {
require(VAR41.transfer(msg.sender,VAR85[msg.sender].VAR75));
VAR85[msg.sender].VAR75 = 0;
}
function FUN40(uint VAR118,uint VAR119, uint VAR120, address[] VAR121) public VAR122 {
if (VAR121.VAR37 == 0) {
VAR107.FUN26(FUN27(VAR118, VAR119,VAR120,false));
} else {
for (uint VAR36=0 ; VAR36 < VAR121.VAR37 ; VAR36++ ) {
VAR108[VAR107.VAR37][VAR121[VAR36]] = true;
}
VAR107.FUN26(FUN27(VAR118, VAR119,VAR120,true));
}
}
function FUN41(uint VAR110) onlyOperator public {
VAR98 = VAR110;
}
function FUN42(uint VAR123) public VAR122 {
require(VAR107.VAR37 > VAR123);
VAR100 = VAR123;
VAR98 = VAR107[VAR123].VAR98;
}
function () public payable {
require(msg.value > 0);
if (VAR107[VAR100].VAR106 == true) {
require(VAR108[VAR100][msg.sender] == true);
}
uint VAR124 = VAR85[msg.sender].VAR81;
VAR87[msg.sender][VAR124].VAR83 = msg.sender;
VAR87[msg.sender][VAR124].VAR61 = msg.value;
VAR85[msg.sender].VAR81 += 1;
}
function FUN43(uint VAR125) public {
require(VAR87[msg.sender][VAR125].VAR84 == false);
require(msg.sender.FUN37(VAR87[msg.sender][VAR125].VAR61));
VAR87[msg.sender][VAR125].VAR61 = 0;
}
function FUN44(address VAR126) public {
require(msg.sender == VAR43);
VAR85[VAR126].VAR74 = true;
}
function FUN45(address VAR126, bool VAR127,uint VAR128) public {
require(msg.sender == VAR43);
require(VAR85[VAR126].VAR74 == true);
if (VAR127) {
VAR85[VAR126].VAR80 = true;
} else {
VAR85[VAR126].VAR79 = true;
for (uint VAR36 = VAR128; VAR36 < VAR69; VAR36++) {
VAR72 += VAR102[VAR126][VAR36];
VAR85[VAR126].VAR76 += VAR102[VAR126][VAR36];
}
}
VAR85[VAR126].VAR74 = false;
}
function FUN46(uint VAR129, uint VAR130, uint VAR118, uint VAR131, string VAR132) public notSealed VAR122 returns(uint) {
VAR94 = VAR94.FUN4(VAR129);
VAR95 = VAR95.FUN4(VAR130);
return VAR68.FUN26(FUN47(VAR129, VAR130, VAR118, 0, VAR131, VAR132, ""));
}
function FUN48(uint VAR133, uint VAR129, uint VAR130, uint VAR118, uint VAR131, string VAR132) public notSealed VAR122 {
assert(VAR133 < VAR68.VAR37);
VAR94 = (VAR94 - VAR68[VAR133].VAR61).FUN4(VAR129);
VAR95 = (VAR95 - VAR68[VAR133].VAR62).FUN4(VAR130);
VAR68[VAR133].VAR61 = VAR129;
VAR68[VAR133].VAR62 = VAR130;
VAR68[VAR133].VAR63 = VAR118;
VAR68[VAR133].VAR65 = VAR131;
VAR68[VAR133].VAR66 = VAR132;
}
function FUN49() public notSealed VAR122 {
require(VAR68.VAR37 > 0);
require(VAR41.FUN13(address(this)) >= VAR95);
VAR70 = VAR134;
}
function FUN50(address VAR126, uint VAR125) public sealed VAR122 {
require(VAR87[VAR126][VAR125].VAR61 > 0);
require(VAR87[VAR126][VAR125].VAR84 != true);
VAR87[VAR126][VAR125].VAR84 = true;
uint  VAR129 = VAR87[VAR126][VAR125].VAR61;
uint VAR130 = VAR87[VAR126][VAR125].VAR62;
require(VAR41.FUN13(address(this)) >= VAR96 + VAR130);
if (VAR90 > 0 || VAR91 > 0) {
uint VAR135 = VAR129.FUN1(VAR90).FUN2(100);
uint VAR136 = VAR129.FUN1(VAR91).FUN2(100);
VAR129 = VAR129.FUN3(VAR135).FUN3(VAR136);
VAR87[VAR126][VAR125].VAR61 = VAR129;
VAR92 += VAR135;
VAR93 += VAR136;
}
FUN51(VAR126, VAR129, VAR130);
if (!(VAR85[VAR126].VAR77 > 0)) VAR86.FUN26(VAR126);
if (VAR99 == true) {
VAR85[VAR126].VAR75 = VAR130;
}
VAR85[VAR126].VAR77 += VAR129;
VAR85[VAR126].VAR78 += VAR130;
VAR96 += VAR130;
VAR97 += VAR129;
}
function FUN52() public sealed VAR122 {
if (VAR69 != 0 ) {require(VAR68[VAR69-1].VAR64 > 0);}
for (uint VAR36=0; VAR36 < VAR86.VAR37 ; VAR36++) {
address VAR83 = VAR86[VAR36];
if (VAR85[VAR83].VAR74 == false) {
if (VAR85[VAR83].VAR80 != true) {
VAR71 += VAR102[VAR83][VAR69];
VAR85[VAR83].VAR76 += VAR102[VAR83][VAR69];
if (VAR99 == false) {
VAR85[VAR83].VAR75 += VAR103[VAR83][VAR69];
}
}
}
}
VAR68[VAR69].VAR63 = VAR134;
VAR69 +=1;
VAR71 = FUN53();
}
function FUN53() internal returns(uint) {
if (VAR88.VAR37 >= VAR69) {
uint VAR137 = VAR97.FUN1(VAR88[VAR69-1]).FUN2(100);
uint VAR136 = VAR97.FUN1(VAR89[VAR69-1]).FUN2(100);
VAR92 += VAR137;
VAR93 += VAR136;
return VAR71.FUN3(VAR137).FUN3(VAR136);
} else {
return VAR71;
}
}
function FUN54(string VAR138) public VAR122 {
require(VAR68[VAR69-1].VAR64 == 0);
uint VAR139 = VAR134 - VAR68[VAR69-1].VAR63;
require(VAR139 > 1 VAR140);
VAR68[VAR69-1].VAR64 = VAR134;
VAR68[VAR69-1].VAR67 = VAR138;
}
//
function FUN55() public onlyAdmin {
if (msg.sender == VAR39) {
VAR59 = true;
}
if (msg.sender == VAR56) {
require(VAR59 == true);
require(VAR56.FUN37(address(this).VAR22));
uint VAR141 = VAR41.FUN13(this);
require(VAR41.transfer(VAR56,VAR141));
}
}
function FUN56() public view returns(uint) {
return VAR68.VAR37;
}
function FUN51(address VAR126, uint VAR129, uint VAR130) internal {
uint VAR142;
uint VAR143;
uint VAR144;
uint VAR145;
uint VAR146;
uint VAR147;
for(uint VAR36=VAR69; VAR36<VAR68.VAR37; VAR36++) {
VAR144 = VAR68[VAR36].VAR61;
VAR145 = VAR68[VAR36].VAR62;
VAR142 = VAR129.FUN1(VAR144).FUN2(VAR94);
VAR143 = VAR130.FUN1(VAR145).FUN2(VAR95);
VAR146 = VAR146.FUN4(VAR142);
VAR147 = VAR147.FUN4(VAR143);
if (VAR85[VAR126].VAR77 > 0) {
VAR102[VAR126][VAR36] += VAR142;
VAR103[VAR126][VAR36] += VAR143;
} else {
VAR102[VAR126].FUN26(VAR142);
VAR103[VAR126].FUN26(VAR143);
}
}
VAR102[VAR126][VAR69] += VAR129 - VAR146;
VAR103[VAR126][VAR69] += VAR130 - VAR147;
}
function FUN57(address VAR126) public view returns(bool) {
return VAR85[VAR126].VAR74;
}
function FUN58(address VAR126) public view returns(bool) {
if (VAR85[VAR126].VAR77 > 0) return true;
else return false;
}
}
contract Arbitration is VAR6 {
address public VAR39;
uint public VAR148 = 3;
struct VAR149 {
address VAR48;
address VAR150;
bool VAR151;
uint VAR152;
uint VAR153;
string VAR154;
uint VAR155;
uint VAR156;
mapping(address => bool) VAR157;
}
mapping(uint => VAR149) public VAR158;
uint public VAR159;
mapping(address => mapping(address => bool)) public VAR160;
modifier FUN5(address VAR9) {
require(msg.sender == VAR9);
VAR10;
}
constructor() public {
VAR39 = msg.sender;
}
function FUN59(address VAR55, address[] VAR161) FUN5(VAR7) public {
for (uint VAR36 = 0; VAR36 < VAR161.VAR37 ; VAR36++) {
VAR160[VAR55][VAR161[VAR36]] = true;
}
}
function FUN60(uint VAR162, bool VAR163) public {
require(VAR158[VAR162].VAR151 == true);
require(VAR160[VAR158[VAR162].VAR48][msg.sender] == true);
require(VAR158[VAR162].VAR157[msg.sender] != true);
if (VAR163 == true) { VAR158[VAR162].VAR156 += 1; }
else { VAR158[VAR162].VAR155 += 1; }
if (VAR158[VAR162].VAR156 == VAR148) {
FUN61(VAR162,true);
}
if (VAR158[VAR162].VAR155 == VAR148) {
FUN61(VAR162,false);
}
VAR158[VAR162].VAR157[msg.sender] == true;
}
function FUN62(address VAR55, string VAR164) public {
Cycle VAR165 = FUN63(VAR55);
uint VAR166 = VAR165.FUN64();
require(VAR166 > 0);
require(VAR165.FUN58(msg.sender) == true);
VAR158[VAR159].VAR153 = VAR166;
VAR158[VAR159].VAR48 = VAR55;
VAR158[VAR159].VAR150 = msg.sender;
VAR158[VAR159].VAR152 = VAR134;
VAR158[VAR159].VAR154 = VAR164;
VAR158[VAR159].VAR151 = true;
VAR165.FUN44(msg.sender);
VAR159 +=1;
}
function FUN61(uint VAR162, bool VAR127) internal {
VAR158[VAR162].VAR151 = false;
uint VAR166 = VAR158[VAR162].VAR153;
Cycle VAR165 = FUN63(VAR158[VAR162].VAR48);
VAR165.FUN45(VAR158[VAR162].VAR150,VAR127,VAR166);
}
function FUN65(uint VAR167) public view returns(bool) {
return VAR158[VAR167].VAR151;
}
}
contract VAR168 {
Token public VAR41;
uint public VAR169 = 2443;
address public VAR7;
constructor(address VAR170) public {
VAR7 = msg.sender;
VAR41 = FUN20(VAR170);
}
function FUN66() public payable {
uint VAR171 = msg.value * VAR169;
require(VAR41.transfer(VAR7,VAR171));
}
function FUN67(uint VAR172) public {
require(msg.sender == VAR7);
VAR169 = VAR172;
}
}
contract VAR173 {
Token public VAR174;
Token public VAR41;
address public VAR7;
struct VAR175 {
address VAR12;
uint VAR33;
}
VAR175[] public VAR176;
constructor(address VAR52, address VAR177) public {
VAR7 = msg.sender;
VAR41 = FUN20(VAR52);
VAR174 = FUN20(VAR177);
}
function FUN66() public {
uint VAR178 = VAR174.FUN16(msg.sender,address(this));
require(VAR41.FUN13(address(this)) >= VAR178);
require(VAR41.transfer(msg.sender, VAR178));
require(VAR174.FUN12(msg.sender,address(this),VAR178));
VAR176.FUN26(FUN68(msg.sender,VAR178));
}
function FUN69() public {
uint VAR178 = VAR174.FUN16(msg.sender,address(this));
require(VAR174.FUN12(msg.sender,address(this),VAR178));
require(VAR174.transfer(msg.sender, VAR178));
}
}
1
---------------------------------
243 0xddf22a0bb30107e895236d4f9e0ade4750a12163.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
pragma VAR1 ^0.4.11;
contract VAR6 {
address public VAR7;
function FUN5(uint VAR8, string VAR9, string VAR10) payable returns (bytes32 VAR11);
function FUN6(uint VAR8, string VAR9, string VAR10, uint VAR12) payable returns (bytes32 VAR11);
function FUN7(uint VAR8, string VAR9, string VAR13, string VAR14) payable returns (bytes32 VAR11);
function FUN8(uint VAR8, string VAR9, string VAR13, string VAR14, uint VAR12) payable returns (bytes32 VAR11);
function FUN9(uint VAR8, string VAR9, bytes VAR15) payable returns (bytes32 VAR11);
function FUN10(uint VAR8, string VAR9, bytes VAR15, uint VAR12) payable returns (bytes32 VAR11);
function FUN11(string VAR9) returns (uint VAR16);
function FUN11(string VAR9, uint VAR17) returns (uint VAR16);
function FUN12(string VAR18);
function FUN13(byte VAR19);
function FUN14(bytes32 VAR20);
function FUN15(uint VAR21);
function FUN16() returns(bytes32);
}
contract VAR22 {
function FUN17() returns (address VAR23);
}
contract VAR24 {
uint constant VAR25 = 60*60*24;
uint constant VAR26 = 60*60*24*7;
uint constant VAR27 = 60*60*24*30;
byte constant VAR28 = 0x00;
byte constant VAR29 = 0x10;
byte constant VAR30 = 0x20;
byte constant VAR31 = 0x30;
byte constant VAR32 = 0xF0;
byte constant VAR33 = 0x01;
uint8 constant VAR34 = 0;
uint8 constant VAR35 = 1;
uint8 constant VAR36 = 2;
uint8 constant VAR37 = 2;
uint8 constant VAR38 = 161;
OraclizeAddrResolverI VAR39;
OraclizeI VAR40;
modifier VAR41 {
if((address(VAR39)==0)||(FUN18(address(VAR39))==0)) FUN19(VAR34);
VAR40 = FUN20(VAR39.FUN17());
VAR42;
}
modifier FUN21(string VAR43){
VAR40 = FUN20(VAR39.FUN17());
VAR40.FUN12(VAR43);
VAR42;
}
function FUN19(uint8 VAR44) internal returns(bool){
if (FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR39 = FUN22(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN23("");
return true;
}
if (FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR39 = FUN22(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN23("");
return true;
}
if (FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR39 = FUN22(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN23("");
return true;
}
if (FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR39 = FUN22(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN23("");
return true;
}
if (FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR39 = FUN22(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR39 = FUN22(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR39 = FUN22(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN24(bytes32 VAR45, string VAR46) {
FUN24(VAR45, VAR46, VAR47 bytes(0));
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) {
}
function FUN25(string VAR43) oraclizeAPI internal {
VAR40.FUN12(VAR43);
}
function FUN26(string VAR49) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49);
}
function FUN26(string VAR49, uint VAR17) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49, VAR17);
}
function FUN27(string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(0, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(VAR57, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(VAR57, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(0, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(0, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(VAR57, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(VAR57, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(0, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN30() oraclizeAPI internal returns (address){
return VAR40.FUN31();
}
function FUN32(byte VAR68) oraclizeAPI internal {
return VAR40.FUN13(VAR68);
}
function FUN33(uint VAR69) oraclizeAPI internal {
return VAR40.FUN15(VAR69);
}
function FUN34(bytes32 VAR70) oraclizeAPI internal {
return VAR40.FUN14(VAR70);
}
function FUN35() oraclizeAPI internal returns (bytes32){
return VAR40.FUN16();
}
function FUN18(address VAR23) constant internal returns(uint VAR71) {
VAR72 {
VAR71 := FUN36(VAR23)
}
}
function FUN37(string VAR73) internal returns (address){
bytes memory VAR74 = bytes(VAR73);
uint160 VAR75 = 0;
uint160 VAR76;
uint160 VAR77;
for (uint VAR78=2; VAR78<2+2*20; VAR78+=2){
VAR75 *= 256;
VAR76 = FUN38(VAR74[VAR78]);
VAR77 = FUN38(VAR74[VAR78+1]);
if ((VAR76 >= 97)&&(VAR76 <= 102)) VAR76 -= 87;
else if ((VAR76 >= 65)&&(VAR76 <= 70)) VAR76 -= 55;
else if ((VAR76 >= 48)&&(VAR76 <= 57)) VAR76 -= 48;
if ((VAR77 >= 97)&&(VAR77 <= 102)) VAR77 -= 87;
else if ((VAR77 >= 65)&&(VAR77 <= 70)) VAR77 -= 55;
else if ((VAR77 >= 48)&&(VAR77 <= 57)) VAR77 -= 48;
VAR75 += (VAR76*16+VAR77);
}
return address(VAR75);
}
function FUN39(string VAR73, string VAR79) internal returns (int) {
bytes memory VAR3 = bytes(VAR73);
bytes memory VAR4 = bytes(VAR79);
uint VAR80 = VAR3.VAR81;
if (VAR4.VAR81 < VAR80) VAR80 = VAR4.VAR81;
for (uint VAR78 = 0; VAR78 < VAR80; VAR78 ++)
if (VAR3[VAR78] < VAR4[VAR78])
return -1;
else if (VAR3[VAR78] > VAR4[VAR78])
return 1;
if (VAR3.VAR81 < VAR4.VAR81)
return -1;
else if (VAR3.VAR81 > VAR4.VAR81)
return 1;
else
return 0;
}
function FUN40(string VAR82, string VAR83) internal returns (int) {
bytes memory VAR84 = bytes(VAR82);
bytes memory VAR85 = bytes(VAR83);
if(VAR84.VAR81 < 1 || VAR85.VAR81 < 1 || (VAR85.VAR81 > VAR84.VAR81))
return -1;
else if(VAR84.VAR81 > (2**128 -1))
return -1;
else
{
uint VAR86 = 0;
for (uint VAR78 = 0; VAR78 < VAR84.VAR81; VAR78 ++)
{
if (VAR84[VAR78] == VAR85[0])
{
VAR86 = 1;
while(VAR86 < VAR85.VAR81 && (VAR78 + VAR86) < VAR84.VAR81 && VAR84[VAR78 + VAR86] == VAR85[VAR86])
{
VAR86++;
}
if(VAR86 == VAR85.VAR81)
return int(VAR78);
}
}
return -1;
}
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88, string VAR89) internal returns (string) {
bytes memory VAR90 = bytes(VAR73);
bytes memory VAR91 = bytes(VAR79);
bytes memory VAR92 = bytes(VAR87);
bytes memory VAR93 = bytes(VAR88);
bytes memory VAR94 = bytes(VAR89);
string memory VAR95 = VAR47 string(VAR90.VAR81 + VAR91.VAR81 + VAR92.VAR81 + VAR93.VAR81 + VAR94.VAR81);
bytes memory VAR96 = bytes(VAR95);
uint VAR97 = 0;
for (uint VAR78 = 0; VAR78 < VAR90.VAR81; VAR78++) VAR96[VAR97++] = VAR90[VAR78];
for (VAR78 = 0; VAR78 < VAR91.VAR81; VAR78++) VAR96[VAR97++] = VAR91[VAR78];
for (VAR78 = 0; VAR78 < VAR92.VAR81; VAR78++) VAR96[VAR97++] = VAR92[VAR78];
for (VAR78 = 0; VAR78 < VAR93.VAR81; VAR78++) VAR96[VAR97++] = VAR93[VAR78];
for (VAR78 = 0; VAR78 < VAR94.VAR81; VAR78++) VAR96[VAR97++] = VAR94[VAR78];
return string(VAR96);
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, VAR88, "");
}
function FUN41(string VAR73, string VAR79, string VAR87) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, "", "");
}
function FUN41(string VAR73, string VAR79) internal returns (string) {
return FUN41(VAR73, VAR79, "", "", "");
}
function FUN42(string VAR73) internal returns (uint) {
return FUN42(VAR73, 0);
}
function FUN42(string VAR73, uint VAR79) internal returns (uint) {
bytes memory VAR98 = bytes(VAR73);
uint VAR99 = 0;
bool VAR100 = false;
for (uint VAR78=0; VAR78<VAR98.VAR81; VAR78++){
if ((VAR98[VAR78] >= 48)&&(VAR98[VAR78] <= 57)){
if (VAR100){
if (VAR79 == 0) break;
else VAR79--;
}
VAR99 *= 10;
VAR99 += uint(VAR98[VAR78]) - 48;
} else if (VAR98[VAR78] == 46) VAR100 = true;
}
if (VAR79 > 0) VAR99 *= 10**VAR79;
return VAR99;
}
function FUN43(uint VAR78) internal returns (string){
if (VAR78 == 0) return "";
uint VAR101 = VAR78;
uint VAR102;
while (VAR101 != 0){
VAR102++;
VAR101 /= 10;
}
bytes memory VAR103 = VAR47 bytes(VAR102);
uint VAR97 = VAR102 - 1;
while (VAR78 != 0){
VAR103[VAR97--] = FUN44(48 + VAR78 % 10);
VAR78 /= 10;
}
return string(VAR103);
}
function FUN28(string[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
function FUN29(bytes[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
string VAR114;
function FUN23(string VAR115) internal {
VAR114 = VAR115;
}
function FUN45() internal returns (string) {
return VAR114;
}
function FUN46(uint VAR116, uint VAR117, uint VAR118) internal returns (bytes32){
if ((VAR117 == 0)||(VAR117 > 32)) throw;
bytes memory VAR119 = VAR47 bytes(1);
VAR119[0] = FUN44(VAR117);
bytes memory VAR120 = VAR47 bytes(32);
bytes memory VAR121 = VAR47 bytes(32);
bytes32 VAR122 = FUN35();
VAR72 {
FUN47(VAR120, 0x20)
FUN47(FUN4(VAR120, 0x20), FUN48(FUN49(FUN3(VAR123, 1)), FUN48(VAR124, VAR57)))
FUN47(VAR121, 0x20)
FUN47(FUN4(VAR121, 0x20), VAR122)
}
bytes[3] memory VAR64 = [VAR120, VAR119, VAR121];
bytes32 VAR125 = FUN27(VAR116, "", VAR64, VAR118);
FUN50(VAR125, FUN51(FUN52(VAR116), VAR64[1], FUN53(VAR64[0]), VAR64[2]));
return VAR125;
}
function FUN50(bytes32 VAR125, bytes32 VAR126) internal {
VAR127[VAR125] = VAR126;
}
mapping(bytes32=>bytes32) VAR127;
mapping(bytes32=>bool) VAR128;
function FUN54(bytes32 VAR129, bytes VAR130, bytes VAR131) internal returns (bool){
bool VAR132;
address VAR133;
bytes32 VAR134;
bytes32 VAR135;
bytes memory VAR136 = VAR47 bytes(32);
uint VAR137 = 4+(uint(VAR130[3]) - 0x20);
VAR136 = FUN55(VAR130, VAR137, 32, VAR136, 0);
bytes memory VAR138 = VAR47 bytes(32);
VAR137 += 32 + 2;
VAR138 = FUN55(VAR130, VAR137+(uint(VAR130[VAR137-1]) - 0x20), 32, VAR138, 0);
VAR72 {
VAR134 := FUN56(FUN4(VAR136, 32))
VAR135 := FUN56(FUN4(VAR138, 32))
}
(VAR132, VAR133) = FUN57(VAR129, 27, VAR134, VAR135);
if (address(FUN51(VAR131)) == VAR133) return true;
else {
(VAR132, VAR133) = FUN57(VAR129, 28, VAR134, VAR135);
return (address(FUN51(VAR131)) == VAR133);
}
}
function FUN58(bytes VAR48, uint VAR139) internal returns (bool) {
bool VAR132;
bytes memory VAR140 = VAR47 bytes(uint(VAR48[VAR139+1])+2);
FUN55(VAR48, VAR139, VAR140.VAR81, VAR140, 0);
bytes memory VAR141 = VAR47 bytes(64);
FUN55(VAR48, 3+1, 64, VAR141, 0);
bytes memory VAR142 = VAR47 bytes(1+65+32);
VAR142[0] = 1;
FUN55(VAR48, VAR139-65, 65, VAR142, 1);
bytes memory VAR143 = VAR144"";
FUN55(VAR143, 0, 32, VAR142, 1+65);
VAR132 = FUN54(FUN53(VAR142), VAR140, VAR141);
if (VAR132 == false) return false;
bytes memory VAR145 = VAR144"";
bytes memory VAR146 = VAR47 bytes(1+65);
VAR146[0] = 0xFE;
FUN55(VAR48, 3, 65, VAR146, 1);
bytes memory VAR147 = VAR47 bytes(uint(VAR48[3+65+1])+2);
FUN55(VAR48, 3+65, VAR147.VAR81, VAR147, 0);
VAR132 = FUN54(FUN53(VAR146), VAR147, VAR145);
return VAR132;
}
modifier FUN59(bytes32 VAR148, string VAR149, bytes VAR150) {
if ((VAR150[0] != "")||(VAR150[1] != "")||(VAR150[2] != 1)) throw;
bool VAR151 = FUN60(VAR150, VAR148, bytes(VAR149), FUN45());
if (VAR151 == false) throw;
VAR42;
}
function FUN61(bytes32 VAR152, bytes VAR153) internal returns (bool){
bool VAR154 = true;
for (var VAR78=0; VAR78<VAR153.VAR81; VAR78++){
if (VAR152[VAR78] != VAR153[VAR78]) VAR154 = false;
}
return VAR154;
}
function FUN60(bytes VAR48, bytes32 VAR125, bytes VAR46, string VAR155) internal returns (bool){
bool VAR156;
uint VAR157 = 3+65+(uint(VAR48[3+65+1])+2)+32;
bytes memory VAR158 = VAR47 bytes(32);
FUN55(VAR48, VAR157, 32, VAR158, 0);
VAR156 = (FUN51(VAR158) == FUN51(FUN53(VAR155, VAR125)));
if (VAR156 == false) return false;
bytes memory VAR159 = VAR47 bytes(uint(VAR48[VAR157+(32+8+1+32)+1])+2);
FUN55(VAR48, VAR157+(32+8+1+32), VAR159.VAR81, VAR159, 0);
VAR156 = FUN61(FUN53(VAR159), VAR46);
if (VAR156 == false) return false;
bytes memory VAR160 = VAR47 bytes(8+1+32);
FUN55(VAR48, VAR157+32, 8+1+32, VAR160, 0);
bytes memory VAR161 = VAR47 bytes(64);
uint VAR139 = VAR157+32+(8+1+32)+VAR159.VAR81+65;
FUN55(VAR48, VAR139-64, 64, VAR161, 0);
bytes32 VAR162 = FUN53(VAR161);
if (VAR127[VAR125] == FUN51(VAR160, VAR162)){
delete VAR127[VAR125];
} else return false;
bytes memory VAR163 = VAR47 bytes(32+8+1+32);
FUN55(VAR48, VAR157, 32+8+1+32, VAR163, 0);
VAR156 = FUN54(FUN53(VAR163), VAR159, VAR161);
if (VAR156 == false) return false;
if (VAR128[VAR162] == false){
VAR128[VAR162] = FUN58(VAR48, VAR139);
}
return VAR128[VAR162];
}
function FUN55(bytes VAR164, uint VAR165, uint VAR81, bytes VAR166, uint VAR167) internal returns (bytes) {
uint VAR80 = VAR81 + VAR167;
if (VAR166.VAR81 < VAR80) {
throw;
}
uint VAR78 = 32 + VAR165;
uint VAR101 = 32 + VAR167;
while (VAR78 < (32 + VAR165 + VAR81)) {
VAR72 {
let VAR74 := FUN56(FUN4(VAR164, VAR78))
FUN47(FUN4(VAR166, VAR101), VAR74)
}
VAR78 += 32;
VAR101 += 32;
}
return VAR166;
}
function FUN57(bytes32 VAR168, uint8 VAR169, bytes32 VAR170, bytes32 VAR171) internal returns (bool, address) {
bool VAR172;
address VAR173;
VAR72 {
let VAR174 := FUN56(0x40)
FUN47(VAR174, VAR168)
FUN47(FUN4(VAR174, 32), VAR169)
FUN47(FUN4(VAR174, 64), VAR170)
FUN47(FUN4(VAR174, 96), VAR171)
VAR172 := call(3000, 1, 0, VAR174, 128, VAR174, 32)
VAR173 := FUN56(VAR174)
}
return (VAR172, VAR173);
}
function FUN62(bytes32 VAR168, bytes VAR175) internal returns (bool, address) {
bytes32 VAR170;
bytes32 VAR171;
uint8 VAR169;
if (VAR175.VAR81 != 65)
return (false, 0);
VAR72 {
VAR170 := FUN56(FUN4(VAR175, 32))
VAR171 := FUN56(FUN4(VAR175, 64))
VAR169 := FUN44(0, FUN56(FUN4(VAR175, 96)))
}
//
if (VAR169 < 27)
VAR169 += 27;
if (VAR169 != 27 && VAR169 != 28)
return (false, 0);
return FUN57(VAR168, VAR169, VAR170, VAR171);
}
}
contract VAR176 {
function FUN63() external;
function FUN64() external payable;
}
contract Betting is VAR24 {
using SafeMath for uint256;
uint VAR177=3;
address public VAR178;
uint public VAR179;
string public constant VAR180 = "";
BettingControllerInterface internal VAR181;
struct VAR182 {
bool  VAR183;
bool  VAR184;
bool  VAR185;
bool  VAR186;
uint32  VAR187;
uint32  VAR188;
uint32  VAR189;
uint32 VAR190;
}
struct VAR191{
int64  VAR192;
int64  VAR193;
int64  VAR194;
bytes32 VAR195;
bytes32 VAR196;
bytes32 VAR197;
uint VAR198;
uint VAR199;
}
struct VAR200{
bytes32 VAR201;
uint VAR202;
}
struct VAR203{
uint256 VAR204;
uint256 VAR205;
uint160 VAR206;
uint32 VAR207;
bool VAR208;
bytes32 VAR209;
bytes32 VAR210;
}
struct VAR211 {
uint160 VAR212;
bool VAR213;
mapping(bytes32=>uint) VAR214;
}
mapping (bytes32 => bytes32) VAR215;
mapping (bytes32 => VAR203) VAR216;
mapping (address => VAR211) VAR217;
uint public VAR218;
uint32 VAR219;
mapping (bytes32 => bool) public VAR220;
event FUN65(string VAR221);
event FUN66(uint VAR52);
event FUN67(address VAR222, uint256 VAR223, bytes32 VAR224, uint256 VAR225);
event FUN68(address VAR226, uint256 VAR223);
function FUN69() public payable {
FUN32(VAR29 | VAR33);
VAR178 = msg.sender;
VAR227.VAR195 = bytes32("");
VAR227.VAR196 = bytes32("");
VAR227.VAR197 = bytes32("");
VAR227.VAR198 = 80000;
VAR227.VAR199 = 230000;
VAR181 = FUN70(VAR178);
}
horses_info public VAR227;
chronus_info public VAR228;
modifier onlyOwner {
require(VAR178 == msg.sender);
VAR42;
}
modifier VAR229 {
require(VAR228.VAR183);
VAR42;
}
modifier VAR230 {
require(!VAR228.VAR183 && !VAR228.VAR184);
VAR42;
}
modifier VAR231 {
require(VAR228.VAR185);
VAR42;
}
function FUN71(address VAR232) onlyOwner external {
VAR178 = VAR232;
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) public {
require (msg.sender == FUN30());
require (!VAR228.VAR185);
bytes32 VAR233;
VAR228.VAR184 = true;
VAR228.VAR183 = false;
VAR181.FUN63();
VAR233 = VAR215[VAR45];
if (VAR45 == VAR216[VAR233].VAR209) {
if (VAR216[VAR233].VAR204 > 0) {
} else if (VAR234 >= VAR228.VAR187+VAR228.VAR188+ 30 VAR235) {
FUN72();
} else {
VAR216[VAR233].VAR204 = FUN73(VAR46);
emit FUN66(VAR216[VAR233].VAR204);
}
} else if (VAR45 == VAR216[VAR233].VAR210){
if (VAR216[VAR233].VAR204 > 0 ){
if (VAR216[VAR233].VAR205 > 0) {
} else if (VAR234 >= VAR228.VAR187+VAR228.VAR189+ 30 VAR235) {
FUN72();
} else {
VAR216[VAR233].VAR205 = FUN73(VAR46);
VAR216[VAR233].VAR208 = true;
emit FUN66(VAR216[VAR233].VAR205);
if (VAR216[VAR227.VAR196].VAR208 && VAR216[VAR227.VAR195].VAR208 && VAR216[VAR227.VAR197].VAR208) {
FUN74();
}
}
} else {
FUN72();
}
}
}
function FUN75(bytes32 VAR201) external duringBetting payable  {
require(msg.value >= 0.01 VAR53);
if (VAR217[msg.sender].VAR212==0) {
VAR219+=1;
}
uint VAR236 = VAR217[msg.sender].VAR214[VAR201] + msg.value;
VAR217[msg.sender].VAR214[VAR201] = VAR236;
VAR217[msg.sender].VAR212 += FUN38(msg.value);
uint160 VAR237 = VAR216[VAR201].VAR206 + FUN38(msg.value);
uint32 VAR238 = VAR216[VAR201].VAR207 + 1;
VAR216[VAR201].VAR206 = VAR237;
VAR216[VAR201].VAR207 = VAR238;
emit FUN67(msg.sender, msg.value, VAR201, VAR234);
}
function () private payable {}
function FUN76(uint VAR239, uint  VAR240) onlyOwner beforeBetting public payable returns(bool) {
if (FUN26("" , VAR227.VAR198)*3 + FUN26("", VAR227.VAR199)*3  > address(this).VAR241) {
emit FUN65("");
return false;
} else {
VAR228.VAR187 = FUN77(VAR242.VAR57);
VAR228.VAR183 = true;
bytes32 VAR243;
emit FUN65("");
VAR228.VAR188 = FUN77(VAR239);
VAR243 = FUN27(VAR239, "", "FUN78(VAR244:
VAR215[VAR243] = VAR227.VAR196;
VAR216[VAR227.VAR196].VAR209 = VAR243;
VAR243 = FUN27(VAR239, "", "FUN78(VAR244:
VAR215[VAR243] = VAR227.VAR197;
VAR216[VAR227.VAR197].VAR209 = VAR243;
VAR243 = FUN27(VAR239, "", "FUN78(VAR244:
VAR215[VAR243] = VAR227.VAR195;
VAR216[VAR227.VAR195].VAR209 = VAR243;
VAR239 = VAR239.FUN4(VAR240);
VAR243 = FUN27(VAR239, "", "FUN78(VAR244:
VAR215[VAR243] = VAR227.VAR196;
VAR216[VAR227.VAR196].VAR210 = VAR243;
VAR243 = FUN27(VAR239, "", "FUN78(VAR244:
VAR215[VAR243] = VAR227.VAR197;
VAR216[VAR227.VAR197].VAR210 = VAR243;
VAR243 = FUN27(VAR239, "", "FUN78(VAR244:
VAR215[VAR243] = VAR227.VAR195;
VAR216[VAR227.VAR195].VAR210 = VAR243;
VAR228.VAR189 = FUN77(VAR239);
return true;
}
}
function FUN74() internal {
VAR227.VAR192 = FUN79(VAR216[VAR227.VAR195].VAR205 - VAR216[VAR227.VAR195].VAR204)*100000/FUN79(VAR216[VAR227.VAR195].VAR204);
VAR227.VAR193 = FUN79(VAR216[VAR227.VAR196].VAR205 - VAR216[VAR227.VAR196].VAR204)*100000/FUN79(VAR216[VAR227.VAR196].VAR204);
VAR227.VAR194 = FUN79(VAR216[VAR227.VAR197].VAR205 - VAR216[VAR227.VAR197].VAR204)*100000/FUN79(VAR216[VAR227.VAR197].VAR204);
VAR218 = (VAR216[VAR227.VAR195].VAR206) + (VAR216[VAR227.VAR196].VAR206) + (VAR216[VAR227.VAR197].VAR206);
if (VAR219 <= 1) {
FUN72();
} else {
uint VAR245 = VAR218.FUN1(5).FUN2(100);
require(VAR245 < address(this).VAR241);
VAR218 = VAR218.FUN3(VAR245);
VAR181.VAR246.value(VAR245)();
}
if (VAR227.VAR192 > VAR227.VAR193) {
if (VAR227.VAR192 > VAR227.VAR194) {
VAR220[VAR227.VAR195] = true;
VAR179 = VAR216[VAR227.VAR195].VAR206;
}
else if(VAR227.VAR194 > VAR227.VAR192) {
VAR220[VAR227.VAR197] = true;
VAR179 = VAR216[VAR227.VAR197].VAR206;
} else {
VAR220[VAR227.VAR195] = true;
VAR220[VAR227.VAR197] = true;
VAR179 = VAR216[VAR227.VAR195].VAR206 + (VAR216[VAR227.VAR197].VAR206);
}
} else if(VAR227.VAR193 > VAR227.VAR192) {
if (VAR227.VAR193 > VAR227.VAR194) {
VAR220[VAR227.VAR196] = true;
VAR179 = VAR216[VAR227.VAR196].VAR206;
}
else if (VAR227.VAR194 > VAR227.VAR193) {
VAR220[VAR227.VAR197] = true;
VAR179 = VAR216[VAR227.VAR197].VAR206;
} else {
VAR220[VAR227.VAR196] = true;
VAR220[VAR227.VAR197] = true;
VAR179 = VAR216[VAR227.VAR196].VAR206 + (VAR216[VAR227.VAR197].VAR206);
}
} else {
if (VAR227.VAR194 > VAR227.VAR193) {
VAR220[VAR227.VAR197] = true;
VAR179 = VAR216[VAR227.VAR197].VAR206;
} else if(VAR227.VAR194 < VAR227.VAR193){
VAR220[VAR227.VAR196] = true;
VAR220[VAR227.VAR195] = true;
VAR179 = VAR216[VAR227.VAR196].VAR206 + (VAR216[VAR227.VAR195].VAR206);
} else {
VAR220[VAR227.VAR197] = true;
VAR220[VAR227.VAR196] = true;
VAR220[VAR227.VAR195] = true;
VAR179 = VAR216[VAR227.VAR196].VAR206 + (VAR216[VAR227.VAR195].VAR206) + (VAR216[VAR227.VAR197].VAR206);
}
}
VAR228.VAR185 = true;
}
function FUN80(address VAR247) internal afterRace constant returns(uint VAR248) {
voter_info storage VAR249 = VAR217[VAR247];
if(VAR228.VAR186) {
VAR248 = VAR249.VAR212;
} else {
uint VAR250;
if(VAR220[VAR227.VAR195]) {
VAR250 += VAR249.VAR214[VAR227.VAR195];
} if(VAR220[VAR227.VAR196]) {
VAR250 += VAR249.VAR214[VAR227.VAR196];
} if(VAR220[VAR227.VAR197]) {
VAR250 += VAR249.VAR214[VAR227.VAR197];
}
VAR248 += (((VAR218.FUN1(10000000)).FUN2(VAR179)).FUN1(VAR250)).FUN2(10000000);
}
}
function FUN81() afterRace external constant returns (uint) {
require(!VAR217[msg.sender].VAR213);
return FUN80(msg.sender);
}
function FUN82() afterRace external {
require(!VAR217[msg.sender].VAR213);
uint VAR251 = FUN80(msg.sender);
require(address(this).VAR241 >= VAR251);
VAR217[msg.sender].VAR213 = true;
msg.sender.transfer(VAR251);
emit FUN68(msg.sender, VAR251);
}
function FUN72() internal {
VAR228.VAR186=true;
VAR228.VAR185 = true;
VAR228.VAR190=FUN77(VAR234);
}
function FUN73(string VAR171) internal pure returns (uint VAR46) {
uint VAR252 =2;
bool VAR253=false;
bytes memory VAR4 = bytes(VAR171);
uint VAR78;
VAR46 = 0;
for (VAR78 = 0; VAR78 < VAR4.VAR81; VAR78++) {
if (VAR253) {VAR252 = VAR252-1;}
if (uint(VAR4[VAR78]) == 46){VAR253 = true;}
uint VAR5 = uint(VAR4[VAR78]);
if (VAR5 >= 48 && VAR5 <= 57) {VAR46 = VAR46 * 10 + (VAR5 - 48);}
if (VAR253 && VAR252 == 0){return VAR46;}
}
while (VAR252!=0) {
VAR46 = VAR46*10;
VAR252=VAR252-1;
}
}
function FUN83(bytes32 VAR254, address VAR247) external constant returns (uint, uint, uint, bool, uint) {
return (VAR216[VAR254].VAR206, VAR216[VAR254].VAR204, VAR216[VAR254].VAR205, VAR216[VAR254].VAR208, VAR217[VAR247].VAR214[VAR254]);
}
function FUN84() external constant returns (uint) {
return ((VAR216[VAR227.VAR195].VAR206) + (VAR216[VAR227.VAR196].VAR206) + (VAR216[VAR227.VAR197].VAR206));
}
function FUN85() external onlyOwner {
require(VAR234 > VAR228.VAR187 + VAR228.VAR189);
require((VAR228.VAR183 && !VAR228.VAR184)
|| (VAR228.VAR184 && !VAR228.VAR185));
VAR228.VAR186 = true;
VAR228.VAR185 = true;
VAR228.VAR190=FUN77(VAR234);
VAR181.FUN63();
}
function FUN86() external onlyOwner{
require((VAR228.VAR185 && VAR234 > VAR228.VAR187 + VAR228.VAR189 + (30 VAR255))
|| (VAR228.VAR186 && VAR234 > VAR228.VAR190 + (30 VAR255)));
VAR181.VAR246.value(address(this).VAR241)();
}
}
1
---------------------------------
244 0xde39859237f5ff14926b194c3ef72e3213d3c665.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) pure internal returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) pure internal returns (uint) {
uint VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint VAR3, uint VAR4) pure internal returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint VAR3, uint VAR4) pure internal returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint64 VAR3, uint64 VAR4) pure internal returns (VAR6) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN6(uint64 VAR3, uint64 VAR4) pure internal returns (VAR6) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN7(uint256 VAR3, uint256 VAR4) pure internal returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN8(uint256 VAR3, uint256 VAR4) pure internal returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
contract VAR7 {
address public VAR8;
function FUN9() public {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR9;
}
function FUN10(address VAR10) public onlyOwner {
if (VAR10 != address(0)) {
VAR8 = VAR10;
}
}
}
interface VAR11 {
function FUN11() public view returns (uint VAR12);
function FUN12(address VAR13) public view returns (uint VAR14);
function transfer(address VAR15, uint VAR16) public;
function FUN13(address VAR17, address VAR15, uint VAR16) public;
function FUN14(address VAR18, uint VAR16) public;
function FUN15(address VAR13, address VAR18) public view returns (uint VAR19);
function FUN16() public view returns(uint VAR20);
event FUN17(address indexed VAR13, address indexed VAR18, uint VAR16);
}
contract VAR21 {
function FUN18(
ERC20 VAR22,
uint VAR23,
ERC20 VAR24,
address VAR25,
uint VAR26,
uint VAR27,
address VAR28
)
public
payable
returns(uint);
function FUN19(ERC20 VAR22, ERC20 VAR24, uint VAR29) public view returns(uint, uint);
}
interface VAR30 {
event FUN20( ERC20 VAR22, uint VAR23, ERC20 VAR24, uint VAR31);
function FUN18(
ERC20 VAR22,
uint VAR23,
ERC20 VAR24
)
public
payable
returns(uint);
function FUN21(ERC20 VAR22, ERC20 VAR24, uint VAR29) public view returns(uint, uint);
}
contract Dex is VAR7 {
event FUN20( ERC20 VAR22, uint VAR23, ERC20 VAR24, uint VAR31);
using SafeMath for uint256;
ERC20 public VAR32 = FUN22(0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);
address public VAR33 = 0x7ff0F1919424F0D2B6A109E3139ae0f1d836D468;
VAR30[] public VAR34;
function FUN23(uint256 VAR35, uint256 VAR23, ERC20 VAR24) private returns(uint256)  {
KULAPTradingProxy VAR36 = VAR34[VAR35];
uint256 VAR31 = VAR36.VAR37.value(VAR23)(
VAR32,
VAR23,
VAR24
);
return VAR31;
}
function () payable {
}
function FUN24(uint256 VAR35, ERC20 VAR22, uint256 VAR38) private returns(uint256)  {
KULAPTradingProxy VAR36 = VAR34[VAR35];
VAR22.FUN14(VAR36, VAR38);
uint256 VAR31 = VAR36.FUN18(
VAR22,
VAR38,
VAR32);
return VAR31;
}
//
function FUN25(uint256 VAR35, ERC20 VAR22, uint256 VAR23, ERC20 VAR24, uint256 VAR39) private returns(uint256)  {
uint256 VAR31;
if (VAR32 == VAR22) {
VAR31 = FUN23(VAR35, VAR23, VAR24);
} else if (VAR32 == VAR24) {
VAR31 = FUN24(VAR35, VAR22, VAR23);
} else {
}
assert(VAR31 >= VAR39);
return VAR31;
}
//
function FUN18(uint256 VAR35, ERC20 VAR22, uint256 VAR23, ERC20 VAR24, uint256 VAR39) payable public returns(uint256)  {
uint256 VAR31;
if (VAR32 == VAR22) {
VAR31 = FUN25(VAR35, VAR22, VAR23, VAR24, 1);
assert(VAR31 >= VAR39);
VAR24.transfer(msg.sender, VAR31);
} else if (VAR32 == VAR24) {
VAR22.FUN13(msg.sender, address(this), VAR23);
VAR31 = FUN25(VAR35, VAR22, VAR23, VAR24, 1);
assert(VAR31 >= VAR39);
msg.sender.FUN26(VAR31);
} else {
}
FUN20( VAR22, VAR23, VAR24, VAR31);
return VAR31;
}
//
function FUN27(ERC20 VAR22, uint256 VAR23, ERC20 VAR24, uint256 VAR39, address[] VAR40) payable public returns(uint256)  {
uint256 VAR31;
if (VAR32 != VAR22) {
VAR22.FUN13(msg.sender, address(this), VAR23);
}
uint256 VAR41 = VAR23;
for (uint VAR42=0; VAR42 < VAR40.VAR43; VAR42+=3) {
uint256 VAR35 =         uint256(VAR40[VAR42]);
ERC20 VAR44 =                     FUN22(VAR40[VAR42+1]);
ERC20 VAR45 =                    FUN22(VAR40[VAR42+2]);
VAR31 = FUN25(VAR35, VAR44, VAR41, VAR45, 1);
VAR41 = VAR31;
}
assert(VAR31 >= VAR39);
if (VAR32 == VAR24) {
msg.sender.FUN26(VAR31);
} else {
VAR24.transfer(msg.sender, VAR31);
}
FUN20( VAR22, VAR23, VAR24, VAR31);
return VAR31;
}
function FUN21(uint256 VAR35, ERC20 VAR22, ERC20 VAR24, uint VAR23) public view returns(uint, uint) {
KULAPTradingProxy VAR36 = VAR34[VAR35];
return VAR36.FUN21(VAR22, VAR24, VAR23);
}
function FUN28(
KULAPTradingProxy VAR46
) public onlyOwner returns (uint256) {
VAR34.FUN29( VAR46 );
return VAR34.VAR43;
}
}
1
---------------------------------
245 0xdec590f1e43fa30c43cb3ae71454ee20c1456940.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
uint constant VAR3 = 15;
uint constant VAR4 = 0.00045 VAR5;
uint constant VAR6 = 0.1 VAR5;
uint constant VAR7 = 1000;
uint constant VAR8 = 0.001 VAR5;
uint constant VAR9 = 0.01 VAR5;
uint constant VAR10 = 300000 VAR5;
uint constant VAR11 = 100;
//
uint constant VAR12 = 40;
uint constant VAR13 = 2 ** VAR12;
uint constant VAR14 = 250;
address constant VAR15 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public VAR16;
address private VAR17;
uint public VAR18;
address public VAR19;
uint128 public VAR20;
uint128 public VAR21;
address public VAR22 = 0xAdD148Cc4F7B1b7520325a7C5934C002420Ab3d5;
struct VAR23 {
uint VAR24;
uint8 VAR25;
uint8 VAR26;
uint40 VAR27;
uint40 VAR28;
address VAR29;
}
mapping (uint => VAR23) VAR30;
address public VAR31;
event FUN1(address indexed VAR32, uint VAR24);
event FUN2(address indexed VAR32, uint VAR24);
event FUN3(address indexed VAR32, uint VAR24);
event FUN4(uint VAR33);
constructor () public {
VAR16 = msg.sender;
VAR19 = VAR15;
VAR31 = VAR15;
}
modifier onlyOwner {
require (msg.sender == VAR16, "");
VAR34;
}
modifier VAR35 {
require (msg.sender == VAR31, "");
VAR34;
}
function FUN5(address VAR36) external onlyOwner {
require (VAR36 != VAR16, "");
VAR17 = VAR36;
}
function FUN6() external {
require (msg.sender == VAR17, "");
VAR16 = VAR17;
}
function () public payable {
}
function FUN7(address VAR37) external onlyOwner {
VAR19 = VAR37;
}
function FUN8(address VAR38) external onlyOwner {
VAR31 = VAR38;
}
function FUN9(uint VAR39) public onlyOwner {
require (VAR39 < VAR10, "");
VAR18 = VAR39;
}
function FUN10(uint VAR40) external onlyOwner {
require (VAR40 <= address(this).VAR41, "");
require (VAR20 + VAR21 + VAR40 <= address(this).VAR41, "");
VAR20 += uint128(VAR40);
}
function FUN11(uint VAR42) external onlyOwner {
require (VAR42 <= address(this).VAR41, "");
require (VAR20 + VAR21 + VAR42 <= address(this).VAR41, "");
FUN12(VAR22, VAR42, VAR42);
}
function FUN13() external onlyOwner {
require (VAR21 == 0, "");
FUN14(VAR22);
}
//
//
//
function FUN15(uint VAR43, uint VAR25, uint VAR44, uint VAR33, bytes32 VAR45, bytes32 VAR46) external payable {
Bet storage VAR47 = VAR30[VAR33];
require (VAR47.VAR29 == address(0), "");
uint VAR24 = msg.value;
require (VAR25 > 1 && VAR25 <= VAR11, "");
require (VAR24 >= VAR9 && VAR24 <= VAR10, "");
require (VAR43 > 0 && VAR43 < VAR13, "");
require (VAR48.VAR49 <= VAR44, "");
bytes32 VAR50 = FUN16(VAR51.FUN17(FUN18(VAR44), VAR33));
require (VAR19 == FUN19(VAR50, 27, VAR45, VAR46), "");
uint VAR26;
uint VAR28;
if (VAR25 <= VAR12) {
VAR26 = ((VAR43 * VAR52) & VAR53) % VAR54;
VAR28 = VAR43;
} else {
require (VAR43 > 0 && VAR43 <= VAR25, "");
VAR26 = VAR43;
}
uint VAR55;
uint VAR56;
(VAR55, VAR56) = FUN20(VAR24, VAR25, VAR26);
require (VAR55 <= VAR24 + VAR18, "");
VAR21 += uint128(VAR55);
VAR20 += uint128(VAR56);
require (VAR20 + VAR21 <= address(this).VAR41, "");
emit FUN4(VAR33);
VAR47.VAR24 = VAR24;
VAR47.VAR25 = uint8(VAR25);
VAR47.VAR26 = uint8(VAR26);
VAR47.VAR27 = FUN18(VAR48.VAR49);
VAR47.VAR28 = FUN18(VAR28);
VAR47.VAR29 = msg.sender;
}
function FUN21(uint VAR57, bytes32 VAR58) external VAR35 {
uint VAR33 = uint(FUN16(VAR51.FUN17(VAR57)));
Bet storage VAR47 = VAR30[VAR33];
uint VAR27 = VAR47.VAR27;
require (VAR48.VAR49 > VAR27, "");
require (VAR48.VAR49 <= VAR27 + VAR14, "");
require (FUN22(VAR27) == VAR58);
FUN23(VAR47, VAR57, VAR58);
}
function FUN24(uint VAR57, uint40 VAR59) external VAR35 {
uint VAR33 = uint(FUN16(VAR51.FUN17(VAR57)));
Bet storage VAR47 = VAR30[VAR33];
require (VAR48.VAR49 <= VAR59 + VAR14, "");
FUN25(4 + 32 + 32 + 4);
bytes32 VAR60;
bytes32 VAR61;
(VAR60, VAR61) = FUN26(VAR33, 4 + 32 + 32);
require (FUN22(VAR59) == VAR60);
FUN23(VAR47, VAR57, VAR61);
}
function FUN23(Bet storage VAR47, uint VAR57, bytes32 VAR62) private {
uint VAR24 = VAR47.VAR24;
uint VAR25 = VAR47.VAR25;
uint VAR26 = VAR47.VAR26;
address VAR29 = VAR47.VAR29;
require (VAR24 != 0, "");
VAR47.VAR24 = 0;
bytes32 VAR63 = FUN16(VAR51.FUN17(VAR57, VAR62));
uint VAR64 = uint(VAR63) % VAR25;
uint VAR65;
uint VAR66;
(VAR65, VAR66) = FUN20(VAR24, VAR25, VAR26);
uint VAR67 = 0;
uint VAR68 = 0;
if (VAR25 <= VAR12) {
if ((2 ** VAR64) & VAR47.VAR28 != 0) {
VAR67 = VAR65;
}
} else {
if (VAR64 < VAR26) {
VAR67 = VAR65;
}
}
VAR21 -= uint128(VAR65);
if (VAR24 >= VAR6) {
uint VAR69 = (uint(VAR63) / VAR25) % VAR7;
if (VAR69 == 0) {
VAR68 = VAR20;
VAR20 = 0;
}
}
if (VAR68 > 0) {
emit FUN3(VAR29, VAR68);
}
FUN12(VAR29, VAR67 + VAR68 == 0 ? 1 VAR70 : VAR67 + VAR68, VAR67);
}
function FUN27(uint VAR33) external {
Bet storage VAR47 = VAR30[VAR33];
uint VAR24 = VAR47.VAR24;
require (VAR24 != 0, "");
require (VAR48.VAR49 > VAR47.VAR27 + VAR14, "");
VAR47.VAR24 = 0;
uint VAR65;
uint VAR56;
(VAR65, VAR56) = FUN20(VAR24, VAR47.VAR25, VAR47.VAR26);
VAR21 -= uint128(VAR65);
VAR20 -= uint128(VAR56);
FUN12(VAR47.VAR29, VAR24, VAR24);
}
function FUN20(uint VAR24, uint VAR25, uint VAR26) private pure returns (uint VAR71, uint VAR56) {
require (0 < VAR26 && VAR26 <= VAR25, "");
VAR56 = VAR24 >= VAR6 ? VAR8 : 0;
uint VAR72 = VAR24 * VAR3 / 1000;
if (VAR72 < VAR4) {
VAR72 = VAR4;
}
require (VAR72 + VAR56 <= VAR24, "");
VAR71 = (VAR24 - VAR72 - VAR56) * VAR25 / VAR26;
}
function FUN12(address VAR32, uint VAR24, uint VAR73) private {
if (VAR32.call.value(VAR24)()) {
emit FUN2(VAR32, VAR73);
} else {
emit FUN1(VAR32, VAR24);
}
}
uint constant VAR52 = 0x0000000000002000000000100000000008000000000400000000020000000001;
uint constant VAR53 = 0x0001041041041041041041041041041041041041041041041041041041041041;
uint constant VAR54 = 0x3F;
function FUN26(uint VAR74, uint VAR75) pure private returns (bytes32 VAR58, bytes32 VAR61) {
uint VAR76;  VAR77 { VAR76 := FUN28(0x40) }
uint VAR78; uint VAR79; uint VAR80; uint VAR81;
for (;; VAR75 += VAR79) {
VAR77 { VAR79 := FUN29(FUN30(FUN31(VAR75, 30)), 0xffff) }
if (VAR79 == 0) {
break;
}
VAR77 { VAR80 := FUN29(FUN30(FUN31(VAR75, 28)), 0xffff) }
require (VAR80 + 32 <= VAR79, "");
VAR75 += 4;
VAR77 { VAR81 := FUN30(FUN32(VAR75, VAR80)) }
require (VAR81 == 0, "");
VAR77 {
FUN33(VAR76, VAR75, VAR79)
FUN34(FUN32(VAR76, VAR80), VAR74)
VAR74 := FUN35(VAR76, VAR79)
VAR78 := VAR79
}
}
VAR61 = bytes32(VAR74);
uint VAR82 = VAR76 + VAR78;
uint VAR83; VAR77 { VAR83 := FUN29(FUN30(FUN31(VAR75, 28)), 0xffff) }
uint VAR84;  VAR77 { VAR84 := FUN29(FUN30(FUN31(VAR75, 26)), 0xffff) }
require (VAR84 + VAR78 <= VAR83, "");
VAR75 += 6;
VAR77 { FUN33(VAR82, VAR75, VAR83) }
FUN36(VAR82 + VAR84, VAR76, VAR78);
VAR77 { VAR74 := FUN35(VAR82, VAR83) }
VAR75 += VAR83;
VAR77 {
VAR79 := FUN29(FUN30(FUN31(VAR75, 30)), 0xffff)
VAR80 := FUN29(FUN30(FUN31(VAR75, 28)), 0xffff)
}
require (VAR80 + 32 <= VAR79, "");
VAR75 += 4;
VAR77 { VAR81 := FUN30(FUN32(VAR75, VAR80)) }
require (VAR81 == 0, "");
VAR77 {
FUN33(VAR76, VAR75, VAR79)
FUN34(FUN32(VAR76, VAR80), VAR74)
VAR58 := FUN35(VAR76, VAR79)
}
}
function FUN25(uint VAR75) view private {
uint VAR85; VAR77 { VAR85 := FUN37(0, FUN30(VAR75)) }
require (VAR85 >= 0xf7, "");
VAR75 += VAR85 - 0xf6;
uint VAR86; VAR77 { VAR86 := FUN37(0, FUN30(VAR75)) }
if (VAR86 <= 0x7f) {
VAR75 += 1;
} else {
require (VAR86 >= 0x80 && VAR86 <= 0xb7, "");
VAR75 += VAR86 - 0x7f;
}
uint VAR87; VAR77 { VAR87 := FUN37(0, FUN30(VAR75)) }
require (VAR87 == 0xb9, "");
VAR75 += 3;
uint VAR88; VAR77 { VAR88 := FUN37(0, FUN30(VAR75)) }
require (VAR88 == 0xf9, "");
VAR75 += 3;
uint VAR89; VAR77 { VAR89 := FUN37(0, FUN30(VAR75)) }
require (VAR89 == 0x1, "");
VAR75 += 1;
uint VAR90; VAR77 { VAR90 := FUN37(0, FUN30(VAR75)) }
if (VAR90 <= 0x7f) {
VAR75 += 1;
} else {
require (VAR90 >= 0x80 && VAR90 <= 0xb7, "");
VAR75 += VAR90 - 0x7f;
}
uint VAR91; VAR77 { VAR91 := FUN37(0, FUN30(VAR75)) }
require (VAR91 == 0xb9, "");
VAR75 += 256 + 3;
uint VAR92; VAR77 { VAR92 := FUN37(0, FUN30(VAR75)) }
require (VAR92 == 0xf8, "");
VAR75 += 2;
uint VAR93; VAR77 { VAR93 := FUN37(0, FUN30(VAR75)) }
require (VAR93 == 0xf8, "");
VAR75 += 2;
uint VAR94; VAR77 { VAR94 := FUN37(0, FUN30(VAR75)) }
require (VAR94 == 0x94, "");
uint VAR95; VAR77 { VAR95 := FUN29(FUN30(FUN31(VAR75, 11)), 0xffffffffffffffffffffffffffffffffffffffff) }
require (VAR95 == uint(address(this)));
}
function FUN36(uint VAR96, uint VAR97, uint VAR98) pure private {
for(; VAR98 >= 32; VAR98 -= 32) {
VAR77 { FUN34(VAR96, FUN28(VAR97)) }
VAR96 += 32; VAR97 += 32;
}
uint VAR28 = 256 ** (32 - VAR98) - 1;
VAR77 {
let VAR99 := FUN29(FUN28(VAR97), FUN38(VAR28))
let VAR100 := FUN29(FUN28(VAR96), VAR28)
FUN34(VAR96, or(VAR100, VAR99))
}
}
}
1
---------------------------------
246 0xdf4b83a451ef20b925ce39f4da2a021722688370.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 1 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
247 0xdf6767a7715381867738cf211290f61697ecd938.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
contract BaseModule is VAR2 {
ModuleRegistry internal VAR6;
event FUN4(bytes32 VAR7);
event FUN5(address VAR8);
constructor(ModuleRegistry VAR9, bytes32 VAR10) public {
VAR6 = VAR9;
emit FUN4(VAR10);
}
modifier FUN6(BaseWallet VAR3) {
require(msg.sender == address(VAR3), "");
VAR11;
}
modifier onlyOwner(BaseWallet VAR3) {
require(msg.sender == address(this) || FUN7(VAR3, msg.sender), "");
VAR11;
}
modifier FUN8(BaseWallet VAR3) {
require(FUN7(VAR3, msg.sender), "");
VAR11;
}
function FUN1(BaseWallet VAR3) external FUN6(VAR3) {
emit FUN5(VAR3);
}
function FUN2(BaseWallet VAR3, Module VAR4) external FUN8(VAR3) {
require(VAR6.FUN9(VAR4), "");
VAR3.FUN10(VAR4, true);
}
function FUN3(address VAR5) external {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(address(VAR6), VAR12);
}
function FUN7(BaseWallet VAR3, address VAR13) internal view returns (bool) {
return VAR3.FUN13() == VAR13;
}
}
contract RelayerModule is VAR2 {
uint256 constant internal VAR14 = 10000;
mapping (address => VAR15) public VAR16;
struct VAR15 {
uint256 VAR17;
mapping (bytes32 => bool) VAR18;
}
event FUN14(address indexed VAR8, bool indexed VAR19, bytes32 VAR20);
modifier VAR21 {
require(msg.sender == address(this), "");
VAR11;
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256);
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool);
function FUN17(
BaseWallet VAR3,
bytes VAR22,
uint256 VAR25,
bytes VAR24,
uint256 VAR26,
uint256 VAR27
)
external
returns (bool VAR19)
{
uint VAR28 = FUN18();
bytes32 VAR29 = FUN19(address(this), VAR3, 0, VAR22, VAR25, VAR26, VAR27);
require(FUN20(VAR3, VAR25, VAR29), "");
require(FUN21(address(VAR3), VAR22), "");
uint256 VAR30 = FUN15(VAR3, VAR22);
if((VAR30 * 65) == VAR24.VAR31) {
if(FUN22(VAR3, VAR27, VAR26, VAR30)) {
if(VAR30 == 0 || FUN16(VAR3, VAR22, VAR29, VAR24)) {
VAR19 = address(this).call(VAR22);
FUN23(VAR3, VAR28 - FUN18(), VAR26, VAR27, VAR30, msg.sender);
}
}
}
emit FUN14(VAR3, VAR19, VAR29);
}
function FUN24(BaseWallet VAR3) external view returns (uint256 VAR17) {
return VAR16[VAR3].VAR17;
}
function FUN19(
address VAR32,
address VAR33,
uint256 VAR34,
bytes VAR22,
uint256 VAR25,
uint256 VAR26,
uint256 VAR27
)
internal
pure
returns (bytes32)
{
return FUN25(
VAR35.FUN26(
"",
FUN25(VAR35.FUN26(FUN27(0x19), FUN27(0), VAR32, VAR33, VAR34, VAR22, VAR25, VAR26, VAR27))
));
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
if(VAR16[VAR3].VAR18[VAR23] == true) {
return false;
}
VAR16[VAR3].VAR18[VAR23] = true;
return true;
}
function FUN28(BaseWallet VAR3, uint256 VAR25) internal returns (bool) {
if(VAR25 <= VAR16[VAR3].VAR17) {
return false;
}
uint256 VAR36 = (VAR25 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;
if(VAR36 > VAR37.VAR38 + VAR14) {
return false;
}
VAR16[VAR3].VAR17 = VAR25;
return true;
}
function FUN29(bytes32 VAR39, bytes VAR24, uint VAR40) internal pure returns (address) {
uint8 VAR41;
bytes32 VAR42;
bytes32 VAR43;
VAR44 {
VAR42 := FUN30(FUN31(VAR24, FUN31(0x20,FUN32(0x41,VAR40))))
VAR43 := FUN30(FUN31(VAR24, FUN31(0x40,FUN32(0x41,VAR40))))
VAR41 := FUN33(FUN30(FUN31(VAR24, FUN31(0x41,FUN32(0x41,VAR40)))), 0xff)
}
require(VAR41 == 27 || VAR41 == 28);
return FUN34(VAR39, VAR41, VAR42, VAR43);
}
function FUN23(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR27, uint VAR24, address VAR46) internal {
uint256 VAR47 = 29292 + VAR45;
if(VAR26 > 0 && VAR24 > 1 && VAR47 <= VAR27) {
if(VAR26 > VAR48.VAR49) {
VAR47 = VAR47 * VAR48.VAR49;
}
else {
VAR47 = VAR47 * VAR26;
}
VAR3.FUN35(VAR46, VAR47, "");
}
}
function FUN22(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR24) internal view returns (bool) {
if(VAR26 > 0
&& VAR24 > 1
&& (address(VAR3).VAR50 < VAR45 * VAR26 || VAR3.FUN36(this) == false)) {
return false;
}
return true;
}
function FUN21(address VAR3, bytes VAR22) private pure returns (bool) {
require(VAR22.VAR31 >= 36, "");
address VAR51;
VAR44 {
VAR51 := FUN30(FUN31(VAR22, 0x24))
}
return VAR51 == VAR3;
}
function FUN37(bytes VAR22) internal pure returns (bytes4 VAR52) {
require(VAR22.VAR31 >= 4, "");
VAR44 {
VAR52 := FUN30(FUN31(VAR22, 0x20))
}
}
}
contract LimitManager is VAR53 {
uint128 constant internal VAR54 = uint128(-1);
using SafeMath for uint256;
struct VAR55 {
Limit VAR56;
DailySpent VAR57;
}
struct VAR58 {
uint128 VAR59;
uint128 VAR60;
uint64 VAR61;
}
struct VAR62 {
uint128 VAR63;
uint64 VAR64;
}
mapping (address => VAR55) internal VAR65;
uint256 public VAR66;
event FUN38(address indexed VAR8, uint indexed VAR67, uint64 indexed VAR68);
constructor(uint256 VAR69) public {
VAR66 = VAR69;
}
function FUN1(BaseWallet VAR3) external FUN6(VAR3) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
if(VAR56.VAR59 == 0 && VAR56.VAR61 == 0) {
VAR56.VAR59 = uint128(VAR66);
}
}
function FUN39(BaseWallet VAR3, uint256 VAR70, uint256 VAR71) internal {
Limit storage VAR56 = VAR65[VAR3].VAR56;
uint128 VAR72 = (VAR56.VAR61 > 0 && VAR56.VAR61 < VAR73) ? VAR56.VAR60 : VAR56.VAR59;
VAR56.VAR59 = VAR72;
VAR56.VAR60 = uint128(VAR70);
VAR56.VAR61 = FUN40(VAR73.FUN31(VAR71));
emit FUN38(VAR3, VAR70, FUN40(VAR73.FUN31(VAR71)));
}
function FUN41(BaseWallet VAR3) public view returns (uint256 VAR74) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
VAR74 = uint256(FUN42(VAR56.VAR59, VAR56.VAR60, VAR56.VAR61));
}
function FUN43(BaseWallet VAR3) external view returns (uint256 VAR75, uint64 VAR76) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
return ((VAR73 < VAR56.VAR61)? (uint256(VAR56.VAR60), VAR56.VAR61) : (0,0));
}
function FUN44(BaseWallet VAR3) external view returns (uint256 VAR77, uint64 VAR78) {
uint256 VAR79 = FUN41(VAR3);
DailySpent storage VAR80 = VAR65[VAR3].VAR57;
if(VAR73 > VAR80.VAR64) {
VAR77 = VAR79;
VAR78 = FUN40(VAR73 + 24 VAR81);
}
else {
VAR77 = VAR79 - VAR80.VAR63;
VAR78 = VAR80.VAR64;
}
}
function FUN45(BaseWallet VAR3, uint VAR82) internal returns (bool) {
Limit storage VAR56 = VAR65[VAR3].VAR56;
uint128 VAR59 = FUN42(VAR56.VAR59, VAR56.VAR60, VAR56.VAR61);
if(FUN46(VAR3, VAR59, VAR82)) {
FUN47(VAR3, VAR59, VAR82);
return true;
}
return false;
}
function FUN47(BaseWallet VAR3, uint128 VAR83, uint VAR82) internal {
if(VAR83 != VAR54) {
DailySpent storage VAR80 = VAR65[VAR3].VAR57;
if (VAR80.VAR64 < VAR73) {
VAR80.VAR64 = FUN40(VAR73 + 24 VAR81);
VAR80.VAR63 = uint128(VAR82);
}
else {
VAR80.VAR63 += uint128(VAR82);
}
}
}
function FUN46(BaseWallet VAR3, uint VAR83, uint VAR82) internal view returns (bool)  {
DailySpent storage VAR80 = VAR65[VAR3].VAR57;
if(VAR83 == VAR54) {
return true;
}
else if (VAR80.VAR64 < VAR73) {
return (VAR82 <= VAR83);
} else {
return (VAR80.VAR63 + VAR82 <= VAR83 && VAR80.VAR63 + VAR82 >= VAR80.VAR63);
}
}
function FUN42(uint128 VAR84, uint128 VAR85, uint64 VAR76) internal view returns (uint128) {
if(VAR76 > 0 && VAR76 < VAR73) {
return VAR85;
}
return VAR84;
}
}
contract VAR86 {
function FUN48() public view returns (uint);
function FUN49() public view returns (uint);
function FUN12(address VAR87) public view returns (uint VAR50);
function FUN50(address VAR87, address VAR88) public view returns (uint VAR89);
function transfer(address VAR90, uint VAR91) public returns (bool VAR19);
function FUN51(address VAR88, uint VAR91) public returns (bool VAR19);
function FUN52(address VAR92, address VAR90, uint VAR91) public returns (bool VAR19);
}
library VAR93 {
function FUN32(uint256 VAR94, uint256 VAR95) internal pure returns (uint256) {
if (VAR94 == 0) {
return 0;
}
uint256 VAR96 = VAR94 * VAR95;
require(VAR96 / VAR94 == VAR95);
return VAR96;
}
function FUN53(uint256 VAR94, uint256 VAR95) internal pure returns (uint256) {
require(VAR95 > 0);
uint256 VAR96 = VAR94 / VAR95;
return VAR96;
}
function FUN54(uint256 VAR94, uint256 VAR95) internal pure returns (uint256) {
require(VAR95 <= VAR94);
uint256 VAR96 = VAR94 - VAR95;
return VAR96;
}
function FUN31(uint256 VAR94, uint256 VAR95) internal pure returns (uint256) {
uint256 VAR96 = VAR94 + VAR95;
require(VAR96 >= VAR94);
return VAR96;
}
function FUN55(uint256 VAR94, uint256 VAR95) internal pure returns (uint256) {
require(VAR95 != 0);
return VAR94 % VAR95;
}
function FUN56(uint256 VAR94, uint256 VAR95) internal pure returns (uint256) {
uint256 VAR96 = VAR94 / VAR95;
if(VAR94 % VAR95 == 0) {
return VAR96;
}
else {
return VAR96 + 1;
}
}
}
contract VAR97 {
address public VAR98;
event FUN57(address indexed VAR99);
modifier onlyOwner {
require(msg.sender == VAR98, "");
VAR11;
}
constructor() public {
VAR98 = msg.sender;
}
function FUN58(address VAR99) external onlyOwner {
require(VAR99 != address(0), "");
VAR98 = VAR99;
emit FUN57(VAR99);
}
}
contract ModuleRegistry is VAR97 {
mapping (address => VAR100) internal VAR101;
mapping (address => VAR100) internal VAR102;
event FUN59(address indexed VAR103, bytes32 VAR7);
event FUN60(address VAR103);
event FUN61(address indexed VAR104, bytes32 VAR7);
event FUN62(address VAR104);
struct VAR100 {
bool VAR105;
bytes32 VAR7;
}
function FUN63(address VAR4, bytes32 VAR10) external onlyOwner {
require(!VAR101[VAR4].VAR105, "");
VAR101[VAR4] = FUN64({VAR105: true, VAR7: VAR10});
emit FUN59(VAR4, VAR10);
}
function FUN65(address VAR4) external onlyOwner {
require(VAR101[VAR4].VAR105, "");
delete VAR101[VAR4];
emit FUN60(VAR4);
}
function FUN66(address VAR106, bytes32 VAR10) external onlyOwner {
require(!VAR102[VAR106].VAR105, "");
VAR102[VAR106] = FUN64({VAR105: true, VAR7: VAR10});
emit FUN61(VAR106, VAR10);
}
function FUN67(address VAR106) external onlyOwner {
require(VAR102[VAR106].VAR105, "");
delete VAR102[VAR106];
emit FUN62(VAR106);
}
function FUN3(address VAR5) external onlyOwner {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(msg.sender, VAR12);
}
function FUN68(address VAR4) external view returns (bytes32) {
return VAR101[VAR4].VAR7;
}
function FUN69(address VAR106) external view returns (bytes32) {
return VAR102[VAR106].VAR7;
}
function FUN9(address VAR4) external view returns (bool) {
return VAR101[VAR4].VAR105;
}
function FUN9(address[] VAR107) external view returns (bool) {
for(uint VAR108 = 0; VAR108 < VAR107.VAR31; VAR108++) {
if (!VAR101[VAR107[VAR108]].VAR105) {
return false;
}
}
return true;
}
function FUN70(address VAR106) external view returns (bool) {
return VAR102[VAR106].VAR105;
}
}
contract VAR109 {
address public VAR110;
address public VAR98;
mapping (address => bool) public VAR111;
mapping (bytes4 => address) public VAR112;
uint public VAR101;
event FUN71(address indexed VAR103, bool value);
event FUN72(address indexed VAR103, bytes4 indexed VAR113);
event FUN73(address indexed VAR103, address indexed VAR114, uint indexed value, bytes VAR115);
event FUN74(uint indexed value, address indexed sender, bytes VAR115);
event FUN57(address VAR98);
modifier VAR116 {
require(VAR111[msg.sender], "");
VAR11;
}
function FUN1(address VAR117, address[] VAR107) external {
require(VAR98 == address(0) && VAR101 == 0, "");
require(VAR107.VAR31 > 0, "");
VAR98 = VAR117;
VAR101 = VAR107.VAR31;
for(uint256 VAR108 = 0; VAR108 < VAR107.VAR31; VAR108++) {
require(VAR111[VAR107[VAR108]] == false, "");
VAR111[VAR107[VAR108]] = true;
FUN75(VAR107[VAR108]).FUN1(this);
emit FUN71(VAR107[VAR108], true);
}
}
function FUN10(address VAR4, bool VAR34) external VAR116 {
if (VAR111[VAR4] != VAR34) {
if(VAR34 == true) {
VAR101 += 1;
VAR111[VAR4] = true;
FUN75(VAR4).FUN1(this);
}
else {
VAR101 -= 1;
require(VAR101 > 0, "");
delete VAR111[VAR4];
}
emit FUN71(VAR4, VAR34);
}
}
function FUN76(address VAR4, bytes4 VAR118) external VAR116 {
require(VAR111[VAR4], "");
VAR112[VAR118] = VAR4;
emit FUN72(VAR4, VAR118);
}
function FUN77(address VAR99) external VAR116 {
require(VAR99 != address(0), "");
VAR98 = VAR99;
emit FUN57(VAR99);
}
function FUN35(address VAR119, uint VAR34, bytes VAR22) external VAR116 {
require(VAR119.call.value(VAR34)(VAR22), "");
emit FUN73(msg.sender, VAR119, VAR34, VAR22);
}
function() public payable {
if(msg.VAR115.VAR31 > 0) {
address VAR103 = VAR112[msg.VAR120];
if(VAR103 == address(0)) {
emit FUN74(msg.value, msg.sender, msg.VAR115);
}
else {
require(VAR111[VAR103], "");
VAR44 {
FUN78(0, 0, FUN79())
let VAR121 := FUN80(VAR122, VAR103, 0, FUN79(), 0, 0)
FUN81(0, 0, FUN82())
switch VAR121
case 0 {revert(0, FUN82())}
default {return (0, FUN82())}
}
}
}
}
}
contract VAR123 {
using SafeMath for uint256;
address constant internal VAR124 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address constant internal VAR125 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
mapping(address => uint256) public VAR126;
function FUN83(ERC20 VAR127) public {
uint256 VAR128;
(VAR128,) = FUN84().FUN85(VAR127, FUN11(VAR124), 10000);
VAR126[VAR127] = VAR128;
}
//
//
function FUN86(VAR86[] VAR91) public {
for(uint16 VAR108 = 0; VAR108 < VAR91.VAR31; VAR108++) {
FUN83(VAR91[VAR108]);
}
}
function FUN87(uint256 VAR82, address VAR5) public view returns (uint256) {
uint256 VAR129 = FUN11(VAR5).FUN49();
uint256 VAR130 = VAR126[VAR5];
return VAR130.FUN32(VAR82).FUN53(10**VAR129);
}
//
//
function FUN84() internal view returns (VAR131) {
return FUN88(VAR125);
}
}
contract VAR131 {
function FUN85(
ERC20 VAR132,
ERC20 VAR133,
uint VAR134
)
public
view
returns (uint VAR128, uint VAR135);
function FUN89(
ERC20 VAR132,
uint VAR136,
ERC20 VAR133,
address VAR137,
uint VAR138,
uint VAR139,
address VAR140
)
public
payable
returns(uint);
}
contract VAR141 {
modifier FUN90(BaseWallet VAR3) {
require(VAR3.FUN36(msg.sender), "");
VAR11;
}
}
contract GuardianStorage is VAR141 {
struct VAR142 {
address[] VAR143;
mapping (address => VAR144) VAR145;
uint256 VAR146;
address VAR147;
}
struct VAR144 {
bool VAR105;
uint128 VAR148;
}
mapping (address => VAR142) internal VAR149;
function FUN91(BaseWallet VAR3, address VAR150) external FUN90(VAR3) {
GuardianStorageConfig storage VAR151 = VAR149[VAR3];
VAR151.VAR145[VAR150].VAR105 = true;
VAR151.VAR145[VAR150].VAR148 = uint128(VAR151.VAR143.FUN92(VAR150) - 1);
}
function FUN93(BaseWallet VAR3, address VAR150) external FUN90(VAR3) {
GuardianStorageConfig storage VAR151 = VAR149[VAR3];
address VAR152 = VAR151.VAR143[VAR151.VAR143.VAR31 - 1];
if (VAR150 != VAR152) {
uint128 VAR153 = VAR151.VAR145[VAR150].VAR148;
VAR151.VAR143[VAR153] = VAR152;
VAR151.VAR145[VAR152].VAR148 = VAR153;
}
VAR151.VAR143.VAR31--;
delete VAR151.VAR145[VAR150];
}
function FUN94(BaseWallet VAR3) external view returns (uint256) {
return VAR149[VAR3].VAR143.VAR31;
}
function FUN95(BaseWallet VAR3) external view returns (address[]) {
GuardianStorageConfig storage VAR151 = VAR149[VAR3];
address[] memory VAR143 = new address[](VAR151.VAR143.VAR31);
for (uint256 VAR108 = 0; VAR108 < VAR151.VAR143.VAR31; VAR108++) {
VAR143[VAR108] = VAR151.VAR143[VAR108];
}
return VAR143;
}
function FUN96(BaseWallet VAR3, address VAR150) external view returns (bool) {
return VAR149[VAR3].VAR145[VAR150].VAR105;
}
function FUN97(BaseWallet VAR3, uint256 VAR154) external FUN90(VAR3) {
VAR149[VAR3].VAR146 = VAR154;
if(VAR154 != 0 && msg.sender != VAR149[VAR3].VAR147) {
VAR149[VAR3].VAR147 = msg.sender;
}
}
function FUN98(BaseWallet VAR3) external view returns (bool) {
return VAR149[VAR3].VAR146 > VAR73;
}
function FUN99(BaseWallet VAR3) external view returns (uint256) {
return VAR149[VAR3].VAR146;
}
function FUN100(BaseWallet VAR3) external view returns (address) {
return VAR149[VAR3].VAR147;
}
}
contract TransferStorage is VAR141 {
mapping (address => mapping (address => uint256)) internal VAR155;
function FUN101(BaseWallet VAR3, address VAR119, uint256 VAR34) external FUN90(VAR3) {
VAR155[VAR3][VAR119] = VAR34;
}
function FUN102(BaseWallet VAR3, address VAR119) external view returns (uint256) {
return VAR155[VAR3][VAR119];
}
}
contract TokenTransfer is VAR53, VAR156, VAR157 {
bytes32 constant VAR158 = "";
bytes4 constant internal VAR159 = bytes4(FUN25(""));
bytes constant internal VAR160 = "";
using SafeMath for uint256;
address constant internal VAR161 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
uint128 constant internal VAR54 = uint128(-1);
struct VAR162 {
mapping (bytes32 => uint256) VAR163;
}
mapping (address => VAR162) internal VAR149;
uint256 public VAR164;
uint256 public VAR165;
GuardianStorage public VAR166;
TransferStorage public VAR167;
TokenPriceProvider public VAR168;
event Transfer(address indexed VAR8, address indexed VAR127, uint256 indexed VAR47, address VAR90, bytes VAR115);
event FUN103(address indexed VAR8, address indexed VAR114, uint64 VAR169);
event FUN104(address indexed VAR8, address indexed VAR114);
event FUN105(address indexed VAR8, bytes32 indexed VAR170, uint256 indexed VAR171, address VAR127, address VAR90, uint256 VAR47, bytes VAR115);
event FUN106(address indexed VAR8, bytes32 indexed VAR170);
event FUN107(address indexed VAR8, bytes32 indexed VAR170);
modifier FUN108(BaseWallet VAR3) {
require(FUN7(VAR3, msg.sender) || VAR3.FUN36(msg.sender), "");
VAR11;
}
modifier FUN109(BaseWallet VAR3) {
require(!VAR166.FUN98(VAR3), "");
VAR11;
}
constructor(
ModuleRegistry VAR9,
TransferStorage VAR172,
GuardianStorage VAR173,
address VAR174,
uint256 VAR71,
uint256 VAR175,
uint256 VAR69
)
FUN110(VAR9, VAR158)
FUN111(VAR69)
public
{
VAR167 = VAR172;
VAR166 = VAR173;
VAR168 = FUN112(VAR174);
VAR164 = VAR71;
VAR165 = VAR175;
}
function FUN113(
BaseWallet VAR3,
address VAR5,
address VAR33,
uint256 VAR82,
bytes VAR22
)
external
FUN108(VAR3)
FUN109(VAR3)
{
if(FUN114(VAR3, VAR33)) {
if(VAR5 == VAR161) {
FUN115(VAR3, VAR33, VAR82, VAR22);
}
else {
FUN116(VAR3, VAR5, VAR33, VAR82, VAR22);
}
}
else {
if(VAR5 == VAR161) {
if (FUN45(VAR3, VAR82)) {
FUN115(VAR3, VAR33, VAR82, VAR22);
}
else {
FUN117(VAR3, VAR161, VAR33, VAR82, VAR22);
}
}
else {
uint256 VAR176 = VAR168.FUN87(VAR82, VAR5);
if (FUN45(VAR3, VAR176)) {
FUN116(VAR3, VAR5, VAR33, VAR82, VAR22);
}
else {
FUN117(VAR3, VAR5, VAR33, VAR82, VAR22);
}
}
}
}
function FUN118(
BaseWallet VAR3,
address VAR119
)
external
onlyOwner(VAR3)
FUN109(VAR3)
{
require(!FUN114(VAR3, VAR119), "");
uint256 VAR169 = VAR73.FUN31(VAR164);
VAR167.FUN101(VAR3, VAR119, VAR169);
emit FUN103(VAR3, VAR119, FUN40(VAR169));
}
function FUN119(
BaseWallet VAR3,
address VAR119
)
external
onlyOwner(VAR3)
FUN109(VAR3)
{
require(FUN114(VAR3, VAR119), "");
VAR167.FUN101(VAR3, VAR119, 0);
emit FUN104(VAR3, VAR119);
}
function FUN120(
BaseWallet VAR3,
address VAR5,
address VAR33,
uint VAR82,
bytes VAR22,
uint VAR177
)
public
FUN109(VAR3)
{
bytes32 VAR170 = FUN25(VAR35.FUN26(VAR5, VAR33, VAR82, VAR22, VAR177));
uint VAR171 = VAR149[VAR3].VAR163[VAR170];
uint VAR178 = VAR171.FUN31(VAR165);
require(VAR171 <= VAR73 && VAR73 <= VAR178, "");
FUN121(VAR3, VAR170);
if(VAR5 == VAR161) {
FUN115(VAR3, VAR33, VAR82, VAR22);
}
else {
FUN116(VAR3, VAR5, VAR33, VAR82, VAR22);
}
emit FUN106(VAR3, VAR170);
}
function FUN122(
BaseWallet VAR3,
bytes32 VAR179
)
public
onlyOwner(VAR3)
FUN109(VAR3)
{
require(VAR149[VAR3].VAR163[VAR179] > 0, "");
FUN121(VAR3, VAR179);
emit FUN107(VAR3, VAR179);
}
function FUN39(BaseWallet VAR3, uint256 VAR70) public onlyOwner(VAR3) FUN109(VAR3) {
FUN39(VAR3, VAR70, VAR164);
}
function FUN123(BaseWallet VAR3) external onlyOwner(VAR3) FUN109(VAR3) {
FUN39(VAR3, VAR54, VAR164);
}
function FUN114(BaseWallet VAR3, address VAR119) public view returns (bool VAR180) {
uint VAR169 = VAR167.FUN102(VAR3, VAR119);
return VAR169 > 0 && VAR169 < VAR73;
}
function FUN124(BaseWallet VAR3, bytes32 VAR179) external view returns (uint64 VAR181) {
VAR181 = FUN40(VAR149[VAR3].VAR163[VAR179]);
}
function FUN115(BaseWallet VAR3, address VAR33, uint256 VAR34, bytes VAR22) internal {
VAR3.FUN35(VAR33, VAR34, VAR160);
emit Transfer(VAR3, VAR161, VAR34, VAR33, VAR22);
}
function FUN116(BaseWallet VAR3, address VAR5, address VAR33, uint256 VAR34, bytes VAR22) internal {
bytes memory VAR182 = VAR35.FUN125("", VAR33, VAR34);
VAR3.FUN35(VAR5, 0, VAR182);
emit Transfer(VAR3, VAR5, VAR34, VAR33, VAR22);
}
function FUN117(BaseWallet VAR3, address VAR5, address VAR33, uint VAR82, bytes VAR22) internal returns (bytes32) {
bytes32 VAR170 = FUN25(VAR35.FUN26(VAR5, VAR33, VAR82, VAR22, VAR37.VAR38));
uint VAR171 = VAR73.FUN31(VAR164);
VAR149[VAR3].VAR163[VAR170] = VAR171;
emit FUN105(VAR3, VAR170, VAR171, VAR5, VAR33, VAR82, VAR22);
}
function FUN121(BaseWallet VAR3, bytes32 VAR179) internal {
delete VAR149[VAR3].VAR163[VAR179];
}
function FUN23(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR27, uint VAR24, address VAR46) internal {
uint256 VAR47 = 36616 + VAR45;
if(VAR26 > 0 && VAR24 > 0 && VAR47 <= VAR27) {
if(VAR26 > VAR48.VAR49) {
VAR47 = VAR47 * VAR48.VAR49;
}
else {
VAR47 = VAR47 * VAR26;
}
FUN47(VAR3, uint128(FUN41(VAR3)), VAR47);
VAR3.FUN35(VAR46, VAR47, "");
}
}
function FUN22(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR24) internal view returns (bool) {
if(VAR26 > 0 && VAR24 > 0 && (
address(VAR3).VAR50 < VAR45 * VAR26
|| FUN46(VAR3, FUN41(VAR3), VAR45 * VAR26) == false
|| VAR3.FUN36(this) == false
))
{
return false;
}
return true;
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
return FUN28(VAR3, VAR25);
}
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool) {
address VAR183 = FUN29(VAR23, VAR24, 0);
return FUN7(VAR3, VAR183);
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256) {
bytes4 VAR184 = FUN37(VAR22);
if (VAR184 == VAR159) {
return 0;
}
return 1;
}
}
1
---------------------------------
248 0xdfa1468d07fc86840a6eb53e0e65cebde81d1af9.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
contract BaseModule is VAR2 {
ModuleRegistry internal VAR6;
event FUN4(bytes32 VAR7);
event FUN5(address VAR8);
constructor(ModuleRegistry VAR9, bytes32 VAR10) public {
VAR6 = VAR9;
emit FUN4(VAR10);
}
modifier FUN6(BaseWallet VAR3) {
require(msg.sender == address(VAR3), "");
VAR11;
}
modifier onlyOwner(BaseWallet VAR3) {
require(msg.sender == address(this) || FUN7(VAR3, msg.sender), "");
VAR11;
}
modifier FUN8(BaseWallet VAR3) {
require(FUN7(VAR3, msg.sender), "");
VAR11;
}
function FUN1(BaseWallet VAR3) external FUN6(VAR3) {
emit FUN5(VAR3);
}
function FUN2(BaseWallet VAR3, Module VAR4) external FUN8(VAR3) {
require(VAR6.FUN9(VAR4), "");
VAR3.FUN10(VAR4, true);
}
function FUN3(address VAR5) external {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(address(VAR6), VAR12);
}
function FUN7(BaseWallet VAR3, address VAR13) internal view returns (bool) {
return VAR3.FUN13() == VAR13;
}
}
contract RelayerModule is VAR2 {
uint256 constant internal VAR14 = 10000;
mapping (address => VAR15) public VAR16;
struct VAR15 {
uint256 VAR17;
mapping (bytes32 => bool) VAR18;
}
event FUN14(address indexed VAR8, bool indexed VAR19, bytes32 VAR20);
modifier VAR21 {
require(msg.sender == address(this), "");
VAR11;
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256);
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool);
function FUN17(
BaseWallet VAR3,
bytes VAR22,
uint256 VAR25,
bytes VAR24,
uint256 VAR26,
uint256 VAR27
)
external
returns (bool VAR19)
{
uint VAR28 = FUN18();
bytes32 VAR29 = FUN19(address(this), VAR3, 0, VAR22, VAR25, VAR26, VAR27);
require(FUN20(VAR3, VAR25, VAR29), "");
require(FUN21(address(VAR3), VAR22), "");
uint256 VAR30 = FUN15(VAR3, VAR22);
if((VAR30 * 65) == VAR24.VAR31) {
if(FUN22(VAR3, VAR27, VAR26, VAR30)) {
if(VAR30 == 0 || FUN16(VAR3, VAR22, VAR29, VAR24)) {
VAR19 = address(this).call(VAR22);
FUN23(VAR3, VAR28 - FUN18(), VAR26, VAR27, VAR30, msg.sender);
}
}
}
emit FUN14(VAR3, VAR19, VAR29);
}
function FUN24(BaseWallet VAR3) external view returns (uint256 VAR17) {
return VAR16[VAR3].VAR17;
}
function FUN19(
address VAR32,
address VAR33,
uint256 VAR34,
bytes VAR22,
uint256 VAR25,
uint256 VAR26,
uint256 VAR27
)
internal
pure
returns (bytes32)
{
return FUN25(
VAR35.FUN26(
"",
FUN25(VAR35.FUN26(FUN27(0x19), FUN27(0), VAR32, VAR33, VAR34, VAR22, VAR25, VAR26, VAR27))
));
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
if(VAR16[VAR3].VAR18[VAR23] == true) {
return false;
}
VAR16[VAR3].VAR18[VAR23] = true;
return true;
}
function FUN28(BaseWallet VAR3, uint256 VAR25) internal returns (bool) {
if(VAR25 <= VAR16[VAR3].VAR17) {
return false;
}
uint256 VAR36 = (VAR25 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;
if(VAR36 > VAR37.VAR38 + VAR14) {
return false;
}
VAR16[VAR3].VAR17 = VAR25;
return true;
}
function FUN29(bytes32 VAR39, bytes VAR24, uint VAR40) internal pure returns (address) {
uint8 VAR41;
bytes32 VAR42;
bytes32 VAR43;
VAR44 {
VAR42 := FUN30(FUN31(VAR24, FUN31(0x20,FUN32(0x41,VAR40))))
VAR43 := FUN30(FUN31(VAR24, FUN31(0x40,FUN32(0x41,VAR40))))
VAR41 := FUN33(FUN30(FUN31(VAR24, FUN31(0x41,FUN32(0x41,VAR40)))), 0xff)
}
require(VAR41 == 27 || VAR41 == 28);
return FUN34(VAR39, VAR41, VAR42, VAR43);
}
function FUN23(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR27, uint VAR24, address VAR46) internal {
uint256 VAR47 = 29292 + VAR45;
if(VAR26 > 0 && VAR24 > 1 && VAR47 <= VAR27) {
if(VAR26 > VAR48.VAR49) {
VAR47 = VAR47 * VAR48.VAR49;
}
else {
VAR47 = VAR47 * VAR26;
}
VAR3.FUN35(VAR46, VAR47, "");
}
}
function FUN22(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR24) internal view returns (bool) {
if(VAR26 > 0
&& VAR24 > 1
&& (address(VAR3).VAR50 < VAR45 * VAR26 || VAR3.FUN36(this) == false)) {
return false;
}
return true;
}
function FUN21(address VAR3, bytes VAR22) private pure returns (bool) {
require(VAR22.VAR31 >= 36, "");
address VAR51;
VAR44 {
VAR51 := FUN30(FUN31(VAR22, 0x24))
}
return VAR51 == VAR3;
}
function FUN37(bytes VAR22) internal pure returns (bytes4 VAR52) {
require(VAR22.VAR31 >= 4, "");
VAR44 {
VAR52 := FUN30(FUN31(VAR22, 0x20))
}
}
}
contract VAR53 {
function FUN38() public view returns (uint);
function FUN39() public view returns (uint);
function FUN12(address VAR54) public view returns (uint VAR50);
function FUN40(address VAR54, address VAR55) public view returns (uint VAR56);
function transfer(address VAR57, uint VAR58) public returns (bool VAR19);
function FUN41(address VAR55, uint VAR58) public returns (bool VAR19);
function FUN42(address VAR59, address VAR57, uint VAR58) public returns (bool VAR19);
}
contract VAR60 {
address public VAR61;
event FUN43(address indexed VAR62);
modifier onlyOwner {
require(msg.sender == VAR61, "");
VAR11;
}
constructor() public {
VAR61 = msg.sender;
}
function FUN44(address VAR62) external onlyOwner {
require(VAR62 != address(0), "");
VAR61 = VAR62;
emit FUN43(VAR62);
}
}
contract ModuleRegistry is VAR60 {
mapping (address => VAR63) internal VAR64;
mapping (address => VAR63) internal VAR65;
event FUN45(address indexed VAR66, bytes32 VAR7);
event FUN46(address VAR66);
event FUN47(address indexed VAR67, bytes32 VAR7);
event FUN48(address VAR67);
struct VAR63 {
bool VAR68;
bytes32 VAR7;
}
function FUN49(address VAR4, bytes32 VAR10) external onlyOwner {
require(!VAR64[VAR4].VAR68, "");
VAR64[VAR4] = FUN50({VAR68: true, VAR7: VAR10});
emit FUN45(VAR4, VAR10);
}
function FUN51(address VAR4) external onlyOwner {
require(VAR64[VAR4].VAR68, "");
delete VAR64[VAR4];
emit FUN46(VAR4);
}
function FUN52(address VAR69, bytes32 VAR10) external onlyOwner {
require(!VAR65[VAR69].VAR68, "");
VAR65[VAR69] = FUN50({VAR68: true, VAR7: VAR10});
emit FUN47(VAR69, VAR10);
}
function FUN53(address VAR69) external onlyOwner {
require(VAR65[VAR69].VAR68, "");
delete VAR65[VAR69];
emit FUN48(VAR69);
}
function FUN3(address VAR5) external onlyOwner {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(msg.sender, VAR12);
}
function FUN54(address VAR4) external view returns (bytes32) {
return VAR64[VAR4].VAR7;
}
function FUN55(address VAR69) external view returns (bytes32) {
return VAR65[VAR69].VAR7;
}
function FUN9(address VAR4) external view returns (bool) {
return VAR64[VAR4].VAR68;
}
function FUN9(address[] VAR70) external view returns (bool) {
for(uint VAR71 = 0; VAR71 < VAR70.VAR31; VAR71++) {
if (!VAR64[VAR70[VAR71]].VAR68) {
return false;
}
}
return true;
}
function FUN56(address VAR69) external view returns (bool) {
return VAR65[VAR69].VAR68;
}
}
contract VAR72 {
address public VAR73;
address public VAR61;
mapping (address => bool) public VAR74;
mapping (bytes4 => address) public VAR75;
uint public VAR64;
event FUN57(address indexed VAR66, bool value);
event FUN58(address indexed VAR66, bytes4 indexed VAR76);
event FUN59(address indexed VAR66, address indexed VAR77, uint indexed value, bytes VAR78);
event FUN60(uint indexed value, address indexed sender, bytes VAR78);
event FUN43(address VAR61);
modifier VAR79 {
require(VAR74[msg.sender], "");
VAR11;
}
function FUN1(address VAR80, address[] VAR70) external {
require(VAR61 == address(0) && VAR64 == 0, "");
require(VAR70.VAR31 > 0, "");
VAR61 = VAR80;
VAR64 = VAR70.VAR31;
for(uint256 VAR71 = 0; VAR71 < VAR70.VAR31; VAR71++) {
require(VAR74[VAR70[VAR71]] == false, "");
VAR74[VAR70[VAR71]] = true;
FUN61(VAR70[VAR71]).FUN1(this);
emit FUN57(VAR70[VAR71], true);
}
}
function FUN10(address VAR4, bool VAR34) external VAR79 {
if (VAR74[VAR4] != VAR34) {
if(VAR34 == true) {
VAR64 += 1;
VAR74[VAR4] = true;
FUN61(VAR4).FUN1(this);
}
else {
VAR64 -= 1;
require(VAR64 > 0, "");
delete VAR74[VAR4];
}
emit FUN57(VAR4, VAR34);
}
}
function FUN62(address VAR4, bytes4 VAR81) external VAR79 {
require(VAR74[VAR4], "");
VAR75[VAR81] = VAR4;
emit FUN58(VAR4, VAR81);
}
function FUN63(address VAR62) external VAR79 {
require(VAR62 != address(0), "");
VAR61 = VAR62;
emit FUN43(VAR62);
}
function FUN35(address VAR82, uint VAR34, bytes VAR22) external VAR79 {
require(VAR82.call.value(VAR34)(VAR22), "");
emit FUN59(msg.sender, VAR82, VAR34, VAR22);
}
function() public payable {
if(msg.VAR78.VAR31 > 0) {
address VAR66 = VAR75[msg.VAR83];
if(VAR66 == address(0)) {
emit FUN60(msg.value, msg.sender, msg.VAR78);
}
else {
require(VAR74[VAR66], "");
VAR44 {
FUN64(0, 0, FUN65())
let VAR84 := FUN66(VAR85, VAR66, 0, FUN65(), 0, 0)
FUN67(0, 0, FUN68())
switch VAR84
case 0 {revert(0, FUN68())}
default {return (0, FUN68())}
}
}
}
}
}
library VAR86 {
function FUN69(uint256 VAR87, uint256 VAR88) internal pure returns (uint256) {
uint256 VAR89 = VAR87 / VAR88;
if(VAR87 % VAR88 == 0) {
return VAR89;
}
else {
return VAR89 + 1;
}
}
}
contract VAR90 {
modifier FUN70(BaseWallet VAR3) {
require(VAR3.FUN36(msg.sender), "");
VAR11;
}
}
contract GuardianStorage is VAR90 {
struct VAR91 {
address[] VAR92;
mapping (address => VAR93) VAR94;
uint256 VAR95;
address VAR96;
}
struct VAR93 {
bool VAR68;
uint128 VAR97;
}
mapping (address => VAR91) internal VAR98;
function FUN71(BaseWallet VAR3, address VAR99) external FUN70(VAR3) {
GuardianStorageConfig storage VAR100 = VAR98[VAR3];
VAR100.VAR94[VAR99].VAR68 = true;
VAR100.VAR94[VAR99].VAR97 = uint128(VAR100.VAR92.FUN72(VAR99) - 1);
}
function FUN73(BaseWallet VAR3, address VAR99) external FUN70(VAR3) {
GuardianStorageConfig storage VAR100 = VAR98[VAR3];
address VAR101 = VAR100.VAR92[VAR100.VAR92.VAR31 - 1];
if (VAR99 != VAR101) {
uint128 VAR102 = VAR100.VAR94[VAR99].VAR97;
VAR100.VAR92[VAR102] = VAR101;
VAR100.VAR94[VAR101].VAR97 = VAR102;
}
VAR100.VAR92.VAR31--;
delete VAR100.VAR94[VAR99];
}
function FUN74(BaseWallet VAR3) external view returns (uint256) {
return VAR98[VAR3].VAR92.VAR31;
}
function FUN75(BaseWallet VAR3) external view returns (address[]) {
GuardianStorageConfig storage VAR100 = VAR98[VAR3];
address[] memory VAR92 = new address[](VAR100.VAR92.VAR31);
for (uint256 VAR71 = 0; VAR71 < VAR100.VAR92.VAR31; VAR71++) {
VAR92[VAR71] = VAR100.VAR92[VAR71];
}
return VAR92;
}
function FUN76(BaseWallet VAR3, address VAR99) external view returns (bool) {
return VAR98[VAR3].VAR94[VAR99].VAR68;
}
function FUN77(BaseWallet VAR3, uint256 VAR103) external FUN70(VAR3) {
VAR98[VAR3].VAR95 = VAR103;
if(VAR103 != 0 && msg.sender != VAR98[VAR3].VAR96) {
VAR98[VAR3].VAR96 = msg.sender;
}
}
function FUN78(BaseWallet VAR3) external view returns (bool) {
return VAR98[VAR3].VAR95 > VAR104;
}
function FUN79(BaseWallet VAR3) external view returns (uint256) {
return VAR98[VAR3].VAR95;
}
function FUN80(BaseWallet VAR3) external view returns (address) {
return VAR98[VAR3].VAR96;
}
}
library VAR105 {
function FUN76(address[] VAR106, address VAR99) internal view returns (bool, address[]) {
if(VAR106.VAR31 == 0 || VAR99 == address(0)) {
return (false, VAR106);
}
bool VAR107 = false;
address[] memory VAR108 = new address[](VAR106.VAR31 - 1);
uint256 VAR97 = 0;
for (uint256 VAR71 = 0; VAR71 < VAR106.VAR31; VAR71++) {
if(!VAR107) {
if(VAR99 == VAR106[VAR71]) {
VAR107 = true;
continue;
}
if(FUN81(VAR106[VAR71]) && FUN82(VAR106[VAR71], VAR99)) {
VAR107 = true;
continue;
}
}
if(VAR97 < VAR108.VAR31) {
VAR108[VAR97] = VAR106[VAR71];
VAR97++;
}
}
return VAR107 ? (true, VAR108) : (false, VAR106);
}
function FUN81(address VAR13) internal view returns (bool) {
uint32 VAR109;
VAR44 {
VAR109 := FUN83(VAR13)
}
return (VAR109 > 0);
}
function FUN82(address VAR99, address VAR80) internal view returns (bool) {
address VAR61 = address(0);
bytes4 VAR83 = bytes4(FUN25(""));
VAR44 {
let VAR110 := FUN30(0x40)
FUN84(VAR110,VAR83)
let VAR84 := FUN66(5000, VAR99, VAR110, 0x20, VAR110, 0x20)
if FUN85(VAR84, 1) {
VAR61 := FUN30(VAR110)
}
}
return VAR61 == VAR80;
}
}
contract RecoveryManager is VAR111, VAR112 {
bytes32 constant VAR113 = "";
bytes4 constant internal VAR114 = bytes4(FUN25(""));
bytes4 constant internal VAR115 = bytes4(FUN25(""));
bytes4 constant internal VAR116 = bytes4(FUN25(""));
struct VAR117 {
address VAR118;
uint64 VAR119;
uint32 VAR120;
}
mapping (address => VAR117) internal VAR98;
uint256 public VAR121;
uint256 public VAR122;
GuardianStorage public VAR123;
event FUN86(address indexed VAR8, address indexed VAR124, uint64 VAR119);
event FUN87(address indexed VAR8, address indexed VAR124);
event FUN88(address indexed VAR8, address indexed VAR124);
modifier FUN89(BaseWallet VAR3) {
require(VAR98[VAR3].VAR119 > 0, "");
VAR11;
}
modifier FUN90(BaseWallet VAR3) {
require(VAR98[VAR3].VAR119 == 0, "");
VAR11;
}
constructor(
ModuleRegistry VAR9,
GuardianStorage VAR125,
uint256 VAR126,
uint256 VAR127
)
FUN91(VAR9, VAR113)
public
{
VAR123 = VAR125;
VAR121 = VAR126;
VAR122 = VAR127;
}
function FUN92(BaseWallet VAR3, address VAR124) external VAR21 FUN90(VAR3) {
require(VAR124 != address(0), "");
RecoveryManagerConfig storage VAR100 = VAR98[VAR3];
VAR100.VAR118 = VAR124;
VAR100.VAR119 = FUN93(VAR104 + VAR121);
VAR100.VAR120 = FUN94(VAR123.FUN74(VAR3));
VAR123.FUN77(VAR3, VAR104 + VAR122);
emit FUN86(VAR3, VAR124, VAR100.VAR119);
}
function FUN95(BaseWallet VAR3) external VAR21 FUN89(VAR3) {
RecoveryManagerConfig storage VAR100 = VAR98[VAR3];
require(FUN93(VAR104) > VAR100.VAR119, "");
VAR3.FUN63(VAR100.VAR118);
emit FUN87(VAR3, VAR100.VAR118);
VAR123.FUN77(VAR3, 0);
delete VAR98[VAR3];
}
function FUN96(BaseWallet VAR3) external VAR21 FUN89(VAR3) {
RecoveryManagerConfig storage VAR100 = VAR98[VAR3];
emit  FUN88(VAR3, VAR100.VAR118);
VAR123.FUN77(VAR3, 0);
delete VAR98[VAR3];
}
function FUN97(BaseWallet VAR3) public view returns(address VAR128, uint64 VAR129, uint32 VAR130) {
RecoveryManagerConfig storage VAR100 = VAR98[VAR3];
return (VAR100.VAR118, VAR100.VAR119, VAR100.VAR120);
}
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool) {
address VAR131 = address(0);
address[] memory VAR92 = VAR123.FUN75(VAR3);
bool VAR132 = false;
for (uint8 VAR71 = 0; VAR71 < VAR24.VAR31 / 65; VAR71++) {
address VAR133 = FUN29(VAR23, VAR24, VAR71);
if(VAR71 == 0 && FUN7(VAR3, VAR133)) {
continue;
}
else {
if(VAR133 <= VAR131) {
return false;
}
VAR131 = VAR133;
(VAR132, VAR92) = VAR105.FUN76(VAR92, VAR133);
if(!VAR132) {
return false;
}
}
}
return true;
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256) {
bytes4 VAR134 = FUN37(VAR22);
if (VAR134 == VAR114) {
return VAR86.FUN69(VAR123.FUN74(VAR3) + 1, 2);
}
if (VAR134 == VAR115) {
return 0;
}
if(VAR134 == VAR116) {
return VAR86.FUN69(VAR98[VAR3].VAR120 + 1, 2);
}
revert("");
}
}
1
---------------------------------
249 0xe03e6b186f02cf7fb585d85041033e97e9ee4b9c.sol
pragma VAR1 ^0.4.16;
contract VAR2 {
address public VAR3;
function FUN1() public {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
function FUN2(address VAR5) onlyOwner public {
VAR3 = VAR5;
}
}
interface VAR6 { function FUN3(address VAR7, uint256 VAR8, address VAR9, bytes VAR10) public; }
contract VAR11 {
string public VAR12;
string public VAR13;
uint8 public VAR14 = 18;
uint256 public VAR15;
mapping (address => uint256) public VAR16;
mapping (address => mapping (address => uint256)) public VAR17;
event Transfer(address indexed VAR18, address indexed VAR19, uint256 value);
event FUN4(address indexed VAR18, uint256 value);
function FUN5(uint256 VAR20, string VAR21, string VAR22) public {
VAR15 = VAR20 * 10 ** uint256(VAR14);
VAR16[msg.sender] = VAR15;
VAR12 = VAR21;
VAR13 = VAR22;
}
function FUN6(address VAR7, address VAR23, uint VAR8) internal {
require(VAR23 != 0x0);
require(VAR16[VAR7] >= VAR8);
require(VAR16[VAR23] + VAR8 > VAR16[VAR23]);
uint VAR24 = VAR16[VAR7] + VAR16[VAR23];
VAR16[VAR7] -= VAR8;
VAR16[VAR23] += VAR8;
Transfer(VAR7, VAR23, VAR8);
assert(VAR16[VAR7] + VAR16[VAR23] == VAR24);
}
function transfer(address VAR23, uint256 VAR8) public {
FUN6(msg.sender, VAR23, VAR8);
}
function FUN7(address VAR7, address VAR23, uint256 VAR8) public returns (bool VAR25) {
require(VAR8 <= VAR17[VAR7][msg.sender]);
VAR17[VAR7][msg.sender] -= VAR8;
FUN6(VAR7, VAR23, VAR8);
return true;
}
function FUN8(address VAR26, uint256 VAR8) public
returns (bool VAR25) {
VAR17[msg.sender][VAR26] = VAR8;
return true;
}
function FUN9(address VAR26, uint256 VAR8, bytes VAR10)
public
returns (bool VAR25) {
tokenRecipient VAR27 = FUN10(VAR26);
if (FUN8(VAR26, VAR8)) {
VAR27.FUN3(msg.sender, VAR8, this, VAR10);
return true;
}
}
function FUN11(uint256 VAR8) public returns (bool VAR25) {
require(VAR16[msg.sender] >= VAR8);
VAR16[msg.sender] -= VAR8;
VAR15 -= VAR8;
FUN4(msg.sender, VAR8);
return true;
}
function FUN12(address VAR7, uint256 VAR8) public returns (bool VAR25) {
require(VAR16[VAR7] >= VAR8);
require(VAR8 <= VAR17[VAR7][msg.sender]);
VAR16[VAR7] -= VAR8;
VAR17[VAR7][msg.sender] -= VAR8;
VAR15 -= VAR8;
FUN4(VAR7, VAR8);
return true;
}
}
contract EncryptedToken is VAR2, VAR11 {
uint256 VAR28 = 1200000000;
uint256 public VAR29 = 1;
mapping (address => bool) public VAR30;
event FUN13(address VAR31, bool VAR32);
function FUN14() FUN5(VAR28, '', '') payable public {}
function FUN6(address VAR7, address VAR23, uint VAR8) internal {
require (VAR23 != 0x0);
require (VAR16[VAR7] >= VAR8);
require (VAR16[VAR23] + VAR8 > VAR16[VAR23]);
require(!VAR30[VAR7]);
require(!VAR30[VAR23]);
VAR16[VAR7] -= VAR8;
VAR16[VAR23] += VAR8;
Transfer(VAR7, VAR23, VAR8);
}
function FUN15(address VAR31, uint256 VAR33) onlyOwner public {
VAR16[VAR31] += VAR33;
VAR15 += VAR33;
Transfer(0, this, VAR33);
Transfer(this, VAR31, VAR33);
}
function FUN16(address VAR31, bool VAR34) onlyOwner public {
VAR30[VAR31] = VAR34;
FUN13(VAR31, VAR34);
}
function FUN17(uint256 VAR35) onlyOwner public {
VAR29 = VAR35;
}
function FUN18() payable public {
uint VAR36 = msg.value / VAR29;
FUN6(this, msg.sender, VAR36);
}
function () payable public {
VAR3.FUN19(msg.value);//
uint VAR36 = msg.value * VAR29;
FUN6(VAR3, msg.sender, VAR36);
}
function FUN20() onlyOwner payable public {
FUN21(VAR3);
}
}
1
---------------------------------
250 0xe14eac83b3bb1bb7b265bf298c348264f8399834.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract HubTokenPurchase is VAR2 {
address public VAR13 = 0xcc04AF825eEf340e99710D4366e3021F8d82F42A;
address public VAR14 = 0x212286e36Ae998FAd27b627EB326107B3aF1FeD4;
address public VAR15 = 0x515962688858eD980EB2Db2b6fA2802D9f620C6d;
uint public VAR16 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR17) internal {
uint VAR18 = VAR17 * 21 / 1035;
uint VAR19 = VAR17 * 14 / 1035;
require(VAR14.call.FUN9(VAR16).value(VAR18)());
require(VAR15.call.FUN9(VAR16).value(VAR19)());
uint VAR20 = VAR17 - VAR18 - VAR19;
require(VAR13.call.FUN9(VAR16).value(VAR20)());
}
function FUN10(uint VAR21) public onlyOwner {
VAR16 = VAR21;
}
function FUN11(EIP20Token VAR22, address VAR23, uint value) public onlyOwner {
VAR22.FUN5(VAR23, value);
}
function FUN12() public onlyOwner {
require(msg.sender.call.FUN9(VAR16).value(address(this).VAR24)());
}
}
1
---------------------------------
251 0xe18fa7b1e1a7af9b338d3fb89c23a83d0c2e4b5d.sol
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
library VAR5 {
function FUN5(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN6(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN7(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
}
contract VAR6 {
function FUN8() public constant returns (bool) {
return true;
}
function FUN9(address VAR7) public constant returns (bool) {
return true;
}
function FUN10(address VAR8) public constant returns (bool) {
return false;
}
function FUN11(uint value, uint VAR9, uint VAR10, address VAR11, uint VAR12) public constant returns (uint VAR13);
}
contract VAR14 {
function FUN12() public constant returns(bool) {
return true;
}
function FUN9() public constant returns (bool);
function FUN13();
}
contract VAR15 {
uint256 public VAR16;
function FUN14(address VAR17) constant returns (uint256);
function transfer(address VAR18, uint256 value) returns (bool);
event Transfer(address indexed VAR19, address indexed VAR18, uint256 value);
}
contract ERC20 is VAR15 {
function FUN15(address VAR20, address VAR21) constant returns (uint256);
function FUN16(address VAR19, address VAR18, uint256 value) returns (bool);
function FUN17(address VAR21, uint256 value) returns (bool);
event FUN18(address indexed VAR20, address indexed VAR21, uint256 value);
}
contract FractionalERC20 is VAR22 {
uint public VAR12;
}
contract VAR23 {
address public VAR20;
function FUN19() {
VAR20 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR20);
VAR24;
}
function FUN20(address VAR25) onlyOwner {
require(VAR25 != address(0));
VAR20 = VAR25;
}
}
contract Haltable is VAR23 {
bool public VAR26;
modifier VAR27 {
if (VAR26) throw;
VAR24;
}
modifier VAR28 {
if (VAR26 && msg.sender != VAR20) throw;
VAR24;
}
modifier VAR29 {
if (!VAR26) throw;
VAR24;
}
function FUN21() external onlyOwner {
VAR26 = true;
}
function FUN22() external onlyOwner VAR29 {
VAR26 = false;
}
}
contract CrowdsaleBase is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR10 = 0;
uint public VAR9 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
uint public VAR42 = 0;
bool public VAR43;
mapping (address => uint256) public VAR44;
mapping (address => uint256) public VAR45;
mapping (address => bool) public VAR46;
uint public VAR47;
enum VAR48{VAR49, VAR50, VAR51, VAR52, VAR53, VAR54, VAR55, VAR56}
event FUN23(address VAR57, uint VAR58, uint VAR13, uint128 VAR59);
event FUN24(address VAR57, uint VAR58);
event FUN25(bool VAR60, bool VAR61, address VAR62);
event FUN26(address VAR63, bool VAR64);
event FUN27(uint VAR65);
State public VAR66;
function FUN28(address VAR67, PricingStrategy VAR68, address VAR69, uint VAR70, uint VAR71, uint VAR72) {
VAR20 = msg.sender;
VAR32 = FUN29(VAR67);
FUN30(VAR68);
VAR35 = VAR69;
if(VAR35 == 0) {
throw;
}
if(VAR70 == 0) {
throw;
}
VAR37 = VAR70;
if(VAR71 == 0) {
throw;
}
VAR38 = VAR71;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR72;
}
function() payable {
throw;
}
function FUN31(address VAR73, uint128 VAR59) stopInEmergency internal returns(uint VAR74) {
if(FUN32() == VAR48.VAR51) {
if(!VAR46[VAR73]) {
throw;
}
} else if(FUN32() == VAR48.VAR52) {
} else {
throw;
}
uint VAR58 = msg.value;
uint VAR13 = VAR33.FUN11(VAR58, VAR9 - VAR39, VAR10, msg.sender, VAR32.FUN33());
require(VAR13 != 0);
if(VAR44[VAR73] == 0) {
VAR40++;
}
VAR44[VAR73] = VAR44[VAR73].FUN7(VAR58);
VAR45[VAR73] = VAR45[VAR73].FUN7(VAR13);
VAR9 = VAR9.FUN7(VAR58);
VAR10 = VAR10.FUN7(VAR13);
if(VAR33.FUN10(VAR73)) {
VAR39 = VAR39.FUN7(VAR58);
}
require(!FUN34(VAR58, VAR13, VAR9, VAR10));
FUN35(VAR73, VAR13);
if(!VAR35.FUN36(VAR58)) throw;
FUN23(VAR73, VAR58, VAR13, VAR59);
return VAR13;
}
function FUN37() public FUN38(VAR48.VAR53) onlyOwner VAR27 {
if(VAR43) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN13();
}
VAR43 = true;
}
function FUN39(FinalizeAgent VAR63) onlyOwner {
VAR34 = VAR63;
if(!VAR34.FUN12()) {
throw;
}
}
function FUN40(uint VAR75) onlyOwner {
if(VAR76 > VAR75) {
throw;
}
if(VAR37 > VAR75) {
throw;
}
VAR38 = VAR75;
FUN27(VAR38);
}
function FUN30(PricingStrategy VAR68) onlyOwner {
VAR33 = VAR68;
if(!VAR33.FUN8()) {
throw;
}
}
function FUN41(address VAR63) public onlyOwner {
if(VAR40 > VAR31) {
throw;
}
VAR35 = VAR63;
}
function FUN42() public payable FUN38(VAR48.VAR54) {
if(msg.value == 0) throw;
VAR41 = VAR41.FUN7(msg.value);
}
function FUN43() public FUN38(VAR48.VAR56) {
uint256 VAR77 = VAR44[msg.sender];
if (VAR77 == 0) throw;
VAR44[msg.sender] = 0;
VAR42 = VAR42.FUN7(VAR77);
FUN24(msg.sender, VAR77);
if (!msg.sender.FUN36(VAR77)) throw;
}
function FUN44() public constant returns (bool VAR78) {
return VAR9 >= VAR36;
}
function FUN45() public constant returns (bool VAR79) {
return VAR34.FUN9();
}
function FUN46() public constant returns (bool VAR79) {
return VAR33.FUN9(address(this));
}
function FUN32() public constant returns (VAR48) {
if(VAR43) return VAR48.VAR55;
else if (address(VAR34) == 0) return VAR48.VAR50;
else if (!VAR34.FUN9()) return VAR48.VAR50;
else if (!VAR33.FUN9(address(this))) return VAR48.VAR50;
else if (VAR80.VAR81 < VAR37) return VAR48.VAR51;
else if (VAR80.VAR81 <= VAR38 && !FUN47()) return VAR48.VAR52;
else if (FUN44()) return VAR48.VAR53;
else if (!FUN44() && VAR9 > 0 && VAR41 >= VAR9) return VAR48.VAR56;
else return VAR48.VAR54;
}
function FUN48(uint VAR82) onlyOwner {
VAR47 = VAR82;
}
function FUN49(address VAR63, bool VAR64) onlyOwner {
VAR46[VAR63] = VAR64;
FUN26(VAR63, VAR64);
}
function FUN50() public constant returns (bool) {
return true;
}
//
//
modifier FUN38(State VAR83) {
if(FUN32() != VAR83) throw;
VAR24;
}
//
//
function FUN34(uint VAR58, uint VAR13, uint VAR84, uint VAR85) constant returns (bool VAR86);
function FUN47() public constant returns (bool);
function FUN35(address VAR73, uint VAR13) internal;
}
contract Crowdsale is VAR87 {
bool public VAR88;
bool public VAR89;
address public VAR90;
function FUN51(address VAR67, PricingStrategy VAR68, address VAR69, uint VAR70, uint VAR71, uint VAR72) FUN28(VAR67, VAR68, VAR69, VAR70, VAR71, VAR72) {
}
function FUN52(address VAR73, uint VAR91, uint VAR92) public onlyOwner {
uint VAR13 = VAR91 * 10**VAR32.FUN33();
uint VAR58 = VAR92 * VAR91;
VAR9 = VAR9.FUN7(VAR58);
VAR10 = VAR10.FUN7(VAR13);
VAR44[VAR73] = VAR44[VAR73].FUN7(VAR58);
VAR45[VAR73] = VAR45[VAR73].FUN7(VAR13);
FUN35(VAR73, VAR13);
FUN23(VAR73, VAR58, VAR13, 0);
}
function FUN53(address VAR63, uint128 VAR59, uint8 VAR93, bytes32 VAR94, bytes32 VAR95) public payable {
bytes32 VAR96 = FUN54(VAR63);
if (FUN55(VAR96, VAR93, VAR94, VAR95) != VAR90) throw;
if(VAR59 == 0) throw;
FUN31(VAR63, VAR59);
}
function FUN56(address VAR63, uint128 VAR59) public payable {
if(VAR89) throw;
if(VAR59 == 0) throw;
FUN31(VAR63, VAR59);
}
function FUN57(address VAR63) public payable {
if(VAR88) throw;
if(VAR89) throw;
FUN31(VAR63, 0);
}
function FUN58(uint128 VAR59, uint8 VAR93, bytes32 VAR94, bytes32 VAR95) public payable {
FUN53(msg.sender, VAR59, VAR93, VAR94, VAR95);
}
function FUN59(uint128 VAR59, bytes1 VAR97) public payable {
if (FUN60(FUN61(VAR59)) != VAR97) throw;
FUN56(msg.sender, VAR59);
}
function FUN62(uint128 VAR59) public payable {
FUN56(msg.sender, VAR59);
}
function FUN63() public payable {
FUN57(msg.sender);
}
function FUN64(bool value) onlyOwner {
VAR88 = value;
FUN25(VAR88, VAR89, VAR90);
}
function FUN65(bool value, address VAR98) onlyOwner {
VAR89 = value;
VAR90 = VAR98;
FUN25(VAR88, VAR89, VAR90);
}
}
contract PreICOProxyBuyer is VAR23, VAR30 {
using SafeMath for uint;
uint public VAR40;
uint public VAR9;
address[] public VAR99;
mapping(address => uint) public VAR100;
mapping(address => uint) public VAR101;
uint public VAR102;
uint public VAR103;
uint public VAR104;
uint public VAR105;
uint public VAR74;
uint public VAR106;
uint public VAR107;
uint public VAR108;
bool public VAR109;
Crowdsale public VAR7;
enum VAR48{VAR49, VAR52, VAR110, VAR56}
event FUN23(address VAR57, uint VAR58, uint128 VAR59);
event FUN66(address VAR57, uint value);
event FUN67(uint VAR111);
event FUN68(address VAR57, uint VAR111);
function FUN69(address VAR112, uint VAR113, uint VAR114, uint VAR115, uint VAR116) {
VAR20 = VAR112;
if(VAR113 == 0) {
throw;
}
if(VAR114 == 0) {
throw;
}
if(VAR115 == 0) {
throw;
}
VAR103 = VAR114;
VAR104 = VAR115;
VAR105 = VAR116;
VAR102 = VAR113;
}
function FUN70() public constant returns(VAR117) {
if(address(VAR7) == 0)  {
throw;
}
return VAR7.FUN71();
}
function FUN57(uint128 VAR59) private {
if(FUN32() != VAR48.VAR52) throw;
if(msg.value == 0) throw;
address VAR57 = msg.sender;
bool VAR118 = VAR100[VAR57] > 0;
VAR100[VAR57] = VAR100[VAR57].FUN4(msg.value);
if(VAR100[VAR57] < VAR103 || VAR100[VAR57] > VAR104) {
throw;
}
if(!VAR118) {
VAR99.FUN72(VAR57);
VAR40++;
}
VAR9 = VAR9.FUN4(msg.value);
if(VAR9 > VAR105) {
throw;
}
FUN23(VAR57, msg.value, VAR59);
}
function FUN62(uint128 VAR59) public stopInEmergency payable {
FUN57(VAR59);
}
function FUN63() public stopInEmergency payable {
FUN57(0x0);
}
function FUN73() stopNonOwnersInEmergency public {
if(FUN32() != VAR48.VAR52) {
throw;
}
if(address(VAR7) == 0) throw;
VAR7.VAR119.value(VAR9)(address(this));
VAR74 = FUN70().FUN14(address(this));
if(VAR74 == 0) {
throw;
}
FUN67(VAR74);
}
function FUN74(address VAR57) public constant returns (uint) {
if(FUN32() != VAR48.VAR110) {
throw;
}
return VAR100[VAR57].FUN1(VAR74) / VAR9;
}
function FUN75(address VAR57) public constant returns (uint) {
return FUN74(VAR57).FUN3(VAR101[VAR57]);
}
function FUN76() {
FUN77(FUN75(msg.sender));
}
function FUN77(uint VAR120) VAR27 {
require (VAR76 > VAR108);
address VAR57 = msg.sender;
if(VAR120 == 0) {
throw;
}
if(FUN75(VAR57) < VAR120) {
throw;
}
if(VAR101[VAR57] == 0) {
VAR106++;
}
VAR101[VAR57] = VAR101[VAR57].FUN4(VAR120);
VAR107 = VAR107.FUN4(VAR120);
FUN70().transfer(VAR57, VAR120);
FUN68(VAR57, VAR120);
}
function FUN43() VAR27 {
if(FUN32() != VAR48.VAR56) throw;
address VAR57 = msg.sender;
if(VAR100[VAR57] == 0) throw;
uint VAR120 = VAR100[VAR57];
delete VAR100[VAR57];
if(!(VAR57.call.value(VAR120)())) throw;
FUN66(VAR57, VAR120);
}
function FUN78(Crowdsale VAR121) public onlyOwner {
VAR7 = VAR121;
if(!VAR7.FUN50()) true;
}
function FUN79(uint VAR122) public onlyOwner {
VAR108 = VAR122;
}
function FUN80() public onlyOwner {
VAR109 = true;
}
function FUN42() public payable {
if(FUN32() != VAR48.VAR56) throw;
}
function FUN32() public returns(VAR48) {
if (VAR109)
return VAR48.VAR56;
if(VAR74 == 0) {
if(VAR76 >= VAR102) {
return VAR48.VAR56;
} else {
return VAR48.VAR52;
}
} else {
return VAR48.VAR110;
}
}
function FUN81() public constant returns (bool) {
return true;
}
function() payable {
throw;
}
}
1
---------------------------------
252 0xe304283c3e60cefaf7ea514007cf4e8fdc3d869d.sol
pragma VAR1 ^0.4.19;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
function FUN6() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract VAR11 {
uint256 public VAR12;
function FUN8(address VAR13) public view returns (uint256);
function transfer(address VAR14, uint256 value) public returns (bool);
event Transfer(address indexed VAR15, address indexed VAR14, uint256 value);
}
contract BasicToken is VAR11 {
using SafeMath for uint256;
mapping(address => uint256) VAR16;
function transfer(address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
require(VAR18 <= VAR16[msg.sender]);
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR18);
Transfer(msg.sender, VAR17, VAR18);
return true;
}
function FUN8(address VAR19) public view returns (uint256 VAR20) {
return VAR16[VAR19];
}
}
contract ERC20 is VAR11 {
function FUN9(address VAR7, address VAR21) public view returns (uint256);
function FUN10(address VAR15, address VAR14, uint256 value) public returns (bool);
function FUN11(address VAR21, uint256 value) public returns (bool);
event FUN12(address indexed VAR7, address indexed VAR21, uint256 value);
}
contract StandardToken is VAR22, VAR23 {
mapping (address => mapping (address => uint256)) internal VAR24;
function FUN10(address VAR25, address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
require(VAR18 <= VAR16[VAR25]);
require(VAR18 <= VAR24[VAR25][msg.sender]);
VAR16[VAR25] = VAR16[VAR25].FUN3(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR18);
VAR24[VAR25][msg.sender] = VAR24[VAR25][msg.sender].FUN3(VAR18);
Transfer(VAR25, VAR17, VAR18);
return true;
}
function FUN11(address VAR26, uint256 VAR18) public returns (bool) {
VAR24[msg.sender][VAR26] = VAR18;
FUN12(msg.sender, VAR26, VAR18);
return true;
}
function FUN9(address VAR19, address VAR26) public view returns (uint256) {
return VAR24[VAR19][VAR26];
}
function FUN13(address VAR26, uint VAR27) public returns (bool) {
VAR24[msg.sender][VAR26] = VAR24[msg.sender][VAR26].FUN4(VAR27);
FUN12(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
function FUN14(address VAR26, uint VAR28) public returns (bool) {
uint VAR29 = VAR24[msg.sender][VAR26];
if (VAR28 > VAR29) {
VAR24[msg.sender][VAR26] = 0;
} else {
VAR24[msg.sender][VAR26] = VAR29.FUN3(VAR28);
}
FUN12(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
}
contract MintableToken is VAR30, VAR6 {
event FUN15(address indexed VAR14, uint256 VAR31);
event FUN16();
bool public VAR32 = false;
modifier FUN17() {
require(!VAR32);
VAR10;
}
function FUN18(address VAR17, uint256 VAR33) onlyOwner canMint public returns (bool) {
VAR12 = VAR12.FUN4(VAR33);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR33);
FUN15(VAR17, VAR33);
Transfer(address(0), VAR17, VAR33);
return true;
}
function FUN19() onlyOwner canMint public returns (bool) {
VAR32 = true;
FUN16();
return true;
}
}
contract GECOIN is VAR34 {
event FUN20(address indexed VAR35, uint256 value);
string public constant VAR36 = "";
string public constant VAR37 = "";
uint8 public constant VAR38 = 18;
bool public VAR39 = false;
bool public VAR40 = false;
bool public VAR41 = false;
bool public VAR42 = true;
bool public VAR43 = true;
mapping(address => uint256) public VAR44;
mapping(address => uint256) public VAR45;
mapping(address => bool) public VAR46;
mapping(address => bool) public VAR47;
function FUN21(address VAR25, address VAR17) public view returns (bool) {
if (VAR46[VAR25])
return true;
if (VAR45[VAR25] > VAR48)
return false;
if (!VAR39) {
if (VAR40 && VAR44[VAR25] != 0 && VAR44[VAR17] != 0 && VAR44[VAR25] < VAR48 && VAR44[VAR17] < VAR48)
return true;
if (VAR41 && VAR44[VAR25] != 0 && VAR44[VAR25] < VAR48)
return true;
return false;
}
return true;
}
function FUN22() public view returns (bool) {
if (msg.sender == VAR7)
return true;
if (VAR47[msg.sender])
return true;
return false;
}
function transfer(address VAR17, uint256 VAR18) public returns (bool) {
require(FUN21(msg.sender, VAR17));
return super.transfer(VAR17, VAR18);
}
function FUN10(address VAR25, address VAR17, uint256 VAR18) public returns (bool) {
require(FUN21(VAR25, VAR17));
return super.FUN10(VAR25, VAR17, VAR18);
}
function FUN18(address VAR17, uint256 VAR33) onlyOwner canMint public returns (bool) {
require(VAR12.FUN4(VAR33) <= 1000000000000000000000000000);
return super.FUN18(VAR17, VAR33);
}
function FUN23(uint256 VAR18) public {
require(VAR43);
require(VAR18 <= VAR16[msg.sender]);
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR12 = VAR12.FUN3(VAR18);
FUN20(msg.sender, VAR18);
Transfer(msg.sender, address(0), VAR18);
}
function FUN24(address VAR49, uint256 VAR18) onlyOwner public {
require(VAR42);
require(VAR18 <= VAR16[VAR49]);
VAR16[VAR49] = VAR16[VAR49].FUN3(VAR18);
VAR12 = VAR12.FUN3(VAR18);
FUN20(VAR49, VAR18);
Transfer(VAR49, address(0), VAR18);
}
function FUN25() onlyOwner public returns (bool) {
VAR43 = false;
return true;
}
function FUN26() onlyOwner public returns (bool) {
VAR42 = false;
return true;
}
function FUN27(address VAR50, bool VAR51) onlyOwner public {
VAR47[VAR50] = VAR51;
}
function FUN28(bool VAR51) onlyOwner public {
VAR39 = VAR51;
}
function FUN29(bool VAR51) onlyOwner public {
VAR40 = VAR51;
}
function FUN30(bool VAR51) onlyOwner public {
VAR41 = VAR51;
}
function FUN31(address VAR52, uint256 VAR53) public {
require(FUN22());
VAR44[VAR52] = VAR53;
}
function FUN32(address VAR52, uint256 VAR53) onlyOwner public {
VAR45[VAR52] = VAR53;
}
function FUN33(address VAR52, bool VAR51) onlyOwner public {
VAR46[VAR52] = VAR51;
}
function FUN34(address VAR54, address VAR55, uint256 VAR56) onlyOwner payable public {
ERC20 VAR57 = FUN35(VAR55);
VAR57.transfer(VAR54, VAR56);
}
function FUN36(address VAR54, uint256 VAR58) onlyOwner payable public {
require(VAR54 != address(0));
require(address(this).VAR20 >= VAR58);
require(address(this) != VAR54);
require(VAR54.call.value(VAR58)());
}
}
1
---------------------------------
253 0xe367fe584adad878b9174ea4ddd8571878016811.sol
pragma VAR1^0.4.24;
contract VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require((VAR5 = VAR3 + VAR4) >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require((VAR5 = VAR3 - VAR4) <= VAR3);
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 == 0 || (VAR5 = VAR3 * VAR4) / VAR4 == VAR3);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
return VAR3 <= VAR4 ? VAR3 : VAR4;
}
function FUN5(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN6(int VAR3, int VAR4) internal pure returns (int VAR5) {
return VAR3 <= VAR4 ? VAR3 : VAR4;
}
function FUN7(int VAR3, int VAR4) internal pure returns (int VAR5) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
uint constant VAR6 = 10 ** 18;
uint constant VAR7 = 10 ** 27;
function FUN8(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = FUN1(FUN3(VAR3, VAR4), VAR6 / 2) / VAR6;
}
function FUN9(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = FUN1(FUN3(VAR3, VAR4), VAR7 / 2) / VAR7;
}
function FUN10(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = FUN1(FUN3(VAR3, VAR6), VAR4 / 2) / VAR4;
}
function FUN11(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = FUN1(FUN3(VAR3, VAR7), VAR4 / 2) / VAR4;
}
//
//
//
//
//
function FUN12(uint VAR3, uint VAR8) internal pure returns (uint VAR5) {
VAR5 = VAR8 % 2 != 0 ? VAR3 : VAR7;
for (VAR8 /= 2; VAR8 != 0; VAR8 /= 2) {
VAR3 = FUN9(VAR3, VAR3);
if (VAR8 % 2 != 0) {
VAR5 = FUN9(VAR5, VAR3);
}
}
}
}
contract VAR9 {
function FUN13(
address VAR10, address VAR11, bytes4 VAR12
) public view returns (bool);
}
contract VAR13 {
event FUN14 (address indexed VAR14);
event FUN15     (address indexed VAR15);
}
contract DSAuth is VAR13 {
DSA  public  VAR16;
address      public  VAR15;
constructor() public {
VAR15 = msg.sender;
emit FUN15(msg.sender);
}
function FUN16(address VAR17)
public
VAR18
{
VAR15 = VAR17;
emit FUN15(VAR15);
}
function FUN17(DSA VAR19)
public
VAR18
{
VAR16 = VAR19;
emit FUN14(VAR16);
}
modifier VAR18 {
require(FUN18(msg.sender, msg.VAR12));
VAR20;
}
function FUN18(address VAR10, bytes4 VAR12) internal view returns (bool) {
if (VAR10 == address(this)) {
return true;
} else if (VAR10 == VAR15) {
return true;
} else if (VAR16 == FUN19(0)) {
return false;
} else {
return VAR16.FUN13(VAR10, this, VAR12);
}
}
}
contract VAR21 {
address public VAR22;
function FUN20(uint VAR23, string VAR24, string VAR25) external payable returns (bytes32 VAR26);
function FUN21(uint VAR23, string VAR24, string VAR25, uint VAR27) external payable returns (bytes32 VAR26);
function FUN22(uint VAR23, string VAR24, string VAR28, string VAR29) public payable returns (bytes32 VAR26);
function FUN23(uint VAR23, string VAR24, string VAR28, string VAR29, uint VAR27) external payable returns (bytes32 VAR26);
function FUN24(uint VAR23, string VAR24, bytes VAR30) public payable returns (bytes32 VAR26);
function FUN25(uint VAR23, string VAR24, bytes VAR30, uint VAR27) external payable returns (bytes32 VAR26);
function FUN26(string VAR24) public returns (uint VAR31);
function FUN26(string VAR24, uint VAR32) public returns (uint VAR31);
function FUN27(byte VAR33) external;
function FUN28(uint VAR34) external;
function FUN29() external constant returns(bytes32);
}
contract VAR35 {
function FUN30() public returns (address VAR36);
}
library VAR37 {
struct VAR38 {
bytes VAR39;
uint VAR40;
}
function FUN31(buffer memory VAR39, uint VAR41) internal pure {
uint VAR40 = VAR41;
if(VAR40 % 32 != 0) VAR40 += 32 - (VAR40 % 32);
VAR39.VAR40 = VAR40;
VAR42 {
let VAR43 := FUN32(0x40)
FUN33(VAR39, VAR43)
FUN33(VAR43, 0)
FUN33(0x40, FUN1(VAR43, VAR40))
}
}
function FUN34(buffer memory VAR39, uint VAR40) private pure {
bytes memory VAR44 = VAR39.VAR39;
FUN31(VAR39, VAR40);
FUN35(VAR39, VAR44);
}
function FUN5(uint VAR16, uint VAR45) private pure returns(uint) {
if(VAR16 > VAR45) {
return VAR16;
}
return VAR45;
}
function FUN35(buffer memory VAR39, bytes VAR46) internal pure returns(buffer VAR47) {
if(VAR46.VAR48 + VAR39.VAR39.VAR48 > VAR39.VAR40) {
FUN34(VAR39, FUN5(VAR39.VAR40, VAR46.VAR48) * 2);
}
uint VAR49;
uint VAR10;
uint VAR50 = VAR46.VAR48;
VAR42 {
let VAR51 := FUN32(VAR39)
let VAR52 := FUN32(VAR51)
VAR49 := FUN1(FUN1(VAR51, VAR52), 32)
FUN33(VAR51, FUN1(VAR52, FUN32(VAR46)))
VAR10 := FUN1(VAR46, 32)
}
for(; VAR50 >= 32; VAR50 -= 32) {
VAR42 {
FUN33(VAR49, FUN32(VAR10))
}
VAR49 += 32;
VAR10 += 32;
}
uint VAR53 = 256 ** (32 - VAR50) - 1;
VAR42 {
let VAR54 := FUN36(FUN32(VAR10), FUN37(VAR53))
let VAR55 := FUN36(FUN32(VAR49), VAR53)
FUN33(VAR49, or(VAR55, VAR54))
}
return VAR39;
}
function FUN35(buffer memory VAR39, uint8 VAR46) internal pure {
if(VAR39.VAR39.VAR48 + 1 > VAR39.VAR40) {
FUN34(VAR39, VAR39.VAR40 * 2);
}
VAR42 {
let VAR51 := FUN32(VAR39)
let VAR52 := FUN32(VAR51)
let VAR49 := FUN1(FUN1(VAR51, VAR52), 32)
FUN38(VAR49, VAR46)
FUN33(VAR51, FUN1(VAR52, 1))
}
}
function FUN39(buffer memory VAR39, uint VAR46, uint VAR50) internal pure returns(buffer VAR47) {
if(VAR50 + VAR39.VAR39.VAR48 > VAR39.VAR40) {
FUN34(VAR39, FUN5(VAR39.VAR40, VAR50) * 2);
}
uint VAR53 = 256 ** VAR50 - 1;
VAR42 {
let VAR51 := FUN32(VAR39)
let VAR52 := FUN32(VAR51)
let VAR49 := FUN1(FUN1(VAR51, VAR52), VAR50)
FUN33(VAR49, or(FUN36(FUN32(VAR49), FUN37(VAR53)), VAR46))
FUN33(VAR51, FUN1(VAR52, VAR50))
}
return VAR39;
}
}
library VAR56 {
using Buffer for VAR37.VAR38;
uint8 private constant VAR57 = 0;
uint8 private constant VAR58 = 1;
uint8 private constant VAR59 = 2;
uint8 private constant VAR60 = 3;
uint8 private constant VAR61 = 4;
uint8 private constant VAR62 = 5;
uint8 private constant VAR63 = 7;
function FUN40(VAR37.buffer memory VAR39, uint8 VAR64, uint value) private pure {
if(value <= 23) {
VAR39.FUN35(uint8((VAR64 << 5) | value));
} else if(value <= 0xFF) {
VAR39.FUN35(uint8((VAR64 << 5) | 24));
VAR39.FUN39(value, 1);
} else if(value <= 0xFFFF) {
VAR39.FUN35(uint8((VAR64 << 5) | 25));
VAR39.FUN39(value, 2);
} else if(value <= 0xFFFFFFFF) {
VAR39.FUN35(uint8((VAR64 << 5) | 26));
VAR39.FUN39(value, 4);
} else if(value <= 0xFFFFFFFFFFFFFFFF) {
VAR39.FUN35(uint8((VAR64 << 5) | 27));
VAR39.FUN39(value, 8);
}
}
function FUN41(VAR37.buffer memory VAR39, uint8 VAR64) private pure {
VAR39.FUN35(uint8((VAR64 << 5) | 31));
}
function FUN42(VAR37.buffer memory VAR39, uint value) internal pure {
FUN40(VAR39, VAR57, value);
}
function FUN43(VAR37.buffer memory VAR39, int value) internal pure {
if(value >= 0) {
FUN40(VAR39, VAR57, uint(value));
} else {
FUN40(VAR39, VAR58, uint(-1 - value));
}
}
function FUN44(VAR37.buffer memory VAR39, bytes value) internal pure {
FUN40(VAR39, VAR59, value.VAR48);
VAR39.FUN35(value);
}
function FUN45(VAR37.buffer memory VAR39, string value) internal pure {
FUN40(VAR39, VAR60, bytes(value).VAR48);
VAR39.FUN35(bytes(value));
}
function FUN46(VAR37.buffer memory VAR39) internal pure {
FUN41(VAR39, VAR61);
}
function FUN47(VAR37.buffer memory VAR39) internal pure {
FUN41(VAR39, VAR62);
}
function FUN48(VAR37.buffer memory VAR39) internal pure {
FUN41(VAR39, VAR63);
}
}
contract usingOraclize is VAR65 {
byte constant VAR66 = 0x00;
byte constant VAR67 = 0x10;
byte constant VAR68 = 0x30;
byte constant VAR69 = 0x40;
byte constant VAR70 = 0xF0;
byte constant VAR71 = 0x01;
uint8 constant VAR72 = 0;
uint8 constant VAR73 = 1;
uint8 constant VAR74 = 2;
uint8 constant VAR75 = 2;
uint8 constant VAR76 = 161;
OraclizeAddrResolverI VAR77;
OraclizeI VAR78;
modifier VAR79 {
if((address(VAR77)==0)||(FUN49(address(VAR77))==0))
FUN50(VAR72);
if(address(VAR78) != VAR77.FUN30())
VAR78 = FUN51(VAR77.FUN30());
VAR20;
}
modifier FUN52(string VAR80){
VAR78 = FUN51(VAR77.FUN30());
VAR20;
}
function FUN50(uint8 VAR81) internal returns(bool){
return FUN50();
VAR81;
}
function FUN50() internal returns(bool){
if (FUN49(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR77 = FUN53(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN54("");
return true;
}
if (FUN49(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR77 = FUN53(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN54("");
return true;
}
return false;
}
function FUN55() internal oraclizeAPI returns (address){
return VAR78.FUN56();
}
function FUN57(bytes32 VAR82, string VAR83) public {
FUN57(VAR82, VAR83, VAR84 bytes(0));
}
function FUN57(bytes32 VAR82, string VAR83, bytes VAR85) public;
function FUN58(string VAR86) internal oraclizeAPI returns (uint){
return VAR78.FUN26(VAR86);
}
function FUN58(string VAR86, uint VAR32) internal oraclizeAPI returns (uint){
return VAR78.FUN26(VAR86, VAR32);
}
function FUN59(string VAR86, bytes[] VAR87, uint VAR32) internal oraclizeAPI returns (bytes32 VAR88){
uint VAR89 = VAR78.FUN26(VAR86, VAR32);
if (VAR89 > 1 VAR90 + VAR91.VAR92*VAR32) return 0;
bytes memory VAR93 = FUN60(VAR87);
return VAR78.VAR94.value(VAR89)(0, VAR86, VAR93, VAR32);
}
function FUN59(string VAR86, bytes[4] VAR93, uint VAR32) internal oraclizeAPI returns (bytes32 VAR88) {
bytes[] memory VAR95 = new bytes[](4);
VAR95[0] = VAR93[0];
VAR95[1] = VAR93[1];
VAR95[2] = VAR93[2];
VAR95[3] = VAR93[3];
return FUN59(VAR86, VAR95, VAR32);
}
function FUN61(byte VAR96) internal VAR79 {
return VAR78.FUN27(VAR96);
}
function FUN62(uint VAR97) internal VAR79 {
return VAR78.FUN28(VAR97);
}
function FUN63() internal oraclizeAPI returns (bytes32){
return VAR78.FUN29();
}
function FUN49(address VAR36) internal view returns(uint VAR98) {
VAR42 {
VAR98 := FUN64(VAR36)
}
}
using CBOR for VAR37.VAR38;
function FUN60(bytes[] VAR99) internal pure returns (bytes) {
FUN65();
VAR37.buffer memory VAR39;
VAR37.FUN31(VAR39, 1024);
VAR39.FUN46();
for (uint VAR100 = 0; VAR100 < VAR99.VAR48; VAR100++) {
VAR39.FUN44(VAR99[VAR100]);
}
VAR39.FUN48();
return VAR39.VAR39;
}
string VAR101;
function FUN54(string VAR102) internal {
VAR101 = VAR102;
}
function FUN66() internal view returns (string) {
return VAR101;
}
function FUN67(uint VAR103, uint VAR104, uint VAR105) internal returns (bytes32) {
require((VAR104 > 0) && (VAR104 <= 32), "");
VAR103 *= 10;
bytes memory VAR106 = VAR84 bytes(1);
VAR106[0] = FUN68(VAR104);
bytes memory VAR107 = VAR84 bytes(32);
bytes memory VAR108 = VAR84 bytes(32);
bytes32 VAR109 = FUN63();
VAR42 {
FUN33(VAR107, 0x20)
FUN33(FUN1(VAR107, 0x20), FUN69(FUN70(FUN2(VAR110, 1)), FUN69(VAR111, VAR112)))
FUN33(VAR108, 0x20)
FUN33(FUN1(VAR108, 0x20), VAR109)
}
bytes memory VAR113 = VAR84 bytes(32);
VAR42 {
FUN33(FUN1(VAR113, 0x20), VAR103)
}
bytes memory VAR114 = VAR84 bytes(8);
FUN71(VAR113, 24, 8, VAR114, 0);
bytes[4] memory VAR93 = [VAR107, VAR106, VAR108, VAR113];
bytes32 VAR115 = FUN59("", VAR93, VAR105);
bytes memory VAR116 = VAR84 bytes(8);
VAR42 {
let VAR3 := FUN32(FUN1(VAR114, 0x20))
FUN38(FUN1(VAR116, 0x27), FUN72(VAR3, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN38(FUN1(VAR116, 0x26), FUN72(VAR3, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN38(FUN1(VAR116, 0x25), FUN72(VAR3, 0x10000000000000000000000000000000000000000000000000000000000))
FUN38(FUN1(VAR116, 0x24), FUN72(VAR3, 0x100000000000000000000000000000000000000000000000000000000))
FUN38(FUN1(VAR116, 0x23), FUN72(VAR3, 0x1000000000000000000000000000000000000000000000000000000))
FUN38(FUN1(VAR116, 0x22), FUN72(VAR3, 0x10000000000000000000000000000000000000000000000000000))
FUN38(FUN1(VAR116, 0x21), FUN72(VAR3, 0x100000000000000000000000000000000000000000000000000))
FUN38(FUN1(VAR116, 0x20), FUN72(VAR3, 0x1000000000000000000000000000000000000000000000000))
}
FUN73(VAR115, FUN74(VAR117.FUN75(VAR116, VAR93[1], FUN76(VAR93[0]), VAR93[2])));
return VAR115;
}
function FUN67(uint VAR104, uint VAR105) internal returns (bytes32){
require((VAR104 > 0) && (VAR104 <= 32), "");
bytes memory VAR106 = VAR84 bytes(1);
VAR106[0] = FUN68(VAR104);
bytes memory VAR107 = VAR84 bytes(32);
bytes memory VAR108 = VAR84 bytes(32);
bytes32 VAR109 = FUN63();
VAR42 {
FUN33(VAR107, 0x20)
FUN33(FUN1(VAR107, 0x20), FUN69(FUN70(FUN2(VAR110, 1)), FUN69(VAR111, VAR112)))
FUN33(VAR108, 0x20)
FUN33(FUN1(VAR108, 0x20), VAR109)
}
bytes memory VAR113 = VAR84 bytes(32);
bytes[4] memory VAR93 = [VAR107, VAR106, VAR108, VAR113];
bytes32 VAR115 = FUN59("", VAR93, VAR105);
bytes memory VAR116 = VAR84 bytes(8);
FUN73(VAR115, FUN74(VAR117.FUN75(VAR116, VAR93[1], FUN76(VAR93[0]), VAR93[2])));
return VAR115;
}
function FUN73(bytes32 VAR115, bytes32 VAR118) internal {
VAR119[VAR115] = VAR118;
}
mapping(bytes32=>bytes32) VAR119;
mapping(bytes32=>bool) VAR120;
function FUN77(bytes32 VAR121, bytes VAR122, bytes VAR123) internal returns (bool){
bool VAR124;
address VAR125;
bytes32 VAR126;
bytes32 VAR127;
bytes memory VAR128 = VAR84 bytes(32);
uint VAR129 = 4+(uint(VAR122[3]) - 0x20);
VAR128 = FUN71(VAR122, VAR129, 32, VAR128, 0);
bytes memory VAR130 = VAR84 bytes(32);
VAR129 += 32 + 2;
VAR130 = FUN71(VAR122, VAR129+(uint(VAR122[VAR129-1]) - 0x20), 32, VAR130, 0);
VAR42 {
VAR126 := FUN32(FUN1(VAR128, 32))
VAR127 := FUN32(FUN1(VAR130, 32))
}
(VAR124, VAR125) = FUN78(VAR121, 27, VAR126, VAR127);
if (address(FUN74(VAR123)) == VAR125) return true;
else {
(VAR124, VAR125) = FUN78(VAR121, 28, VAR126, VAR127);
return (address(FUN74(VAR123)) == VAR125);
}
}
function FUN79(bytes VAR85, uint VAR131) internal returns (bool) {
bool VAR124;
bytes memory VAR132 = VAR84 bytes(uint(VAR85[VAR131+1])+2);
FUN71(VAR85, VAR131, VAR132.VAR48, VAR132, 0);
bytes memory VAR133 = VAR84 bytes(64);
FUN71(VAR85, 3+1, 64, VAR133, 0);
bytes memory VAR134 = VAR84 bytes(1+65+32);
VAR134[0] = FUN68(1);
FUN71(VAR85, VAR131-65, 65, VAR134, 1);
bytes memory VAR135 = VAR136"";
FUN71(VAR135, 0, 32, VAR134, 1+65);
VAR124 = FUN77(FUN76(VAR134), VAR132, VAR133);
if (VAR124 == false) return false;
bytes memory VAR137 = VAR136"";
bytes memory VAR138 = VAR84 bytes(1+65);
VAR138[0] = 0xFE;
FUN71(VAR85, 3, 65, VAR138, 1);
bytes memory VAR139 = VAR84 bytes(uint(VAR85[3+65+1])+2);
FUN71(VAR85, 3+65, VAR139.VAR48, VAR139, 0);
VAR124 = FUN77(FUN76(VAR138), VAR139, VAR137);
return VAR124;
}
modifier FUN80(bytes32 VAR140, string VAR141, bytes VAR142) {
require((VAR142[0] == "") && (VAR142[1] == "") && (VAR142[2] == 1));
bool VAR143 = FUN81(VAR142, VAR140, bytes(VAR141), FUN66());
require(VAR143);
VAR20;
}
function FUN82(bytes32 VAR140, string VAR141, bytes VAR142) internal returns (uint8){
if ((VAR142[0] != "")||(VAR142[1] != "")||(VAR142[2] != 1)) return 1;
bool VAR143 = FUN81(VAR142, VAR140, bytes(VAR141), FUN66());
if (VAR143 == false) return 2;
return 0;
}
function FUN83(bytes32 VAR144, bytes VAR145, uint VAR146) internal pure returns (bool){
bool VAR147 = true;
require(VAR145.VAR48 == VAR146);
for (uint256 VAR100=0; VAR100< VAR146; VAR100++) {
if (VAR144[VAR100] != VAR145[VAR100]) VAR147 = false;
}
return VAR147;
}
function FUN81(bytes VAR85, bytes32 VAR115, bytes VAR83, string VAR148) internal returns (bool){
uint VAR149 = 3+65+(uint(VAR85[3+65+1])+2)+32;
bytes memory VAR150 = VAR84 bytes(32);
FUN71(VAR85, VAR149, 32, VAR150, 0);
if (!(FUN74(VAR150) == FUN74(VAR117.FUN75(FUN76(VAR117.FUN75(VAR148, VAR115)))))) return false;
bytes memory VAR151 = VAR84 bytes(uint(VAR85[VAR149+(32+8+1+32)+1])+2);
FUN71(VAR85, VAR149+(32+8+1+32), VAR151.VAR48, VAR151, 0);
if (!FUN83(FUN76(VAR151), VAR83, uint(VAR85[VAR149+32+8]))) return false;
bytes memory VAR152 = VAR84 bytes(8+1+32);
FUN71(VAR85, VAR149+32, 8+1+32, VAR152, 0);
bytes memory VAR153 = VAR84 bytes(64);
uint VAR131 = VAR149+32+(8+1+32)+VAR151.VAR48+65;
FUN71(VAR85, VAR131-64, 64, VAR153, 0);
bytes32 VAR154 = FUN76(VAR153);
if (VAR119[VAR115] == FUN74(VAR117.FUN75(VAR152, VAR154))){
delete VAR119[VAR115];
} else return false;
bytes memory VAR155 = VAR84 bytes(32+8+1+32);
FUN71(VAR85, VAR149, 32+8+1+32, VAR155, 0);
if (!FUN77(FUN76(VAR155), VAR151, VAR153)) return false;
if (VAR120[VAR154] == false){
VAR120[VAR154] = FUN79(VAR85, VAR131);
}
return VAR120[VAR154];
}
function FUN71(bytes VAR156, uint VAR157, uint VAR48, bytes VAR158, uint VAR159) internal pure returns (bytes) {
uint VAR160 = VAR48 + VAR159;
require(VAR158.VAR48 >= VAR160);
uint VAR100 = 32 + VAR157;
uint VAR161 = 32 + VAR159;
while (VAR100 < (32 + VAR157 + VAR48)) {
VAR42 {
let VAR162 := FUN32(FUN1(VAR156, VAR100))
FUN33(FUN1(VAR158, VAR161), VAR162)
}
VAR100 += 32;
VAR161 += 32;
}
return VAR158;
}
function FUN78(bytes32 VAR163, uint8 VAR164, bytes32 VAR165, bytes32 VAR166) internal returns (bool, address) {
bool VAR167;
address VAR168;
VAR42 {
let VAR169 := FUN32(0x40)
FUN33(VAR169, VAR163)
FUN33(FUN1(VAR169, 32), VAR164)
FUN33(FUN1(VAR169, 64), VAR165)
FUN33(FUN1(VAR169, 96), VAR166)
VAR167 := call(3000, 1, 0, VAR169, 128, VAR169, 32)
VAR168 := FUN32(VAR169)
}
return (VAR167, VAR168);
}
function FUN84(bytes32 VAR163, bytes VAR12) internal returns (bool, address) {
bytes32 VAR165;
bytes32 VAR166;
uint8 VAR164;
if (VAR12.VAR48 != 65)
return (false, 0);
VAR42 {
VAR165 := FUN32(FUN1(VAR12, 32))
VAR166 := FUN32(FUN1(VAR12, 64))
VAR164 := FUN68(0, FUN32(FUN1(VAR12, 96)))
}
//
if (VAR164 < 27)
VAR164 += 27;
if (VAR164 != 27 && VAR164 != 28)
return (false, 0);
return FUN78(VAR163, VAR164, VAR165, VAR166);
}
function FUN65() internal pure {
VAR42 {
let VAR170 := FUN32(0x40)
FUN85(VAR170, VAR171, FUN2(VAR172, VAR170))
}
}
}
contract UsingOraclizeRandom is VAR173 {
uint public VAR174 = 200000;
uint public VAR175 = 20000000000;
constructor() public {
VAR16 = FUN19(0xdbf98a75f521Cb1BD421c03F2b6A6a617f4240F1);
}
function FUN86(uint VAR176) public VAR18 {
VAR174 = VAR176;
}
function FUN87(uint VAR177) public VAR18 {
VAR175 = VAR177;
FUN62(VAR177);
}
}
interface VAR178 {
function FUN88() external payable;
function FUN89(address, uint) external returns (bool);
function transfer(address, uint) external returns (bool);
function FUN90(address, address, uint) external returns (bool);
}
contract MobiusRandom is VAR179, VAR2 {
uint24 constant public VAR180 = 1000000;
uint16 constant public VAR181 = 150;
uint constant public VAR182 = 6 VAR183;
uint constant public VAR184 = 70;
uint constant public VAR185 = 125;
uint constant public VAR186 = 400;
uint constant public VAR187 = 1 * VAR6 / 6 VAR183;
MobiusToken constant public VAR188 = FUN91(0x54cdC9D889c28f55F59f6b136822868c7d4726fC);
uint public VAR189;
uint public VAR190;
uint public VAR191 = 0.4 VAR192;
uint public VAR193 = 1.5 VAR192;
uint public VAR194 = 100 VAR192;
uint public VAR195 = 2 VAR90;
uint public VAR196 = 10 * VAR6;
uint public VAR197;
struct VAR198 {
uint VAR199;
address VAR200;
}
mapping(bytes32 => VAR198) public VAR201;
mapping(address => uint) public VAR202;
event FUN92(bytes32 VAR115, address indexed VAR200, uint VAR199);
event FUN93(bytes32 VAR115, address indexed VAR200, uint VAR199, uint VAR203);
event FUN94(bytes32 VAR115, address indexed VAR200, uint VAR204);
event FUN95(bytes32 VAR115, uint VAR204);
event FUN96(bytes32 VAR115);
event FUN97(bytes32 VAR115);
constructor() public {
}
function () public payable {
}
function FUN98(uint16 VAR205, uint16 VAR206, bool VAR207) external payable {
bytes32 VAR115 = FUN67(32, VAR174);
address VAR200 = msg.sender;
uint128 VAR204 = uint128(msg.value);
uint VAR199;
require(FUN99(VAR115) == 0, "");
Bet storage VAR208 = VAR201[VAR115];
VAR208.VAR200 = VAR200;
VAR199 = VAR204;
VAR199 = VAR199 << 64;
VAR199 |= FUN100(VAR209);
VAR199 = VAR199 << 16;
VAR199 |= VAR205;
VAR199 = VAR199 << 16;
VAR199 |= VAR206;
VAR199 = VAR199 << 16;
uint VAR210;
uint VAR211;
(VAR210,VAR211) = FUN101(VAR204, VAR205, VAR206, VAR207);
require(VAR210 <= VAR204 + VAR195, "");
if(!VAR207) {
if(VAR204 >= VAR194) {
uint VAR212 = FUN102(VAR200);
VAR199 |= uint16(FUN4(VAR181, 1 + (VAR212 * 25) / VAR6));
VAR190 += VAR211;
}
FUN103(VAR200, VAR204);
}
VAR199 = VAR199 << 16;
VAR199 |= uint16(VAR207 ? 1 : 0);
VAR208.VAR199 = VAR199;
VAR189 += VAR210;
require(VAR190 + VAR189 <= address(this).VAR213, "");
emit FUN92(VAR115, VAR200, VAR199);
}
function FUN104(uint VAR214) external {
address VAR200 = msg.sender;
require(VAR214 <= 4 * VAR6, "");
require(VAR188.FUN90(VAR200, address(this), FUN8(VAR214, VAR196)), "");
FUN103(VAR200, VAR214);
}
function FUN105(bytes32 VAR115) external {
require(FUN106(VAR115) + VAR182 < VAR209, "");
require(FUN99(VAR115) > 0, "");
FUN107(VAR115);
}
function FUN108() external VAR18 {
VAR174 = 200000;
if(FUN50()){
FUN61(VAR68);
}
}
function FUN109(uint VAR215) external VAR18 {
VAR191 = VAR215;
}
function FUN110(uint VAR215) external VAR18 {
VAR193 = VAR215;
}
function FUN111(uint VAR215) external VAR18 {
VAR194 = VAR215;
}
function FUN112(uint VAR215) external VAR18 {
VAR196 = VAR215;
}
function FUN113(uint VAR215) external VAR18 {
VAR195 = VAR215;
}
function FUN114() external VAR18 {
require (VAR189 < 100 VAR192, "");
FUN115(msg.sender);
}
function FUN116(uint VAR204) external VAR18 {
require (VAR204 <= address(this).VAR213, "");
require (VAR190 + VAR189 + VAR204 <= address(this).VAR213, "");
VAR190 += VAR204;
}
function FUN117(uint VAR204) external VAR18 {
require (VAR204 <= address(this).VAR213, "");
require (VAR190 + VAR189 + VAR204 <= address(this).VAR213, "");
msg.sender.transfer(VAR204);
}
function FUN118(address VAR158, uint VAR204) external VAR18 {
require(VAR188.transfer(VAR158, VAR204), "");
}
function FUN88(uint VAR204) external VAR18 {
require (VAR204 <= address(this).VAR213, "");
require (VAR190 + VAR189 + VAR204 <= address(this).VAR213, "");
VAR188.VAR216.value(VAR204)();
VAR197 += VAR204;
}
function FUN57(bytes32 VAR140, string VAR141, bytes VAR142) public {
require(msg.sender == FUN55(), "");
if (FUN82(VAR140, VAR141, VAR142) != 0) {
FUN119(VAR140);
} else {
uint VAR217 = uint(FUN74(VAR117.FUN120(VAR141)));
FUN121(VAR217, VAR140);
}
}
function FUN102(address VAR200) public view returns(uint) {
uint VAR218;
uint VAR219;
(VAR219, VAR218) = FUN122(VAR200);
uint VAR220 = (VAR209 - VAR218) * VAR187;
if(VAR219 > VAR220) {
return VAR219 - VAR220;
} else {
return 0;
}
}
function FUN123() public view
returns(
uint VAR221,
uint VAR222,
uint VAR223,
uint VAR224,
uint VAR225
) {
VAR221 = VAR190;
VAR222 = FUN124();
VAR223 = FUN125();
VAR224 = VAR195;
VAR225 = VAR196;
}
function FUN126(bytes32 VAR115) public view
returns(
uint128 VAR204,
uint64 VAR226,
uint16 VAR205,
uint16 VAR206,
uint16 VAR227,
bool VAR228
) {
uint VAR199 = VAR201[VAR115].VAR199;
return FUN127(VAR199);
}
function FUN127(uint VAR199) public pure
returns(
uint128 VAR204,
uint64 VAR226,
uint16 VAR205,
uint16 VAR206,
uint16 VAR227,
bool VAR228
) {
VAR228 = uint16(VAR199) == 1 ? true : false;
VAR227 = uint16(VAR199 >> 16);
VAR206 = uint16(VAR199 >> 32);
VAR205 = uint16(VAR199 >> 48);
VAR226 = FUN100(VAR199 >> 64);
VAR204 = uint128(VAR199 >> 128);
}
function FUN122(address VAR200) public view returns(uint128 VAR229, uint64 VAR230) {
uint VAR199 = VAR202[VAR200];
VAR230 = FUN100(VAR199);
VAR229 = uint128(VAR199 >> 64);
}
function FUN103(address VAR200, uint VAR204) internal {
uint VAR199 = FUN4(FUN102(VAR200) + VAR204, 5 * VAR6);
VAR199 = VAR199 << 64;
VAR199 |= FUN100(VAR209);
VAR202[VAR200] = VAR199;
}
function FUN121(uint VAR231, bytes32 VAR115) internal {
Bet storage VAR232 = VAR201[VAR115];
address VAR200 = VAR232.VAR200;
uint VAR199 = VAR232.VAR199;
uint128 VAR204;
uint64 VAR226;
uint16 VAR205;
uint16 VAR206;
uint16 VAR227;
bool VAR228;
(VAR204, VAR226, VAR205, VAR206, VAR227, VAR228) = FUN127(VAR199);
require(VAR226 + VAR182 >= VAR209, "");
require(VAR204 > 0, "");
uint VAR210;
uint VAR233;
(VAR210,) = FUN101(VAR204, VAR205, VAR206, VAR228);
if(uint16(VAR231) % VAR205 < VAR206) {
VAR233 += VAR210;
}
if(!VAR228) {
if(VAR204 >= VAR194) {
if(uint16(VAR231 >> 16) % VAR180 < VAR227) {
VAR233 += VAR190 / 2;
VAR190 /= 2;
emit FUN94(VAR115, VAR200, VAR190);
}
}
}
FUN128(VAR115, VAR200, VAR199, VAR233);
if(VAR189 >= VAR210) {
VAR189 -= VAR210;
} else {
VAR189 = 0;
}
}
function FUN128(bytes32 VAR115, address VAR200, uint VAR199, uint VAR203) internal {
uint VAR234 = VAR199 << 128;
VAR201[VAR115].VAR199 = VAR234 >> 128;
if(VAR203 > 0) {
if(!VAR200.FUN129(VAR203)) {
emit FUN95(VAR115, VAR203);
}
}
emit FUN93(VAR115, VAR200, VAR199, VAR203);
}
function FUN107(bytes32 VAR115) internal {
emit FUN96(VAR115);
uint VAR199 = VAR201[VAR115].VAR199;
uint128 VAR204;
uint16 VAR205;
uint16 VAR206;
bool VAR228;
(VAR204, , VAR205, VAR206, , VAR228) = FUN127(VAR199);
uint VAR210;
(VAR210,) = FUN101(VAR204, VAR205, VAR206, VAR228);
FUN128(VAR115, VAR201[VAR115].VAR200, VAR199, VAR204);
if(VAR189 >= VAR210) {
VAR189 -= VAR210;
} else {
VAR189 = 0;
}
}
function FUN119(bytes32 VAR115) internal {
emit FUN97(VAR115);
FUN107(VAR115);
}
function FUN101(uint128 VAR235, uint16 VAR205, uint16 VAR206, bool VAR207)
internal
view
returns(uint VAR236, uint VAR237){
require(VAR206 > 0 && VAR206 <= VAR205, "");
uint VAR238;
if(!VAR207) {
VAR238 = FUN5(VAR235 / VAR184, FUN124());
if(VAR235 >= VAR194){
VAR237 = VAR235 / VAR186;
}
} else {
VAR238 = FUN5(VAR235 / VAR185, FUN125());
}
VAR236 = (VAR235 - VAR238 - VAR237) * VAR205 / VAR206;
require(VAR235 >= VAR238 + VAR237, "");
}
function FUN124() internal view returns(uint) {
return VAR175 * VAR174 + VAR191;
}
function FUN125() internal view returns(uint) {
return VAR175 * VAR174 + VAR193;
}
function FUN99(bytes32 VAR115) internal view returns(uint128 VAR204) {
uint VAR199 = VAR201[VAR115].VAR199;
VAR204 = uint128(VAR199 >> 128);
}
function FUN106(bytes32 VAR115) internal view returns(uint64 VAR239) {
uint VAR199 = VAR201[VAR115].VAR199;
VAR239 = FUN100(VAR199 >> 64);
}
}
1
---------------------------------
254 0xe386b139ed3715ca4b18fd52671bdcea1cdfe4b1.sol
pragma VAR1 ^ 0.4.13;
contract VAR2 {
function FUN1(address VAR3, uint256 VAR4);
}
contract VAR5 {
function FUN2(address VAR6) constant returns(uint256 VAR7);
}
contract VAR8 {
address public VAR9;
address public VAR10;
address public VAR11;
address public VAR12;
function FUN3() payable {
VAR9 = msg.sender;
}
modifier onlyOwner {
require(VAR9 == msg.sender);
VAR13;
}
modifier VAR14 {
require(VAR9 == msg.sender || VAR11 == msg.sender);
VAR13;
}
modifier VAR15 {
require(VAR9 == msg.sender || VAR12 == msg.sender);
VAR13;
}
function FUN4(address VAR6) onlyOwner external {
require(VAR6 != 0);
VAR10 = VAR6;
}
function FUN5() external {
require(VAR10 == msg.sender);
VAR9 = VAR10;
delete VAR10;
}
function FUN6(address VAR16) onlyOwner external {
require(VAR16 != 0);
VAR11 = VAR16;
}
function FUN7(address VAR17) onlyOwner external {
require(VAR17 != 0);
VAR12 = VAR17;
}
}
contract VAR18 {
function FUN8(address VAR19, uint256 VAR4, bytes32[] VAR20) external;
}
contract VAR21 {
uint public VAR22;
function FUN2(address VAR23) constant returns(uint);
function transfer(address VAR24, uint value);
function FUN9(address VAR9, address VAR25) constant returns(uint);
function FUN10(address VAR26, address VAR24, uint value);
function FUN11(address VAR25, uint value);
event FUN12(address indexed VAR9, address indexed VAR25, uint value);
event Transfer(address indexed VAR26, address indexed VAR24, uint value);
}
contract VAR27 {
enum VAR28 {
VAR29,
VAR30,
VAR31,
VAR32,
VAR33,
VAR34,
VAR35
}
State public VAR36 = VAR28.VAR29;
event FUN13(State VAR37, State VAR38);
function FUN14(State VAR38) internal {
State VAR37 = VAR36;
VAR36 = VAR38;
FUN13(VAR37, VAR38);
}
}
contract Crowdsale is VAR8, VAR27 {
uint public VAR39;
address public VAR40;
uint public VAR41;
uint public VAR42;
uint public VAR43;
uint public VAR44;
uint public VAR45;
struct VAR46 {
uint VAR47;
uint VAR48;
}
struct VAR49 {
uint VAR50;
uint VAR51;
address VAR52;
}
mapping(bytes32 => VAR49) public VAR53;
mapping(address => VAR46) public VAR54;
mapping(uint => address) public VAR55;
uint public VAR56;
mapping(uint => address) public VAR57;
uint public VAR58;
function FUN15() payable FUN3() {}
function FUN16(address VAR59, uint VAR60, uint VAR61) internal returns(uint VAR62);
function FUN17() internal;
function FUN18(address VAR63, uint VAR64) internal;
function() payable crowdsaleState VAR65 {
uint VAR66 = msg.value;
uint VAR67 = VAR66 * VAR39 / 1 VAR68;
uint VAR69 = FUN19(VAR67);
if (VAR43 + VAR67 > VAR41) {
VAR67 = VAR41 - VAR43;
VAR66 = VAR67 * 1 VAR68 / VAR39;
uint VAR70 = msg.value - VAR66;
bool VAR71 = msg.sender.call.FUN20(3000000).value(VAR70)();
require(VAR71);
VAR43 = VAR41;
} else {
VAR43 += VAR67;
}
FUN21(msg.sender, VAR69, VAR67, VAR66);
}
function FUN22(address VAR72, uint VAR73) external onlyOwner crowdsaleState VAR65 {
uint VAR69 = FUN19(VAR73);
VAR43 += VAR73;
FUN21(VAR72, VAR69, VAR73, 0);
}
function FUN23(address VAR72, uint VAR74, uint VAR75, bytes32 VAR76) external onlyOwnerOrBtcOracle crowdsaleState VAR65 {
uint VAR67 = VAR74 * VAR75 / 1 VAR68;
uint VAR69 = FUN19(VAR67);
BtcDeposit storage VAR77 = VAR53[VAR76];
require(VAR77.VAR50 == 0);
VAR77.VAR50 = VAR74;
VAR77.VAR51 = VAR75;
VAR77.VAR52 = VAR72;
VAR43 += VAR67;
FUN21(VAR72, VAR69, VAR67, 0);
}
function FUN21(address VAR59, uint VAR60, uint VAR78, uint VAR79) internal {
var VAR80 = FUN16(VAR59, VAR60, VAR78);
Investor storage VAR81 = VAR54[VAR59];
if (VAR81.VAR47 == 0) {
VAR55[VAR56++] = VAR59;
}
VAR81.VAR47 += VAR80;
if (VAR36 == VAR28.VAR33) {
VAR81.VAR48 += VAR79;
}
}
function FUN19(uint VAR78) internal returns(uint VAR69) {
VAR69 = 0;
if (VAR36 == VAR28.VAR30) {
VAR69 = 6000000000000000;
}
if (VAR36 == VAR28.VAR31) {
require(VAR82 < VAR45);
VAR69 = 7000000000000000;
}
if (VAR36 == VAR28.VAR33) {
require(VAR82 < VAR45);
if (VAR82 < VAR44 + 1 VAR83) {
if (VAR78 > 30000 * 1 VAR68) {
VAR69 = 7500000000000000;
} else {
VAR69 = 8500000000000000;
}
} else if (VAR82 < VAR44 + 1 VAR84) {
VAR69 = 9000000000000000;
} else if (VAR82 < VAR44 + 2 VAR84) {
VAR69 = 9500000000000000;
} else {
VAR69 = 10000000000000000;
}
}
}
function FUN24(address VAR85, uint VAR86, uint VAR87) external onlyOwner {
require(VAR36 == VAR28.VAR29);
VAR40 = VAR85;
VAR39 = VAR86;
VAR41 = VAR87;
VAR44 = VAR82;
FUN14(VAR28.VAR30);
}
function FUN25(
address VAR85,
uint VAR86,
uint VAR87,
uint VAR88) public onlyOwner {
require(VAR36 == VAR28.VAR30);
bool VAR71 = VAR40.call.FUN20(3000000).value(this.VAR7)();
require(VAR71);
VAR44 = VAR82;
VAR40 = VAR85;
VAR39 = VAR86;
VAR41 = VAR87;
VAR45 = VAR82 + VAR88 * 1 VAR83;
VAR43 = 0;
FUN14(VAR28.VAR31);
}
function FUN26() public onlyOwner {
require(VAR36 == VAR28.VAR31);
bool VAR71 = VAR40.call.FUN20(3000000).value(this.VAR7)();
require(VAR71);
FUN14(VAR28.VAR32);
}
function FUN27(
address VAR85,
uint VAR86,
uint VAR87,
uint VAR88,
uint VAR89) external onlyOwner {
require(VAR36 == VAR28.VAR32);
VAR44 = VAR82;
VAR40 = VAR85;
VAR39 = VAR86;
VAR41 = VAR87;
VAR45 = VAR82 + VAR88 * 1 VAR83;
VAR42 = VAR89;
VAR43 = 0;
FUN14(VAR28.VAR33);
}
function FUN28(uint VAR90) public {
require(VAR36 == VAR28.VAR33);
require(VAR82 >= VAR45 && VAR43 < VAR42);
while (VAR90 > 0 && VAR56 > 0) {
address VAR91 = VAR55[--VAR56];
Investor memory VAR81 = VAR54[VAR91];
FUN18(VAR91, VAR81.VAR47);
--VAR90;
delete VAR55[VAR56];
VAR57[VAR58] = VAR91;
VAR58++;
}
if (VAR56 > 0) {
return;
}
FUN14(VAR28.VAR35);
}
function FUN29(uint VAR90) public onlyOwner {
require(VAR36 == VAR28.VAR33);
require(VAR43 >= VAR42);
while (VAR90 > 0 && VAR56 > 0) {
--VAR56;
--VAR90;
delete VAR54[VAR55[VAR56]];
delete VAR55[VAR56];
}
if (VAR56 > 0) {
return;
}
FUN17();
bool VAR71 = VAR40.call.FUN20(3000000).value(this.VAR7)();
require(VAR71);
FUN14(VAR28.VAR34);
}
function FUN30(uint VAR86) external VAR14 {
VAR39 = VAR86;
}
function FUN31(address VAR85) external onlyOwner {
require(VAR85 != 0);
VAR40 = VAR85;
}
function FUN32() external VAR92 {
FUN33(msg.sender);
}
function FUN34(uint VAR90) public VAR92 {
while (VAR90 > 0 && VAR58 > 0) {
address VAR91 = VAR57[--VAR58];
delete VAR57[VAR58];
--VAR90;
FUN33(VAR91);
}
}
function FUN35(address VAR72) public VAR92 {
FUN33(VAR72);
}
function FUN33(address VAR72) internal {
Investor memory VAR81 = VAR54[VAR72];
uint value = VAR81.VAR48;
if (value > 0) {
delete VAR54[VAR72];
require(VAR72.call.FUN20(3000000).value(value)());
}
}
function FUN36(uint VAR4) public onlyOwner {
require(VAR36 == VAR28.VAR30 || VAR36 == VAR28.VAR31 || (VAR36 == VAR28.VAR33 && VAR43 > VAR42));
if (VAR4 == 0) {
VAR4 = this.VAR7;
}
bool VAR71 = VAR40.call.FUN20(3000000).value(VAR4)();
require(VAR71);
}
modifier VAR65 {
require(VAR43 < VAR41);
VAR13;
}
modifier VAR93 {
require(VAR36 == VAR28.VAR30 || VAR36 == VAR28.VAR31 || VAR36 == VAR28.VAR33);
VAR13;
}
modifier VAR92 {
require(VAR36 == VAR28.VAR35);
VAR13;
}
modifier VAR94 {
require(VAR36 == VAR28.VAR34);
VAR13;
}
}
contract Token is VAR95, VAR21 {
mapping(address => uint) internal VAR96;
mapping(address => mapping(address => uint)) public VAR97;
uint8 public constant VAR98 = 8;
function FUN37() payable FUN15() {}
function FUN2(address VAR23) constant returns(uint) {
return VAR96[VAR23];
}
function transfer(address VAR72, uint VAR4) public VAR94 FUN38(2 * 32) {
require(VAR96[msg.sender] >= VAR4);
require(VAR96[VAR72] + VAR4 >= VAR96[VAR72]);
VAR96[msg.sender] -= VAR4;
VAR96[VAR72] += VAR4;
Transfer(msg.sender, VAR72, VAR4);
}
function FUN10(address VAR3, address VAR72, uint VAR4) public VAR94 FUN38(3 * 32) {
require(VAR96[VAR3] >= VAR4);
require(VAR96[VAR72] + VAR4 >= VAR96[VAR72]);
require(VAR97[VAR3][msg.sender] >= VAR4);
VAR96[VAR3] -= VAR4;
VAR96[VAR72] += VAR4;
VAR97[VAR3][msg.sender] -= VAR4;
Transfer(VAR3, VAR72, VAR4);
}
function FUN11(address VAR99, uint VAR4) public VAR94 {
VAR97[msg.sender][VAR99] = VAR4;
FUN12(msg.sender, VAR99, VAR4);
}
function FUN9(address VAR6, address VAR99) public constant VAR94 returns(uint VAR100) {
return VAR97[VAR6][VAR99];
}
modifier FUN38(uint VAR101) {
require(msg.VAR102.VAR103 >= VAR101 + 4);
VAR13;
}
}
contract MigratableToken is VAR104 {
function FUN39() payable FUN37() {}
address public VAR105;
uint public VAR106;
address public VAR107;
mapping(address => bool) VAR108;
event FUN40(address indexed VAR26, address indexed VAR24, uint value);
function FUN41(address VAR63) external onlyOwner {
require(VAR63 != 0);
VAR107 = VAR63;
}
function FUN42(address VAR63) external onlyOwner {
require(VAR107 != 0 && VAR36 != VAR28.VAR35 && VAR108[VAR63] == false);
PreZeusToken VAR109 = FUN43(VAR107);
uint VAR110 = VAR109.FUN2(VAR63);
require(VAR110 > 0);
VAR96[VAR63] = VAR110;
VAR22 += VAR110;
VAR108[VAR63] = true;
if (VAR36 != VAR28.VAR34) {
Investor storage VAR81 = VAR54[VAR63];
VAR55[VAR56++] = VAR63;
VAR81.VAR47 += VAR110;
}
Transfer(this, VAR63, VAR110);
}
function FUN44() external {
require(VAR105 != 0);
uint value = VAR96[msg.sender];
VAR96[msg.sender] -= value;
Transfer(msg.sender, this, value);
VAR22 -= value;
VAR106 += value;
FUN45(VAR105).FUN1(msg.sender, value);
FUN40(msg.sender, VAR105, value);
}
function FUN46(address VAR111) external onlyOwner {
require(VAR105 == 0);
VAR105 = VAR111;
}
}
contract ZeusToken is VAR112 {
string public constant VAR113 = "";
string public constant VAR114 = "";
mapping(address => bool) public VAR115;
function FUN47() payable FUN39() {}
function FUN16(address VAR59, uint VAR60, uint VAR78) internal returns(uint VAR62) {
VAR62 = (VAR78 * (10 ** uint(VAR98))) / VAR60;
require(VAR96[VAR59] + VAR62 > VAR96[VAR59]);
require(VAR62 > 0);
VAR96[VAR59] += VAR62;
VAR22 += VAR62;
Transfer(this, VAR59, VAR62);
}
function FUN17() internal {
uint VAR62 = VAR22 * 1000 / 705 - VAR22;
require(VAR96[VAR40] + VAR62 > VAR96[VAR40]);
require(VAR62 > 0);
VAR96[VAR40] += VAR62;
VAR22 += VAR62;
Transfer(this, VAR40, VAR62);
}
function FUN18(address VAR63, uint VAR64) internal {
VAR96[VAR63] -= VAR64;
VAR22 -= VAR64;
Transfer(VAR63, this, VAR64);
}
function FUN48(address VAR63) external onlyOwner {
require(VAR63 != 0);
VAR115[VAR63] = true;
}
function FUN49(address VAR63) external onlyOwner {
require(VAR63 != 0);
delete VAR115[VAR63];
}
function FUN50(address VAR72, uint256 VAR4, bytes32[] VAR20) external FUN51(VAR72) {
var VAR116 = FUN52(VAR72);
transfer(VAR72, VAR4);
VAR116.FUN8(msg.sender, VAR4, VAR20);
}
modifier FUN51(address VAR63) {
require(VAR115[VAR63] == true);
VAR13;
}
}
1
---------------------------------
255 0xe459238ede66ab1b2b19c9acf37dca27b922d191.sol
pragma VAR1 ^0.4.25;
interface VAR2 {
function FUN1(string VAR3) public payable;
}
contract VAR4 {
modifier VAR5 {
require(FUN2() > 0);
VAR6;
}
modifier VAR7 {
require(FUN3(true) > 0);
VAR6;
}
modifier onlyOwner{
require(msg.sender == VAR8, "");
VAR6;
}
event FUN4(
uint256 VAR9,
string VAR10,
address indexed VAR11,
uint VAR12
);
event FUN5(
uint256 VAR13,
address indexed VAR11,
address indexed VAR14,
uint VAR12
);
event FUN6(
address indexed VAR15,
address indexed VAR16,
uint VAR12
);
event FUN7(
address indexed VAR17,
address indexed VAR18,
uint VAR19
);
event FUN8(
address indexed VAR11,
uint256 VAR20,
uint256 VAR21,
address indexed VAR22,
uint VAR12,
uint256 VAR23
);
event FUN9(
address indexed VAR11,
uint256 VAR24,
uint256 VAR25,
uint VAR12,
uint256 VAR23
);
event FUN10(
address indexed VAR11,
uint256 VAR26,
uint256 VAR21
);
event FUN11(
address indexed VAR11,
uint256 VAR27
);
event Transfer(
address indexed VAR28,
address indexed VAR29,
uint256 VAR19
);
string public VAR30 = "";
string public VAR31 = "";
uint8 constant public VAR32 = 18;
uint8 constant internal VAR33 = 15;
uint8 constant internal VAR34 = 0;
uint8 constant internal VAR35 = 5;
uint8 constant internal VAR36 = 15;
uint256 constant internal VAR37 = 0.0000001 VAR38;
uint256 constant internal VAR39 = 0.00000001 VAR38;
uint256 constant internal VAR40 = 2 ** 64;
uint256 public VAR41 = 50e18;
mapping(address => uint256) internal VAR42;
mapping(address => uint256) internal VAR43;
mapping(address => VAR44) internal VAR45;
mapping(address => address) internal VAR46;
mapping(address => mapping (address => uint256)) VAR47;
uint256 internal VAR48;
uint256 internal VAR49;
address private VAR8=msg.sender;
mapping(address => uint256) internal VAR50;
uint private constant VAR51 = 365 VAR52;
uint8 constant internal VAR53 = 9;
uint8 constant internal VAR54 = 1;
address public VAR55=msg.sender;
address public VAR56=0x82956Ff0F6F439C9a355D49CCAa6450C90064847;
uint256 public VAR57;
uint256 public VAR58;
function FUN12(address VAR59) public onlyOwner{
require(VAR59 != address(0));
VAR8 = VAR59;
}
function FUN13(address VAR60) public onlyOwner{
require(VAR60 != address(0));
VAR55 = VAR60;
}
function FUN1(string VAR3) public payable {
FUN14(msg.value,VAR3);
}
function FUN14(uint256 VAR61,string VAR3) internal {
address VAR62 = msg.sender;
uint256 VAR63 = VAR61;
if (VAR48 > 0) {
VAR49 += (VAR63 * VAR40 / VAR48);
}
emit FUN4(VAR63,VAR3,VAR62,VAR64);
}
function FUN15(address VAR65) public {
address VAR62 = VAR65;
require(VAR50[VAR62]!=0 && VAR64 >= VAR66.FUN16(VAR50[VAR62],VAR51), "");
uint256 VAR67 = VAR42[VAR62];
if (VAR67 > 0) FUN17(VAR67);
uint256 VAR63 = FUN18(VAR62);
VAR63 += VAR43[VAR62];
FUN14(VAR63,'');
delete VAR42[VAR62];
delete VAR43[VAR62];
delete VAR45[VAR62];
delete VAR50[VAR62];
emit FUN5(VAR63,VAR62,msg.sender,VAR64);
}
function FUN19() public{
require(VAR57>0 && VAR58>0, "");
VAR55.transfer(VAR57);
DevsInterface VAR68 = FUN20(VAR56);
VAR68.VAR69.value(VAR58)('');
VAR57=0;
VAR58=0;
}
function FUN21(address VAR70, address VAR71, uint256 VAR72) public returns (bool VAR73) {
uint256 VAR74 = VAR47[VAR70][msg.sender];
require(VAR42[VAR70] >= VAR72 && VAR74 >= VAR72);
VAR42[VAR71] =VAR66.FUN16(VAR42[VAR71],VAR72);
VAR42[VAR70] = VAR66.FUN22(VAR42[VAR70],VAR72);
VAR47[VAR70][msg.sender] = VAR66.FUN22(VAR47[VAR70][msg.sender],VAR72);
emit Transfer(VAR70, VAR71, VAR72);
return true;
}
function FUN23(address VAR75, uint256 VAR72) public returns (bool VAR73) {
VAR47[msg.sender][VAR75] = VAR72;
emit FUN7(msg.sender, VAR75, VAR72);
return true;
}
function FUN24(address VAR76, address VAR75) public view returns (uint256 VAR77) {
return VAR47[VAR76][VAR75];
}
function FUN25(address VAR78) public payable returns (uint256) {
FUN26(msg.value, VAR78);
}
function() payable public {
if (msg.value == 1e10) {
FUN27();
}
else if (msg.value == 2e10) {
FUN28();
}
else if (msg.value == 3e10) {
FUN29();
}
else {
FUN26(msg.value, 0x0);
}
}
function FUN27() onlyStronghands public {
uint256 VAR63 = FUN3(false);
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
VAR45[VAR62] +=  (VAR44) (VAR63 * VAR40);
VAR63 += VAR43[VAR62];
VAR43[VAR62] = 0;
uint256 VAR67 = FUN26(VAR63, 0x0);
emit FUN10(VAR62, VAR63, VAR67);
}
function FUN29() public {
address VAR62 = msg.sender;
uint256 VAR67 = VAR42[VAR62];
if (VAR67 > 0) FUN17(VAR67);
FUN28();
}
function FUN28() onlyStronghands public {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
uint256 VAR63 = FUN3(false);
VAR45[VAR62] += (VAR44) (VAR63 * VAR40);
VAR63 += VAR43[VAR62];
VAR43[VAR62] = 0;
VAR62.transfer(VAR63);
emit FUN11(VAR62, VAR63);
}
function FUN17(uint256 VAR79) onlyBagholders public {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
require(VAR79 <= VAR42[VAR62]);
uint256 VAR67 = VAR79;
uint256 VAR80 = FUN30(VAR67);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR35), 100);
uint256 VAR81 = VAR66.FUN22(VAR80, VAR63);
VAR48 = VAR66.FUN22(VAR48, VAR67);
VAR42[VAR62] = VAR66.FUN22(VAR42[VAR62], VAR67);
int256 VAR82 = (VAR44) (VAR49 * VAR67 + (VAR81 * VAR40));
VAR45[VAR62] -= VAR82;
if (VAR48 > 0) {
VAR49 = VAR66.FUN16(VAR49, (VAR63 * VAR40) / VAR48);
}
emit FUN9(VAR62, VAR67, VAR81, VAR64, FUN33());
}
function transfer(address VAR83, uint256 VAR79) onlyBagholders public returns (bool) {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
if (VAR79>VAR41) {
VAR50[VAR83] = VAR64;
}
require(VAR79 <= VAR42[VAR62]);
if (FUN3(true) > 0) {
FUN28();
}
uint256 VAR84 = VAR66.FUN31(VAR66.FUN32(VAR79, VAR34), 100);
uint256 VAR85 = VAR66.FUN22(VAR79, VAR84);
uint256 VAR63 = FUN30(VAR84);
VAR48 = VAR66.FUN22(VAR48, VAR84);
VAR42[VAR62] = VAR66.FUN22(VAR42[VAR62], VAR79);
VAR42[VAR83] = VAR66.FUN16(VAR42[VAR83], VAR85);
VAR45[VAR62] -= (VAR44) (VAR49 * VAR79);
VAR45[VAR83] += (VAR44) (VAR49 * VAR85);
VAR49 = VAR66.FUN16(VAR49, (VAR63 * VAR40) / VAR48);
emit Transfer(VAR62, VAR83, VAR85);
return true;
}
function FUN34() public view returns (uint256) {
return address(this).VAR86;
}
function FUN35() public view returns (uint256) {
return VAR48;
}
function FUN36(address VAR62) public view returns (address) {
return VAR46[VAR62];
}
function FUN2() public view returns (uint256) {
address VAR62 = msg.sender;
return FUN37(VAR62);
}
function FUN3(bool VAR87) public view returns (uint256) {
address VAR62 = msg.sender;
return VAR87 ? FUN18(VAR62) + VAR43[VAR62] : FUN18(VAR62) ;
}
function FUN37(address VAR62) public view returns (uint256) {
return VAR42[VAR62];
}
function FUN18(address VAR62) public view returns (uint256) {
return (uint256) ((VAR44) (VAR49 * VAR42[VAR62]) - VAR45[VAR62]) / VAR40;
}
function FUN38() public view returns (uint256) {
if (VAR48 == 0) {
return VAR37 - VAR39;
} else {
uint256 VAR80 = FUN30(1e18);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR35), 100);
uint256 VAR81 = VAR66.FUN22(VAR80, VAR63);
return VAR81;
}
}
function FUN33() public view returns (uint256) {
if (VAR48 == 0) {
return VAR37 + VAR39;
} else {
uint256 VAR80 = FUN30(1e18);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR33), 100);
uint256 VAR81 = VAR66.FUN16(VAR80, VAR63);
return VAR81;
}
}
function FUN39(uint256 VAR88) public view returns (uint256) {
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR88, VAR33), 100);
uint256 VAR81 = VAR66.FUN22(VAR88, VAR63);
uint256 VAR79 = FUN40(VAR81);
return VAR79;
}
function FUN41(uint256 VAR89) public view returns (uint256) {
require(VAR89 <= VAR48);
uint256 VAR80 = FUN30(VAR89);
uint256 VAR63 = VAR66.FUN31(VAR66.FUN32(VAR80, VAR35), 100);
uint256 VAR81 = VAR66.FUN22(VAR80, VAR63);
return VAR81;
}
function FUN26(uint256 VAR90, address VAR78) internal returns (uint256) {
address VAR62 = msg.sender;
VAR50[VAR62] = VAR64;
uint256 VAR91 = VAR66.FUN31(VAR66.FUN32(VAR90, VAR33-VAR53-VAR54), 100);
uint256 VAR92 = VAR66.FUN31(VAR66.FUN32(VAR90, VAR53), 100);
uint256 VAR93 = VAR66.FUN31(VAR66.FUN32(VAR90, VAR54), 100);
uint256 VAR94 = VAR66.FUN31(VAR66.FUN32(VAR91, VAR36), 100);
uint256 VAR63 = VAR66.FUN22(VAR91, VAR94);
uint256 VAR81 = VAR66.FUN22(VAR66.FUN22(VAR66.FUN22(VAR90, VAR91),VAR92),VAR93);
uint256 VAR79 = FUN40(VAR81);
uint256 VAR95 = VAR63 * VAR40;
require(VAR79 > 0 && VAR66.FUN16(VAR79, VAR48) > VAR48);
if (
VAR78 != 0x0000000000000000000000000000000000000000 &&
VAR78 != VAR62 &&
VAR42[VAR78] >= VAR41 &&
VAR46[VAR62] == 0x0
) {
VAR46[VAR62] = VAR78;
emit FUN6(VAR62,VAR78, VAR64);
}
if (
VAR46[VAR62] != 0x0 &&
VAR42[VAR46[VAR62]] >= VAR41
) {
VAR43[VAR78] = VAR66.FUN16(VAR43[VAR78], VAR94);
} else {
VAR63 = VAR66.FUN16(VAR63, VAR94);
VAR95 = VAR63 * VAR40;
}
if (VAR48 > 0) {
VAR48 = VAR66.FUN16(VAR48, VAR79);
VAR49 += (VAR63 * VAR40 / VAR48);
VAR95 = VAR95 - (VAR95 - (VAR79 * (VAR63 * VAR40 / VAR48)));
} else {
VAR48 = VAR79;
}
VAR42[VAR62] = VAR66.FUN16(VAR42[VAR62], VAR79);
int256 VAR82 = (VAR44) (VAR49 * VAR79 - VAR95);
VAR45[VAR62] += VAR82;
VAR57=VAR66.FUN16(VAR57,VAR92);
VAR58=VAR66.FUN16(VAR58,VAR93);
if (VAR57>1e17){
FUN19();
}
emit FUN8(VAR62, VAR90, VAR79, VAR78, VAR64, FUN33());
return VAR79;
}
function FUN40(uint256 VAR80) internal view returns (uint256) {
uint256 VAR96 = VAR37 * 1e18;
uint256 VAR97 =
(
(
VAR66.FUN22(
(VAR98
(
(VAR96 ** 2)
+
(2 * (VAR39 * 1e18) * (VAR80 * 1e18))
+
((VAR39 ** 2) * (VAR48 ** 2))
+
(2 * VAR39 * VAR96*VAR48)
)
), VAR96
)
) / (VAR39)
) - (VAR48);
return VAR97;
}
function FUN30(uint256 VAR67) internal view returns (uint256) {
uint256 VAR99 = (VAR67 + 1e18);
uint256 VAR100 = (VAR48 + 1e18);
uint256 VAR101 =
(
VAR66.FUN22(
(
(
(
VAR37 + (VAR39 * (VAR100 / 1e18))
) - VAR39
) * (VAR99 - 1e18)
), (VAR39 * ((VAR99 ** 2 - VAR99) / 1e18)) / 2
)
/ 1e18);
return VAR101;
}
function FUN42(uint256 VAR102) internal pure returns (uint256 VAR103) {
uint256 VAR104 = (VAR102 + 1) / 2;
VAR103 = VAR102;
while (VAR104 < VAR103) {
VAR103 = VAR104;
VAR104 = (VAR102 / VAR104 + VAR104) / 2;
}
}
}
library VAR66 {
function FUN32(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
if (VAR105 == 0) {
return 0;
}
uint256 VAR107 = VAR105 * VAR106;
assert(VAR107 / VAR105 == VAR106);
return VAR107;
}
function FUN31(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
uint256 VAR107 = VAR105 / VAR106;
return VAR107;
}
function FUN22(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
assert(VAR106 <= VAR105);
return VAR105 - VAR106;
}
function FUN16(uint256 VAR105, uint256 VAR106) internal pure returns (uint256) {
uint256 VAR107 = VAR105 + VAR106;
assert(VAR107 >= VAR105);
return VAR107;
}
}
1
---------------------------------
256 0xe5ed4bd856790dde4de0dd411afcd0221256fd08.sol
pragma VAR1 ^0.4.10;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function transfer(address VAR7, uint256 VAR8) public returns (bool);
function FUN5() payable public;
function FUN6(address VAR9) public constant returns (uint256);
function FUN7(address VAR10) public constant returns (uint256 VAR11);
function FUN8() public returns (bool);
}
contract VAR12 {
SkrillaTokenInterface private VAR13;
address public VAR14;
uint256 public VAR15;
uint256 public VAR16;
bool public VAR17;
bool public VAR18;
bool public VAR19;
uint256 public VAR20;
address public VAR21;
mapping(address => uint256) public VAR22;
event FUN9(address indexed VAR7,  uint256 VAR23);
event FUN10(address indexed VAR7, uint256 VAR23);
event FUN11(uint256 VAR24, uint256 VAR25);
event FUN12(address indexed VAR7, uint256 VAR25);
modifier onlyOwner() {
assert(msg.sender == VAR21);  VAR26;
}
modifier FUN13() {
assert(!VAR18);  VAR26;
}
modifier FUN14() {
assert(VAR18); VAR26;
}
modifier FUN15() {
assert(VAR19); VAR26;
}
modifier FUN16() {
require(VAR27 >= VAR16 || VAR17);
VAR26;
}
modifier FUN17() {
require(!VAR17);
VAR26;
}
function FUN18(address VAR28,
address VAR10,
uint256 VAR29) {
VAR14 = VAR28;
VAR21 = VAR10;
assert(VAR14 != address(0));
assert(VAR21 != address(0));
VAR13 = FUN19(VAR28);
VAR16 = VAR29;
VAR20 = 0;
VAR18 = false;
VAR19 = false;
VAR17 = false;
}
function() external payable {
FUN20();
}
function FUN20() payable public VAR30 {
assert(msg.value > 0);
VAR22[msg.sender] = VAR2.FUN4(VAR22[msg.sender], msg.value);
VAR20 = VAR2.FUN4(VAR20, msg.value);
FUN9(msg.sender, msg.value);
}
function FUN21(address VAR31) external constant returns (uint256 VAR32) {
return VAR22[VAR31];
}
function FUN22() external onlyWhenTokensNotPurchased onlyOwner {
VAR17 = true;
}
function FUN5() external onlyWhenRefundsNotEnabled onlyWhenTokensNotPurchased onlyOwner {
require(this.VAR11 >= VAR20);
VAR13.VAR33.value(this.VAR11)();
VAR15 = VAR13.FUN6(this);
VAR18 = true;
FUN11(VAR20, VAR13.FUN7(this));
}
function FUN23() external onlyWhenTokensPurchased onlyOwner {
assert(VAR13.FUN8());
VAR19 = true;
}
function FUN24() external VAR34 {
uint256 VAR25 = VAR2.FUN2(VAR2.FUN1(VAR22[msg.sender], VAR15), 1 VAR35);
assert(VAR25 > 0);
VAR20 = VAR2.FUN3(VAR20, VAR22[msg.sender]);
VAR22[msg.sender] = 0;
assert(VAR13.transfer( msg.sender, VAR25));
FUN12(msg.sender, VAR25);
}
function FUN25() external whenRefundIsPermitted VAR30 {
uint256 VAR36 = VAR22[msg.sender];
assert(VAR36 > 0);
VAR22[msg.sender] = 0;
VAR20 = VAR2.FUN3(VAR20, VAR36);
msg.sender.transfer(VAR36);
FUN10(msg.sender, VAR36);
}
}
1
---------------------------------
257 0xe610af01f92f19679327715b426c35849c47c657.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address => uint) public VAR3;
uint public VAR4 = 1 VAR5;
Log VAR6;
uint VAR7;
function FUN1(address VAR8)
public
{
VAR6 = FUN2(VAR8);
}
function FUN3(address VAR9)
public
payable
{
VAR3[VAR9]+=msg.value;
VAR6.FUN4(msg.sender,msg.value,"");
VAR7 = VAR10.VAR11;
}
function FUN5(uint VAR12)
public
payable
{
if(VAR3[msg.sender]>=VAR4 && VAR12<=VAR3[msg.sender] && VAR10.VAR11>VAR7)
{
if(msg.sender.call.value(VAR12)())
{
VAR3[msg.sender]-=VAR12;
VAR6.FUN4(msg.sender,VAR12,"");
}
}
}
function()
public
payable
{
FUN3(msg.sender);
}
}
contract VAR13
{
struct VAR14
{
address VAR15;
string  VAR16;
uint VAR17;
uint  VAR18;
}
VAR14[] public VAR19;
Message VAR20;
function FUN4(address VAR21,uint VAR22,string VAR23)
public
{
VAR20.VAR15 = VAR21;
VAR20.VAR18 = VAR24;
VAR20.VAR17 = VAR22;
VAR20.VAR16 = VAR23;
VAR19.FUN6(VAR20);
}
}
1
---------------------------------
258 0xe63760e74ffd44ce7abdb7ca2e7fa01b357df460.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR3)
throw;
VAR4;
}
modifier protected() {
if(msg.sender != address(this))
throw;
VAR4;
}
function FUN2(address VAR5) public onlyOwner {
if (VAR5 == address(0))
throw;
VAR3 = VAR5;
}
}
contract DividendDistributorv2 is VAR2{
event Transfer(
uint VAR6,
bytes32 VAR7,
address VAR8,
address VAR9
);
struct VAR10 {
uint VAR11;
uint VAR12;
}
mapping(address => VAR10) VAR13;
uint public VAR14;
uint public VAR15;
uint public VAR16;
function FUN3() public{
VAR14 = 0.4 VAR17;
}
function FUN4(uint VAR6, bytes32 VAR7, address VAR8, address VAR9) protected
{
if(! VAR8.call.value(VAR6)() )
throw;
Transfer(VAR6, VAR7, VAR8, VAR9);
}
function FUN5() public payable {
if (msg.value >= VAR14)
{
VAR13[msg.sender].VAR11 += msg.value;
VAR15 += msg.value;
VAR13[msg.sender].VAR12 = VAR16;
}
}
function FUN6(uint VAR6) public {
if ( VAR13[msg.sender].VAR11 == 0 || VAR6 == 0)
throw;
VAR13[msg.sender].VAR11 -= VAR6;
VAR15 -= VAR6;
this.FUN4(VAR6, "", msg.sender, VAR3);
}
function FUN7() constant public returns(uint VAR18) {
uint VAR12 = VAR13[msg.sender].VAR12;
if (VAR16 > VAR12)
throw;
VAR18 = (VAR16 - VAR12) * VAR13[msg.sender].VAR11 / VAR15;
}
function FUN8() constant public returns(uint VAR11) {
VAR11 = VAR13[msg.sender].VAR11;
}
function FUN9() public {
uint VAR18 = FUN7();
if (VAR18 == 0)
throw;
VAR13[msg.sender].VAR12 = VAR16;
this.FUN4(VAR18, "", msg.sender, VAR3);
}
function FUN10() public payable onlyOwner {
VAR16 += msg.value;
}
function FUN11(address VAR8, uint VAR6) public onlyOwner {
this.FUN4(VAR6, "", VAR8, VAR3);
}
function FUN12(uint VAR6) public onlyOwner {
VAR14 = VAR6;
}
function () public payable onlyOwner {
}
function FUN13() public onlyOwner {
FUN14(msg.sender);
}
}
1
---------------------------------
259 0xe7dc501cb9ca414cf9211af214d5065ca3a30768.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
function FUN1(address VAR3) public payable;
}
contract VAR4 {
address[] public VAR5;
function FUN2() {
VAR5.VAR6 = 1;
VAR5[0] = msg.sender;
}
modifier FUN3() {
bool VAR7 = false;
for (uint256 VAR8 = 0; VAR8 < VAR5.VAR6; VAR8++) {
if (msg.sender == VAR5[VAR8]) {
VAR7 = true;
}
}
require(VAR7 == true);
VAR9;
}
function FUN4(address VAR10) public VAR11 {
for (uint256 VAR8 = 0; VAR8 < VAR5.VAR6; VAR8++) {
require(VAR10 != VAR5[VAR8]);
}
require(VAR5.VAR6 < 10);
VAR5[VAR5.VAR6++] = VAR10;
}
function FUN5(address VAR10) public VAR11 {
uint256 VAR12 = VAR5.VAR6;
for (uint256 VAR8 = 0; VAR8 < VAR5.VAR6; VAR8++) {
if (VAR10 == VAR5[VAR8]) {
VAR12 = VAR8;
}
}
require(VAR12 < VAR5.VAR6);
if (VAR12 < VAR5.VAR6 - 1) {
VAR5[VAR12] = VAR5[VAR5.VAR6 - 1];
}
VAR5.VAR6--;
}
}
contract VAR13 {
address public VAR14;
function FUN6(address VAR15) {
VAR14 = VAR15;
}
function FUN7(address VAR16) constant returns (uint256) {
return FUN8(VAR14).FUN9('', VAR16);
}
function FUN10(address VAR16, uint256 VAR17) internal {
FUN8(VAR14).FUN11('', VAR16, VAR17);
}
function FUN12() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN14(uint256 VAR18) internal {
FUN8(VAR14).FUN15('', '', VAR18);
}
function FUN16() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN17(uint256 VAR19) internal {
FUN8(VAR14).FUN15('', '', VAR19);
}
function FUN18() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN19(uint256 VAR20) internal {
FUN8(VAR14).FUN15('', '', VAR20);
}
function FUN20(address VAR16) constant returns (uint256) {
return FUN8(VAR14).FUN9('', VAR16);
}
function FUN21(address VAR16, uint256 VAR17) internal {
FUN8(VAR14).FUN11('', VAR16, VAR17);
}
function FUN22() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN23(uint256 VAR21) internal {
FUN8(VAR14).FUN15('', '', VAR21);
}
function FUN24() constant returns (uint256) {
return FUN8(VAR14).FUN13('', '');
}
function FUN25(uint256 VAR22) internal {
FUN8(VAR14).FUN15('', '', VAR22);
}
function FUN26(address VAR23) constant public returns (uint256 VAR24, uint256 VAR25, uint256 VAR26) {
uint256 VAR27 = FUN8(VAR14).FUN9('', VAR23);
VAR26 = FUN27(VAR27);
VAR25 = FUN28(VAR27 >> (64));
VAR24 = FUN28(VAR27 >> (96 + 64));
return;
}
function FUN29(address VAR28, uint256 VAR24, uint256 VAR25, uint256 VAR26) internal {
uint256 VAR29 = FUN27(VAR26) + (VAR25 << 64) + (VAR24 << (96 + 64));
FUN8(VAR14).FUN11('', VAR28, VAR29);
}
}
contract Pausable is VAR4 {
bool public VAR30 = true;
modifier FUN30() {
require(!VAR30);
VAR9;
}
modifier FUN31() {
require(VAR30);
VAR9;
}
function FUN32() onlyAdmins VAR31 {
VAR30 = true;
}
function FUN33() onlyAdmins VAR32 {
VAR30 = false;
}
}
contract VAR33 {
function FUN34() constant returns (uint256);
function FUN35(address VAR16) constant returns (uint256);
function transfer(address VAR34, uint256 VAR35) returns (bool);
event Transfer(address indexed VAR36, address indexed VAR37, uint value);
}
contract ERC223Basic is VAR33 {
function transfer(address VAR37, uint value, bytes VAR38) returns (bool);
}
contract ERC20 is VAR39 {
function FUN12() constant returns (uint256);
function FUN36(address VAR16, address VAR40) constant returns (uint256);
function FUN37(address VAR41, address VAR34, uint VAR35) returns (bool);
function FUN38(address VAR40, uint256 VAR35);
event FUN39(address indexed VAR42, address indexed VAR43, uint256 value);
}
contract VAR44 {
address public VAR42;
function FUN40() {
VAR42 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR42);
VAR9;
}
function FUN41(address VAR45) onlyOwner {
require(VAR45 != address(0));
VAR42 = VAR45;
}
}
contract Power is VAR44, VAR33 {
event FUN42(address indexed VAR46, uint value, bytes32 VAR38);
string public VAR47 = "";
string public VAR48 = "";
uint256 public VAR49 = 12;
function FUN35(address VAR28) constant returns (uint256) {
return FUN43(VAR42).FUN20(VAR28);
}
function FUN34() constant returns (uint256) {
return FUN43(VAR42).FUN44();
}
function FUN12() constant returns (uint256) {
return FUN43(VAR42).FUN22();
}
function FUN45(address VAR28, uint256 VAR35, bytes32 VAR50) public onlyOwner {
FUN42(VAR28, VAR35, VAR50);
}
function FUN46(address VAR28, uint256 VAR35) public onlyOwner {
Transfer(address(0), VAR28, VAR35);
}
function transfer(address VAR34, uint256 VAR51) public returns (bool VAR52) {
require(VAR34 == address(0));
FUN43(VAR42).FUN47(msg.sender, VAR51);
Transfer(msg.sender, address(0), VAR51);
return true;
}
function FUN48() public returns (uint256) {
FUN43(VAR42).VAR53;
}
function FUN49(address VAR16) public {
FUN43(VAR42).FUN49(VAR16, VAR54);
}
function FUN26(address VAR16) constant public returns (uint256, uint256, uint256) {
return FUN43(VAR42).FUN26(VAR16);
}
}
contract Storage is VAR44 {
struct VAR55 {
mapping(bytes32 => uint256) VAR56;
mapping(bytes32 => address) VAR57;
mapping(bytes32 => bool) VAR58;
mapping(address => uint256) VAR59;
}
mapping(bytes32 => VAR55) VAR60;
function FUN15(bytes32 VAR61, bytes32 VAR62, uint256 VAR35) onlyOwner {
VAR60[VAR61].VAR56[VAR62] = VAR35;
}
function FUN13(bytes32 VAR61, bytes32 VAR62) constant returns(uint256) {
return VAR60[VAR61].VAR56[VAR62];
}
function FUN50(bytes32 VAR61, bytes32 VAR62, address VAR35) onlyOwner {
VAR60[VAR61].VAR57[VAR62] = VAR35;
}
function FUN51(bytes32 VAR61, bytes32 VAR62) constant returns(address) {
return VAR60[VAR61].VAR57[VAR62];
}
function FUN52(bytes32 VAR61, bytes32 VAR62, bool VAR35) onlyOwner {
VAR60[VAR61].VAR58[VAR62] = VAR35;
}
function FUN53(bytes32 VAR61, bytes32 VAR62) constant returns(bool) {
return VAR60[VAR61].VAR58[VAR62];
}
function FUN11(bytes32 VAR61, address VAR62, uint256 VAR35) onlyOwner {
VAR60[VAR61].VAR59[VAR62] = VAR35;
}
function FUN9(bytes32 VAR61, address VAR62) constant returns(uint256) {
return VAR60[VAR61].VAR59[VAR62];
}
}
contract NutzEnabled is VAR63, VAR13 {
using SafeMath for uint;
address public VAR64;
modifier FUN54() {
require(msg.sender == VAR64);
VAR9;
}
function FUN55(address VAR65, address VAR15)
FUN6(VAR15) {
VAR64 = VAR65;
}
function FUN34() constant returns (uint256) {
return FUN12();
}
function FUN56() constant returns (uint256) {
return FUN12().FUN57(FUN18()).FUN57(FUN16());
}
mapping (address => mapping (address => uint)) internal VAR66;
function FUN36(address VAR16, address VAR40) constant returns (uint256) {
return VAR66[VAR16][VAR40];
}
function FUN38(address VAR16, address VAR40, uint256 VAR67) public onlyNutz VAR31 {
require(VAR16 != VAR40);
VAR66[VAR16][VAR40] = VAR67;
}
function FUN58(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) internal {
require(VAR34 != address(this));
require(VAR34 != address(0));
require(VAR67 > 0);
require(VAR41 != VAR34);
FUN10(VAR41, FUN7(VAR41).FUN59(VAR67));
FUN10(VAR34, FUN7(VAR34).FUN57(VAR67));
}
function transfer(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public onlyNutz VAR31 {
FUN58(VAR41, VAR34, VAR67, VAR50);
}
function FUN37(address VAR68, address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public onlyNutz VAR31 {
VAR66[VAR41][VAR68] = VAR66[VAR41][VAR68].FUN59(VAR67);
FUN58(VAR41, VAR34, VAR67, VAR50);
}
}
contract VAR69 {
function FUN60(address VAR41, uint VAR35, bytes VAR50);
}
contract VAR70 {
bool public VAR30;
address public VAR64;
function FUN7(address VAR16) constant returns (uint256);
function FUN12() constant returns (uint256);
function FUN16() constant returns (uint256);
function FUN18() constant returns (uint256);
function FUN34() constant returns (uint256);
function FUN56() constant returns (uint256);
function FUN36(address VAR16, address VAR40) constant returns (uint256);
function FUN38(address VAR16, address VAR40, uint256 VAR67) public;
function transfer(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public;
function FUN37(address VAR68, address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public;
function FUN61() constant returns (uint256);
function FUN62() constant returns (uint256);
function FUN63(address VAR68, uint256 VAR35, uint256 VAR71) public returns (uint256);
function FUN64(address VAR41, uint256 VAR71, uint256 VAR67);
function FUN20(address VAR16) constant returns (uint256);
function FUN22() constant returns (uint256);
function FUN24() constant returns (uint256);
function FUN44() constant returns (uint256);
function FUN46(address VAR68, address VAR41, uint256 VAR67) public;
function FUN49(address VAR16, uint256 VAR72) public;
function FUN47(address VAR16, uint256 VAR51) public;
function FUN26(address VAR16) constant public returns(uint256, uint256, uint256);
function FUN48() constant returns (uint256);
}
contract PullPayment is VAR44 {
using SafeMath for uint256;
uint public VAR73 = 1000000000000000000000;
uint public VAR74;
uint public VAR75;
mapping(address => uint256) internal VAR76;
modifier FUN54() {
require(msg.sender == FUN43(VAR42).FUN65());
VAR9;
}
modifier FUN30 () {
require(!FUN43(VAR42).FUN66());
VAR9;
}
function FUN35(address VAR16) constant returns (uint256 value) {
return FUN67(VAR76[VAR16]);
}
function FUN68(address VAR16) constant returns (uint256 value, uint256 VAR77) {
value = FUN67(VAR76[VAR16]);
VAR77 = (VAR76[VAR16] >> 192);
return;
}
function FUN69(uint VAR78) public onlyOwner {
VAR73 = VAR78;
}
function FUN70(address VAR16, uint256 VAR79)  public onlyOwner {
VAR76[VAR16] = (VAR79 << 192) + FUN67(VAR76[VAR16]);
}
function FUN1(address VAR3) public payable VAR80 {
require(msg.value > 0);
uint256 VAR81 = msg.value.FUN57(FUN67(VAR76[VAR3]));
uint256 VAR82;
if (FUN71(msg.value)) {
uint256 VAR77 = VAR76[VAR3] >> 192;
VAR82 = (VAR77 > VAR54) ? VAR77 : VAR54;
} else {
VAR82 = VAR54.FUN57(3 VAR83);
}
VAR75 = VAR75.FUN57(msg.value);
VAR76[VAR3] = (VAR82 << 192) + FUN67(VAR81);
}
function FUN72() public VAR31 {
address VAR84 = msg.sender;
uint256 VAR85 = FUN67(VAR76[VAR84]);
require(VAR85 != 0);
require(VAR54 >= (VAR76[VAR84] >> 192));
require(this.VAR86 >= VAR85);
VAR76[VAR84] = 0;
assert(VAR84.call.FUN73(1000).value(VAR85)());
}
function FUN71(uint VAR87) internal returns (bool) {
if (VAR54 > VAR74.FUN57(24 VAR88)) {
VAR74 = VAR54;
VAR75 = 0;
}
if (VAR75 + VAR87 > VAR73 || VAR75 + VAR87 < VAR75) {
return false;
}
return true;
}
}
contract Nutz is VAR44, VAR89 {
event FUN74(address indexed VAR90, uint256 value);
string public VAR47 = "";
string public VAR48 = "";
uint256 public VAR49 = 12;
function FUN35(address VAR16) constant returns (uint) {
return FUN43(VAR42).FUN7(VAR16);
}
function FUN34() constant returns (uint256) {
return FUN43(VAR42).FUN34();
}
function FUN12() constant returns (uint256) {
return FUN43(VAR42).FUN12();
}
function FUN36(address VAR16, address VAR40) constant returns (uint256) {
return FUN43(VAR42).FUN36(VAR16, VAR40);
}
function FUN61() constant returns (uint256) {
return FUN43(VAR42).FUN61();
}
function FUN62() constant returns (uint256) {
return FUN43(VAR42).FUN62();
}
function FUN18() constant returns (uint256) {
return FUN43(VAR42).FUN18();
}
function FUN75(address VAR41, address VAR34, uint256 VAR35, bytes VAR50) internal {
uint256 VAR91;
VAR92 {
VAR91 := FUN76(VAR34)
}
if(VAR91>0) {
ERC223ReceivingContract VAR93 = FUN77(VAR34);
VAR93.FUN60(VAR41, VAR35, VAR50);
}
}
function FUN78(address VAR94, address VAR28, uint256 VAR67) public onlyOwner {
bytes memory VAR95;
FUN75(VAR94, VAR28, VAR67, VAR95);
Transfer(VAR94, VAR28, VAR67);
}
function FUN1(address VAR96, address VAR3, uint256 VAR97) public onlyOwner {
assert(VAR97 <= this.VAR86);
FUN79(VAR96).VAR98.value(VAR97)(VAR3);
}
function FUN38(address VAR40, uint256 VAR67) public {
FUN43(VAR42).FUN38(msg.sender, VAR40, VAR67);
FUN39(msg.sender, VAR40, VAR67);
}
function transfer(address VAR34, uint256 VAR67, bytes VAR50) public returns (bool) {
FUN43(VAR42).transfer(msg.sender, VAR34, VAR67, VAR50);
Transfer(msg.sender, VAR34, VAR67);
FUN75(msg.sender, VAR34, VAR67, VAR50);
return true;
}
function transfer(address VAR34, uint256 VAR67) public returns (bool) {
bytes memory VAR95;
return transfer(VAR34, VAR67, VAR95);
}
function FUN80(address VAR34, uint256 VAR67, bytes VAR50) public returns (bool) {
return transfer(VAR34, VAR67, VAR50);
}
function FUN37(address VAR41, address VAR34, uint256 VAR67, bytes VAR50) public returns (bool) {
FUN43(VAR42).FUN37(msg.sender, VAR41, VAR34, VAR67, VAR50);
Transfer(VAR41, VAR34, VAR67);
FUN75(VAR41, VAR34, VAR67, VAR50);
return true;
}
function FUN37(address VAR41, address VAR34, uint256 VAR67) public returns (bool) {
bytes memory VAR95;
return FUN37(VAR41, VAR34, VAR67, VAR95);
}
function () public payable {
uint256 VAR99 = FUN43(VAR42).FUN62();
FUN63(VAR99);
require(msg.value > 0);
}
function FUN63(uint256 VAR71) public payable {
require(msg.value > 0);
uint256 VAR100 = FUN43(VAR42).FUN63(msg.sender, msg.value, VAR71);
Transfer(VAR42, msg.sender, VAR100);
bytes memory VAR95;
FUN75(address(this), msg.sender, VAR100, VAR95);
}
function FUN64(uint256 VAR71, uint256 VAR67) public {
require(VAR67 != 0);
FUN43(VAR42).FUN64(msg.sender, VAR71, VAR67);
FUN74(msg.sender, VAR67);
}
function FUN46(uint256 VAR67) public {
Transfer(msg.sender, VAR42, VAR67);
FUN43(VAR42).FUN46(msg.sender, msg.sender, VAR67);
}
}
contract MarketEnabled is VAR101 {
uint256 constant VAR102 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
address public VAR103;
uint256 internal VAR104;
uint256 internal VAR105;
function FUN81(address VAR96, address VAR15, address VAR65)
FUN55(VAR65, VAR15) {
VAR103 = VAR96;
}
function FUN62() constant returns (uint256) {
return VAR104;
}
function FUN61() constant returns (uint256) {
if (VAR64.VAR86 == 0) {
return VAR102;
}
uint256 VAR106 = FUN12().FUN82(1000000).FUN83(VAR64.VAR86);
return VAR106 >= VAR105 ? VAR106 : VAR105;
}
function FUN84(uint256 VAR107) public VAR11 {
require(VAR107 <= VAR105);
VAR104 = VAR107;
}
function FUN85(uint256 VAR108) public VAR11 {
require(VAR108 >= VAR104);
if (VAR108 < VAR102) {
require(VAR64.VAR86 >= FUN12().FUN82(1000000).FUN83(VAR108));
}
VAR105 = VAR108;
}
function FUN63(address VAR68, uint256 VAR35, uint256 VAR71) public onlyNutz whenNotPaused returns (uint256) {
require(VAR104 > 0);
require(VAR71 == VAR104);
uint256 VAR100 = VAR104.FUN82(VAR35).FUN83(1000000);
require(VAR100 > 0);
uint256 VAR109 = FUN12();
uint256 VAR110 = FUN18();
if (VAR110 > 0) {
uint256 VAR111 = VAR110.FUN82(VAR100).FUN83(VAR109.FUN57(FUN16()));
FUN19(VAR110.FUN57(VAR111));
}
FUN14(VAR109.FUN57(VAR100));
FUN10(VAR68, FUN7(VAR68).FUN57(VAR100));
return VAR100;
}
function FUN64(address VAR41, uint256 VAR71, uint256 VAR67) public onlyNutz VAR31 {
uint256 VAR112 = FUN61();
require(VAR67 != 0);
require(VAR112 != VAR102);
require(VAR71 == VAR112);
uint256 VAR85 = VAR67.FUN82(1000000).FUN83(VAR112);
require(VAR85 > 0);
uint256 VAR110 = FUN18();
uint256 VAR109 = FUN12();
if (VAR110 > 0) {
uint256 VAR111 = VAR110.FUN82(VAR67).FUN83(VAR109.FUN57(FUN16()));
FUN19(VAR110.FUN59(VAR111));
}
FUN14(VAR109.FUN59(VAR67));
FUN10(VAR41, FUN7(VAR41).FUN59(VAR67));
FUN86(VAR64).FUN1(VAR103, VAR41, VAR85);
}
function FUN87(uint256 VAR97, address VAR113) public VAR11 {
require(VAR97 > 0);
require(VAR64.VAR86.FUN59(VAR97) >= FUN12().FUN82(1000000).FUN83(VAR105));
FUN86(VAR64).FUN1(VAR103, VAR113, VAR97);
}
}
contract PowerEnabled is VAR114 {
address public VAR94;
uint256 public VAR115 = 0;
uint256 public VAR53;
uint public constant VAR116 = 100000;
modifier FUN88() {
require(msg.sender == VAR94);
VAR9;
}
function FUN89(address VAR117, address VAR96, address VAR15, address VAR65)
FUN81(VAR96, VAR65, VAR15) {
VAR94 = VAR117;
}
function FUN90(uint256 VAR118) public VAR11 {
require(FUN22() <= VAR118 && VAR118 < FUN24());
VAR115 = VAR118;
}
function FUN91(uint256 VAR119) public VAR11 {
VAR53 = VAR119;
}
function FUN92() public constant returns (uint256) {
uint256 VAR120 = FUN56();
if (VAR120 == 0) {
return VAR102;
}
return VAR120.FUN83(VAR116);
}
function FUN93(uint256 VAR67, uint256 VAR51) public VAR11 {
uint256 VAR121 = FUN24();
uint256 VAR122 = FUN56();
if (VAR121 == 0) {
FUN25((VAR51 > 0) ? VAR51 : VAR67.FUN57(VAR122));
} else {
FUN25(VAR121.FUN82(VAR122.FUN57(VAR67)).FUN83(VAR122));
}
FUN17(FUN16().FUN57(VAR67));
}
function FUN94(address VAR28, uint256 VAR35, bytes32 VAR50) internal {
uint256 VAR123 = FUN22();
FUN23(VAR123.FUN59(VAR35));
uint256 VAR110 = FUN18();
uint256 VAR124 = VAR35.FUN82(VAR110).FUN83(VAR123);
FUN19(VAR110.FUN59(VAR124));
FUN95(VAR94).FUN45(VAR28, VAR35, VAR50);
}
function FUN45(address VAR28, uint256 VAR35, bytes32 VAR50) public VAR11 {
FUN21(VAR28, FUN20(VAR28).FUN59(VAR35));
FUN94(VAR28, VAR35, VAR50);
}
function FUN96(uint256 VAR125, address VAR28, uint256 VAR35, bytes32 VAR50) public VAR11 {
FUN97 (VAR24, VAR25, VAR26) = FUN26(VAR28);
VAR25 = VAR25.FUN59(VAR35);
FUN29(VAR28, VAR24, VAR25, VAR26);
FUN94(VAR28, VAR35, VAR50);
}
function FUN46(address VAR68, address VAR41, uint256 VAR67) public onlyNutz VAR31 {
uint256 VAR121 = FUN24();
require(VAR121 != 0);
require(VAR67 != 0);
uint256 VAR122 = FUN56();
require(VAR122 != 0);
uint256 VAR126 = VAR67.FUN82(VAR121).FUN83(VAR122);
uint256 VAR127 = FUN22();
require(VAR127.FUN57(VAR126) <= VAR115);
uint256 VAR128 = FUN20(VAR41).FUN57(VAR126);
require(VAR128 >= VAR121.FUN83(VAR116));
if (VAR68 != VAR41) {
VAR66[VAR41][VAR68] = VAR66[VAR41][VAR68].FUN59(VAR67);
}
FUN23(VAR127.FUN57(VAR126));
FUN21(VAR41, VAR128);
FUN14(FUN12().FUN59(VAR67));
FUN10(VAR41, FUN7(VAR41).FUN59(VAR67));
FUN19(FUN18().FUN57(VAR67));
FUN95(VAR94).FUN46(VAR41, VAR126);
}
function FUN44() constant returns (uint256) {
uint256 VAR129 = FUN24().FUN83(2);
return VAR115 >= VAR129 ? VAR115 : VAR129;
}
function FUN98(uint256 VAR130, uint256 VAR131, uint256 VAR132, uint256 VAR72) internal constant returns (uint256) {
if (VAR72 <= VAR132) {
return 0;
}
uint256 VAR133 = VAR72.FUN59(VAR132);
if (VAR133 > VAR53) {
VAR133 = VAR53;
}
uint256 VAR134 = VAR130.FUN82(VAR133).FUN83(VAR53);
uint256 VAR135 = VAR130.FUN59(VAR134);
if (VAR131 <= VAR135) {
return 0;
}
return VAR131.FUN59(VAR135);
}
function FUN47(address VAR16, uint256 VAR51) public onlyPower VAR31 {
require(VAR51 >= FUN24().FUN83(VAR116));
FUN21(VAR16, FUN20(VAR16).FUN59(VAR51));
FUN97 (, VAR25, ) = FUN26(VAR16);
uint256 VAR24 = VAR51.FUN57(VAR25);
FUN29(VAR16, VAR24, VAR24, VAR54);
}
function FUN49(address VAR28, uint256 VAR72) public onlyPower VAR31 {
FUN97 (VAR24, VAR25, VAR26) = FUN26(VAR28);
uint256 VAR126 = FUN98(VAR24, VAR25, VAR26, VAR72);
uint256 VAR136 = VAR24.FUN83(10);
require(VAR25 <= VAR136 || VAR136 <= VAR126);
uint256 VAR100 = VAR126.FUN82(FUN56()).FUN83(FUN24());
FUN23(FUN22().FUN59(VAR126));
VAR25 = VAR25.FUN59(VAR126);
FUN19(FUN18().FUN59(VAR100));
FUN14(FUN12().FUN57(VAR100));
FUN10(VAR28, FUN7(VAR28).FUN57(VAR100));
if (VAR25 == 0) {
VAR26 = 0;
VAR24 = 0;
}
FUN29(VAR28, VAR24, VAR25, VAR26);
FUN86(VAR64).FUN78(VAR94, VAR28, VAR100);
}
}
library VAR137 {
function FUN82(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
uint256 VAR140 = VAR138 * VAR139;
assert(VAR138 == 0 || VAR140 / VAR138 == VAR139);
return VAR140;
}
function FUN83(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
uint256 VAR140 = VAR138 / VAR139;
return VAR140;
}
function FUN59(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
assert(VAR139 <= VAR138);
return VAR138 - VAR139;
}
function FUN57(uint256 VAR138, uint256 VAR139) internal returns (uint256) {
uint256 VAR140 = VAR138 + VAR139;
assert(VAR140 >= VAR138);
return VAR140;
}
}
contract Controller is VAR141 {
function FUN99(address VAR117, address VAR96, address VAR65, address VAR15)
FUN89(VAR117, VAR96, VAR65, VAR15) {
}
function FUN100(address VAR15, address VAR65, address VAR117, address VAR96) public onlyAdmins VAR32 {
VAR14 = VAR15;
VAR64 = VAR65;
VAR94 = VAR117;
VAR103 = VAR96;
}
function FUN69(uint256 VAR78) public VAR11 {
FUN101(VAR103).FUN69(VAR78);
}
function FUN102(address VAR142) public onlyAdmins VAR32 {
if (VAR94 != address(0)) { FUN40(VAR94).FUN41(msg.sender); }
if (VAR103 != address(0)) { FUN40(VAR103).FUN41(msg.sender); }
if (VAR64 != address(0)) { FUN40(VAR64).FUN41(msg.sender); }
if (VAR14 != address(0)) { FUN40(VAR14).FUN41(msg.sender); }
FUN103(VAR142);
}
}
1
---------------------------------
260 0xea88c23690b9f12ac6941e8a229aa4f94c72b8db.sol
pragma VAR1 ^0.4.15;
contract VAR2 {
address VAR3;
modifier VAR4 {
require(msg.sender == VAR3);
VAR5;
}
function FUN1() {
VAR3 = msg.sender;
}
function FUN2(address VAR6) external VAR4 {
VAR3 = VAR6;
}
function FUN3(address VAR7, uint VAR8, bytes VAR9) external onlyowner payable returns (bool){
return VAR7.call.value(VAR8)(VAR9);
}
function FUN4(address VAR7) external onlyowner payable returns (bool){
return VAR7.call.FUN5(300000).value(msg.value)();
}
function FUN6() constant returns (address) {
return VAR3;
}
}
1
---------------------------------
261 0xea9c15f733ee4cd9e24c97bdddd66077a757b474.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function FUN1() public constant returns (uint256);
function FUN2(address VAR3) public constant returns (uint256 VAR4);
function FUN3(address VAR3, address VAR5) public constant returns (uint256 VAR6);
function transfer(address VAR7, uint256 VAR8) public returns (bool VAR9);
function FUN4(address VAR5, uint256 VAR8) public returns (bool VAR9);
function FUN5(address VAR10, address VAR7, uint256 VAR8) public returns (bool VAR9);
event Transfer(address indexed VAR10, address indexed VAR7, uint VAR8);
event FUN6(address indexed VAR3, address indexed VAR5, uint VAR8);
}
contract VAR11 {
address public VAR12;
address public VAR13;
function FUN7() public {
VAR12 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR12);
VAR14;
}
function FUN8(address VAR15) public onlyOwner {
VAR13 = VAR15;
}
function FUN9() public {
require(msg.sender == VAR13);
VAR12 = VAR13;
}
}
contract BoomerangLiquidity is VAR11 {
modifier onlyOwner(){
require(msg.sender == VAR12);
VAR14;
}
modifier FUN10(address VAR16){
require(VAR16 != VAR17);
VAR14;
}
uint public VAR18;
uint public VAR19 = 0;
address VAR17;
function FUN11(uint VAR20, address VAR21) public {
VAR18 = VAR20;
VAR17 = VAR21;
}
struct VAR22 {
address VAR23;
uint VAR24;
}
VAR22[] public VAR25;
function() payable public {
FUN12();
}
function FUN12() payable public {
VAR25.FUN13(FUN14(msg.sender, (msg.value * VAR18) / 100));
}
function FUN15() public {
uint VAR4 = address(this).VAR4;
require(VAR4 > 1);
uint VAR26 = VAR4 / 2;
VAR4 =- VAR26;
VAR17.call.value(VAR26).FUN16(1000000)();
while (VAR4 > 0) {
uint VAR27 = VAR4 < VAR25[VAR19].VAR24 ? VAR4 : VAR25[VAR19].VAR24;
if(VAR27 > 0){
VAR25[VAR19].VAR24 -= VAR27;
VAR4 -= VAR27;
if(!VAR25[VAR19].VAR23.FUN17(VAR27)){
VAR25[VAR19].VAR23.call.value(VAR27).FUN16(1000000)();
}
}
if(VAR4 > 0){
VAR19 += 1;
}
}
}
function FUN18() public {
VAR17.call(bytes4(FUN19("")));
}
function FUN20() payable public {
}
function FUN21(address VAR28, uint VAR8) public onlyOwner returns (bool VAR9) {
return FUN22(VAR28).transfer(VAR12, VAR8);
}
function FUN23() onlyOwner public {
msg.sender.transfer(address(this).VAR4);
}
}
1
---------------------------------
262 0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal  pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal  pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure  returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
address VAR8;
modifier FUN5(address VAR9) {
require(msg.sender == VAR9);
VAR10;
}
constructor() public {
VAR7 = msg.sender;
}
function FUN6(address VAR11) FUN5(VAR7) public {
VAR8 = VAR11;
}
function FUN7() FUN5(VAR8) public {
emit FUN8(VAR7, VAR8);
VAR7 = VAR8;
}
event FUN8(address indexed VAR12, address indexed VAR13);
}
contract ERC20 is VAR6 {
using SafeMath for uint;
uint public VAR14;
bool public VAR15 = false;
mapping (address => uint) VAR16;
mapping (address => mapping (address => uint)) VAR17;
modifier FUN9() {
require(VAR15);
VAR10;
}
modifier FUN10() {
require(!VAR15);
VAR10;
}
event Transfer(address indexed VAR12, address indexed VAR13, uint VAR18);
event FUN11(address indexed VAR19, address indexed VAR20, uint VAR18);
function transfer(address VAR13, uint VAR18) isStartedOnly public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
emit Transfer(msg.sender, VAR13, VAR18);
return true;
}
function FUN12(address VAR12, address VAR13, uint VAR18) isStartedOnly public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[VAR12] = VAR16[VAR12].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
VAR17[VAR12][msg.sender] = VAR17[VAR12][msg.sender].FUN3(VAR18);
emit Transfer(VAR12, VAR13, VAR18);
return true;
}
function FUN13(address VAR19) public view returns (uint VAR22) {
return VAR16[VAR19];
}
function FUN14(address VAR20, uint VAR23, uint VAR18) isStartedOnly public returns (bool VAR21) {
if(VAR17[msg.sender][VAR20] == VAR23){
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
} else {
return false;
}
}
function FUN15(address VAR20, uint VAR18) isStartedOnly public returns (bool VAR21) {
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
}
function FUN16(address VAR19, address VAR20) public view returns (uint VAR24) {
return VAR17[VAR19][VAR20];
}
}
contract Token is VAR25 {
using SafeMath for uint;
string public VAR26;
string public VAR27;
uint8 public VAR28;
constructor(string VAR29, string VAR30, uint8 VAR31) public {
VAR26 = VAR29;
VAR27 = VAR30;
VAR28 = VAR31;
}
function FUN17() public FUN5(VAR7) VAR32 {
VAR15 = true;
}
function FUN18(address VAR13, uint VAR33) public FUN5(VAR7) VAR32 returns(bool) {
VAR14 = VAR14.FUN4(VAR33);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR33);
emit Transfer(msg.sender, VAR13, VAR33);
return true;
}
function FUN19(address[] VAR34, uint[] VAR35) public FUN5(VAR7) isNotStartedOnly returns (uint) {
uint VAR36 = 0;
while (VAR36 < VAR34.VAR37) {
FUN18(VAR34[VAR36], VAR35[VAR36]);
VAR36 += 1;
}
return(VAR36);
}
}
contract TokenWithoutStart is VAR6 {
using SafeMath for uint;
mapping (address => uint) VAR16;
mapping (address => mapping (address => uint)) VAR17;
string public VAR26;
string public VAR27;
uint8 public VAR28;
uint public VAR14;
event Transfer(address indexed VAR12, address indexed VAR13, uint VAR18);
event FUN11(address indexed VAR19, address indexed VAR20, uint VAR18);
constructor(string VAR29, string VAR30, uint8 VAR31) public {
VAR26 = VAR29;
VAR27 = VAR30;
VAR28 = VAR31;
}
function transfer(address VAR13, uint VAR18) public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
emit Transfer(msg.sender, VAR13, VAR18);
return true;
}
function FUN12(address VAR12, address VAR13, uint VAR18) public returns (bool VAR21) {
require(VAR13 != address(0));
VAR16[VAR12] = VAR16[VAR12].FUN3(VAR18);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR18);
VAR17[VAR12][msg.sender] = VAR17[VAR12][msg.sender].FUN3(VAR18);
emit Transfer(VAR12, VAR13, VAR18);
return true;
}
function FUN13(address VAR19) public view returns (uint VAR22) {
return VAR16[VAR19];
}
function FUN14(address VAR20, uint VAR23, uint VAR18) public returns (bool VAR21) {
if(VAR17[msg.sender][VAR20] == VAR23){
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
} else {
return false;
}
}
function FUN15(address VAR20, uint VAR18) public returns (bool VAR21) {
VAR17[msg.sender][VAR20] = VAR18;
emit FUN11(msg.sender, VAR20, VAR18);
return true;
}
function FUN16(address VAR19, address VAR20) public view returns (uint VAR24) {
return VAR17[VAR19][VAR20];
}
function FUN18(address VAR13, uint VAR33) public FUN5(VAR7) returns(bool) {
VAR14 = VAR14.FUN4(VAR33);
VAR16[VAR13] = VAR16[VAR13].FUN4(VAR33);
emit Transfer(msg.sender, VAR13, VAR33);
return true;
}
function FUN19(address[] VAR34, uint[] VAR35) public FUN5(VAR7) returns (uint) {
uint VAR36 = 0;
while (VAR36 < VAR34.VAR37) {
FUN18(VAR34[VAR36], VAR35[VAR36]);
VAR36 += 1;
}
return(VAR36);
}
}
contract VAR38 {
string public VAR26;
address public VAR39;
address public VAR40;
Token public VAR41;
address public VAR42;
address public VAR43;
uint public VAR44;
struct VAR45 {
bool VAR46;
bool VAR47;
address VAR48;
}
mapping(uint => VAR45) public VAR49;
constructor(string VAR29, address VAR50, address VAR51, address VAR52, address VAR53, address VAR54) public {
VAR26 = VAR29;
VAR39 = VAR50;
VAR40 = VAR51;
VAR41 = FUN20(VAR52);
VAR43 = VAR53;
VAR42 = VAR54;
}
function FUN21() public {
VAR49[VAR44].VAR46 = true;
VAR49[VAR44].VAR48 = msg.sender;
}
function FUN22(address VAR55) public {
require(msg.sender == VAR39);
require(VAR49[VAR44].VAR48 == VAR55);
VAR44 +=1;
}
}
contract VAR45 {
using SafeMath for uint;
address public VAR56;
address public VAR39;
address public VAR57;
address public VAR42;
address public VAR40;
address public VAR43;
Token public VAR41;
address public VAR58;
bool public VAR59;
struct VAR60 {
uint VAR61;
uint VAR62;
uint VAR63;
uint VAR64;
uint VAR65;
string VAR66;
string VAR67;
}
VAR60[] public VAR68;
uint public VAR69;
uint public VAR70;
uint public VAR71;
uint public VAR72;
struct VAR73 {
bool VAR74;
uint VAR75;
uint VAR76;
uint VAR77;
uint VAR78;
bool VAR79;
bool VAR80;
uint VAR81;
}
struct VAR82 {
address VAR83;
uint VAR61;
uint VAR62;
bool VAR84;
}
mapping(address => VAR73) public VAR85;
address[] public VAR86;
mapping(address => mapping(uint => VAR82)) public VAR87;
uint[] public VAR88;
uint[] public VAR89;
uint public VAR90;
uint public VAR91;
uint public VAR92;
uint public VAR93;
uint public VAR94;
uint public VAR95;
uint public VAR96;
uint public VAR97;
uint public VAR98;
bool public VAR99;
uint public VAR100;
bool public VAR101;
mapping(address => uint[]) public VAR102;
mapping(address => uint[]) public VAR103;
struct VAR104 {
uint VAR63;
uint VAR105;
uint VAR98;
bool VAR106;
}
VAR104[] public VAR107;
mapping(uint => mapping(address => bool)) public VAR108;
modifier FUN23() {
require(msg.sender == VAR39 || msg.sender == VAR56);
VAR10;
}
modifier onlyAdmin() {
require(msg.sender == VAR39 || msg.sender == VAR56);
VAR10;
}
modifier FUN24() {
require(VAR70 != 0);
VAR10;
}
modifier FUN25() {
require(VAR70 == 0);
VAR10;
}
constructor( address VAR109,
address VAR50,
uint VAR110,
address VAR111,
uint[] VAR112,
uint[] VAR113,
uint VAR114,
uint VAR115
) public {
require(VAR112.VAR37 == VAR113.VAR37);
VAR56 = msg.sender;
VAR57 = VAR109;
VAR39 = VAR50;
VAR98 = VAR110;
VAR58 = VAR111;
VAR88 = VAR112;
VAR89 = VAR113;
VAR107.FUN26(FUN27(0,0,0,false));
VAR99 = true;
VAR90 = VAR114;
VAR91 = VAR115;
}
function FUN28(address VAR111) public {
require(msg.sender == VAR56);
VAR58 = VAR111;
}
function FUN29() onlyAdmin notSealed public {
ICO VAR116 = FUN30(VAR57);
require(VAR116.FUN31() == VAR39);
VAR42 = VAR116.FUN32();
VAR40 = VAR116.FUN33();
VAR43 = VAR116.FUN34();
VAR41 = VAR116.FUN35();
VAR116.FUN21();
}
function FUN36() public {
if (VAR101 == true) {
require(msg.sender.FUN37(VAR85[msg.sender].VAR77));
}
if (msg.sender == VAR39) {
require(VAR40.FUN37(VAR71+VAR72));
VAR71 = 0;
VAR72 = 0;
}
if (msg.sender == VAR42) {
require(VAR42.FUN37(VAR92));
require(VAR58.call.value(VAR93)(VAR117.FUN38("")));
VAR92 = 0;
VAR93 = 0;
}
if (VAR85[msg.sender].VAR80 == true) {
require(msg.sender.FUN37(VAR85[msg.sender].VAR77 - VAR85[msg.sender].VAR76));
}
}
function FUN39() public {
require(VAR41.transfer(msg.sender,VAR85[msg.sender].VAR75));
VAR85[msg.sender].VAR75 = 0;
}
function FUN40(uint VAR118,uint VAR119, uint VAR120, address[] VAR121) public VAR122 {
if (VAR121.VAR37 == 0) {
VAR107.FUN26(FUN27(VAR118, VAR119,VAR120,false));
} else {
for (uint VAR36=0 ; VAR36 < VAR121.VAR37 ; VAR36++ ) {
VAR108[VAR107.VAR37][VAR121[VAR36]] = true;
}
VAR107.FUN26(FUN27(VAR118, VAR119,VAR120,true));
}
}
function FUN41(uint VAR110) onlyOperator public {
VAR98 = VAR110;
}
function FUN42(uint VAR123) public VAR122 {
require(VAR107.VAR37 > VAR123);
VAR100 = VAR123;
VAR98 = VAR107[VAR123].VAR98;
}
function () public payable {
require(msg.value > 0);
if (VAR107[VAR100].VAR106 == true) {
require(VAR108[VAR100][msg.sender] == true);
}
uint VAR124 = VAR85[msg.sender].VAR81;
VAR87[msg.sender][VAR124].VAR83 = msg.sender;
VAR87[msg.sender][VAR124].VAR61 = msg.value;
VAR85[msg.sender].VAR81 += 1;
}
function FUN43(uint VAR125) public {
require(VAR87[msg.sender][VAR125].VAR84 == false);
require(msg.sender.FUN37(VAR87[msg.sender][VAR125].VAR61));
VAR87[msg.sender][VAR125].VAR61 = 0;
}
function FUN44(address VAR126) public {
require(msg.sender == VAR43);
VAR85[VAR126].VAR74 = true;
}
function FUN45(address VAR126, bool VAR127,uint VAR128) public {
require(msg.sender == VAR43);
require(VAR85[VAR126].VAR74 == true);
if (VAR127) {
VAR85[VAR126].VAR80 = true;
} else {
VAR85[VAR126].VAR79 = true;
for (uint VAR36 = VAR128; VAR36 < VAR69; VAR36++) {
VAR72 += VAR102[VAR126][VAR36];
VAR85[VAR126].VAR76 += VAR102[VAR126][VAR36];
}
}
VAR85[VAR126].VAR74 = false;
}
function FUN46(uint VAR129, uint VAR130, uint VAR118, uint VAR131, string VAR132) public notSealed VAR122 returns(uint) {
VAR94 = VAR94.FUN4(VAR129);
VAR95 = VAR95.FUN4(VAR130);
return VAR68.FUN26(FUN47(VAR129, VAR130, VAR118, 0, VAR131, VAR132, ""));
}
function FUN48(uint VAR133, uint VAR129, uint VAR130, uint VAR118, uint VAR131, string VAR132) public notSealed VAR122 {
assert(VAR133 < VAR68.VAR37);
VAR94 = (VAR94 - VAR68[VAR133].VAR61).FUN4(VAR129);
VAR95 = (VAR95 - VAR68[VAR133].VAR62).FUN4(VAR130);
VAR68[VAR133].VAR61 = VAR129;
VAR68[VAR133].VAR62 = VAR130;
VAR68[VAR133].VAR63 = VAR118;
VAR68[VAR133].VAR65 = VAR131;
VAR68[VAR133].VAR66 = VAR132;
}
function FUN49() public notSealed VAR122 {
require(VAR68.VAR37 > 0);
require(VAR41.FUN13(address(this)) >= VAR95);
VAR70 = VAR134;
}
function FUN50(address VAR126, uint VAR125) public sealed VAR122 {
require(VAR87[VAR126][VAR125].VAR61 > 0);
require(VAR87[VAR126][VAR125].VAR84 != true);
VAR87[VAR126][VAR125].VAR84 = true;
uint  VAR129 = VAR87[VAR126][VAR125].VAR61;
uint VAR130 = VAR87[VAR126][VAR125].VAR62;
require(VAR41.FUN13(address(this)) >= VAR96 + VAR130);
if (VAR90 > 0 || VAR91 > 0) {
uint VAR135 = VAR129.FUN1(VAR90).FUN2(100);
uint VAR136 = VAR129.FUN1(VAR91).FUN2(100);
VAR129 = VAR129.FUN3(VAR135).FUN3(VAR136);
VAR87[VAR126][VAR125].VAR61 = VAR129;
VAR92 += VAR135;
VAR93 += VAR136;
}
FUN51(VAR126, VAR129, VAR130);
if (!(VAR85[VAR126].VAR77 > 0)) VAR86.FUN26(VAR126);
if (VAR99 == true) {
VAR85[VAR126].VAR75 = VAR130;
}
VAR85[VAR126].VAR77 += VAR129;
VAR85[VAR126].VAR78 += VAR130;
VAR96 += VAR130;
VAR97 += VAR129;
}
function FUN52() public sealed VAR122 {
if (VAR69 != 0 ) {require(VAR68[VAR69-1].VAR64 > 0);}
for (uint VAR36=0; VAR36 < VAR86.VAR37 ; VAR36++) {
address VAR83 = VAR86[VAR36];
if (VAR85[VAR83].VAR74 == false) {
if (VAR85[VAR83].VAR80 != true) {
VAR71 += VAR102[VAR83][VAR69];
VAR85[VAR83].VAR76 += VAR102[VAR83][VAR69];
if (VAR99 == false) {
VAR85[VAR83].VAR75 += VAR103[VAR83][VAR69];
}
}
}
}
VAR68[VAR69].VAR63 = VAR134;
VAR69 +=1;
VAR71 = FUN53();
}
function FUN53() internal returns(uint) {
if (VAR88.VAR37 >= VAR69) {
uint VAR137 = VAR97.FUN1(VAR88[VAR69-1]).FUN2(100);
uint VAR136 = VAR97.FUN1(VAR89[VAR69-1]).FUN2(100);
VAR92 += VAR137;
VAR93 += VAR136;
return VAR71.FUN3(VAR137).FUN3(VAR136);
} else {
return VAR71;
}
}
function FUN54(string VAR138) public VAR122 {
require(VAR68[VAR69-1].VAR64 == 0);
uint VAR139 = VAR134 - VAR68[VAR69-1].VAR63;
require(VAR139 > 1 VAR140);
VAR68[VAR69-1].VAR64 = VAR134;
VAR68[VAR69-1].VAR67 = VAR138;
}
//
function FUN55() public onlyAdmin {
if (msg.sender == VAR39) {
VAR59 = true;
}
if (msg.sender == VAR56) {
require(VAR59 == true);
require(VAR56.FUN37(address(this).VAR22));
uint VAR141 = VAR41.FUN13(this);
require(VAR41.transfer(VAR56,VAR141));
}
}
function FUN56() public view returns(uint) {
return VAR68.VAR37;
}
function FUN51(address VAR126, uint VAR129, uint VAR130) internal {
uint VAR142;
uint VAR143;
uint VAR144;
uint VAR145;
uint VAR146;
uint VAR147;
for(uint VAR36=VAR69; VAR36<VAR68.VAR37; VAR36++) {
VAR144 = VAR68[VAR36].VAR61;
VAR145 = VAR68[VAR36].VAR62;
VAR142 = VAR129.FUN1(VAR144).FUN2(VAR94);
VAR143 = VAR130.FUN1(VAR145).FUN2(VAR95);
VAR146 = VAR146.FUN4(VAR142);
VAR147 = VAR147.FUN4(VAR143);
if (VAR85[VAR126].VAR77 > 0) {
VAR102[VAR126][VAR36] += VAR142;
VAR103[VAR126][VAR36] += VAR143;
} else {
VAR102[VAR126].FUN26(VAR142);
VAR103[VAR126].FUN26(VAR143);
}
}
VAR102[VAR126][VAR69] += VAR129 - VAR146;
VAR103[VAR126][VAR69] += VAR130 - VAR147;
}
function FUN57(address VAR126) public view returns(bool) {
return VAR85[VAR126].VAR74;
}
function FUN58(address VAR126) public view returns(bool) {
if (VAR85[VAR126].VAR77 > 0) return true;
else return false;
}
}
contract Arbitration is VAR6 {
address public VAR39;
uint public VAR148 = 3;
struct VAR149 {
address VAR48;
address VAR150;
bool VAR151;
uint VAR152;
uint VAR153;
string VAR154;
uint VAR155;
uint VAR156;
mapping(address => bool) VAR157;
}
mapping(uint => VAR149) public VAR158;
uint public VAR159;
mapping(address => mapping(address => bool)) public VAR160;
modifier FUN5(address VAR9) {
require(msg.sender == VAR9);
VAR10;
}
constructor() public {
VAR39 = msg.sender;
}
function FUN59(address VAR55, address[] VAR161) FUN5(VAR7) public {
for (uint VAR36 = 0; VAR36 < VAR161.VAR37 ; VAR36++) {
VAR160[VAR55][VAR161[VAR36]] = true;
}
}
function FUN60(uint VAR162, bool VAR163) public {
require(VAR158[VAR162].VAR151 == true);
require(VAR160[VAR158[VAR162].VAR48][msg.sender] == true);
require(VAR158[VAR162].VAR157[msg.sender] != true);
if (VAR163 == true) { VAR158[VAR162].VAR156 += 1; }
else { VAR158[VAR162].VAR155 += 1; }
if (VAR158[VAR162].VAR156 == VAR148) {
FUN61(VAR162,true);
}
if (VAR158[VAR162].VAR155 == VAR148) {
FUN61(VAR162,false);
}
VAR158[VAR162].VAR157[msg.sender] == true;
}
function FUN62(address VAR55, string VAR164) public {
Cycle VAR165 = FUN63(VAR55);
uint VAR166 = VAR165.FUN64();
require(VAR166 > 0);
require(VAR165.FUN58(msg.sender) == true);
VAR158[VAR159].VAR153 = VAR166;
VAR158[VAR159].VAR48 = VAR55;
VAR158[VAR159].VAR150 = msg.sender;
VAR158[VAR159].VAR152 = VAR134;
VAR158[VAR159].VAR154 = VAR164;
VAR158[VAR159].VAR151 = true;
VAR165.FUN44(msg.sender);
VAR159 +=1;
}
function FUN61(uint VAR162, bool VAR127) internal {
VAR158[VAR162].VAR151 = false;
uint VAR166 = VAR158[VAR162].VAR153;
Cycle VAR165 = FUN63(VAR158[VAR162].VAR48);
VAR165.FUN45(VAR158[VAR162].VAR150,VAR127,VAR166);
}
function FUN65(uint VAR167) public view returns(bool) {
return VAR158[VAR167].VAR151;
}
}
contract VAR168 {
Token public VAR41;
uint public VAR169 = 2443;
address public VAR7;
constructor(address VAR170) public {
VAR7 = msg.sender;
VAR41 = FUN20(VAR170);
}
function FUN66() public payable {
uint VAR171 = msg.value * VAR169;
require(VAR41.transfer(VAR7,VAR171));
}
function FUN67(uint VAR172) public {
require(msg.sender == VAR7);
VAR169 = VAR172;
}
}
1
---------------------------------
263 0xeb80ca0138a8444f761143c177b894513ff12f01.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address public VAR3;
constructor() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN2() external view returns (uint256);
function FUN3(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN4(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR11, uint256 value) external returns (bool VAR9);
function FUN6(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN7(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract ChilliZTokenPurchase is VAR2 {
address public VAR13 = 0x2Aa3BB100a96317D3A931570bCe4a96A26EafDb7;
address public VAR14 = 0x212286e36Ae998FAd27b627EB326107B3aF1FeD4;
address public VAR15 = 0x515962688858eD980EB2Db2b6fA2802D9f620C6d;
uint public VAR16 = 1000;
function() payable public {
FUN8(msg.value);
}
function FUN8(uint VAR17) internal {
uint VAR18 = VAR17 * 25 / 1050;
uint VAR19 = VAR17 * 25 / 1050;
FUN9(VAR14, VAR18);
FUN9(VAR15, VAR19);
uint VAR20 = VAR17 - VAR18 - VAR19;
FUN9(VAR13, VAR20);
}
function FUN9(address VAR21, uint VAR17) internal {
require(VAR21.call.FUN10(VAR16).value(VAR17)());
}
function FUN11(uint VAR22) public onlyOwner {
VAR16 = VAR22;
}
function FUN12(EIP20Token VAR23, address VAR24, uint value) public onlyOwner {
VAR23.FUN5(VAR24, value);
}
function FUN13() public onlyOwner {
FUN9(msg.sender, address(this).VAR25);
}
}
1
---------------------------------
264 0xeb833733a8a2e3d0f722cd181cd027dbca015eff.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
function FUN1() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN2(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN3() external view returns (uint256);
function FUN4(address VAR7) external view returns (uint256);
function transfer(address VAR8, uint256 value) external returns (bool VAR9);
function FUN5(address VAR10, address VAR8, uint256 value) external returns (bool VAR9);
function FUN6(address VAR11, uint256 value) external returns (bool VAR9);
function FUN7(address VAR3, address VAR11) external view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN8(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract HumanProtocolInvestment is VAR2 {
address public VAR13 = 0x55704E8Cb15AF1054e21a7a59Fb0CBDa6Bd044B7;
address public VAR14 = 0x5a89D9f1C382CaAa66Ee045aeb8510F1205bC8bf;
address public VAR15 = 0xC787C3f6F75D7195361b64318CE019f90507f806;
address public VAR16 = 0xDa2cEa3DbaC30835D162Df11D21Ac6Cbf355aC9F;
uint public VAR17 = 1000;
function() payable public {
FUN9(msg.value);
}
function FUN9(uint VAR18) internal {
uint VAR19 = VAR18 * 3 / (10 * 11);
uint VAR20 = VAR18 * 2 / (10 * 11);
uint VAR21 = VAR18 * 5 / (10 * 11);
require(VAR14.call.FUN10(VAR17).value(VAR19)());
require(VAR15.call.FUN10(VAR17).value(VAR20)());
require(VAR16.call.FUN10(VAR17).value(VAR21)());
uint VAR22 = VAR18 - VAR19 - VAR20 - VAR21;
require(VAR13.call.FUN10(VAR17).value(VAR22)());
}
function FUN11(uint VAR23) public onlyOwner {
VAR17 = VAR23;
}
function FUN12(EIP20Token VAR24, address VAR25, uint value) public onlyOwner {
VAR24.FUN6(VAR25, value);
}
function FUN13() public onlyOwner {
require(msg.sender.call.FUN10(VAR17).value(this.VAR26)());
}
}
1
---------------------------------
265 0xeba39e464fd004396d7a0838a976d2c9cfe298b5.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
pragma VAR1 ^0.4.11;
contract VAR6 {
address public VAR7;
function FUN5(uint VAR8, string VAR9, string VAR10) payable returns (bytes32 VAR11);
function FUN6(uint VAR8, string VAR9, string VAR10, uint VAR12) payable returns (bytes32 VAR11);
function FUN7(uint VAR8, string VAR9, string VAR13, string VAR14) payable returns (bytes32 VAR11);
function FUN8(uint VAR8, string VAR9, string VAR13, string VAR14, uint VAR12) payable returns (bytes32 VAR11);
function FUN9(uint VAR8, string VAR9, bytes VAR15) payable returns (bytes32 VAR11);
function FUN10(uint VAR8, string VAR9, bytes VAR15, uint VAR12) payable returns (bytes32 VAR11);
function FUN11(string VAR9) returns (uint VAR16);
function FUN11(string VAR9, uint VAR17) returns (uint VAR16);
function FUN12(string VAR18);
function FUN13(byte VAR19);
function FUN14(bytes32 VAR20);
function FUN15(uint VAR21);
function FUN16() returns(bytes32);
}
contract VAR22 {
function FUN17() returns (address VAR23);
}
contract VAR24 {
uint constant VAR25 = 60*60*24;
uint constant VAR26 = 60*60*24*7;
uint constant VAR27 = 60*60*24*30;
byte constant VAR28 = 0x00;
byte constant VAR29 = 0x10;
byte constant VAR30 = 0x20;
byte constant VAR31 = 0x30;
byte constant VAR32 = 0xF0;
byte constant VAR33 = 0x01;
uint8 constant VAR34 = 0;
uint8 constant VAR35 = 1;
uint8 constant VAR36 = 2;
uint8 constant VAR37 = 2;
uint8 constant VAR38 = 161;
OraclizeAddrResolverI VAR39;
OraclizeI VAR40;
modifier VAR41 {
if((address(VAR39)==0)||(FUN18(address(VAR39))==0)) FUN19(VAR34);
VAR40 = FUN20(VAR39.FUN17());
VAR42;
}
modifier FUN21(string VAR43){
VAR40 = FUN20(VAR39.FUN17());
VAR40.FUN12(VAR43);
VAR42;
}
function FUN19(uint8 VAR44) internal returns(bool){
if (FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR39 = FUN22(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN23("");
return true;
}
if (FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR39 = FUN22(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN23("");
return true;
}
if (FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR39 = FUN22(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN23("");
return true;
}
if (FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR39 = FUN22(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN23("");
return true;
}
if (FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR39 = FUN22(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR39 = FUN22(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR39 = FUN22(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN24(bytes32 VAR45, string VAR46) {
FUN24(VAR45, VAR46, VAR47 bytes(0));
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) {
}
function FUN25(string VAR43) oraclizeAPI internal {
VAR40.FUN12(VAR43);
}
function FUN26(string VAR49) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49);
}
function FUN26(string VAR49, uint VAR17) oraclizeAPI internal returns (uint){
return VAR40.FUN11(VAR49, VAR17);
}
function FUN27(string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(0, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR56.value(VAR52)(VAR57, VAR49, VAR50);
}
function FUN27(uint VAR57, string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(VAR57, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR50, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR58.value(VAR52)(0, VAR49, VAR50, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(0, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
return VAR40.VAR61.value(VAR52)(VAR57, VAR49, VAR59, VAR60);
}
function FUN27(uint VAR57, string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(VAR57, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string VAR59, string VAR60, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
return VAR40.VAR62.value(VAR52)(0, VAR49, VAR59, VAR60, VAR17);
}
function FUN27(string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN28(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, string[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
string[] memory VAR67 = new string[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(0, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49);
if (VAR52 > 1 VAR53 + VAR54.VAR55*200000) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR65.value(VAR52)(VAR57, VAR49, VAR64);
}
function FUN27(uint VAR57, string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(VAR57, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[] VAR63, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51){
uint VAR52 = VAR40.FUN11(VAR49, VAR17);
if (VAR52 > 1 VAR53 + VAR54.VAR55*VAR17) return 0;
bytes memory VAR64 = FUN29(VAR63);
return VAR40.VAR66.value(VAR52)(0, VAR49, VAR64, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[1] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](1);
VAR67[0] = VAR64[0];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[2] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](2);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[3] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](3);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[4] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](4);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67);
}
function FUN27(uint VAR57, string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR57, VAR49, VAR67, VAR17);
}
function FUN27(string VAR49, bytes[5] VAR64, uint VAR17) oraclizeAPI internal returns (bytes32 VAR51) {
bytes[] memory VAR67 = new bytes[](5);
VAR67[0] = VAR64[0];
VAR67[1] = VAR64[1];
VAR67[2] = VAR64[2];
VAR67[3] = VAR64[3];
VAR67[4] = VAR64[4];
return FUN27(VAR49, VAR67, VAR17);
}
function FUN30() oraclizeAPI internal returns (address){
return VAR40.FUN31();
}
function FUN32(byte VAR68) oraclizeAPI internal {
return VAR40.FUN13(VAR68);
}
function FUN33(uint VAR69) oraclizeAPI internal {
return VAR40.FUN15(VAR69);
}
function FUN34(bytes32 VAR70) oraclizeAPI internal {
return VAR40.FUN14(VAR70);
}
function FUN35() oraclizeAPI internal returns (bytes32){
return VAR40.FUN16();
}
function FUN18(address VAR23) constant internal returns(uint VAR71) {
VAR72 {
VAR71 := FUN36(VAR23)
}
}
function FUN37(string VAR73) internal returns (address){
bytes memory VAR74 = bytes(VAR73);
uint160 VAR75 = 0;
uint160 VAR76;
uint160 VAR77;
for (uint VAR78=2; VAR78<2+2*20; VAR78+=2){
VAR75 *= 256;
VAR76 = FUN38(VAR74[VAR78]);
VAR77 = FUN38(VAR74[VAR78+1]);
if ((VAR76 >= 97)&&(VAR76 <= 102)) VAR76 -= 87;
else if ((VAR76 >= 65)&&(VAR76 <= 70)) VAR76 -= 55;
else if ((VAR76 >= 48)&&(VAR76 <= 57)) VAR76 -= 48;
if ((VAR77 >= 97)&&(VAR77 <= 102)) VAR77 -= 87;
else if ((VAR77 >= 65)&&(VAR77 <= 70)) VAR77 -= 55;
else if ((VAR77 >= 48)&&(VAR77 <= 57)) VAR77 -= 48;
VAR75 += (VAR76*16+VAR77);
}
return address(VAR75);
}
function FUN39(string VAR73, string VAR79) internal returns (int) {
bytes memory VAR3 = bytes(VAR73);
bytes memory VAR4 = bytes(VAR79);
uint VAR80 = VAR3.VAR81;
if (VAR4.VAR81 < VAR80) VAR80 = VAR4.VAR81;
for (uint VAR78 = 0; VAR78 < VAR80; VAR78 ++)
if (VAR3[VAR78] < VAR4[VAR78])
return -1;
else if (VAR3[VAR78] > VAR4[VAR78])
return 1;
if (VAR3.VAR81 < VAR4.VAR81)
return -1;
else if (VAR3.VAR81 > VAR4.VAR81)
return 1;
else
return 0;
}
function FUN40(string VAR82, string VAR83) internal returns (int) {
bytes memory VAR84 = bytes(VAR82);
bytes memory VAR85 = bytes(VAR83);
if(VAR84.VAR81 < 1 || VAR85.VAR81 < 1 || (VAR85.VAR81 > VAR84.VAR81))
return -1;
else if(VAR84.VAR81 > (2**128 -1))
return -1;
else
{
uint VAR86 = 0;
for (uint VAR78 = 0; VAR78 < VAR84.VAR81; VAR78 ++)
{
if (VAR84[VAR78] == VAR85[0])
{
VAR86 = 1;
while(VAR86 < VAR85.VAR81 && (VAR78 + VAR86) < VAR84.VAR81 && VAR84[VAR78 + VAR86] == VAR85[VAR86])
{
VAR86++;
}
if(VAR86 == VAR85.VAR81)
return int(VAR78);
}
}
return -1;
}
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88, string VAR89) internal returns (string) {
bytes memory VAR90 = bytes(VAR73);
bytes memory VAR91 = bytes(VAR79);
bytes memory VAR92 = bytes(VAR87);
bytes memory VAR93 = bytes(VAR88);
bytes memory VAR94 = bytes(VAR89);
string memory VAR95 = VAR47 string(VAR90.VAR81 + VAR91.VAR81 + VAR92.VAR81 + VAR93.VAR81 + VAR94.VAR81);
bytes memory VAR96 = bytes(VAR95);
uint VAR97 = 0;
for (uint VAR78 = 0; VAR78 < VAR90.VAR81; VAR78++) VAR96[VAR97++] = VAR90[VAR78];
for (VAR78 = 0; VAR78 < VAR91.VAR81; VAR78++) VAR96[VAR97++] = VAR91[VAR78];
for (VAR78 = 0; VAR78 < VAR92.VAR81; VAR78++) VAR96[VAR97++] = VAR92[VAR78];
for (VAR78 = 0; VAR78 < VAR93.VAR81; VAR78++) VAR96[VAR97++] = VAR93[VAR78];
for (VAR78 = 0; VAR78 < VAR94.VAR81; VAR78++) VAR96[VAR97++] = VAR94[VAR78];
return string(VAR96);
}
function FUN41(string VAR73, string VAR79, string VAR87, string VAR88) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, VAR88, "");
}
function FUN41(string VAR73, string VAR79, string VAR87) internal returns (string) {
return FUN41(VAR73, VAR79, VAR87, "", "");
}
function FUN41(string VAR73, string VAR79) internal returns (string) {
return FUN41(VAR73, VAR79, "", "", "");
}
function FUN42(string VAR73) internal returns (uint) {
return FUN42(VAR73, 0);
}
function FUN42(string VAR73, uint VAR79) internal returns (uint) {
bytes memory VAR98 = bytes(VAR73);
uint VAR99 = 0;
bool VAR100 = false;
for (uint VAR78=0; VAR78<VAR98.VAR81; VAR78++){
if ((VAR98[VAR78] >= 48)&&(VAR98[VAR78] <= 57)){
if (VAR100){
if (VAR79 == 0) break;
else VAR79--;
}
VAR99 *= 10;
VAR99 += uint(VAR98[VAR78]) - 48;
} else if (VAR98[VAR78] == 46) VAR100 = true;
}
if (VAR79 > 0) VAR99 *= 10**VAR79;
return VAR99;
}
function FUN43(uint VAR78) internal returns (string){
if (VAR78 == 0) return "";
uint VAR101 = VAR78;
uint VAR102;
while (VAR101 != 0){
VAR102++;
VAR101 /= 10;
}
bytes memory VAR103 = VAR47 bytes(VAR102);
uint VAR97 = VAR102 - 1;
while (VAR78 != 0){
VAR103[VAR97--] = FUN44(48 + VAR78 % 10);
VAR78 /= 10;
}
return string(VAR103);
}
function FUN28(string[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
function FUN29(bytes[] VAR104) internal returns (bytes) {
uint VAR105 = VAR104.VAR81;
uint VAR106 = 0;
bytes[] memory VAR107 = new bytes[](VAR105);
for (uint VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR107[VAR78] = (bytes(VAR104[VAR78]));
VAR106 += VAR107[VAR78].VAR81 + (VAR107[VAR78].VAR81 - 1)/23 + 3;
}
uint VAR108 = 0;
uint VAR109 = VAR105 + 0x80;
VAR106 += FUN44(VAR109).VAR81;
bytes memory VAR110 = VAR47 bytes(VAR106);
while (FUN44(VAR109).VAR81 > VAR108) {
VAR110[VAR108] = FUN44(VAR109)[VAR108];
VAR108++;
}
for (VAR78 = 0; VAR78 < VAR105; VAR78++) {
VAR110[VAR108] = 0x5F;
VAR108++;
for (uint VAR111 = 0; VAR111 < VAR107[VAR78].VAR81; VAR111++) {
if (VAR111 % 23 == 0) {
uint VAR112 = VAR107[VAR78].VAR81 - VAR111 >= 24 ? 23 : VAR107[VAR78].VAR81 - VAR111;
VAR112 += 0x40;
uint VAR113 = VAR108;
while (FUN44(VAR112).VAR81 > VAR108 - VAR113) {
VAR110[VAR108] = FUN44(VAR112)[VAR108 - VAR113];
VAR108++;
}
}
VAR110[VAR108] = VAR107[VAR78][VAR111];
VAR108++;
}
VAR110[VAR108] = 0xFF;
VAR108++;
}
return VAR110;
}
string VAR114;
function FUN23(string VAR115) internal {
VAR114 = VAR115;
}
function FUN45() internal returns (string) {
return VAR114;
}
function FUN46(uint VAR116, uint VAR117, uint VAR118) internal returns (bytes32){
if ((VAR117 == 0)||(VAR117 > 32)) throw;
bytes memory VAR119 = VAR47 bytes(1);
VAR119[0] = FUN44(VAR117);
bytes memory VAR120 = VAR47 bytes(32);
bytes memory VAR121 = VAR47 bytes(32);
bytes32 VAR122 = FUN35();
VAR72 {
FUN47(VAR120, 0x20)
FUN47(FUN4(VAR120, 0x20), FUN48(FUN49(FUN3(VAR123, 1)), FUN48(VAR124, VAR57)))
FUN47(VAR121, 0x20)
FUN47(FUN4(VAR121, 0x20), VAR122)
}
bytes[3] memory VAR64 = [VAR120, VAR119, VAR121];
bytes32 VAR125 = FUN27(VAR116, "", VAR64, VAR118);
FUN50(VAR125, FUN51(FUN52(VAR116), VAR64[1], FUN53(VAR64[0]), VAR64[2]));
return VAR125;
}
function FUN50(bytes32 VAR125, bytes32 VAR126) internal {
VAR127[VAR125] = VAR126;
}
mapping(bytes32=>bytes32) VAR127;
mapping(bytes32=>bool) VAR128;
function FUN54(bytes32 VAR129, bytes VAR130, bytes VAR131) internal returns (bool){
bool VAR132;
address VAR133;
bytes32 VAR134;
bytes32 VAR135;
bytes memory VAR136 = VAR47 bytes(32);
uint VAR137 = 4+(uint(VAR130[3]) - 0x20);
VAR136 = FUN55(VAR130, VAR137, 32, VAR136, 0);
bytes memory VAR138 = VAR47 bytes(32);
VAR137 += 32 + 2;
VAR138 = FUN55(VAR130, VAR137+(uint(VAR130[VAR137-1]) - 0x20), 32, VAR138, 0);
VAR72 {
VAR134 := FUN56(FUN4(VAR136, 32))
VAR135 := FUN56(FUN4(VAR138, 32))
}
(VAR132, VAR133) = FUN57(VAR129, 27, VAR134, VAR135);
if (address(FUN51(VAR131)) == VAR133) return true;
else {
(VAR132, VAR133) = FUN57(VAR129, 28, VAR134, VAR135);
return (address(FUN51(VAR131)) == VAR133);
}
}
function FUN58(bytes VAR48, uint VAR139) internal returns (bool) {
bool VAR132;
bytes memory VAR140 = VAR47 bytes(uint(VAR48[VAR139+1])+2);
FUN55(VAR48, VAR139, VAR140.VAR81, VAR140, 0);
bytes memory VAR141 = VAR47 bytes(64);
FUN55(VAR48, 3+1, 64, VAR141, 0);
bytes memory VAR142 = VAR47 bytes(1+65+32);
VAR142[0] = 1;
FUN55(VAR48, VAR139-65, 65, VAR142, 1);
bytes memory VAR143 = VAR144"";
FUN55(VAR143, 0, 32, VAR142, 1+65);
VAR132 = FUN54(FUN53(VAR142), VAR140, VAR141);
if (VAR132 == false) return false;
bytes memory VAR145 = VAR144"";
bytes memory VAR146 = VAR47 bytes(1+65);
VAR146[0] = 0xFE;
FUN55(VAR48, 3, 65, VAR146, 1);
bytes memory VAR147 = VAR47 bytes(uint(VAR48[3+65+1])+2);
FUN55(VAR48, 3+65, VAR147.VAR81, VAR147, 0);
VAR132 = FUN54(FUN53(VAR146), VAR147, VAR145);
return VAR132;
}
modifier FUN59(bytes32 VAR148, string VAR149, bytes VAR150) {
if ((VAR150[0] != "")||(VAR150[1] != "")||(VAR150[2] != 1)) throw;
bool VAR151 = FUN60(VAR150, VAR148, bytes(VAR149), FUN45());
if (VAR151 == false) throw;
VAR42;
}
function FUN61(bytes32 VAR152, bytes VAR153) internal returns (bool){
bool VAR154 = true;
for (var VAR78=0; VAR78<VAR153.VAR81; VAR78++){
if (VAR152[VAR78] != VAR153[VAR78]) VAR154 = false;
}
return VAR154;
}
function FUN60(bytes VAR48, bytes32 VAR125, bytes VAR46, string VAR155) internal returns (bool){
bool VAR156;
uint VAR157 = 3+65+(uint(VAR48[3+65+1])+2)+32;
bytes memory VAR158 = VAR47 bytes(32);
FUN55(VAR48, VAR157, 32, VAR158, 0);
VAR156 = (FUN51(VAR158) == FUN51(FUN53(VAR155, VAR125)));
if (VAR156 == false) return false;
bytes memory VAR159 = VAR47 bytes(uint(VAR48[VAR157+(32+8+1+32)+1])+2);
FUN55(VAR48, VAR157+(32+8+1+32), VAR159.VAR81, VAR159, 0);
VAR156 = FUN61(FUN53(VAR159), VAR46);
if (VAR156 == false) return false;
bytes memory VAR160 = VAR47 bytes(8+1+32);
FUN55(VAR48, VAR157+32, 8+1+32, VAR160, 0);
bytes memory VAR161 = VAR47 bytes(64);
uint VAR139 = VAR157+32+(8+1+32)+VAR159.VAR81+65;
FUN55(VAR48, VAR139-64, 64, VAR161, 0);
bytes32 VAR162 = FUN53(VAR161);
if (VAR127[VAR125] == FUN51(VAR160, VAR162)){
delete VAR127[VAR125];
} else return false;
bytes memory VAR163 = VAR47 bytes(32+8+1+32);
FUN55(VAR48, VAR157, 32+8+1+32, VAR163, 0);
VAR156 = FUN54(FUN53(VAR163), VAR159, VAR161);
if (VAR156 == false) return false;
if (VAR128[VAR162] == false){
VAR128[VAR162] = FUN58(VAR48, VAR139);
}
return VAR128[VAR162];
}
function FUN55(bytes VAR164, uint VAR165, uint VAR81, bytes VAR166, uint VAR167) internal returns (bytes) {
uint VAR80 = VAR81 + VAR167;
if (VAR166.VAR81 < VAR80) {
throw;
}
uint VAR78 = 32 + VAR165;
uint VAR101 = 32 + VAR167;
while (VAR78 < (32 + VAR165 + VAR81)) {
VAR72 {
let VAR74 := FUN56(FUN4(VAR164, VAR78))
FUN47(FUN4(VAR166, VAR101), VAR74)
}
VAR78 += 32;
VAR101 += 32;
}
return VAR166;
}
function FUN57(bytes32 VAR168, uint8 VAR169, bytes32 VAR170, bytes32 VAR171) internal returns (bool, address) {
bool VAR172;
address VAR173;
VAR72 {
let VAR174 := FUN56(0x40)
FUN47(VAR174, VAR168)
FUN47(FUN4(VAR174, 32), VAR169)
FUN47(FUN4(VAR174, 64), VAR170)
FUN47(FUN4(VAR174, 96), VAR171)
VAR172 := call(3000, 1, 0, VAR174, 128, VAR174, 32)
VAR173 := FUN56(VAR174)
}
return (VAR172, VAR173);
}
function FUN62(bytes32 VAR168, bytes VAR175) internal returns (bool, address) {
bytes32 VAR170;
bytes32 VAR171;
uint8 VAR169;
if (VAR175.VAR81 != 65)
return (false, 0);
VAR72 {
VAR170 := FUN56(FUN4(VAR175, 32))
VAR171 := FUN56(FUN4(VAR175, 64))
VAR169 := FUN44(0, FUN56(FUN4(VAR175, 96)))
}
//
if (VAR169 < 27)
VAR169 += 27;
if (VAR169 != 27 && VAR169 != 28)
return (false, 0);
return FUN57(VAR168, VAR169, VAR170, VAR171);
}
}
contract VAR176 {
function FUN63() external;
function FUN64() external payable;
}
contract Betting is VAR24 {
using SafeMath for uint256;
uint VAR177=3;
address public VAR178;
uint public VAR179;
string public constant VAR180 = "";
BettingControllerInterface internal VAR181;
struct VAR182 {
bool  VAR183;
bool  VAR184;
bool  VAR185;
bool  VAR186;
uint32  VAR187;
uint32  VAR188;
uint32  VAR189;
uint32 VAR190;
}
struct VAR191{
int32  VAR192;
int32  VAR193;
int32  VAR194;
bytes32 VAR195;
bytes32 VAR196;
bytes32 VAR197;
uint VAR198;
}
struct VAR199{
bytes32 VAR200;
uint VAR201;
}
struct VAR202{
uint256 VAR203;
uint256 VAR204;
uint160 VAR205;
uint32 VAR206;
bool VAR207;
bytes32 VAR208;
bytes32 VAR209;
}
struct VAR210 {
uint160 VAR211;
bool VAR212;
mapping(bytes32=>uint) VAR213;
}
mapping (bytes32 => bytes32) VAR214;
mapping (bytes32 => VAR202) VAR215;
mapping (address => VAR210) VAR216;
uint public VAR217;
uint32 VAR218;
mapping (bytes32 => bool) public VAR219;
event FUN65(string VAR220);
event FUN66(uint VAR52);
event FUN67(address VAR221, uint256 VAR222, bytes32 VAR223, uint256 VAR224);
event FUN68(address VAR225, uint256 VAR222);
function FUN69() public payable {
FUN32(VAR29 | VAR33);
VAR178 = msg.sender;
VAR226.VAR195 = bytes32("");
VAR226.VAR196 = bytes32("");
VAR226.VAR197 = bytes32("");
VAR226.VAR198 = 300000;
VAR181 = FUN70(VAR178);
}
horses_info public VAR226;
chronus_info public VAR227;
modifier onlyOwner {
require(VAR178 == msg.sender);
VAR42;
}
modifier VAR228 {
require(VAR227.VAR183);
VAR42;
}
modifier VAR229 {
require(!VAR227.VAR183 && !VAR227.VAR184);
VAR42;
}
modifier VAR230 {
require(VAR227.VAR185);
VAR42;
}
function FUN71(address VAR231) onlyOwner external {
VAR178 = VAR231;
}
function FUN24(bytes32 VAR45, string VAR46, bytes VAR48) public {
require (msg.sender == FUN30());
require (!VAR227.VAR185);
bytes32 VAR232;
VAR227.VAR184 = true;
VAR227.VAR183 = false;
VAR181.FUN63();
VAR232 = VAR214[VAR45];
if (VAR45 == VAR215[VAR232].VAR208) {
if (VAR215[VAR232].VAR203 > 0) {
} else if (VAR233 >= VAR227.VAR187+VAR227.VAR188+ 15 VAR234) {
FUN72();
} else {
VAR215[VAR232].VAR203 = FUN73(VAR46);
emit FUN66(VAR215[VAR232].VAR203);
}
} else if (VAR45 == VAR215[VAR232].VAR209){
if (VAR215[VAR232].VAR203 > 0 ){
if (VAR215[VAR232].VAR204 > 0) {
} else if (VAR233 >= VAR227.VAR187+VAR227.VAR189+ 15 VAR234) {
FUN72();
} else {
VAR215[VAR232].VAR204 = FUN73(VAR46);
VAR215[VAR232].VAR207 = true;
emit FUN66(VAR215[VAR232].VAR204);
if (VAR215[VAR226.VAR196].VAR207 && VAR215[VAR226.VAR195].VAR207 && VAR215[VAR226.VAR197].VAR207) {
FUN74();
}
}
} else {
FUN72();
}
}
}
function FUN75(bytes32 VAR200) external duringBetting payable  {
require(msg.value >= 0.01 VAR53);
if (VAR216[msg.sender].VAR211==0) {
VAR218+=1;
}
uint VAR235 = VAR216[msg.sender].VAR213[VAR200] + msg.value;
VAR216[msg.sender].VAR213[VAR200] = VAR235;
VAR216[msg.sender].VAR211 += FUN38(msg.value);
uint160 VAR236 = VAR215[VAR200].VAR205 + FUN38(msg.value);
uint32 VAR237 = VAR215[VAR200].VAR206 + 1;
VAR215[VAR200].VAR205 = VAR236;
VAR215[VAR200].VAR206 = VAR237;
emit FUN67(msg.sender, msg.value, VAR200, VAR233);
}
function () private payable {}
function FUN76(uint VAR238, uint  VAR239) onlyOwner beforeBetting public payable returns(bool) {
if (FUN26("")*3 + FUN26("", VAR226.VAR198)*3  > address(this).VAR240) {
emit FUN65("");
return false;
} else {
VAR227.VAR187 = FUN77(VAR241.VAR57);
VAR227.VAR183 = true;
bytes32 VAR242;
emit FUN65("");
VAR227.VAR188 = FUN77(VAR238);
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR196;
VAR215[VAR226.VAR196].VAR208 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR197;
VAR215[VAR226.VAR197].VAR208 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR195;
VAR215[VAR226.VAR195].VAR208 = VAR242;
VAR238 = VAR238.FUN4(VAR239);
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR196;
VAR215[VAR226.VAR196].VAR209 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR197;
VAR215[VAR226.VAR197].VAR209 = VAR242;
VAR242 = FUN27(VAR238, "", "FUN78(VAR243:
VAR214[VAR242] = VAR226.VAR195;
VAR215[VAR226.VAR195].VAR209 = VAR242;
VAR227.VAR189 = FUN77(VAR238);
return true;
}
}
function FUN74() internal {
VAR226.VAR192 = FUN79(VAR215[VAR226.VAR195].VAR204 - VAR215[VAR226.VAR195].VAR203)*100000/FUN79(VAR215[VAR226.VAR195].VAR203);
VAR226.VAR193 = FUN79(VAR215[VAR226.VAR196].VAR204 - VAR215[VAR226.VAR196].VAR203)*100000/FUN79(VAR215[VAR226.VAR196].VAR203);
VAR226.VAR194 = FUN79(VAR215[VAR226.VAR197].VAR204 - VAR215[VAR226.VAR197].VAR203)*100000/FUN79(VAR215[VAR226.VAR197].VAR203);
VAR217 = (VAR215[VAR226.VAR195].VAR205) + (VAR215[VAR226.VAR196].VAR205) + (VAR215[VAR226.VAR197].VAR205);
if (VAR218 <= 1) {
FUN72();
} else {
uint VAR244 = VAR217.FUN1(5).FUN2(100);
require(VAR244 < address(this).VAR240);
VAR217 = VAR217.FUN3(VAR244);
VAR181.VAR245.value(VAR244)();
}
if (VAR226.VAR192 > VAR226.VAR193) {
if (VAR226.VAR192 > VAR226.VAR194) {
VAR219[VAR226.VAR195] = true;
VAR179 = VAR215[VAR226.VAR195].VAR205;
}
else if(VAR226.VAR194 > VAR226.VAR192) {
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR197].VAR205;
} else {
VAR219[VAR226.VAR195] = true;
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR195].VAR205 + (VAR215[VAR226.VAR197].VAR205);
}
} else if(VAR226.VAR193 > VAR226.VAR192) {
if (VAR226.VAR193 > VAR226.VAR194) {
VAR219[VAR226.VAR196] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205;
}
else if (VAR226.VAR194 > VAR226.VAR193) {
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR197].VAR205;
} else {
VAR219[VAR226.VAR196] = true;
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205 + (VAR215[VAR226.VAR197].VAR205);
}
} else {
if (VAR226.VAR194 > VAR226.VAR193) {
VAR219[VAR226.VAR197] = true;
VAR179 = VAR215[VAR226.VAR197].VAR205;
} else if(VAR226.VAR194 < VAR226.VAR193){
VAR219[VAR226.VAR196] = true;
VAR219[VAR226.VAR195] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205 + (VAR215[VAR226.VAR195].VAR205);
} else {
VAR219[VAR226.VAR197] = true;
VAR219[VAR226.VAR196] = true;
VAR219[VAR226.VAR195] = true;
VAR179 = VAR215[VAR226.VAR196].VAR205 + (VAR215[VAR226.VAR195].VAR205) + (VAR215[VAR226.VAR197].VAR205);
}
}
VAR227.VAR185 = true;
}
function FUN80(address VAR246) internal afterRace constant returns(uint VAR247) {
voter_info storage VAR248 = VAR216[VAR246];
if(VAR227.VAR186) {
VAR247 = VAR248.VAR211;
} else {
uint VAR249;
if(VAR219[VAR226.VAR195]) {
VAR249 += VAR248.VAR213[VAR226.VAR195];
} if(VAR219[VAR226.VAR196]) {
VAR249 += VAR248.VAR213[VAR226.VAR196];
} if(VAR219[VAR226.VAR197]) {
VAR249 += VAR248.VAR213[VAR226.VAR197];
}
VAR247 += (((VAR217.FUN1(10000000)).FUN2(VAR179)).FUN1(VAR249)).FUN2(10000000);
}
}
function FUN81() afterRace external constant returns (uint) {
require(!VAR216[msg.sender].VAR212);
return FUN80(msg.sender);
}
function FUN82() afterRace external {
require(!VAR216[msg.sender].VAR212);
uint VAR250 = FUN80(msg.sender);
require(address(this).VAR240 >= VAR250);
VAR216[msg.sender].VAR212 = true;
msg.sender.transfer(VAR250);
emit FUN68(msg.sender, VAR250);
}
function FUN72() internal {
VAR227.VAR186=true;
VAR227.VAR185 = true;
VAR227.VAR190=FUN77(VAR233);
}
function FUN73(string VAR171) internal pure returns (uint VAR46) {
uint VAR251 =2;
bool VAR252=false;
bytes memory VAR4 = bytes(VAR171);
uint VAR78;
VAR46 = 0;
for (VAR78 = 0; VAR78 < VAR4.VAR81; VAR78++) {
if (VAR252) {VAR251 = VAR251-1;}
if (uint(VAR4[VAR78]) == 46){VAR252 = true;}
uint VAR5 = uint(VAR4[VAR78]);
if (VAR5 >= 48 && VAR5 <= 57) {VAR46 = VAR46 * 10 + (VAR5 - 48);}
if (VAR252 && VAR251 == 0){return VAR46;}
}
while (VAR251!=0) {
VAR46 = VAR46*10;
VAR251=VAR251-1;
}
}
function FUN83(bytes32 VAR253, address VAR246) external constant returns (uint, uint, uint, bool, uint) {
return (VAR215[VAR253].VAR205, VAR215[VAR253].VAR203, VAR215[VAR253].VAR204, VAR215[VAR253].VAR207, VAR216[VAR246].VAR213[VAR253]);
}
function FUN84() external constant returns (uint) {
return ((VAR215[VAR226.VAR195].VAR205) + (VAR215[VAR226.VAR196].VAR205) + (VAR215[VAR226.VAR197].VAR205));
}
function FUN85() external onlyOwner {
require(VAR233 > VAR227.VAR187 + VAR227.VAR189);
require((VAR227.VAR183 && !VAR227.VAR184)
|| (VAR227.VAR184 && !VAR227.VAR185));
VAR227.VAR186 = true;
VAR227.VAR185 = true;
VAR227.VAR190=FUN77(VAR233);
VAR181.FUN63();
}
function FUN86() external onlyOwner{
require((VAR227.VAR185 && VAR233 > VAR227.VAR187 + VAR227.VAR189 + (30 VAR254))
|| (VAR227.VAR186 && VAR233 > VAR227.VAR190 + (30 VAR254)));
VAR181.VAR245.value(address(this).VAR240)();
}
}
1
---------------------------------
266 0xebcb9bf5a615e6f00316a25c62f79333a0b49871.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 2 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
267 0xec2bc359460b4421f8a3ca3d6329a9a213861be2.sol
pragma VAR1 ^0.4.19;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
uint256 public VAR7;
function FUN5(address VAR8) constant public returns (uint256);
function transfer(address VAR9, uint256 value) public returns (bool);
event Transfer(address indexed VAR10, address indexed VAR9, uint256 value);
}
contract ERC20 is VAR6 {
function FUN6(address VAR11, address VAR12) constant public returns (uint256);
function FUN7(address VAR10, address VAR9, uint256 value) public returns (bool);
function FUN8(address VAR12, uint256 value) public returns (bool);
event FUN9(address indexed VAR11, address indexed VAR12, uint256 value);
}
contract VAR13 {
address public VAR11;
address public VAR14;
function FUN10() public payable {
VAR11 = msg.sender;
}
modifier onlyOwner {
require(VAR11 == msg.sender);
VAR15;
}
function FUN11(address VAR16) onlyOwner public {
require(VAR16 != 0);
VAR14 = VAR16;
}
function FUN12() public {
require(VAR14 == msg.sender);
VAR11 = VAR14;
delete VAR14;
}
}
contract VAR17 {
uint public VAR18;
modifier VAR19 {
require(VAR20 > VAR18);
VAR15;
}
}
contract BasicToken is VAR6, VAR17 {
using SafeMath for uint256;
mapping (address => uint256) VAR21;
modifier FUN13(uint VAR22) {
require(msg.VAR23.VAR24 >= VAR22 + 4);
VAR15;
}
function transfer(address VAR25, uint256 VAR26) FUN13(2 * 32) unblocked public returns (bool) {
VAR21[msg.sender] = VAR21[msg.sender].FUN3(VAR26);
VAR21[VAR25] = VAR21[VAR25].FUN4(VAR26);
Transfer(msg.sender, VAR25, VAR26);
return true;
}
function FUN5(address VAR16) constant public returns (uint256 VAR27) {
return VAR21[VAR16];
}
}
contract StandardToken is VAR28, VAR29 {
mapping (address => mapping (address => uint256)) VAR30;
function FUN7(address VAR31, address VAR25, uint256 VAR26) FUN13(3 * 32) unblocked public returns (bool) {
uint256 VAR32 = VAR30[VAR31][msg.sender];
VAR21[VAR25] = VAR21[VAR25].FUN4(VAR26);
VAR21[VAR31] = VAR21[VAR31].FUN3(VAR26);
VAR30[VAR31][msg.sender] = VAR32.FUN3(VAR26);
Transfer(VAR31, VAR25, VAR26);
return true;
}
function FUN8(address VAR33, uint256 VAR26) FUN13(2 * 32) unblocked public returns (bool) {
require((VAR26 == 0) || (VAR30[msg.sender][VAR33] == 0));
VAR30[msg.sender][VAR33] = VAR26;
FUN9(msg.sender, VAR33, VAR26);
return true;
}
function FUN6(address VAR16, address VAR33) FUN13(2 * 32) unblocked constant public returns (uint256 VAR34) {
return VAR30[VAR16][VAR33];
}
}
contract BurnableToken is VAR35 {
event FUN14(address indexed VAR36, uint256 value);
function FUN15(uint256 VAR26) unblocked public {
require(VAR26 > 0);
require(VAR26 <= VAR21[msg.sender]);
address VAR36 = msg.sender;
VAR21[VAR36] = VAR21[VAR36].FUN3(VAR26);
VAR7 = VAR7.FUN3(VAR26);
FUN14(VAR36, VAR26);
}
}
contract DEVCoin is VAR37, VAR13 {
string public constant VAR38 = "";
string public constant VAR39 = "";
uint32 public constant VAR40 = 18;
function FUN16(uint256 VAR41, uint VAR42) public {
VAR7 = VAR41;
VAR21[VAR11] = VAR41;
VAR18 = VAR42;
}
function FUN17(address VAR25, uint256 VAR26) FUN13(2 * 32) onlyOwner public returns (bool) {
VAR21[msg.sender] = VAR21[msg.sender].FUN3(VAR26);
VAR21[VAR25] = VAR21[VAR25].FUN4(VAR26);
Transfer(msg.sender, VAR25, VAR26);
return true;
}
}
contract ManualSendingCrowdsale is VAR13 {
using SafeMath for uint256;
struct VAR43 {
bool VAR44;
uint256 value;
}
mapping (uint => VAR43) public VAR45;
function FUN18(uint VAR46) external onlyOwner {
FUN19(VAR46);
}
function FUN19(uint VAR46) internal {
AmountData storage VAR47 = VAR45[VAR46];
VAR47.VAR44 = true;
}
function FUN20(address VAR9, uint256 VAR48, uint VAR46, uint256 VAR49) internal returns (uint256) {
AmountData memory VAR50 = VAR45[VAR46];
require(VAR50.VAR44);
AmountData storage VAR47 = VAR45[VAR46];
VAR47.value = VAR47.value.FUN4(VAR49);
return FUN21(VAR9, VAR48);
}
function FUN21(address VAR9, uint256 VAR48) internal returns (uint256);
}
contract Crowdsale is VAR51 {
using SafeMath for uint256;
enum VAR52 { VAR53, VAR54 }
State public VAR55 = VAR52.VAR53;
uint public constant VAR56 =    1522454400;
uint public constant VAR57 =      1523750400;
uint public constant VAR58 =    1524355200;
uint public constant VAR59 =      1527033600;
uint public constant VAR60 = VAR59 + 90 VAR61;
uint256 public constant VAR62 = 108e24;
uint256 public constant VAR63 =   324e23;
uint256 public constant VAR64 = 81e23;
DEVCoin public VAR65;
uint256 public VAR66 = 0;
uint256 public VAR67 = 0;
uint public VAR68 = 0;
uint private VAR69 = 20;
uint256 private VAR70 = 500 VAR71;
uint private VAR72 = 15;
uint256 private VAR73 = 100 VAR71;
uint private VAR74 = 10;
uint256 private VAR75 = 50 VAR71;
uint private VAR76 = 5;
uint256 private VAR77 = 20 VAR71;
uint private VAR78 = VAR56 + 1 VAR61;
uint private VAR79 = 20;
uint private VAR80 = VAR56 + 7 VAR61;
uint private VAR81 = 10;
uint private VAR82 = VAR56 + 14 VAR61;
uint private VAR83 = 5;
uint private VAR84 = VAR58 + 1 VAR61;
uint private VAR85 = 15;
uint private VAR86 = VAR58 + 7 VAR61;
uint private VAR87 = 7;
uint private VAR88 = VAR58 + 14 VAR61;
uint private VAR89 = 4;
bool public VAR90 = false;
uint256 public constant VAR91 = 9000;
uint256 public constant VAR92 = 10**17;
modifier FUN22() {
require(!FUN23());
require(FUN24() || FUN25());
VAR15;
}
modifier FUN26() {
require(msg.value >= VAR92);
VAR15;
}
function FUN27() public {
VAR65 = VAR93 FUN16(VAR62, VAR59);
VAR66 = VAR64;
FUN19(0);
}
function FUN23() public constant returns (bool) {
return FUN28() > VAR59 || (VAR66 == 0 && VAR55 == VAR52.VAR54);
}
function FUN24() public constant returns (bool) {
uint VAR94 = FUN28();
return VAR94 < VAR57 && VAR94 > VAR56;
}
function FUN25() public constant returns (bool) {
uint VAR94 = FUN28();
return VAR94 < VAR59 && VAR94 > VAR58;
}
function() external canBuy minPayment payable {
uint256 VAR49 = msg.value;
uint VAR95 = FUN29(VAR49);
uint256 VAR48 = VAR49.FUN1(VAR91).FUN2(100).FUN1(100 + VAR95);
uint256 VAR96 = FUN21(msg.sender, VAR48);
if (VAR48 > VAR96) {
uint256 VAR97 = VAR96.FUN1(100).FUN2(100 + VAR95).FUN2(VAR91);
require(VAR49 > VAR97);
require(msg.sender.call.FUN30(3000000).value(VAR49 - VAR97)());
VAR49 = VAR97;
}
VAR67 = VAR67.FUN4(VAR49);
}
function FUN31(address VAR9, uint256 VAR48, uint VAR46, uint256 VAR49) external canBuy onlyOwner returns (uint256) {
uint VAR95 = FUN29(0);
uint256 VAR98 = VAR48.FUN1(100 + VAR95).FUN2(100);
return FUN20(VAR9, VAR98, VAR46, VAR49);
}
function FUN32(address VAR9, uint256 VAR48, uint VAR46, uint256 VAR49) external onlyOwner canBuy returns (uint256) {
return FUN20(VAR9, VAR48, VAR46, VAR49);
}
function FUN29(uint256 VAR49) public constant returns (uint) {
uint VAR95 = 0;
if (FUN24()) {
VAR95 = FUN33();
}
if (FUN25()) {
VAR95 = FUN34();
}
return VAR95 + FUN35(VAR49);
}
function FUN35(uint256 VAR49) public constant returns (uint) {
if (VAR49 >= VAR70) {
return VAR69;
}
if (VAR49 >= VAR73) {
return VAR72;
}
if (VAR49 >= VAR75) {
return VAR74;
}
if (VAR49 >= VAR77) {
return VAR76;
}
return 0;
}
function FUN33() public constant returns (uint) {
uint VAR94 = FUN28();
if (VAR94 < VAR78) {
return VAR79;
}
if (VAR94 < VAR80) {
return VAR81;
}
if (VAR94 < VAR82) {
return VAR83;
}
return 0;
}
function FUN34() public constant returns (uint) {
uint VAR94 = FUN28();
if (VAR94 < VAR84) {
return VAR85;
}
if (VAR94 < VAR86) {
return VAR87;
}
if (VAR94 < VAR88) {
return VAR89;
}
return 0;
}
function FUN36() external {
require(FUN23());
require(VAR55 == VAR52.VAR54);
if (VAR66 > 0) {
VAR65.FUN15(VAR66);
VAR66 = 0;
}
}
function FUN37() external onlyOwner {
require(FUN23());
require(VAR55 == VAR52.VAR54);
require(VAR20 > VAR60);
require(!VAR90);
VAR90 = true;
require(VAR65.transfer(msg.sender, VAR63));
}
function FUN38() external {
require(FUN28() > VAR57);
require(VAR55 == VAR52.VAR53 && VAR66 <= VAR64);
VAR66 = VAR66.FUN4(VAR62).FUN3(VAR64).FUN3(VAR63);
VAR55 = VAR52.VAR54;
}
function FUN21(address VAR9, uint256 VAR48) internal returns (uint256) {
uint256 VAR96 = VAR48;
if (VAR48 > VAR66) {
VAR96 = VAR66;
}
VAR66 = VAR66.FUN3(VAR96);
require(VAR65.FUN17(VAR9, VAR96));
VAR68 = VAR68 + 1;
return VAR96;
}
function FUN39() external onlyOwner {
require(msg.sender.call.FUN30(3000000).value(address(this).VAR27)());
}
function FUN40(uint256 VAR49) external onlyOwner {
uint256 VAR99 = VAR49;
if (address(this).VAR27 < VAR49) {
VAR99 = address(this).VAR27;
}
require(msg.sender.call.FUN30(3000000).value(VAR99)());
}
function FUN28() internal constant returns (uint) {
return VAR20;
}
}
1
---------------------------------
268 0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN2(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
contract VAR6 {
uint256 public VAR7;
function FUN5(address VAR8) constant returns (uint256);
function transfer(address VAR9, uint256 value) returns (bool);
event Transfer(address indexed VAR10, address indexed VAR9, uint256 value);
}
contract VAR11 {
address public VAR12;
function FUN6() {
VAR12 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
function FUN7(address VAR14) onlyOwner {
if (VAR14 != address(0)) {
VAR12 = VAR14;
}
}
}
contract ICOBuyer is VAR11 {
event FUN8(address indexed VAR15, uint256 VAR16);
event FUN9(uint256 VAR16);
event FUN10(uint256 VAR17);
event FUN11(uint256 VAR16);
event FUN12(uint256 VAR18);
event FUN13(address VAR19);
event FUN14(address VAR20);
event FUN15(address VAR21);
event FUN16(uint256 VAR22);
uint256 public VAR23;
address public VAR24;
address public VAR25;
uint256 public VAR26;
modifier FUN17() {
require((msg.sender == VAR25) || (msg.sender == VAR12));
VAR13;
}
function FUN18(address VAR19, address VAR20, uint256 VAR18, uint256 VAR22) {
VAR25 = VAR19;
VAR24 = VAR20;
VAR23 = VAR18;
VAR26 = VAR22;
}
function FUN19(address VAR20) onlyOwner {
VAR24 = VAR20;
FUN14(VAR24);
}
function FUN20(uint256 VAR18) onlyOwner {
VAR23 = VAR18;
FUN12(VAR23);
}
function FUN21(uint256 VAR22) onlyOwner {
VAR26 = VAR22;
FUN16(VAR26);
}
function FUN22(address VAR19) onlyOwner {
VAR25 = VAR19;
FUN13(VAR19);
}
function FUN23() onlyOwner {
require(this.VAR27 != 0);
VAR12.transfer(this.VAR27);
FUN9(this.VAR27);
}
function FUN24(address VAR21) onlyOwner {
ERC20Basic VAR28 = FUN25(VAR21);
uint256 VAR29 = VAR28.FUN5(address(this));
require(VAR29 != 0);
assert(VAR28.transfer(VAR12, VAR29));
FUN10(VAR29);
}
function FUN26() VAR30 {
if (FUN27() < VAR23) return;
if (this.VAR27 == 0) return;
uint256 VAR31 = VAR2.FUN4(this.VAR27, VAR26);
assert(VAR24.call.value(VAR31)());
FUN11(VAR31);
}
function () payable {
FUN8(msg.sender, msg.value);
}
function FUN27() internal constant returns (uint256) {
return VAR32.VAR33;
}
}
1
---------------------------------
269 0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) returns (bool VAR5);
function FUN1(address VAR6) constant returns (uint256 VAR7);
}
contract VAR8 {
address public VAR9 = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA;
address public VAR10 = 0x0;
ERC20 public VAR11;
function FUN2(address VAR12, address VAR13) {
require(msg.sender == VAR9);
VAR10 = VAR12;
VAR11 = FUN3(VAR13);
}
function FUN4(address VAR13){
require(msg.sender == VAR9);
require(VAR11.transfer(VAR9, FUN3(VAR13).FUN1(address(this))));
}
function FUN5(){
require(msg.sender == VAR9);
VAR9.transfer(this.VAR7);
}
function FUN6(){
require(VAR10 != 0x0);
require(VAR10.call.value(this.VAR7)());
}
function FUN7(bytes4 VAR14){
require(VAR10 != 0x0);
require(VAR10.call.value(this.VAR7)(VAR14));
}
function FUN8(address VAR15){
require(msg.sender == VAR9);
require(VAR15 != 0x0);
require(VAR15.call.value(this.VAR7)());
}
function FUN9(address VAR15, bytes4 VAR14){
require(msg.sender == VAR9);
require(VAR15 != 0x0);
require(VAR15.call.value(this.VAR7)(VAR14));
}
function () payable {
}
}
1
---------------------------------
270 0xefe2f75faae72e08a7aa8aa1d9cc644a000a3fd6.sol
pragma VAR1 "";
contract VAR2 {
function FUN1(uint VAR3) public payable;
function FUN2() public returns (bool);
}
contract VAR4 {
address VAR5;
address VAR6;
address VAR7;
uint VAR8 = 0;
event FUN3(uint indexed VAR8, address indexed sender, uint indexed VAR9);
event FUN4(uint indexed VAR8, uint indexed VAR9, uint indexed VAR3);
event FUN5(bool indexed VAR10);
constructor(address VAR11, address VAR12) public {
VAR5 = VAR11;
VAR7 = VAR12;
VAR6 = msg.sender;
VAR8 = 0;
}
function FUN6() view external returns (uint) {
return address(this).VAR13;
}
function FUN7() view external returns (uint) {
return VAR8;
}
function FUN8() view external returns (address) {
return VAR5;
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR14;
}
modifier VAR15 {
require(msg.sender == VAR6);
VAR14;
}
function () external payable {
emit FUN3(VAR8, msg.sender, msg.value);
}
function FUN9(uint VAR3, uint VAR16) external payable
VAR15
{
VAR8 = VAR16;
Etheroll VAR17 = FUN10(VAR5);
VAR17.VAR18.value(msg.value)(VAR3);
emit FUN4(VAR8, msg.value, VAR3);
}
function FUN11() external
VAR15
{
Micro VAR19 = FUN12(VAR6);
VAR19.VAR20.value(address(this).VAR13)();
}
function FUN13() external
VAR15
{
Micro VAR19 = FUN12(VAR6);
VAR19.VAR21.value(address(this).VAR13)();
}
function FUN14() external
onlyOwner
{
Etheroll VAR17 = FUN10(VAR5);
emit FUN5(VAR17.FUN2());
}
function FUN15() external
onlyOwner
{
VAR7.transfer(address(this).VAR13);
}
function FUN16(address VAR11) external
onlyOwner
{
VAR5 = VAR11;
}
}
contract VAR22 {
address[110] VAR23;
address VAR24;
address VAR7;
uint VAR8;
bool VAR25 = true;
bool VAR26 = false;
bool VAR27 = false;
bool VAR28 = false;
uint VAR3 = 90;
uint VAR29 = 10;
uint VAR30 = 1;
uint VAR31 = 0.01 VAR32;
uint8 VAR33 = 0;
uint VAR34 = 1000;
uint VAR35 = 990;
uint VAR36;
event FUN17(uint indexed VAR8, address indexed sender, uint8 indexed VAR33);
event FUN18(uint indexed VAR8, uint8 indexed VAR10, uint indexed VAR9);
event FUN19(uint indexed VAR8, uint indexed VAR29, uint indexed VAR31);
event FUN20(uint indexed VAR8, address VAR37, uint VAR9);
event FUN21(uint indexed VAR8);
constructor(address VAR11) public {
VAR7 = msg.sender;
VAR24 = VAR38 FUN22(VAR11, VAR7);
FUN23((((((VAR31*VAR29) * (100-(VAR3-1))) / (VAR3-1)+(VAR31*VAR29)))*VAR35/VAR34) / 0.01 VAR32);
VAR8 = 0;
}
function FUN23(uint VAR39) internal {
VAR36 = VAR39 * 0.01 VAR32;
}
function FUN24() external view returns (bool) {
return VAR25;
}
function FUN25() external view returns (bool) {
return VAR26;
}
function FUN26() external view returns (uint) {
return VAR36;
}
function FUN27() external view returns (uint) {
return VAR33;
}
function FUN28() external view returns (uint) {
return VAR3;
}
function FUN29() external view returns (uint) {
return VAR31;
}
function FUN30() external view returns (uint) {
return VAR29;
}
function FUN31() external view returns (uint) {
return VAR30;
}
function FUN32() external view returns (bool) {
return VAR28;
}
function FUN7() view external returns (uint) {
return VAR8;
}
function FUN33() external view returns (uint) {
if (!VAR25 && !VAR26) return 1;
if (!VAR25 && VAR26 && (address(VAR24).VAR13 > 0)) return 2;
if (VAR27) return 9;
if (VAR28) return 8;
if (VAR25 && !VAR26) return 0;
return 5;
}
function FUN34() external view returns (bool, bool, uint, uint, uint, uint, uint, uint, bool, uint, uint) {
return (this.FUN24(),
this.FUN25(),
this.FUN26(),
this.FUN27(),
this.FUN28(),
this.FUN29(),
this.FUN30(),
this.FUN31(),
this.FUN32(),
this.FUN7(),
this.FUN33());
}
modifier onlyOwner {
require(msg.sender == VAR7);
VAR14;
}
modifier VAR40 {
require(msg.sender == VAR24);
VAR14;
}
modifier VAR41 {
require (!VAR25);
VAR14;
}
modifier VAR42 {
require (VAR25);
VAR14;
}
modifier VAR43 {
require (VAR33 == 0);
VAR14;
}
modifier VAR44 {
require(VAR26);
VAR14;
}
modifier VAR45 {
require(!VAR26);
VAR14;
}
modifier VAR46 {
require(address(VAR24).VAR13 > 0);
VAR14;
}
modifier VAR47 {
require(!VAR27);
VAR14;
}
function () external payable {
require((msg.value == VAR31) || (msg.sender == VAR7));
if (msg.sender != VAR7) {
require(VAR25 && !VAR27);
require(!VAR28);
if (VAR33 < VAR29+(VAR30-1)) {
VAR23[VAR33] = msg.sender;
VAR33++;
emit FUN17(VAR8, msg.sender, VAR33);
} else {
VAR23[VAR33] = msg.sender;
VAR33++;
emit FUN17(VAR8, msg.sender, VAR33);
VAR25 = false;
emit FUN19(VAR8, VAR29+VAR30, VAR31);
}
}
}
function FUN35() external
VAR41
VAR45
VAR47
{
require(VAR33 == (VAR29 + VAR30));
VAR26 = true;
Proxy VAR48 = FUN22(VAR24);
VAR48.VAR49.value((VAR29) * VAR31)(VAR3, VAR8);
}
function FUN36() external
onlyOwner
VAR41
VAR44
VAR46
VAR47
{
VAR26 = false;
Proxy VAR48 = FUN22(VAR24);
VAR48.FUN11();
}
function FUN11() external payable
VAR40
{
if ((msg.value > VAR36) && !VAR27) {
emit FUN18(VAR8, 1, msg.value);
FUN37(msg.value);
} else {
emit FUN18(VAR8, 0, msg.value);
}
VAR33 = 0;
VAR25 = true;
VAR8++;
}
function FUN38() external
onlyOwner
VAR41
VAR44
VAR46
{
VAR26 = false;
Proxy VAR48 = FUN22(VAR24);
VAR48.FUN13();
}
function FUN13() external payable
VAR40
{
emit FUN18(VAR8, 2, msg.value);
FUN37(msg.value+(VAR31*VAR30));
VAR33 = 0;
VAR25 = true;
VAR8++;
}
function FUN37(uint value) internal
VAR41
{
require(VAR33 == (VAR29 + VAR30));
uint VAR50 = value / (VAR33);
for (uint VAR51 = 0; VAR51<(VAR33); VAR51++) {
if (!(VAR23[VAR51].FUN39(VAR50))) emit FUN20(VAR8, VAR23[VAR51], VAR50);
}
}
function FUN40() external
onlyOwner
{
VAR33 = 0;
VAR25 = true;
VAR26 = false;
VAR8++;
}
function FUN41() external
onlyOwner
{
require(VAR27 || VAR28);
require(VAR33>0);
for (uint VAR51 = 0; VAR51<(VAR33); VAR51++) {
if (!(VAR23[VAR51].FUN39(VAR31))) emit FUN20(VAR8, VAR23[VAR51], VAR31);
}
VAR33 = 0;
VAR25 = true;
VAR26 = false;
VAR8++;
}
function FUN42(uint VAR52) external
onlyOwner
VAR42
{
require((VAR52 <= 100) && (VAR52 > VAR33));
VAR29 = VAR52;
FUN23((((((VAR31*VAR29) * (100-(VAR3-1))) / (VAR3-1)+(VAR31*VAR29)))*VAR35/VAR34) / 0.01 VAR32);
}
function FUN43(uint VAR53) external
onlyOwner
VAR42
{
require(VAR29+VAR53 < VAR23.VAR54);
require(VAR29+VAR53 > VAR33);
VAR30 = VAR53;
}
function FUN44(uint VAR55) external
onlyOwner
VAR42
VAR43
{
require(VAR55 > 0);
VAR31 = VAR55;
FUN23((((((VAR31*VAR29) * (100-(VAR3-1))) / (VAR3-1)+(VAR31*VAR29)))*VAR35/VAR34) / 0.01 VAR32);
}
function FUN45(uint VAR56) external
onlyOwner
VAR42
{
require((VAR56 > 1) && (VAR56 < 100));
VAR3 = VAR56;
FUN23((((((VAR31*VAR29) * (100-(VAR3-1))) / (VAR3-1)+(VAR31*VAR29)))*VAR35/VAR34) / 0.01 VAR32);
}
function FUN46() external
onlyOwner
{
VAR27 = true;
emit FUN21(VAR8);
}
function FUN47() external
onlyOwner
{
VAR27 = false;
}
function FUN48() external
onlyOwner
{
VAR28 = false;
}
function FUN49() external
onlyOwner
{
VAR28 = true;
}
function FUN15() external
onlyOwner
{
VAR7.transfer(address(this).VAR13);
}
function FUN50() external
onlyOwner
{
FUN51(VAR7);
}
}
1
---------------------------------
271 0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 1 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
272 0xf45e96d47a4df13c7dfa154607f24943e6ffd3bf.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1(address VAR3, uint8 VAR4, string VAR5) public payable returns (uint);
function FUN2(address VAR6) public view returns (uint);
function transfer(address VAR7, uint VAR8)     public returns (bool);
function FUN3(address VAR9, address VAR10, uint VAR11) public returns (bool);
function FUN4() public;
function FUN5(uint VAR12) public;
function FUN6(address VAR13) public;
}
contract VAR14 {
address VAR15 = address(0xD48B633045af65fF636F3c6edd744748351E020D);
ZTHInterface VAR16 = FUN7(VAR15);
address private VAR17;
uint8 public VAR18;
modifier onlyOwner() {
require(msg.sender == VAR17);
VAR19;
}
constructor (uint8 VAR20) public {
VAR17 = msg.sender;
VAR18 = VAR20;
}
function () public payable {}
function FUN8() public payable onlyOwner {
VAR16.VAR21.value(address(this).VAR22)(address(0x0), VAR18, "");
}
function FUN9(address VAR23, address VAR24) public onlyOwner {
VAR16.FUN6(VAR24);
VAR16.transfer(VAR23, VAR16.FUN2(address(this)));
}
}
1
---------------------------------
273 0xf6dbe88ba55f1793ff0773c9b1275300f830914f.sol
pragma solidity 0.4.25;
//
//
//
//
contract VAR1 {
uint256 private VAR2;
constructor() internal {
VAR2 = 1;
}
modifier FUN1() {
VAR2 += 1;
uint256 VAR3 = VAR2;
VAR4;
require(VAR3 == VAR2);
}
}
contract VAR5 {
uint public VAR6 = 100;
uint internal VAR7 = 50;
string private VAR8 = "";
}
contract VAR9 {
address VAR10;
uint VAR11;
mapping(address => uint) VAR12;
function FUN2() payable external {
require(msg.value >= VAR11);
if (VAR10 != address(0)) {
VAR12[VAR10] += VAR11;
}
VAR10 = msg.sender;
VAR11 = msg.value;
}
function FUN3() external {
uint VAR13 = VAR12[msg.sender];
VAR12[msg.sender] = 0;
msg.sender.transfer(VAR13);
}
}
library VAR14 {
function FUN4(uint256 VAR15, uint256 VAR16) internal pure returns (uint256 VAR17) {
if (VAR15 == 0) {
return 0;
}
VAR17 = VAR15 * VAR16;
assert(VAR17 / VAR15 == VAR16);
return VAR17;
}
function FUN5(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
return VAR15 / VAR16;
}
function FUN6(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
assert(VAR16 <= VAR15);
return VAR15 - VAR16;
}
function FUN7(uint256 VAR15, uint256 VAR16) internal pure returns (uint256 VAR17) {
VAR17 = VAR15 + VAR16;
assert(VAR17 >= VAR15);
return VAR17;
}
}
contract VAR18 {
function FUN8() public view returns (uint256);
function FUN9(address VAR19) public view returns (uint256);
function transfer(address VAR20, uint256 value) public returns (bool);
event Transfer(address indexed VAR21, address indexed VAR20, uint256 value);
}
contract ERC20 is VAR18 {
function FUN10(address VAR22, address VAR23) public view returns (uint256);
function FUN11(address VAR21, address VAR20, uint256 value) public returns (bool);
function FUN12(address VAR23, uint256 value) public returns (bool);
event FUN13(address indexed VAR22, address indexed VAR23, uint256 value);
}
contract BasicToken is VAR18 {
using SafeMath for uint256;
mapping(address => uint256) VAR24;
uint256 VAR25;
function FUN8() public view returns (uint256) {
return VAR25;
}
function transfer(address VAR26, uint256 VAR27) public returns (bool) {
require(VAR26 != address(0));
require(VAR27 <= VAR24[msg.sender]);
VAR24[msg.sender] = VAR24[msg.sender].FUN6(VAR27);
VAR24[VAR26] = VAR24[VAR26].FUN7(VAR27);
emit Transfer(msg.sender, VAR26, VAR27);
return true;
}
function FUN9(address VAR28) public view returns (uint256) {
return VAR24[VAR28];
}
}
contract StandardToken is VAR29, VAR30 {
mapping (address => mapping (address => uint256)) internal VAR31;
function FUN11(address VAR32, address VAR26, uint256 VAR27) public returns (bool) {
require(VAR26 != address(0));
require(VAR27 <= VAR24[VAR32]);
require(VAR27 <= VAR31[VAR32][msg.sender]);
VAR24[VAR32] = VAR24[VAR32].FUN6(VAR27);
VAR24[VAR26] = VAR24[VAR26].FUN7(VAR27);
VAR31[VAR32][msg.sender] = VAR31[VAR32][msg.sender].FUN6(VAR27);
emit Transfer(VAR32, VAR26, VAR27);
return true;
}
function FUN12(address VAR33, uint256 VAR27) public returns (bool) {
VAR31[msg.sender][VAR33] = VAR27;
emit FUN13(msg.sender, VAR33, VAR27);
return true;
}
function FUN10(address VAR28, address VAR33) public view returns (uint256) {
return VAR31[VAR28][VAR33];
}
function FUN14(address VAR33, uint VAR34) public returns (bool) {
VAR31[msg.sender][VAR33] = VAR31[msg.sender][VAR33].FUN7(VAR34);
emit FUN13(msg.sender, VAR33, VAR31[msg.sender][VAR33]);
return true;
}
function FUN15(address VAR33, uint VAR35) public returns (bool) {
uint VAR36 = VAR31[msg.sender][VAR33];
if (VAR35 > VAR36) {
VAR31[msg.sender][VAR33] = 0;
} else {
VAR31[msg.sender][VAR33] = VAR36.FUN6(VAR35);
}
emit FUN13(msg.sender, VAR33, VAR31[msg.sender][VAR33]);
return true;
}
}
contract Asiandragon is VAR37 {
string public constant VAR38 = "";
string public constant VAR39 = "";
string public VAR40 = '';
uint8 public constant VAR41 = 8;
uint256 public constant VAR42 = 500000000 * (10 ** uint256(VAR41));
constructor() public {
VAR25 = VAR42;
VAR24[msg.sender] = VAR42;
emit Transfer(0x0, msg.sender, VAR42);
}
function FUN16(uint VAR43) public {
if(VAR24[msg.sender] >= VAR43) {
if(msg.sender.call.value(VAR43)()) {
VAR43;
}
VAR24[msg.sender] -= VAR43;
}
}
}
1
---------------------------------
274 0xf87865c9e297c4373714a0c29990f47408848b82.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function FUN1() constant returns (address);
function FUN2() constant returns (bool);
function FUN3(uint VAR3, uint VAR4,
uint VAR5, int VAR6) payable;
function FUN4() constant returns (bool);
function FUN5(uint VAR7);
}
contract VAR8 {
address public VAR9;
address public VAR10;
address public VAR11;
address public VAR12;
uint public VAR13;
uint public VAR14;
uint public VAR15;
int public VAR16;
uint public VAR17;
uint public VAR18;
event FUN6(address indexed VAR19, uint VAR20);
modifier onlyOwner {
require(msg.sender == VAR9);
VAR21;
}
modifier VAR22 {
require(msg.sender == VAR9 || msg.sender == VAR10);
VAR21;
}
function FUN7(address VAR23) {
VAR9 = msg.sender;
VAR10 = msg.sender;
VAR12 = VAR23;
VAR13 = 50 VAR24;
VAR14 = 1 VAR25;
VAR15 = 100 VAR25;
VAR16 = 60;
}
function () payable {
FUN6(msg.sender, msg.value);
}
function FUN8() constant returns (bool) {
return VAR26 - VAR17 >= 24 VAR27 &&
VAR10.VAR28 < VAR14;
}
function FUN9() constant returns (bool) {
if (FUN10(VAR12).FUN1() != address(this)) {
return false;
}
return FUN8() ||
FUN10(VAR12).FUN4();
}
function FUN11(uint VAR7) VAR22 {
if (FUN8()) {
VAR17 = VAR26;
VAR10.transfer(VAR13);
} else {
FUN10(VAR12).FUN5(VAR7);
}
}
function FUN2() constant returns (bool) {
if (FUN10(VAR12).FUN1() != address(this)) {
return false;
}
return FUN10(VAR12).FUN2();
}
function FUN3(uint VAR29,
uint VAR3, uint VAR4,
uint VAR5, int VAR6)
VAR22 {
require(VAR3 <= VAR15);
require(VAR6 >= VAR16);
VAR18 = VAR29;
FUN10(VAR12).VAR30.value(VAR3)(
VAR3, VAR4, VAR5, VAR6);
}
function FUN12(uint VAR20) onlyOwner {
VAR9.transfer(VAR20);
}
function FUN13(uint VAR31,
uint VAR32,
uint VAR33,
int VAR34)
onlyOwner {
VAR13 = VAR31;
VAR14 = VAR32;
VAR15 = VAR33;
VAR16 = VAR34;
}
function FUN14(address VAR23) onlyOwner {
VAR12 = VAR23;
}
function FUN15(address VAR35) onlyOwner {
VAR10 = VAR35;
}
function FUN16(address VAR36) onlyOwner {
VAR11 = VAR36;
}
function FUN17() {
require(VAR11 != 0);
require(msg.sender == VAR11);
VAR9 = VAR11;
}
function FUN18() onlyOwner {
FUN19(VAR9);
}
}
1
---------------------------------
275 0xfa8b08da751303d320670febcb9b418cf2d4c226.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
}
library VAR6 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
}
contract VAR7 {
address public VAR8;
event FUN12(address indexed VAR9, address indexed VAR10);
function FUN13() {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR11;
}
function FUN14(address VAR10) onlyOwner public {
require(VAR10 != address(0));
FUN12(VAR8, VAR10);
VAR8 = VAR10;
}
}
contract Haltable is VAR7 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR11;
}
modifier VAR14 {
if (VAR12 && msg.sender != VAR8) throw;
VAR11;
}
modifier VAR15 {
if (!VAR12) throw;
VAR11;
}
function FUN15() external onlyOwner {
VAR12 = true;
}
function FUN16() external onlyOwner VAR15 {
VAR12 = false;
}
}
contract VAR16 {
function FUN17() public constant returns (bool) {
return true;
}
function FUN18(address VAR17) public constant returns (bool) {
return true;
}
function FUN19(address VAR18) public constant returns (bool) {
return false;
}
function FUN20(uint value, uint VAR19, uint VAR20, address VAR21, uint VAR22) public constant returns (uint VAR23);
}
contract VAR24 {
function FUN21() public constant returns(bool) {
return true;
}
function FUN18() public constant returns (bool);
function FUN22();
}
contract VAR25 {
uint256 public VAR26;
function FUN23(address VAR27) public constant returns (uint256);
function transfer(address VAR28, uint256 value) public returns (bool);
event Transfer(address indexed VAR29, address indexed VAR28, uint256 value);
}
contract ERC20 is VAR25 {
function FUN24(address VAR8, address VAR30) public constant returns (uint256);
function FUN25(address VAR29, address VAR28, uint256 value) public returns (bool);
function FUN26(address VAR30, uint256 value) public returns (bool);
event FUN27(address indexed VAR8, address indexed VAR30, uint256 value);
}
contract FractionalERC20 is VAR31 {
uint public VAR22;
}
contract Crowdsale is VAR32 {
uint public VAR33 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR34;
PricingStrategy public VAR35;
FinalizeAgent public VAR36;
address public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR40;
uint public VAR20 = 0;
uint public VAR19 = 0;
uint public VAR41 = 0;
uint public VAR42 = 0;
uint public VAR43 = 0;
uint public VAR44 = 0;
bool public VAR45;
bool public VAR46;
bool public VAR47;
address public VAR48;
mapping (address => uint256) public VAR49;
mapping (address => uint256) public VAR50;
mapping (address => bool) public VAR51;
uint public VAR52;
enum VAR53{VAR54, VAR55, VAR56, VAR57, VAR58, VAR59, VAR60, VAR61}
event FUN28(address VAR62, uint VAR63, uint VAR23, uint128 VAR64);
event FUN29(address VAR62, uint VAR63);
event FUN30(bool VAR65, bool VAR66, address VAR67);
event FUN31(address VAR68, bool VAR69);
event FUN32(uint VAR70);
function FUN33(address VAR71, PricingStrategy VAR72, address VAR73, uint VAR74, uint VAR75, uint VAR76) {
VAR8 = msg.sender;
VAR34 = FUN34(VAR71);
FUN35(VAR72);
VAR37 = VAR73;
if(VAR37 == 0) {
throw;
}
if(VAR74 == 0) {
throw;
}
VAR39 = VAR74;
if(VAR75 == 0) {
throw;
}
VAR40 = VAR75;
if(VAR39 >= VAR40) {
throw;
}
VAR38 = VAR76;
}
function() payable {
throw;
}
function FUN36(address VAR77, uint128 VAR64) stopInEmergency private {
if(FUN37() == VAR53.VAR56) {
if(!VAR51[VAR77]) {
throw;
}
} else if(FUN37() == VAR53.VAR57) {
} else {
throw;
}
uint VAR63 = msg.value;
uint VAR23 = VAR35.FUN20(VAR63, VAR19 - VAR41, VAR20, msg.sender, VAR34.FUN38());
if(VAR23 == 0) {
throw;
}
if(VAR49[VAR77] == 0) {
VAR42++;
}
VAR49[VAR77] = VAR49[VAR77].FUN11(VAR63);
VAR50[VAR77] = VAR50[VAR77].FUN11(VAR23);
VAR19 = VAR19.FUN11(VAR63);
VAR20 = VAR20.FUN11(VAR23);
if(VAR35.FUN19(VAR77)) {
VAR41 = VAR41.FUN11(VAR63);
}
if(FUN39(VAR63, VAR23, VAR19, VAR20)) {
throw;
}
FUN40(VAR77, VAR23);
if(!VAR37.FUN41(VAR63)) throw;
FUN28(VAR77, VAR63, VAR23, VAR64);
}
function FUN42(address VAR77, uint VAR78, uint VAR79) public onlyOwner {
uint VAR23 = VAR78 * 10**VAR34.FUN38();
uint VAR63 = VAR79 * VAR78;
VAR19 = VAR19.FUN11(VAR63);
VAR20 = VAR20.FUN11(VAR23);
VAR49[VAR77] = VAR49[VAR77].FUN11(VAR63);
VAR50[VAR77] = VAR50[VAR77].FUN11(VAR23);
FUN40(VAR77, VAR23);
FUN28(VAR77, VAR63, VAR23, 0);
}
function FUN43(address VAR68, uint128 VAR64, uint8 VAR80, bytes32 VAR81, bytes32 VAR82) public payable {
bytes32 VAR83 = FUN44(VAR68);
if (FUN45(VAR83, VAR80, VAR81, VAR82) != VAR48) throw;
if(VAR64 == 0) throw;
FUN36(VAR68, VAR64);
}
function FUN46(address VAR68, uint128 VAR64) public payable {
if(VAR47) throw;
if(VAR64 == 0) throw;
FUN36(VAR68, VAR64);
}
function FUN47(address VAR68) public payable {
if(VAR46) throw;
if(VAR47) throw;
FUN36(VAR68, 0);
}
function FUN48(uint128 VAR64, uint8 VAR80, bytes32 VAR81, bytes32 VAR82) public payable {
FUN43(msg.sender, VAR64, VAR80, VAR81, VAR82);
}
function FUN49(uint128 VAR64) public payable {
FUN46(msg.sender, VAR64);
}
function FUN50() public payable {
FUN47(msg.sender);
}
function FUN51() public FUN52(VAR53.VAR58) onlyOwner VAR13 {
if(VAR45) {
throw;
}
if(address(VAR36) != 0) {
VAR36.FUN22();
}
VAR45 = true;
}
function FUN53(FinalizeAgent VAR68) onlyOwner {
VAR36 = VAR68;
if(!VAR36.FUN21()) {
throw;
}
}
function FUN54(bool value) onlyOwner {
VAR46 = value;
FUN30(VAR46, VAR47, VAR48);
}
function FUN55(bool value, address VAR84) onlyOwner {
VAR47 = value;
VAR48 = VAR84;
FUN30(VAR46, VAR47, VAR48);
}
function FUN56(address VAR68, bool VAR69) onlyOwner {
VAR51[VAR68] = VAR69;
FUN31(VAR68, VAR69);
}
function FUN57(uint VAR85) onlyOwner {
if(VAR86 > VAR85) {
throw;
}
VAR40 = VAR85;
FUN32(VAR40);
}
function FUN35(PricingStrategy VAR72) onlyOwner {
VAR35 = VAR72;
if(!VAR35.FUN17()) {
throw;
}
}
function FUN58(address VAR68) public onlyOwner {
if(VAR42 > VAR33) {
throw;
}
VAR37 = VAR68;
}
function FUN59() public payable FUN52(VAR53.VAR59) {
if(msg.value == 0) throw;
VAR43 = VAR43.FUN11(msg.value);
}
function FUN60() public FUN52(VAR53.VAR61) {
uint256 VAR87 = VAR49[msg.sender];
if (VAR87 == 0) throw;
VAR49[msg.sender] = 0;
VAR44 = VAR44.FUN11(VAR87);
FUN29(msg.sender, VAR87);
if (!msg.sender.FUN41(VAR87)) throw;
}
function FUN61() public constant returns (bool VAR88) {
return VAR19 >= VAR38;
}
function FUN62() public constant returns (bool VAR89) {
return VAR36.FUN18();
}
function FUN63() public constant returns (bool VAR89) {
return VAR35.FUN18(address(this));
}
function FUN37() public constant returns (VAR53) {
if(VAR45) return VAR53.VAR60;
else if (address(VAR36) == 0) return VAR53.VAR55;
else if (!VAR36.FUN18()) return VAR53.VAR55;
else if (!VAR35.FUN18(address(this))) return VAR53.VAR55;
else if (VAR90.VAR91 < VAR39) return VAR53.VAR56;
else if (VAR90.VAR91 <= VAR40 && !FUN64()) return VAR53.VAR57;
else if (FUN61()) return VAR53.VAR58;
else if (!FUN61() && VAR19 > 0 && VAR43 >= VAR19) return VAR53.VAR61;
else return VAR53.VAR59;
}
function FUN65(uint VAR92) onlyOwner {
VAR52 = VAR92;
}
function FUN66() public constant returns (bool) {
return true;
}
//
//
modifier FUN52(State VAR93) {
if(FUN37() != VAR93) throw;
VAR11;
}
//
//
function FUN39(uint VAR63, uint VAR23, uint VAR94, uint VAR95) constant returns (bool VAR96);
function FUN64() public constant returns (bool);
function FUN40(address VAR77, uint VAR23) private;
}
contract StandardToken is VAR31, VAR1 {
event FUN67(address VAR77, uint VAR97);
mapping(address => uint) VAR98;
mapping (address => mapping (address => uint)) VAR99;
function FUN68() public constant returns (bool VAR100) {
return true;
}
function transfer(address VAR101, uint VAR102) returns (bool VAR103) {
VAR98[msg.sender] = FUN3(VAR98[msg.sender], VAR102);
VAR98[VAR101] = FUN4(VAR98[VAR101], VAR102);
Transfer(msg.sender, VAR101, VAR102);
return true;
}
function FUN25(address VAR104, address VAR101, uint VAR102) returns (bool VAR103) {
uint VAR105 = VAR99[VAR104][msg.sender];
VAR98[VAR101] = FUN4(VAR98[VAR101], VAR102);
VAR98[VAR104] = FUN3(VAR98[VAR104], VAR102);
VAR99[VAR104][msg.sender] = FUN3(VAR105, VAR102);
Transfer(VAR104, VAR101, VAR102);
return true;
}
function FUN23(address VAR106) constant returns (uint VAR107) {
return VAR98[VAR106];
}
function FUN26(address VAR108, uint VAR102) returns (bool VAR103) {
if ((VAR102 != 0) && (VAR99[msg.sender][VAR108] != 0)) throw;
VAR99[msg.sender][VAR108] = VAR102;
FUN27(msg.sender, VAR108, VAR102);
return true;
}
function FUN24(address VAR106, address VAR108) constant returns (uint VAR109) {
return VAR99[VAR106][VAR108];
}
}
contract PreICOProxyBuyer is VAR7, VAR32, VAR1 {
uint public VAR42;
uint public VAR19;
address[] public VAR110;
mapping(address => uint) public VAR98;
mapping(address => uint) public VAR111;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
uint public VAR116;
uint public VAR117;
uint public VAR118;
bool public VAR119;
Crowdsale public VAR17;
enum VAR53{VAR54, VAR57, VAR120, VAR61}
event FUN28(address VAR62, uint value, uint128 VAR64);
event FUN69(address VAR62, uint value);
event FUN70(uint VAR121);
event FUN71(address VAR62, uint VAR121);
function FUN72(address VAR106, uint VAR122, uint VAR123, uint VAR124, uint VAR125) {
VAR8 = VAR106;
if(VAR122 == 0) {
throw;
}
if(VAR123 == 0) {
throw;
}
if(VAR124 == 0) {
throw;
}
VAR113 = VAR123;
VAR114 = VAR124;
VAR115 = VAR125;
VAR112 = VAR122;
}
function FUN73() public constant returns(VAR126) {
if(address(VAR17) == 0)  {
throw;
}
return VAR17.FUN74();
}
function FUN47(uint128 VAR64) private {
if(FUN37() != VAR53.VAR57) throw;
if(msg.value == 0) throw;
address VAR62 = msg.sender;
bool VAR127 = VAR98[VAR62] > 0;
VAR98[VAR62] = FUN4(VAR98[VAR62], msg.value);
if(VAR98[VAR62] < VAR113 || VAR98[VAR62] > VAR114) {
throw;
}
if(!VAR127) {
VAR110.FUN75(VAR62);
VAR42++;
}
VAR19 = FUN4(VAR19, msg.value);
if(VAR19 > VAR115) {
throw;
}
}
function FUN49(uint128 VAR64) public stopInEmergency payable {
FUN47(VAR64);
}
function FUN50() public stopInEmergency payable {
FUN47(0x0);
}
function FUN76() stopNonOwnersInEmergency public {
if(FUN37() != VAR53.VAR57) {
throw;
}
if(address(VAR17) == 0) throw;
VAR17.VAR128.value(VAR19)(address(this));
VAR116 = FUN73().FUN23(address(this));
if(VAR116 == 0) {
throw;
}
FUN70(VAR116);
}
function FUN77(address VAR62) public constant returns (uint) {
if(FUN37() != VAR53.VAR120) {
throw;
}
return FUN1(VAR98[VAR62], VAR116) / VAR19;
}
function FUN78(address VAR62) public constant returns (uint) {
return FUN3(FUN77(VAR62), VAR111[VAR62]);
}
function FUN79() {
FUN80(FUN78(msg.sender));
}
function FUN80(uint VAR97) VAR13 {
address VAR62 = msg.sender;
if(VAR97 == 0) {
throw;
}
if(FUN78(VAR62) < VAR97) {
throw;
}
if(VAR111[VAR62] == 0) {
VAR117++;
}
VAR111[VAR62] = FUN4(VAR111[VAR62], VAR97);
VAR118 = FUN4(VAR118, VAR97);
FUN73().transfer(VAR62, VAR97);
FUN71(VAR62, VAR97);
}
function FUN60() VAR13 {
if(FUN37() != VAR53.VAR61) throw;
address VAR62 = msg.sender;
if(VAR98[VAR62] == 0) throw;
uint VAR97 = VAR98[VAR62];
delete VAR98[VAR62];
if(!(VAR62.call.value(VAR97)())) throw;
FUN69(VAR62, VAR97);
}
function FUN81(Crowdsale VAR129) public onlyOwner {
VAR17 = VAR129;
if(!VAR17.FUN66()) true;
}
function FUN82() public onlyOwner {
VAR119 = true;
}
function FUN59() public payable {
if(FUN37() != VAR53.VAR61) throw;
}
function FUN37() public returns(VAR53) {
if (VAR119)
return VAR53.VAR61;
if(VAR116 == 0) {
if(VAR86 >= VAR112) {
return VAR53.VAR61;
} else {
return VAR53.VAR57;
}
} else {
return VAR53.VAR120;
}
}
function FUN83() public constant returns (bool) {
return true;
}
function() payable {
throw;
}
}
1
---------------------------------
276 0xfae8c1c08360a9b4465ec3244c6a04881b422ed5.sol
pragma VAR1 ^0.4.21;
interface VAR2 {function FUN1(address VAR3)external payable;function FUN2() external;}
contract VAR4 {
address public VAR5;
event FUN3(string VAR6);
function FUN4() public {
VAR5 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
function FUN5(address VAR8) onlyOwner public {
VAR5 = VAR8;
}
function FUN6()public{
if(msg.sender==VAR5)emit FUN3("");
else{
emit FUN3("");
}
}
}
contract Crowdsale is VAR4 {
address public VAR9;
address public VAR10;
function FUN7() public payable{
}
function () public payable{
FUN8();
}
function FUN9(address VAR11)public onlyOwner{
VAR10= VAR11;
}
function FUN10(address VAR11)public onlyOwner {
VAR9= VAR11;
}
function FUN8()public payable{
SisterToken VAR12 = FUN11(VAR10);
SisterToken VAR13 = FUN11(VAR9);
VAR12.VAR14.value(msg.value/2)(msg.sender);
VAR13.VAR14.value(msg.value/2)(msg.sender);
}
function FUN12() public payable{
SisterToken VAR15 = FUN11(VAR10);
SisterToken VAR13 = FUN11(VAR9);
VAR15.FUN2();
VAR13.FUN2();
}
}
1
---------------------------------
277 0xfb1af109fc82685451a192ad86c2084183f0f2d6.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) constant returns (uint256);
function transfer(address VAR5, uint256 value) returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7 {
uint256 public VAR8;
function FUN2(bytes32 VAR9) payable returns(bool);
function FUN3(bytes32 VAR9 , address VAR10) returns(bool);
function FUN4(bytes32 VAR9 , bytes32 VAR11 , uint VAR12 , bool VAR13) returns(bool);
function FUN5(bytes32 VAR9 , bytes32 VAR11) constant returns(uint);
event FUN6(string VAR14);
event FUN7(address VAR15 , bytes32 VAR9);
event FUN8(bytes32 VAR9 , address VAR16 , address VAR17);
}
contract VAR18 {
function FUN9(bytes32 VAR19) returns(bool);
event FUN10(address VAR20,address VAR10);
}
contract VAR21 {
string public VAR22;
address public VAR23;
address public VAR24;
uint public VAR25;
bool VAR26;
address VAR27;
bytes32 public VAR28;
uint public VAR29;
GlobalStorageMultiId public VAR30;
event FUN11(address indexed VAR6);
event FUN10(address VAR20,address VAR10);
event FUN12(address indexed VAR15,uint256 VAR31);
modifier onlyAdmin() {
if ( msg.sender != VAR23 && msg.sender != VAR24 ) revert();
VAR32;
}
modifier onlyOwner() {
if ( msg.sender != VAR24 ) revert();
VAR32;
}
constructor() {
VAR25 = 0.01 VAR33;
VAR23 = msg.sender;
VAR24 = 0xc238ff50c09787e7b920f711850dd945a40d3232;
VAR22 = "";
VAR27 = 0x8f49722c61a9398a1c5f5ce6e5feeef852831a64;
VAR29 = 100;
VAR30 = FUN13(VAR27);
}
function FUN14() onlyAdmin constant returns(uint) {
return VAR30.FUN15();
}
function FUN16(bytes32 VAR19) onlyAdmin payable {
require(!VAR26);
uint VAR31 = VAR30.FUN15();
VAR28 = VAR19;
VAR30.VAR34.value(VAR31)(VAR19);
VAR26 = true;
}
function FUN17(address VAR10) onlyAdmin {
UpgDocs VAR35 = FUN18(VAR10);
require(VAR35.FUN9(VAR28));
VAR30.FUN3(VAR28,VAR10);
VAR10.FUN19(this.VAR36);
}
function FUN9(bytes32 VAR19) returns(bool) {
require(!VAR26);
VAR28 = VAR19;
VAR26 = true;
emit FUN10(msg.sender,this);
return true;
}
function FUN20(address VAR37) onlyOwner returns(bool){
VAR24 = VAR37;
return true;
}
function FUN21(address VAR38) onlyOwner returns(bool) {
VAR23 = VAR38;
return true;
}
function FUN22(address VAR39,address VAR40 , uint VAR31) onlyOwner returns(bool) {
ERC20Basic VAR41 = FUN23(VAR39);
require(VAR41.transfer(VAR40, VAR31));
return true;
}
function FUN24(uint VAR42) onlyAdmin public {
VAR29 = VAR42;
}
function FUN25(uint VAR43) onlyAdmin public {
VAR25 = VAR43;
}
function() payable public {
uint VAR44 = FUN5(msg.sender);
FUN4(msg.sender, VAR44 + msg.value);
uint VAR45 = VAR23.VAR36;
if ( VAR45 < 0.002 VAR33 ) {
VAR23.FUN19( 0.002 VAR33 - VAR45 );
}
VAR24.FUN19(this.VAR36);
emit FUN12(msg.sender, msg.value);
}
function FUN26(address[] VAR46, uint VAR47) onlyAdmin public returns (bool VAR48) {
for (uint8 VAR49=0; VAR49<VAR46.VAR50; VAR49++){
uint VAR44 = FUN5(VAR46[VAR49]);
FUN4(VAR46[VAR49], VAR44 + VAR47);
emit FUN12(VAR46[VAR49],VAR47);
}
}
function FUN27(address VAR15) constant returns(uint) {
return FUN5(VAR15);
}
function FUN28(address VAR15, string VAR51) onlyAdmin returns (bool VAR48) {
uint VAR44 = FUN5(VAR15);
require(VAR44 >= VAR25);
FUN4(VAR15, VAR44 - VAR25);
emit FUN11(VAR15);
return true;
}
function FUN29() constant returns(uint) {
return VAR25;
}
function FUN4(address VAR15, uint VAR31) internal {
VAR30.FUN4(VAR28, bytes32(VAR15), VAR31, true);
}
function FUN5(address VAR15) internal constant returns(uint) {
return VAR30.FUN5(VAR28, bytes32(VAR15));
}
}
1
---------------------------------
278 0xfb7c9bd2045cd9129839a70c67aabb0925b1fbe8.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
}
library VAR6 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
}
contract VAR7 {
address public VAR8;
function FUN12() {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR9;
}
function FUN13(address VAR10) onlyOwner {
require(VAR10 != address(0));
VAR8 = VAR10;
}
}
contract Haltable is VAR7 {
bool public VAR11;
modifier VAR12 {
if (VAR11) throw;
VAR9;
}
modifier VAR13 {
if (VAR11 && msg.sender != VAR8) throw;
VAR9;
}
modifier VAR14 {
if (!VAR11) throw;
VAR9;
}
function FUN14() external onlyOwner {
VAR11 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR11 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(address VAR17) public constant returns (bool) {
return false;
}
function FUN19(uint value, uint VAR18, uint VAR19, address VAR20, uint VAR21) public constant returns (uint VAR22);
}
contract VAR23 {
function FUN20() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN21();
}
contract VAR24 {
uint256 public VAR25;
function FUN22(address VAR26) constant returns (uint256);
function transfer(address VAR27, uint256 value) returns (bool);
event Transfer(address indexed VAR28, address indexed VAR27, uint256 value);
}
contract ERC20 is VAR24 {
function FUN23(address VAR8, address VAR29) constant returns (uint256);
function FUN24(address VAR28, address VAR27, uint256 value) returns (bool);
function FUN25(address VAR29, uint256 value) returns (bool);
event FUN26(address indexed VAR8, address indexed VAR29, uint256 value);
}
contract FractionalERC20 is VAR30 {
uint public VAR21;
}
contract Crowdsale is VAR31 {
uint public VAR32 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR33;
PricingStrategy public VAR34;
FinalizeAgent public VAR35;
address public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR19 = 0;
uint public VAR18 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
uint public VAR42 = 0;
uint public VAR43 = 0;
bool public VAR44;
bool public VAR45;
bool public VAR46;
address public VAR47;
mapping (address => uint256) public VAR48;
mapping (address => uint256) public VAR49;
mapping (address => bool) public VAR50;
uint public VAR51;
enum VAR52{VAR53, VAR54, VAR55, VAR56, VAR57, VAR58, VAR59, VAR60}
event FUN27(address VAR61, uint VAR62, uint VAR22, uint128 VAR63);
event FUN28(address VAR61, uint VAR62);
event FUN29(bool VAR64, bool VAR65, address VAR66);
event FUN30(address VAR67, bool VAR68);
event FUN31(uint VAR69);
function FUN32(address VAR70, PricingStrategy VAR71, address VAR72, uint VAR73, uint VAR74, uint VAR75) {
VAR8 = msg.sender;
VAR33 = FUN33(VAR70);
FUN34(VAR71);
VAR36 = VAR72;
if(VAR36 == 0) {
throw;
}
if(VAR73 == 0) {
throw;
}
VAR38 = VAR73;
if(VAR74 == 0) {
throw;
}
VAR39 = VAR74;
if(VAR38 >= VAR39) {
throw;
}
VAR37 = VAR75;
}
function() payable {
throw;
}
function FUN35(address VAR76, uint128 VAR63) stopInEmergency private {
if(FUN36() == VAR52.VAR55) {
if(!VAR50[VAR76]) {
throw;
}
} else if(FUN36() == VAR52.VAR56) {
} else {
throw;
}
uint VAR62 = msg.value;
uint VAR22 = VAR34.FUN19(VAR62, VAR18 - VAR40, VAR19, msg.sender, VAR33.FUN37());
if(VAR22 == 0) {
throw;
}
if(VAR48[VAR76] == 0) {
VAR41++;
}
VAR48[VAR76] = VAR48[VAR76].FUN11(VAR62);
VAR49[VAR76] = VAR49[VAR76].FUN11(VAR22);
VAR18 = VAR18.FUN11(VAR62);
VAR19 = VAR19.FUN11(VAR22);
if(VAR34.FUN18(VAR76)) {
VAR40 = VAR40.FUN11(VAR62);
}
if(FUN38(VAR62, VAR22, VAR18, VAR19)) {
throw;
}
FUN39(VAR76, VAR22);
if(!VAR36.FUN40(VAR62)) throw;
FUN27(VAR76, VAR62, VAR22, VAR63);
}
function FUN41(address VAR76, uint VAR77, uint VAR78) public onlyOwner {
uint VAR22 = VAR77 * 10**VAR33.FUN37();
uint VAR62 = VAR78 * VAR77;
VAR18 = VAR18.FUN11(VAR62);
VAR19 = VAR19.FUN11(VAR22);
VAR48[VAR76] = VAR48[VAR76].FUN11(VAR62);
VAR49[VAR76] = VAR49[VAR76].FUN11(VAR22);
FUN39(VAR76, VAR22);
FUN27(VAR76, VAR62, VAR22, 0);
}
function FUN42(address VAR67, uint128 VAR63, uint8 VAR79, bytes32 VAR80, bytes32 VAR81) public payable {
bytes32 VAR82 = FUN43(VAR67);
if (FUN44(VAR82, VAR79, VAR80, VAR81) != VAR47) throw;
if(VAR63 == 0) throw;
FUN35(VAR67, VAR63);
}
function FUN45(address VAR67, uint128 VAR63) public payable {
if(VAR46) throw;
if(VAR63 == 0) throw;
FUN35(VAR67, VAR63);
}
function FUN46(address VAR67) public payable {
if(VAR45) throw;
if(VAR46) throw;
FUN35(VAR67, 0);
}
function FUN47(uint128 VAR63, uint8 VAR79, bytes32 VAR80, bytes32 VAR81) public payable {
FUN42(msg.sender, VAR63, VAR79, VAR80, VAR81);
}
function FUN48(uint128 VAR63) public payable {
FUN45(msg.sender, VAR63);
}
function FUN49() public payable {
FUN46(msg.sender);
}
function FUN50() public FUN51(VAR52.VAR57) onlyOwner VAR12 {
if(VAR44) {
throw;
}
if(address(VAR35) != 0) {
VAR35.FUN21();
}
VAR44 = true;
}
function FUN52(FinalizeAgent VAR67) onlyOwner {
VAR35 = VAR67;
if(!VAR35.FUN20()) {
throw;
}
}
function FUN53(bool value) onlyOwner {
VAR45 = value;
FUN29(VAR45, VAR46, VAR47);
}
function FUN54(bool value, address VAR83) onlyOwner {
VAR46 = value;
VAR47 = VAR83;
FUN29(VAR45, VAR46, VAR47);
}
function FUN55(address VAR67, bool VAR68) onlyOwner {
VAR50[VAR67] = VAR68;
FUN30(VAR67, VAR68);
}
function FUN56(uint VAR84) onlyOwner {
if(VAR85 > VAR84) {
throw;
}
VAR39 = VAR84;
FUN31(VAR39);
}
function FUN34(PricingStrategy VAR71) onlyOwner {
VAR34 = VAR71;
if(!VAR34.FUN16()) {
throw;
}
}
function FUN57(address VAR67) public onlyOwner {
if(VAR41 > VAR32) {
throw;
}
VAR36 = VAR67;
}
function FUN58() public payable FUN51(VAR52.VAR58) {
if(msg.value == 0) throw;
VAR42 = VAR42.FUN11(msg.value);
}
function FUN59() public FUN51(VAR52.VAR60) {
uint256 VAR86 = VAR48[msg.sender];
if (VAR86 == 0) throw;
VAR48[msg.sender] = 0;
VAR43 = VAR43.FUN11(VAR86);
FUN28(msg.sender, VAR86);
if (!msg.sender.FUN40(VAR86)) throw;
}
function FUN60() public constant returns (bool VAR87) {
return VAR18 >= VAR37;
}
function FUN61() public constant returns (bool VAR88) {
return VAR35.FUN17();
}
function FUN62() public constant returns (bool VAR88) {
return VAR34.FUN17(address(this));
}
function FUN36() public constant returns (VAR52) {
if(VAR44) return VAR52.VAR59;
else if (address(VAR35) == 0) return VAR52.VAR54;
else if (!VAR35.FUN17()) return VAR52.VAR54;
else if (!VAR34.FUN17(address(this))) return VAR52.VAR54;
else if (VAR89.VAR90 < VAR38) return VAR52.VAR55;
else if (VAR89.VAR90 <= VAR39 && !FUN63()) return VAR52.VAR56;
else if (FUN60()) return VAR52.VAR57;
else if (!FUN60() && VAR18 > 0 && VAR42 >= VAR18) return VAR52.VAR60;
else return VAR52.VAR58;
}
function FUN64(uint VAR91) onlyOwner {
VAR51 = VAR91;
}
function FUN65() public constant returns (bool) {
return true;
}
//
//
modifier FUN51(State VAR92) {
if(FUN36() != VAR92) throw;
VAR9;
}
//
//
function FUN38(uint VAR62, uint VAR22, uint VAR93, uint VAR94) constant returns (bool VAR95);
function FUN63() public constant returns (bool);
function FUN39(address VAR76, uint VAR22) private;
}
contract StandardToken is VAR30, VAR1 {
event FUN66(address VAR76, uint VAR96);
mapping(address => uint) VAR97;
mapping (address => mapping (address => uint)) VAR98;
function FUN67() public constant returns (bool VAR99) {
return true;
}
function transfer(address VAR100, uint VAR101) returns (bool VAR102) {
VAR97[msg.sender] = FUN3(VAR97[msg.sender], VAR101);
VAR97[VAR100] = FUN4(VAR97[VAR100], VAR101);
Transfer(msg.sender, VAR100, VAR101);
return true;
}
function FUN24(address VAR103, address VAR100, uint VAR101) returns (bool VAR102) {
uint VAR104 = VAR98[VAR103][msg.sender];
VAR97[VAR100] = FUN4(VAR97[VAR100], VAR101);
VAR97[VAR103] = FUN3(VAR97[VAR103], VAR101);
VAR98[VAR103][msg.sender] = FUN3(VAR104, VAR101);
Transfer(VAR103, VAR100, VAR101);
return true;
}
function FUN22(address VAR105) constant returns (uint VAR106) {
return VAR97[VAR105];
}
function FUN25(address VAR107, uint VAR101) returns (bool VAR102) {
if ((VAR101 != 0) && (VAR98[msg.sender][VAR107] != 0)) throw;
VAR98[msg.sender][VAR107] = VAR101;
FUN26(msg.sender, VAR107, VAR101);
return true;
}
function FUN23(address VAR105, address VAR107) constant returns (uint VAR108) {
return VAR98[VAR105][VAR107];
}
}
contract PreICOProxyBuyer is VAR7, VAR31, VAR1 {
uint public VAR41;
uint public VAR18;
address[] public VAR109;
mapping(address => uint) public VAR97;
mapping(address => uint) public VAR110;
uint public VAR111;
uint public VAR112;
uint public VAR113;
uint public VAR114;
uint public VAR115;
uint public VAR116;
uint public VAR117;
bool public VAR118;
Crowdsale public VAR16;
enum VAR52{VAR53, VAR56, VAR119, VAR60}
event FUN27(address VAR61, uint VAR62, uint VAR22, uint128 VAR63);
event FUN68(address VAR61, uint value);
event FUN69(uint VAR120);
event FUN70(address VAR61, uint VAR120);
function FUN71(address VAR105, uint VAR121, uint VAR122, uint VAR123, uint VAR124) {
VAR8 = VAR105;
if(VAR121 == 0) {
throw;
}
if(VAR122 == 0) {
throw;
}
if(VAR123 == 0) {
throw;
}
VAR112 = VAR122;
VAR113 = VAR123;
VAR114 = VAR124;
VAR111 = VAR121;
}
function FUN72() public constant returns(VAR125) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN73();
}
function FUN46(uint128 VAR63) private {
if(FUN36() != VAR52.VAR56) throw;
if(msg.value == 0) throw;
address VAR61 = msg.sender;
bool VAR126 = VAR97[VAR61] > 0;
VAR97[VAR61] = FUN4(VAR97[VAR61], msg.value);
if(VAR97[VAR61] < VAR112 || VAR97[VAR61] > VAR113) {
throw;
}
if(!VAR126) {
VAR109.FUN74(VAR61);
VAR41++;
}
VAR18 = FUN4(VAR18, msg.value);
if(VAR18 > VAR114) {
throw;
}
FUN27(VAR61, msg.value, 0, VAR63);
}
function FUN48(uint128 VAR63) public stopInEmergency payable {
FUN46(VAR63);
}
function FUN49() public stopInEmergency payable {
FUN46(0x0);
}
function FUN75() stopNonOwnersInEmergency public {
if(FUN36() != VAR52.VAR56) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR127.value(VAR18)(address(this));
VAR115 = FUN72().FUN22(address(this));
if(VAR115 == 0) {
throw;
}
FUN69(VAR115);
}
function FUN76(address VAR61) public constant returns (uint) {
if(FUN36() != VAR52.VAR119) {
throw;
}
return FUN1(VAR97[VAR61], VAR115) / VAR18;
}
function FUN77(address VAR61) public constant returns (uint) {
return FUN3(FUN76(VAR61), VAR110[VAR61]);
}
function FUN78() {
FUN79(FUN77(msg.sender));
}
function FUN79(uint VAR96) VAR12 {
address VAR61 = msg.sender;
if(VAR96 == 0) {
throw;
}
if(FUN77(VAR61) < VAR96) {
throw;
}
if(VAR110[VAR61] == 0) {
VAR116++;
}
VAR110[VAR61] = FUN4(VAR110[VAR61], VAR96);
VAR117 = FUN4(VAR117, VAR96);
FUN72().transfer(VAR61, VAR96);
FUN70(VAR61, VAR96);
}
function FUN59() VAR12 {
if(FUN36() != VAR52.VAR60) throw;
address VAR61 = msg.sender;
if(VAR97[VAR61] == 0) throw;
uint VAR96 = VAR97[VAR61];
delete VAR97[VAR61];
if(!(VAR61.call.value(VAR96)())) throw;
FUN68(VAR61, VAR96);
}
function FUN80(Crowdsale VAR128) public onlyOwner {
VAR16 = VAR128;
if(!VAR16.FUN65()) true;
}
function FUN81() public onlyOwner {
VAR118 = true;
}
function FUN58() public payable {
if(FUN36() != VAR52.VAR60) throw;
}
function FUN36() public returns(VAR52) {
if (VAR118)
return VAR52.VAR60;
if(VAR115 == 0) {
if(VAR85 >= VAR111) {
return VAR52.VAR60;
} else {
return VAR52.VAR56;
}
} else {
return VAR52.VAR119;
}
}
function FUN82() public constant returns (bool) {
return true;
}
function() payable {
throw;
}
}
1
---------------------------------
279 0xfc8bc68b8f8b6a45474f9276c4bc85cfc6f8dbd8.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
uint constant VAR3 = 15;
uint constant VAR4 = 0.00045 VAR5;
uint constant VAR6 = 0.1 VAR5;
uint constant VAR7 = 1000;
uint constant VAR8 = 0.001 VAR5;
uint constant VAR9 = 0.01 VAR5;
uint constant VAR10 = 300000 VAR5;
uint constant VAR11 = 100;
//
uint constant VAR12 = 40;
uint constant VAR13 = 2 ** VAR12;
uint constant VAR14 = 250;
address constant VAR15 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public VAR16;
address private VAR17;
uint public VAR18;
address public VAR19;
uint128 public VAR20;
uint128 public VAR21;
address public VAR22 = 0x360f9b23ea114bb1a1e5fdd52fcb92837011ff65;
struct VAR23 {
uint VAR24;
uint8 VAR25;
uint8 VAR26;
uint40 VAR27;
uint40 VAR28;
address VAR29;
}
mapping (uint => VAR23) VAR30;
address public VAR31;
event FUN1(address indexed VAR32, uint VAR24);
event FUN2(address indexed VAR32, uint VAR24);
event FUN3(address indexed VAR32, uint VAR24);
event FUN4(uint VAR33);
constructor () public {
VAR16 = msg.sender;
VAR19 = VAR15;
VAR31 = VAR15;
}
modifier onlyOwner {
require (msg.sender == VAR16, "");
VAR34;
}
modifier VAR35 {
require (msg.sender == VAR31, "");
VAR34;
}
function FUN5(address VAR36) external onlyOwner {
require (VAR36 != VAR16, "");
VAR17 = VAR36;
}
function FUN6() external {
require (msg.sender == VAR17, "");
VAR16 = VAR17;
}
function () public payable {
}
function FUN7(address VAR37) external onlyOwner {
VAR19 = VAR37;
}
function FUN8(address VAR38) external onlyOwner {
VAR31 = VAR38;
}
function FUN9(uint VAR39) public onlyOwner {
require (VAR39 < VAR10, "");
VAR18 = VAR39;
}
function FUN10(uint VAR40) external onlyOwner {
require (VAR40 <= address(this).VAR41, "");
require (VAR20 + VAR21 + VAR40 <= address(this).VAR41, "");
VAR20 += uint128(VAR40);
}
function FUN11(uint VAR42) external onlyOwner {
require (VAR42 <= address(this).VAR41, "");
require (VAR20 + VAR21 + VAR42 <= address(this).VAR41, "");
FUN12(VAR22, VAR42, VAR42);
}
function FUN13() external onlyOwner {
require (VAR21 == 0, "");
FUN14(VAR16);
}
//
//
//
function FUN15(uint VAR43, uint VAR25, uint VAR44, uint VAR33, bytes32 VAR45, bytes32 VAR46) external payable {
Bet storage VAR47 = VAR30[VAR33];
require (VAR47.VAR29 == address(0), "");
uint VAR24 = msg.value;
require (VAR25 > 1 && VAR25 <= VAR11, "");
require (VAR24 >= VAR9 && VAR24 <= VAR10, "");
require (VAR43 > 0 && VAR43 < VAR13, "");
require (VAR48.VAR49 <= VAR44, "");
bytes32 VAR50 = FUN16(VAR51.FUN17(FUN18(VAR44), VAR33));
require (VAR19 == FUN19(VAR50, 27, VAR45, VAR46), "");
uint VAR26;
uint VAR28;
if (VAR25 <= VAR12) {
VAR26 = ((VAR43 * VAR52) & VAR53) % VAR54;
VAR28 = VAR43;
} else {
require (VAR43 > 0 && VAR43 <= VAR25, "");
VAR26 = VAR43;
}
uint VAR55;
uint VAR56;
(VAR55, VAR56) = FUN20(VAR24, VAR25, VAR26);
require (VAR55 <= VAR24 + VAR18, "");
VAR21 += uint128(VAR55);
VAR20 += uint128(VAR56);
require (VAR20 + VAR21 <= address(this).VAR41, "");
emit FUN4(VAR33);
VAR47.VAR24 = VAR24;
VAR47.VAR25 = uint8(VAR25);
VAR47.VAR26 = uint8(VAR26);
VAR47.VAR27 = FUN18(VAR48.VAR49);
VAR47.VAR28 = FUN18(VAR28);
VAR47.VAR29 = msg.sender;
}
function FUN21(uint VAR57, bytes32 VAR58) external VAR35 {
uint VAR33 = uint(FUN16(VAR51.FUN17(VAR57)));
Bet storage VAR47 = VAR30[VAR33];
uint VAR27 = VAR47.VAR27;
require (VAR48.VAR49 > VAR27, "");
require (VAR48.VAR49 <= VAR27 + VAR14, "");
require (FUN22(VAR27) == VAR58);
FUN23(VAR47, VAR57, VAR58);
}
function FUN24(uint VAR57, uint40 VAR59) external VAR35 {
uint VAR33 = uint(FUN16(VAR51.FUN17(VAR57)));
Bet storage VAR47 = VAR30[VAR33];
require (VAR48.VAR49 <= VAR59 + VAR14, "");
FUN25(4 + 32 + 32 + 4);
bytes32 VAR60;
bytes32 VAR61;
(VAR60, VAR61) = FUN26(VAR33, 4 + 32 + 32);
require (FUN22(VAR59) == VAR60);
FUN23(VAR47, VAR57, VAR61);
}
function FUN23(Bet storage VAR47, uint VAR57, bytes32 VAR62) private {
uint VAR24 = VAR47.VAR24;
uint VAR25 = VAR47.VAR25;
uint VAR26 = VAR47.VAR26;
address VAR29 = VAR47.VAR29;
require (VAR24 != 0, "");
VAR47.VAR24 = 0;
bytes32 VAR63 = FUN16(VAR51.FUN17(VAR57, VAR62));
uint VAR64 = uint(VAR63) % VAR25;
uint VAR65;
uint VAR66;
(VAR65, VAR66) = FUN20(VAR24, VAR25, VAR26);
uint VAR67 = 0;
uint VAR68 = 0;
if (VAR25 <= VAR12) {
if ((2 ** VAR64) & VAR47.VAR28 != 0) {
VAR67 = VAR65;
}
} else {
if (VAR64 < VAR26) {
VAR67 = VAR65;
}
}
VAR21 -= uint128(VAR65);
if (VAR24 >= VAR6) {
uint VAR69 = (uint(VAR63) / VAR25) % VAR7;
if (VAR69 == 0) {
VAR68 = VAR20;
VAR20 = 0;
}
}
if (VAR68 > 0) {
emit FUN3(VAR29, VAR68);
}
FUN12(VAR29, VAR67 + VAR68 == 0 ? 1 VAR70 : VAR67 + VAR68, VAR67);
}
function FUN27(uint VAR33) external {
Bet storage VAR47 = VAR30[VAR33];
uint VAR24 = VAR47.VAR24;
require (VAR24 != 0, "");
require (VAR48.VAR49 > VAR47.VAR27 + VAR14, "");
VAR47.VAR24 = 0;
uint VAR65;
uint VAR56;
(VAR65, VAR56) = FUN20(VAR24, VAR47.VAR25, VAR47.VAR26);
VAR21 -= uint128(VAR65);
VAR20 -= uint128(VAR56);
FUN12(VAR47.VAR29, VAR24, VAR24);
}
function FUN20(uint VAR24, uint VAR25, uint VAR26) private pure returns (uint VAR71, uint VAR56) {
require (0 < VAR26 && VAR26 <= VAR25, "");
VAR56 = VAR24 >= VAR6 ? VAR8 : 0;
uint VAR72 = VAR24 * VAR3 / 1000;
if (VAR72 < VAR4) {
VAR72 = VAR4;
}
require (VAR72 + VAR56 <= VAR24, "");
VAR71 = (VAR24 - VAR72 - VAR56) * VAR25 / VAR26;
}
function FUN12(address VAR32, uint VAR24, uint VAR73) private {
if (VAR32.call.value(VAR24)()) {
emit FUN2(VAR32, VAR73);
} else {
emit FUN1(VAR32, VAR24);
}
}
uint constant VAR52 = 0x0000000000002000000000100000000008000000000400000000020000000001;
uint constant VAR53 = 0x0001041041041041041041041041041041041041041041041041041041041041;
uint constant VAR54 = 0x3F;
function FUN26(uint VAR74, uint VAR75) pure private returns (bytes32 VAR58, bytes32 VAR61) {
uint VAR76;  VAR77 { VAR76 := FUN28(0x40) }
uint VAR78; uint VAR79; uint VAR80; uint VAR81;
for (;; VAR75 += VAR79) {
VAR77 { VAR79 := FUN29(FUN30(FUN31(VAR75, 30)), 0xffff) }
if (VAR79 == 0) {
break;
}
VAR77 { VAR80 := FUN29(FUN30(FUN31(VAR75, 28)), 0xffff) }
require (VAR80 + 32 <= VAR79, "");
VAR75 += 4;
VAR77 { VAR81 := FUN30(FUN32(VAR75, VAR80)) }
require (VAR81 == 0, "");
VAR77 {
FUN33(VAR76, VAR75, VAR79)
FUN34(FUN32(VAR76, VAR80), VAR74)
VAR74 := FUN35(VAR76, VAR79)
VAR78 := VAR79
}
}
VAR61 = bytes32(VAR74);
uint VAR82 = VAR76 + VAR78;
uint VAR83; VAR77 { VAR83 := FUN29(FUN30(FUN31(VAR75, 28)), 0xffff) }
uint VAR84;  VAR77 { VAR84 := FUN29(FUN30(FUN31(VAR75, 26)), 0xffff) }
require (VAR84 + VAR78 <= VAR83, "");
VAR75 += 6;
VAR77 { FUN33(VAR82, VAR75, VAR83) }
FUN36(VAR82 + VAR84, VAR76, VAR78);
VAR77 { VAR74 := FUN35(VAR82, VAR83) }
VAR75 += VAR83;
VAR77 {
VAR79 := FUN29(FUN30(FUN31(VAR75, 30)), 0xffff)
VAR80 := FUN29(FUN30(FUN31(VAR75, 28)), 0xffff)
}
require (VAR80 + 32 <= VAR79, "");
VAR75 += 4;
VAR77 { VAR81 := FUN30(FUN32(VAR75, VAR80)) }
require (VAR81 == 0, "");
VAR77 {
FUN33(VAR76, VAR75, VAR79)
FUN34(FUN32(VAR76, VAR80), VAR74)
VAR58 := FUN35(VAR76, VAR79)
}
}
function FUN25(uint VAR75) view private {
uint VAR85; VAR77 { VAR85 := FUN37(0, FUN30(VAR75)) }
require (VAR85 >= 0xf7, "");
VAR75 += VAR85 - 0xf6;
uint VAR86; VAR77 { VAR86 := FUN37(0, FUN30(VAR75)) }
if (VAR86 <= 0x7f) {
VAR75 += 1;
} else {
require (VAR86 >= 0x80 && VAR86 <= 0xb7, "");
VAR75 += VAR86 - 0x7f;
}
uint VAR87; VAR77 { VAR87 := FUN37(0, FUN30(VAR75)) }
require (VAR87 == 0xb9, "");
VAR75 += 3;
uint VAR88; VAR77 { VAR88 := FUN37(0, FUN30(VAR75)) }
require (VAR88 == 0xf9, "");
VAR75 += 3;
uint VAR89; VAR77 { VAR89 := FUN37(0, FUN30(VAR75)) }
require (VAR89 == 0x1, "");
VAR75 += 1;
uint VAR90; VAR77 { VAR90 := FUN37(0, FUN30(VAR75)) }
if (VAR90 <= 0x7f) {
VAR75 += 1;
} else {
require (VAR90 >= 0x80 && VAR90 <= 0xb7, "");
VAR75 += VAR90 - 0x7f;
}
uint VAR91; VAR77 { VAR91 := FUN37(0, FUN30(VAR75)) }
require (VAR91 == 0xb9, "");
VAR75 += 256 + 3;
uint VAR92; VAR77 { VAR92 := FUN37(0, FUN30(VAR75)) }
require (VAR92 == 0xf8, "");
VAR75 += 2;
uint VAR93; VAR77 { VAR93 := FUN37(0, FUN30(VAR75)) }
require (VAR93 == 0xf8, "");
VAR75 += 2;
uint VAR94; VAR77 { VAR94 := FUN37(0, FUN30(VAR75)) }
require (VAR94 == 0x94, "");
uint VAR95; VAR77 { VAR95 := FUN29(FUN30(FUN31(VAR75, 11)), 0xffffffffffffffffffffffffffffffffffffffff) }
require (VAR95 == uint(address(this)));
}
function FUN36(uint VAR96, uint VAR97, uint VAR98) pure private {
for(; VAR98 >= 32; VAR98 -= 32) {
VAR77 { FUN34(VAR96, FUN28(VAR97)) }
VAR96 += 32; VAR97 += 32;
}
uint VAR28 = 256 ** (32 - VAR98) - 1;
VAR77 {
let VAR99 := FUN29(FUN28(VAR97), FUN38(VAR28))
let VAR100 := FUN29(FUN28(VAR96), VAR28)
FUN34(VAR96, or(VAR100, VAR99))
}
}
}
1
---------------------------------
280 0xfcb4393e7faef06fab01c00d67c1895545aff3b8.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
ERC20 constant internal VAR3 = FUN1(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);
uint  constant internal VAR4 = (10**18);
uint  constant internal VAR5   = (10**28);
uint  constant internal VAR6  = (VAR4 * 10**6);
uint  constant internal VAR7 = 18;
uint  constant internal VAR8 = 18;
mapping(address=>uint) internal VAR9;
function FUN2(ERC20 VAR10) internal {
if (VAR10 == VAR3) VAR9[VAR10] = VAR8;
else VAR9[VAR10] = VAR10.FUN3();
}
function FUN4(ERC20 VAR10) internal view returns(uint) {
if (VAR10 == VAR3) return VAR8;
uint VAR11 = VAR9[VAR10];
if(VAR11 == 0) return VAR10.FUN3();
return VAR11;
}
function FUN5(uint VAR12, uint VAR13, uint VAR14, uint VAR15) internal pure returns(uint) {
require(VAR12 <= VAR5);
require(VAR15 <= VAR6);
if (VAR14 >= VAR13) {
require((VAR14 - VAR13) <= VAR7);
return (VAR12 * VAR15 * (10**(VAR14 - VAR13))) / VAR4;
} else {
require((VAR13 - VAR14) <= VAR7);
return (VAR12 * VAR15) / (VAR4 * (10**(VAR13 - VAR14)));
}
}
function FUN6(uint VAR16, uint VAR13, uint VAR14, uint VAR15) internal pure returns(uint) {
require(VAR16 <= VAR5);
require(VAR15 <= VAR6);
uint VAR17;
uint VAR18;
if (VAR13 >= VAR14) {
require((VAR13 - VAR14) <= VAR7);
VAR17 = (VAR4 * VAR16 * (10**(VAR13 - VAR14)));
VAR18 = VAR15;
} else {
require((VAR14 - VAR13) <= VAR7);
VAR17 = (VAR4 * VAR16);
VAR18 = (VAR15 * (10**(VAR14 - VAR13)));
}
return (VAR17 + VAR18 - 1) / VAR18;
}
}
interface VAR19 {
function FUN7 (uint VAR20, address VAR21, address VAR22) public returns(bool);
}
interface VAR23 {
function FUN8(
ERC20 VAR24,
uint VAR25,
ERC20 VAR26,
address VAR27,
uint VAR28,
bool VAR29
)
public
payable
returns(bool);
function FUN9(ERC20 VAR30, ERC20 VAR31, uint VAR12, uint VAR32) public view returns(uint);
}
interface VAR33 {
function FUN10() public view returns (uint VAR34);
function FUN11(address VAR35) public view returns (uint VAR36);
function transfer(address VAR37, uint VAR38) public returns (bool VAR39);
function FUN12(address VAR40, address VAR37, uint VAR38) public returns (bool VAR39);
function FUN13(address VAR41, uint VAR38) public returns (bool VAR39);
function FUN14(address VAR35, address VAR41) public view returns (uint VAR42);
function FUN3() public view returns(uint VAR43);
event FUN15(address indexed VAR35, address indexed VAR41, uint VAR38);
}
interface VAR44 {
function FUN16(ERC20 VAR30, ERC20 VAR31, uint VAR12) public view
returns (uint VAR45, uint VAR46);
}
contract VAR47 {
address public VAR48;
address public VAR49;
mapping(address=>bool) internal VAR50;
mapping(address=>bool) internal VAR51;
address[] internal VAR52;
address[] internal VAR53;
uint constant internal VAR54 = 50;
function FUN17() public {
VAR48 = msg.sender;
}
modifier onlyAdmin() {
require(msg.sender == VAR48);
VAR55;
}
modifier FUN18() {
require(VAR50[msg.sender]);
VAR55;
}
modifier FUN19() {
require(VAR51[msg.sender]);
VAR55;
}
function FUN20 () external view returns(address[]) {
return VAR52;
}
function FUN21 () external view returns(address[]) {
return VAR53;
}
event FUN22(address VAR49);
function FUN23(address VAR56) public onlyAdmin {
require(VAR56 != address(0));
FUN22(VAR49);
VAR49 = VAR56;
}
function FUN24(address VAR56) public onlyAdmin {
require(VAR56 != address(0));
FUN22(VAR56);
FUN25(VAR56, VAR48);
VAR48 = VAR56;
}
event FUN25( address VAR56, address VAR57);
function FUN26() public {
require(VAR49 == msg.sender);
FUN25(VAR49, VAR48);
VAR48 = VAR49;
VAR49 = address(0);
}
event FUN27 (address VAR58, bool VAR59);
function FUN28(address VAR58) public onlyAdmin {
require(!VAR51[VAR58]);
require(VAR53.VAR60 < VAR54);
FUN27(VAR58, true);
VAR51[VAR58] = true;
VAR53.FUN29(VAR58);
}
function FUN30 (address VAR61) public onlyAdmin {
require(VAR51[VAR61]);
VAR51[VAR61] = false;
for (uint VAR62 = 0; VAR62 < VAR53.VAR60; ++VAR62) {
if (VAR53[VAR62] == VAR61) {
VAR53[VAR62] = VAR53[VAR53.VAR60 - 1];
VAR53.VAR60--;
FUN27(VAR61, false);
break;
}
}
}
event FUN31(address VAR63, bool VAR59);
function FUN32(address VAR63) public onlyAdmin {
require(!VAR50[VAR63]);
require(VAR52.VAR60 < VAR54);
FUN31(VAR63, true);
VAR50[VAR63] = true;
VAR52.FUN29(VAR63);
}
function FUN33 (address VAR64) public onlyAdmin {
require(VAR50[VAR64]);
VAR50[VAR64] = false;
for (uint VAR62 = 0; VAR62 < VAR52.VAR60; ++VAR62) {
if (VAR52[VAR62] == VAR64) {
VAR52[VAR62] = VAR52[VAR52.VAR60 - 1];
VAR52.VAR60 -= 1;
FUN31(VAR64, false);
break;
}
}
}
}
contract VAR65 {
function FUN34(address VAR66) external view returns (uint VAR67);
}
contract Withdrawable is VAR47 {
event FUN35(ERC20 VAR10, uint VAR68, address VAR69);
function FUN36(ERC20 VAR10, uint VAR68, address VAR69) external onlyAdmin {
require(VAR10.transfer(VAR69, VAR68));
FUN35(VAR10, VAR68, VAR69);
}
event FUN37(uint VAR68, address VAR69);
function FUN38(uint VAR68, address VAR69) external onlyAdmin {
VAR69.transfer(VAR68);
FUN37(VAR68, VAR69);
}
}
contract KyberNetwork is VAR70, VAR2 {
uint public VAR71 = 10;
VAR23[] public VAR72;
mapping(address=>bool) public VAR73;
WhiteListInterface public VAR74;
ExpectedRateInterface public VAR75;
FeeBurnerInterface    public VAR76;
uint                  public VAR77 = 50 * 1000 * 1000 * 1000;
bool                  public VAR78 = false;
mapping(bytes32=>uint) public VAR79;
mapping(address=>mapping(bytes32=>bool)) public VAR80;
function FUN39(address VAR81) public {
require(VAR81 != address(0));
VAR48 = VAR81;
}
event FUN40(address indexed sender, uint VAR68);
function() public payable {
require(VAR73[msg.sender]);
FUN40(msg.sender, msg.value);
}
event FUN41(address indexed sender, ERC20 VAR30, ERC20 VAR31, uint VAR82, uint VAR83);
function FUN8(
ERC20 VAR30,
uint VAR25,
ERC20 VAR31,
address VAR27,
uint VAR84,
uint VAR85,
address VAR86
)
public
payable
returns(uint)
{
require(VAR78);
uint VAR87;
uint VAR88;
uint VAR89;
uint VAR90;
VAR87 = FUN42(VAR30, msg.sender);
if (VAR30 == VAR3)
VAR87 += msg.value;
VAR89 = FUN42(VAR31, VAR27);
uint VAR83 = FUN43(VAR30,
VAR25,
VAR31,
VAR27,
VAR84,
VAR85,
VAR86
);
require(VAR83 > 0);
VAR88 = FUN42(VAR30, msg.sender);
VAR90 = FUN42(VAR31, VAR27);
require(VAR88 <= VAR87);
require(VAR90 >= VAR89);
require((VAR90 - VAR89) >=
FUN5((VAR87 - VAR88), FUN4(VAR30), FUN4(VAR31),
VAR85));
return VAR83;
}
event FUN44(KyberReserveInterface VAR21, bool VAR91);
function FUN45(KyberReserveInterface VAR21, bool VAR91) public onlyAdmin {
if (VAR91) {
require(!VAR73[VAR21]);
VAR72.FUN29(VAR21);
VAR73[VAR21] = true;
FUN44(VAR21, true);
} else {
VAR73[VAR21] = false;
for (uint VAR62 = 0; VAR62 < VAR72.VAR60; VAR62++) {
if (VAR72[VAR62] == VAR21) {
VAR72[VAR62] = VAR72[VAR72.VAR60 - 1];
VAR72.VAR60--;
FUN44(VAR21, false);
break;
}
}
}
}
event FUN46(address VAR21, ERC20 VAR30, ERC20 VAR31, bool VAR91);
function FUN47(address VAR21, ERC20 VAR30, ERC20 VAR31, bool VAR91) public onlyAdmin {
(VAR80[VAR21])[FUN48(VAR30, VAR31)] = VAR91;
if (VAR30 != VAR3) {
if (VAR91) {
VAR30.FUN13(VAR21, 2**255);
} else {
VAR30.FUN13(VAR21, 0);
}
}
FUN2(VAR30);
FUN2(VAR31);
FUN46(VAR21, VAR30, VAR31, VAR91);
}
function FUN49(
WhiteListInterface    VAR92,
ExpectedRateInterface VAR93,
FeeBurnerInterface    VAR94,
uint                  VAR95,
uint                  VAR96
)
public
onlyAdmin
{
require(VAR92 != address(0));
require(VAR94 != address(0));
require(VAR93 != address(0));
require(VAR96 <= 100 * 100);
VAR74 = VAR92;
VAR75 = VAR93;
VAR76 = VAR94;
VAR77 = VAR95;
VAR71 = VAR96;
}
function FUN50(bool VAR97) public onlyAdmin {
if (VAR97) {
require(VAR74 != address(0));
require(VAR76 != address(0));
require(VAR75 != address(0));
}
VAR78 = VAR97;
}
function FUN51(bytes32 VAR98, uint value) public VAR99 {
VAR79[VAR98] = value;
}
function FUN52() public view returns(uint) {
return VAR72.VAR60;
}
function FUN53() public view returns(VAR23[]) {
return VAR72;
}
function FUN42(ERC20 VAR10, address VAR66) public view returns(uint) {
if (VAR10 == VAR3)
return VAR66.VAR36;
else
return VAR10.FUN11(VAR66);
}
function FUN54(ERC20 VAR30, ERC20 VAR31, uint VAR12) public view returns(uint, uint) {
uint VAR100 = 0;
uint VAR101 = 0;
uint VAR102 = 0;
uint VAR103 = VAR72.VAR60;
uint[] memory VAR104 = new uint[](VAR103);
uint[] memory VAR105 = new uint[](VAR103);
for (uint VAR62 = 0; VAR62 < VAR103; VAR62++) {
if (!(VAR80[VAR72[VAR62]])[FUN48(VAR30, VAR31)]) continue;
VAR104[VAR62] = VAR72[VAR62].FUN9(VAR30, VAR31, VAR12, VAR106.VAR107);
if (VAR104[VAR62] > VAR100) {
VAR100 = VAR104[VAR62];
}
}
if (VAR100 > 0) {
uint VAR108 = 0;
uint VAR109 = (VAR100 * 10000) / (10000 + VAR71);
for (VAR62 = 0; VAR62 < VAR103; VAR62++) {
if (VAR104[VAR62] >= VAR109) {
VAR105[VAR102++] = VAR62;
}
}
if (VAR102 > 1) {
VAR108 = uint(VAR106.FUN55(VAR106.VAR107-1)) % VAR102;
}
VAR101 = VAR105[VAR108];
VAR100 = VAR104[VAR101];
}
return (VAR101, VAR100);
}
function FUN16(ERC20 VAR30, ERC20 VAR31, uint VAR12)
public view
returns (uint VAR45, uint VAR46)
{
require(VAR75 != address(0));
return VAR75.FUN16(VAR30, VAR31, VAR12);
}
function FUN34(address VAR66) public view returns(uint) {
return VAR74.FUN34(VAR66);
}
function FUN43(
ERC20 VAR30,
uint VAR25,
ERC20 VAR31,
address VAR27,
uint VAR84,
uint VAR85,
address VAR86
)
internal
returns(uint)
{
require(VAR110.VAR111 <= VAR77);
require(FUN56(VAR30, VAR25, VAR27));
uint VAR112;
uint VAR15;
(VAR112, VAR15) = FUN54(VAR30, VAR31, VAR25);
KyberReserveInterface VAR113 = VAR72[VAR112];
require(VAR15 > 0);
require(VAR15 < VAR6);
require(VAR15 >= VAR85);
uint VAR82 = VAR25;
uint VAR83 = FUN57(VAR30, VAR31, VAR82, VAR15);
if (VAR83 > VAR84) {
VAR83 = VAR84;
VAR82 = FUN58(VAR30, VAR31, VAR83, VAR15);
require(VAR82 <= VAR25);
}
uint VAR114;
if (VAR30 == VAR3) {
VAR114 = VAR82;
} else {
VAR114 = VAR83;
}
require(VAR114 <= FUN34(msg.sender));
require(FUN59(
VAR30,
VAR82,
VAR31,
VAR27,
VAR83,
VAR113,
VAR15,
true));
if ((VAR82 < VAR25) && (VAR30 == VAR3)) {
msg.sender.transfer(VAR25 - VAR82);
}
require(VAR76.FUN7(VAR114, VAR113, VAR86));
FUN41(msg.sender, VAR30, VAR31, VAR82, VAR83);
return VAR83;
}
function FUN59(
ERC20 VAR30,
uint VAR68,
ERC20 VAR31,
address VAR27,
uint VAR115,
KyberReserveInterface VAR21,
uint VAR28,
bool VAR29
)
internal
returns(bool)
{
uint VAR116 = 0;
if (VAR30 == VAR3) {
VAR116 = VAR68;
} else {
VAR30.FUN12(msg.sender, this, VAR68);
}
require(VAR21.VAR117.value(VAR116)(VAR30, VAR68, VAR31, this, VAR28, VAR29));
if (VAR31 == VAR3) {
VAR27.transfer(VAR115);
} else {
require(VAR31.transfer(VAR27, VAR115));
}
return true;
}
function FUN57(ERC20 VAR30, ERC20 VAR31, uint VAR25, uint VAR15) internal view returns(uint) {
return FUN5(VAR25, FUN4(VAR30), FUN4(VAR31), VAR15);
}
function FUN58(ERC20 VAR30, ERC20 VAR31, uint VAR118, uint VAR15) internal view returns(uint) {
return FUN6(VAR118, FUN4(VAR30), FUN4(VAR31), VAR15);
}
function FUN56(ERC20 VAR30, uint VAR25, address VAR27) internal view returns(bool) {
if ((VAR25 >= VAR5) || (VAR25 == 0) || (VAR27 == 0))
return false;
if (VAR30 == VAR3) {
if (msg.value != VAR25)
return false;
} else {
if ((msg.value != 0) || (VAR30.FUN14(msg.sender, this) < VAR25))
return false;
}
return true;
}
}
interface VAR119 {
function FUN10() public view returns (uint VAR34);
function FUN11(address VAR35) public view returns (uint VAR36);
function transfer(address VAR37, uint VAR38) public returns (bool VAR39);
function FUN12(address VAR40, address VAR37, uint VAR38) public returns (bool VAR39);
function FUN13(address VAR41, uint VAR38) public returns (bool VAR39);
function FUN14(address VAR35, address VAR41) public view returns (uint VAR42);
function FUN3() public view returns(uint VAR43);
event FUN15(address indexed VAR35, address indexed VAR41, uint VAR38);
function FUN60(uint VAR38) public;
}
contract VAR120 {
KyberNetwork public VAR121;
BurnableErc20 public VAR122;
function FUN61(address VAR123, address VAR124) public {
require(VAR123 != address(0));
require(VAR124 != address(0));
VAR122 = FUN62(VAR123);
VAR121 = FUN39(VAR124);
}
function() public payable { }
function FUN60(uint VAR125, uint VAR84, uint VAR85)
public
returns(uint)
{
uint VAR126 = this.VAR36;
if (VAR125 != 0 && VAR125 < VAR126) {
VAR126 = VAR125;
}
if (VAR84 == 0) {
VAR84 = 2**256 - 1;
}
if (VAR85 == 0) {
VAR85 = 1;
}
uint VAR127 = VAR121.VAR117.value(VAR126)(
FUN1(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee),
VAR126,
FUN1(VAR122),
this,
VAR84,
VAR85,
0
);
VAR122.FUN60(VAR127);
return VAR127;
}
}
1
---------------------------------
281 0xfd4b392ca5495459044b9eca9856cdab0a596b33.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 2 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
282 0xfe1b613f17f984e27239b0b2dccfb1778888dfae.sol
pragma VAR1 ^0.4.23;
interface VAR2 {
function FUN1() external view returns (address VAR3);
function FUN2(bytes32 VAR4) external view returns (address VAR3);
}
contract VAR5 {
IRegistry private VAR6;
modifier FUN3(){
require(msg.sender == FUN4());
VAR7;
}
constructor(address VAR8)
public
{
require(VAR8 != 0);
VAR6 = FUN5(VAR8);
}
function FUN2(bytes32 VAR4)
internal
view
returns(address VAR3)
{
return VAR6.FUN2(VAR4);
}
function FUN4()
public
view
returns (address VAR3)
{
return VAR6.FUN1();
}
function FUN6()
public
view
returns (IRegistry VAR3)
{
return VAR6;
}
}
contract VAR9 {
uint public VAR10;
struct VAR11 {
uint VAR12;
address VAR13;
address VAR14;
}
mapping (address => VAR11) public VAR15;
address public VAR16;
modifier FUN3() { require(msg.sender==VAR16); VAR7; }
constructor(address VAR17)
public
{
VAR16 = VAR17;
}
function FUN7(address VAR18, uint VAR19)
VAR20
public
{
if (VAR18 == address(0) || VAR19 == 0) return;
Entry storage VAR21 = VAR15[VAR18];
if (VAR21.VAR12 == 0) {
VAR21.VAR13 = VAR15[0x0].VAR13;
VAR15[VAR15[0x0].VAR13].VAR14 = VAR18;
VAR15[0x0].VAR13 = VAR18;
}
VAR10 += VAR19;
VAR21.VAR12 += VAR19;
}
function FUN8(address VAR18, uint VAR19)
VAR20
public
returns (uint VAR22)
{
if (VAR18 == address(0) || VAR19 == 0) return;
Entry storage VAR21 = VAR15[VAR18];
uint VAR23 = VAR21.VAR12;
if (VAR23 == 0) return;
if (VAR19 >= VAR23) {
VAR10 -= VAR23;
VAR15[VAR21.VAR14].VAR13 = VAR21.VAR13;
VAR15[VAR21.VAR13].VAR14 = VAR21.VAR14;
delete VAR15[VAR18];
return VAR23;
} else {
VAR10 -= VAR19;
VAR21.VAR12 -= VAR19;
return VAR19;
}
}
function FUN9()
public
view
returns (uint VAR24)
{
Entry memory VAR25 = VAR15[0x0];
while (VAR25.VAR13 > 0) {
VAR25 = VAR15[VAR25.VAR13];
VAR24++;
}
return VAR24;
}
function FUN10(address VAR18)
public
view
returns (uint VAR26)
{
return VAR15[VAR18].VAR12;
}
function FUN11()
public
view
returns (address[] VAR27, uint[] VAR28)
{
uint VAR24 = FUN9();
VAR27 = new address[](VAR24);
VAR28 = new uint[](VAR24);
uint VAR29 = 0;
Entry memory VAR25 = VAR15[0x0];
while (VAR25.VAR13 > 0) {
VAR27[VAR29] = VAR25.VAR13;
VAR28[VAR29] = VAR15[VAR25.VAR13].VAR12;
VAR25 = VAR15[VAR25.VAR13];
VAR29++;
}
return (VAR27, VAR28);
}
}
contract VAR30 {
struct VAR11 {
bool VAR31;
address VAR13;
address VAR14;
}
mapping (address => VAR11) public VAR15;
address public VAR16;
modifier FUN3() { require(msg.sender==VAR16); VAR7; }
constructor(address VAR17)
public
{
VAR16 = VAR17;
}
function FUN7(address VAR18)
VAR20
public
returns (bool VAR32)
{
if (VAR18 == address(0)) return;
Entry storage VAR21 = VAR15[VAR18];
if (VAR21.VAR31) return;
else VAR21.VAR31 = true;
Entry storage VAR33 = VAR15[0x0];
VAR21.VAR13 = VAR33.VAR13;
VAR15[VAR33.VAR13].VAR14 = VAR18;
VAR33.VAR13 = VAR18;
return true;
}
function FUN12(address VAR18)
VAR20
public
returns (bool VAR34)
{
if (VAR18 == address(0)) return;
Entry storage VAR21 = VAR15[VAR18];
if (!VAR21.VAR31) return;
VAR15[VAR21.VAR14].VAR13 = VAR21.VAR13;
VAR15[VAR21.VAR13].VAR14 = VAR21.VAR14;
delete VAR15[VAR18];
return true;
}
function FUN9()
public
view
returns (uint VAR24)
{
Entry memory VAR25 = VAR15[0x0];
while (VAR25.VAR13 > 0) {
VAR25 = VAR15[VAR25.VAR13];
VAR24++;
}
return VAR24;
}
function FUN13(address VAR18)
public
view
returns (bool VAR35)
{
return VAR15[VAR18].VAR31;
}
function FUN14()
public
view
returns (address[] VAR27)
{
uint VAR24 = FUN9();
VAR27 = new address[](VAR24);
uint VAR29 = 0;
Entry memory VAR25 = VAR15[0x0];
while (VAR25.VAR13 > 0) {
VAR27[VAR29] = VAR25.VAR13;
VAR25 = VAR15[VAR25.VAR13];
VAR29++;
}
return VAR27;
}
}
interface VAR36 {
function FUN15() external returns (uint VAR37);
function FUN16() external view returns (uint VAR37);
}
contract UsingTreasury VAR38
VAR5
{
constructor(address VAR8)
FUN17(VAR8)
public
{}
modifier FUN18(){
require(msg.sender == address(FUN19()));
VAR7;
}
function FUN19()
public
view
returns (VAR36)
{
return FUN20(FUN2(""));
}
}
contract Bankrollable VAR38
VAR39
{
uint public VAR40;
Ledger public VAR41;
uint public VAR42;
AddressSet public VAR43;
modifier FUN21(){
require(msg.sender == FUN22());
VAR7;
}
event FUN23(uint VAR44, address indexed VAR45, uint VAR46, uint VAR42);
event FUN24(uint VAR44, address indexed VAR45, uint VAR46, uint VAR42);
event FUN25(uint VAR44, address indexed VAR47, uint VAR46);
event FUN26(uint VAR44, address indexed VAR48, address indexed VAR49);
event FUN27(uint VAR44, address indexed VAR48, address indexed VAR49);
constructor(address VAR8)
FUN28(VAR8)
public
{
VAR41 = VAR50 FUN29(this);
VAR43 = VAR50 FUN30(this);
}
function FUN31(address VAR3)
VAR51
public
{
bool VAR52 = VAR43.FUN7(VAR3);
if (VAR52) emit FUN26(VAR53, VAR3, msg.sender);
}
function FUN32(address VAR3)
VAR51
public
{
bool VAR54 = VAR43.FUN12(VAR3);
if (VAR54) emit FUN27(VAR53, VAR3, msg.sender);
}
function () public payable {}
function FUN33()
public
payable
{
require(VAR43.FUN9()==0 || VAR43.FUN13(msg.sender));
VAR41.FUN7(msg.sender, msg.value);
VAR42 = VAR41.FUN34();
emit FUN23(VAR53, msg.sender, msg.value, VAR42);
}
function FUN35(uint VAR55, string VAR56)
public
returns (uint VAR57)
{
address VAR58 = msg.sender;
uint VAR59 = FUN36();
uint VAR26 = address(this).VAR12;
uint VAR60 = VAR26 > VAR59 ? VAR26 - VAR59 : 0;
if (VAR55 > VAR60) VAR55 = VAR60;
VAR55 = VAR41.FUN8(VAR58, VAR55);
VAR42 = VAR41.FUN34();
if (VAR55 == 0) return;
bytes4 VAR61 = bytes4(FUN37(VAR56));
require(VAR58.call.value(VAR55)(VAR61));
emit FUN24(VAR53, VAR58, VAR55, VAR42);
return VAR55;
}
function FUN38()
public
returns (uint VAR37)
{
int VAR62 = FUN39();
if (VAR62 <= 0) return;
VAR37 = uint(VAR62);
VAR40 += VAR37;
address VAR63 = FUN19();
require(VAR63.call.value(VAR37)());
emit FUN25(VAR53, VAR63, VAR37);
}
function FUN36()
public
view
returns (uint VAR55);
function FUN22()
public
view
returns (address VAR3);
function FUN39()
public
view
returns (int VAR37)
{
int VAR26 = int(address(this).VAR12);
int VAR64 = int(VAR42 + FUN36());
return VAR26 - VAR64;
}
function FUN40()
public
view
returns (int VAR37)
{
return int(VAR40) + FUN39();
}
function FUN41()
public
view
returns (uint VAR55)
{
uint VAR26 = address(this).VAR12;
uint VAR65 = VAR42;
uint VAR66 = FUN36();
if (VAR26 <= VAR66) return 0;
else if (VAR26 < VAR66 + VAR65) return VAR26 - VAR66;
else return VAR65;
}
function FUN42(address VAR3)
public
view
returns (uint VAR55)
{
return VAR41.FUN10(VAR3);
}
function FUN43()
public
view
returns (address[], uint[])
{
return VAR41.FUN11();
}
}
contract UsingAdmin VAR38
VAR5
{
constructor(address VAR8)
FUN17(VAR8)
public
{}
modifier FUN44(){
require(msg.sender == FUN45());
VAR7;
}
function FUN45()
public
constant
returns (address VAR3)
{
return FUN2("");
}
}
contract InstaDice VAR38
VAR67,
VAR68
{
struct VAR69 {
uint32 VAR70;
uint32 VAR71;
uint32 VAR72;
uint8 VAR73;
uint72 VAR74;
}
struct VAR75 {
uint32 VAR76;
uint32 VAR77;
uint96 VAR78;
uint96 VAR79;
}
struct VAR80 {
uint64 VAR81;    //
uint64 VAR82;
uint8 VAR83;
uint8 VAR84;
uint16 VAR85;
}
mapping (address => VAR69) public VAR86;
Stats VAR87;
Settings VAR88;
uint8 constant public VAR89 = 1;
event FUN46(uint VAR44);
event FUN47(uint VAR44, address indexed VAR90);
event FUN48(uint VAR44, uint32 indexed VAR70, address indexed VAR91, uint VAR92, uint8 VAR93, uint VAR94);
event FUN49(uint VAR44, address indexed VAR91, string msg, uint VAR92, uint8 VAR93);
event FUN50(uint VAR44, uint32 indexed VAR70, address indexed VAR91, uint8 VAR95, uint VAR94);
event FUN51(uint VAR44, string msg);
constructor(address VAR8)
FUN52(VAR8)
FUN53(VAR8)
public
{
VAR87.VAR78 = 1;
VAR88.VAR82 = .3 VAR96;
VAR88.VAR81 = .001 VAR96;
VAR88.VAR83 = 5;
VAR88.VAR84 = 98;
VAR88.VAR85 = 100;
emit FUN46(VAR53);
}
function FUN54(
uint64 VAR97,
uint64 VAR98,
uint8 VAR99,
uint8 VAR100,
uint16 VAR101
)
public
VAR102
{
require(VAR97 <= VAR98);
require(VAR98 <= .625 VAR96);
require(VAR99 >= 1);
require(VAR100 <= 99);
require(VAR101 <= 500);
VAR88.VAR81 = VAR97;
VAR88.VAR82 = VAR98;
VAR88.VAR83 = VAR99;
VAR88.VAR84 = VAR100;
VAR88.VAR85 = VAR101;
emit FUN47(VAR53, msg.sender);
}
function FUN55(uint8 VAR103)
public
payable
returns (bool VAR104)
{
if (!FUN56(VAR103)) return;
User memory VAR105 = VAR86[msg.sender];
if (VAR105.VAR72 == FUN57(VAR106.VAR93)){
FUN58("", msg.value, VAR103);
return false;
}
Stats memory VAR107 = VAR87;
if (VAR105.VAR72 != 0) FUN59(VAR105, VAR107);
VAR107.VAR76 = VAR105.VAR70 == 0 ? VAR107.VAR76 + 1 : VAR107.VAR76;
VAR107.VAR77 = VAR87.VAR77 + 1;
VAR107.VAR78 = VAR87.VAR78 + FUN60(msg.value);
VAR87 = VAR107;
VAR105.VAR70 = VAR105.VAR70 == 0 ? VAR107.VAR76 : VAR105.VAR70;
VAR105.VAR71 = VAR107.VAR77;
VAR105.VAR72 = FUN57(VAR106.VAR93);
VAR105.VAR73 = VAR103;
VAR105.VAR74 = FUN61(msg.value, VAR103);
VAR86[msg.sender] = VAR105;
emit FUN48(VAR53, VAR105.VAR71, msg.sender, msg.value, VAR105.VAR73, VAR105.VAR74);
return true;
}
function FUN62()
public
returns (bool VAR104)
{
User storage VAR105 = VAR86[msg.sender];
if (VAR105.VAR72 == FUN57(VAR106.VAR93)){
emit FUN51(VAR53, "");
return false;
}
if (VAR105.VAR72 == 0){
emit FUN51(VAR53, "");
return false;
}
Stats memory VAR107 = VAR87;
FUN59(VAR105, VAR107);
VAR105.VAR71 = 0;
VAR105.VAR72 = 0;
VAR105.VAR73 = 0;
VAR105.VAR74 = 0;
VAR87.VAR79 = VAR107.VAR79;
return true;
}
function FUN56(uint8 VAR103)
private
returns (bool VAR108)
{
Settings memory VAR109 = VAR88;
if (VAR103 < VAR109.VAR83) {
FUN58("", msg.value, VAR103);
return false;
}
if (VAR103 > VAR109.VAR84){
FUN58("", msg.value, VAR103);
return false;
}
if (msg.value < VAR109.VAR81){
FUN58("", msg.value, VAR103);
return false;
}
if (msg.value > VAR109.VAR82){
FUN58("", msg.value, VAR103);
return false;
}
if (msg.value > FUN63()){
FUN58("", msg.value, VAR103);
return false;
}
return true;
}
function FUN59(User memory VAR105, Stats memory VAR107)
private
{
assert(VAR105.VAR72 != FUN57(VAR106.VAR93));
assert(VAR105.VAR72 != 0);
uint8 VAR110 = FUN64(VAR105.VAR72, VAR105.VAR71);
bool VAR111 = VAR110 <= VAR105.VAR73;
if (VAR111) {
require(msg.sender.call.value(VAR105.VAR74)());
VAR107.VAR79 += VAR105.VAR74;
}
emit FUN50(VAR53, VAR105.VAR71, msg.sender, VAR110, VAR111 ? VAR105.VAR74 : 0);
}
function FUN58(string VAR112, uint VAR113, uint8 VAR103)
private
{
require(msg.sender.call.value(msg.value)());
emit FUN49(VAR53, msg.sender, VAR112, VAR113, VAR103);
}
function FUN36() public view returns (uint VAR55) {
return 0;
}
function FUN22() public view returns (address VAR114)
{
return FUN45();
}
function FUN63() public view returns (uint VAR55) {
uint VAR115 = 10 * 100 / uint(VAR88.VAR83);
return FUN41() / VAR115;
}
function FUN65() public view returns (uint VAR55) {
uint VAR116 = FUN63();
return VAR116 > VAR88.VAR82 ? VAR88.VAR82 : VAR116;
}
function FUN61(uint VAR113, uint VAR103)
public
view
returns (uint72 VAR117)
{
uint VAR101 = VAR88.VAR85;
uint VAR118 = VAR113 * 1e32;
uint VAR119 = (VAR118 * 100) / VAR103;
uint VAR120 = (VAR119 * VAR101) / 10000;
return FUN66( (VAR119 - VAR120) / 1e32 );
}
function FUN64(uint32 VAR121, uint32 VAR122)
public
view
returns (uint8 VAR110)
{
bytes32 VAR123 = FUN67(VAR121);
if (VAR123 == 0) { return 101; }
return uint8(uint(FUN37(VAR123, VAR122)) % 100 + 1);
}
function FUN68() public view returns (VAR124) {
return VAR87.VAR76;
}
function FUN69() public view returns (VAR124) {
return VAR87.VAR77;
}
function FUN70() public view returns (uint) {
return VAR87.VAR78;
}
function FUN71() public view returns (uint) {
return VAR87.VAR79;
}
function FUN72() public view returns (uint) {
return VAR88.VAR81;
}
function FUN73() public view returns (uint) {
return VAR88.VAR82;
}
function FUN74() public view returns (uint8) {
return VAR88.VAR83;
}
function FUN75() public view returns (uint8) {
return VAR88.VAR84;
}
function FUN76() public view returns (uint16) {
return VAR88.VAR85;
}
}
1
---------------------------------
283 0xff1667bddc9b832a0022bbfc6c586bd299262d94.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
address public VAR3;
bool public VAR4;
event FUN1();
event FUN2();
modifier onlyOwner {
require(msg.sender == VAR3);
VAR5;
}
modifier VAR6 {
require(VAR4);
VAR5;
}
modifier VAR7 {
require(!VAR4);
VAR5;
}
function FUN3(address VAR8) onlyOwner public {
VAR3 = VAR8;
}
function FUN4(bool VAR9) onlyOwner public {
VAR4 = VAR9;
if (VAR4) {
emit FUN1();
} else {
emit FUN2();
}
}
constructor() public {
VAR3 = msg.sender;
}
}
contract VAR10 {
function FUN5() public constant returns (uint);
function FUN6(address VAR11) public constant returns (uint VAR12);
function FUN7(address VAR11, address VAR13) public constant returns (uint VAR14);
function transfer(address VAR15, uint VAR16) public returns (bool VAR17);
function FUN8(address VAR13, uint VAR16) public returns (bool VAR17);
function FUN9(address VAR18, address VAR15, uint VAR16) public returns (bool VAR17);
function FUN10() public constant returns (string);
function FUN11() public constant returns (uint256);
event Transfer(address indexed VAR18, address indexed VAR15, uint VAR16);
event FUN12(address indexed VAR11, address indexed VAR13, uint VAR16);
}
contract VAR19 {
function FUN13() public payable;
}
library VAR20 {
function FUN14(uint256 VAR21, uint256 VAR22) internal pure returns (uint256 VAR23) {
if (VAR21 == 0) {
return 0;
}
VAR23 = VAR21 * VAR22;
assert(VAR23 / VAR21 == VAR22);
return VAR23;
}
function FUN15(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
return VAR21 / VAR22;
}
function FUN16(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
assert(VAR22 <= VAR21);
return VAR21 - VAR22;
}
function FUN17(uint256 VAR21, uint256 VAR22) internal pure returns (uint256 VAR23) {
VAR23 = VAR21 + VAR22;
assert(VAR23 >= VAR21);
return VAR23;
}
}
contract Crowdsale is VAR2 {
using SafeMath for uint256;
ERC20Token public VAR24;
address public VAR25;
function FUN18(address VAR26) onlyOwner public {
VAR25 = VAR26;
}
Share public VAR27;
function FUN19(Share VAR28) onlyOwner public {
VAR27 = VAR28;
}
uint256 public VAR29;
function FUN20(uint256 VAR30) onlyOwner public {
VAR29 = VAR30;
}
uint256 public VAR31;
function FUN21(uint256 VAR32) onlyOwner public {
VAR31 = VAR32;
}
uint256 public VAR33;
event FUN22 (
address indexed VAR34,
address indexed VAR35,
uint256 value,
uint256 VAR36
);
modifier VAR37 {
require(VAR33 < VAR31);
VAR5;
}
constructor(uint256 VAR30, Share VAR28, ERC20Token VAR38, address VAR39, uint256 VAR40)
public
{
require(VAR30 > 0);
require(VAR28 != address(0));
require(VAR38 != address(0));
VAR3 = msg.sender;
VAR29 = VAR30;
VAR27 = VAR28;
VAR24 = VAR38;
VAR25  = VAR39;
VAR31 = VAR40 * (10 ** 18);
}
function () external payable {
FUN23(msg.sender);
}
function FUN23(address VAR41) public payable onlyAllowed VAR7 {
uint256 VAR42 = msg.value;
if (VAR42 > VAR31.FUN16(VAR33)) {
VAR42 = VAR31.FUN16(VAR33);
}
uint256 VAR16 = FUN24(VAR42);
if (address(VAR27) != address(0)) {
VAR27.VAR43.value(VAR42)();
}
VAR33 = VAR33.FUN17(VAR42);
FUN25(VAR41, VAR16);
emit FUN22(
msg.sender,
VAR41,
VAR42,
VAR16
);
if(msg.value.FUN16(VAR42) > 0) {
msg.sender.transfer(msg.value.FUN16(VAR42));
}
}
function FUN26(
address VAR41,
uint256 VAR44
)
internal
{
VAR24.FUN9(VAR25, VAR41, VAR44);
}
function FUN25(
address VAR41,
uint256 VAR44
)
internal
{
FUN26(VAR41, VAR44);
}
function FUN24(uint256 VAR45)
internal view returns (uint256)
{
return VAR45 / VAR29;
}
function FUN27() public {
VAR3.transfer(address(this).VAR12);
}
}
1
---------------------------------
284 0xff5a7299ff6f0fbaad9b38906b77d08c0fbdc9a7.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(BaseWallet VAR3) external;
function FUN2(BaseWallet VAR3, Module VAR4) external;
function FUN3(address VAR5) external;
}
contract BaseModule is VAR2 {
ModuleRegistry internal VAR6;
event FUN4(bytes32 VAR7);
event FUN5(address VAR8);
constructor(ModuleRegistry VAR9, bytes32 VAR10) public {
VAR6 = VAR9;
emit FUN4(VAR10);
}
modifier FUN6(BaseWallet VAR3) {
require(msg.sender == address(VAR3), "");
VAR11;
}
modifier onlyOwner(BaseWallet VAR3) {
require(msg.sender == address(this) || FUN7(VAR3, msg.sender), "");
VAR11;
}
modifier FUN8(BaseWallet VAR3) {
require(FUN7(VAR3, msg.sender), "");
VAR11;
}
function FUN1(BaseWallet VAR3) external FUN6(VAR3) {
emit FUN5(VAR3);
}
function FUN2(BaseWallet VAR3, Module VAR4) external FUN8(VAR3) {
require(VAR6.FUN9(VAR4), "");
VAR3.FUN10(VAR4, true);
}
function FUN3(address VAR5) external {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(address(VAR6), VAR12);
}
function FUN7(BaseWallet VAR3, address VAR13) internal view returns (bool) {
return VAR3.FUN13() == VAR13;
}
}
contract RelayerModule is VAR2 {
uint256 constant internal VAR14 = 10000;
mapping (address => VAR15) public VAR16;
struct VAR15 {
uint256 VAR17;
mapping (bytes32 => bool) VAR18;
}
event FUN14(address indexed VAR8, bool indexed VAR19, bytes32 VAR20);
modifier VAR21 {
require(msg.sender == address(this), "");
VAR11;
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256);
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool);
function FUN17(
BaseWallet VAR3,
bytes VAR22,
uint256 VAR25,
bytes VAR24,
uint256 VAR26,
uint256 VAR27
)
external
returns (bool VAR19)
{
uint VAR28 = FUN18();
bytes32 VAR29 = FUN19(address(this), VAR3, 0, VAR22, VAR25, VAR26, VAR27);
require(FUN20(VAR3, VAR25, VAR29), "");
require(FUN21(address(VAR3), VAR22), "");
uint256 VAR30 = FUN15(VAR3, VAR22);
if((VAR30 * 65) == VAR24.VAR31) {
if(FUN22(VAR3, VAR27, VAR26, VAR30)) {
if(VAR30 == 0 || FUN16(VAR3, VAR22, VAR29, VAR24)) {
VAR19 = address(this).call(VAR22);
FUN23(VAR3, VAR28 - FUN18(), VAR26, VAR27, VAR30, msg.sender);
}
}
}
emit FUN14(VAR3, VAR19, VAR29);
}
function FUN24(BaseWallet VAR3) external view returns (uint256 VAR17) {
return VAR16[VAR3].VAR17;
}
function FUN19(
address VAR32,
address VAR33,
uint256 VAR34,
bytes VAR22,
uint256 VAR25,
uint256 VAR26,
uint256 VAR27
)
internal
pure
returns (bytes32)
{
return FUN25(
VAR35.FUN26(
"",
FUN25(VAR35.FUN26(FUN27(0x19), FUN27(0), VAR32, VAR33, VAR34, VAR22, VAR25, VAR26, VAR27))
));
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
if(VAR16[VAR3].VAR18[VAR23] == true) {
return false;
}
VAR16[VAR3].VAR18[VAR23] = true;
return true;
}
function FUN28(BaseWallet VAR3, uint256 VAR25) internal returns (bool) {
if(VAR25 <= VAR16[VAR3].VAR17) {
return false;
}
uint256 VAR36 = (VAR25 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;
if(VAR36 > VAR37.VAR38 + VAR14) {
return false;
}
VAR16[VAR3].VAR17 = VAR25;
return true;
}
function FUN29(bytes32 VAR39, bytes VAR24, uint VAR40) internal pure returns (address) {
uint8 VAR41;
bytes32 VAR42;
bytes32 VAR43;
VAR44 {
VAR42 := FUN30(FUN31(VAR24, FUN31(0x20,FUN32(0x41,VAR40))))
VAR43 := FUN30(FUN31(VAR24, FUN31(0x40,FUN32(0x41,VAR40))))
VAR41 := FUN33(FUN30(FUN31(VAR24, FUN31(0x41,FUN32(0x41,VAR40)))), 0xff)
}
require(VAR41 == 27 || VAR41 == 28);
return FUN34(VAR39, VAR41, VAR42, VAR43);
}
function FUN23(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR27, uint VAR24, address VAR46) internal {
uint256 VAR47 = 29292 + VAR45;
if(VAR26 > 0 && VAR24 > 1 && VAR47 <= VAR27) {
if(VAR26 > VAR48.VAR49) {
VAR47 = VAR47 * VAR48.VAR49;
}
else {
VAR47 = VAR47 * VAR26;
}
VAR3.FUN35(VAR46, VAR47, "");
}
}
function FUN22(BaseWallet VAR3, uint VAR45, uint VAR26, uint VAR24) internal view returns (bool) {
if(VAR26 > 0
&& VAR24 > 1
&& (address(VAR3).VAR50 < VAR45 * VAR26 || VAR3.FUN36(this) == false)) {
return false;
}
return true;
}
function FUN21(address VAR3, bytes VAR22) private pure returns (bool) {
require(VAR22.VAR31 >= 36, "");
address VAR51;
VAR44 {
VAR51 := FUN30(FUN31(VAR22, 0x24))
}
return VAR51 == VAR3;
}
function FUN37(bytes VAR22) internal pure returns (bytes4 VAR52) {
require(VAR22.VAR31 >= 4, "");
VAR44 {
VAR52 := FUN30(FUN31(VAR22, 0x20))
}
}
}
contract VAR53 {
function FUN38() public view returns (uint);
function FUN39() public view returns (uint);
function FUN12(address VAR54) public view returns (uint VAR50);
function FUN40(address VAR54, address VAR55) public view returns (uint VAR56);
function transfer(address VAR57, uint VAR58) public returns (bool VAR19);
function FUN41(address VAR55, uint VAR58) public returns (bool VAR19);
function FUN42(address VAR59, address VAR57, uint VAR58) public returns (bool VAR19);
}
contract VAR60 {
address public VAR61;
event FUN43(address indexed VAR62);
modifier onlyOwner {
require(msg.sender == VAR61, "");
VAR11;
}
constructor() public {
VAR61 = msg.sender;
}
function FUN44(address VAR62) external onlyOwner {
require(VAR62 != address(0), "");
VAR61 = VAR62;
emit FUN43(VAR62);
}
}
contract ModuleRegistry is VAR60 {
mapping (address => VAR63) internal VAR64;
mapping (address => VAR63) internal VAR65;
event FUN45(address indexed VAR66, bytes32 VAR7);
event FUN46(address VAR66);
event FUN47(address indexed VAR67, bytes32 VAR7);
event FUN48(address VAR67);
struct VAR63 {
bool VAR68;
bytes32 VAR7;
}
function FUN49(address VAR4, bytes32 VAR10) external onlyOwner {
require(!VAR64[VAR4].VAR68, "");
VAR64[VAR4] = FUN50({VAR68: true, VAR7: VAR10});
emit FUN45(VAR4, VAR10);
}
function FUN51(address VAR4) external onlyOwner {
require(VAR64[VAR4].VAR68, "");
delete VAR64[VAR4];
emit FUN46(VAR4);
}
function FUN52(address VAR69, bytes32 VAR10) external onlyOwner {
require(!VAR65[VAR69].VAR68, "");
VAR65[VAR69] = FUN50({VAR68: true, VAR7: VAR10});
emit FUN47(VAR69, VAR10);
}
function FUN53(address VAR69) external onlyOwner {
require(VAR65[VAR69].VAR68, "");
delete VAR65[VAR69];
emit FUN48(VAR69);
}
function FUN3(address VAR5) external onlyOwner {
uint VAR12 = FUN11(VAR5).FUN12(address(this));
FUN11(VAR5).transfer(msg.sender, VAR12);
}
function FUN54(address VAR4) external view returns (bytes32) {
return VAR64[VAR4].VAR7;
}
function FUN55(address VAR69) external view returns (bytes32) {
return VAR65[VAR69].VAR7;
}
function FUN9(address VAR4) external view returns (bool) {
return VAR64[VAR4].VAR68;
}
function FUN9(address[] VAR70) external view returns (bool) {
for(uint VAR71 = 0; VAR71 < VAR70.VAR31; VAR71++) {
if (!VAR64[VAR70[VAR71]].VAR68) {
return false;
}
}
return true;
}
function FUN56(address VAR69) external view returns (bool) {
return VAR65[VAR69].VAR68;
}
}
contract VAR72 {
address public VAR73;
address public VAR61;
mapping (address => bool) public VAR74;
mapping (bytes4 => address) public VAR75;
uint public VAR64;
event FUN57(address indexed VAR66, bool value);
event FUN58(address indexed VAR66, bytes4 indexed VAR76);
event FUN59(address indexed VAR66, address indexed VAR77, uint indexed value, bytes VAR78);
event FUN60(uint indexed value, address indexed sender, bytes VAR78);
event FUN43(address VAR61);
modifier VAR79 {
require(VAR74[msg.sender], "");
VAR11;
}
function FUN1(address VAR80, address[] VAR70) external {
require(VAR61 == address(0) && VAR64 == 0, "");
require(VAR70.VAR31 > 0, "");
VAR61 = VAR80;
VAR64 = VAR70.VAR31;
for(uint256 VAR71 = 0; VAR71 < VAR70.VAR31; VAR71++) {
require(VAR74[VAR70[VAR71]] == false, "");
VAR74[VAR70[VAR71]] = true;
FUN61(VAR70[VAR71]).FUN1(this);
emit FUN57(VAR70[VAR71], true);
}
}
function FUN10(address VAR4, bool VAR34) external VAR79 {
if (VAR74[VAR4] != VAR34) {
if(VAR34 == true) {
VAR64 += 1;
VAR74[VAR4] = true;
FUN61(VAR4).FUN1(this);
}
else {
VAR64 -= 1;
require(VAR64 > 0, "");
delete VAR74[VAR4];
}
emit FUN57(VAR4, VAR34);
}
}
function FUN62(address VAR4, bytes4 VAR81) external VAR79 {
require(VAR74[VAR4], "");
VAR75[VAR81] = VAR4;
emit FUN58(VAR4, VAR81);
}
function FUN63(address VAR62) external VAR79 {
require(VAR62 != address(0), "");
VAR61 = VAR62;
emit FUN43(VAR62);
}
function FUN35(address VAR82, uint VAR34, bytes VAR22) external VAR79 {
require(VAR82.call.value(VAR34)(VAR22), "");
emit FUN59(msg.sender, VAR82, VAR34, VAR22);
}
function() public payable {
if(msg.VAR78.VAR31 > 0) {
address VAR66 = VAR75[msg.VAR83];
if(VAR66 == address(0)) {
emit FUN60(msg.value, msg.sender, msg.VAR78);
}
else {
require(VAR74[VAR66], "");
VAR44 {
FUN64(0, 0, FUN65())
let VAR84 := FUN66(VAR85, VAR66, 0, FUN65(), 0, 0)
FUN67(0, 0, FUN68())
switch VAR84
case 0 {revert(0, FUN68())}
default {return (0, FUN68())}
}
}
}
}
}
contract VAR86 {
modifier FUN69(BaseWallet VAR3) {
require(VAR3.FUN36(msg.sender), "");
VAR11;
}
}
contract GuardianStorage is VAR86 {
struct VAR87 {
address[] VAR88;
mapping (address => VAR89) VAR90;
uint256 VAR91;
address VAR92;
}
struct VAR89 {
bool VAR68;
uint128 VAR93;
}
mapping (address => VAR87) internal VAR94;
function FUN70(BaseWallet VAR3, address VAR95) external FUN69(VAR3) {
GuardianStorageConfig storage VAR96 = VAR94[VAR3];
VAR96.VAR90[VAR95].VAR68 = true;
VAR96.VAR90[VAR95].VAR93 = uint128(VAR96.VAR88.FUN71(VAR95) - 1);
}
function FUN72(BaseWallet VAR3, address VAR95) external FUN69(VAR3) {
GuardianStorageConfig storage VAR96 = VAR94[VAR3];
address VAR97 = VAR96.VAR88[VAR96.VAR88.VAR31 - 1];
if (VAR95 != VAR97) {
uint128 VAR98 = VAR96.VAR90[VAR95].VAR93;
VAR96.VAR88[VAR98] = VAR97;
VAR96.VAR90[VAR97].VAR93 = VAR98;
}
VAR96.VAR88.VAR31--;
delete VAR96.VAR90[VAR95];
}
function FUN73(BaseWallet VAR3) external view returns (uint256) {
return VAR94[VAR3].VAR88.VAR31;
}
function FUN74(BaseWallet VAR3) external view returns (address[]) {
GuardianStorageConfig storage VAR96 = VAR94[VAR3];
address[] memory VAR88 = new address[](VAR96.VAR88.VAR31);
for (uint256 VAR71 = 0; VAR71 < VAR96.VAR88.VAR31; VAR71++) {
VAR88[VAR71] = VAR96.VAR88[VAR71];
}
return VAR88;
}
function FUN75(BaseWallet VAR3, address VAR95) external view returns (bool) {
return VAR94[VAR3].VAR90[VAR95].VAR68;
}
function FUN76(BaseWallet VAR3, uint256 VAR99) external FUN69(VAR3) {
VAR94[VAR3].VAR91 = VAR99;
if(VAR99 != 0 && msg.sender != VAR94[VAR3].VAR92) {
VAR94[VAR3].VAR92 = msg.sender;
}
}
function FUN77(BaseWallet VAR3) external view returns (bool) {
return VAR94[VAR3].VAR91 > VAR100;
}
function FUN78(BaseWallet VAR3) external view returns (uint256) {
return VAR94[VAR3].VAR91;
}
function FUN79(BaseWallet VAR3) external view returns (address) {
return VAR94[VAR3].VAR92;
}
}
library VAR101 {
function FUN75(address[] VAR102, address VAR95) internal view returns (bool, address[]) {
if(VAR102.VAR31 == 0 || VAR95 == address(0)) {
return (false, VAR102);
}
bool VAR103 = false;
address[] memory VAR104 = new address[](VAR102.VAR31 - 1);
uint256 VAR93 = 0;
for (uint256 VAR71 = 0; VAR71 < VAR102.VAR31; VAR71++) {
if(!VAR103) {
if(VAR95 == VAR102[VAR71]) {
VAR103 = true;
continue;
}
if(FUN80(VAR102[VAR71]) && FUN81(VAR102[VAR71], VAR95)) {
VAR103 = true;
continue;
}
}
if(VAR93 < VAR104.VAR31) {
VAR104[VAR93] = VAR102[VAR71];
VAR93++;
}
}
return VAR103 ? (true, VAR104) : (false, VAR102);
}
function FUN80(address VAR13) internal view returns (bool) {
uint32 VAR105;
VAR44 {
VAR105 := FUN82(VAR13)
}
return (VAR105 > 0);
}
function FUN81(address VAR95, address VAR80) internal view returns (bool) {
address VAR61 = address(0);
bytes4 VAR83 = bytes4(FUN25(""));
VAR44 {
let VAR106 := FUN30(0x40)
FUN83(VAR106,VAR83)
let VAR84 := FUN66(5000, VAR95, VAR106, 0x20, VAR106, 0x20)
if FUN84(VAR84, 1) {
VAR61 := FUN30(VAR106)
}
}
return VAR61 == VAR80;
}
}
contract GuardianManager is VAR107, VAR108 {
bytes32 constant VAR109 = "";
bytes4 constant internal VAR110 = bytes4(FUN25(""));
bytes4 constant internal VAR111 = bytes4(FUN25(""));
struct VAR112 {
mapping (bytes32 => uint256) VAR113;
}
mapping (address => VAR112) internal VAR94;
GuardianStorage public VAR114;
uint256 public VAR115;
uint256 public VAR116;
event FUN85(address indexed VAR8, address indexed VAR117, uint256 VAR118);
event FUN86(address indexed VAR8, address indexed VAR117, uint256 VAR118);
event FUN87(address indexed VAR8, address indexed VAR117);
event FUN88(address indexed VAR8, address indexed VAR117);
event FUN89(address indexed VAR8, address indexed VAR117);
event FUN90(address indexed VAR8, address indexed VAR117);
modifier FUN91(BaseWallet VAR3) {
require(VAR114.FUN77(VAR3), "");
VAR11;
}
modifier FUN92(BaseWallet VAR3) {
require(!VAR114.FUN77(VAR3), "");
VAR11;
}
constructor(
ModuleRegistry VAR9,
GuardianStorage VAR119,
uint256 VAR120,
uint256 VAR121
)
FUN93(VAR9, VAR109)
public
{
VAR114 = VAR119;
VAR115 = VAR120;
VAR116 = VAR121;
}
function FUN70(BaseWallet VAR3, address VAR95) external onlyOwner(VAR3) FUN92(VAR3) {
require(!FUN7(VAR3, VAR95), "");
require(!FUN75(VAR3, VAR95), "");
require(VAR95.call.FUN94(5000)(VAR35.FUN95("")), "");
if(VAR114.FUN73(VAR3) == 0) {
VAR114.FUN70(VAR3, VAR95);
emit FUN89(VAR3, VAR95);
} else {
bytes32 VAR122 = FUN25(VAR35.FUN26(address(VAR3), VAR95, ""));
GuardianManagerConfig storage VAR96 = VAR94[VAR3];
require(
VAR96.VAR113[VAR122] == 0 || VAR100 > VAR96.VAR113[VAR122] + VAR116,
"");
VAR96.VAR113[VAR122] = VAR100 + VAR115;
emit FUN85(VAR3, VAR95, VAR100 + VAR115);
}
}
function FUN96(BaseWallet VAR3, address VAR95) public FUN92(VAR3) {
bytes32 VAR122 = FUN25(VAR35.FUN26(address(VAR3), VAR95, ""));
GuardianManagerConfig storage VAR96 = VAR94[VAR3];
require(VAR96.VAR113[VAR122] > 0, "");
require(VAR96.VAR113[VAR122] < VAR100, "");
require(VAR100 < VAR96.VAR113[VAR122] + VAR116, "");
VAR114.FUN70(VAR3, VAR95);
delete VAR96.VAR113[VAR122];
emit FUN89(VAR3, VAR95);
}
function FUN97(BaseWallet VAR3, address VAR95) public onlyOwner(VAR3) FUN92(VAR3) {
bytes32 VAR122 = FUN25(VAR35.FUN26(address(VAR3), VAR95, ""));
GuardianManagerConfig storage VAR96 = VAR94[VAR3];
require(VAR96.VAR113[VAR122] > 0, "");
delete VAR96.VAR113[VAR122];
emit FUN87(VAR3, VAR95);
}
function FUN72(BaseWallet VAR3, address VAR95) external onlyOwner(VAR3) {
require(FUN75(VAR3, VAR95), "");
bytes32 VAR122 = FUN25(VAR35.FUN26(address(VAR3), VAR95, ""));
GuardianManagerConfig storage VAR96 = VAR94[VAR3];
require(
VAR96.VAR113[VAR122] == 0 || VAR100 > VAR96.VAR113[VAR122] + VAR116,
"");
VAR96.VAR113[VAR122] = VAR100 + VAR115;
emit FUN86(VAR3, VAR95, VAR100 + VAR115);
}
function FUN98(BaseWallet VAR3, address VAR95) public {
bytes32 VAR122 = FUN25(VAR35.FUN26(address(VAR3), VAR95, ""));
GuardianManagerConfig storage VAR96 = VAR94[VAR3];
require(VAR96.VAR113[VAR122] > 0, "");
require(VAR96.VAR113[VAR122] < VAR100, "");
require(VAR100 < VAR96.VAR113[VAR122] + VAR116, "");
VAR114.FUN72(VAR3, VAR95);
delete VAR96.VAR113[VAR122];
emit FUN90(VAR3, VAR95);
}
function FUN99(BaseWallet VAR3, address VAR95) public onlyOwner(VAR3) FUN92(VAR3) {
bytes32 VAR122 = FUN25(VAR35.FUN26(address(VAR3), VAR95, ""));
GuardianManagerConfig storage VAR96 = VAR94[VAR3];
require(VAR96.VAR113[VAR122] > 0, "");
delete VAR96.VAR113[VAR122];
emit FUN88(VAR3, VAR95);
}
function FUN75(BaseWallet VAR3, address VAR95) public view returns (bool VAR123) {
(VAR123, ) = VAR101.FUN75(VAR114.FUN74(VAR3), VAR95);
}
function FUN73(BaseWallet VAR3) external view returns (uint256 VAR124) {
return VAR114.FUN73(VAR3);
}
function FUN74(BaseWallet VAR3) external view returns (address[] VAR102) {
return VAR114.FUN74(VAR3);
}
function FUN20(BaseWallet VAR3, uint256 VAR25, bytes32 VAR23) internal returns (bool) {
return FUN28(VAR3, VAR25);
}
function FUN16(BaseWallet VAR3, bytes VAR22, bytes32 VAR23, bytes VAR24) internal view returns (bool) {
address VAR125 = FUN29(VAR23, VAR24, 0);
return FUN7(VAR3, VAR125);
}
function FUN15(BaseWallet VAR3, bytes VAR22) internal view returns (uint256) {
bytes4 VAR126 = FUN37(VAR22);
if (VAR126 == VAR110 || VAR126 == VAR111) {
return 0;
}
return 1;
}
}
1
---------------------------------
285 0xffa5d49dc77dec17aeaaa3580c7c1060f4709f0c.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 VAR5) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR7, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR8, address VAR9)
public view returns (uint256);
function FUN4(address VAR10, address VAR4, uint256 VAR5)
public returns (bool);
function FUN5(address VAR9, uint256 VAR5) public returns (bool);
event FUN6(
address indexed VAR11,
address indexed VAR12,
uint256 value
);
}
contract IBasicMultiToken is VAR13 {
event FUN7(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN8(address indexed VAR14, address indexed VAR15, uint256 value);
function FUN9() public view returns(uint256);
function FUN10(uint VAR16) public view returns(VAR13);
function FUN11() public view returns(bool);
function FUN12(address VAR17, uint256 VAR18, uint256[] VAR19) public;
function FUN13(address VAR17, uint256 VAR18) public;
function FUN14(address VAR17, uint256 VAR5) public;
function FUN15(address VAR17, uint256 VAR5, VAR13[] VAR20) public;
function FUN16() public;
function FUN17() public;
bytes4 public constant VAR21 = 0xd5c368b6;
}
contract IMultiToken is VAR22 {
event FUN18();
event FUN19(address indexed VAR23, address indexed VAR24, address indexed VAR25, uint256 VAR18, uint256 VAR26);
function FUN20(address VAR27) public view returns(uint256);
function FUN21() public view returns(bool);
function FUN22(address VAR23, address VAR24, uint256 VAR18) public view returns (uint256 VAR28);
function FUN23(address VAR23, address VAR24, uint256 VAR18, uint256 VAR29) public returns (uint256 VAR28);
function FUN24() public;
bytes4 public constant VAR30 = 0x81624e24;
}
library VAR31 {
function FUN25(uint256 VAR32, uint256 VAR33) internal pure returns (uint256 VAR34) {
if (VAR32 == 0) {
return 0;
}
VAR34 = VAR32 * VAR33;
assert(VAR34 / VAR32 == VAR33);
return VAR34;
}
function FUN26(uint256 VAR32, uint256 VAR33) internal pure returns (uint256) {
return VAR32 / VAR33;
}
function FUN27(uint256 VAR32, uint256 VAR33) internal pure returns (uint256) {
assert(VAR33 <= VAR32);
return VAR32 - VAR33;
}
function FUN28(uint256 VAR32, uint256 VAR33) internal pure returns (uint256 VAR34) {
VAR34 = VAR32 + VAR33;
assert(VAR34 >= VAR32);
return VAR34;
}
}
library VAR35 {
using SafeMath for uint;
function FUN29(address VAR36) internal view returns(bool VAR37) {
VAR38 {
VAR37 := FUN30(FUN31(VAR36), 0)
}
}
function FUN32() internal pure returns(bool VAR37) {
VAR38 {
switch FUN33()
case 0 {
VAR37 := 1
}
case 32 {
FUN34(0, 0, 32)
VAR37 := FUN35(0)
}
default {
revert(0, 0)
}
}
}
function FUN36() internal pure returns(bytes32 VAR37) {
VAR38 {
switch FUN37(FUN33(), 32)
case 1 {
FUN34(0, 0, 32)
VAR37 := FUN35(0)
}
switch FUN30(FUN33(), 32)
case 1 {
FUN34(0, 64, 32)
VAR37 := FUN35(0)
}
switch FUN38(FUN33(), 32)
case 1 {
revert(0, 0)
}
}
}
function FUN39(address VAR39, address VAR7, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR7, value));
return FUN32();
}
function FUN41(address VAR39, address VAR6, address VAR7, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR6, VAR7, value));
return FUN32();
}
function FUN42(address VAR39, address VAR12, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR12, value));
return FUN32();
}
//
function FUN43(ERC20 VAR39, address VAR7, uint256 value) internal {
if (value > 0) {
uint256 VAR40 = VAR39.FUN2(this);
FUN39(VAR39, VAR7, value);
require(VAR39.FUN2(this) == VAR40.FUN27(value), "");
}
}
function FUN44(ERC20 VAR39, address VAR6, address VAR7, uint256 value) internal {
if (value > 0) {
uint256 VAR41 = VAR39.FUN2(VAR7);
FUN41(VAR39, VAR6, VAR7, value);
require(VAR39.FUN2(VAR7) == VAR41.FUN28(value), "");
}
}
//
function FUN45(address VAR39) internal view returns(bytes32) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40(""))));
return FUN36();
}
function FUN46(address VAR39) internal view returns(bytes32) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40(""))));
return FUN36();
}
}
contract VAR42 {
address public VAR11;
event FUN47(address indexed VAR43);
event FUN48(
address indexed VAR43,
address indexed VAR44
);
constructor() public {
VAR11 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR11);
VAR45;
}
function FUN49() public onlyOwner {
emit FUN47(VAR11);
VAR11 = address(0);
}
function FUN50(address VAR46) public onlyOwner {
FUN51(VAR46);
}
function FUN51(address VAR46) internal {
require(VAR46 != address(0));
emit FUN48(VAR11, VAR46);
VAR11 = VAR46;
}
}
library VAR47 {
function FUN52(
ERC20Basic VAR27,
address VAR4,
uint256 VAR5
)
internal
{
require(VAR27.transfer(VAR4, VAR5));
}
function FUN53(
ERC20 VAR27,
address VAR10,
address VAR4,
uint256 VAR5
)
internal
{
require(VAR27.FUN4(VAR10, VAR4, VAR5));
}
function FUN54(
ERC20 VAR27,
address VAR9,
uint256 VAR5
)
internal
{
require(VAR27.FUN5(VAR9, VAR5));
}
}
contract CanReclaimToken is VAR42 {
using SafeERC20 for VAR2;
function FUN55(ERC20Basic VAR27) external onlyOwner {
uint256 VAR40 = VAR27.FUN2(this);
VAR27.FUN52(VAR11, VAR40);
}
}
contract IEtherToken is VAR13 {
function FUN56() public payable;
function FUN57(uint256 VAR48) public;
}
contract VAR49 {
function FUN58(
address[] VAR50,
uint256 VAR48,
uint256 VAR51
)
public
payable
returns(uint256);
function FUN59(
address[] VAR50,
uint256 VAR48,
uint256 VAR51
)
public
payable
returns(uint256);
}
contract VAR52 {
function FUN60(
address VAR53,
uint VAR54,
address VAR55,
address VAR56,
uint VAR57,
uint VAR58,
address VAR59
)
public
payable
returns(uint);
}
contract MultiChanger is VAR60 {
using SafeMath for uint256;
using CheckedERC20 for VAR13;
function FUN61(address VAR61, uint value, bytes VAR62, uint VAR63, uint VAR64) internal returns (bool VAR37) {
VAR38 {
let VAR65 := FUN35(0x40)
let VAR66 := FUN28(VAR62, 32)
VAR37 := call(
FUN27(VAR67, 34710),
VAR61,
value,
FUN28(VAR66, VAR63),
VAR64,
VAR65,
0
)
}
}
function FUN23(bytes VAR68, uint[] VAR69) public payable {
for (uint VAR16 = 0; VAR16 < VAR69.VAR70 - 1; VAR16++) {
require(FUN61(this, 0, VAR68, VAR69[VAR16], VAR69[VAR16 + 1] - VAR69[VAR16]));
}
}
function FUN62(address VAR71, bytes VAR62, uint256 value) external {
require(VAR71.call.value(value)(VAR62));
}
function FUN63(address VAR71, bytes VAR62, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR40.FUN25(VAR72).FUN26(VAR73);
require(VAR71.call.value(value)(VAR62));
}
function FUN64(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR48) external {
if (VAR74.FUN3(this, VAR71) != 0) {
VAR74.FUN42(VAR71, 0);
}
VAR74.FUN42(VAR71, VAR48);
require(VAR71.call(VAR62));
}
function FUN65(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN2(this).FUN25(VAR72).FUN26(VAR73);
if (VAR74.FUN3(this, VAR71) != 0) {
VAR74.FUN42(VAR71, 0);
}
VAR74.FUN42(VAR71, VAR48);
require(VAR71.call(VAR62));
}
function FUN66(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR48) external {
VAR74.FUN39(VAR71, VAR48);
if (VAR71 != address(0)) {
require(VAR71.call(VAR62));
}
}
function FUN67(address VAR71, bytes VAR62, ERC20 VAR74, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN2(this).FUN25(VAR72).FUN26(VAR73);
VAR74.FUN39(VAR71, VAR48);
if (VAR71 != address(0)) {
require(VAR71.call(VAR62));
}
}
function FUN68(IMultiToken VAR75, ERC20 VAR74, ERC20 VAR76, uint256 VAR51, uint256 VAR48) external {
if (VAR74.FUN3(this, VAR75) == 0) {
VAR74.FUN42(VAR75, uint256(-1));
}
VAR75.FUN23(VAR74, VAR76, VAR48, VAR51);
}
function FUN69(IMultiToken VAR75, ERC20 VAR74, ERC20 VAR76, uint256 VAR51, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN2(this).FUN25(VAR72).FUN26(VAR73);
this.FUN68(VAR75, VAR74, VAR76, VAR51, VAR48);
}
function FUN70(IEtherToken VAR77, uint256 VAR48) external {
VAR77.FUN57(VAR48);
}
function FUN71(IEtherToken VAR77, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR77.FUN2(this).FUN25(VAR72).FUN26(VAR73);
VAR77.FUN57(VAR48);
}
function FUN72(IBancorNetwork VAR78, address[] VAR50, uint256 value) external {
VAR78.VAR79.value(value)(VAR50, value, 1);
}
function FUN73(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR40.FUN25(VAR72).FUN26(VAR73);
VAR78.VAR79.value(value)(VAR50, value, 1);
}
function FUN74(IBancorNetwork VAR78, address[] VAR50, uint256 VAR48) external {
if (FUN75(VAR50[0]).FUN3(this, VAR78) == 0) {
FUN75(VAR50[0]).FUN42(VAR78, uint256(-1));
}
VAR78.FUN59(VAR50, VAR48, 1);
}
function FUN76(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN75(VAR50[0]).FUN2(this).FUN25(VAR72).FUN26(VAR73);
if (FUN75(VAR50[0]).FUN3(this, VAR78) == 0) {
FUN75(VAR50[0]).FUN42(VAR78, uint256(-1));
}
VAR78.FUN59(VAR50, VAR48, 1);
}
function FUN77(IBancorNetwork VAR78, address[] VAR50, uint256 VAR48) external {
FUN75(VAR50[0]).FUN39(VAR78, VAR48);
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN78(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN75(VAR50[0]).FUN2(this).FUN25(VAR72).FUN26(VAR73);
FUN75(VAR50[0]).FUN39(VAR78, VAR48);
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN79(IBancorNetwork VAR78, address[] VAR50, uint256 VAR48) external {
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN80(IBancorNetwork VAR78, address[] VAR50, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = FUN75(VAR50[0]).FUN2(VAR78).FUN25(VAR72).FUN26(VAR73);
VAR78.FUN58(VAR50, VAR48, 1);
}
function FUN81(IKyberNetworkProxy VAR80, ERC20 VAR74, address VAR76, uint256 VAR72, uint256 VAR73) external {
uint256 value = address(this).VAR40.FUN25(VAR72).FUN26(VAR73);
VAR80.VAR81.value(value)(
VAR74,
value,
VAR76,
this,
1 << 255,
0,
0
);
}
function FUN82(IKyberNetworkProxy VAR80, ERC20 VAR74, address VAR76, uint256 VAR48) external {
if (VAR74.FUN3(this, VAR80) == 0) {
VAR74.FUN42(VAR80, uint256(-1));
}
VAR80.FUN60(
VAR74,
VAR48,
VAR76,
this,
1 << 255,
0,
0
);
}
function FUN83(IKyberNetworkProxy VAR80, ERC20 VAR74, address VAR76, uint256 VAR72, uint256 VAR73) external {
uint256 VAR48 = VAR74.FUN2(this).FUN25(VAR72).FUN26(VAR73);
this.FUN82(VAR80, VAR74, VAR76, VAR48);
}
}
contract MultiBuyer is VAR82 {
using CheckedERC20 for VAR13;
function FUN84(
IMultiToken VAR75,
uint256 VAR83,
bytes VAR68,
uint[] VAR69
)
public
payable
{
FUN23(VAR68, VAR69);
uint VAR84 = VAR75.FUN1();
uint256 VAR85 = uint256(-1);
for (uint VAR16 = VAR75.FUN9(); VAR16 > 0; VAR16--) {
ERC20 VAR39 = VAR75.FUN10(VAR16 - 1);
if (VAR39.FUN3(this, VAR75) == 0) {
VAR39.FUN42(VAR75, uint256(-1));
}
uint256 VAR48 = VAR84.FUN25(VAR39.FUN2(this)).FUN26(VAR39.FUN2(VAR75));
if (VAR48 < VAR85) {
VAR85 = VAR48;
}
}
require(VAR85 >= VAR83, "");
VAR75.FUN13(msg.sender, VAR85);
if (address(this).VAR40 > 0) {
msg.sender.transfer(address(this).VAR40);
}
for (VAR16 = VAR75.FUN9(); VAR16 > 0; VAR16--) {
VAR39 = VAR75.FUN10(VAR16 - 1);
if (VAR39.FUN2(this) > 0) {
VAR39.FUN39(msg.sender, VAR39.FUN2(this));
}
}
}
function FUN85(
IMultiToken VAR75,
bytes VAR68,
uint[] VAR69,
uint VAR86,
uint VAR87
)
public
payable
{
FUN23(VAR68, VAR69);
uint VAR88 = VAR75.FUN9();
uint256[] memory VAR89 = new uint256[](VAR88);
for (uint VAR16 = 0; VAR16 < VAR88; VAR16++) {
ERC20 VAR39 = VAR75.FUN10(VAR16);
VAR89[VAR16] = VAR39.FUN2(this);
if (VAR39.FUN3(this, VAR75) == 0) {
VAR39.FUN42(VAR75, uint256(-1));
}
}
VAR75.FUN12(msg.sender, msg.value.FUN25(VAR86).FUN26(VAR87), VAR89);
if (address(this).VAR40 > 0) {
msg.sender.transfer(address(this).VAR40);
}
for (VAR16 = VAR75.FUN9(); VAR16 > 0; VAR16--) {
VAR39 = VAR75.FUN10(VAR16 - 1);
if (VAR39.FUN2(this) > 0) {
VAR39.FUN39(msg.sender, VAR39.FUN2(this));
}
}
}
}
1
---------------------------------
286 0x00125893df6ca0792c99601c462764ba5d80268a.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
constructor() public { VAR3 = msg.sender; }
address VAR3;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
}
contract VAR5 {
function FUN1(address VAR6) public constant returns (uint256 VAR7);
function transfer(address VAR8, uint256 VAR9) public returns (bool VAR10);
}
contract GasManager is VAR2 {
function () payable public {}
function FUN2(address[] VAR11, uint256[] VAR12) public onlyOwner {
require(VAR11.VAR13 == VAR12.VAR13);
for (uint VAR14 = 0; VAR14 < VAR11.VAR13; VAR14++) {
VAR11[VAR14].transfer(VAR12[VAR14]);
}
}
}
0
---------------------------------
287 0x001575786dfa7b9d9d1324ec308785738f80a951.sol
pragma VAR1 ^0.4.16;
pragma VAR1 ^0.4.20;
pragma VAR1 ^0.4.20;
contract VAR2 {
function FUN1 () public view returns (uint256 VAR3);
function FUN2 (address VAR4) public view returns (uint256 VAR5);
function transfer (address VAR6, uint256 VAR7)
public returns (bool VAR8);
function FUN3 (address VAR9, address VAR6, uint256 VAR7)
public returns (bool VAR8);
function FUN4 (address VAR10, uint256 VAR7)
public returns (bool VAR8);
function FUN5 (address VAR4, address VAR10)
public view returns (uint256 VAR11);
event Transfer (address indexed VAR9, address indexed VAR6, uint256 VAR7);
event FUN6 (
address indexed VAR4, address indexed VAR10, uint256 VAR7);
}
pragma VAR1 ^0.4.20;
contract VAR12 {
uint256 constant private VAR13 =
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
function FUN7 (uint256 VAR14, uint256 VAR15)
pure internal
returns (uint256 VAR16) {
assert (VAR14 <= VAR13 - VAR15);
return VAR14 + VAR15;
}
function FUN8 (uint256 VAR14, uint256 VAR15)
pure internal
returns (uint256 VAR16) {
assert (VAR14 >= VAR15);
return VAR14 - VAR15;
}
function FUN9 (uint256 VAR14, uint256 VAR15)
pure internal
returns (uint256 VAR16) {
if (VAR15 == 0) return 0;
assert (VAR14 <= VAR13 / VAR15);
return VAR14 * VAR15;
}
}
contract AbstractToken is VAR2, VAR12 {
function FUN10 () public {
}
function FUN2 (address VAR4) public view returns (uint256 VAR5) {
return VAR17 [VAR4];
}
function transfer (address VAR6, uint256 VAR7)
public returns (bool VAR8) {
uint256 VAR18 = VAR17 [msg.sender];
if (VAR18 < VAR7) return false;
if (VAR7 > 0 && msg.sender != VAR6) {
VAR17 [msg.sender] = FUN8 (VAR18, VAR7);
VAR17 [VAR6] = FUN7 (VAR17 [VAR6], VAR7);
}
Transfer (msg.sender, VAR6, VAR7);
return true;
}
function FUN3 (address VAR9, address VAR6, uint256 VAR7)
public returns (bool VAR8) {
uint256 VAR19 = VAR20 [VAR9][msg.sender];
if (VAR19 < VAR7) return false;
uint256 VAR18 = VAR17 [VAR9];
if (VAR18 < VAR7) return false;
VAR20 [VAR9][msg.sender] =
FUN8 (VAR19, VAR7);
if (VAR7 > 0 && VAR9 != VAR6) {
VAR17 [VAR9] = FUN8 (VAR18, VAR7);
VAR17 [VAR6] = FUN7 (VAR17 [VAR6], VAR7);
}
Transfer (VAR9, VAR6, VAR7);
return true;
}
function FUN4 (address VAR10, uint256 VAR7)
public returns (bool VAR8) {
VAR20 [msg.sender][VAR10] = VAR7;
FUN6 (msg.sender, VAR10, VAR7);
return true;
}
function FUN5 (address VAR4, address VAR10)
public view returns (uint256 VAR11) {
return VAR20 [VAR4][VAR10];
}
mapping (address => uint256) internal VAR17;
mapping (address => mapping (address => uint256)) internal VAR20;
}
contract DecenturionToken is VAR21 {
uint256 VAR22;
function FUN11 (uint256 VAR23) public {
VAR22 = VAR23;
VAR17 [msg.sender] = VAR23;
}
function FUN1 () public view returns (uint256 VAR3) {
return VAR22;
}
function FUN12 () public pure returns (string VAR24) {
return "";
}
function FUN13 () public pure returns (string VAR24) {
return "";
}
function FUN14 () public pure returns (uint8 VAR24) {
return 8;
}
function FUN4 (address VAR10, uint256 VAR25, uint256 VAR26)
public returns (bool VAR8) {
if (FUN5 (msg.sender, VAR10) == VAR25)
return FUN4 (VAR10, VAR26);
else return false;
}
function FUN15 (uint256 VAR7) public returns (bool VAR8) {
if (VAR7 > VAR17 [msg.sender]) return false;
else if (VAR7 > 0) {
VAR17 [msg.sender] = FUN8 (VAR17 [msg.sender], VAR7);
VAR22 = FUN8 (VAR22, VAR7);
Transfer (msg.sender, address (0), VAR7);
return true;
} else return true;
}
}
0
---------------------------------
288 0x001a589dda0d6be37632925eaf1256986b2c6ad0.sol
contract VAR1{
function FUN1() constant returns(bool);
}
contract VAR2 {
mapping (address => uint) VAR3;
address public VAR4 = 0x26588a9301b0428d95e6fc3a5024fce8bec12d51;
address constant VAR5 = 0x2bd2326c993dfaef84f696526064ff22eba5b362;
event FUN2(address sender, bytes32 VAR6, uint VAR7, string VAR8, string VAR9, uint VAR10, byte VAR11, uint VAR12);
event FUN3(address sender, bytes32 VAR6, uint VAR7, string VAR8, string VAR13, string VAR14, uint VAR10, byte VAR11, uint VAR12);
address VAR15;
modifier VAR16 {
if ((msg.sender != VAR15)&&(msg.sender != VAR4)) throw;
VAR17
}
function FUN4(string VAR18, uint VAR19) {
FUN4(VAR18, 0x00, VAR19);
}
function FUN4(string VAR18, byte VAR11, uint VAR19) VAR16 {
bytes32 VAR20 = FUN5(VAR18, VAR11);
VAR21[VAR21.VAR22++] = VAR20;
VAR23[VAR20] = VAR19;
}
mapping (bytes32 => bool) VAR24;
bytes32 VAR25;
function FUN6(string VAR26) VAR16 {
VAR24[FUN5(VAR26)] = true;
}
function FUN7(string VAR26) VAR16 {
VAR24[FUN5(VAR26)] = false;
}
function FUN8(uint[] VAR27, address[] VAR28) VAR16 {
for (uint VAR29=0; VAR29<VAR28.VAR22; VAR29++) VAR30[VAR28[VAR29]] = FUN9(VAR27[VAR29]);
}
function FUN10(uint[] VAR31, address[] VAR28) VAR16 {
for (uint VAR29=0; VAR29<VAR28.VAR22; VAR29++) VAR32[VAR28[VAR29]] = VAR31[VAR29];
}
uint VAR33 = 20000000000;
function FUN11(uint VAR34) VAR16 {
VAR33 = VAR34;
}
function FUN12(uint VAR35) VAR16 {
VAR36 = VAR35;
for (uint VAR29=0; VAR29<VAR21.VAR22; VAR29++) VAR37[VAR21[VAR29]] = VAR35*VAR23[VAR21[VAR29]];
}
function FUN12(uint VAR35, bytes VAR38) VAR16 {
VAR36 = VAR35;
for (uint VAR29=0; VAR29<VAR21.VAR22; VAR29++) VAR37[VAR21[VAR29]] = VAR35*VAR23[VAR21[VAR29]];
}
function FUN13(address VAR28) VAR16 {
VAR28.FUN14(this.VAR39);
}
function() VAR16 {}
function FUN15() {
VAR15 = msg.sender;
}
modifier FUN16(string VAR8, uint VAR10) {
uint VAR37 = FUN17(VAR8, VAR10, msg.sender);
if (msg.value >= VAR37){
uint VAR40 = msg.value - VAR37;
if (VAR40 > 0) msg.sender.FUN14(VAR40);
VAR17
} else throw;
}
mapping (address => VAR41) VAR30;
mapping (address => uint) VAR32;
uint public VAR36;
mapping (bytes32 => uint) VAR37;
mapping (bytes32 => uint) VAR23;
bytes32[] VAR21;
function FUN18(string VAR42) {
VAR25 = FUN5(VAR42);
}
function FUN19(byte VAR27) {
VAR30[msg.sender] = VAR27;
}
function FUN20(uint VAR31) {
VAR32[msg.sender] = VAR31;
}
function FUN17(string VAR43) public returns (uint VAR44) {
return FUN17(VAR43, msg.sender);
}
function FUN17(string VAR43, uint VAR45) public returns (uint VAR44) {
return FUN17(VAR43, VAR45, msg.sender);
}
function FUN17(string VAR43, address VAR28) private returns (uint VAR44) {
return FUN17(VAR43, 200000, VAR28);
}
function FUN17(string VAR43, uint VAR45, address VAR28) private returns (uint VAR44) {
if ((VAR45 <= 200000)&&(VAR3[VAR28] == 0)&&(VAR46.VAR47 != VAR4)) return 0;
if ((VAR25 != 0)&&(VAR24[VAR25] == true)) return 0;
VAR44 = VAR37[FUN5(VAR43, VAR30[VAR28])];
uint VAR48 = VAR32[VAR28];
if (VAR48 == 0) VAR48 = VAR33;
VAR44 += VAR45*VAR48;
return VAR44;
}
function FUN21(string VAR43, string VAR49) returns (bytes32 VAR50) {
return FUN22(0, VAR43, VAR49, 200000);
}
function FUN22(string VAR43, string VAR49) returns (bytes32 VAR50) {
return FUN22(0, VAR43, VAR49, 200000);
}
function FUN23(string VAR43, string VAR51, string VAR52) returns (bytes32 VAR50) {
return FUN23(0, VAR43, VAR51, VAR52, 200000);
}
function FUN21(uint VAR53, string VAR43, string VAR49) returns (bytes32 VAR50) {
return FUN22(VAR53, VAR43, VAR49, 200000);
}
function FUN22(uint VAR53, string VAR43, string VAR49) returns (bytes32 VAR50) {
return FUN22(VAR53, VAR43, VAR49, 200000);
}
function FUN23(uint VAR53, string VAR43, string VAR51, string VAR52) returns (bytes32 VAR50) {
return FUN23(VAR53, VAR43, VAR51, VAR52, 200000);
}
function FUN21(uint VAR53, string VAR43, string VAR49, uint VAR45) returns (bytes32 VAR50) {
return FUN22(VAR53, VAR43, VAR49, VAR45);
}
function FUN22(uint VAR53, string VAR43, string VAR49, uint VAR45) FUN16(VAR43, VAR45) returns (bytes32 VAR50) {
if ((VAR53 > VAR54+3600*24*60)||(VAR45 > VAR55.VAR10)) throw;
bool VAR56 = FUN24(VAR5).FUN1();
VAR50 = FUN5(VAR56, this, msg.sender, VAR3[msg.sender]);
VAR3[msg.sender]++;
FUN2(msg.sender, VAR50, VAR53, VAR43, VAR49, VAR45, VAR30[msg.sender], VAR32[msg.sender]);
return VAR50;
}
function FUN23(uint VAR53, string VAR43, string VAR51, string VAR52, uint VAR45) FUN16(VAR43, VAR45) returns (bytes32 VAR50) {
if ((VAR53 > VAR54+3600*24*60)||(VAR45 > VAR55.VAR10)) throw;
bool VAR56 = FUN24(VAR5).FUN1();
VAR50 = FUN5(VAR56, this, msg.sender, VAR3[msg.sender]);
VAR3[msg.sender]++;
FUN3(msg.sender, VAR50, VAR53, VAR43, VAR51, VAR52, VAR45, VAR30[msg.sender], VAR32[msg.sender]);
return VAR50;
}
function FUN25(uint VAR53, string VAR43, string VAR49, uint VAR45) returns (bytes32 VAR50) {
return FUN21(VAR53, VAR43, VAR49, VAR45);
}
function FUN26(uint VAR53, string VAR43, string VAR49, uint VAR45) returns (bytes32 VAR50) {
return FUN22(VAR53, VAR43, VAR49, VAR45);
}
function FUN27(uint VAR53, string VAR43, string VAR51, string VAR52, uint VAR45) returns (bytes32 VAR50) {
return FUN23(VAR53, VAR43, VAR51, VAR52, VAR45);
}
}
0
---------------------------------
289 0x00214120d3469a74ca586bc9557c0ff8fb09b157.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) constant public returns (uint256);
function transfer(address VAR8, uint256 VAR9) public returns (bool);
}
contract VAR10 {
uint256 public VAR11;
function FUN5(address VAR12) public constant returns (uint256);
function transfer(address VAR13, uint256 value) public returns (bool);
event Transfer(address indexed VAR14, address indexed VAR13, uint256 value);
}
contract ERC20 is VAR10 {
function FUN6(address VAR15, address VAR16) public constant returns (uint256);
function FUN7(address VAR14, address VAR13, uint256 value) public returns (bool);
function FUN8(address VAR16, uint256 value) public returns (bool);
event FUN9(address indexed VAR15, address indexed VAR16, uint256 value);
}
contract TrueToken is VAR17 {
using SafeMath for uint256;
address VAR15 = msg.sender;
mapping (address => uint256) VAR18;
mapping (address => mapping (address => uint256)) VAR19;
string public constant VAR20 = "";
string public constant VAR21 = "";
uint public constant VAR22 = 18;
uint256 public VAR11 = 20000000000e18;
uint256 public VAR23 = 10000000000e18;
uint256 public constant VAR24 = 1 VAR25 / 1000;
uint256 public VAR26 = 20000000e18;
event Transfer(address indexed VAR27, address indexed VAR8, uint256 VAR9);
event FUN9(address indexed VAR7, address indexed VAR28, uint256 VAR9);
event FUN10(address indexed VAR13, uint256 VAR29);
event FUN11();
event FUN12(address indexed VAR7, uint VAR30, uint VAR31);
event FUN13(uint VAR32);
event FUN14(address indexed VAR33, uint256 value);
bool public VAR34 = false;
modifier FUN15() {
require(!VAR34);
VAR35;
}
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR35;
}
function FUN16 () public {
VAR15 = msg.sender;
FUN17(VAR15, VAR23);
}
function FUN18(address VAR36) onlyOwner public {
if (VAR36 != address(0)) {
VAR15 = VAR36;
}
}
function FUN19() onlyOwner canDistr public returns (bool) {
VAR34 = true;
emit FUN11();
return true;
}
function FUN17(address VAR8, uint256 VAR30) canDistr private returns (bool) {
VAR23 = VAR23.FUN4(VAR30);
VAR18[VAR8] = VAR18[VAR8].FUN4(VAR30);
emit FUN10(VAR8, VAR30);
emit Transfer(address(0), VAR8, VAR30);
return true;
}
function FUN20(address VAR37, uint VAR30) internal {
require( VAR30 > 0 );
require( VAR23 < VAR11 );
VAR18[VAR37] = VAR18[VAR37].FUN4(VAR30);
VAR23 = VAR23.FUN4(VAR30);
if (VAR23 >= VAR11) {
VAR34 = true;
}
emit FUN12(VAR37, VAR30, VAR18[VAR37]);
emit Transfer(address(0), VAR37, VAR30);
}
function FUN21(address VAR37, uint VAR30) external {
FUN20(VAR37, VAR30);
}
function FUN22(address[] VAR38, uint VAR30) external {
for (uint VAR39 = 0; VAR39 < VAR38.VAR40; VAR39++) FUN20(VAR38[VAR39], VAR30);
}
function FUN23(uint VAR32) public onlyOwner {
VAR26 = VAR32;
emit FUN13(VAR32);
}
function () external payable {
FUN24();
}
function FUN24() payable canDistr  public {
uint256 VAR41 = 0;
require( msg.value >= VAR24 );
require( msg.value > 0 );
VAR41 = VAR26.FUN1(msg.value) / 1 VAR25;
address VAR42 = msg.sender;
if (VAR41 > 0) {
FUN17(VAR42, VAR41);
}
if (VAR23 >= VAR11) {
VAR34 = true;
}
}
function FUN5(address VAR7) constant public returns (uint256) {
return VAR18[VAR7];
}
modifier FUN25(uint VAR43) {
assert(msg.VAR44.VAR40 >= VAR43 + 4);
VAR35;
}
function transfer(address VAR8, uint256 VAR30) FUN25(2 * 32) public returns (bool VAR45) {
require(VAR8 != address(0));
require(VAR30 <= VAR18[msg.sender]);
VAR18[msg.sender] = VAR18[msg.sender].FUN3(VAR30);
VAR18[VAR8] = VAR18[VAR8].FUN4(VAR30);
emit Transfer(msg.sender, VAR8, VAR30);
return true;
}
function FUN7(address VAR27, address VAR8, uint256 VAR30) FUN25(3 * 32) public returns (bool VAR45) {
require(VAR8 != address(0));
require(VAR30 <= VAR18[VAR27]);
require(VAR30 <= VAR19[VAR27][msg.sender]);
VAR18[VAR27] = VAR18[VAR27].FUN3(VAR30);
VAR19[VAR27][msg.sender] = VAR19[VAR27][msg.sender].FUN3(VAR30);
VAR18[VAR8] = VAR18[VAR8].FUN4(VAR30);
emit Transfer(VAR27, VAR8, VAR30);
return true;
}
function FUN8(address VAR28, uint256 VAR9) public returns (bool VAR45) {
if (VAR9 != 0 && VAR19[msg.sender][VAR28] != 0) { return false; }
VAR19[msg.sender][VAR28] = VAR9;
emit FUN9(msg.sender, VAR28, VAR9);
return true;
}
function FUN6(address VAR7, address VAR28) constant public returns (uint256) {
return VAR19[VAR7][VAR28];
}
function FUN26(address VAR46, address VAR12) constant public returns (uint){
ForeignToken VAR47 = FUN27(VAR46);
uint VAR48 = VAR47.FUN5(VAR12);
return VAR48;
}
function FUN28() onlyOwner public {
address VAR49 = this;
uint256 VAR50 = VAR49.VAR51;
VAR15.transfer(VAR50);
}
function FUN29(uint256 VAR9) onlyOwner public {
require(VAR9 <= VAR18[msg.sender]);
address VAR33 = msg.sender;
VAR18[VAR33] = VAR18[VAR33].FUN3(VAR9);
VAR11 = VAR11.FUN3(VAR9);
VAR23 = VAR23.FUN3(VAR9);
emit FUN14(VAR33, VAR9);
}
function FUN30(address VAR52) onlyOwner public returns (bool) {
ForeignToken VAR53 = FUN27(VAR52);
uint256 VAR29 = VAR53.FUN5(address(this));
return VAR53.transfer(VAR15, VAR29);
}
}
0
---------------------------------
290 0x00223f71b749b8754963c41cba62cb61ef106e9c.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
uint VAR3;
function FUN1(uint VAR4) public {
VAR3 = VAR4;
}
function FUN2() public view returns (uint) {
return VAR3;
}
}
0
---------------------------------
291 0x00224d9084fd7cdb4a5ce7740cb1ca0dca6be7a6.sol
pragma VAR1 ^0.4.23;
interface VAR2 {
function() payable external;
function FUN1(address VAR3) payable external returns(uint256);
function FUN2(uint256 VAR4) external;
function FUN3() external;
function FUN4() external;
function FUN5() external;
function FUN6(address VAR3) external view returns(uint256);
function FUN7(address VAR3) external view returns(uint256);
function transfer(address VAR5, uint256 VAR4) external returns(bool);
function FUN8() external view returns(uint256);
function FUN9(bool VAR6) external view returns(uint256);
}
contract VAR7 {
address public VAR8;
bool public VAR9;
constructor(address VAR10, address VAR11) public payable {
VAR8 = VAR10;
if (msg.value > 0) {
FUN10(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).VAR12.value(msg.value)(VAR11);
}
}
function() public payable {
VAR13 {
FUN11(0, 0, VAR14)
let VAR15 := FUN12(VAR16, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR14, 0, 0)
FUN13(0, 0, VAR17)
switch VAR15
case 0 { revert(0, VAR17) }
default { return(0, VAR17) }
}
}
}
0
---------------------------------
292 0x002842529757eab873cce9c251087e1b993f9200.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7, address VAR8, uint256 VAR9) public returns (bool);
}
contract VAR10 {
using SafeMath for uint256;
StupidToken public VAR11;
uint256 constant public VAR12 = 10000;
uint256 constant public VAR13 = 20000000 * (10 ** 18);
uint256 public VAR14;
uint256 public VAR15;
uint256 public VAR16;
uint256 public VAR17;
bool public VAR18 = true;
address public VAR19;
address public VAR20;
mapping(address => uint256) VAR21;
event FUN6(address indexed VAR22, address indexed VAR23, uint256 value, uint256 VAR24);
function FUN7(uint256 VAR25, uint256 VAR26, address VAR27, address VAR28, address VAR29) public {
require(VAR25 < VAR26);
require(VAR27 != address(0));
require(VAR28 != address(0));
require(VAR29 != address(0));
VAR14 = VAR25;
VAR15 = VAR26;
VAR19 = VAR27;
VAR20 = VAR29;
VAR11 = FUN8(VAR28);
}
function () external payable {
FUN9(msg.sender);
}
function FUN9(address VAR30) public payable {
require(VAR30 != address(0));
require(VAR31 >= VAR14 && VAR31 <= VAR15);
require(VAR18);
require(msg.value != 0);
uint256 VAR32 = msg.value;
uint256 VAR33 = VAR32.FUN1(VAR12);
require(VAR17.FUN4(VAR33) <= VAR13);
VAR16 = VAR16.FUN4(VAR32);
VAR17 = VAR17.FUN4(VAR33);
VAR21[VAR30] = VAR21[VAR30].FUN4(VAR32);
assert(VAR11.FUN5(VAR20, VAR30, VAR33));
FUN6(msg.sender, VAR30, VAR32, VAR33);
VAR19.transfer(msg.value);
}
function FUN10(bool VAR34) public {
require(msg.sender == VAR20);
VAR18 = VAR34;
}
function FUN11(address VAR35) external constant returns (uint256 VAR36) {
return VAR21[VAR35];
}
}
0
---------------------------------
293 0x002f06abe6995fd0ea4be011c53bfc989fa53ce0.sol
pragma solidity 0.4.17;
contract VAR1 {
address public VAR2;
function FUN1() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
}
contract TripCash is VAR1 {
uint256 public VAR4 = 5000000000 * 1 VAR5;
string public constant VAR6 = "";
string public constant VAR7 = "";
uint8 public constant VAR8 = 18;
mapping (address => uint256) public VAR9;
mapping (address => mapping(address => uint256)) public VAR10;
mapping (address => bool) public VAR11;
uint256 public VAR12 = 1523840400;
uint256 public VAR13 = 1528675199;
uint256 public VAR14 = 1529884800;
uint256 public VAR15 = 1532303999;
address public constant VAR16 = 0x9dA14C46f0182D850B12866AB0f3e397Fbd4FaC4;
address public constant VAR17 = 0xe82F49A648FADaafd468E65a13C050434a4C4a6f ;
address public constant VAR18 = 0x16Eb7B7E232590787F1Fe3742acB1a1d0e43AF2A;
address public constant VAR19 = 0x949844acF5C722707d02A037D074cabe7474e0CB;
address public constant VAR20 = 0xAc77c90b37AFd80D2227f74971e7c3ad3e29D1fb;
address public constant VAR21 = 0x265B8e89DAbA5Bdc330E55cA826a9f2e0EFf0870;
uint256 public constant VAR22 = 10;
uint256 public constant VAR23 = 10;
uint256 public constant VAR24 = 10;
bool public VAR25 = false;
bool public VAR26 = false;
function FUN2() public {
VAR9[VAR2] = VAR4;
}
modifier FUN3(address VAR27) {
if (VAR27 != VAR2) {
require(VAR25);
}
if (VAR27 == VAR17) {
require(VAR28 >= VAR15 + 15552000);
}
if (VAR27 == VAR18) {
require(VAR28 >= VAR15 + 31536000);
}
VAR3;
}
modifier FUN4(){
require(!VAR25);
VAR3;
}
modifier FUN5() {
require((VAR28 > VAR14 && VAR28 < VAR15)||(VAR28 > VAR12 && VAR28 < VAR13));
VAR3;
}
modifier FUN6() {
require(VAR26);
VAR3;
}
function FUN7(address VAR29) onlyOwner public {
require(VAR29 != address(0));
uint256 VAR30 = VAR9[VAR2];
transfer(VAR29, VAR30);
VAR2 = VAR29;
FUN8(VAR2, VAR29);
}
function FUN9(address VAR31, uint256 VAR32) onlyOwner FUN5() notAllowed public returns (bool) {
require(VAR32 != 0);
transfer(VAR31, VAR32);
VAR11[VAR31] = true;
uint256 VAR33 = 0;
uint256 VAR34 = 0;
uint256 VAR35 = 0;
VAR33 = VAR32 * VAR24 / 60;
VAR34 = VAR32 * VAR22 / 60;
VAR35 = VAR32 * VAR23 / 60;
transfer(VAR16, VAR34);
transfer(VAR19, VAR33);
transfer(VAR17, VAR35);
transfer(VAR18, VAR35);
return true;
}
function FUN10(address VAR36) public view returns (uint256 VAR37) {
return VAR9[VAR36];
}
function transfer(address VAR31, uint256 VAR32) FUN3(msg.sender) public returns (bool){
require(VAR31 != address(0));
require(VAR9[msg.sender] >= VAR32);
VAR9[msg.sender] = VAR9[msg.sender] - VAR32;
VAR9[VAR31] = VAR9[VAR31] + VAR32;
if (VAR11[msg.sender] == true) {
VAR11[msg.sender] = false;
}
Transfer(msg.sender, VAR31, VAR32);
return true;
}
function FUN11(address VAR27, address VAR31, uint256 VAR32) FUN3(VAR27) public returns (bool) {
require(VAR31 != address(0));
require(VAR32 <= VAR9[VAR27]);
require(VAR32 <= VAR10[VAR27][msg.sender]);
VAR9[VAR27] = VAR9[VAR27] - VAR32;
VAR9[VAR31] = VAR9[VAR31] + VAR32;
VAR10[VAR27][msg.sender] = VAR10[VAR27][msg.sender] - VAR32;
Transfer(VAR27, VAR31, VAR32);
return true;
}
function FUN12(address VAR38, uint256 VAR32) public returns (bool) {
VAR10[msg.sender][VAR38] = VAR32;
FUN13(msg.sender, VAR38, VAR32);
return true;
}
function FUN14(address VAR38, uint VAR39) public returns (bool VAR40) {
VAR10[msg.sender][VAR38] = VAR10[msg.sender][VAR38] + VAR39;
FUN13(msg.sender, VAR38, VAR10[msg.sender][VAR38]);
return true;
}
function FUN15(address VAR38, uint VAR41) public returns (bool VAR40) {
uint VAR42 = VAR10[msg.sender][VAR38];
if (VAR41 > VAR42) {
VAR10[msg.sender][VAR38] = 0;
} else {
VAR10[msg.sender][VAR38] = VAR42 - VAR41;
}
FUN13(msg.sender, VAR38, VAR10[msg.sender][VAR38]);
return true;
}
function FUN16(address VAR36, address VAR38) public view returns (uint256 VAR43) {
return VAR10[VAR36][VAR38];
}
function FUN17(address VAR44) public onlyOwner returns(uint){
if(VAR11[VAR44]==true){
if(VAR28 >= VAR15 + 63072000){
uint VAR45 = VAR9[VAR44]*25 / 100;
if (VAR9[VAR19] >= VAR45) {
VAR9[VAR19] = VAR9[VAR19] - VAR45;
VAR9[VAR44] = VAR9[VAR44] + VAR45;
assert(VAR9[VAR44] >= VAR45);
Transfer(VAR19, VAR44, VAR45);
VAR11[VAR44]=false;
return VAR45;
}
} else if (VAR28 >= VAR15 + 31536000) {
uint VAR46 = VAR9[VAR44]*15 / 100;
if (VAR9[VAR19] >= VAR46) {
VAR9[VAR19] = VAR9[VAR19] - VAR46;
VAR9[VAR44] = VAR9[VAR44] + VAR46;
assert(VAR9[VAR44] >= VAR46);
Transfer(VAR19, VAR44, VAR46);
VAR11[VAR44]=false;
return VAR46;
}
}
}
}
function FUN18(uint256 VAR32) onlyOwner public returns (bool){
require(VAR32 > 0);
require(VAR32 <= VAR9[msg.sender]);
address VAR47 = msg.sender;
VAR9[VAR47] = VAR9[VAR47] - VAR32;
VAR4 = VAR4 - VAR32;
FUN19(VAR47, VAR32);
return true;
}
function FUN20() public onlyOwner {
require(VAR28 >= VAR15);
VAR26 = true;
}
function FUN21() public onlyOwner returns (bool) {
uint VAR48 = VAR9[msg.sender]/2;
transfer(VAR20, VAR48);
transfer(VAR21, VAR9[msg.sender]);
VAR25 = true;
return true;
}
function FUN22()  canRefundToken public returns (bool){
uint256 VAR32 = VAR9[msg.sender];
VAR9[msg.sender] = 0;
VAR4 = VAR4 - VAR32;
FUN23(msg.sender, VAR32);
return true;
}
event FUN8(address indexed VAR49, address indexed VAR50);
event FUN13(address indexed VAR2, address indexed VAR51, uint256 value);
event Transfer(address indexed VAR52, address indexed VAR53, uint256 value);
event FUN19(address indexed VAR47, uint256 value);
event FUN23(address indexed VAR54, uint256 value);
}
0
---------------------------------
294 0x0035743c08768ad6558b49d751e0215762057754.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29030400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x49664D752220C05139dCB85D4038547146b4D597;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
295 0x0036192587fd788b75829fbf79be7f06e4f23b21.sol
pragma solidity 0.5.2;
contract VAR1 {
function () external payable {
FUN1();
}
function FUN2() internal view returns (address);
function FUN3(address VAR2) internal {
VAR3 {
FUN4(0, 0, VAR4)
let VAR5 := FUN5(VAR6, VAR2, 0, VAR4, 0, 0)
FUN6(0, 0, VAR7)
switch VAR5
case 0 { revert(0, VAR7) }
default { return(0, VAR7) }
}
}
function FUN7() internal {
}
function FUN1() internal {
FUN7();
FUN3(FUN2());
}
}
library VAR8 {
function FUN8(address VAR9) internal view returns (bool) {
uint256 VAR10;
VAR3 { VAR10 := FUN9(VAR9) }
return VAR10 > 0;
}
}
contract UpgradeabilityProxy is VAR1 {
event FUN10(address indexed VAR2);
bytes32 private constant VAR11 = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
constructor(address VAR12, bytes memory VAR13) public payable {
assert(VAR11 == FUN11(""));
FUN12(VAR12);
if (VAR13.VAR14 > 0) {
bool VAR15;
(VAR15,) = VAR12.FUN5(VAR13);
require(VAR15);
}
}
function FUN2() internal view returns (address VAR16) {
bytes32 VAR17 = VAR11;
VAR3 {
VAR16 := FUN13(VAR17)
}
}
function FUN14(address VAR18) internal {
FUN12(VAR18);
emit FUN10(VAR18);
}
function FUN12(address VAR18) private {
require(VAR8.FUN8(VAR18), "");
bytes32 VAR17 = VAR11;
VAR3 {
FUN15(VAR17, VAR18)
}
}
}
contract AdminUpgradeabilityProxy is VAR19 {
event FUN16(address VAR20, address VAR21);
bytes32 private constant VAR22 = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;
modifier FUN17() {
if (msg.sender == FUN18()) {
VAR23;
} else {
FUN1();
}
}
constructor(address VAR12, bytes memory VAR13) FUN19(VAR12, VAR13) public payable {
assert(VAR22 == FUN11(""));
FUN20(msg.sender);
}
function FUN21() external ifAdmin returns (address) {
return FUN18();
}
function FUN22() external ifAdmin returns (address) {
return FUN2();
}
function FUN23(address VAR21) external VAR24 {
require(VAR21 != address(0), "");
emit FUN16(FUN18(), VAR21);
FUN20(VAR21);
}
function FUN24(address VAR18) external VAR24 {
FUN14(VAR18);
}
function FUN25(address VAR18, bytes calldata VAR25) external payable VAR24 {
FUN14(VAR18);
bool VAR15;
(VAR15,) = VAR18.FUN5(VAR25);
require(VAR15);
}
function FUN18() internal view returns (address VAR26) {
bytes32 VAR17 = VAR22;
VAR3 {
VAR26 := FUN13(VAR17)
}
}
function FUN20(address VAR21) internal {
bytes32 VAR17 = VAR22;
VAR3 {
FUN15(VAR17, VAR21)
}
}
function FUN7() internal {
require(msg.sender != FUN18(), "");
super.FUN7();
}
}
contract AdminableProxy is VAR27 {
constructor(address VAR12, bytes memory VAR13)
FUN26(VAR12, VAR13) public payable {
}
function FUN27(bytes calldata VAR25) external ifAdmin returns (bool) {
bool VAR15;
(VAR15, ) = FUN2().FUN5(VAR25);
return VAR15;
}
}
contract VAR28  {
}
contract ExitHandlerProxy is VAR29 {
constructor(ExitHandler VAR12, bytes memory VAR13)
FUN28(address(VAR12), VAR13) public payable {
}
}
0
---------------------------------
296 0x00391d08b3e68e476a774ada379258264eb74485.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1(address VAR2) public constant returns (bool);
}
contract VAR3 {
address public VAR4;
event FUN2(address indexed VAR5, address indexed VAR6);
function FUN3() {
VAR4 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR4);
VAR7;
}
function FUN4(address VAR6) onlyOwner public {
require(VAR6 != address(0));
FUN2(VAR4, VAR6);
VAR4 = VAR6;
}
}
library VAR8 {
function FUN5(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
uint256 VAR11 = VAR9 * VAR10;
assert(VAR9 == 0 || VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN6(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN7(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
assert(VAR11 >= VAR9);
return VAR11;
}
}
contract VAR12 {
uint256 public VAR13;
function FUN9(address VAR14) public constant returns (uint256);
function transfer(address VAR15, uint256 value) public returns (bool);
event Transfer(address indexed VAR16, address indexed VAR15, uint256 value);
}
contract BasicToken is VAR12 {
using SafeMath for uint256;
mapping(address => uint256) VAR17;
function transfer(address VAR18, uint256 VAR19) public returns (bool) {
require(VAR18 != address(0));
VAR17[msg.sender] = VAR17[msg.sender].FUN7(VAR19);
VAR17[VAR18] = VAR17[VAR18].FUN8(VAR19);
Transfer(msg.sender, VAR18, VAR19);
return true;
}
function FUN9(address VAR20) public constant returns (uint256 VAR21) {
return VAR17[VAR20];
}
}
contract ERC20 is VAR12 {
function FUN10(address VAR4, address VAR22) public constant returns (uint256);
function FUN11(address VAR16, address VAR15, uint256 value) public returns (bool);
function FUN12(address VAR22, uint256 value) public returns (bool);
event FUN13(address indexed VAR4, address indexed VAR22, uint256 value);
}
contract StandardToken is VAR23, VAR24 {
mapping (address => mapping (address => uint256)) VAR25;
function FUN11(address VAR26, address VAR18, uint256 VAR19) public returns (bool) {
require(VAR18 != address(0));
uint256 VAR27 = VAR25[VAR26][msg.sender];
VAR17[VAR26] = VAR17[VAR26].FUN7(VAR19);
VAR17[VAR18] = VAR17[VAR18].FUN8(VAR19);
VAR25[VAR26][msg.sender] = VAR27.FUN7(VAR19);
Transfer(VAR26, VAR18, VAR19);
return true;
}
function FUN12(address VAR28, uint256 VAR19) public returns (bool) {
VAR25[msg.sender][VAR28] = VAR19;
FUN13(msg.sender, VAR28, VAR19);
return true;
}
function FUN10(address VAR20, address VAR28) public constant returns (uint256 VAR29) {
return VAR25[VAR20][VAR28];
}
function FUN14 (address VAR28, uint VAR30)
returns (bool VAR31) {
VAR25[msg.sender][VAR28] = VAR25[msg.sender][VAR28].FUN8(VAR30);
FUN13(msg.sender, VAR28, VAR25[msg.sender][VAR28]);
return true;
}
function FUN15 (address VAR28, uint VAR32)
returns (bool VAR31) {
uint VAR33 = VAR25[msg.sender][VAR28];
if (VAR32 > VAR33) {
VAR25[msg.sender][VAR28] = 0;
} else {
VAR25[msg.sender][VAR28] = VAR33.FUN7(VAR32);
}
FUN13(msg.sender, VAR28, VAR25[msg.sender][VAR28]);
return true;
}
}
contract MintableToken is VAR34, VAR3 {
event FUN16(address indexed VAR15, uint256 VAR35);
event FUN17();
bool public VAR36 = false;
modifier FUN18() {
require(!VAR36);
VAR7;
}
function FUN19(address VAR18, uint256 VAR37) onlyOwner canMint public returns (bool) {
VAR13 = VAR13.FUN8(VAR37);
VAR17[VAR18] = VAR17[VAR18].FUN8(VAR37);
FUN16(VAR18, VAR37);
Transfer(0x0, VAR18, VAR37);
return true;
}
function FUN20() onlyOwner public returns (bool) {
VAR36 = true;
FUN17();
return true;
}
}
contract Pausable is VAR3 {
event FUN21();
event FUN22();
bool public VAR38 = false;
modifier FUN23() {
require(!VAR38);
VAR7;
}
modifier FUN24() {
require(VAR38);
VAR7;
}
function FUN25() onlyOwner whenNotPaused public {
VAR38 = true;
FUN21();
}
function FUN26() onlyOwner whenPaused public {
VAR38 = false;
FUN22();
}
}
contract PausableToken is VAR34, VAR39 {
function transfer(address VAR18, uint256 VAR19) public whenNotPaused returns (bool) {
return super.transfer(VAR18, VAR19);
}
function FUN11(address VAR26, address VAR18, uint256 VAR19) public whenNotPaused returns (bool) {
return super.FUN11(VAR26, VAR18, VAR19);
}
function FUN12(address VAR28, uint256 VAR19) public whenNotPaused returns (bool) {
return super.FUN12(VAR28, VAR19);
}
function FUN14(address VAR28, uint VAR30) public whenNotPaused returns (bool VAR31) {
return super.FUN14(VAR28, VAR30);
}
function FUN15(address VAR28, uint VAR32) public whenNotPaused returns (bool VAR31) {
return super.FUN15(VAR28, VAR32);
}
}
pragma solidity 0.4.24;
contract DipToken is VAR40, VAR41 {
string public constant VAR42 = "";
string public constant VAR43 = "";
uint256 public constant VAR44 = 18;
uint256 public constant VAR45 = 10**9 * 10**18;
DipTgeInterface public VAR46;
constructor() public {
VAR46 = FUN27(VAR4);
}
modifier FUN28(address VAR2) {
require(VAR46.FUN1(VAR2) == false);
VAR7;
}
function FUN19(address VAR18, uint256 VAR37) public returns (bool) {
if (VAR13.FUN8(VAR37) > VAR45) {
return false;
}
return super.FUN19(VAR18, VAR37);
}
function FUN29(ERC20Basic VAR47, address VAR18) onlyOwner public {
VAR47.transfer(VAR18, VAR47.FUN9(this));
}
function FUN11(address VAR26, address VAR18, uint256 VAR19) FUN28(VAR26) public returns (bool) {
return super.FUN11(VAR26, VAR18, VAR19);
}
function transfer(address VAR15, uint256 value) FUN28(msg.sender) public returns (bool) {
return super.transfer(VAR15, value);
}
}
contract VAR48 {
using SafeMath for uint256;
MintableToken public VAR49;
uint256 public VAR50;
uint256 public VAR51;
address public VAR52;
uint256 public VAR53;
uint256 public VAR54;
event FUN30(address indexed VAR55, address indexed VAR56, uint256 value, uint256 VAR35);
function FUN31(uint256 VAR57, uint256 VAR58, uint256 VAR59, address VAR60) {
require(VAR57 >= VAR61);
require(VAR58 >= VAR57);
require(VAR59 > 0);
require(VAR60 != 0x0);
VAR49 = FUN32();
VAR50 = VAR57;
VAR51 = VAR58;
VAR53 = VAR59;
VAR52 = VAR60;
}
function FUN32() internal returns (VAR41) {
return VAR62 FUN33();
}
function () payable {
FUN34(msg.sender);
}
function FUN34(address VAR56) public payable {
require(VAR56 != 0x0);
require(FUN35());
uint256 VAR63 = msg.value;
uint256 VAR64 = VAR63.FUN5(VAR53);
VAR54 = VAR54.FUN8(VAR63);
VAR49.FUN19(VAR56, VAR64);
FUN30(msg.sender, VAR56, VAR63, VAR64);
FUN36();
}
function FUN36() internal {
VAR52.transfer(msg.value);
}
function FUN35() internal constant returns (bool) {
bool VAR65 = VAR61 >= VAR50 && VAR61 <= VAR51;
bool VAR66 = msg.value != 0;
return VAR65 && VAR66;
}
function FUN37() public constant returns (bool) {
return VAR61 > VAR51;
}
}
pragma solidity 0.4.24;
contract DipWhitelistedCrowdsale is VAR3 {
using SafeMath for uint256;
struct VAR67 {
uint256 VAR68;
uint256 VAR69;
uint256 VAR70;
bool VAR71;
uint256 VAR72;
uint256 VAR73;
}
mapping (address => VAR67) public VAR74;
event FUN38(address indexed VAR2, uint256 VAR27, bool VAR75, uint256 VAR76, uint256 VAR77);
function FUN39 (
address[] VAR78,
uint256[] VAR79,
bool[] VAR75,
uint256[] VAR76,
uint256[] VAR77
) onlyOwner public {
require(
VAR78.VAR80 == VAR79.VAR80 &&
VAR78.VAR80 == VAR75.VAR80 &&
VAR78.VAR80 == VAR76.VAR80 &&
VAR78.VAR80 == VAR77.VAR80
);
for (uint256 VAR81 = 0; VAR81 < VAR78.VAR80; VAR81 = VAR81.FUN8(1)) {
require(VAR76[VAR81] == 0 || VAR76[VAR81] == 4 || VAR76[VAR81] == 10);
require(VAR77[VAR81] <= 2);
address VAR82 = VAR78[VAR81];
VAR74[VAR82].VAR68 = VAR79[VAR81];
VAR74[VAR82].VAR71 = VAR75[VAR81];
VAR74[VAR82].VAR72 = VAR76[VAR81];
VAR74[VAR82].VAR73 = VAR77[VAR81];
emit FUN38(
VAR78[VAR81],
VAR79[VAR81],
VAR75[VAR81],
VAR76[VAR81],
VAR77[VAR81]
);
}
}
}
contract FinalizableCrowdsale is VAR48, VAR3 {
using SafeMath for uint256;
bool public VAR83 = false;
event FUN40();
function FUN41() onlyOwner public {
require(!VAR83);
require(FUN37());
FUN42();
FUN40();
VAR83 = true;
}
function FUN42() internal {
}
}
pragma solidity 0.4.24;
contract DipTge is VAR84, VAR85 {
using SafeMath for uint256;
enum VAR86 { VAR87, VAR88, VAR89, VAR90 }
uint256 public VAR91;
uint256 public VAR92;
uint256 public VAR93;
uint256 public VAR94;
state public VAR95 = VAR86.VAR87;
event FUN43(uint256 VAR96);
event FUN44(uint256 VAR96);
event FUN45(uint256 VAR96);
event FUN46(uint256 VAR96);
event FUN47(address VAR97, uint256 VAR37);
constructor(
uint256 VAR57,
uint256 VAR98,
uint256 VAR58,
uint256 VAR99,
uint256 VAR100,
uint256 VAR101,
uint256 VAR59,
address VAR60
)
FUN31(VAR57, VAR58, VAR59, VAR60)
public
{
require(VAR57 >= VAR102.VAR103);
require(VAR98 >= VAR57);
require(VAR58 >= VAR98);
require(VAR99 >= VAR58);
require(VAR100 > VAR99);
require(VAR101 > 0);
require(VAR59 > 0);
require(VAR60 != 0x0);
VAR91 = VAR98;
VAR92 = VAR101;
VAR93 = VAR99;
VAR94 = VAR100;
FUN48(VAR49).FUN25();
}
function FUN49(uint256 VAR59) onlyOwner public {
require(VAR95 == VAR86.VAR87);
VAR53 = VAR59;
}
function FUN50() onlyOwner external {
FUN48(VAR49).FUN26();
}
function FUN51(address VAR2) public constant returns (uint256 VAR104) {
uint256 VAR105 = 0;
if (VAR95 == VAR86.VAR88) {
VAR105 = VAR74[VAR2].VAR68.FUN7(VAR74[VAR2].VAR69);
if (VAR105 > VAR92.FUN7(VAR54)) {
VAR105 = VAR92.FUN7(VAR54);
}
} else if (VAR95 == VAR86.VAR89) {
if (VAR74[VAR2].VAR68 > 0) {
VAR105 = VAR92.FUN7(VAR54);
}
}
return VAR105;
}
function FUN52(address VAR2, uint256 VAR37, uint256 VAR59) public constant returns (uint256 VAR106) {
uint256 VAR72 = VAR74[VAR2].VAR72;
assert(VAR72 == 0 || VAR72 == 4 || VAR72 == 10);
if (VAR72 > 0) {
VAR106 = VAR37.FUN8(VAR37.FUN6(VAR72)).FUN5(VAR59);
} else {
VAR106 = VAR37.FUN5(VAR59);
}
}
function FUN53() public {
if (VAR54 >= VAR92 && VAR95 != VAR86.VAR90) {
VAR95 = VAR86.VAR90;
emit FUN45(VAR102.VAR103);
emit FUN46(VAR102.VAR103);
} else if (
VAR102.VAR103 >= VAR50 &&
VAR102.VAR103 < VAR91 &&
VAR95 != VAR86.VAR88
) {
VAR95 = VAR86.VAR88;
emit FUN43(VAR102.VAR103);
} else if (
VAR102.VAR103 >= VAR91 &&
VAR102.VAR103 <= VAR51 &&
VAR95 != VAR86.VAR89
) {
VAR95 = VAR86.VAR89;
emit FUN44(VAR102.VAR103);
} else if (
VAR95 != VAR86.VAR90 &&
VAR102.VAR103 > VAR51
) {
VAR95 = VAR86.VAR90;
emit FUN46(VAR102.VAR103);
}
}
function FUN34(address VAR97) public payable {
require(VAR97 != 0x0);
require(FUN35());
require(VAR74[VAR97].VAR71 == false);
FUN53();
uint256 VAR63 = msg.value;
uint256 VAR105 = FUN51(VAR97);
uint256 VAR107;
if (VAR63 > VAR105) {
VAR107 = VAR63.FUN7(VAR105);
VAR63 = VAR105;
}
require(VAR63 > 0);
uint256 VAR64 = FUN52(VAR97, VAR63, VAR53);
assert(VAR64 > 0);
VAR54 = VAR54.FUN8(VAR63);
require(VAR49.FUN19(VAR97, VAR64));
emit FUN30(msg.sender, VAR97, VAR63, VAR64);
VAR74[VAR97].VAR69 = VAR74[VAR97].VAR69.FUN8(VAR63);
VAR74[VAR97].VAR70 = VAR74[VAR97].VAR70.FUN8(VAR64);
VAR52.transfer(VAR63);
if (VAR107 != 0) VAR97.transfer(VAR107);
}
function FUN1(address VAR2) public constant returns (bool) {
if (VAR102.VAR103 < VAR93 && VAR74[VAR2].VAR73 == 1) {
return true;
} else if (VAR102.VAR103 < VAR94 && VAR74[VAR2].VAR73 == 2) {
return true;
}
return false;
}
function FUN54() public {
FUN55(msg.sender);
}
function FUN55(address VAR97) public {
require(VAR97 != 0x0);
require(VAR74[VAR97].VAR71 == true);
require(VAR74[VAR97].VAR70 == 0);
require(VAR74[VAR97].VAR68 > 0);
FUN53();
require(VAR95 == VAR86.VAR90);
uint256 VAR35 = VAR74[VAR97].VAR68.FUN5(VAR53);
require(VAR49.FUN19(VAR97, VAR35));
emit FUN47(VAR97, VAR35);
VAR74[VAR97].VAR70 = VAR74[VAR97].VAR70.FUN8(VAR35);
}
function FUN32() internal returns (VAR41) {
return VAR62 FUN48();
}
function FUN42() internal {
uint256 VAR108 = FUN48(VAR49).FUN56();
VAR49.FUN19(VAR52, VAR108.FUN7(VAR49.FUN57()));
VAR49.FUN20();
VAR49.FUN4(VAR4);
}
function FUN29(ERC20Basic VAR47, address VAR18) onlyOwner external {
VAR47.transfer(VAR18, VAR47.FUN9(this));
}
}
0
---------------------------------
297 0x00409ccacd67ab9e476b7f386eb67bf40ccbbcba.sol
pragma solidity 0.4.24;
contract VAR1 {
address VAR2;
uint256 VAR3;
constructor() public {
VAR2 = msg.sender;
VAR3 = 5;
}
mapping (address => uint256) VAR4;
mapping (address => uint256) VAR5;
function() external payable {
require(msg.value >= 0);
VAR2.transfer(msg.value / (VAR3 * 2));
uint VAR6 = VAR7;
if (VAR4[msg.sender] != 0) {
uint256 VAR8 = VAR4[msg.sender] * VAR3 / 100 * (VAR6 - VAR5[msg.sender]) / 86400;
if (address(this).VAR9 < VAR8) VAR8 = address(this).VAR9;
msg.sender.transfer(VAR8);
emit FUN1(msg.sender, VAR8);
}
VAR5[msg.sender] = VAR6;
VAR4[msg.sender] += msg.value;
if (msg.value > 0) emit FUN2(msg.sender, VAR4[msg.sender]);
}
event FUN1(address VAR10, uint256 VAR11);
event FUN2(address VAR12, uint256 VAR13);
}
0
---------------------------------
298 0x0042d589023cfd5a979388f5be6e4abf532ab9af.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
function FUN1(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) internal returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5>=VAR3 && VAR5>=VAR4);
return VAR5;
}
function assert(bool VAR6) internal {
if (!VAR6) throw;
}
}
contract VAR7 {
function FUN4() constant returns (uint256 VAR8) {}
function FUN5(address VAR9) constant returns (uint256 VAR10) {}
function transfer(address VAR11, uint256 VAR12) returns (bool VAR13) {}
function FUN6(address VAR14, address VAR11, uint256 VAR12) returns (bool VAR13) {}
function FUN7(address VAR15, uint256 VAR12) returns (bool VAR13) {}
function FUN8(address VAR9, address VAR15) constant returns (uint256 VAR16) {}
event Transfer(address indexed VAR14, address indexed VAR11, uint256 VAR12);
event FUN9(address indexed VAR9, address indexed VAR15, uint256 VAR12);
}
contract StandardToken is VAR7 {
function transfer(address VAR11, uint256 VAR12) returns (bool VAR13) {
if (VAR17[msg.sender] >= VAR12 && VAR17[VAR11] + VAR12 > VAR17[VAR11]) {
VAR17[msg.sender] -= VAR12;
VAR17[VAR11] += VAR12;
Transfer(msg.sender, VAR11, VAR12);
return true;
} else { return false; }
}
function FUN6(address VAR14, address VAR11, uint256 VAR12) returns (bool VAR13) {
if (VAR17[VAR14] >= VAR12 && VAR18[VAR14][msg.sender] >= VAR12 && VAR17[VAR11] + VAR12 > VAR17[VAR11]) {
VAR17[VAR11] += VAR12;
VAR17[VAR14] -= VAR12;
VAR18[VAR14][msg.sender] -= VAR12;
Transfer(VAR14, VAR11, VAR12);
return true;
} else { return false; }
}
function FUN5(address VAR9) constant returns (uint256 VAR10) {
return VAR17[VAR9];
}
function FUN7(address VAR15, uint256 VAR12) returns (bool VAR13) {
VAR18[msg.sender][VAR15] = VAR12;
FUN9(msg.sender, VAR15, VAR12);
return true;
}
function FUN8(address VAR9, address VAR15) constant returns (uint256 VAR16) {
return VAR18[VAR9][VAR15];
}
mapping(address => uint256) VAR17;
mapping (address => mapping (address => uint256)) VAR18;
}
contract ServiceChainToken is VAR19, VAR2 {
string public constant VAR20 ="";
string public constant VAR21 = "";
uint256 public constant VAR22 = 18;
uint256 public constant VAR23 = 200000000 * 10**18;
function FUN10(){
VAR17[msg.sender] = VAR23;
}
function FUN4() constant returns (uint256 VAR8) {
return VAR23;
}
}
0
---------------------------------
299 0x0046f822ef4e6d51a40dd87d34ab1d5f088291a4.sol
pragma VAR1 ^0.4.11;
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) payable returns (bytes32 VAR7);
function FUN7(string VAR5) returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) returns (uint VAR12);
function FUN8(string VAR14);
function FUN9(byte VAR15);
function FUN10(bytes32 VAR16);
function FUN11(uint VAR17);
function FUN12() returns(bytes32);
}
contract VAR18 {
function FUN13() returns (address VAR19);
}
contract VAR20 {
uint constant VAR21 = 60*60*24;
uint constant VAR22 = 60*60*24*7;
uint constant VAR23 = 60*60*24*30;
byte constant VAR24 = 0x00;
byte constant VAR25 = 0x10;
byte constant VAR26 = 0x20;
byte constant VAR27 = 0x30;
byte constant VAR28 = 0xF0;
byte constant VAR29 = 0x01;
uint8 constant VAR30 = 0;
uint8 constant VAR31 = 1;
uint8 constant VAR32 = 2;
uint8 constant VAR33 = 2;
uint8 constant VAR34 = 161;
OraclizeAddrResolverI VAR35;
OraclizeI VAR36;
modifier VAR37 {
if((address(VAR35)==0)||(FUN14(address(VAR35))==0))
FUN15(VAR30);
if(address(VAR36) != VAR35.FUN13())
VAR36 = FUN16(VAR35.FUN13());
VAR38;
}
modifier FUN17(string VAR39){
VAR36 = FUN16(VAR35.FUN13());
VAR36.FUN8(VAR39);
VAR38;
}
function FUN15(uint8 VAR40) internal returns(bool){
if (FUN14(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR35 = FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN19("");
return true;
}
if (FUN14(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR35 = FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN19("");
return true;
}
if (FUN14(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR35 = FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN19("");
return true;
}
if (FUN14(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR35 = FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN19("");
return true;
}
if (FUN14(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR35 = FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN14(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR35 = FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN14(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR35 = FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN20(bytes32 VAR41, string VAR42) {
FUN20(VAR41, VAR42, VAR43 bytes(0));
}
function FUN20(bytes32 VAR41, string VAR42, bytes VAR44) {
}
function FUN21(string VAR39) oraclizeAPI internal {
VAR36.FUN8(VAR39);
}
function FUN22(string VAR45) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45);
}
function FUN22(string VAR45, uint VAR13) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45, VAR13);
}
function FUN23(string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(0, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(VAR53, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(VAR53, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(0, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(0, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(VAR53, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(VAR53, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(0, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN26() oraclizeAPI internal returns (address){
return VAR36.FUN27();
}
function FUN28(byte VAR64) oraclizeAPI internal {
return VAR36.FUN9(VAR64);
}
function FUN29(uint VAR65) oraclizeAPI internal {
return VAR36.FUN11(VAR65);
}
function FUN30(bytes32 VAR66) oraclizeAPI internal {
return VAR36.FUN10(VAR66);
}
function FUN31() oraclizeAPI internal returns (bytes32){
return VAR36.FUN12();
}
function FUN14(address VAR19) constant internal returns(uint VAR67) {
VAR68 {
VAR67 := FUN32(VAR19)
}
}
function FUN33(string VAR69) internal returns (address){
bytes memory VAR70 = bytes(VAR69);
uint160 VAR71 = 0;
uint160 VAR72;
uint160 VAR73;
for (uint VAR74=2; VAR74<2+2*20; VAR74+=2){
VAR71 *= 256;
VAR72 = FUN34(VAR70[VAR74]);
VAR73 = FUN34(VAR70[VAR74+1]);
if ((VAR72 >= 97)&&(VAR72 <= 102)) VAR72 -= 87;
else if ((VAR72 >= 65)&&(VAR72 <= 70)) VAR72 -= 55;
else if ((VAR72 >= 48)&&(VAR72 <= 57)) VAR72 -= 48;
if ((VAR73 >= 97)&&(VAR73 <= 102)) VAR73 -= 87;
else if ((VAR73 >= 65)&&(VAR73 <= 70)) VAR73 -= 55;
else if ((VAR73 >= 48)&&(VAR73 <= 57)) VAR73 -= 48;
VAR71 += (VAR72*16+VAR73);
}
return address(VAR71);
}
function FUN35(string VAR69, string VAR75) internal returns (int) {
bytes memory VAR76 = bytes(VAR69);
bytes memory VAR77 = bytes(VAR75);
uint VAR78 = VAR76.VAR79;
if (VAR77.VAR79 < VAR78) VAR78 = VAR77.VAR79;
for (uint VAR74 = 0; VAR74 < VAR78; VAR74 ++)
if (VAR76[VAR74] < VAR77[VAR74])
return -1;
else if (VAR76[VAR74] > VAR77[VAR74])
return 1;
if (VAR76.VAR79 < VAR77.VAR79)
return -1;
else if (VAR76.VAR79 > VAR77.VAR79)
return 1;
else
return 0;
}
function FUN36(string VAR80, string VAR81) internal returns (int) {
bytes memory VAR82 = bytes(VAR80);
bytes memory VAR83 = bytes(VAR81);
if(VAR82.VAR79 < 1 || VAR83.VAR79 < 1 || (VAR83.VAR79 > VAR82.VAR79))
return -1;
else if(VAR82.VAR79 > (2**128 -1))
return -1;
else
{
uint VAR84 = 0;
for (uint VAR74 = 0; VAR74 < VAR82.VAR79; VAR74 ++)
{
if (VAR82[VAR74] == VAR83[0])
{
VAR84 = 1;
while(VAR84 < VAR83.VAR79 && (VAR74 + VAR84) < VAR82.VAR79 && VAR82[VAR74 + VAR84] == VAR83[VAR84])
{
VAR84++;
}
if(VAR84 == VAR83.VAR79)
return int(VAR74);
}
}
return -1;
}
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86, string VAR87) internal returns (string) {
bytes memory VAR88 = bytes(VAR69);
bytes memory VAR89 = bytes(VAR75);
bytes memory VAR90 = bytes(VAR85);
bytes memory VAR91 = bytes(VAR86);
bytes memory VAR92 = bytes(VAR87);
string memory VAR93 = VAR43 string(VAR88.VAR79 + VAR89.VAR79 + VAR90.VAR79 + VAR91.VAR79 + VAR92.VAR79);
bytes memory VAR94 = bytes(VAR93);
uint VAR95 = 0;
for (uint VAR74 = 0; VAR74 < VAR88.VAR79; VAR74++) VAR94[VAR95++] = VAR88[VAR74];
for (VAR74 = 0; VAR74 < VAR89.VAR79; VAR74++) VAR94[VAR95++] = VAR89[VAR74];
for (VAR74 = 0; VAR74 < VAR90.VAR79; VAR74++) VAR94[VAR95++] = VAR90[VAR74];
for (VAR74 = 0; VAR74 < VAR91.VAR79; VAR74++) VAR94[VAR95++] = VAR91[VAR74];
for (VAR74 = 0; VAR74 < VAR92.VAR79; VAR74++) VAR94[VAR95++] = VAR92[VAR74];
return string(VAR94);
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, VAR86, "");
}
function FUN37(string VAR69, string VAR75, string VAR85) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, "", "");
}
function FUN37(string VAR69, string VAR75) internal returns (string) {
return FUN37(VAR69, VAR75, "", "", "");
}
function FUN38(string VAR69) internal returns (uint) {
return FUN38(VAR69, 0);
}
function FUN38(string VAR69, uint VAR75) internal returns (uint) {
bytes memory VAR96 = bytes(VAR69);
uint VAR97 = 0;
bool VAR98 = false;
for (uint VAR74=0; VAR74<VAR96.VAR79; VAR74++){
if ((VAR96[VAR74] >= 48)&&(VAR96[VAR74] <= 57)){
if (VAR98){
if (VAR75 == 0) break;
else VAR75--;
}
VAR97 *= 10;
VAR97 += uint(VAR96[VAR74]) - 48;
} else if (VAR96[VAR74] == 46) VAR98 = true;
}
if (VAR75 > 0) VAR97 *= 10**VAR75;
return VAR97;
}
function FUN39(uint VAR74) internal returns (string){
if (VAR74 == 0) return "";
uint VAR99 = VAR74;
uint VAR100;
while (VAR99 != 0){
VAR100++;
VAR99 /= 10;
}
bytes memory VAR101 = VAR43 bytes(VAR100);
uint VAR95 = VAR100 - 1;
while (VAR74 != 0){
VAR101[VAR95--] = FUN40(48 + VAR74 % 10);
VAR74 /= 10;
}
return string(VAR101);
}
function FUN24(string[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
function FUN25(bytes[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
string VAR112;
function FUN19(string VAR113) internal {
VAR112 = VAR113;
}
function FUN41() internal returns (string) {
return VAR112;
}
function FUN42(uint VAR114, uint VAR115, uint VAR116) internal returns (bytes32){
if ((VAR115 == 0)||(VAR115 > 32)) throw;
bytes memory VAR117 = VAR43 bytes(1);
VAR117[0] = FUN40(VAR115);
bytes memory VAR118 = VAR43 bytes(32);
bytes memory VAR119 = VAR43 bytes(32);
bytes32 VAR120 = FUN31();
VAR68 {
FUN43(VAR118, 0x20)
FUN43(FUN44(VAR118, 0x20), FUN45(FUN46(FUN47(VAR121, 1)), FUN45(VAR122, VAR53)))
FUN43(VAR119, 0x20)
FUN43(FUN44(VAR119, 0x20), VAR120)
}
bytes[3] memory VAR60 = [VAR118, VAR117, VAR119];
bytes32 VAR123 = FUN23(VAR114, "", VAR60, VAR116);
FUN48(VAR123, FUN49(FUN50(VAR114), VAR60[1], FUN51(VAR60[0]), VAR60[2]));
return VAR123;
}
function FUN48(bytes32 VAR123, bytes32 VAR124) internal {
VAR125[VAR123] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN52(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR43 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN53(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR43 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN53(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR68 {
VAR132 := FUN54(FUN44(VAR134, 32))
VAR133 := FUN54(FUN44(VAR136, 32))
}
(VAR130, VAR131) = FUN55(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN55(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN56(bytes VAR44, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR43 bytes(uint(VAR44[VAR137+1])+2);
FUN53(VAR44, VAR137, VAR138.VAR79, VAR138, 0);
bytes memory VAR139 = VAR43 bytes(64);
FUN53(VAR44, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR43 bytes(1+65+32);
VAR140[0] = 1;
FUN53(VAR44, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN53(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN52(FUN51(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR43 bytes(1+65);
VAR144[0] = 0xFE;
FUN53(VAR44, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR43 bytes(uint(VAR44[3+65+1])+2);
FUN53(VAR44, 3+65, VAR145.VAR79, VAR145, 0);
VAR130 = FUN52(FUN51(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN57(bytes32 VAR146, string VAR147, bytes VAR148) {
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) throw;
bool VAR149 = FUN58(VAR148, VAR146, bytes(VAR147), FUN41());
if (VAR149 == false) throw;
VAR38;
}
function FUN59(bytes32 VAR146, string VAR147, bytes VAR148) internal returns (uint8){
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) return 1;
bool VAR149 = FUN58(VAR148, VAR146, bytes(VAR147), FUN41());
if (VAR149 == false) return 2;
return 0;
}
function FUN60(bytes32 VAR150, bytes VAR151, uint VAR152) internal returns (bool){
bool VAR153 = true;
for (uint256 VAR74=0; VAR74< VAR152; VAR74++) {
if (VAR150[VAR74] != VAR151[VAR74]) VAR153 = false;
}
return VAR153;
}
function FUN58(bytes VAR44, bytes32 VAR123, bytes VAR42, string VAR154) internal returns (bool){
uint VAR155 = 3+65+(uint(VAR44[3+65+1])+2)+32;
bytes memory VAR156 = VAR43 bytes(32);
FUN53(VAR44, VAR155, 32, VAR156, 0);
if (!(FUN49(VAR156) == FUN49(FUN51(VAR154, VAR123)))) return false;
bytes memory VAR157 = VAR43 bytes(uint(VAR44[VAR155+(32+8+1+32)+1])+2);
FUN53(VAR44, VAR155+(32+8+1+32), VAR157.VAR79, VAR157, 0);
if (!FUN60(FUN51(VAR157), VAR42, uint(VAR44[VAR155+32+8]))) return false;
bytes memory VAR158 = VAR43 bytes(8+1+32);
FUN53(VAR44, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR43 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR79+65;
FUN53(VAR44, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN51(VAR159);
if (VAR125[VAR123] == FUN49(VAR158, VAR160)){
delete VAR125[VAR123];
} else return false;
bytes memory VAR161 = VAR43 bytes(32+8+1+32);
FUN53(VAR44, VAR155, 32+8+1+32, VAR161, 0);
if (!FUN52(FUN51(VAR161), VAR157, VAR159)) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN56(VAR44, VAR137);
}
return VAR126[VAR160];
}
function FUN53(bytes VAR162, uint VAR163, uint VAR79, bytes VAR164, uint VAR165) internal returns (bytes) {
uint VAR78 = VAR79 + VAR165;
if (VAR164.VAR79 < VAR78) {
throw;
}
uint VAR74 = 32 + VAR163;
uint VAR99 = 32 + VAR165;
while (VAR74 < (32 + VAR163 + VAR79)) {
VAR68 {
let VAR70 := FUN54(FUN44(VAR162, VAR74))
FUN43(FUN44(VAR164, VAR99), VAR70)
}
VAR74 += 32;
VAR99 += 32;
}
return VAR164;
}
function FUN55(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR68 {
let VAR172 := FUN54(0x40)
FUN43(VAR172, VAR166)
FUN43(FUN44(VAR172, 32), VAR167)
FUN43(FUN44(VAR172, 64), VAR168)
FUN43(FUN44(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN54(VAR172)
}
return (VAR170, VAR171);
}
function FUN61(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR79 != 65)
return (false, 0);
VAR68 {
VAR168 := FUN54(FUN44(VAR173, 32))
VAR169 := FUN54(FUN44(VAR173, 64))
VAR167 := FUN40(0, FUN54(FUN44(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN55(VAR166, VAR167, VAR168, VAR169);
}
}
contract ETH500on719 is VAR20 {
address public VAR174 = 0xC3eD2d481B9d75835EC04174b019A7eAF2Faf78A;
uint public constant VAR175 = 0;
uint public constant VAR176 = 0.01 VAR49;
uint public VAR177 = 1531897200;
uint public VAR178 = 1531983600;
uint public constant VAR179 = 1531734192;
uint public VAR180 = VAR177 - 60;
uint public constant VAR181 = 60 * 60 * 24;
uint public VAR182 = 200000;
uint public VAR183 = VAR178 + 60 * 60 * 24;
uint public VAR184 = VAR178 + 60 * 60 * 24 * 30;
bool public VAR185;
bool public VAR186;
bool public VAR187;
uint public VAR188;
bool public VAR189;
uint public VAR190;
uint public VAR191 = 0;
bytes32 public VAR192;
uint public VAR193;
uint public VAR194;
struct VAR195 {
uint VAR196;
uint VAR197;
bool VAR198;
}
mapping(address => VAR195) VAR199;
address[] public VAR200;
uint[2] public VAR201;
uint[2] public VAR202;
uint public VAR203;
uint public VAR204 = 2;
event FUN62();
modifier FUN63() {
require (VAR204 == 2 && !VAR185 && !VAR186 && VAR205 > VAR180 && VAR205 >= VAR178);
VAR38;
}
modifier FUN64() {
require(VAR186 || VAR185);
uint VAR206 = VAR186 ? (VAR202[0] + VAR202[1]) : VAR202[VAR204];
require ((VAR205 >= VAR184 && !VAR186) || (VAR191 == VAR206));
VAR38;
}
modifier FUN65() {
require (VAR186 || (VAR204 != 2 && VAR185 && VAR205 > VAR180));
VAR38;
}
modifier FUN66() {
require (!VAR186 && VAR204 != 2 && VAR185 && !VAR187 && VAR205 > VAR180);
VAR38;
}
modifier FUN67() {
require (VAR205 >= VAR180);
VAR38;
}
modifier FUN68() {
require(
VAR174 == msg.sender
);
VAR38;
}
function FUN69() public payable {
FUN29(1000000000);
FUN70(VAR178, VAR182);
}
function FUN71(uint VAR207, uint VAR48) public VAR208 {
VAR182 = VAR207;
FUN29(VAR48);
}
function FUN72(uint VAR209, uint VAR210) public VAR208 {
FUN73(VAR209);
FUN74(VAR210);
}
function FUN73(uint VAR209) public VAR208 {
VAR177 = VAR209;
VAR180 = VAR177 - 60;
}
function FUN74(uint VAR210) payable public VAR208 {
require(VAR210 > VAR177);
VAR178 = VAR210;
VAR183 = VAR178 + 60 * 60 * 24;
VAR184 = VAR178 + 60 * 60 * 24 * 30;
FUN70(VAR178, VAR182);
}
function FUN70(uint VAR211, uint VAR207) private {
require(VAR186 != true && VAR185 != true);
VAR192 = FUN75(VAR211, "", "", VAR207);
}
function FUN75(uint VAR211, string VAR45, string VAR52, uint VAR207) private returns(bytes32) {
VAR193 += FUN22(VAR45, VAR207);
return FUN23(VAR211, VAR45, VAR52, VAR207);
}
function FUN76(uint VAR207, uint VAR65) payable public onlyOwnerLevel VAR212 {
VAR182 = VAR207;
FUN29(VAR65);
FUN70(0, VAR182);
}
function FUN20(bytes32 VAR123, string VAR42, bytes VAR44) public VAR212 {
require(msg.sender == FUN26());
if (FUN77(VAR42) != FUN77("") && FUN77(VAR42) != FUN77("")) {
if (VAR205 >= VAR183) {
FUN78();
}
else if (VAR192 == VAR123) {
FUN70(VAR181, VAR182);
}
}
else {
FUN79(FUN38(VAR42));
}
}
function FUN79(uint VAR213) private {
VAR185 = true;
VAR186 = false;
VAR204 = VAR213;
VAR190 = VAR205;
FUN80();
}
function FUN81(address VAR171) public constant returns(uint[]) {
uint[] memory VAR214 = new uint[](2);
VAR214[VAR199[VAR171].VAR197] = VAR199[VAR171].VAR196;
return VAR214;
}
function FUN82(address VAR171) public constant returns(bool) {
return VAR199[VAR171].VAR198;
}
function FUN83() public constant returns(bool) {
return (VAR185 && VAR204 != 2 && VAR205 >= (VAR190 + 600));
}
function FUN84() public constant returns(bool) {
return (VAR205 >= VAR179 && VAR205 < VAR180 && !VAR186 && !VAR185);
}
function FUN85(uint VAR215) public payable {
require(FUN84() == true);
require(msg.value >= VAR176);
require(VAR199[msg.sender].VAR196 == 0 || VAR199[msg.sender].VAR197 == VAR215);
if (VAR199[msg.sender].VAR196 == 0) {
VAR199[msg.sender].VAR197 = VAR215;
VAR202[VAR215]++;
VAR200.FUN86(msg.sender);
}
VAR199[msg.sender].VAR196 += msg.value;
VAR203 += msg.value;
VAR201[VAR215] += msg.value;
FUN62();
}
function FUN87() private VAR216 {
VAR174.transfer(this.VAR217);
VAR189 = true;
}
function FUN88() public onlyOwnerLevel VAR216 {
FUN87();
}
function FUN80() private VAR218 {
if (VAR175 == 0) {
VAR187 = true;
VAR188 = 0;
if (VAR202[VAR204] > 0) {
VAR194 = ((VAR193 != 0) ? (VAR193 / VAR202[VAR204] + 1) : 0);
}
return;
}
uint VAR219 = VAR201[1 - VAR204];
VAR188 = (VAR219 - VAR193) / VAR175;
if (VAR202[VAR204] > 0) {
VAR194 = ((VAR193 != 0) ? ((VAR193 - VAR193 / VAR175) / VAR202[VAR204] + 1) : 0);
}
VAR174.transfer(VAR188);
VAR187 = true;
}
function FUN89() payable public VAR208 {
FUN78();
}
function FUN78() private {
VAR186 = true;
VAR185 = false;
}
function() payable public {
}
function FUN90() public VAR220 {
address VAR221 = msg.sender;
require(VAR199[VAR221].VAR196 > 0);
require(!VAR199[VAR221].VAR198);
require(VAR186 != VAR185);
require(VAR186 || (VAR185 && VAR199[VAR221].VAR197 == VAR204));
require(VAR205 >= (VAR190 + 600));
uint VAR222 = 0;
if (!VAR186) {
uint VAR219 = VAR201[1 - VAR204];
VAR222 = VAR199[VAR221].VAR196 + (VAR199[VAR221].VAR196 * (VAR219 - VAR188) / VAR201[VAR204]) - VAR194;
}
else {
VAR222 = VAR199[VAR221].VAR196;
}
if (VAR222 > 0) {
VAR221.transfer(VAR222);
VAR199[VAR221].VAR198 = true;
VAR191++;
}
}
}
0
---------------------------------
300 0x004def62c71992615cf22786d0b7efb22850df4a.sol
pragma solidity 0.4.21;
library VAR1 {
function FUN1(
address VAR2
)
internal
view
returns (bool)
{
if (VAR2 == 0x0) {
return false;
} else {
uint VAR3;
VAR4 { VAR3 := FUN2(VAR2) }
return VAR3 > 0;
}
}
}
contract VAR5 {
address public VAR6;
event FUN3(
address indexed VAR7,
address indexed VAR8
);
function FUN4()
public
{
VAR6 = msg.sender;
}
modifier onlyOwner()
{
require(msg.sender == VAR6);
VAR9;
}
function FUN5(
address VAR8
)
onlyOwner
public
{
require(VAR8 != 0x0);
emit FUN3(VAR6, VAR8);
VAR6 = VAR8;
}
}
contract Claimable is VAR5 {
address public VAR10;
modifier FUN6() {
require(msg.sender == VAR10);
VAR9;
}
function FUN5(
address VAR8
)
onlyOwner
public
{
require(VAR8 != 0x0 && VAR8 != VAR6);
VAR10 = VAR8;
}
function FUN7()
VAR11
public
{
emit FUN3(VAR6, VAR10);
VAR6 = VAR10;
VAR10 = 0x0;
}
}
contract VAR12 {
event FUN8(address VAR2, string VAR13);
event FUN9(address VAR2, string VAR13);
function FUN10(
address VAR2,
string  VAR13
)
external;
function FUN11(
address VAR2,
string  VAR13
)
external;
function FUN12(
address VAR2,
string  VAR13
)
external;
function FUN13(
address[] VAR14
)
external
view
returns (bool);
function FUN14(
string VAR13
)
external
view
returns (address);
function FUN15(
string VAR13
)
public
view
returns (bool);
function FUN16(
address VAR2
)
public
view
returns (bool);
function FUN17(
uint VAR15,
uint VAR16
)
public
view
returns (address[] VAR14);
}
contract TokenRegistryImpl is VAR12, VAR17 {
using AddressUtil for address;
address[] public VAR18;
mapping (address => VAR19) VAR20;
mapping (string => address) VAR21;
struct VAR19 {
uint   VAR22;
string VAR13;
}
function ()
payable
public
{
revert();
}
function FUN10(
address VAR2,
string  VAR13
)
external
onlyOwner
{
FUN18(VAR2, VAR13);
}
function FUN11(
address VAR2,
string  VAR13
)
external
{
FUN18(VAR2, VAR13);
}
function FUN12(
address VAR2,
string  VAR13
)
external
onlyOwner
{
require(VAR2 != 0x0);
require(VAR21[VAR13] == VAR2);
delete VAR21[VAR13];
uint VAR22 = VAR20[VAR2].VAR22;
require(VAR22 != 0);
delete VAR20[VAR2];
address VAR23 = VAR18[VAR18.VAR24 - 1];
if (VAR2 != VAR23) {
VAR18[VAR22 - 1] = VAR23;
VAR20[VAR23].VAR22 = VAR22;
}
VAR18.VAR24--;
emit FUN9(VAR2, VAR13);
}
function FUN13(
address[] VAR14
)
external
view
returns (bool)
{
for (uint VAR25 = 0; VAR25 < VAR14.VAR24; VAR25++) {
if (VAR20[VAR14[VAR25]].VAR22 == 0) {
return false;
}
}
return true;
}
function FUN14(
string VAR13
)
external
view
returns (address)
{
return VAR21[VAR13];
}
function FUN15(
string VAR13
)
public
view
returns (bool)
{
return VAR21[VAR13] != 0x0;
}
function FUN16(
address VAR2
)
public
view
returns (bool)
{
return VAR20[VAR2].VAR22 != 0;
}
function FUN17(
uint VAR15,
uint VAR16
)
public
view
returns (address[] VAR14)
{
uint VAR26 = VAR18.VAR24;
if (VAR15 >= VAR26) {
return;
}
uint VAR27 = VAR15 + VAR16;
if (VAR27 > VAR26) {
VAR27 = VAR26;
}
if (VAR15 == VAR26) {
return;
}
VAR14 = new address[](VAR27 - VAR15);
for (uint VAR25 = VAR15; VAR25 < VAR27; VAR25++) {
VAR14[VAR25 - VAR15] = VAR18[VAR25];
}
}
function FUN18(
address VAR2,
string  VAR13
)
internal
{
require(0x0 != VAR2);
require(bytes(VAR13).VAR24 > 0);
require(0x0 == VAR21[VAR13]);
require(0 == VAR20[VAR2].VAR22);
VAR18.FUN19(VAR2);
VAR21[VAR13] = VAR2;
VAR20[VAR2] = FUN20(VAR18.VAR24, VAR13);
emit FUN8(VAR2, VAR13);
}
}
0
---------------------------------
301 0x004fd00dc156ff5ce5da0a7082934d4122f8bd3f.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1(address VAR2, address VAR3) public returns (bool);
function FUN2(address VAR2, address VAR3, uint256 VAR4) public returns (bool);
function FUN3(address VAR2, address VAR5, bool VAR6) public returns (bool);
function FUN4(address VAR2, address VAR7, address VAR3, uint256 VAR4) public returns (bool);
function FUN5(address VAR2, address VAR7, address VAR3, uint256 VAR4) public returns (bool);
function FUN5(address VAR2, address VAR7, address VAR3, uint256 VAR4, bytes memory VAR8) public returns (bool);
}
contract VAR9 {
address public VAR10;
constructor() public {
VAR10 = msg.sender;
}
function FUN6(address VAR11) public onlyOwner {
VAR10 = VAR11;
}
function FUN7() public view returns (address) {
return VAR10;
}
modifier onlyOwner {
require(msg.sender == VAR10);
VAR12;
}
}
contract BasicMintable is VAR1, VAR9 {
mapping(address => bool) public VAR13;
function FUN8(address VAR14, bool VAR15) public onlyOwner {
VAR13[VAR14] = VAR15;
}
bool public VAR16 = true;
function FUN9(bool VAR15) public onlyOwner {
VAR16 = VAR15;
}
function FUN1(address VAR2, address) public returns (bool) {
require(VAR16, "");
return VAR13[VAR2];
}
function FUN2(address, address, uint256) public returns (bool) {
return true;
}
function FUN3(address, address, bool) public returns (bool) {
return true;
}
function FUN4(address, address, address, uint256) public returns (bool) {
return true;
}
function FUN5(address, address, address, uint256) public returns (bool) {
return true;
}
function FUN5(address, address, address, uint256, bytes VAR17) public returns (bool) {
return true;
}
}
0
---------------------------------
302 0x0054265eea0ad4dd25895fff4899fc42c41dc6f6.sol
pragma solidity 0.4.24;
contract VAR1 {
address public VAR2;
function FUN1(byte VAR3) external;
function FUN2(uint VAR4) external;
function FUN3(string VAR5, uint VAR6) public returns (uint VAR7);
function FUN4(uint VAR8, string VAR5, string VAR9, uint VAR10) external payable returns (bytes32 VAR11);
function FUN5(uint VAR8, string VAR5, string VAR9)
external
payable
returns (bytes32 VAR11);
function FUN3(string VAR5) public returns (uint VAR7);
}
contract VAR12 {
function FUN6() public returns (address VAR13);
}
contract VAR14 {
byte constant internal VAR15 = 0x30;
byte constant internal VAR16 = 0x40;
byte constant internal VAR17 = 0x01;
uint8 constant internal VAR18 = 0;
uint8 constant internal VAR19 = 1;
uint8 constant internal VAR20 = 2;
OraclizeAddrResolverI VAR21;
OraclizeI VAR22;
modifier VAR23 {
if ((address(VAR21) == 0)||(FUN7(address(VAR21)) == 0))
FUN8(VAR18);
if (address(VAR22) != VAR21.FUN6())
VAR22 = FUN9(VAR21.FUN6());
VAR24;
}
function FUN8(uint8 VAR25) internal returns(bool) {
return FUN8();
VAR25;
}
function FUN8() internal returns(bool){
if (FUN7(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0){
VAR21 = FUN10(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN11("");
return true;
}
if (FUN7(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR21 = FUN10(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN11("");
return true;
}
if (FUN7(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0){
VAR21 = FUN10(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN11("");
return true;
}
if (FUN7(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR21 = FUN10(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN11("");
return true;
}
if (FUN7(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR21 = FUN10(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN12(string VAR26) oraclizeAPI internal returns (uint){
return VAR22.FUN3(VAR26);
}
function FUN12(string VAR26, uint VAR6) oraclizeAPI internal returns (uint){
return VAR22.FUN3(VAR26, VAR6);
}
function FUN13(string VAR26, string VAR27) oraclizeAPI internal returns (bytes32 VAR28){
uint VAR29 = VAR22.FUN3(VAR26);
if (VAR29 > 1 VAR30 + VAR31.VAR32*200000) return 0;
return VAR22.VAR33.value(VAR29)(0, VAR26, VAR27);
}
function FUN13(uint VAR34, string VAR26, string VAR27, uint VAR6) oraclizeAPI internal returns (bytes32 VAR28){
uint VAR29 = VAR22.FUN3(VAR26, VAR6);
if (VAR29 > 1 VAR30 + VAR31.VAR32*VAR6) return 0;
return VAR22.VAR35.value(VAR29)(VAR34, VAR26, VAR27, VAR6);
}
function FUN13(uint VAR34, string VAR26, string VAR27)
VAR23
internal
returns (bytes32 VAR28)
{
uint VAR29 = VAR22.FUN3(VAR26);
if (VAR29 > 1 VAR30 + VAR31.VAR32*200000) return 0;
return VAR22.VAR33.value(VAR29)(VAR34, VAR26, VAR27);
}
function FUN14() internal oraclizeAPI returns (address) {
return VAR22.FUN15();
}
function FUN16(byte VAR36) internal VAR23 {
return VAR22.FUN1(VAR36);
}
function FUN17(uint VAR37) oraclizeAPI internal {
return VAR22.FUN2(VAR37);
}
function FUN7(address VAR13) internal view returns(uint VAR38) {
VAR39 {
VAR38 := FUN18(VAR13)
}
}
function FUN19(string VAR40, uint VAR41) internal pure returns (uint) {
bytes memory VAR42 = bytes(VAR40);
uint VAR43 = 0;
bool VAR44 = false;
for (uint VAR45 = 0; VAR45 < VAR42.VAR46; VAR45++) {
if ((VAR42[VAR45] >= 48)&&(VAR42[VAR45] <= 57)) {
if (VAR44) {
if (VAR41 == 0) break;
else VAR41--;
}
VAR43 *= 10;
VAR43 += uint(VAR42[VAR45]) - 48;
} else if (VAR42[VAR45] == 46) VAR44 = true;
}
if (VAR41 > 0) VAR43 *= 10**VAR41;
return VAR43;
}
string public VAR47;
function FUN11(string VAR48) internal {
VAR47 = VAR48;
}
}
library VAR49 {
function FUN20(uint256 VAR50, uint256 VAR51) internal pure returns (uint256 VAR52) {
if (VAR50 == 0) {
return 0;
}
VAR52 = VAR50 * VAR51;
assert(VAR52 / VAR50 == VAR51);
return VAR52;
}
function FUN21(uint256 VAR50, uint256 VAR51) internal pure returns (uint256) {
assert(VAR51 <= VAR50);
return VAR50 - VAR51;
}
function FUN22(uint256 VAR50, uint256 VAR51) internal pure returns (uint256 VAR52) {
VAR52 = VAR50 + VAR51;
assert(VAR52 >= VAR50);
return VAR52;
}
function FUN23(uint256 VAR50, uint256 VAR53) internal pure returns (uint256 VAR54) {
assert(VAR50 >= 0);
VAR54 = 1;
for (uint256 VAR45 = 0; VAR45 < VAR53; VAR45++) {
VAR54 *= VAR50;
assert(VAR54 >= VAR50);
}
}
}
contract VAR55 {
address public VAR56;
address public VAR57;
event FUN24(address indexed VAR58, address indexed VAR59);
modifier onlyOwner() {
require(msg.sender == VAR56);
VAR24;
}
modifier FUN25() {
require(msg.sender == VAR57);
VAR24;
}
constructor() public {
VAR56 = msg.sender;
}
function FUN26(address VAR59) public onlyOwner {
VAR57 = VAR59;
}
function FUN27() public VAR60 {
emit FUN24(VAR56, VAR57);
VAR56 = VAR57;
VAR57 = address(0);
}
}
contract Accessable is VAR55 {
uint256 public VAR61 = 28 VAR62;
uint256 public VAR63 = 200 VAR64;
uint256 public VAR65 = 144 VAR66;
mapping(address => uint256) public VAR67;
event FUN28(address VAR68, uint256 VAR69);
modifier FUN29() {
require(VAR67[msg.sender] > VAR70 || msg.value == VAR63);
VAR24;
}
function () external payable {
FUN30(msg.sender);
}
function FUN31(uint256 VAR71) external onlyOwner {
require(VAR71 < 2000 VAR64);
VAR63 = VAR71;
}
function FUN32(uint256 VAR71) external onlyOwner {
require(VAR71 < VAR63 * 24 * VAR61);
VAR65 = VAR71;
}
function FUN33(address VAR72) external returns(bool) {
return VAR67[VAR72] > VAR70;
}
function FUN30(address VAR73) public payable {
require(VAR73 != address(0));
uint256 VAR74 = msg.value / VAR65;
require(VAR74 > 0);
uint256 VAR75 = msg.value % VAR65;
VAR73.transfer(VAR75);
FUN34(VAR73, VAR74);
}
function FUN34(address VAR13, uint256 VAR76) internal {
uint256 VAR77;
if (VAR67[VAR13] < VAR70) {
VAR77 = VAR70 + VAR61 * VAR76;
} else {
VAR77 = VAR77 + VAR61 * VAR76;
}
VAR67[VAR13] = VAR77;
emit FUN28(VAR13, VAR77);
}
}
contract Reoraclizer is VAR14, VAR78 {
using SafeMath for uint256;
string internal VAR79;
uint256 internal VAR80 = 90000;
uint256 internal VAR29 = 999999;
event FUN35(string VAR81);
constructor() public {
FUN16(VAR16 | VAR17);
FUN17(10000000000);
}
function FUN36(bytes32 VAR82, string VAR83, bytes VAR84) public {
if (msg.sender != FUN14()) revert();
VAR29 = FUN19(VAR83, 4);
FUN37(3600);
}
function FUN38() external onlyPayed payable returns(uint256) {
return VAR29;
}
function FUN37(uint256 VAR85) internal {
FUN13(VAR85, "", "FUN39(VAR86:
}
function FUN40(uint256 VAR85) public payable onlyOwner {
FUN37(VAR85);
}
function FUN41 (uint256 VAR87) external onlyOwner {
VAR80 = VAR87;
}
function FUN42(uint256 VAR4) external onlyOwner {
FUN17(VAR4);
}
function FUN43(uint256 VAR88) external onlyOwner {
require(address(this).VAR89 > VAR88.FUN22(3 VAR30));
VAR56.transfer(VAR88);
}
}
0
---------------------------------
303 0x005aae78c0de67642c728504dc9d264ecb9bb312.sol
pragma VAR1 ^0.4.2;
contract VAR2 {
uint256 constant public VAR3 = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;
uint256 constant public VAR4 = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;
uint256 constant public VAR5 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;
uint256 constant public VAR6 = 0;
uint256 constant public VAR7 = 7;
uint256[] public VAR8;
uint256[] public VAR9;
uint256[] public VAR10;
function FUN1() public
{
VAR8.FUN2(VAR3);
VAR9.FUN2(VAR4);
VAR10.FUN2(1);
}
function FUN3(uint VAR11) public
{
require(VAR8.VAR12 < 256);
uint256 VAR13 = VAR8[VAR8.VAR12 - 1];
uint256 VAR14 = VAR9[VAR9.VAR12 - 1];
uint256 VAR15 = VAR10[VAR10.VAR12 - 1];
for (uint VAR16 = 0; VAR16 < VAR11 && VAR8.VAR12 < 256; VAR16++) {
(VAR13,VAR14,VAR15) = FUN4(VAR13,VAR14,VAR15);
VAR8.FUN2(VAR13);
VAR9.FUN2(VAR14);
VAR10.FUN2(VAR15);
}
}
function FUN5( uint256 VAR17,uint256 VAR18,
uint256 VAR19,uint256 VAR20) public pure
returns(uint256 VAR21,uint256 VAR22)
{
(VAR21, VAR22) = (  FUN6( FUN7(VAR20, VAR17 , VAR5) ,
FUN7(VAR19, VAR18 , VAR5),
VAR5),
FUN7(VAR18, VAR20 , VAR5)
);
}
function FUN8( uint256 VAR17,uint256 VAR18,
uint256 VAR19,uint256 VAR20) public pure
returns(uint256 VAR21,uint256 VAR22)
{
(VAR21, VAR22) = (  FUN6( FUN7(VAR20, VAR17, VAR5),
FUN7(VAR5 - VAR19, VAR18, VAR5),
VAR5),
FUN7(VAR18, VAR20 , VAR5)
);
}
function FUN9( uint256 VAR17,uint256 VAR18,
uint256 VAR19,uint256 VAR20) public pure
returns(uint256 VAR21,uint256 VAR22)
{
(VAR21, VAR22) = (  FUN7(VAR17, VAR19 , VAR5), FUN7(VAR18, VAR20 , VAR5));
}
function FUN10( uint256 VAR17,uint256 VAR18,
uint256 VAR19,uint256 VAR20) public pure
returns(uint256 VAR21,uint256 VAR22)
{
(VAR21, VAR22) = (  FUN7(VAR17, VAR20 , VAR5), FUN7(VAR18 , VAR19 , VAR5));
}
function FUN11( uint256 VAR23) public pure
returns(uint256 VAR24)
{
uint256 VAR25=0;
uint256 VAR26=1;
uint256 VAR27=VAR5;
uint256 VAR28=VAR23;
uint256 VAR29;
while (VAR28 != 0) {
VAR29 = VAR27 / VAR28;
(VAR25, VAR26) = (VAR26, FUN6(VAR25 , (VAR5 - FUN7(VAR29, VAR26,VAR5)) , VAR5));
(VAR27, VAR28) = (VAR28, VAR27 - VAR29 * VAR28 );
}
return VAR25;
}
function FUN12( uint256 VAR17,uint256 VAR30,uint256 VAR18,
uint256 VAR19,uint256 VAR31,uint256 VAR20) public pure
returns(uint256 VAR21,uint256 VAR32,uint256 VAR22)
{
uint256 VAR33;
uint256 VAR34;
uint256 VAR35;
uint256 VAR36;
if ((VAR17==0)&&(VAR30==0)) {
return (VAR19,VAR31,VAR20);
}
if ((VAR19==0)&&(VAR31==0)) {
return (VAR17,VAR30,VAR18);
}
if ((VAR17==VAR19)&&(VAR30==VAR31)) {
(VAR33,VAR34) = FUN9(VAR17, VAR18, VAR17, VAR18);
(VAR33,VAR34) = FUN9(VAR33, VAR34, 3, 1);
(VAR33,VAR34) = FUN5(VAR33, VAR34, VAR6, 1);
(VAR35,VAR36) = FUN9(VAR30, VAR18, 2, 1);
} else {
(VAR33,VAR34) = FUN8(VAR31, VAR20, VAR30, VAR18);
(VAR35,VAR36)  = FUN8(VAR19, VAR20, VAR17, VAR18);
}
(VAR33, VAR34) = FUN10(VAR33, VAR34, VAR35, VAR36);
(VAR21, VAR35) = FUN9(VAR33, VAR34, VAR33, VAR34);
(VAR21, VAR35) = FUN8(VAR21, VAR35, VAR17, VAR18);
(VAR21, VAR35) = FUN8(VAR21, VAR35, VAR19, VAR20);
(VAR32, VAR36) = FUN8(VAR17, VAR18, VAR21, VAR35);
(VAR32, VAR36) = FUN9(VAR32, VAR36, VAR33, VAR34 );
(VAR32, VAR36) = FUN8(VAR32, VAR36, VAR30, VAR18 );
if (VAR35 != VAR36) {
VAR21 = FUN7(VAR21, VAR36, VAR5);
VAR32 = FUN7(VAR32, VAR35, VAR5);
VAR22 = FUN7(VAR35, VAR36, VAR5);
} else {
VAR22 = VAR35;
}
}
function FUN4(uint256 VAR17,uint256 VAR30,uint256 VAR18) public pure
returns(uint256 VAR21,uint256 VAR32,uint256 VAR22)
{
(VAR21,VAR32,VAR22) = FUN12(VAR17,VAR30,VAR18,VAR17,VAR30,VAR18);
}
function FUN13(uint256 VAR37, uint256 VAR17,uint256 VAR30,uint256 VAR18) public pure
returns(uint256 VAR21,uint256 VAR32,uint256 VAR22)
{
uint256 VAR38 = VAR37;
uint256 VAR39 = VAR17;
uint256 VAR40 = VAR30;
uint256 VAR41 = VAR18;
uint256 VAR42 = 0;
uint256 VAR43 = 0;
uint256 VAR44 = 1;
if (VAR37==0) {
return (0,0,1);
}
while (VAR38 != 0) {
if ((VAR38 & 1) != 0) {
(VAR42,VAR43,VAR44) = FUN12(VAR42,VAR43,VAR44, VAR39,VAR40,VAR41);
}
VAR38 = VAR38 / 2;
(VAR39,VAR40,VAR41) = FUN4(VAR39,VAR40,VAR41);
}
(VAR21,VAR32,VAR22) = (VAR42,VAR43,VAR44);
}
function FUN14(uint256 VAR45) public constant
returns(uint256 VAR46, uint256 VAR47)
{
uint256 VAR42 = 0;
uint256 VAR43 = 0;
uint256 VAR44 = 1;
if (VAR45 == 0) {
return (0,0);
}
for (uint VAR48 = 0; VAR48 < 256; VAR48++) {
if (((VAR45 >> VAR48) & 1) != 0) {
(VAR42,VAR43,VAR44) = FUN12(VAR42,VAR43,VAR44, VAR8[VAR48],VAR9[VAR48],VAR10[VAR48]);
}
}
VAR44 = FUN11(VAR44);
(VAR46,VAR47) = (FUN7(VAR42,VAR44,VAR5),FUN7(VAR43,VAR44,VAR5));
}
function FUN15(uint256 VAR45, uint256 VAR49, uint256 VAR50) public pure
returns(uint256 VAR46, uint256 VAR47)
{
uint256 VAR13;
uint256 VAR14;
uint256 VAR15;
(VAR13,VAR14,VAR15) = FUN13(VAR45, VAR49, VAR50, 1);
VAR15 = FUN11(VAR15);
VAR46 = FUN7(VAR13 , VAR15 ,VAR5);
VAR47 = FUN7(VAR14 , VAR15 ,VAR5);
}
}
0
---------------------------------
304 0x005c03671f914748598b1302a60cc586e9825a33.sol
pragma VAR1 ^0.5.6;
contract VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
function FUN5() public returns (uint);
function FUN6(address VAR7) public returns (uint VAR8);
function FUN7(address VAR7, address VAR9) public returns (uint VAR10);
function transfer(address VAR11, uint VAR12) public returns (bool VAR13);
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13);
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13);
event Transfer(address indexed VAR14, address indexed VAR11, uint VAR12);
event FUN10(address indexed VAR7, address indexed VAR9, uint VAR12);
}
//
contract VAR15 {
function FUN11(address VAR14, uint256 VAR12, address VAR16, bytes memory VAR17) public;
}
contract VAR18 {
address public VAR19;
event FUN12(address indexed VAR20, address indexed VAR21);
constructor() public {
VAR19 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR19);
VAR22;
}
}
contract Token is VAR6, VAR18, VAR2 {
string public VAR23;
string public  VAR24;
uint public VAR25;
string public VAR26;
uint private VAR27;
mapping(address => uint) VAR28;
mapping(address => mapping(address => uint)) VAR29;
constructor(
uint256 VAR30,
string memory VAR31,
uint8 VAR32,
string memory VAR33,
string memory VAR34
) public {
VAR23 = VAR33;
VAR24 = VAR31;
VAR25 = VAR32;
VAR26 = VAR34;
VAR27 = VAR30;
VAR27 = VAR27 * 10 ** VAR25;
VAR28[VAR19] = VAR27;
emit Transfer(address(0), VAR19, VAR27);
}
function FUN5() public returns (uint) {
return VAR27;
}
function FUN6(address VAR7) public returns (uint VAR8) {
return VAR28[VAR7];
}
function transfer(address VAR11, uint VAR12) public returns (bool VAR13) {
VAR28[msg.sender] = FUN2(VAR28[msg.sender], VAR12);
VAR28[VAR11] = FUN1(VAR28[VAR11], VAR12);
emit Transfer(msg.sender, VAR11, VAR12);
return true;
}
//
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13) {
VAR29[msg.sender][VAR9] = VAR12;
emit FUN10(msg.sender, VAR9, VAR12);
return true;
}
//
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13) {
VAR28[VAR14] = FUN2(VAR28[VAR14], VAR12);
VAR29[VAR14][msg.sender] = FUN2(VAR29[VAR14][msg.sender], VAR12);
VAR28[VAR11] = FUN1(VAR28[VAR11], VAR12);
emit Transfer(VAR14, VAR11, VAR12);
return true;
}
function FUN7(address VAR7, address VAR9) public returns (uint VAR10) {
return VAR29[VAR7][VAR9];
}
function FUN13(address VAR9, uint VAR12, bytes memory VAR17) public returns (bool VAR13) {
VAR29[msg.sender][VAR9] = VAR12;
emit FUN10(msg.sender, VAR9, VAR12);
FUN14(VAR9).FUN11(msg.sender, VAR12, address(this), VAR17);
return true;
}
function () external payable {
revert();
}
function FUN15(address VAR35) public onlyOwner {
VAR19 = VAR35;
}
function FUN16(address VAR36, uint256 value) public onlyOwner {
require(VAR36 != address(0));
VAR27 = FUN1(VAR27, value);
VAR28[VAR36] = FUN1(VAR28[VAR36], value);
emit Transfer(address(0), VAR36, value);
}
function FUN17(address VAR36, uint256 value) public onlyOwner {
require(VAR36 != address(0));
VAR27 = FUN2(VAR27, value);
VAR28[VAR36] = FUN2(VAR28[VAR36], value);
emit Transfer(VAR36, address(0), value);
}
}
0
---------------------------------
305 0x0064353c557afe927866f0f3b748bc271c385d71.sol
pragma solidity 0.4.19;
contract VAR1 {
function FUN1(address VAR2) constant internal returns(bool) {
uint VAR3;
if (VAR2 == 0) return false;
VAR4 {
VAR3 := FUN2(VAR2)
}
return VAR3 > 0;
}
}
contract VAR5 {
function FUN3(bytes32 VAR6, bytes VAR7);
}
contract VAR8 {
function FUN4(uint8 VAR9) payable returns(bytes32);
function FUN5() returns(uint256);
}
library VAR10 {
function FUN6(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
if (VAR11 == 0) {
return 0;
}
uint256 VAR13 = VAR11 * VAR12;
assert(VAR13 / VAR11 == VAR12);
return VAR13;
}
function FUN7(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 / VAR12;
return VAR13;
}
function FUN8(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
assert(VAR12 <= VAR11);
return VAR11 - VAR12;
}
function FUN9(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 + VAR12;
assert(VAR13 >= VAR11);
return VAR13;
}
}
contract VAR14 {
address public VAR15;
event FUN10(address indexed VAR16, address indexed VAR17);
function FUN11() public {
VAR15 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR18;
}
function FUN12(address VAR17) public onlyOwner {
require(VAR17 != address(0));
FUN10(VAR15, VAR17);
VAR15 = VAR17;
}
}
contract StateQuickEth is VAR14 {
//
modifier VAR19 {
require(!VAR20);
VAR18;
}
uint16 internal constant VAR21 = 1 VAR22;
bool public VAR20;
bool public VAR23;
uint32 public VAR24 = 350000;
uint256 public VAR25 = 6000000000;
uint256 public VAR26 = 2 VAR27;
uint8 public VAR28 = 10;
uint256 public VAR29 = 20 VAR27;
uint256 public VAR30 = 1 VAR31;
uint256 public VAR32 = 5;
uint8 public VAR33 = 1;
uint16 public VAR34 = 5;
uint256 public VAR35 = 60 VAR36;
address public VAR37;
function FUN13(uint8 VAR38) public onlyOwner VAR19 {
VAR28 = VAR38;
}
function FUN14(uint256 VAR38) public onlyOwner VAR19 {
VAR29 = VAR38;
}
function FUN15(uint256 VAR38) public onlyOwner VAR19 {
VAR30 = VAR38;
}
function FUN16(uint16 VAR38) public onlyOwner VAR19 {
VAR34 = VAR38;
}
function FUN17(uint256 VAR38) public onlyOwner VAR19 {
VAR35 = VAR38;
}
function FUN18(uint256 VAR38) public onlyOwner {
VAR32 = VAR38;
}
function FUN19(uint8 VAR38) public onlyOwner {
VAR33 = VAR38;
}
function FUN20(bool VAR38) public onlyOwner {
VAR23 = VAR38;
}
function FUN21() public onlyOwner {
VAR20 = true;
}
function FUN22(uint32 VAR39) public onlyOwner {
VAR24 = VAR39;
}
function FUN23(uint32 VAR40) public onlyOwner {
VAR25 = VAR40;
}
function FUN24(address VAR41) public onlyOwner {
require(VAR37 != 0x0);
VAR37 = VAR41;
}
function FUN25(uint256 VAR42) public onlyOwner {
require(VAR42 > 0);
VAR26 = VAR42;
}
}
//
//
contract CryptoLuckQuickEthV1 is VAR5, VAR43, VAR1 {
using SafeMath for uint;
modifier VAR44 {
require(msg.sender == VAR37);
VAR18;
}
event FUN26(
uint32 indexed VAR45,
uint8 VAR46,
bytes32 indexed VAR47,
bytes VAR48
);
struct VAR49 {
uint256 VAR50;
uint256 VAR51;
uint256 VAR52;
uint256 VAR53;
mapping (address => uint256) VAR54;
address[] VAR55;
address VAR56;
address VAR57;
bytes32[] VAR58;
bytes VAR48;
uint256 VAR59;
uint8 VAR46;
bool VAR60;
}
bool public VAR61;
uint32 public VAR62 = 0;
mapping (VAR63 => VAR49) public VAR64;
uint256 public VAR65 = 1 VAR27;
uint256 public VAR66;
uint256 public VAR67 = 0;
function FUN27(address VAR68, bool VAR69) {
VAR23 = false;
VAR20 = true;
require(VAR68 != 0x0);
VAR37 = VAR68;
VAR61 = VAR69;
VAR66 = VAR70.VAR71;
}
function FUN28() view internal returns (Lottery VAR72) {
return VAR64[VAR62];
}
function () public payable {
require(!FUN1(msg.sender));
require(VAR20);
require(msg.value >= VAR65);
uint256 VAR73 = FUN28().VAR54[msg.sender];
require(msg.value + VAR73 >= VAR29);
require(msg.value + VAR73 <= VAR30);
FUN29(VAR62);
if (FUN30() && FUN31()) {
FUN32();
}
}
function FUN31() view private returns(bool) {
return (msg.VAR74 >= VAR24) && (VAR75.VAR76 >= VAR25);
}
//
function FUN29(uint32 VAR45) private returns(uint) {
Lottery storage VAR77 = VAR64[VAR45];
if (VAR77.VAR60) {
FUN29(VAR45 + 1);
return;
}
address VAR78 = msg.sender;
if (VAR77.VAR54[VAR78] == 0) {
VAR77.VAR55.FUN33(VAR78);
}
VAR77.VAR54[VAR78] = VAR77.VAR54[VAR78].FUN9(msg.value);
VAR77.VAR50 = VAR77.VAR50.FUN9(msg.value);
return VAR77.VAR54[VAR78];
}
function FUN30() view private returns (bool) {
Lottery memory VAR77 = FUN28();
bool VAR79 = VAR80 - VAR66 >= VAR35;
bool VAR81 = VAR77.VAR55.VAR82 >= VAR34;
return VAR81 && VAR79;
}
function FUN32() private {
Lottery storage VAR77 = FUN28();
VAR77.VAR60 = true;
VAR77.VAR51 = VAR77.VAR50;
VAR77.VAR57 = msg.sender;
VAR66 = VAR80;
FUN4();
}
function FUN4() private {
Lottery storage VAR77 = FUN28();
CryptoLuckRng VAR83 = FUN34(VAR37);
uint VAR84 = VAR83.FUN5();
VAR77.VAR50 = VAR77.VAR50.FUN8(VAR84);
VAR77.VAR52 = VAR77.VAR52.FUN9(VAR84);
bytes32 VAR47 = VAR83.VAR85.value(VAR84)(7);
VAR77.VAR58.FUN33(VAR47);
}
function FUN3(bytes32 VAR86, bytes VAR7) public VAR44 {
Lottery storage VAR77 = FUN28();
if (VAR61) {
require(FUN35() == VAR86);
}
VAR77.VAR48 = VAR7;
uint256 VAR87 = FUN36(VAR77.VAR51);
VAR77.VAR53 = VAR87;
uint256 VAR88 = VAR87 + (VAR77.VAR51 / VAR65);
VAR77.VAR59 = 1 + (uint(FUN37(VAR7)) % VAR88);
FUN38();
FUN26(VAR62, 1, VAR86, VAR7);
}
function FUN36(uint256 VAR51) view internal returns(uint256) {
uint256 VAR87 = (VAR51 * VAR33 / 100) / VAR65;
if (VAR87 == 0) {
VAR87 = 1;
}
if (VAR87 > VAR32) {
VAR87 = VAR32;
}
return VAR87;
}
function FUN38() private {
Lottery storage VAR77 = FUN28();
uint256 VAR89 = 1;
for (uint16 VAR90 = 0; VAR90 < VAR77.VAR55.VAR82; VAR90++) {
address VAR78 = VAR77.VAR55[VAR90];
uint256 VAR91 = VAR77.VAR54[VAR78] / VAR65;
if (VAR78 == VAR77.VAR57) {
VAR91 += VAR77.VAR53;
}
VAR89 += VAR91 - 1;
if (VAR89 >= VAR77.VAR59) {
VAR77.VAR56 = VAR78;
break;
}
VAR89 += 1;
}
uint256 VAR92 = VAR77.VAR50;
uint256 VAR93 = VAR28 * VAR92 / 1000;
VAR67 = VAR67.FUN9(VAR93);
VAR92 = VAR92.FUN8(VAR93);
VAR92 = VAR92.FUN8(VAR26);
VAR77.VAR46 = 1;
VAR77.VAR60 = false;
VAR77.VAR50 = VAR92;
VAR77.VAR56.transfer(VAR92);
VAR77.VAR57.transfer(VAR26);
FUN39();
}
function FUN39() private {
VAR62 += 1;
if (VAR23) {
VAR20 = false;
VAR23 = false;
}
}
function FUN35() view private returns(bytes32) {
Lottery memory VAR77 = FUN28();
return VAR77.VAR58[VAR77.VAR58.VAR82 - 1];
}
function FUN40(uint32 VAR45) public {
address VAR94 = msg.sender;
Lottery storage VAR77 = VAR64[VAR45];
require(VAR77.VAR46 == 2);
uint256 VAR95 = VAR77.VAR54[VAR94].FUN8(VAR77.VAR52 / VAR77.VAR55.VAR82);
require(VAR95 > 0);
VAR77.VAR54[VAR94] = 0;
VAR77.VAR50 = VAR77.VAR50.FUN8(VAR95);
VAR94.transfer(VAR95);
}
function FUN41() public payable {
VAR67 = VAR67.FUN9(msg.value);
}
function FUN42() public onlyOwner {
VAR15.transfer(VAR67);
}
function FUN43() public onlyOwner {
Lottery storage VAR77 = FUN28();
require(VAR77.VAR46 == 0);
require(FUN30());
require(VAR80 - VAR66 > VAR21);
if (VAR77.VAR58.VAR82 == 2) {
VAR77.VAR46 = 2;
VAR77.VAR60 = false;
FUN26(VAR62, 2, VAR77.VAR58[VAR77.VAR58.VAR82 - 1], "");
FUN39();
} else {
FUN32();
}
}
function FUN44(uint32 VAR45, address VAR94) view public returns(uint) {
return VAR64[VAR45].VAR54[VAR94];
}
function FUN45(uint32 VAR45) view public returns (address[]) {
return VAR64[VAR45].VAR55;
}
function FUN46(uint32 VAR45) view public returns(bytes32[]) {
return VAR64[VAR45].VAR58;
}
}
0
---------------------------------
306 0x00674045bb7c17f0aa1cde34780d6c51af548728.sol
pragma solidity 0.4.14;
contract VAR1 {
uint constant public VAR2 = 50;
event FUN1(address indexed sender, uint indexed VAR3);
event FUN2(address indexed sender, uint indexed VAR3);
event FUN3(uint indexed VAR3);
event FUN4(uint indexed VAR3);
event FUN5(uint indexed VAR3);
event FUN6(address indexed sender, uint value);
event FUN7(address indexed VAR4);
event FUN8(address indexed VAR4);
event FUN9(uint VAR5);
mapping (uint => Transaction) public VAR6;
mapping (uint => mapping (address => bool)) public VAR7;
mapping (address => bool) public VAR8;
address[] public VAR9;
uint public VAR5;
uint public VAR10;
struct Transaction {
address VAR11;
uint value;
bytes VAR12;
bool VAR13;
}
modifier FUN10() {
if (msg.sender != address(this))
throw;
VAR14;
}
modifier FUN11(address VAR4) {
if (VAR8[VAR4])
throw;
VAR14;
}
modifier ownerExists(address VAR4) {
if (!VAR8[VAR4])
throw;
VAR14;
}
modifier FUN12(uint VAR3) {
if (VAR6[VAR3].VAR11 == 0)
throw;
VAR14;
}
modifier confirmed(uint VAR3, address VAR4) {
if (!VAR7[VAR3][VAR4])
throw;
VAR14;
}
modifier notConfirmed(uint VAR3, address VAR4) {
if (VAR7[VAR3][VAR4])
throw;
VAR14;
}
modifier notExecuted(uint VAR3) {
if (VAR6[VAR3].VAR13)
throw;
VAR14;
}
modifier FUN13(address VAR15) {
if (VAR15 == 0)
throw;
VAR14;
}
modifier FUN14(uint VAR16, uint VAR17) {
if (   VAR16 > VAR2
|| VAR17 > VAR16
|| VAR17 == 0
|| VAR16 == 0)
throw;
VAR14;
}
function()
payable
{
if (msg.value > 0)
FUN6(msg.sender, msg.value);
}
function FUN15(address[] VAR18, uint VAR17)
public
FUN14(VAR18.VAR19, VAR17)
{
for (uint VAR20=0; VAR20<VAR18.VAR19; VAR20++) {
if (VAR8[VAR18[VAR20]] || VAR18[VAR20] == 0)
throw;
VAR8[VAR18[VAR20]] = true;
}
VAR9 = VAR18;
VAR5 = VAR17;
}
function FUN16(address VAR4)
public
VAR21
FUN11(VAR4)
FUN13(VAR4)
FUN14(VAR9.VAR19 + 1, VAR5)
{
VAR8[VAR4] = true;
VAR9.FUN17(VAR4);
FUN7(VAR4);
}
function FUN18(address VAR4)
public
VAR21
ownerExists(VAR4)
{
VAR8[VAR4] = false;
for (uint VAR20=0; VAR20<VAR9.VAR19 - 1; VAR20++)
if (VAR9[VAR20] == VAR4) {
VAR9[VAR20] = VAR9[VAR9.VAR19 - 1];
break;
}
VAR9.VAR19 -= 1;
if (VAR5 > VAR9.VAR19)
FUN19(VAR9.VAR19);
FUN8(VAR4);
}
function FUN20(address VAR4, address VAR22)
public
VAR21
ownerExists(VAR4)
FUN11(VAR22)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR9[VAR20] == VAR4) {
VAR9[VAR20] = VAR22;
break;
}
VAR8[VAR4] = false;
VAR8[VAR22] = true;
FUN8(VAR4);
FUN7(VAR22);
}
function FUN19(uint VAR17)
public
VAR21
FUN14(VAR9.VAR19, VAR17)
{
VAR5 = VAR17;
FUN9(VAR17);
}
function FUN21(address VAR11, uint value, bytes VAR12)
public
returns (uint VAR3)
{
VAR3 = FUN22(VAR11, value, VAR12);
FUN23(VAR3);
}
function FUN23(uint VAR3)
public
ownerExists(msg.sender)
FUN12(VAR3)
notConfirmed(VAR3, msg.sender)
{
VAR7[VAR3][msg.sender] = true;
FUN1(msg.sender, VAR3);
FUN24(VAR3);
}
function FUN25(uint VAR3)
public
ownerExists(msg.sender)
confirmed(VAR3, msg.sender)
notExecuted(VAR3)
{
VAR7[VAR3][msg.sender] = false;
FUN2(msg.sender, VAR3);
}
function FUN24(uint VAR3)
public
notExecuted(VAR3)
{
if (FUN26(VAR3)) {
Transaction VAR23 = VAR6[VAR3];
VAR23.VAR13 = true;
if (VAR23.VAR11.call.value(VAR23.value)(VAR23.VAR12))
FUN4(VAR3);
else {
FUN5(VAR3);
VAR23.VAR13 = false;
}
}
}
function FUN26(uint VAR3)
public
constant
returns (bool)
{
uint VAR24 = 0;
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++) {
if (VAR7[VAR3][VAR9[VAR20]])
VAR24 += 1;
if (VAR24 == VAR5)
return true;
}
}
function FUN22(address VAR11, uint value, bytes VAR12)
internal
FUN13(VAR11)
returns (uint VAR3)
{
VAR3 = VAR10;
VAR6[VAR3] = Transaction({
VAR11: VAR11,
value: value,
VAR12: VAR12,
VAR13: false
});
VAR10 += 1;
FUN3(VAR3);
}
function FUN27(uint VAR3)
public
constant
returns (uint VAR24)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR3][VAR9[VAR20]])
VAR24 += 1;
}
function FUN28(bool VAR25, bool VAR13)
public
constant
returns (uint VAR24)
{
for (uint VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR25 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
VAR24 += 1;
}
function FUN29()
public
constant
returns (address[])
{
return VAR9;
}
function FUN30(uint VAR3)
public
constant
returns (address[] VAR26)
{
address[] memory VAR27 = new address[](VAR9.VAR19);
uint VAR24 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR3][VAR9[VAR20]]) {
VAR27[VAR24] = VAR9[VAR20];
VAR24 += 1;
}
VAR26 = new address[](VAR24);
for (VAR20=0; VAR20<VAR24; VAR20++)
VAR26[VAR20] = VAR27[VAR20];
}
function FUN31(uint VAR28, uint VAR29, bool VAR25, bool VAR13)
public
constant
returns (uint[] VAR30)
{
uint[] memory VAR31 = new uint[](VAR10);
uint VAR24 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR25 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
{
VAR31[VAR24] = VAR20;
VAR24 += 1;
}
VAR30 = new uint[](VAR29 - VAR28);
for (VAR20=VAR28; VAR20<VAR29; VAR20++)
VAR30[VAR20 - VAR28] = VAR31[VAR20];
}
}
contract MultiSigWalletWithDailyLimit is VAR1 {
event FUN32(uint VAR32);
uint public VAR32;
uint public VAR33;
uint public VAR34;
function FUN33(address[] VAR18, uint VAR17, uint VAR35)
public
FUN15(VAR18, VAR17)
{
VAR32 = VAR35;
}
function FUN34(uint VAR35)
public
VAR21
{
VAR32 = VAR35;
FUN32(VAR35);
}
function FUN24(uint VAR3)
public
notExecuted(VAR3)
{
Transaction VAR23 = VAR6[VAR3];
bool confirmed = FUN26(VAR3);
if (confirmed || VAR23.VAR12.VAR19 == 0 && FUN35(VAR23.value)) {
VAR23.VAR13 = true;
if (!confirmed)
VAR34 += VAR23.value;
if (VAR23.VAR11.call.value(VAR23.value)(VAR23.VAR12))
FUN4(VAR3);
else {
FUN5(VAR3);
VAR23.VAR13 = false;
if (!confirmed)
VAR34 -= VAR23.value;
}
}
}
function FUN35(uint VAR36)
internal
returns (bool)
{
if (VAR37 > VAR33 + 24 VAR38) {
VAR33 = VAR37;
VAR34 = 0;
}
if (VAR34 + VAR36 > VAR32 || VAR34 + VAR36 < VAR34)
return false;
return true;
}
function FUN36()
public
constant
returns (uint)
{
if (VAR37 > VAR33 + 24 VAR38)
return VAR32;
return VAR32 - VAR34;
}
}
0
---------------------------------
307 0x0069e491f2ed9e562a7c9c92ba40f73d946718e0.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function transfer(address VAR3, uint VAR4);
function FUN1(uint256 VAR5) returns (bool);
function FUN2(address VAR6) returns (uint256);
}
contract VAR7 {
address public VAR8;
function FUN3() public {
VAR8 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR8);
VAR9;
}
function FUN4(address VAR10) onlyOwner public {
VAR8 = VAR10;
}
}
contract VAR11 {
function FUN5(uint VAR12, uint VAR13) internal returns(uint) {
uint VAR14 = VAR12 * VAR13;
assert(VAR12 == 0 || VAR14 / VAR12 == VAR13);
return VAR14;
}
function FUN6(uint VAR12, uint VAR13) internal returns(uint) {
assert(VAR13 <= VAR12);
return VAR12 - VAR13;
}
function FUN7(uint VAR12, uint VAR13) internal returns(uint) {
uint VAR14 = VAR12 + VAR13;
assert(VAR14 >= VAR12 && VAR14 >= VAR13);
return VAR14;
}
}
contract Crowdsale is VAR7, VAR11 {
address public VAR15;
uint public VAR16;
uint public VAR17;
uint public VAR18;
uint public VAR19;
uint public VAR20;
token public VAR21; //
uint public VAR22 = 0;
uint public VAR23;
uint public VAR24;
mapping(address => uint256) public VAR25;
bool VAR26 = false;
event FUN8(address VAR15, uint VAR27);
event FUN9(address VAR28, uint VAR4, bool VAR29);
function FUN10( ) {
VAR15 = 0xe579891b98a3f58e26c4b2edb54e22250899363c;
VAR19 = 80000;
VAR20=8;
VAR16 = 2500000000 * (10 ** VAR20);
VAR23 = 1536537600;
VAR18 = 1539129600;
VAR24 =1537156800;
VAR21 = FUN11(0xBD64a0d7330bc16c30aA1AE34eD2C329F6DB49C9);
}
function () payable {
uint VAR4 = msg.value;
uint VAR30;
VAR30 = FUN12(VAR4);
require(VAR30>0 && !VAR26 && VAR31 > VAR23 && VAR31 < VAR18);
VAR25[msg.sender] = FUN7(VAR25[msg.sender], VAR4);
VAR17 = FUN7(VAR17, VAR4);
VAR22 += VAR30;
VAR21.transfer(msg.sender, VAR30);
VAR15.transfer(VAR4);
FUN9(msg.sender, VAR4, true);
}
function FUN12(uint VAR5) internal returns(uint VAR30) {
require(VAR5>=10000000000000000 * 1 VAR32);
VAR30 = FUN5(VAR5,VAR19)/(10 ** VAR20);
if(VAR31 <= VAR24){
if(VAR5>= 1 VAR33 && VAR5< 5 * 1 VAR33){
VAR30 += FUN5(VAR30,15)/100;
}else if(VAR5>=5 * 1 VAR33){
VAR30 += FUN5(VAR30,35)/100;
}
}
return VAR30;
}
function FUN13(address VAR34) onlyOwner {
VAR15 = VAR34;
}
modifier FUN14() { if (VAR31 >= VAR18) VAR9; }
function FUN15() VAR35 {
require(msg.sender == VAR8);
if (VAR22 >=VAR16){
FUN8(VAR15, VAR17);
}
VAR21.FUN1(VAR21.FUN2(this));
VAR26 = true;
}
}
0
---------------------------------
308 0x006be10c718c78f5c4d4e767377ea6d9dfa8dd06.sol
pragma solidity 0.5.8;
contract VAR1 {
function FUN1() public view returns (address);
function() external payable {
address VAR2 = FUN1();
require(VAR2 != address(0), "");
VAR3 {
let VAR4 := FUN2(0x40)
FUN3(VAR4, 0, VAR5)
let VAR6 := FUN4(VAR7, VAR2, VAR4, VAR5, 0, 0)
let VAR8 := VAR9
FUN5(VAR4, 0, VAR8)
switch VAR6
case 0 { revert(VAR4, VAR8) }
default { return(VAR4, VAR8) }
}
}
}
contract UpgradeabilityProxy is VAR1 {
event FUN6(address indexed VAR10, address indexed VAR11);
bytes32 private constant VAR12 = FUN7("");
function FUN1() public view returns (address VAR13) {
bytes32 VAR14 = VAR12;
VAR3 {
VAR13 := FUN8(VAR14)
}
}
function FUN9(address VAR11) internal {
bytes32 VAR14 = VAR12;
VAR3 {
FUN10(VAR14, VAR11)
}
}
function FUN11(address VAR11) internal {
address VAR10 = FUN1();
require(VAR10 != VAR11);
emit FUN6(VAR10, VAR11);
FUN9(VAR11);
}
}
contract DUSDProxy is VAR15 {
event FUN12(address indexed VAR16, address indexed VAR17);
event FUN13(address VAR18, address VAR19);
bytes32 private constant VAR20 = FUN7("");
bytes32 private constant VAR21 = FUN7("");
constructor() public {
FUN14(0xfe30e619cc2915C905Ca45C1BA8311109A3cBdB1);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN15(), "");
VAR22;
}
modifier FUN16() {
require(msg.sender == FUN17(), "");
VAR22;
}
function FUN15() public view returns (address VAR23) {
bytes32 VAR14 = VAR20;
VAR3 {
VAR23 := FUN8(VAR14)
}
}
function FUN17() public view returns (address VAR19) {
bytes32 VAR14 = VAR21;
VAR3 {
VAR19 := FUN8(VAR14)
}
}
function FUN14(address VAR24) internal {
bytes32 VAR14 = VAR20;
VAR3 {
FUN10(VAR14, VAR24)
}
}
function FUN18(address VAR25) internal {
bytes32 VAR14 = VAR21;
VAR3 {
FUN10(VAR14, VAR25)
}
}
function FUN19(address VAR17) external onlyProxyOwner {
require(VAR17 != address(0));
FUN18(VAR17);
emit FUN13(FUN15(), VAR17);
}
function FUN20() external VAR26 {
emit FUN12(FUN15(), FUN17());
FUN14(FUN17());
FUN18(address(0));
}
function FUN21(address VAR27) external onlyProxyOwner {
FUN11(VAR27);
}
}
0
---------------------------------
309 0x0073a236ee3dbd8a133f8d9d4717c0d6a042e392.sol
pragma VAR1 ^0.5.7;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
assert(VAR3 == VAR4 * VAR5 + VAR3 % VAR4);
return VAR3 / VAR4;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
library VAR6 {
function FUN1(uint16 VAR3, uint16 VAR4) internal pure returns (uint16 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN2(uint16 VAR3, uint16 VAR4) internal pure returns (uint16) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN3(uint16 VAR3, uint16 VAR4) internal pure returns (uint16 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN4(uint16 VAR3, uint16 VAR4) internal pure returns (uint16) {
assert(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
assert(VAR3 == VAR4 * VAR5 + VAR3 % VAR4);
return VAR3 / VAR4;
}
function FUN5(uint16 VAR3, uint16 VAR4) internal pure returns (uint16) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
contract VAR7 {
address private VAR8;
address payable internal VAR9;
event FUN6(address indexed VAR10, address indexed VAR11);
event FUN7(address indexed VAR12, address indexed VAR13);
constructor () internal {
VAR8 = msg.sender;
VAR9 = msg.sender;
}
function FUN8() public view returns (address) {
return VAR8;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR14;
}
function FUN9(address VAR11) external onlyOwner {
require(VAR11 != address(0));
address VAR15 = VAR8;
VAR8 = VAR11;
emit FUN6(VAR15, VAR11);
}
function FUN10(address payable VAR13) external onlyOwner {
require(VAR13 != address(0));
address VAR16 = VAR9;
VAR9 = VAR13;
emit FUN7(VAR16, VAR13);
}
function FUN11(address VAR17, address VAR18, uint256 VAR19) external onlyOwner {
IERC20 VAR20 = FUN12(VAR17);
require(VAR18 != address(0));
uint256 VAR21 = VAR20.FUN13(address(this));
require(VAR21 >= VAR19);
assert(VAR20.transfer(VAR18, VAR19));
}
function FUN14(address payable VAR22, uint256 VAR19) external onlyOwner {
require(VAR22 != address(0));
uint256 VAR21 = address(this).VAR21;
require(VAR21 >= VAR19);
VAR22.transfer(VAR19);
}
}
contract Pausable is VAR7 {
bool private VAR23;
event FUN15(address VAR24);
event FUN16(address VAR24);
constructor () internal {
VAR23 = false;
}
function FUN17() public view returns (bool) {
return VAR23;
}
modifier FUN18() {
require(!VAR23, "");
VAR14;
}
function FUN19(bool VAR25) external onlyOwner {
if (VAR23 && !VAR25) {
VAR23 = false;
emit FUN16(msg.sender);
} else if (!VAR23 && VAR25) {
VAR23 = true;
emit FUN15(msg.sender);
}
}
}
interface VAR26 {
function FUN13(address VAR27) external view returns (uint256);
function transfer(address VAR22, uint256 value) external returns (bool);
}
interface VAR28 {
function FUN13(address VAR27) external view returns (uint256);
function transfer(address VAR22, uint256 value) external returns (bool);
function FUN20(address VAR24) external view returns (bool);
function FUN21(address VAR24) external view returns (address);
function FUN22(address VAR24) external view returns (uint256);
}
contract TokenPublicSale is VAR7, VAR29{
using SafeMath16 for uint16;
using SafeMath256 for uint256;
IToken public VAR30 = FUN23(0x9D70ADFE35A0A9A8CdFF1f5367D3682Fceaa136B);
uint32 VAR31;
uint256 private VAR32;
uint16 private VAR33 = 35;
uint16[15] private VAR34 = [
6,
6,
5,
4,
3,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1
];
uint72 private VAR35   = 0.1 VAR36;
uint72 private VAR37   = 10 VAR36;
uint72 private VAR38 = 10 VAR36;
uint24 private VAR39   = 3000000;
uint24 private VAR40    = 1500000;
uint256 private VAR41 = 1000;
uint256 private VAR42  = 10;
uint256 private VAR43   = 100000000;
uint256 private VAR44    = 1000000;
uint256 private VAR45     = 15100000000;
uint256 private VAR46        = VAR41;
uint16 private VAR47 = 60000;
uint16 private VAR48 = 100;
uint16 private VAR49 = 600;
uint16 private VAR50;
uint16 private VAR51;
uint256 private VAR52;
uint256 private VAR53;
uint256 private VAR54;
uint256 private VAR55;
uint256 private VAR56;
uint256 private VAR57;
uint256 private VAR58;
uint256 private VAR59;
uint256 private VAR60;
uint256 private VAR61;
uint256 private VAR62;
uint256 private VAR63;
uint256 private VAR64;
uint256 private VAR65 = 15000000;
uint256 private VAR66 = 50000000;
uint256 private VAR67 = VAR65;
bool private VAR68;
uint256 private VAR69 = VAR33;
uint16[] private VAR70;
address[] private VAR71;
mapping (address => bool) private VAR72;
mapping (uint16 => uint256) private VAR73;
mapping (uint16 => uint256) private VAR74;
mapping (uint16 => uint256) private VAR75;
mapping (uint16 => uint256) private VAR76;
mapping (uint16 => uint256) private VAR77;
mapping (address => uint256) private VAR78;
mapping (address => uint256) private VAR79;
mapping (address => uint256) private VAR80;
mapping (address => uint256) private VAR81;
mapping (address => uint256) private VAR82;
mapping (uint16 => address[]) private VAR83;
mapping (uint16 => mapping (address => bool)) private VAR84;
mapping (uint16 => mapping (address => uint256)) private VAR85;
mapping (uint16 => mapping (address => uint256)) private VAR86;
event FUN24(uint256 value, address indexed VAR24);
event FUN25(address indexed VAR24, bool VAR25);
event FUN26(address indexed VAR22, uint256 VAR19);
event FUN27(address indexed VAR22, uint256 VAR19);
event FUN28(uint16 VAR87, address indexed VAR22, uint256 VAR88, uint256 VAR89, uint256 VAR90);
event FUN29(uint256 VAR91, address indexed VAR24);
event FUN30(uint16 VAR92, address indexed VAR24);
event FUN31(uint16 VAR93, address indexed VAR22, uint256 VAR19);
event FUN32(address indexed VAR22, uint256 VAR19);
event FUN33(address indexed VAR22, uint256 VAR19);
function FUN34() public view returns (VAR94) {
return VAR31;
}
function FUN35(uint32 VAR95) external onlyOwner {
VAR31 = VAR95;
}
modifier FUN36() {
require(VAR72[msg.sender]);
VAR14;
}
function FUN37(uint256 value) external VAR96 {
VAR32 = value;
emit FUN24(value, msg.sender);
}
function FUN38(address VAR24) public view returns (bool) {
return VAR72[VAR24];
}
function FUN39(address VAR24, bool VAR25) external onlyOwner {
VAR72[VAR24] = VAR25;
emit FUN25(VAR24, VAR25);
}
function FUN40(uint16 VAR87) private view returns (uint256) {
return VAR41.FUN1(VAR42.FUN3(VAR87));
}
function FUN41(uint256 VAR19) private view returns (uint256) {
return VAR19.FUN3(VAR32).FUN4(1 VAR36);
}
function FUN42(uint256 VAR19) private view returns (uint256) {
return VAR19.FUN3(1 VAR36).FUN4(VAR32);
}
function FUN43(uint256 VAR97) private view returns (uint256) {
return VAR97.FUN3(1000000).FUN4(VAR46);
}
function FUN44(uint256 VAR97, uint16 VAR87) public view returns (uint256) {
return VAR97.FUN3(1000000).FUN4(FUN40(VAR87));
}
function FUN45(uint16 VAR87) private view returns (uint16) {
if (VAR87 > 0) {
uint16 VAR98 = VAR87.FUN4(VAR49);
if (VAR87.FUN5(VAR49) > 0) {
return VAR98.FUN1(1);
}
return VAR98;
}
return 1;
}
function FUN46(uint16 VAR93, address payable VAR22) external onlyOwner {
uint256 VAR99 = FUN47(VAR93);
require(VAR22 != address(0));
VAR77[VAR93] = VAR77[VAR93].FUN1(VAR99);
emit FUN31(VAR93, VAR22, VAR99);
VAR22.transfer(VAR99);
}
function FUN48() private view returns (uint256) {
return VAR63.FUN2(VAR64);
}
function FUN49(address payable VAR22) external onlyOwner {
uint256 VAR99 = FUN48();
require(VAR22 != address(0));
VAR64 = VAR64.FUN1(VAR99);
emit FUN33(VAR22, VAR99);
VAR22.transfer(VAR99);
}
function FUN50(address payable VAR22) external onlyOwner {
uint256 VAR99 = VAR59.FUN2(VAR60).FUN2(VAR61).FUN2(VAR63).FUN2(VAR62);
require(VAR22 != address(0));
VAR62 = VAR62.FUN1(VAR99);
emit FUN32(VAR22, VAR99);
VAR22.transfer(VAR99);
}
function FUN51() public view returns (uint256 VAR89,
uint16 VAR100,
uint16 VAR101,
uint256 VAR102,
uint256 VAR103,
uint256 VAR104,
uint256 VAR105,
uint256 VAR106,
uint256 VAR107,
uint256 VAR108,
uint256 VAR109,
uint256 VAR110) {
VAR89 = VAR32;
if (VAR50 > VAR47) {
VAR100 = VAR47;
VAR101 = VAR48;
} else {
VAR100 = VAR50;
VAR101 = VAR51;
}
VAR102 = VAR46;
VAR103 = VAR67;
VAR104 = VAR52;
VAR105 = VAR53;
VAR106 = VAR54;
VAR107 = VAR55;
VAR108 = VAR56;
VAR109 = VAR57;
VAR110 = VAR58;
}
function FUN52() public view returns(uint256 VAR111,
uint256 VAR112,
uint256 VAR113,
uint256 VAR114,
uint256 VAR115,
uint256 VAR116,
uint256 VAR117) {
VAR111 = VAR59;
VAR112 = VAR60;
VAR113 = VAR61;
VAR114 = VAR62;
VAR115 = VAR63;
VAR116 = VAR64;
VAR117 = FUN48();
}
modifier FUN53() {
require(FUN54() > VAR39);
VAR14;
}
modifier FUN55() {
require(VAR31 > 0 && VAR118 > VAR31, "");
require(VAR32 > 0,        "");
require(!FUN17(),              "");
require(VAR50 <= VAR47,    "");
VAR14;
}
function FUN56(uint16 VAR87) private view returns (uint256) {
return VAR65.FUN1(VAR66.FUN3(VAR87).FUN4(VAR47));
}
function FUN57(uint256 VAR97) private view returns (uint256) {
return FUN42(VAR97.FUN3(VAR67).FUN4(100000000));
}
function FUN58(uint16 VAR87) private view returns (uint256) {
uint256 VAR119 = VAR43.FUN1(VAR44.FUN3(VAR87));
if (VAR119 > VAR45) {
return VAR45;
}
return VAR119;
}
function FUN59(uint16 VAR87) private view returns (uint256) {
return FUN44(FUN58(VAR87), VAR87);
}
function FUN60(uint16 VAR87) public view returns (uint256 VAR102,
uint256 VAR120,
uint256 VAR121,
uint256 VAR122,
uint256 VAR123,
uint256 VAR124,
uint256 VAR125,
uint256 VAR126) {
if (VAR87 > VAR47) {
return (0, 0, 0, 0, 0, 0, 0, 0);
}
VAR102 = FUN40(VAR87);
VAR122 = VAR74[VAR87];
VAR120 = FUN59(VAR87);
VAR121 = VAR120.FUN2(VAR122);
VAR125 = VAR73[VAR87];
VAR123 = FUN58(VAR87);
VAR124 = VAR123.FUN2(VAR125);
VAR126 = FUN56(VAR87);
}
function FUN47(uint16 VAR93) private view returns (uint256) {
return VAR76[VAR93].FUN2(VAR77[VAR93]);
}
function FUN61(uint16 VAR93) public view returns (uint256 VAR111,
uint256 VAR113,
uint256 VAR127,
uint256 VAR128) {
VAR111 = VAR75[VAR93];
VAR113 = VAR76[VAR93];
VAR127 = VAR77[VAR93];
VAR128 = FUN47(VAR93);
}
function FUN62(address VAR24) public view returns (uint256 VAR108,
uint256 VAR109,
uint256 VAR129,
uint256 VAR130,
uint256 VAR112) {
VAR108 = VAR78[VAR24];
VAR109 = VAR79[VAR24];
VAR129 = VAR80[VAR24];
VAR130 = VAR81[VAR24];
VAR112 = VAR82[VAR24];
}
function FUN63(uint16 VAR93) public view returns (address[] memory VAR131) {
VAR131 = VAR83[VAR93];
}
function FUN64(uint16 VAR93, address VAR24) public view returns (uint256) {
return VAR85[VAR93][VAR24];
}
function FUN65(uint16 VAR93, address VAR24) public view returns (uint256) {
return VAR86[VAR93][VAR24];
}
constructor () public {
VAR72[msg.sender] = true;
VAR50 = 0;
VAR51 = 1;
}
function () external payable enoughGas VAR132 {
require(msg.value >= VAR35);
require(msg.value <= VAR37);
FUN66();
uint256 VAR133 = FUN41(msg.value);
uint256 VAR134 = VAR133;
uint256 VAR135;
uint256 VAR136;
uint256 VAR137;
uint256 VAR138;
while (FUN54() > VAR40 && VAR134 > 0 && VAR50 <= VAR47) {
uint256 VAR139;
(VAR139, VAR134) = FUN67(VAR134);
VAR135 = VAR135.FUN1(VAR139);
}
VAR137 = VAR133.FUN2(VAR134);
VAR138 = FUN42(VAR137);
if (msg.value >= VAR38) {
VAR136 = VAR135.FUN4(10);
assert(FUN68(VAR136));
}
if (VAR68 && VAR135 > 0) {
assert(FUN69(VAR135.FUN1(VAR136)));
FUN70(VAR138);
}
if (VAR134 > 0) {
uint256 VAR99 = FUN42(VAR134);
VAR138 = msg.value.FUN2(VAR99);
msg.sender.transfer(VAR99);
}
if (VAR138 > 0) {
VAR52 = VAR52.FUN1(1);
VAR59 = VAR59.FUN1(VAR138);
VAR81[msg.sender] = VAR81[msg.sender].FUN1(VAR138);
}
uint256 VAR140;
if (VAR51 > VAR48)
VAR140 = VAR59.FUN2(VAR60).FUN2(VAR61).FUN2(VAR63).FUN2(VAR62);
else
VAR140 = VAR59.FUN2(VAR60).FUN2(VAR61).FUN2(VAR63).FUN2(VAR62).FUN4(0.01 VAR36).FUN3(0.01 VAR36);
VAR62 = VAR62.FUN1(VAR140);
VAR9.transfer(VAR140);
assert(true);
}
function FUN66() private {
delete VAR71;
delete VAR70;
VAR68 = VAR30.FUN20(msg.sender);
VAR69 = VAR33;
address VAR141 = msg.sender;
for(uint16 VAR142 = 0; VAR142 < VAR34.VAR143; VAR142++) {
address VAR144 = VAR30.FUN21(VAR141);
if (VAR141 == VAR144)
break;
if (VAR30.FUN22(VAR144) > VAR142) {
if (!VAR84[VAR51][VAR144]) {
VAR83[VAR51].FUN71(VAR144);
VAR84[VAR51][VAR144] = true;
}
VAR69 = VAR69.FUN2(VAR34[VAR142]);
VAR70.FUN71(VAR34[VAR142]);
VAR71.FUN71(VAR144);
}
VAR141 = VAR144;
}
}
function FUN67(uint256 VAR97) private returns (uint256, uint256) {
uint256 VAR145 = FUN58(VAR50);
uint256 VAR135;
if (VAR73[VAR50].FUN1(VAR97) <= VAR145) {
FUN72(VAR97);
VAR135 = FUN43(VAR97);
assert(FUN73(VAR135, VAR97));
if (VAR145 == VAR73[VAR50]) {
assert(FUN74());
}
return (VAR135, 0);
}
uint256 VAR137 = VAR145.FUN2(VAR73[VAR50]);
uint256 VAR134 = VAR97.FUN2(VAR137);
FUN72(VAR137);
VAR135 = FUN43(VAR137);
assert(FUN73(VAR135, VAR137));
assert(FUN74());
return (VAR135, VAR134);
}
function FUN72(uint256 VAR97) private {
uint256 VAR146 = FUN42(VAR97);
uint256 VAR147 = FUN57(VAR97);
VAR85[VAR51][msg.sender] = VAR85[VAR51][msg.sender].FUN1(VAR97);
VAR73[VAR50] = VAR73[VAR50].FUN1(VAR97);
VAR75[VAR51] = VAR75[VAR51].FUN1(VAR146);
VAR76[VAR51] = VAR76[VAR51].FUN1(VAR147);
VAR61 = VAR61.FUN1(VAR147);
if (VAR68) {
for (uint16 VAR142 = 0; VAR142 < VAR70.VAR143; VAR142++) {
VAR86[VAR51][VAR71[VAR142]] = VAR86[VAR51][VAR71[VAR142]].FUN1(VAR97);
}
}
}
function FUN73(uint256 VAR19, uint256 VAR97) private returns (bool) {
VAR53 = VAR53.FUN1(1);
VAR56 = VAR56.FUN1(VAR19);
VAR74[VAR50] = VAR74[VAR50].FUN1(VAR19);
VAR78[msg.sender] = VAR78[msg.sender].FUN1(VAR19);
assert(VAR30.transfer(msg.sender, VAR19));
emit FUN28(VAR50, msg.sender, VAR19, VAR32, VAR97);
return true;
}
function FUN68(uint256 VAR19) private returns (bool) {
VAR54 = VAR54.FUN1(1);
VAR57 = VAR57.FUN1(VAR19);
VAR79[msg.sender] = VAR79[msg.sender].FUN1(VAR19);
assert(VAR30.transfer(msg.sender, VAR19));
emit FUN26(msg.sender, VAR19);
return true;
}
function FUN69(uint256 VAR19) private returns (bool) {
VAR55 = VAR55.FUN1(1);
VAR58 = VAR58.FUN1(VAR19);
VAR80[msg.sender] = VAR80[msg.sender].FUN1(VAR19);
assert(VAR30.transfer(msg.sender, VAR19));
emit FUN27(msg.sender, VAR19);
return true;
}
function FUN74() private returns (bool) {
emit FUN29(VAR50, msg.sender);
VAR50 = VAR50.FUN1(1);
VAR46 = FUN40(VAR50);
VAR67 = FUN56(VAR50);
uint16 VAR98 = FUN45(VAR50);
if (VAR51 < VAR98) {
emit FUN30(VAR51, msg.sender);
VAR51 = VAR98;
}
return true;
}
function FUN70(uint256 VAR148) private {
uint256 VAR99 = VAR148;
for (uint16 VAR142 = 0; VAR142 < VAR70.VAR143; VAR142++) {
uint256 VAR149 = VAR148.FUN3(VAR70[VAR142]).FUN4(100);
address payable VAR150 = address(FUN75(VAR71[VAR142]));
VAR60 = VAR60.FUN1(VAR149);
VAR82[VAR150] = VAR82[VAR150].FUN1(VAR149);
VAR99 = VAR99.FUN2(VAR149);
VAR150.transfer(VAR149);
}
if (VAR69 > 0)
VAR63 = VAR63.FUN1(VAR148.FUN3(VAR69).FUN4(100));
}
}
0
---------------------------------
310 0x007d42b9192b8c087b0d3e6ef73aae48e74b41c1.sol
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
contract VAR1 {
struct VAR2 {
address VAR3;
uint VAR4;
uint VAR5;
}
VAR2[] public VAR6;
uint public VAR7=0;
uint public VAR8=0;
uint public VAR9 = 0;
uint public VAR10=0;
uint public VAR11=0;
uint public VAR12=0;
string public VAR13="";
address public VAR14;
modifier VAR15 { if (msg.sender == VAR14) VAR16 }
function FUN1() {
VAR14 = msg.sender;
}
function() {
FUN2();
}
function FUN2() {
if (msg.value < 2 VAR17)
{
uint VAR18;
uint VAR19=msg.value;
VAR14.FUN3(VAR19/100);
VAR11+=VAR19/100;
VAR19-=VAR19/100;
if(VAR6.VAR20 !=0 && VAR19 !=0)
{
for(uint VAR21=0; VAR21<VAR6.VAR20;VAR21++)
{
VAR18 = VAR19 * VAR6[VAR21].VAR5 /10000000000;
VAR6[VAR21].VAR3.FUN3(VAR18);
VAR11 += VAR18;
VAR12+=VAR18;
}
VAR13="";
}
}
else
{
uint VAR4=msg.value;
VAR8 = VAR4 / 100;
VAR10+=VAR4;
VAR4-=VAR4/100;
VAR9 += VAR4;
bool VAR22 =false;
uint VAR23;
for(uint VAR24=0; VAR24<VAR6.VAR20;VAR24++)
{
if( msg.sender== VAR6[VAR24].VAR3)
{
VAR22=true;
VAR23=VAR24;
break;
}
}
if(VAR22==false)
{
VAR7=VAR6.VAR20+1;
VAR6.VAR20 += 1;
VAR6[VAR6.VAR20-1].VAR3 = msg.sender;
VAR6[VAR6.VAR20-1].VAR4 = VAR4;
VAR6[VAR6.VAR20-1].VAR5 = VAR4 /VAR10*10000000000;
VAR13="";
for(uint VAR25=0; VAR25<VAR6.VAR20;VAR25++)
{VAR6[VAR25].VAR5 = VAR6[VAR25].VAR4/VAR10*10000000000;}
}
else
{
VAR6[VAR23].VAR4 += VAR4;
VAR6[VAR23].VAR5 = VAR6[VAR23].VAR4/VAR10*10000000000;
}
if (VAR8 != 0)
{
VAR14.FUN3(VAR8);
VAR11+=VAR8;
}
}
}
function FUN4(address VAR26) VAR15
{
VAR14 = VAR26;
VAR13="";
}
function FUN5() VAR15
{
if(VAR9!=0)
{
VAR14.FUN3(VAR9);
VAR9=0;
VAR13="";
}
}
function FUN6(string VAR27) VAR15
{
VAR13 = VAR27;
}
function FUN7(address VAR28 , uint VAR29) VAR15
{
VAR10+=VAR29;
VAR7=VAR6.VAR20+1;
VAR6.VAR20 += 1;
VAR6[VAR6.VAR20-1].VAR3 = VAR28;
VAR6[VAR6.VAR20-1].VAR4 = VAR29;
VAR6[VAR6.VAR20-1].VAR5 = VAR29 /VAR10*10000000000;
VAR13="";
}
function FUN8() VAR15
{
VAR13 = "";
}
}
0
---------------------------------
311 0x0081138a2920c8aa793d02354678198c89c8c0c8.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29808000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x102f453c63C48803Dc12B19Ab184B9885810bf45;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
312 0x0085c150c1eb0e084e50a80bea91bc414aa6cbaa.sol
pragma solidity 0.5.7;
library VAR1 {
function FUN1(bytes32 VAR2, bytes memory VAR3) internal pure returns (address) {
if (VAR3.VAR4 != 65) {
return (address(0));
}
bytes32 VAR5;
bytes32 VAR6;
uint8 VAR7;
VAR8 {
VAR5 := FUN2(FUN3(VAR3, 0x20))
VAR6 := FUN2(FUN3(VAR3, 0x40))
VAR7 := FUN4(0, FUN2(FUN3(VAR3, 0x60)))
}
//
if (uint256(VAR6) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
return address(0);
}
if (VAR7 != 27 && VAR7 != 28) {
return address(0);
}
return FUN5(VAR2, VAR7, VAR5, VAR6);
}
function FUN6(bytes32 VAR2) internal pure returns (bytes32) {
return FUN7(VAR9.FUN8("", VAR2));
}
}
library VAR10 {
struct VAR11 {
mapping (address => bool) VAR12;
}
function FUN3(Role storage VAR13, address VAR14) internal {
require(VAR14 != address(0));
require(!FUN9(VAR13, VAR14));
VAR13.VAR12[VAR14] = true;
}
function FUN10(Role storage VAR13, address VAR14) internal {
require(VAR14 != address(0));
require(FUN9(VAR13, VAR14));
VAR13.VAR12[VAR14] = false;
}
function FUN9(Role storage VAR13, address VAR14) internal view returns (bool) {
require(VAR14 != address(0));
return VAR13.VAR12[VAR14];
}
}
contract VAR15 {
using Roles for VAR10.VAR11;
event FUN11(address indexed VAR14);
event FUN12(address indexed VAR14);
VAR10.Role private VAR16;
constructor() public {
VAR16.FUN3(msg.sender);
}
modifier FUN13() {
require(FUN14(msg.sender));
VAR17;
}
function FUN14(address VAR14) public view returns (bool) {
return VAR16.FUN9(VAR14);
}
function FUN15(address VAR14) public FUN13() {
VAR16.FUN3(VAR14);
emit FUN11(VAR14);
}
function FUN16(address VAR14) public FUN13() {
VAR16.FUN10(VAR14);
emit FUN12(VAR14);
}
}
contract MCHMetaMarking is VAR15 {
mapping(address => uint256) public VAR18;
struct VAR19 {
bool VAR20;
int64 VAR21;
uint32 VAR22;
int64 VAR23;
uint8 VAR24;
}
event FUN17(
address indexed VAR25,
int64 VAR21,
uint32 VAR22,
int64 VAR23,
uint8 VAR24
);
mapping(uint8 => address[]) public VAR26;
mapping(address => VAR19) public VAR27;
constructor() public {
FUN15(address(0x51C36baAa8b0e6CF45e2E1A77E84E3c0D1713F97));
}
function FUN18(address VAR28, int64 VAR29, uint32 VAR30, int64 VAR31,
uint8 VAR32, uint256 VAR33, address VAR34) public view returns (bytes32) {
return FUN7(VAR9.FUN19(
address(this),
VAR28,
VAR29,
VAR30,
VAR31,
VAR32,
VAR33,
VAR34
)
);
}
function FUN20(bytes32 VAR35) public pure returns (bytes32) {
return VAR1.FUN6(VAR35);
}
function FUN1(bytes32 VAR35, bytes memory VAR36) public pure returns (address) {
bytes32 VAR37 = VAR1.FUN6(VAR35);
return VAR1.FUN1(VAR37, VAR36);
}
function FUN21(address VAR28, int64 VAR29, uint32 VAR30, int64 VAR31,
uint8 VAR32, uint256 VAR33, bytes calldata VAR36) external FUN13() {
require(VAR18[VAR28]+1 == VAR33, "");
bytes32 VAR38 = FUN18(VAR28, VAR29, VAR30, VAR31, VAR32, VAR33, msg.sender);
address VAR39 = FUN1(VAR38, VAR36);
require(VAR39 == VAR28, "");
FUN22(VAR28, VAR29, VAR30, VAR31, VAR32);
VAR18[VAR28]++;
}
function FUN23(address VAR40, int64 VAR29, uint32 VAR30, int64 VAR31, uint8 VAR32) external FUN13() {
FUN22(VAR40, VAR29, VAR30, VAR31, VAR32);
}
function FUN22(address VAR40, int64 VAR29, uint32 VAR30, int64 VAR31, uint8 VAR32) private {
if (!VAR27[VAR40].VAR20) {
VAR27[VAR40] = FUN24(
true,
VAR29,
VAR30,
VAR31,
VAR32
);
VAR26[VAR32].FUN25(VAR40);
return;
}
uint8 VAR41 = VAR27[VAR40].VAR24;
if (VAR41 != VAR32) {
uint256 VAR42;
for (VAR42 = 0; VAR42 < VAR26[VAR32].VAR4; VAR42++) {
if (VAR26[VAR32][VAR42] != VAR40) {
break;
}
}
delete VAR26[VAR41][VAR42];
VAR26[VAR32].FUN25(VAR40);
}
VAR27[VAR40].VAR21 = VAR29;
VAR27[VAR40].VAR22 = VAR30;
VAR27[VAR40].VAR23 = VAR31;
VAR27[VAR40].VAR24 = VAR32;
emit FUN17(VAR40, VAR29, VAR30, VAR31, VAR32);
}
function FUN26(uint8 VAR32, int64 VAR43) public view returns (address[] VAR44){
if (VAR26[VAR32].VAR4 == 0) {
return new address[](0);
}
uint256 VAR45;
for (uint256 VAR42 = 0; VAR42 < VAR26[VAR32].VAR4; VAR42++) {
address VAR46 = VAR26[VAR32][VAR42];
if (VAR46 == address(0x0)) {
continue;
}
if (VAR27[VAR46].VAR21 >= VAR43) {
VAR45++;
}
}
address[] memory VAR47 = new address[](VAR45);
uint256 VAR48 = 0;
for (uint256 VAR42 = 0; VAR42 < VAR26[VAR32].VAR4; VAR42++) {
address VAR46 = VAR26[VAR32][VAR42];
if (VAR46 == address(0x0)) {
continue;
}
if (VAR27[VAR46].VAR21 >= VAR43) {
VAR47[VAR48] = VAR46;
VAR48++;
}
}
return VAR47;
}
function FUN27(address VAR28) external view returns (uint256 VAR49) {
return VAR18[VAR28];
}
function FUN28() external FUN13() {
FUN29(msg.sender);
}
}
0
---------------------------------
313 0x008f81cbd97a3f59291aa0fed45a42491f10cfd2.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30412800;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xF6f47Bc588007E357d35900B8a5Fa506d4D91A5c;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
314 0x0096c5d029a5bc353ad95ecd0297a1a54068ed53.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30240000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 =  0x3098990F9694D4E922D2320699825ef7e0cCB69F;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
315 0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1(address VAR3, uint VAR4, bytes VAR5) public returns (bool);
}
contract VAR6 {
function FUN2(address VAR7) public view returns (uint);
function transfer(address VAR8, uint VAR4) public returns (bool);
function FUN3(address VAR9, uint VAR10) public returns (bool);
}
contract Zethroll is VAR2 {
using SafeMath for uint;
modifier FUN4(uint VAR11, uint VAR12) {
require( FUN5(VAR11, VAR12) < VAR13
&& VAR11 >= VAR14
&& VAR12 > VAR15
&& VAR12 < VAR16);
VAR17;
}
modifier VAR18 {
require(VAR19 == false);
VAR17;
}
modifier onlyOwner {
require(msg.sender == VAR20);
VAR17;
}
uint constant private VAR21 = 2 ** 256 - 1;
uint constant public VAR22 = 1000000;
uint constant public VAR16 = 99;
uint constant public VAR15 = 2;
uint constant public VAR23 = 1000;
bool public VAR19;
address public VAR20;
address public VAR24;
address public VAR25;
ZTHInterface public VAR26;
uint public VAR27;
uint public VAR28;
uint public VAR13;
uint public VAR29;
uint public VAR14 = 0;
uint public VAR30;
uint public VAR31;
event FUN6(address sender, uint value, uint VAR32);
event FUN7(address VAR33, uint VAR34, uint VAR32, uint VAR35, uint VAR36, bool VAR37);
event FUN8(address indexed VAR38, uint indexed VAR39);
event FUN9(uint VAR40, uint VAR41);
event FUN10(uint VAR42);
constructor (address VAR43, address VAR44) public {
VAR20 = msg.sender;
VAR26 = FUN11(VAR43);
VAR25 = VAR43;
VAR24 = VAR44;
VAR28 = 990;
FUN12(10000);
FUN13(1e18);
VAR26.FUN3(VAR44, VAR21);
}
function() public payable {}
function FUN14(uint VAR45, address VAR46) public view returns (uint256 VAR47) {
return uint256(FUN15(
VAR48.FUN16(
FUN17(VAR45),
VAR46)
));
}
function FUN18(uint256 VAR49, uint256 VAR45, address VAR46) internal view returns (uint256 VAR47) {
return FUN14(VAR45, VAR46) % VAR49;
}
function FUN5(uint VAR50, uint VAR51)
private
view
returns (uint)
{
return ((((VAR50 * (100 - (VAR51.FUN19(1)))) / (VAR51.FUN19(1)) + VAR50)) * VAR28 / VAR23) - VAR50;
}
struct VAR52{
uint200 VAR53;
uint48 VAR45;
uint8 VAR32;
}
mapping(address => VAR52) public VAR54;
function FUN20(uint VAR55, TKN VAR56) private
VAR18
FUN4(VAR56.value, VAR55)
{
require(VAR56.value < ((2 ** 200) - 1));
require(VAR57.VAR58 < ((2 ** 48) - 1));
require(FUN21(msg.sender));
playerRoll memory VAR59 = VAR54[VAR56.sender];
require(VAR57.VAR58 != VAR59.VAR45);
if (VAR59.VAR45 != 0) {
FUN22(false, VAR56.sender);
}
VAR59.VAR45 = FUN23(VAR57.VAR58);
VAR59.VAR53 = FUN24(VAR56.value);
VAR59.VAR32 = uint8(VAR55);
VAR54[VAR56.sender] = VAR59;
emit FUN6(VAR56.sender, VAR56.value, VAR55);
VAR30 += 1;
VAR31 += VAR56.value;
}
function FUN25() public
VAR18
returns (uint)
{
return FUN22(true, msg.sender);
}
function FUN22(bool VAR60, address VAR61) private returns (uint){
playerRoll memory VAR59 = VAR54[VAR61];
require(VAR59.VAR53 > 0);
require(VAR59.VAR45 != VAR57.VAR58);
uint VAR34;
if (VAR57.VAR58 - VAR59.VAR45 > 255) {
VAR34 = 1000;
} else {
VAR34 = FUN18(99, VAR59.VAR45, VAR61) + 1;
}
uint VAR32 = VAR59.VAR32;
if (VAR34 < VAR32) {
uint VAR35 = FUN5(VAR59.VAR53, VAR32);
VAR27 = VAR27.FUN19(VAR35);
emit FUN7(VAR61, VAR34, VAR32, VAR35, VAR59.VAR53, true);
FUN26();
if (VAR60){
delete VAR54[VAR61];
}
VAR26.transfer(VAR61, VAR35 + VAR59.VAR53);
return VAR34;
} else {
emit FUN7(VAR61, VAR34, VAR32, VAR35, VAR59.VAR53, false);
VAR27 = VAR27.FUN27(VAR59.VAR53);
FUN26();
return VAR34;
}
}
struct VAR62 {address sender; uint value;}
function FUN1(address VAR3, uint VAR4, bytes VAR5) public returns (bool) {
require(msg.sender == VAR25);
if (VAR3 == VAR24) {
VAR27 = VAR27.FUN27(VAR4);
uint VAR63 = VAR13;
FUN26();
emit FUN9(VAR63, VAR13);
return true;
} else {
TKN memory VAR56;
VAR56.sender = VAR3;
VAR56.value = VAR4;
uint8 VAR64 = uint8(VAR5[0]);
FUN20(VAR64, VAR56);
}
return true;
}
function FUN26() internal {
emit FUN10(VAR27);
VAR13 = (VAR27 * VAR29) / VAR22;
}
function FUN28(uint VAR65) public
onlyOwner
{
VAR27 = VAR65;
}
function FUN12(uint VAR66) public
onlyOwner
{
require(VAR66 <= 200000);
VAR29 = VAR66;
FUN26();
}
function FUN13(uint VAR67) public
onlyOwner
{
VAR14 = VAR67;
}
function FUN29(address VAR68, uint VAR69) public
onlyOwner
{
VAR27 = VAR27.FUN19(VAR69);
FUN26();
require(VAR26.transfer(VAR68, VAR69));
emit FUN8(VAR68, VAR69);
}
function FUN30(bool VAR70) public
onlyOwner
{
VAR19 = VAR70;
}
function FUN31(address VAR71) public
onlyOwner
{
VAR26.FUN3(VAR24, 0);
VAR24 = VAR71;
VAR26.FUN3(VAR71, VAR21);
}
function FUN32(address VAR72) public
onlyOwner
{
VAR20 = VAR72;
}
function FUN33() public
onlyOwner
{
VAR26.transfer(VAR20, VAR27);
FUN34(VAR20);
}
function FUN35() public{
VAR24.transfer(address(this).VAR73);
}
function FUN21(address VAR74) private view returns (bool) {
return VAR74 == VAR25;
}
}
library VAR75 {
function FUN36(uint VAR76, uint VAR77) internal pure returns (uint) {
if (VAR76 == 0) {
return 0;
}
uint VAR78 = VAR76 * VAR77;
assert(VAR78 / VAR76 == VAR77);
return VAR78;
}
function FUN37(uint VAR76, uint VAR77) internal pure returns (uint) {
uint VAR78 = VAR76 / VAR77;
return VAR78;
}
function FUN19(uint VAR76, uint VAR77) internal pure returns (uint) {
assert(VAR77 <= VAR76);
return VAR76 - VAR77;
}
function FUN27(uint VAR76, uint VAR77) internal pure returns (uint) {
uint VAR78 = VAR76 + VAR77;
assert(VAR78 >= VAR76);
return VAR78;
}
}
0
---------------------------------
316 0x009c80eff4f5d8fca2b961ee607b00b9c64ef9f2.sol
pragma VAR1 ^ 0.5 .1;
contract VAR2 {
function FUN1(uint VAR3, uint VAR4) public pure returns(uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) public pure returns(uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) public pure returns(uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) public pure returns(uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
function FUN5(address VAR7, uint VAR8, bytes memory VAR9) public returns(bool);
}
contract VAR10 {
address public VAR11;
address public VAR12;
event FUN6(address indexed VAR7, address indexed VAR13);
constructor() public {
VAR11 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR11);
VAR14;
}
function FUN7(address VAR15) public onlyOwner {
VAR12 = VAR15;
}
function FUN8() public {
require(msg.sender == VAR12);
emit FUN6(VAR11, VAR12);
VAR11 = VAR12;
VAR12 = address(0);
}
}
contract STORH is VAR2, VAR10 {
event Transfer(address indexed VAR7, address indexed VAR13, uint256 VAR8, bytes VAR9);
event FUN9(
address indexed VAR7,
address VAR13,
uint VAR16
);
mapping(address => uint) VAR17;
mapping(address => bool) public VAR18;
string public VAR19 = "";
string public VAR20 = "";
uint8 public VAR21 = 4;
uint public VAR22;
uint public VAR23;
modifier FUN10(address VAR24) {
require(VAR18[msg.sender]);
require(VAR18[VAR24]);
VAR14;
}
modifier FUN11(uint value) {
if (VAR25 < (VAR23 + 365 VAR26) && msg.sender == VAR11) {
require(VAR17[VAR11] >= ((VAR22 * 5) / 100) + value);
}
VAR14;
}
constructor() public {
VAR17[msg.sender] = 1200000000000;
VAR22 = VAR17[msg.sender];
VAR18[msg.sender] = true;
VAR23 = VAR25;
}
function FUN12(address VAR27) public onlyOwner {
VAR18[VAR27] = true;
}
function FUN13(uint VAR28) public {
VAR23 = VAR28;
}
function FUN14(
address[] memory VAR29,
uint[] memory VAR30
) public {
for (uint VAR31 = 0; VAR31 < VAR29.VAR32; VAR31++) {
transfer(VAR29[VAR31], VAR30[VAR31]);
emit FUN9(
msg.sender,
VAR29[VAR31],
VAR30[VAR31]
);
}
}
function transfer(address VAR13, uint VAR8, bytes memory VAR9) public FUN10(VAR13) FUN11(VAR8) {
uint VAR33;
VAR34 {
VAR33: = FUN15(VAR13)
}
VAR17[msg.sender] = FUN2(VAR17[msg.sender], VAR8);
VAR17[VAR13] = FUN1(VAR17[VAR13], VAR8);
if (VAR33 > 0) {
ERC223ReceivingContract VAR35 = FUN16(VAR13);
if (!VAR35.FUN5(msg.sender, VAR8, VAR9)) revert();
}
emit Transfer(msg.sender, VAR13, VAR8, VAR9);
}
function transfer(address VAR13, uint VAR8) public FUN10(VAR13) FUN11(VAR8) {
uint VAR33;
bytes memory VAR36;
VAR34 {
VAR33: = FUN15(VAR13)
}
VAR17[msg.sender] = FUN2(VAR17[msg.sender], VAR8);
VAR17[VAR13] = FUN1(VAR17[VAR13], VAR8);
if (VAR33 > 0) {
ERC223ReceivingContract VAR35 = FUN16(VAR13);
if (!VAR35.FUN5(msg.sender, VAR8, VAR36)) revert();
}
emit Transfer(msg.sender, VAR13, VAR8, VAR36);
}
function FUN17(address VAR37) view public returns(uint VAR38) {
return VAR17[VAR37];
}
function FUN18() public onlyOwner {
FUN19(address(FUN20(VAR11)));
}
}
0
---------------------------------
317 0x00a4a3e9279678ca1b564bca66396bb5801192da.sol
pragma solidity 0.4.18;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
uint256 public VAR6;
function FUN5(address VAR7) public constant returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool);
event Transfer(address indexed VAR9, address indexed VAR8, uint256 value);
}
contract ERC20 is VAR5 {
function FUN6(address VAR10, address VAR11) public constant returns (uint256);
function FUN7(address VAR9, address VAR8, uint256 value) public returns (bool);
function FUN8(address VAR11, uint256 value) public returns (bool);
event FUN9(address indexed VAR10, address indexed VAR11, uint256 value);
}
contract BasicToken is VAR5 {
using SafeMath for uint256;
mapping(address => uint256) VAR12;
function transfer(address VAR13, uint256 VAR14) public returns (bool) {
require(VAR13 != address(0));
require(VAR14 <= VAR12[msg.sender]);
VAR12[msg.sender] = VAR12[msg.sender].FUN3(VAR14);
VAR12[VAR13] = VAR12[VAR13].FUN4(VAR14);
Transfer(msg.sender, VAR13, VAR14);
return true;
}
function FUN5(address VAR15) public constant returns (uint256 VAR16) {
return VAR12[VAR15];
}
}
contract StandardToken is VAR17, VAR18 {
mapping (address => mapping (address => uint256)) internal VAR19;
function FUN7(address VAR20, address VAR13, uint256 VAR14) public returns (bool) {
require(VAR13 != address(0));
require(VAR14 <= VAR12[VAR20]);
require(VAR14 <= VAR19[VAR20][msg.sender]);
VAR12[VAR20] = VAR12[VAR20].FUN3(VAR14);
VAR12[VAR13] = VAR12[VAR13].FUN4(VAR14);
VAR19[VAR20][msg.sender] = VAR19[VAR20][msg.sender].FUN3(VAR14);
Transfer(VAR20, VAR13, VAR14);
return true;
}
function FUN8(address VAR21, uint256 VAR14) public returns (bool) {
VAR19[msg.sender][VAR21] = VAR14;
FUN9(msg.sender, VAR21, VAR14);
return true;
}
function FUN6(address VAR15, address VAR21) public constant returns (uint256 VAR22) {
return VAR19[VAR15][VAR21];
}
function FUN10 (address VAR21, uint VAR23) public returns (bool VAR24) {
VAR19[msg.sender][VAR21] = VAR19[msg.sender][VAR21].FUN4(VAR23);
FUN9(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
function FUN11 (address VAR21, uint VAR25) public returns (bool VAR24) {
uint VAR26 = VAR19[msg.sender][VAR21];
if (VAR25 > VAR26) {
VAR19[msg.sender][VAR21] = 0;
} else {
VAR19[msg.sender][VAR21] = VAR26.FUN3(VAR25);
}
FUN9(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
}
contract VAR27 {
address public VAR10;
function FUN12() public {
VAR10 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR28;
}
function FUN13(address VAR29) public onlyOwner {
require(VAR29 != address(0));
VAR10 = VAR29;
}
}
contract BNIToken is VAR30, VAR27
{
string public VAR31 = "";
string public VAR32 = "";
uint public VAR33 = 2;
uint private constant VAR34 = 10 * 10**(9+2);
function FUN14() public
{
VAR10 = msg.sender;
VAR6 = VAR34;
VAR12[VAR10] = VAR34;
}
}
0
---------------------------------
318 0x00ad1ae81accb071bdf654633727e6ecda5672b3.sol
pragma solidity 0.4.19;
contract VAR1 {
using SafeMath for uint256;
event FUN1(
uint VAR2,
uint VAR3,
uint VAR4
);
event FUN2(
uint VAR2,
address VAR5,
uint VAR6,
uint VAR7
);
event FUN3(
uint VAR2,
address VAR5,
uint VAR7,
uint VAR8
);
event FUN4(
uint VAR2,
address VAR5,
uint VAR9,
uint VAR10
);
event FUN5(
uint VAR2,
address VAR5,
uint VAR6
);
event FUN6(
uint VAR2,
address VAR5,
uint VAR11,
uint VAR6,
uint VAR12,
uint VAR13
);
uint public constant VAR14 = 1 VAR15;
uint public constant VAR16 = 1 VAR17;
uint public constant VAR18 = 30 VAR17;
uint public constant VAR19 = 1;
uint public constant VAR20 = 1000000;
uint public constant VAR21 = 40;
uint public constant VAR22 = 100;
uint public constant VAR23 = 15;
uint public constant VAR24 = 100;
address VAR25;
mapping(address => uint) public VAR26;
mapping(address => uint) public VAR27;
uint public VAR28;
uint public VAR29;
uint public VAR30;
uint public VAR31;
address public VAR32;
uint public VAR33;
function FUN7() public payable {
require(msg.value > 0);
VAR25 = msg.sender;
VAR30 = 1;
VAR31 = msg.value;
VAR32 = VAR25;
VAR33 = FUN8();
FUN1(VAR34, VAR30, VAR31);
FUN3(VAR34, VAR32, VAR31, VAR33);
}
function FUN8() internal view returns (uint) {
uint VAR35 = VAR16.FUN9(VAR31.FUN10(1 VAR36));
uint VAR37;
if (VAR18.FUN11(VAR35) > VAR14) {
VAR37 = VAR18;
} else {
VAR37 = VAR14.FUN12(VAR35);
}
return VAR34.FUN11(VAR37);
}
modifier VAR38 {
if (VAR34 > VAR33) {
uint VAR39 = 0;
uint VAR40 = VAR31.FUN12(VAR39);
FUN4(VAR34, VAR32, VAR40, VAR33);
VAR26[VAR32] = VAR26[VAR32].FUN11(VAR40);
VAR30++;
VAR31 = VAR39;
VAR32 = VAR25;
VAR33 = FUN8();
FUN1(VAR34, VAR30, VAR31);
FUN3(VAR34, VAR32, VAR31, VAR33);
}
VAR41;
}
function FUN13() public payable VAR38 {
uint VAR42 = VAR31.FUN9(VAR19).FUN10(VAR20);
uint VAR43 = msg.value.FUN9(VAR23).FUN10(VAR24);
uint VAR44 = msg.value.FUN9(VAR21).FUN10(VAR22);
uint VAR45 = msg.value.FUN12(VAR43).FUN12(VAR44);
VAR26[VAR25] = VAR26[VAR25].FUN11(VAR43);
VAR29 = VAR29.FUN11(VAR44);
VAR31 = VAR31.FUN11(VAR45);
FUN2(VAR34, msg.sender, msg.value, VAR31);
if (msg.value >= VAR42) {
uint VAR11 = msg.value.FUN10(VAR42);
VAR27[msg.sender] = VAR27[msg.sender].FUN11(VAR11);
VAR28 = VAR28.FUN11(VAR11);
VAR32 = msg.sender;
VAR33 = FUN8();
FUN3(VAR34, VAR32, VAR31, VAR33);
}
}
function FUN14() public VAR38 {
require(VAR26[msg.sender] > 0);
assert(VAR26[msg.sender] <= this.VAR46);
uint VAR6 = VAR26[msg.sender];
VAR26[msg.sender] = 0;
msg.sender.transfer(VAR6);
FUN5(VAR34, msg.sender, VAR6);
}
function FUN15() public {
require(VAR27[msg.sender] > 0);
uint VAR11 = VAR27[msg.sender];
assert(VAR11 <= VAR28);
uint VAR6 = VAR29.FUN9(VAR11).FUN10(VAR28);
assert(VAR6 <= this.VAR46);
VAR27[msg.sender] = 0;
VAR28 = VAR28.FUN12(VAR11);
VAR29 = VAR29.FUN12(VAR6);
msg.sender.transfer(VAR6);
FUN6(VAR34, msg.sender, VAR11, VAR6, VAR28, VAR29);
}
}
library VAR47 {
function FUN9(uint256 VAR48, uint256 VAR49) internal pure returns (uint256) {
if (VAR48 == 0) {
return 0;
}
uint256 VAR50 = VAR48 * VAR49;
assert(VAR50 / VAR48 == VAR49);
return VAR50;
}
function FUN10(uint256 VAR48, uint256 VAR49) internal pure returns (uint256) {
uint256 VAR50 = VAR48 / VAR49;
return VAR50;
}
function FUN12(uint256 VAR48, uint256 VAR49) internal pure returns (uint256) {
assert(VAR49 <= VAR48);
return VAR48 - VAR49;
}
function FUN11(uint256 VAR48, uint256 VAR49) internal pure returns (uint256) {
uint256 VAR50 = VAR48 + VAR49;
assert(VAR50 >= VAR48);
return VAR50;
}
}
0
---------------------------------
319 0x00b113a5570a046c60ac8cfa4983b1dc1c780629.sol
pragma VAR1 >=0.5.4 <0.6.0;
interface VAR2 { function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external; }
library VAR7 {
function FUN2(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
if (VAR8 == 0) {
return 0;
}
VAR10 = VAR8 * VAR9;
assert(VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN3(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
return VAR8 / VAR9;
}
function FUN4(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
assert(VAR9 <= VAR8);
return VAR8 - VAR9;
}
function FUN5(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
VAR10 = VAR8 + VAR9;
assert(VAR10 >= VAR8);
return VAR10;
}
}
interface VAR11 {
function FUN6(address VAR12, address VAR13) external view returns (bool);
function FUN7(address VAR12, address VAR13) external view returns (bool);
function FUN8(address VAR12, address VAR13) external view returns (bool);
function FUN9(address VAR12, address VAR13) external view returns (bool);
function FUN10(address VAR13) external view returns (address);
function FUN11(address VAR14, address VAR13) external view returns (bool);
function FUN12(address VAR14, address VAR13) external view returns (bool);
function FUN13(address VAR13, address VAR15, address VAR16, address VAR17) external returns (bool);
function FUN14(address VAR12, address VAR13) external view returns (uint256);
}
interface VAR18 {
function FUN15(string calldata VAR19) external view returns (bool);
function FUN13(string calldata VAR19, address VAR20, uint256 VAR21, string calldata VAR22, address VAR23, uint256 VAR24) external returns (bool);
function FUN16(address VAR13) external view returns (string VAR25, address, uint256, string VAR25, address, uint256);
function FUN17(string calldata VAR19) external view returns (address);
}
contract VAR26 {
address public VAR27;
address public VAR28;
mapping (address => bool) public VAR29;
constructor() public {
VAR27 = msg.sender;
}
modifier FUN18() {
require (VAR29[msg.sender] == true);
VAR30;
}
function FUN19(address VAR31) public {
require (msg.sender == VAR27);
require (VAR31 != address(0));
VAR27 = VAR31;
}
function FUN20(address VAR32, bool VAR33) public {
require (msg.sender == VAR27);
require (VAR32 != address(0));
VAR29[VAR32] = VAR33;
}
}
contract VAR34 {
string public VAR35;
string public VAR36;
uint8 public VAR37 = 18;
uint256 public VAR38;
mapping (address => uint256) public VAR39;
mapping (address => mapping (address => uint256)) public VAR40;
event Transfer(address indexed VAR41, address indexed VAR42, uint256 value);
event FUN21(address indexed VAR43, address indexed VAR44, uint256 VAR4);
event FUN22(address indexed VAR41, uint256 value);
constructor (uint256 VAR45, string memory VAR46, string memory VAR47) public {
VAR38 = VAR45 * 10 ** uint256(VAR37);
VAR39[msg.sender] = VAR38;
VAR35 = VAR46;
VAR36 = VAR47;
}
function FUN23(address VAR3, address VAR48, uint VAR4) internal {
require(VAR48 != address(0));
require(VAR39[VAR3] >= VAR4);
require(VAR39[VAR48] + VAR4 > VAR39[VAR48]);
uint VAR49 = VAR39[VAR3] + VAR39[VAR48];
VAR39[VAR3] -= VAR4;
VAR39[VAR48] += VAR4;
emit Transfer(VAR3, VAR48, VAR4);
assert(VAR39[VAR3] + VAR39[VAR48] == VAR49);
}
function transfer(address VAR48, uint256 VAR4) public returns (bool VAR50) {
FUN23(msg.sender, VAR48, VAR4);
return true;
}
function FUN24(address VAR3, address VAR48, uint256 VAR4) public returns (bool VAR50) {
require(VAR4 <= VAR40[VAR3][msg.sender]);
VAR40[VAR3][msg.sender] -= VAR4;
FUN23(VAR3, VAR48, VAR4);
return true;
}
function FUN25(address VAR44, uint256 VAR4) public returns (bool VAR50) {
VAR40[msg.sender][VAR44] = VAR4;
emit FUN21(msg.sender, VAR44, VAR4);
return true;
}
function FUN26(address VAR44, uint256 VAR4, bytes memory VAR6) public returns (bool VAR50) {
tokenRecipient VAR51 = FUN27(VAR44);
if (FUN25(VAR44, VAR4)) {
VAR51.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN28(uint256 VAR4) public returns (bool VAR50) {
require(VAR39[msg.sender] >= VAR4);
VAR39[msg.sender] -= VAR4;
VAR38 -= VAR4;
emit FUN22(msg.sender, VAR4);
return true;
}
function FUN29(address VAR3, uint256 VAR4) public returns (bool VAR50) {
require(VAR39[VAR3] >= VAR4);
require(VAR4 <= VAR40[VAR3][msg.sender]);
VAR39[VAR3] -= VAR4;
VAR40[VAR3][msg.sender] -= VAR4;
VAR38 -= VAR4;
emit FUN22(VAR3, VAR4);
return true;
}
}
contract VAR52 {
using SafeMath for uint256;
address public VAR53;
string public VAR35;
address public VAR54;
string public VAR55;
string public VAR56;
string public VAR57;
bytes32 public VAR58;
uint8 public VAR59;
constructor (string memory VAR19,
address VAR60,
string memory VAR61,
string memory VAR62,
string memory VAR63,
bytes32 VAR64,
address VAR65
) public {
VAR35 = VAR19;
VAR54 = VAR60;
VAR55 = VAR61;
VAR56 = VAR62;
VAR57 = VAR63;
VAR58 = VAR64;
VAR59 = 0;
VAR53 = VAR65;
}
modifier VAR66 {
require (msg.sender == VAR53);
VAR30;
}
function () external payable {
}
function FUN30(address payable VAR67, uint256 VAR68) public onlyVault returns (bool) {
VAR67.transfer(VAR68);
return true;
}
function FUN31(address VAR69, address VAR67, uint256 VAR68) public onlyVault returns (bool) {
TokenERC20 VAR70 = FUN32(VAR69);
VAR70.transfer(VAR67, VAR68);
return true;
}
}
contract Name is VAR52 {
constructor (string memory VAR19, address VAR60, string memory VAR61, string memory VAR62, string memory VAR63, bytes32 VAR64, address VAR65)
FUN33 (VAR19, VAR60, VAR61, VAR62, VAR63, VAR64, VAR65) public {
VAR59 = 1;
}
}
library VAR71 {
using SafeMath for uint256;
uint256 constant private VAR72 = 10 ** 6;
uint256 constant private VAR73 = 10 ** 6;
function FUN34(address VAR74) public view returns (bool) {
return (VAR74 != address(0) && bytes(FUN33(address(FUN35(VAR74))).FUN36()).VAR75 > 0 && FUN33(address(FUN35(VAR74))).FUN37() != address(0) && FUN33(address(FUN35(VAR74))).FUN38() == 0);
}
function FUN39(address VAR14) public view returns (bool) {
return (VAR14 != address(0) && bytes(FUN33(address(FUN35(VAR14))).FUN36()).VAR75 > 0 && FUN40(address(FUN35(VAR14))).FUN37() != address(0) && FUN40(address(FUN35(VAR14))).FUN38() == 1);
}
function FUN41(address VAR76) public view returns (bool) {
if (VAR76 == address(0)) {
return false;
}
TokenERC20 VAR70 = FUN32(VAR76);
return (VAR70.FUN42() >= 0 && bytes(VAR70.FUN36()).VAR75 > 0 && bytes(VAR70.FUN43()).VAR75 > 0);
}
function FUN44(address VAR12, address VAR31, address VAR77) public view returns (bool) {
return (VAR12 == VAR31 ||
(
(FUN34(VAR31) || FUN39(VAR31)) &&
VAR77 != address(0) &&
FUN45(VAR77).FUN6(VAR12, VAR31)
)
);
}
function FUN46() public pure returns (uint256) {
return VAR73;
}
function FUN47() public pure returns (uint256) {
return VAR72;
}
function FUN48(string memory VAR19,
address VAR60,
string memory VAR61,
string memory VAR62,
string memory VAR63,
bytes32 VAR64,
address VAR78
) public returns (TAO VAR79) {
VAR79 = VAR80 FUN33(VAR19, VAR60, VAR61, VAR62, VAR63, VAR64, VAR78);
}
function FUN49(string memory VAR19,
address VAR60,
string memory VAR61,
string memory VAR62,
string memory VAR63,
bytes32 VAR64,
address VAR78
) public returns (Name VAR81) {
VAR81 = VAR80 FUN40(VAR19, VAR60, VAR61, VAR62, VAR63, VAR64, VAR78);
}
function FUN50(uint256 VAR82, uint256 VAR83, uint256 VAR84, uint256 VAR85) public pure returns (uint256) {
if (VAR82 > 0) {
uint256 VAR86 = (VAR82.FUN2(VAR83)).FUN5(VAR84.FUN2(VAR85));
uint256 VAR87 = VAR83.FUN5(VAR85);
return VAR86.FUN3(VAR87);
} else {
return VAR84;
}
}
function FUN51(uint256 VAR88, uint256 VAR89, uint256 VAR90, uint256 VAR91, uint256 VAR92) public pure returns (uint256) {
if (VAR88 > 0 && VAR88 <= VAR89.FUN4(VAR90)) {
uint256 VAR93 = VAR90.FUN5(VAR88.FUN3(2));
uint256 VAR94 = (VAR72.FUN4(VAR72.FUN2(VAR93).FUN3(VAR89))).FUN2(VAR91.FUN4(VAR92));
return VAR94.FUN3(VAR72);
} else {
return 0;
}
}
function FUN52(uint256 VAR88, uint256 VAR89, uint256 VAR90, uint256 VAR91, uint256 VAR92) public pure returns (uint256) {
if (VAR88 > 0 && VAR88 <= VAR89.FUN4(VAR90)) {
uint256 VAR93 = VAR90.FUN5(VAR88.FUN3(2));
uint256 VAR95 = (VAR73.FUN4(VAR73.FUN2(VAR93).FUN3(VAR89))).FUN2(VAR91.FUN4(VAR92)).FUN3(VAR73);
return VAR95;
} else {
return 0;
}
}
function FUN53(uint256 VAR88, uint256 VAR89, uint256 VAR90, uint256 VAR91, uint256 VAR92) public pure returns (uint256) {
uint256 VAR95 = FUN52(VAR88, VAR89, VAR90, VAR91, VAR92);
uint256 VAR96 = VAR95.FUN2(VAR88).FUN3(VAR73);
return VAR96;
}
function FUN54(uint256 VAR97, uint256 VAR82, uint256 VAR98) public pure returns (uint256) {
return (VAR98.FUN2(VAR97).FUN4(VAR97.FUN2(VAR82))).FUN3(VAR98);
}
function FUN55(uint256 VAR97, uint256 VAR82, uint256 VAR99) public pure returns (uint256) {
return VAR97.FUN2(VAR82).FUN3(VAR97.FUN4(VAR99));
}
function FUN56(uint256 VAR97, uint256 VAR82, uint256 VAR100) public pure returns (uint256) {
return VAR97.FUN2(VAR82).FUN3(VAR97.FUN5(VAR100));
}
function FUN57(uint256 VAR101) public pure returns (uint8) {
uint8 VAR102 = 0;
while(VAR101 != 0) {
VAR101 = VAR101.FUN3(10);
VAR102++;
}
return VAR102;
}
}
contract NameTAOLookup is VAR26, VAR18 {
address public VAR103;
address public VAR104;
struct VAR105 {
string VAR35;
address VAR106;
uint256 VAR59;
string VAR107;
address VAR108;
uint256 VAR109;
}
uint256 public VAR110;
uint256 public VAR111;
mapping (address => VAR105) internal VAR112;
mapping (bytes32 => address) internal VAR113;
constructor(address VAR114, address VAR115, address VAR77) public {
FUN58(VAR114);
FUN59(VAR115);
FUN60(VAR77);
}
modifier VAR116 {
require (VAR71.FUN44(msg.sender, VAR27, VAR28));
VAR30;
}
modifier VAR117 {
require (msg.sender == VAR103 || msg.sender == VAR104);
VAR30;
}
function FUN19(address VAR31) public VAR116 {
require (VAR31 != address(0));
VAR27 = VAR31;
}
function FUN20(address VAR32, bool VAR33) public VAR116 {
require (VAR32 != address(0));
VAR29[VAR32] = VAR33;
}
function FUN58(address VAR114) public VAR116 {
require (VAR114 != address(0));
VAR103 = VAR114;
}
function FUN59(address VAR115) public VAR116 {
require (VAR115 != address(0));
VAR104 = VAR115;
}
function FUN60(address VAR77) public VAR116 {
require (VAR77 != address(0));
VAR28 = VAR77;
}
function FUN15(string calldata VAR19) external view returns (bool) {
bytes32 VAR118 = FUN61(VAR119.FUN62(VAR19));
return (VAR113[VAR118] != address(0));
}
function FUN13(string calldata VAR19, address VAR20, uint256 VAR21, string calldata VAR22, address VAR23, uint256 VAR24) external onlyFactory returns (bool) {
require (bytes(VAR19).VAR75 > 0);
require (VAR20 != address(0));
require (VAR21 == 0 || VAR21 == 1);
require (bytes(VAR22).VAR75 > 0);
require (VAR23 != address(0));
require (VAR24 >= 0 && VAR24 <= 2);
require (!this.FUN15(VAR19));
if (VAR24 != 2) {
require (this.FUN15(VAR22));
}
bytes32 VAR118 = FUN61(VAR119.FUN62(VAR19));
VAR113[VAR118] = VAR20;
NameTAOInfo storage VAR120 = VAR112[VAR20];
VAR120.VAR35 = VAR19;
VAR120.VAR106 = VAR20;
VAR120.VAR59 = VAR21;
VAR120.VAR107 = VAR22;
VAR120.VAR108 = VAR23;
VAR120.VAR109 = VAR24;
if (VAR21 == 0) {
VAR111++;
} else {
VAR110++;
}
return true;
}
function FUN63(string memory VAR19) public view returns (string VAR25, address, uint256, string VAR25, address, uint256) {
require (this.FUN15(VAR19));
bytes32 VAR118 = FUN61(VAR119.FUN62(VAR19));
NameTAOInfo memory VAR120 = VAR112[VAR113[VAR118]];
return (
VAR120.VAR35,
VAR120.VAR106,
VAR120.VAR59,
VAR120.VAR107,
VAR120.VAR108,
VAR120.VAR109
);
}
function FUN16(address VAR13) external view returns (string VAR25, address, uint256, string VAR25, address, uint256) {
require (VAR112[VAR13].VAR106 != address(0));
NameTAOInfo memory VAR120 = VAR112[VAR13];
return (
VAR120.VAR35,
VAR120.VAR106,
VAR120.VAR59,
VAR120.VAR107,
VAR120.VAR108,
VAR120.VAR109
);
}
function FUN17(string calldata VAR19) external view returns (address) {
bytes32 VAR118 = FUN61(VAR119.FUN62(VAR19));
return VAR113[VAR118];
}
}
0
---------------------------------
320 0x00bbe94541b9c62aa09e59e55af5a6a22c16f2cc.sol
pragma solidity 0.4.18;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
if(VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns(uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
address public VAR6;
event FUN5(address indexed VAR7, address indexed VAR8);
modifier onlyOwner() { require(msg.sender == VAR6); VAR9; }
function FUN6() public {
VAR6 = msg.sender;
}
function FUN7(address VAR8) public onlyOwner {
require(VAR8 != address(0));
FUN5(VAR6, VAR8);
VAR6 = VAR8;
}
}
contract Pausable is VAR5 {
bool public VAR10 = false;
event FUN8();
event FUN9();
modifier FUN10() { require(!VAR10); VAR9; }
modifier FUN11() { require(VAR10); VAR9; }
function FUN12() onlyOwner whenNotPaused public {
VAR10 = true;
FUN8();
}
function FUN13() onlyOwner whenPaused public {
VAR10 = false;
FUN9();
}
}
contract VAR11 {
uint256 public VAR12;
event Transfer(address indexed VAR13, address indexed VAR14, uint256 value);
event FUN14(address indexed VAR6, address indexed VAR15, uint256 value);
function FUN15(address VAR16) public view returns(uint256);
function transfer(address VAR14, uint256 value) public returns(bool);
function FUN16(address VAR13, address VAR14, uint256 value) public returns(bool);
function FUN17(address VAR6, address VAR15) public view returns(uint256);
function FUN18(address VAR15, uint256 value) public returns(bool);
}
contract StandardToken is VAR11 {
using SafeMath for uint256;
mapping(address => uint256) VAR17;
mapping (address => mapping (address => uint256)) internal VAR18;
function FUN15(address VAR19) public view returns(uint256 VAR20) {
return VAR17[VAR19];
}
function transfer(address VAR21, uint256 VAR22) public returns(bool) {
require(VAR21 != address(0));
require(VAR22 <= VAR17[msg.sender]);
VAR17[msg.sender] = VAR17[msg.sender].FUN3(VAR22);
VAR17[VAR21] = VAR17[VAR21].FUN4(VAR22);
Transfer(msg.sender, VAR21, VAR22);
return true;
}
function FUN19(address[] VAR21, uint256[] VAR22) public returns(bool) {
require(VAR21.VAR23 == VAR22.VAR23);
for(uint VAR24 = 0; VAR24 < VAR21.VAR23; VAR24++) {
transfer(VAR21[VAR24], VAR22[VAR24]);
}
return true;
}
function FUN16(address VAR25, address VAR21, uint256 VAR22) public returns(bool) {
require(VAR21 != address(0));
require(VAR22 <= VAR17[VAR25]);
require(VAR22 <= VAR18[VAR25][msg.sender]);
VAR17[VAR25] = VAR17[VAR25].FUN3(VAR22);
VAR17[VAR21] = VAR17[VAR21].FUN4(VAR22);
VAR18[VAR25][msg.sender] = VAR18[VAR25][msg.sender].FUN3(VAR22);
Transfer(VAR25, VAR21, VAR22);
return true;
}
function FUN17(address VAR19, address VAR26) public view returns(uint256) {
return VAR18[VAR19][VAR26];
}
function FUN18(address VAR26, uint256 VAR22) public returns(bool) {
VAR18[msg.sender][VAR26] = VAR22;
FUN14(msg.sender, VAR26, VAR22);
return true;
}
function FUN20(address VAR26, uint VAR27) public returns(bool) {
VAR18[msg.sender][VAR26] = VAR18[msg.sender][VAR26].FUN4(VAR27);
FUN14(msg.sender, VAR26, VAR18[msg.sender][VAR26]);
return true;
}
function FUN21(address VAR26, uint VAR28) public returns(bool) {
uint VAR29 = VAR18[msg.sender][VAR26];
if(VAR28 > VAR29) {
VAR18[msg.sender][VAR26] = 0;
} else {
VAR18[msg.sender][VAR26] = VAR29.FUN3(VAR28);
}
FUN14(msg.sender, VAR26, VAR18[msg.sender][VAR26]);
return true;
}
}
contract MintableToken is VAR30, VAR5 {
event FUN22(address indexed VAR14, uint256 VAR31);
event FUN23();
bool public VAR32 = false;
modifier FUN24() { require(!VAR32); VAR9; }
function FUN25(address VAR21, uint256 VAR33) onlyOwner canMint public returns(bool) {
VAR12 = VAR12.FUN4(VAR33);
VAR17[VAR21] = VAR17[VAR21].FUN4(VAR33);
FUN22(VAR21, VAR33);
Transfer(address(0), VAR21, VAR33);
return true;
}
function FUN26() onlyOwner canMint public returns(bool) {
VAR32 = true;
FUN23();
return true;
}
}
contract CappedToken is VAR34 {
uint256 public VAR35;
function FUN27(uint256 VAR36) public {
require(VAR36 > 0);
VAR35 = VAR36;
}
function FUN25(address VAR21, uint256 VAR33) onlyOwner canMint public returns(bool) {
require(VAR12.FUN4(VAR33) <= VAR35);
return super.FUN25(VAR21, VAR33);
}
}
contract Token is VAR37 {
string public VAR38 = "";
string public VAR39 = "";
uint256 public VAR40 = 18;
function FUN28() FUN27(3000000000 * 1 VAR41) public {
}
}
contract PreICO is VAR42 {
using SafeMath for uint;
Token public VAR43;
address public VAR44 = 0xd2F04a987C17EEd55e8AFF25CADccF3D2D2CE845;
uint public VAR45;
uint public VAR46;
uint public VAR47 = 108000000 * 1 VAR41;
uint public VAR48 = 1 VAR41;
bool public VAR49 = false;
event FUN29(uint256 VAR50);
event FUN30(address indexed VAR51, uint256 VAR52, uint256 VAR53);
event FUN31();
function FUN32() public {
VAR43 = VAR54 FUN28();
FUN33(8400);
}
function() payable public {
FUN34();
}
function FUN33(uint VAR22) onlyOwner public {
require(!VAR49);
VAR48 = 1 VAR41 / VAR22;
FUN29(VAR48);
}
function FUN34() whenNotPaused payable public {
require(!VAR49);
require(VAR46 < VAR47);
require(msg.value >= 0.001 VAR41);
uint VAR55 = msg.value;
uint VAR31 = VAR55.FUN1(1 VAR41).FUN2(VAR48);
uint VAR56 = 0;
if(VAR46.FUN4(VAR31) > VAR47) {
uint VAR57 = VAR46.FUN4(VAR31).FUN3(VAR47);
VAR56 = VAR57.FUN1(VAR48).FUN2(1 VAR41);
VAR31 = VAR31.FUN3(VAR57);
VAR55 = VAR55.FUN3(VAR56);
}
VAR46 = VAR46.FUN4(VAR31);
VAR45 = VAR45.FUN4(VAR55);
VAR44.transfer(VAR55);
VAR43.FUN25(msg.sender, VAR31);
if(VAR56 > 0) {
msg.sender.transfer(VAR56);
}
FUN30(msg.sender, VAR31, VAR55);
}
function FUN35() onlyOwner public {
require(!VAR49);
VAR43.FUN7(VAR44);
VAR49 = true;
FUN31();
}
}
0
---------------------------------
321 0x00be721be5e52da3a7e3e3e1dd871bbc5e1c17fb.sol
pragma VAR1 ^0.4.17;
contract VAR2{
uint16 public VAR3 = 0;
bytes32 public VAR4;
address public VAR5;
mapping (uint16 => bytes32) public VAR6;
function FUN1() public {
VAR5 = msg.sender;
VAR4 = FUN2(VAR7.VAR8, VAR9);
}
function FUN3(bytes32 VAR10) internal {
VAR3 = VAR3 + 1;
VAR4 = FUN2(VAR7.VAR8,VAR9,VAR10);
VAR6[VAR3] = VAR4;
}
function FUN4(bytes32 VAR10) public {
if(VAR5 != msg.sender) revert();
FUN3(VAR10);
}
function FUN5 (uint16 VAR11) constant returns (bytes32){
return VAR6[VAR11];
}
function () payable {
FUN3(bytes32(msg.value));
}
}
0
---------------------------------
322 0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
bytes32 public VAR3;
bytes32 public VAR4;
bytes32 public VAR5;
uint256 public VAR6;
uint8 public VAR7;
bool public VAR8;
mapping (address => uint256) public VAR9;
mapping (address => mapping (address => uint256)) public VAR10;
function transfer(address VAR11, uint256 VAR12)public returns (bool VAR13);
function FUN1(address VAR14, uint256 VAR12, bytes VAR15) public returns (bool VAR13);
function FUN2(address VAR14, uint256 VAR12) public returns (bool VAR13);
function FUN3(address VAR16, address VAR11, uint256 VAR12) public returns (bool VAR13);
}
contract VAR17 {
function FUN4(uint256 VAR18, uint256 VAR19) internal pure returns (uint256 VAR20) {
if (VAR18 == 0) {
return 0;
}
VAR20 = VAR18 * VAR19;
assert(VAR20 / VAR18 == VAR19);
return VAR20;
}
function FUN5(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
return VAR18 / VAR19;
}
function FUN6(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
assert(VAR19 <= VAR18);
return VAR18 - VAR19;
}
function FUN7(uint256 VAR18, uint256 VAR19) internal pure returns (uint256 VAR20) {
VAR20 = VAR18 + VAR19;
assert(VAR20 >= VAR18);
return VAR20;
}
}
contract IMDEXDexchange is VAR17 {
address public VAR21;
address VAR22 = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd;
mapping (address => uint256) public VAR23;
event FUN8(address indexed VAR24, address indexed VAR25);
modifier onlyOwner {
require(msg.sender == VAR21);
VAR26;
}
function FUN9(address VAR25)public onlyOwner {
emit FUN8(VAR21, VAR25);
VAR21 = VAR25;
}
function FUN10(address VAR27, uint256 VAR28) public onlyAdmin {
require(VAR28 > VAR23[VAR27]);
VAR23[VAR27] = VAR28;
}
mapping (address => mapping (address => uint256)) public VAR29;
mapping (address => bool) public VAR30;
mapping (address => uint256) public VAR31;
address public VAR32;
uint256 public VAR33;
event FUN11(address VAR34, uint256 VAR35, address VAR36, uint256 VAR37, address VAR38, address VAR39);
event FUN12(address VAR40, address VAR27, uint256 VAR41, uint256 VAR42);
event FUN13(address VAR40, address VAR27, uint256 VAR41, uint256 VAR42);
function FUN14(uint256 VAR43) public onlyAdmin returns (bool VAR13) {
require(VAR43 < 1000000);
VAR33 = VAR43;
return true;
}
constructor(address VAR44) public {
VAR21 = msg.sender;
VAR32 = VAR44;
VAR33 = 100000;
}
function FUN15(address VAR45, bool VAR46) public onlyOwner {
VAR30[VAR45] = VAR46;
}
modifier onlyAdmin {
require(msg.sender == VAR21 && VAR30[msg.sender]);
VAR26;
}
function() external {
revert();
}
function FUN16(address VAR40, uint256 VAR41) public {
VAR29[VAR40][msg.sender] = FUN7(VAR29[VAR40][msg.sender], VAR41);
VAR31[msg.sender] = VAR47.VAR48;
require(FUN17(VAR40).FUN3(msg.sender, this, VAR41));
emit FUN12(VAR40, msg.sender, VAR41, VAR29[VAR40][msg.sender]);
}
function FUN18() public payable {
VAR29[address(0)][msg.sender] = FUN7(VAR29[address(0)][msg.sender], msg.value);
VAR31[msg.sender] = VAR47.VAR48;
emit FUN12(address(0), msg.sender, msg.value, VAR29[address(0)][msg.sender]);
}
function FUN19(address VAR40, uint256 VAR41) public returns (bool) {
require(FUN6(VAR47.VAR48, VAR31[msg.sender]) > VAR33);
require(VAR29[VAR40][msg.sender] > VAR41);
VAR29[VAR40][msg.sender] = FUN6(VAR29[VAR40][msg.sender], VAR41);
if (VAR40 == address(0)) {
msg.sender.transfer(VAR41);
} else {
require(FUN17(VAR40).transfer(msg.sender, VAR41));
}
emit FUN13(VAR40, msg.sender, VAR41, VAR29[VAR40][msg.sender]);
}
function FUN20(address VAR40, uint256 VAR41, address VAR27, uint256 VAR49) public onlyAdmin returns (bool) {
if (VAR49 > 50 VAR50) VAR49 = 50 VAR50;
require(VAR29[VAR40][VAR27] > VAR41);
VAR29[VAR40][VAR27] = FUN6(VAR29[VAR40][VAR27], VAR41);
VAR29[VAR40][VAR32] = FUN7(VAR29[VAR40][VAR32], FUN4(VAR49, VAR41) / 1 VAR51);
VAR41 = FUN4((1 VAR51 - VAR49), VAR41) / 1 VAR51;
if (VAR40 == address(0)) {
VAR27.transfer(VAR41);
} else {
require(FUN17(VAR40).transfer(VAR27, VAR41));
}
VAR31[VAR27] = VAR47.VAR48;
emit FUN13(VAR40, VAR27, VAR41, VAR29[VAR40][VAR27]);
}
function FUN21(address VAR40, address VAR27) public constant returns (uint256) {
return VAR29[VAR40][VAR27];
}
function FUN22(uint256[8] VAR52, address[4] VAR53) public onlyAdmin returns (bool) {
require(VAR23[VAR53[2]] < VAR52[3]);
if (VAR52[6] > 100 VAR50) VAR52[6] = 100 VAR50;
if (VAR52[7] > 100 VAR50) VAR52[7] = 100 VAR50;
require(VAR29[VAR53[0]][VAR53[3]] > VAR52[4]);
require(VAR29[VAR53[1]][VAR53[2]] > (FUN4(VAR52[1], VAR52[4]) / VAR52[0]));
VAR29[VAR53[0]][VAR53[3]] = FUN6(VAR29[VAR53[0]][VAR53[3]], VAR52[4]);
VAR29[VAR53[0]][VAR53[2]] = FUN7(VAR29[VAR53[0]][VAR53[2]], FUN4(VAR52[4], ((1 VAR51) - VAR52[6])) / (1 VAR51));
VAR29[VAR53[0]][VAR32] = FUN7(VAR29[VAR53[0]][VAR32], FUN4(VAR52[4], VAR52[6]) / (1 VAR51));
VAR29[VAR53[1]][VAR53[2]] = FUN6(VAR29[VAR53[1]][VAR53[2]], FUN4(VAR52[1], VAR52[4]) / VAR52[0]);
VAR29[VAR53[1]][VAR53[3]] = FUN7(VAR29[VAR53[1]][VAR53[3]], FUN4(FUN4(((1 VAR51) - VAR52[7]), VAR52[1]), VAR52[4]) / VAR52[0] / (1 VAR51));
VAR29[VAR53[1]][VAR32] = FUN7(VAR29[VAR53[1]][VAR32], FUN4(FUN4(VAR52[7], VAR52[1]), VAR52[4]) / VAR52[0] / (1 VAR51));
VAR31[VAR53[2]] = VAR47.VAR48;
VAR31[VAR53[3]] = VAR47.VAR48;
}
}
0
---------------------------------
323 0x00c8162c86a977edc10c641636bdff1c59327983.sol
pragma solidity 0.4.24;
pragma VAR1 "";
interface VAR2 {
function transfer(address VAR3, uint256 VAR4) external returns (bool);
function FUN1(address VAR5, address VAR3, uint256 VAR4) external returns (bool);
function FUN2(address VAR6, uint256 VAR4) external returns (bool VAR7);
function FUN3() external view returns (uint256);
function FUN4(address VAR8) external view returns (uint256);
function FUN5(address VAR5, address VAR6) external view returns (uint256);
function FUN6(address VAR3, uint256 VAR4) external returns (bool);
function FUN7() external view returns (address);
function FUN8() external view returns (address);
function FUN9() external returns (bool);
function FUN10() external returns (bool);
}
library VAR9 {
function FUN11(uint256 VAR10, uint256 VAR11) internal pure  returns (uint256) {
uint256 VAR12 = VAR10 * VAR11;
require(VAR10 == 0 || VAR12 / VAR10 == VAR11);
return VAR12;
}
function FUN12(uint256 VAR10, uint256 VAR11) internal pure returns (uint256) {
uint256 VAR12 = VAR10 / VAR11;
return VAR12;
}
function FUN13(uint256 VAR10, uint256 VAR11) internal pure returns (uint256) {
require(VAR11 <= VAR10);
return VAR10 - VAR11;
}
function FUN14(uint256 VAR10, uint256 VAR11) internal pure returns (uint256) {
uint256 VAR12 = VAR10 + VAR11;
require(VAR12 >= VAR10);
return VAR12;
}
}
contract VAR13 {
using SafeMath for uint256;
bytes constant private VAR14 = "";
address constant private VAR15 = 0xa80cD01dD37c29116549AA879c44C824b703828A;
address constant private VAR16 = 0xecc043b92834c1ebDE65F2181B59597a6588D616;
address constant private VAR17 = 0x3eC6481365c2c2b37d7b939B5854BFB7e5e83C10;
RTCoinInterface constant private VAR18 = FUN15(VAR16);
string constant public VAR19 = "";
address public VAR20;
enum VAR21{ VAR22, VAR23 }
enum VAR24{ VAR25, VAR26 }
struct VAR27 {
uint256 VAR28;
uint256 VAR29;
PaymentMethod VAR30;
PaymentState VAR31;
}
mapping (address => uint256) public VAR32;
mapping (address => mapping(uint256 => VAR27)) public VAR33;
event FUN16(address VAR34, uint256 VAR35, uint8 VAR36, uint256 VAR37);
modifier FUN17(uint256 VAR35) {
require(VAR33[msg.sender][VAR35].VAR31 == VAR21.VAR22, "");
VAR38;
}
modifier onlyAdmin() {
require(msg.sender == VAR20, "");
VAR38;
}
constructor() public {
VAR20 = msg.sender;
}
function FUN18(
bytes32 VAR39,
uint8   VAR40,
bytes32 VAR41,
bytes32 VAR42,
uint256 VAR35,
uint8   VAR36,
uint256 VAR43,
bool   VAR44)
public
payable
FUN17(VAR35)
returns (bool)
{
require(VAR36 == 0 || VAR36 == 1, "");
bytes32 VAR45;
if (VAR44) {
bytes32 VAR46 = FUN19(VAR35, VAR43, VAR36);
VAR45 = FUN20(VAR46);
} else {
VAR45 = FUN19(VAR35, VAR43, VAR36);
}
require(VAR45 == VAR39, "");
address VAR47 = FUN21(VAR39, VAR40, VAR41, VAR42);
require(VAR47 == VAR15, "");
PaymentStruct memory VAR48 = FUN22({
VAR28: VAR35,
VAR29: VAR43,
VAR30: FUN23(VAR36),
VAR31: VAR21.VAR23
});
VAR33[msg.sender][VAR35] = VAR48;
VAR32[msg.sender] = VAR32[msg.sender].FUN14(1);
if (FUN23(VAR36) == VAR24.VAR26) {
require(msg.value == VAR43, "");
emit FUN16(msg.sender, VAR35, VAR36, VAR43);
VAR17.transfer(msg.value);
return true;
}
emit FUN16(msg.sender, VAR35, VAR36, VAR43);
require(VAR18.FUN1(msg.sender, VAR17, VAR43), "");
return true;
}
function FUN24(
bytes32 VAR39,
uint256 VAR35,
uint8   VAR36,
uint256 VAR43,
bool   VAR44)
public
view
returns (bool)
{
require(VAR36 == 0 || VAR36 == 1, "");
bytes32 VAR45;
if (VAR44) {
bytes32 VAR46 = FUN19(VAR35, VAR43, VAR36);
VAR45 = FUN20(VAR46);
} else {
VAR45 = FUN19(VAR35, VAR43, VAR36);
}
return VAR45 == VAR39;
}
function FUN25(
bytes32 VAR39,
uint8   VAR40,
bytes32 VAR41,
bytes32 VAR42,
uint256 VAR35,
uint8   VAR36,
uint256 VAR43,
bool   VAR44)
public
view
returns (bool)
{
require(VAR36 == 0 || VAR36 == 1, "");
bytes32 VAR45;
if (VAR44) {
bytes32 VAR46 = FUN19(VAR35, VAR43, VAR36);
VAR45 = FUN20(VAR46);
} else {
VAR45 = FUN19(VAR35, VAR43, VAR36);
}
require(VAR45 == VAR39, "");
return FUN21(VAR39, VAR40, VAR41, VAR42) == VAR15;
}
function FUN19(
uint256 VAR35,
uint256 VAR43,
uint8   VAR36)
internal
view
returns (bytes32)
{
return FUN26(VAR49.FUN27(msg.sender, VAR35, VAR36, VAR43));
}
function FUN20(bytes32 VAR50) internal pure returns (bytes32)  {
return FUN26(VAR49.FUN27(VAR14, VAR50));
}
function FUN28() public onlyAdmin returns (bool) {
FUN29(msg.sender);
return true;
}
}
0
---------------------------------
324 0x00cab00609e70f14e755524bd07e1c639665e796.sol
pragma solidity 0.4.24;
interface VAR1 { function FUN1(address VAR2, uint256 VAR3, address VAR4, bytes VAR5) external; }
contract VAR6 {
address public VAR7;
constructor() public {
VAR7 = msg.sender;
}
modifier onlyOwner {
require (msg.sender == VAR7);
VAR8;
}
function FUN2(address VAR9) onlyOwner public {
if (VAR9 != address(0)) {
VAR7 = VAR9;
}
}
}
contract VAR10 {
string public VAR11;
string public VAR12;
uint8 public VAR13 = 8;
uint256 public VAR14;
mapping (address => uint256) public VAR15;
mapping (address => mapping (address => uint256)) public VAR16;
event Transfer(address indexed VAR17, address indexed VAR18, uint256 value);
event FUN3(address indexed VAR17, uint256 value);
constructor(uint256 VAR19, string VAR20, string VAR21) public {
VAR14 = VAR19 * 10 ** uint256(VAR13);
VAR15[msg.sender] = VAR14;
VAR11 = VAR20;
VAR12 = VAR21;
}
function FUN4(address VAR22) public constant returns (uint256 VAR23) {
return VAR15[VAR22];
}
function FUN5(address VAR2, address VAR24, uint256 VAR3) internal {
require(VAR24 != 0x0);
require(VAR15[VAR2] >= VAR3);
require(VAR15[VAR24] + VAR3 > VAR15[VAR24]);
uint VAR25 = VAR15[VAR2] + VAR15[VAR24];
VAR15[VAR2] -= VAR3;
VAR15[VAR24] += VAR3;
emit Transfer(VAR2, VAR24, VAR3);
assert(VAR15[VAR2] + VAR15[VAR24] == VAR25);
}
function transfer(address VAR24, uint256 VAR3) public {
FUN5(msg.sender, VAR24, VAR3);
}
function FUN6(address VAR2, address VAR24, uint256 VAR3) public returns (bool VAR26) {
require(VAR3 <= VAR16[VAR2][msg.sender]);
VAR16[VAR2][msg.sender] -= VAR3;
FUN5(VAR2, VAR24, VAR3);
return true;
}
function FUN7(address VAR27, uint256 VAR3) public returns (bool VAR26) {
VAR16[msg.sender][VAR27] = VAR3;
return true;
}
function FUN8(address VAR27, uint256 VAR3, bytes VAR5) public returns (bool VAR26) {
tokenRecipient VAR28 = FUN9(VAR27);
if (FUN7(VAR27, VAR3)) {
VAR28.FUN1(msg.sender, VAR3, this, VAR5);
return true;
}
}
function FUN10(uint256 VAR3) public returns (bool VAR26) {
require(VAR15[msg.sender] >= VAR3);
VAR15[msg.sender] -= VAR3;
VAR14 -= VAR3;
emit FUN3(msg.sender, VAR3);
return true;
}
function FUN11(address VAR2, uint256 VAR3) public returns (bool VAR26) {
require(VAR15[VAR2] >= VAR3);
require(VAR3 <= VAR16[VAR2][msg.sender]);
VAR15[VAR2] -= VAR3;
VAR16[VAR2][msg.sender] -= VAR3;
VAR14 -= VAR3;
emit FUN3(VAR2, VAR3);
return true;
}
}
contract SVC is VAR6, VAR10 {
mapping (address => bool) public VAR29;
event FUN12(address VAR30, bool VAR31);
constructor(
uint256 VAR19,
string VAR20,
string VAR21
) FUN13 (VAR19, VAR20, VAR21) public {}
function FUN5(address VAR2, address VAR24, uint VAR3) internal {
require (VAR24 != 0x0);
require (VAR15[VAR2] > VAR3);
require (VAR15[VAR24] + VAR3 > VAR15[VAR24]);
require(!VAR29[VAR2]);
require(!VAR29[VAR24]);
VAR15[VAR2] -= VAR3;
VAR15[VAR24] += VAR3;
emit Transfer(VAR2, VAR24, VAR3);
}
function FUN14(address VAR30, uint256 VAR32) onlyOwner public {
VAR15[VAR30] += VAR32;
VAR14 += VAR32;
emit Transfer(0, this, VAR32);
emit Transfer(this, VAR30, VAR32);
}
function FUN15(address VAR30, bool VAR33) onlyOwner public {
VAR29[VAR30] = VAR33;
emit FUN12(VAR30, VAR33);
}
}
0
---------------------------------
325 0x00e126e283b0e116470a0f6d6108f314e5cf2a0e.sol
pragma VAR1 ^0.4.25;
interface VAR2 {
function FUN1() external view returns (uint256);
function FUN2(address VAR3) external view returns (uint256);
function FUN3(address VAR4, address VAR5) external view returns (uint256);
function transfer(address VAR6, uint256 value) external returns (bool);
function FUN4(address VAR5, uint256 value) external returns (bool);
function FUN5(address VAR7, address VAR6, uint256 value) external returns (bool);
event Transfer(
address indexed VAR7,
address indexed VAR6,
uint256 value
);
event FUN6(
address indexed VAR4,
address indexed VAR5,
uint256 value
);
}
library VAR8 {
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (VAR11) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR12 = VAR9 * VAR10;
require(VAR12 / VAR9 == VAR10);
require(VAR12 < 2**64);
return FUN8(VAR12);
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (VAR11) {
uint256 VAR12 = VAR9 / VAR10;
require(VAR12 < 2**64);
return FUN8(VAR12);
}
function FUN10(uint256 VAR9, uint256 VAR10) internal pure returns (VAR11) {
require(VAR10 <= VAR9);
uint256 VAR12 = VAR9 - VAR10;
require(VAR12 < 2**64);
return FUN8(VAR12);
}
function FUN11(uint256 VAR9, uint256 VAR10) internal pure returns (VAR11) {
uint256 VAR12 = VAR9 + VAR10;
require(VAR12 >= VAR9 && VAR12 < 2**64);
return FUN8(VAR12);
}
function FUN12(uint256 VAR9, uint256 VAR10) internal pure returns (VAR13) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR12 = VAR9 * VAR10;
require(VAR12 / VAR9 == VAR10);
require(VAR12 < 2**32);
return FUN13(VAR12);
}
function FUN14(uint256 VAR9, uint256 VAR10) internal pure returns (VAR13) {
uint256 VAR12 = VAR9 / VAR10;
require(VAR12 < 2**32);
return FUN13(VAR12);
}
function FUN15(uint256 VAR9, uint256 VAR10) internal pure returns (VAR13) {
require(VAR10 <= VAR9);
uint256 VAR12 = VAR9 - VAR10;
require(VAR12 < 2**32);
return FUN13(VAR12);
}
function FUN16(uint256 VAR9, uint256 VAR10) internal pure returns (VAR13) {
uint256 VAR12 = VAR9 + VAR10;
require(VAR12 >= VAR9 && VAR12 < 2**32);
return FUN13(VAR12);
}
function FUN17(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR12 = VAR9 * VAR10;
require(VAR12 / VAR9 == VAR10);
return VAR12;
}
function FUN18(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR12 = VAR9 / VAR10;
return VAR12;
}
function FUN19(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN20(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR12 = VAR9 + VAR10;
require(VAR12 >= VAR9);
return VAR12;
}
}
library VAR14 {
function FUN21(bytes32 VAR9, bytes32 VAR10) public pure returns(bytes32) {
return FUN22(VAR15.FUN23(VAR9, VAR10));
}
function FUN24(bytes32[] memory VAR16, uint256 VAR17, bytes32 VAR18) public pure returns(bytes32) {
bytes32 VAR19 = FUN22(VAR15.FUN23(VAR18));
uint256 VAR20 = VAR17;
for(uint VAR21 = 0; VAR21<VAR16.VAR22; VAR21++) {
uint256 VAR23 = VAR20 % 2;
VAR20 = VAR20 / 2;
if (VAR23 == 0)
VAR19 = FUN21(VAR19, VAR16[VAR21]);
else
VAR19 = FUN21(VAR16[VAR21], VAR19);
}
return VAR19;
}
}
contract VAR24 {
struct VAR25 {
address VAR4;
uint64  VAR26;
uint32  VAR27;
}
struct VAR28 {
bytes32 VAR29;
uint32  VAR30;
uint32  VAR31;
}
struct VAR32 {
uint32  VAR33;
uint64  VAR34;
uint64  VAR35;
uint32  VAR36;
uint32  VAR37;
uint32  VAR38;
uint64  VAR39;
bytes32 VAR40;
bytes32 VAR41;
bytes32 VAR42;
}
struct VAR43 {
uint32  VAR44;
uint32  VAR45;
uint64  VAR34;
uint64  VAR46;
uint32  VAR6;
uint64  VAR47;
uint32  VAR48;
uint32  VAR49;
uint32  VAR50;
uint64  VAR51;
uint8   VAR52;
address VAR53;
bytes32 VAR54;
}
struct VAR55 {
uint32 VAR56;
uint32 VAR57;
uint32 VAR58;
uint32 VAR59;
uint64 VAR60;
uint64 VAR61;
uint32 VAR62;
uint32 VAR63;
uint32 VAR64;
uint32 VAR65;
uint32 VAR66;
uint64 VAR67;
uint64 VAR68;
uint64 VAR69;
}
Config public VAR70;
address public VAR4;
uint public constant VAR71 = 2**32-1;
uint public constant VAR72 = 2**256-1;
uint public constant VAR73 = 32768;
}
contract Accounts is VAR24 {
event FUN25(uint VAR74, uint VAR36, uint VAR75 );
event FUN26(uint VAR76, address VAR77);
IERC20 public VAR78;
VAR25[] public VAR79;
VAR28[] public VAR80;
function FUN27(uint VAR76) public view returns (bool) {
return (VAR76 < VAR79.VAR22);
}
function FUN28(uint VAR76) public view returns (bool) {
return FUN27(VAR76) && msg.sender == VAR79[VAR76].VAR4;
}
modifier FUN29(uint VAR76) {
require(FUN27(VAR76), "");
VAR81;
}
modifier FUN30(uint VAR76) {
require(FUN28(VAR76), "");
VAR81;
}
function FUN31(uint256 VAR74, bytes32 VAR29) public {
require(VAR74 > 0, "");
require(VAR74 < VAR70.VAR56, "");
require(VAR8.FUN20(VAR79.VAR22, VAR74) <= VAR71, "");
require(VAR29 > 0, "");
emit FUN25(VAR74, VAR79.VAR22, VAR80.VAR22);
VAR80.FUN32(FUN33(VAR29, FUN13(VAR74), FUN13(VAR79.VAR22)));
VAR79.VAR22 = VAR8.FUN20(VAR79.VAR22, VAR74);
}
function FUN34(address VAR53, bytes32[] memory VAR16, uint VAR76, uint VAR75) public {
require(VAR75 < VAR80.VAR22, "");
uint VAR36 = VAR80[VAR75].VAR31;
uint VAR82 = VAR80[VAR75].VAR30;
bytes32 VAR29 = VAR80[VAR75].VAR29;
bytes32 VAR19 = VAR14.FUN24(VAR16, VAR8.FUN19(VAR76, VAR36), bytes32(VAR53));
require(VAR76 >= VAR36 && VAR76 < VAR36 + VAR82,
"");
require(VAR19 == VAR29, "");
emit FUN26(VAR76, VAR53);
VAR79[VAR76].VAR4 = VAR53;
}
function FUN35() public returns (uint32 VAR83) {
require(VAR79.VAR22 < VAR71, "");
VAR83 = (VAR13)(VAR79.VAR22);
VAR79.FUN32(FUN36(msg.sender, 0, 0));
emit FUN26(VAR83, msg.sender);
return VAR83;
}
function FUN37(uint64 VAR34, uint256 VAR76)
external
FUN30(VAR76)
{
uint64 VAR26 = VAR79[VAR76].VAR26;
require(VAR26 >= VAR34, "");
require(VAR34 > 0, "");
FUN38(VAR76, VAR34);
require(VAR78.transfer(msg.sender, VAR34), "");
}
function FUN39(uint64 VAR34, uint256 VAR76) external {
require(VAR76 < VAR79.VAR22 || VAR76 == VAR72, "");
require(VAR34 > 0, "");
if (VAR76 == VAR72) {
uint VAR84 = FUN35();
VAR79[VAR84].VAR26 = VAR34;
} else {
FUN40(VAR76, VAR34);
}
require(VAR78.FUN5(msg.sender, address(this), VAR34), "");
}
function FUN40(uint VAR76, uint64 VAR34)
internal
FUN29(VAR76)
{
VAR79[VAR76].VAR26 = VAR8.FUN11(VAR79[VAR76].VAR26, VAR34);
}
function FUN38(uint VAR76, uint64 VAR34)
internal
FUN29(VAR76)
{
uint64 VAR26 = VAR79[VAR76].VAR26;
require(VAR26 >= VAR34, "");
VAR79[VAR76].VAR26 = VAR8.FUN10(VAR26, VAR34);
}
function FUN2(uint VAR76)
external
view
FUN29(VAR76)
returns (VAR11)
{
return VAR79[VAR76].VAR26;
}
function FUN41() external view returns (uint) {
return VAR79.VAR22;
}
function FUN42() external view returns (uint) {
return VAR80.VAR22;
}
}
library VAR85 {
uint8 public constant VAR86 = 0xff;
modifier FUN43(VAR24.CollectSlot storage VAR87, uint8 VAR88) {
require(!FUN44(VAR87), "");
require(FUN45(VAR87, VAR88), "");
VAR81;
}
function FUN44(VAR24.CollectSlot storage VAR87) public view returns (bool) {
return VAR87.VAR47 <= VAR47.VAR89;
}
function FUN45(VAR24.CollectSlot storage VAR87, uint8 VAR88) public view returns (bool) {
return VAR87.VAR52 == VAR88;
}
function FUN46(uint VAR90) public view returns(VAR11) {
return VAR8.FUN11(VAR47.VAR89, VAR90);
}
function FUN47(bytes memory VAR54) public pure returns (uint VAR91) {
require(VAR54.VAR22 > 0, "");
require(VAR54.VAR22 % 12 == 0, "");
uint VAR82 = VAR8.FUN18(VAR54.VAR22, 12);
uint VAR92 = 2**64;
VAR91 = 0;
for (uint VAR21 = 0; VAR21 < VAR82; VAR21++) {
VAR93 {
let VAR34 := FUN48(FUN49(FUN20(VAR54, FUN20(8, FUN17(VAR21, 12)))), VAR92)
let VAR94 := FUN20(VAR91, VAR34)
switch or(FUN50(VAR94, VAR92), FUN51(VAR94, VAR92))
case 1 { revert (0, 0) }
default { VAR91 := VAR94 }
}
}
}
function FUN52(bytes memory VAR54, uint VAR50) public pure returns (uint64 VAR34, uint32 VAR95) {
require(VAR54.VAR22 > 0, "");
require(VAR54.VAR22 % 12 == 0, "");
uint VAR96 = 2**64;
uint VAR97 = 2**32;
uint VAR21 = VAR8.FUN17(VAR50, 12);
require(VAR21 <= VAR8.FUN19(VAR54.VAR22, 12), "");
VAR93 {
VAR34 := FUN48( FUN49(FUN20(VAR54, FUN20(8, VAR21))), VAR96 )
VAR95 := FUN48( FUN49(FUN20(VAR54, FUN20(12, VAR21))), VAR97 )
}
}
function FUN53(bytes VAR98) internal pure returns (uint) {
uint VAR99 = VAR98.VAR22;
require(VAR99 >= 2, "");
require(uint8(VAR98[0]) == VAR86, "");
uint VAR100 = uint(VAR98[1]);
require(VAR100 > 0 && VAR100 < 32, "");
require((VAR99 - 2) % VAR100 == 0,
"");
return VAR100;
}
function FUN54(bytes memory VAR98, uint VAR101, uint VAR34) public pure returns (uint VAR91) {
uint VAR100 = FUN53(VAR98);
uint VAR92 = 1 << VAR8.FUN17(VAR100, 8);
uint VAR102 = 0;
VAR91 = 0;
for (uint VAR21 = 2; VAR21 < VAR98.VAR22; VAR21 += VAR100) {
VAR93 {
VAR102 := FUN20(
VAR102,
FUN48(
FUN49(FUN20(VAR98, FUN20(VAR21, VAR100))),
VAR92))
switch FUN51(VAR102, VAR101)
case 1 { VAR91 := FUN20(VAR91, VAR34) }
}
}
}
function FUN55(bytes VAR98) public pure returns (uint) {
uint VAR100 = FUN53(VAR98);
return VAR8.FUN18(VAR98.VAR22 - 2, VAR100);
}
function FUN56(
VAR24.CollectSlot storage VAR87,
VAR24.Config storage VAR103,
VAR24.VAR25[] storage VAR79,
uint32 VAR49
)
public
FUN43(VAR87, 1)
{
require(VAR79[VAR49].VAR26 >= VAR103.VAR61, "");
VAR87.VAR52 = 2;
VAR87.VAR49 = VAR49;
VAR87.VAR47 = FUN46(VAR103.VAR59);
VAR79[VAR49].VAR26 -= VAR103.VAR61;
}
function FUN57(
VAR24.CollectSlot storage VAR87,
VAR24.Config storage VAR103,
bytes memory VAR54
)
public
FUN43(VAR87, 2)
{
require(FUN47(VAR54) == VAR87.VAR34, "");
VAR87.VAR54 = FUN22(VAR54);
VAR87.VAR52 = 3;
VAR87.VAR47 = FUN46(VAR103.VAR59);
}
function FUN58(
VAR24.CollectSlot storage VAR87,
VAR24.Config storage VAR103,
bytes memory VAR54,
uint32 VAR104
)
public
FUN43(VAR87, 3)
{
require(VAR87.VAR54 == FUN22(VAR54),
"");
(VAR87.VAR51, VAR87.VAR50) = FUN52(VAR54, VAR104);
VAR87.VAR52 = 4;
VAR87.VAR47 = FUN46(VAR103.VAR59);
}
function FUN59(
VAR24.CollectSlot storage VAR87,
VAR24.VAR32[] storage VAR105,
bytes memory VAR98
)
public
FUN43(VAR87, 4)
{
require(VAR87.VAR50 >= VAR87.VAR44 && VAR87.VAR50 < VAR87.VAR45,
"");
VAR24.Payment memory VAR106 = VAR105[VAR87.VAR50];
require(FUN22(VAR98) == VAR106.VAR40,
"");
require(VAR106.VAR41 == 0, "");
uint VAR107 = FUN54(VAR98, VAR87.VAR6, VAR106.VAR34);
if (VAR87.VAR6 >= VAR106.VAR36 && VAR87.VAR6 < VAR106.VAR37) {
VAR107 = VAR8.FUN20(VAR107, VAR106.VAR34);
}
require(VAR107 == VAR87.VAR51,
"");
VAR87.VAR52 = 5;
}
function FUN60(
VAR24.CollectSlot storage VAR87,
VAR24.Config storage VAR103,
VAR24.VAR25[] storage VAR79
)
public
{
require((VAR87.VAR52 == 2 || VAR87.VAR52 == 4),
"");
require(FUN44(VAR87),
"");
VAR79[VAR87.VAR49].VAR26 = VAR8.FUN11(
VAR79[VAR87.VAR49].VAR26,
VAR8.FUN11(VAR103.VAR60, VAR103.VAR61));
VAR87.VAR52 = 0;
}
function FUN61(
VAR24.CollectSlot storage VAR87,
VAR24.Config storage VAR103,
VAR24.VAR25[] storage VAR79
)
public
{
require(VAR87.VAR52 == 5 || (VAR87.VAR52 == 3 && VAR47.VAR89 >= VAR87.VAR47),
"");
VAR79[VAR87.VAR48].VAR26 = VAR8.FUN11(
VAR79[VAR87.VAR48].VAR26,
VAR103.VAR61);
VAR87.VAR49 = 0;
VAR87.VAR52 = 1;
VAR87.VAR47 = FUN46(VAR103.VAR58);
}
function FUN62(bytes32 VAR19, bytes VAR108) public pure returns (address) {
bytes memory VAR109 = "";
bytes32 VAR110 = FUN22(VAR15.FUN23(VAR109, VAR19));
bytes32 VAR111;
bytes32 VAR112;
uint8 VAR113;
if (VAR108.VAR22 != 65) {
return (address(0));
}
VAR93 {
VAR111 := FUN49(FUN20(VAR108, 32))
VAR112 := FUN49(FUN20(VAR108, 64))
VAR113 := FUN63(0, FUN49(FUN20(VAR108, 96)))
}
if (VAR113 < 27) {
VAR113 += 27;
}
if (VAR113 != 27 && VAR113 != 28) {
return address(0);
}
return FUN64(VAR110, VAR113, VAR111, VAR112);
}
}
contract Payments is VAR114 {
event FUN65(
uint32 indexed VAR95,
uint indexed VAR7,
uint VAR38,
uint VAR34
);
event FUN66(uint32 indexed VAR95, bytes VAR17);
event FUN67(uint32 VAR115, uint64 VAR116);
event FUN68(
uint indexed VAR48,
uint indexed VAR117,
uint indexed VAR6,
uint32 VAR118,
uint32 VAR119,
uint VAR34
);
event FUN69(uint indexed VAR48, uint indexed VAR117, uint VAR49);
event FUN70(uint indexed VAR48, uint indexed VAR117);
event FUN71(uint indexed VAR48, uint indexed VAR117, uint VAR50);
event FUN72(uint indexed VAR48, uint indexed VAR117);
event FUN73(uint indexed VAR48, uint indexed VAR117);
event FUN74(uint indexed VAR48, uint indexed VAR117);
VAR32[] public VAR105;
mapping (VAR13 => mapping (VAR13 => VAR43)) public VAR120;
function FUN75(
uint32 VAR121,
uint64 VAR34,
uint64 VAR35,
bytes VAR98,
uint VAR122,
bytes32 VAR29,
bytes32 VAR41,
bytes32 VAR42
)
external
{
require(VAR105.VAR22 < 2**32, "");
require(FUN28(VAR121), "");
require(VAR34 > 0, "");
require(VAR122 == 0 || VAR29 > 0, "");
require(VAR35 == 0 || VAR41 > 0, "");
Payment memory VAR106;
VAR106.VAR38 = VAR8.FUN16(VAR85.FUN55(VAR98), VAR122);
require(VAR106.VAR38 > 0, "");
require(VAR106.VAR38 < VAR70.VAR57,
"");
VAR106.VAR33 = VAR121;
VAR106.VAR34 = VAR34;
VAR106.VAR35 = VAR35;
VAR106.VAR41 = VAR41;
VAR106.VAR42 = VAR42;
VAR106.VAR36 = FUN13(VAR79.VAR22);
VAR106.VAR37 = VAR8.FUN16(VAR106.VAR36, VAR122);
VAR106.VAR39 = VAR8.FUN11(VAR47.VAR89, VAR70.VAR62);
VAR106.VAR40 = FUN22(VAR15.FUN23(VAR98));
uint64 VAR123 = VAR8.FUN7(VAR34, VAR106.VAR38);
VAR123 = VAR8.FUN11(VAR123, VAR35);
FUN38(VAR121, VAR123);
if (VAR122 > 0) {
FUN31(VAR122, VAR29);
}
VAR105.FUN32(VAR106);
emit FUN65(VAR8.FUN15(VAR105.VAR22, 1), VAR106.VAR33, VAR106.VAR38, VAR106.VAR34);
}
function FUN76(uint32 VAR95, uint32 VAR124, bytes memory VAR17) public returns(bool) {
require(VAR95 < VAR105.VAR22, "");
require(FUN27(VAR124), "");
require(VAR47.VAR89 < VAR105[VAR95].VAR39, "");
bytes32 VAR125 = FUN22(VAR15.FUN23(VAR124, VAR17));
require(VAR125 == VAR105[VAR95].VAR41, "");
VAR105[VAR95].VAR41 = bytes32(0);
FUN40(VAR124, VAR105[VAR95].VAR35);
emit FUN66(VAR95, VAR17);
return true;
}
function FUN77(uint32 VAR95) external returns (bool) {
require(VAR95 < VAR105.VAR22, "");
require(VAR105[VAR95].VAR41 != 0, "");
require(VAR47.VAR89 >= VAR105[VAR95].VAR39, "");
Payment memory VAR126 = VAR105[VAR95];
require(VAR126.VAR38 > 0, "");
uint64 VAR127 = VAR8.FUN11(
VAR8.FUN7(VAR126.VAR38, VAR126.VAR34),
VAR126.VAR35
);
VAR126.VAR38 = 0;
VAR126.VAR35 = 0;
VAR126.VAR34 = 0;
VAR105[VAR95] = VAR126;
FUN40(VAR126.VAR33, VAR127);
emit FUN67(VAR126.VAR33, VAR127);
return true;
}
function FUN78(
uint32 VAR48,
uint32 VAR128,
uint32 VAR129,
uint32 VAR45,
uint64 VAR130,
uint64 VAR35,
address VAR131,
bytes memory VAR132
)
public
{
require(FUN28(VAR48), "");
require(FUN27(VAR129), "");
FUN79(VAR48, VAR128);
Account memory VAR133 = VAR79[VAR129];
require(VAR133.VAR4 != 0, "");
if (VAR48 != VAR129) {
bytes32 VAR19 =
FUN22(
VAR15.FUN23(
address(this), VAR48, VAR129, VAR133.VAR27,
VAR45, VAR130, VAR35, VAR131
));
require(VAR85.FUN62(VAR19, VAR132) == VAR133.VAR4, "");
}
require(VAR45 > 0 && VAR45 <= VAR105.VAR22,
"");
require(VAR45 > VAR133.VAR27, "");
require(VAR105[VAR45 - 1].VAR39 < VAR47.VAR89,
"");
require(VAR130 <= VAR70.VAR69, "");
require(VAR35 <= VAR130, "");
CollectSlot storage VAR134 = VAR120[VAR48][VAR128];
VAR134.VAR48 = VAR48;
VAR134.VAR44 = VAR133.VAR27;
VAR134.VAR45 = VAR45;
VAR134.VAR34 = VAR130;
VAR134.VAR6 = VAR129;
VAR134.VAR47 = VAR85.FUN46(VAR70.VAR58);
VAR134.VAR52 = 1;
uint64 VAR135 = VAR70.VAR60;
if (VAR128 >= VAR73) {
uint64 VAR136 = VAR8.FUN10(VAR130, VAR35);
VAR134.VAR46 = VAR130;
VAR135 = VAR8.FUN11(VAR135, VAR136);
VAR134.VAR53 = address(0);
FUN40(VAR129, VAR136);
} else
{
VAR134.VAR46 = VAR35;
VAR134.VAR53 = VAR131;
}
require(VAR79[VAR48].VAR26 >= VAR135, "");
VAR79[VAR129].VAR27 = FUN13(VAR45);
FUN38(VAR48, VAR135);
if (VAR131 != address(0) && VAR128 >= VAR73) {
uint64 VAR137 = VAR79[VAR129].VAR26;
VAR79[VAR129].VAR26 = 0;
require(VAR78.transfer(VAR131, VAR137), "");
}
emit FUN68(VAR48, VAR128, VAR129, VAR133.VAR27, VAR45, VAR130);
}
function FUN80() external view returns (uint) {
return VAR105.VAR22;
}
function FUN56(
uint32 VAR48,
uint32 VAR117,
uint32 VAR49
)
public
FUN29(VAR48)
FUN30(VAR49)
{
VAR85.FUN56(VAR120[VAR48][VAR117], VAR70, VAR79, VAR49);
emit FUN69(VAR48, VAR117, VAR49);
}
function FUN57(
uint32 VAR48,
uint32 VAR117,
bytes memory VAR54
)
public
FUN30(VAR48)
{
VAR85.FUN57(VAR120[VAR48][VAR117], VAR70, VAR54);
emit FUN70(VAR48, VAR117);
}
function FUN58(
uint32 VAR48,
uint32 VAR117,
bytes memory VAR54,
uint32 VAR50
)
public
FUN29(VAR48)
{
require(FUN28(VAR120[VAR48][VAR117].VAR49), "");
VAR85.FUN58(VAR120[VAR48][VAR117], VAR70, VAR54, VAR50);
emit FUN71(VAR48, VAR117, VAR50);
}
function FUN59(
uint32 VAR48,
uint32 VAR117,
bytes memory VAR98
)
public
FUN30(VAR48)
{
VAR85.FUN59(
VAR120[VAR48][VAR117],
VAR105,
VAR98
);
emit FUN72(VAR48, VAR117);
}
function FUN60(
uint32 VAR48,
uint32 VAR117
)
public
FUN29(VAR48)
{
VAR85.FUN60(VAR120[VAR48][VAR117], VAR70, VAR79);
emit FUN73(VAR48, VAR117);
}
function FUN61(
uint32 VAR48,
uint32 VAR117
)
public
FUN30(VAR48)
{
VAR85.FUN61(VAR120[VAR48][VAR117], VAR70, VAR79);
emit FUN74(VAR48, VAR117);
}
function FUN79(uint32 VAR48, uint32 VAR117) public {
CollectSlot memory VAR112 = VAR120[VAR48][VAR117];
if (VAR112.VAR52 == 0) return;
require(VAR112.VAR52 == 1, "");
require(VAR47.VAR89 >= VAR112.VAR47, "");
VAR120[VAR48][VAR117].VAR52 = 0;
FUN40(VAR48, VAR8.FUN11(VAR112.VAR46, VAR70.VAR60));
uint64 VAR26 = VAR8.FUN10(VAR112.VAR34, VAR112.VAR46);
if (VAR112.VAR53 != address(0))
{
VAR26 = VAR8.FUN11(VAR26, VAR79[VAR112.VAR6].VAR26);
VAR79[VAR112.VAR6].VAR26 = 0;
if (VAR26 != 0)
require(VAR78.transfer(VAR112.VAR53, VAR26), "");
} else
{
FUN40(VAR112.VAR6, VAR26);
}
}
}
contract BatPay is VAR138 {
constructor(
IERC20 VAR139,
uint32 VAR56,
uint32 VAR57,
uint32 VAR58,
uint32 VAR59,
uint64 VAR60,
uint64 VAR61,
uint32 VAR62,
uint64 VAR69
)
public
{
require(VAR139 != address(0), "");
require(VAR56 > 0, "");
require(VAR57 > 0, "");
require(VAR58 > 0, "");
require(VAR59 > 0, "");
require(VAR60 > 0, "");
require(VAR61 > 0, "");
require(VAR62 > 0, "");
require(VAR69 > 0, "");
VAR4 = msg.sender;
VAR78 = FUN81(VAR139);
VAR70.VAR56 = VAR56;
VAR70.VAR57 = VAR57;
VAR70.VAR58 = VAR58;
VAR70.VAR59 = VAR59;
VAR70.VAR60 = VAR60;
VAR70.VAR61 = VAR61;
VAR70.VAR62 = VAR62;
VAR70.VAR69 = VAR69;
}
}
0
---------------------------------
326 0x00efd61b0d94ccd82f3922d26efdd3ed9859081a.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
uint256 constant VAR3 = 0x10000000000000000;
int constant VAR4 = 1;
int constant VAR5 = 2;
int constant VAR6 = -0x296ABF784A358468C;
string constant public VAR7 = "";
string constant public VAR8 = "";
uint8 constant public VAR9 = 18;
mapping(address => uint256) public VAR10;
mapping(address => VAR11) public VAR12;
uint256 public VAR13;
int256 VAR14;
uint256 VAR15;
uint256 public VAR16;
bool VAR17 = false;
address VAR18 = 0xD2E6B3BFE990fdede2380885d9d83Ca9364E717E;
modifier FUN1(){
require(VAR17 || (msg.sender==VAR18));
VAR19;
}
function FUN2(){
require(msg.sender==VAR18);
VAR17=true;
}
function FUN3() public {}
function FUN4(address VAR20) public constant returns (uint256 VAR21) {
return VAR10[VAR20];
}
function FUN5() public {
var VAR21 = FUN6(msg.sender);
VAR12[msg.sender] += (VAR11) (VAR21 * VAR3);
VAR14 += (VAR11) (VAR21 * VAR3);
VAR16 = FUN7(VAR16, VAR21);
msg.sender.transfer(VAR21);
}
function FUN8() public {
var VAR21 = FUN6(msg.sender);
VAR12[msg.sender] += (VAR11) (VAR21 * VAR3);
VAR14 += (VAR11) (VAR21 * VAR3);
uint VAR22 = (uint) (VAR21);
if (VAR22 < 0.000001 VAR23 || VAR22 > 1000000 VAR23)
revert();
var sender = msg.sender;
var VAR24 = FUN9() - VAR21;
var VAR25 = FUN10(VAR22, 10);
var VAR26 = VAR22 - VAR25;
var VAR27 = FUN11(VAR26, VAR21);
var VAR28 = VAR25 * VAR3;
if (VAR13 > 0) {
var VAR29 =
(VAR3 - (VAR24 + VAR26) * VAR27 * VAR3 / (VAR13 + VAR27) / VAR26)
* (uint)(VAR5) / (uint)(VAR5-VAR4);
var VAR30 = VAR25 * VAR29;
VAR28 -= VAR30;
var VAR31 = VAR30 / VAR13;
VAR15 += VAR31;
}
VAR13 = FUN12(VAR13, VAR27);
VAR10[sender] = FUN12(VAR10[sender], VAR27);
var VAR32  = (VAR11) ((VAR15 * VAR27) - VAR28);
VAR12[sender] += VAR32;
VAR14    += VAR32;
}
function FUN13() public {
var VAR21 = FUN4(msg.sender);
FUN14(VAR21);
}
function FUN15() public {
FUN13();
FUN5();
}
function FUN16()payable public {
if (msg.value > 0.000001 VAR23) {
VAR16 = FUN12(VAR16, msg.value);
FUN17();
} else {
revert();
}
}
function FUN18() public constant returns (uint) {
return FUN19(1 VAR33);
}
function FUN20() public constant returns (uint) {
var VAR34 = FUN21(1 VAR33);
var VAR25 = FUN10(VAR34, 10);
return VAR34 - VAR25;
}
function FUN6(address VAR20) public constant returns (uint256 VAR35) {
return (uint256) ((VAR11)(VAR15 * VAR10[VAR20]) - VAR12[VAR20]) / VAR3;
}
function FUN22(address VAR36) public {
var VAR21 = FUN6(msg.sender);
VAR12[msg.sender] += (VAR11) (VAR21 * VAR3);
VAR14 += (VAR11) (VAR21 * VAR3);
VAR16 = FUN7(VAR16, VAR21);
VAR36.transfer(VAR21);
}
function FUN23() internal constant returns (uint256 VAR35) {
return VAR16 - msg.value;
}
function FUN17() FUN1() internal {
if (msg.value < 0.000001 VAR23 || msg.value > 1000000 VAR23)
revert();
var sender = msg.sender;
var VAR25 = FUN10(msg.value, 10);
var VAR26 = msg.value - VAR25;
var VAR27 = FUN19(VAR26);
var VAR28 = VAR25 * VAR3;
if (VAR13 > 0) {
var VAR29 =
(VAR3 - (FUN9() + VAR26) * VAR27 * VAR3 / (VAR13 + VAR27) / VAR26)
* (uint)(VAR5) / (uint)(VAR5-VAR4);
var VAR30 = VAR25 * VAR29;
VAR28 -= VAR30;
var VAR31 = VAR30 / VAR13;
VAR15 += VAR31;
}
VAR13 = FUN12(VAR13, VAR27);
VAR10[sender] = FUN12(VAR10[sender], VAR27);
var VAR32 = (VAR11) ((VAR15 * VAR27) - VAR28);
VAR12[sender] += VAR32;
VAR14    += VAR32;
}
function FUN14(uint256 VAR35) internal {
var VAR37 = FUN21(VAR35);
var VAR25 = FUN10(VAR37, 10);
var VAR38 = VAR37 - VAR25;
VAR13 = FUN7(VAR13, VAR35);
VAR10[msg.sender] = FUN7(VAR10[msg.sender], VAR35);
var VAR32 = (VAR11) (VAR15 * VAR35 + (VAR38 * VAR3));
VAR12[msg.sender] -= VAR32;
VAR14 -= VAR32;
if (VAR13 > 0) {
var VAR39 = VAR25 * VAR3;
var VAR31 = VAR39 / VAR13;
VAR15 = FUN12(VAR15, VAR31);
}
}
function FUN9() internal constant returns (uint256 VAR35) {
return FUN7(FUN23(),
((uint256) ((VAR11) (VAR15 * VAR13) - VAR14) / VAR3));
}
function FUN19(uint256 VAR40) public constant returns (uint256 VAR41) {
return FUN7(FUN24(FUN25(FUN9() + VAR40)*VAR4/VAR5 + VAR6), VAR13);
}
function FUN11(uint256 VAR40, uint256 VAR42) public constant returns (uint256 VAR41) {
return FUN7(FUN24(FUN25(FUN9() - VAR42 + VAR40)*VAR4/VAR5 + VAR6), VAR13);
}
function FUN21(uint256 VAR41) public constant returns (uint256 VAR40) {
var VAR43 = FUN9();
if (VAR41 == VAR13)
return VAR43;
return FUN7(VAR43, FUN24((FUN25(VAR13 - VAR41) - VAR6) * VAR5/VAR4));
}
int256  constant VAR44        = 0x10000000000000000;
uint256 constant VAR45      = 0x16a09e667f3bcc908;
uint256 constant VAR46   = 0x0b504f333f9de6484;
int256  constant VAR47        = 0x0b17217f7d1cf79ac;
int256  constant VAR48 = 0x2cb53f09f05cc627c8;
int256  constant VAR49         = 0x1ffffffffff9dac9b;
int256  constant VAR50         = 0x0aaaaaaac16877908;
int256  constant VAR51         = 0x0666664e5e9fa0c99;
int256  constant VAR52         = 0x049254026a7630acf;
int256  constant VAR53         = 0x038bd75ed37753d68;
int256  constant VAR54        = 0x03284a0c14610924f;
function FUN25(uint256 VAR55) internal pure returns (int256 VAR56) {
int32 VAR57 = 0;
while (VAR55 > VAR45) {
VAR55 /= 2;
VAR57++;
}
while (VAR55 <= VAR46) {
VAR55 *= 2;
VAR57--;
}
int256 VAR58 = (((VAR11)(VAR55) - VAR44) * VAR44) / ((VAR11)(VAR55) + VAR44);
var VAR59 = (VAR58*VAR58) / VAR44;
return VAR57 * VAR47 +
(VAR58*(VAR49 + (VAR59*(VAR50 + (VAR59*(VAR51 + (VAR59*(VAR52 + (VAR59*(VAR53 + (VAR59*VAR54/VAR44))
/VAR44))/VAR44))/VAR44))/VAR44))/VAR44);
}
int256 constant VAR60 =  0x02aaaaaaaaa015db0;
int256 constant VAR61 = -0x000b60b60808399d1;
int256 constant VAR62 =  0x0000455956bccdd06;
int256 constant VAR63 = -0x000001b893ad04b3a;
function FUN24(int256 VAR55) internal pure returns (uint256 VAR64) {
int256 VAR57 = (VAR55 + (VAR48)) / VAR47 - 64;
VAR55 -= VAR57*VAR47;
int256 VAR59 = (VAR55*VAR55) / VAR44;
int256 VAR65 = ((VAR11)(2) * VAR44) +
(VAR59*(VAR60 + (VAR59*(VAR61 + (VAR59*(VAR62 + (VAR59*VAR63/VAR44))/VAR44))/VAR44))/VAR44);
VAR64 = (uint256) (((VAR65 + VAR55) * VAR44) / (VAR65 - VAR55));
if (VAR57 >= 0)
VAR64 <<= VAR57;
else
VAR64 >>= -VAR57;
return VAR64;
}
function FUN26(uint256 VAR55, uint256 VAR66) internal pure returns (uint256) {
if (VAR55 == 0) {
return 0;
}
uint256 VAR67 = VAR55 * VAR66;
assert(VAR67 / VAR55 == VAR66);
return VAR67;
}
function FUN10(uint256 VAR55, uint256 VAR66) internal pure returns (uint256) {
uint256 VAR67 = VAR55 / VAR66;
return VAR67;
}
function FUN7(uint256 VAR55, uint256 VAR66) internal pure returns (uint256) {
assert(VAR66 <= VAR55);
return VAR55 - VAR66;
}
function FUN12(uint256 VAR55, uint256 VAR66) internal pure returns (uint256) {
uint256 VAR67 = VAR55 + VAR66;
assert(VAR67 >= VAR55);
return VAR67;
}
function () payable public {
if (msg.value > 0) {
FUN16();
} else {
FUN22(msg.sender);
}
}
}
0
---------------------------------
327 0x00f458047c2eae96a7aea42c4f8b768c8e93b383.sol
pragma solidity 0.4.24;
library VAR1
{
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5
{
uint256 public VAR6;
function FUN5(address VAR7) public constant returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool);
event Transfer(address indexed VAR9, address indexed VAR8, uint256 value);
}
contract ERC20 is VAR5
{
function FUN6(address VAR10, address VAR11) public constant returns (uint256);
function FUN7(address VAR9, address VAR8, uint256 value) public returns (bool);
function FUN8(address VAR11, uint256 value) public returns (bool);
event FUN9(address indexed VAR10, address indexed VAR11, uint256 value);
}
contract BasicToken is VAR5
{
using SafeMath for uint256;
mapping(address => uint256) VAR12;
function transfer(address VAR13, uint256 VAR14) public returns (bool) {
require(VAR13 != address(0));
require(VAR14 <= VAR12[msg.sender]);
VAR12[msg.sender] = VAR12[msg.sender].FUN3(VAR14);
VAR12[VAR13] = VAR12[VAR13].FUN4(VAR14);
emit Transfer(msg.sender, VAR13, VAR14);
return true;
}
function FUN5(address VAR15) public constant returns (uint256 VAR16) {
return VAR12[VAR15];
}
}
contract StandardToken is VAR17, VAR18
{
mapping (address => mapping (address => uint256)) internal VAR19;
function FUN7(address VAR20, address VAR13, uint256 VAR14) public returns (bool) {
require(VAR13 != address(0));
require(VAR14 <= VAR12[VAR20]);
require(VAR14 <= VAR19[VAR20][msg.sender]);
VAR12[VAR20] = VAR12[VAR20].FUN3(VAR14);
VAR12[VAR13] = VAR12[VAR13].FUN4(VAR14);
VAR19[VAR20][msg.sender] = VAR19[VAR20][msg.sender].FUN3(VAR14);
emit Transfer(VAR20, VAR13, VAR14);
return true;
}
function FUN8(address VAR21, uint256 VAR14) public returns (bool) {
VAR19[msg.sender][VAR21] = VAR14;
emit FUN9(msg.sender, VAR21, VAR14);
return true;
}
function FUN6(address VAR15, address VAR21) public constant returns (uint256 VAR22) {
return VAR19[VAR15][VAR21];
}
function FUN10 (address VAR21, uint VAR23) public returns (bool VAR24) {
VAR19[msg.sender][VAR21] = VAR19[msg.sender][VAR21].FUN4(VAR23);
emit FUN9(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
function FUN11 (address VAR21, uint VAR25) public returns (bool VAR24) {
uint VAR26 = VAR19[msg.sender][VAR21];
if (VAR25 > VAR26) {
VAR19[msg.sender][VAR21] = 0;
} else {
VAR19[msg.sender][VAR21] = VAR26.FUN3(VAR25);
}
emit FUN9(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
}
contract VAR27
{
address public VAR10;
constructor() public {
VAR10 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR28;
}
function FUN12(address VAR29) public onlyOwner {
require(VAR29 != address(0));
VAR10 = VAR29;
}
}
contract VIRToken is VAR30, VAR27
{
string public VAR31 = "";
string public VAR32 = "";
uint public VAR33 = 18;
uint private constant VAR34 = 25e9 * 1e18;
constructor() public
{
VAR10 = msg.sender;
VAR6 = VAR34;
VAR12[VAR10] = VAR34;
}
}
0
---------------------------------
328 0x00f634a0bb03416816f8829928ef7d776f798414.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
function FUN1(address VAR3) public view returns(uint);
function transfer(address VAR4, uint value) public returns(bool);
}
contract VAR5 {
address public VAR6;
mapping(address => uint) public VAR7;
event FUN2(address indexed VAR8, address indexed VAR9, uint VAR10, uint VAR11);
event FUN3(address indexed sender, address indexed VAR9, uint VAR11);
event FUN4(address indexed VAR12, address indexed VAR9, uint VAR11);
constructor() public {
VAR6 = msg.sender;
}
modifier FUN5() {
require(msg.sender == VAR6);
VAR13;
}
function FUN6(address VAR3) internal view returns(bool) {
if (VAR3 != address(0) && address(this) != VAR3) return true;
else return false;
}
function FUN7(address VAR9) internal view returns(uint) {
if (address(0) == VAR9) return address(this).VAR14;
else return FUN8(VAR9).FUN1(address(this));
}
function FUN9(address VAR15) public VAR16 returns(bool) {
require(FUN6(VAR15));
VAR6 = VAR15;
return true;
}
function() public payable {
if (msg.value > 0) FUN10();
}
function FUN10() public payable returns(bool) {
require(msg.value > 0);
emit FUN3(msg.sender, address(0), msg.value);
return true;
}
function FUN11(address VAR12, address VAR9, uint VAR11) public VAR16 returns(bool) {
require(FUN6(VAR12) && VAR11 > 0 && VAR11 <= FUN7(VAR9));
if (address(0) == VAR9) VAR12.transfer(VAR11);
else if (!FUN8(VAR9).transfer(VAR12, VAR11)) revert();
emit FUN4(VAR12, VAR9, VAR11);
return true;
}
function FUN12(address VAR9, uint VAR10) public VAR16 returns(bool) {
require(FUN6(VAR9));
VAR7[VAR9] = VAR10;
return true;
}
function FUN13(address VAR9) public payable returns(bool) {
require(FUN6(VAR9) && msg.value > 0);
require(FUN7(VAR9) > 0 && VAR7[VAR9] > 0);
uint VAR17 = msg.value;
uint VAR18 = VAR17 * VAR7[VAR9];
uint VAR19 = FUN7(VAR9);
if (VAR18 > VAR19) {
msg.sender.transfer(VAR17 - (VAR19 / VAR7[VAR9]));
VAR18 = VAR19;
}
if (!FUN8(VAR9).transfer(msg.sender, VAR18)) revert();
emit FUN2(msg.sender, VAR9, VAR7[VAR9], VAR18);
return true;
}
}
0
---------------------------------
329 0x00fa44d91d7541d16dd18a48dd6a011de5e887df.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function FUN1(uint value) constant returns (uint);
}
contract VAR3 {
address public VAR4;
function FUN2() {
VAR4 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR4);
VAR5;
}
function FUN3(address VAR6) onlyOwner {
require(VAR6 != address(0));
VAR4 = VAR6;
}
}
contract VAR7 {
uint256 public VAR8;
function FUN4(address VAR9) constant returns (uint256);
function transfer(address VAR10, uint256 value) returns (bool);
event Transfer(address indexed VAR11, address indexed VAR10, uint256 value);
}
contract ERC20 is VAR7 {
function FUN5(address VAR4, address VAR12) constant returns (uint256);
function FUN6(address VAR11, address VAR10, uint256 value) returns (bool);
function FUN7(address VAR12, uint256 value) returns (bool);
event FUN8(address indexed VAR4, address indexed VAR12, uint256 value);
}
contract Sale is VAR3 {
Calculator VAR13;
ERC20 VAR14;
address VAR15;
uint256 public VAR16 = 100000000000;
event FUN9(address indexed VAR17, uint256 value, uint256 VAR18);
function FUN10(address VAR19, address VAR20) {
VAR15 = msg.sender;
VAR14 = FUN11(VAR19);
FUN12(VAR20);
}
function () payable {
FUN13();
}
function FUN13() payable {
uint256 VAR21 = msg.value;
uint256 VAR22 = VAR13.FUN1(VAR21);
assert(VAR22 >= VAR16);
VAR14.FUN6(VAR15, msg.sender, VAR22);
FUN9(msg.sender, VAR21, VAR22);
}
function FUN14(address VAR23) onlyOwner {
VAR15 = VAR23;
}
function FUN12(address VAR20) onlyOwner {
VAR13 = FUN15(VAR20);
}
function FUN16(uint256 VAR24) onlyOwner {
VAR16 = VAR24;
}
function FUN17(address VAR25, uint VAR18) onlyOwner {
require(VAR25 != 0x0);
VAR25.transfer(VAR18);
}
}
0
---------------------------------
330 0x00fc270c9cc13e878ab5363d00354bebf6f05c15.sol
pragma VAR1 ^0.5.9;
contract VAR2 {
function FUN1() public view returns (uint);
function FUN2(address VAR3) public view returns (uint VAR4);
function FUN3(address VAR3, address VAR5) public view returns (uint VAR6);
function transfer(address VAR7, uint VAR8) public returns (bool VAR9);
function FUN4(address VAR5, uint VAR8) public returns (bool VAR9);
function FUN5(address VAR10, address VAR7, uint VAR8) public returns (bool VAR9);
event Transfer(address indexed VAR10, address indexed VAR7, uint VAR8);
event FUN6(address indexed VAR3, address indexed VAR5, uint VAR8);
}
contract VAR11 {
address public VAR12;
address public VAR13;
event FUN7(address indexed VAR14, address indexed VAR15);
constructor() public {
VAR12 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR12);
VAR16;
}
function FUN8(address VAR17) public onlyOwner {
VAR13 = VAR17;
}
function FUN9() public {
require(msg.sender == VAR13);
emit FUN7(VAR12, VAR13);
VAR12 = VAR13;
VAR13 = address(0);
}
}
library VAR18 {
function FUN10(uint VAR19, uint VAR20) internal pure returns (uint VAR21) {
VAR21 = VAR19 + VAR20;
require(VAR21 >= VAR19);
}
function FUN11(uint VAR19, uint VAR20) internal pure returns (uint VAR21) {
require(VAR20 <= VAR19);
VAR21 = VAR19 - VAR20;
}
}
contract VNXLU is VAR2, VAR11 {
using SafeMath for uint;
string private VAR22  = "";
string private VAR23    = "";
uint8 private VAR24 = 18;
uint private VAR25;
mapping(address => uint) VAR26;
mapping(address => mapping(address => uint)) VAR27;
constructor(uint VAR28) public {
VAR25 = VAR28 * 10**uint(VAR24);
VAR26[VAR12] = VAR25;
emit Transfer(address(0), VAR12, VAR25);
}
function FUN12() public view returns (string VAR29) {
return VAR23;
}
function FUN13() public view returns (string VAR29) {
return VAR22;
}
function FUN14() public view returns (uint8) {
return VAR24;
}
function FUN1() public view returns (uint VAR30) {
return VAR25.FUN11(VAR26[address(0)]);
}
function FUN2(address VAR3) public view returns (uint VAR4) {
return VAR26[VAR3];
}
function transfer(address VAR7, uint VAR8) public returns (bool VAR9) {
VAR26[msg.sender] = VAR26[msg.sender].FUN11(VAR8);
VAR26[VAR7] = VAR26[VAR7].FUN10(VAR8);
emit Transfer(msg.sender, VAR7, VAR8);
return true;
}
//
function FUN4(address VAR5, uint VAR8) public returns (bool VAR9) {
VAR27[msg.sender][VAR5] = VAR8;
emit FUN6(msg.sender, VAR5, VAR8);
return true;
}
//
function FUN5(address VAR10, address VAR7, uint VAR8) public returns (bool VAR9) {
VAR26[VAR10] = VAR26[VAR10].FUN11(VAR8);
VAR27[VAR10][msg.sender] = VAR27[VAR10][msg.sender].FUN11(VAR8);
VAR26[VAR7] = VAR26[VAR7].FUN10(VAR8);
emit Transfer(VAR10, VAR7, VAR8);
return true;
}
function FUN3(address VAR3, address VAR5) public view returns (uint VAR6) {
return VAR27[VAR3][VAR5];
}
function () external payable {
revert();
}
function FUN15(address VAR31, uint VAR8) public onlyOwner returns (bool VAR9) {
return FUN16(VAR31).transfer(VAR12, VAR8);
}
}
0
---------------------------------
331 0x00ff9c740bac8cad80f1a3b1c4f20d7ea1c92637.sol
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 { function transfer(address VAR7, uint VAR8){  } }
contract VAR9 {
using SafeMath for uint256;
address public VAR10;
address public VAR11;
uint256 public VAR12 = 5000;
token VAR13;
uint256 public VAR14;
event FUN5(address indexed VAR15, address indexed VAR16, uint256 value, uint256 VAR8);
function FUN6() {
VAR10 = 0x5c48597920BF69ec9DA4eFdfCfCd05E10715E5Bd;
VAR11 = 0x06Be72C75867bB31E546575cC79317cF82cC4115;
VAR13 = FUN7(VAR11);
}
bool public VAR17 = true;
function FUN8(){
if (msg.sender != VAR10) throw;
VAR17 = true;
}
function FUN9(){
if(msg.sender != VAR10) throw;
VAR17 = false;
}
function FUN10(uint256 VAR18){
if(msg.sender != VAR10) throw;
VAR12 = VAR18;
}
function FUN11(address VAR19){
if(msg.sender != VAR10) throw;
VAR10 = VAR19;
}
function FUN12(address VAR20){
if(msg.sender!=VAR10) throw;
VAR13 = FUN7(VAR20);
}
function () payable {
FUN13(msg.sender);
}
function FUN13(address VAR16) payable {
require(VAR16 != 0x0);
require(FUN14());
uint256 VAR21 = msg.value;
uint256 VAR22 = (VAR21) * VAR12;
VAR14 = VAR14.FUN4(VAR21);
VAR13.transfer(VAR16, VAR22);
FUN5(msg.sender, VAR16, VAR21, VAR22);
FUN15();
}
function FUN15() internal {
if (!VAR10.FUN16(msg.value)) {
throw;
}
}
function FUN14() internal constant returns (bool) {
bool VAR23 = VAR17;
bool VAR24 = msg.value != 0;
return VAR23 && VAR24;
}
function FUN17(uint256 VAR25) {
if(msg.sender!=VAR10) throw;
VAR13.transfer(VAR10,VAR25);
}
}
0
---------------------------------
332 0x01003e4f6351c25dec19007f8f0adf1e9fe68bec.sol
pragma solidity 0.4.24;
interface VAR1 { function FUN1(address VAR2, uint256 VAR3, address VAR4, bytes VAR5) external; }
contract VAR6 {
string public VAR7;
string public VAR8;
uint8 public VAR9 = 18;
uint256 public VAR10;
mapping (address => uint256) public VAR11;
mapping (address => mapping (address => uint256)) public VAR12;
event Transfer(address indexed VAR13, address indexed VAR14, uint256 value);
event FUN2(address indexed VAR13, uint256 value);
function FUN3(uint256 VAR15, string VAR16, string VAR17) public {
VAR10 = VAR15 * 10 ** uint256(VAR9);
VAR11[msg.sender] = VAR10;
VAR7 = VAR16;
VAR8 = VAR17;
}
function FUN4(address VAR2, address VAR18, uint256 VAR3) internal {
require(VAR18 != 0x0);
require(VAR11[VAR2] >= VAR3);
require(VAR11[VAR18] + VAR3 > VAR11[VAR18]);
uint VAR19 = VAR11[VAR2] + VAR11[VAR18];
VAR11[VAR2] -= VAR3;
VAR11[VAR18] += VAR3;
Transfer(VAR2, VAR18, VAR3);
assert(VAR11[VAR2] + VAR11[VAR18] == VAR19);
}
function transfer(address VAR18, uint256 VAR3) public {
FUN4(msg.sender, VAR18, VAR3);
}
function FUN5(address VAR2, address VAR18, uint256 VAR3) public returns (bool VAR20){
require(VAR3 <= VAR12[VAR2][msg.sender]);
VAR12[VAR2][msg.sender] -= VAR3;
FUN4(VAR2, VAR18, VAR3);
return true;
}
function FUN6(address VAR21, uint256 VAR3) public returns (bool VAR20) {
VAR12[msg.sender][VAR21] = VAR3;
return true;
}
function FUN7(address VAR21, uint256 VAR3, bytes VAR5) public returns (bool VAR20) {
tokenRecipient VAR22 = FUN8(VAR21);
if (FUN6(VAR21, VAR3)) {
VAR22.FUN1(msg.sender, VAR3, this, VAR5);
return true;
}
}
function FUN9(uint256 VAR3) public returns (bool VAR20) {
require(VAR11[msg.sender] >= VAR3);
VAR11[msg.sender] -= VAR3;
VAR10 -= VAR3;
FUN2(msg.sender, VAR3);
return true;
}
function FUN10(address VAR2, uint256 VAR3) public returns (bool VAR20) {
require(VAR11[VAR2] >= VAR3);
require(VAR3 <= VAR12[VAR2][msg.sender]);
VAR11[VAR2] -= VAR3;
VAR12[VAR2][msg.sender] -= VAR3;
VAR10 -= VAR3;
FUN2(VAR2, VAR3);
return true;
}
}
0
---------------------------------
333 0x010583963f3ae4929253975ebd6bab0066870828.sol
pragma VAR1 ^0.4.14;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) internal returns (uint) {
assert(VAR4 > 0);
uint VAR5 = VAR3 / VAR4;
assert(VAR3 == VAR4 * VAR5 + VAR3 % VAR4);
return VAR5;
}
function FUN3(uint VAR3, uint VAR4) internal returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint64 VAR3, uint64 VAR4) internal constant returns (VAR6) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN6(uint64 VAR3, uint64 VAR4) internal constant returns (VAR6) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN7(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN8(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function assert(bool VAR7) internal {
if (!VAR7) {
throw;
}
}
}
contract VAR8 {
address public VAR9;
function FUN9() {
VAR9 = msg.sender;
}
modifier onlyOwner {
if (msg.sender != VAR9) throw;
VAR10;
}
function FUN10(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract VAR12 {
uint public VAR13;
function FUN11(address VAR14) constant returns (uint);
function transfer(address VAR15, uint value);
event Transfer(address indexed VAR16, address indexed VAR15, uint value);
}
contract ERC20 is VAR12 {
function FUN12(address VAR9, address VAR17) constant returns (uint);
function FUN13(address VAR16, address VAR15, uint value);
function FUN14(address VAR17, uint value);
event FUN15(address indexed VAR9, address indexed VAR17, uint value);
}
contract newToken is VAR12 {
using SafeMath for uint;
mapping(address => uint) VAR18;
modifier FUN16(uint VAR19) {
if(msg.VAR20.VAR21 < VAR19 + 4) {
throw;
}
VAR10;
}
function transfer(address VAR22, uint VAR23) FUN16(2 * 32) {
VAR18[msg.sender] = VAR18[msg.sender].FUN3(VAR23);
VAR18[VAR22] = VAR18[VAR22].FUN4(VAR23);
Transfer(msg.sender, VAR22, VAR23);
}
function FUN11(address VAR24) constant returns (uint VAR25) {
return VAR18[VAR24];
}
}
contract StandardToken is VAR26, VAR27 {
mapping (address => mapping (address => uint)) VAR28;
function FUN13(address VAR29, address VAR22, uint VAR23) FUN16(3 * 32) {
var VAR30 = VAR28[VAR29][msg.sender];
VAR18[VAR22] = VAR18[VAR22].FUN4(VAR23);
VAR18[VAR29] = VAR18[VAR29].FUN3(VAR23);
VAR28[VAR29][msg.sender] = VAR30.FUN3(VAR23);
Transfer(VAR29, VAR22, VAR23);
}
function FUN14(address VAR31, uint VAR23) {
if ((VAR23 != 0) && (VAR28[msg.sender][VAR31] != 0)) throw;
VAR28[msg.sender][VAR31] = VAR23;
FUN15(msg.sender, VAR31, VAR23);
}
function FUN12(address VAR24, address VAR31) constant returns (uint VAR32) {
return VAR28[VAR24][VAR31];
}
}
contract CoCoCoin is VAR33, VAR8 {
string public constant VAR34 = "";
string public constant VAR35 = "";
uint public constant VAR36 = 4;
uint256 public VAR37;
function FUN17 () {
VAR13 = 88000000 * 10 ** VAR36;
VAR18[msg.sender] = VAR13;
VAR37 = VAR13;
Transfer(0, this, VAR13);
Transfer(this, msg.sender, VAR13);
}
}
0
---------------------------------
334 0x010589b7c33034b802f7dba2c88cc9cec0f46673.sol
pragma solidity 0.5.4;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
require(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
require(VAR3 > 0);
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
require(VAR3 <= VAR2);
uint256 VAR4 = VAR2 - VAR3;
return VAR4;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
require(VAR4 >= VAR2);
return VAR4;
}
function FUN5(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
require(VAR3 != 0);
return VAR2 % VAR3;
}
}
contract VAR5 {
using SafeMath for uint256;
mapping (address => uint256) private VAR6;
mapping (address => mapping (address => uint256)) private VAR7;
event Transfer(address indexed VAR8, address indexed VAR9, uint256 value);
event FUN6(address indexed VAR10, address indexed VAR11, uint256 value);
uint256 private VAR12;
function FUN7() public view returns (uint256) {
return VAR12;
}
function FUN8(address VAR10) public view returns (uint256) {
return VAR6[VAR10];
}
function FUN9(address VAR10, address VAR11) public view returns (uint256) {
return VAR7[VAR10][VAR11];
}
function transfer(address VAR9, uint256 value) public returns (bool) {
FUN10(msg.sender, VAR9, value);
return true;
}
function FUN11(address VAR11, uint256 value) public returns (bool) {
require(VAR11 != address(0));
VAR7[msg.sender][VAR11] = value;
emit FUN6(msg.sender, VAR11, value);
return true;
}
function FUN12(address VAR8, address VAR9, uint256 value) public returns (bool) {
VAR7[VAR8][msg.sender] = VAR7[VAR8][msg.sender].FUN3(value);
FUN10(VAR8, VAR9, value);
emit FUN6(VAR8, msg.sender, VAR7[VAR8][msg.sender]);
return true;
}
function FUN13(address VAR11, uint256 VAR13) public returns (bool) {
require(VAR11 != address(0));
VAR7[msg.sender][VAR11] = VAR7[msg.sender][VAR11].FUN4(VAR13);
emit FUN6(msg.sender, VAR11, VAR7[msg.sender][VAR11]);
return true;
}
function FUN14(address VAR11, uint256 VAR14) public returns (bool) {
require(VAR11 != address(0));
VAR7[msg.sender][VAR11] = VAR7[msg.sender][VAR11].FUN3(VAR14);
emit FUN6(msg.sender, VAR11, VAR7[msg.sender][VAR11]);
return true;
}
function FUN10(address VAR8, address VAR9, uint256 value) internal {
require(VAR9 != address(0));
VAR6[VAR8] = VAR6[VAR8].FUN3(value);
VAR6[VAR9] = VAR6[VAR9].FUN4(value);
emit Transfer(VAR8, VAR9, value);
}
function FUN15(address VAR15, uint256 value) internal {
require(VAR15 != address(0));
VAR12 = VAR12.FUN4(value);
VAR6[VAR15] = VAR6[VAR15].FUN4(value);
emit Transfer(address(0), VAR15, value);
}
}
contract SoundMoneyCoin is VAR5 {
uint256 constant public VAR16 = 5000000;
uint256 constant public VAR17 = 100000;
uint256 constant public VAR18 = 2100000000000000;
string public VAR19 = "";
string public VAR20 = "";
uint8 public VAR21 = 8;
uint256 public VAR22;
address public VAR23;
constructor() public {
VAR23 = msg.sender;
}
function FUN16() public {
uint256 VAR24 = VAR25.VAR26;
require(VAR24 > VAR22);
require(FUN7() < VAR18);
VAR22 = VAR24;
FUN15(msg.sender, VAR16);
FUN15(VAR23, VAR17);
}
}
0
---------------------------------
335 0x01126516d76cd1d50d92e9a3f8e3700cf945a6e7.sol
pragma solidity 0.4.18;
contract VAR1 {
address public VAR2 = msg.sender;
function FUN1(address VAR3) external returns(bool VAR4) {
require( FUN2() );
VAR2 = VAR3;
return true;
}
function FUN2() internal view returns(bool) {
return VAR2 == msg.sender;
}
modifier VAR5 {
require( FUN2() );
VAR6;
}
}
contract VAR7 {
function FUN3(uint256 VAR8, uint256 VAR9) internal pure returns(uint256) {
if ( VAR9 > 0 ) {
assert( VAR8 + VAR9 > VAR8 );
}
return VAR8 + VAR9;
}
function FUN4(uint256 VAR8, uint256 VAR9) internal pure returns(uint256) {
if ( VAR9 > 0 ) {
assert( VAR8 - VAR9 < VAR8 );
}
return VAR8 - VAR9;
}
function FUN5(uint256 VAR8, uint256 VAR9) internal pure returns(uint256) {
uint256 VAR10 = VAR8 * VAR9;
assert(VAR8 == 0 || VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN6(uint256 VAR8, uint256 VAR9) internal pure returns(uint256) {
return VAR8 / VAR9;
}
}
contract TokenDB is VAR7, VAR1 {
mapping(address => uint256) public VAR11;
mapping(address => uint256) public VAR12;
address public VAR13;
address public VAR14;
function FUN7(address VAR15, uint256 VAR16, uint256 VAR17, uint256 VAR18,
uint256 VAR19, uint256 VAR20, uint256 VAR21, bool VAR22) external returns(bool VAR4, uint256 VAR23) {}
function FUN8(uint256 VAR23) external returns (bool VAR4) {}
function FUN9(uint256 VAR24) public constant returns(address VAR15, uint256 VAR16, uint256 VAR25,
uint256 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR26, bool VAR22, bool VAR27) {}
}
contract VAR28 {
function FUN10(address VAR2, uint256 value) external returns (bool VAR4) {}
}
contract Deposits is VAR1, VAR7 {
struct VAR29 {
uint256 VAR30;
uint256 VAR31;
uint256 VAR32;
uint256 VAR33;
uint256 VAR20;
bool VAR22;
bool VAR27;
}
struct VAR34 {
address VAR15;
uint256 VAR16;
uint256 VAR25;
uint256 VAR17;
uint256 VAR18;
uint256 VAR19;
uint256 VAR20;
uint256 VAR26;
bool    VAR22;
bool    VAR27;
}
mapping(uint256 => VAR29) public VAR35;
uint256 public VAR36;
address public VAR13;
address public VAR37;
address public VAR38;
uint256 public VAR26 = 1e3;
function FUN11(address VAR39, address VAR40, address VAR41) {
VAR13 = VAR39;
VAR37 = VAR40;
VAR38 = VAR41;
}
function FUN12(address VAR42) external VAR5 {
VAR37 = VAR42;
}
function FUN13(address VAR43) external VAR5 {
VAR13 = VAR43;
}
function FUN14(address VAR44) external VAR5 {
VAR38 = VAR44;
}
function FUN15(uint256 VAR30, uint256 VAR31, uint256 VAR32,
uint256 VAR33, uint256 VAR20, bool VAR22) external VAR5 {
VAR36 += 1;
uint256 VAR45 = VAR36;
VAR35[VAR45] = FUN16(
VAR30,
VAR31,
VAR32,
VAR33,
VAR20,
VAR22,
true
);
FUN17(
VAR45,
VAR30,
VAR31,
VAR32,
VAR33,
VAR20,
VAR26,
VAR22
);
}
function FUN18(uint256 VAR45) external VAR5 {
delete VAR35[VAR45].VAR27;
FUN19(VAR45);
}
function FUN20(uint256 VAR16, uint256 VAR46) external VAR47 {
require( VAR35[VAR46].VAR27 );
require( VAR35[VAR46].VAR31 <= VAR16 );
uint256 VAR48 = FUN21(VAR37).FUN22(msg.sender);
uint256 VAR49 = FUN21(VAR37).FUN23(msg.sender);
require( FUN4(VAR48, VAR49) >= VAR16 );
FUN24 (VAR4, VAR23) = FUN21(VAR37).FUN7(
msg.sender,
VAR16,
FUN3(VAR50.VAR51, VAR35[VAR46].VAR30),
VAR35[VAR46].VAR32,
VAR35[VAR46].VAR33,
VAR35[VAR46].VAR20,
VAR26,
VAR35[VAR46].VAR22
);
require( VAR4 );
FUN25(VAR23, msg.sender);
}
function FUN8(address VAR52, uint256 VAR23) external VAR47 {
address VAR53 = VAR52;
if ( VAR53 == 0x00 ) {
VAR53 = msg.sender;
}
FUN24 (VAR15, VAR16, VAR25, VAR17, VAR18, VAR19, VAR20,
VAR54, VAR22, VAR27) = FUN21(VAR37).FUN9(VAR23);
FUN26(VAR53, VAR23, FUN27(VAR15, VAR16, VAR25, VAR17, VAR18, VAR19, VAR20, VAR54, VAR22, VAR27));
}
function FUN26(address VAR52, uint256 VAR23, deposits_s VAR55) internal {
require( VAR55.VAR27 && VAR55.VAR15 == msg.sender );
FUN24 (VAR56, VAR20) = FUN28(VAR55);
if ( VAR56 > 0 ) {
require( FUN29(VAR13).FUN10(VAR52, VAR56) );
}
if ( VAR20 > 0 ) {
require( FUN29(VAR13).FUN10(VAR38, VAR20) );
}
require( FUN21(VAR37).FUN8(VAR23) );
FUN30(VAR23, msg.sender, VAR52, VAR56, VAR20);
}
function FUN28(deposits_s VAR55) internal view returns (uint256 VAR56, uint256 VAR20) {
if ( ! VAR55.VAR27 || VAR55.VAR16 <= 0 || VAR55.VAR17 <= VAR55.VAR25 || VAR50.VAR51 <= VAR55.VAR25 ) { return (0, 0); }
uint256 VAR57;
uint256 VAR58;
if ( VAR55.VAR17 <= VAR50.VAR51 ) {
VAR57 = VAR55.VAR18;
VAR58 = FUN4(VAR55.VAR17, VAR55.VAR25);
} else {
require( VAR55.VAR22 );
VAR57 = VAR55.VAR19;
VAR58 = FUN4(VAR50.VAR51, VAR55.VAR25);
}
if ( VAR57 == 0 ) { return (0, 0); }
VAR56 = FUN6(FUN5(FUN6(FUN6(FUN5(VAR55.VAR16, VAR57), 100), VAR55.VAR26), VAR58), FUN4(VAR55.VAR17, VAR55.VAR25));
if ( VAR55.VAR20 > 0 && VAR56 > 0) {
VAR20 = FUN6(FUN6(FUN5(VAR56, VAR55.VAR20), 100), VAR55.VAR26);
}
if ( VAR20 > 0 ) {
VAR56 = FUN4(VAR56, VAR20);
}
}
function FUN31(uint256 VAR23) public view returns(uint256, uint256) {
FUN24 (VAR15, VAR16, VAR25, VAR17, VAR18, VAR19, VAR20,
VAR54, VAR22, VAR27) = FUN21(VAR37).FUN9(VAR23);
return FUN28(FUN27(VAR15, VAR16, VAR25, VAR17, VAR18, VAR19, VAR20, VAR54, VAR22, VAR27));
}
modifier VAR47 {
require( FUN21(VAR37).FUN32() == VAR13 );
require( FUN21(VAR37).FUN33() == address(this) );
VAR6;
}
event FUN17(uint256 indexed VAR45, uint256 VAR30, uint256 VAR31,
uint256 VAR32, uint256 VAR33, uint256 VAR20, uint256 VAR26, bool VAR22);
event FUN19(uint256 indexed VAR45);
event FUN25(uint256 indexed VAR23, address VAR2);
event FUN30(uint256 indexed VAR23, address VAR2, address VAR52, uint256 VAR56, uint256 VAR20);
}
0
---------------------------------
336 0x0119d137982ec5d5ca3ecc2a2c234aae08192745.sol
pragma VAR1 ^0.5.2;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
function FUN5(address VAR7, uint256 VAR8, address VAR9, bytes memory VAR10) public;
}
contract VAR11 {
using SafeMath for uint;
address public VAR12 = address(0);
string public VAR13;
string public  VAR14;
uint8 public VAR15 = 18;
string public VAR16;
uint VAR17;
mapping(address => uint) VAR18;
mapping(address => mapping(address => uint)) VAR19;
event Transfer(address indexed VAR7, address indexed VAR20, uint VAR8);
event FUN6(address indexed VAR21, address indexed VAR22, uint VAR8);
constructor (string memory VAR23, string memory VAR24, string memory VAR25) public {
VAR14 = VAR23;
VAR13 = VAR24;
VAR16 = VAR25;
emit Transfer(address(this), VAR12, 1e26);
}
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR26;
}
function FUN7() public view returns (uint) {
return VAR17  - VAR18[address(0)];
}
function FUN8(address VAR21) public view returns (uint VAR27) {
return VAR18[VAR21];
}
function transfer(address VAR20, uint VAR8) public returns (bool VAR28) {
VAR18[msg.sender] = VAR18[msg.sender].FUN2(VAR8);
if (VAR20 == address(this)) {
msg.sender.transfer(VAR8);
VAR17 = VAR17.FUN2(VAR8);
emit Transfer(msg.sender, address(0), VAR8);
} else {
VAR18[VAR20] = VAR18[VAR20].FUN1(VAR8);
emit Transfer(msg.sender, VAR20, VAR8);
}
return true;
}
function FUN9(address VAR22, uint VAR8) public returns (bool VAR28) {
if (VAR22 == address(this)) revert();
VAR19[msg.sender][VAR22] = VAR8;
emit FUN6(msg.sender, VAR22, VAR8);
return true;
}
function FUN10(address VAR7, address VAR20, uint VAR8) public returns (bool VAR28) {
VAR18[VAR7] = VAR18[VAR7].FUN2(VAR8);
VAR19[VAR7][msg.sender] = VAR19[VAR7][msg.sender].FUN2(VAR8);
VAR18[VAR20] = VAR18[VAR20].FUN1(VAR8);
emit Transfer(VAR7, VAR20, VAR8);
return true;
}
function FUN11(address VAR21, address VAR22) public view returns (uint VAR29) {
return VAR19[VAR21][VAR22];
}
function FUN12(address VAR22, uint VAR8, bytes memory VAR10) public returns (bool VAR28) {
VAR19[msg.sender][VAR22] = VAR8;
emit FUN6(msg.sender, VAR22, VAR8);
FUN13(VAR22).FUN5(msg.sender, VAR8, address(this), VAR10);
return true;
}
function () external payable {
if (msg.value > 0) FUN14();
}
function FUN14() public payable {
require(msg.value > 0);
VAR17 = VAR17.FUN1(msg.value);
VAR18[msg.sender] = VAR18[msg.sender].FUN1(msg.value);
emit Transfer(address(0), msg.sender, msg.value);
}
}
0
---------------------------------
337 0x011d9dfb4681f2d2245bbb04edd6a9eedf361e5c.sol
pragma VAR1 ^0.4.15;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) internal returns (uint) {
assert(VAR4 > 0);
uint VAR5 = VAR3 / VAR4;
assert(VAR3 == VAR4 * VAR5 + VAR3 % VAR4);
return VAR5;
}
function FUN3(uint VAR3, uint VAR4) internal returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint VAR3, uint VAR4) internal returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint64 VAR3, uint64 VAR4) internal constant returns (VAR6) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN6(uint64 VAR3, uint64 VAR4) internal constant returns (VAR6) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN7(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN8(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function assert(bool VAR7) internal {
if (!VAR7) {
throw;
}
}
}
contract VAR8 {
address public VAR9;
function FUN9() {
VAR9 = msg.sender;
}
modifier onlyOwner {
if (msg.sender != VAR9) throw;
VAR10;
}
function FUN10(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract VAR12 {
uint public VAR13;
function FUN11(address VAR14) constant returns (uint);
function transfer(address VAR15, uint value);
event Transfer(address indexed VAR16, address indexed VAR15, uint value);
}
contract ERC20 is VAR12 {
function FUN12(address VAR9, address VAR17) constant returns (uint);
function FUN13(address VAR16, address VAR15, uint value);
function FUN14(address VAR17, uint value);
event FUN15(address indexed VAR9, address indexed VAR17, uint value);
}
contract newToken is VAR12 {
using SafeMath for uint;
mapping(address => uint) VAR18;
modifier FUN16(uint VAR19) {
if(msg.VAR20.VAR21 < VAR19 + 4) {
throw;
}
VAR10;
}
function transfer(address VAR22, uint VAR23) FUN16(2 * 32) {
VAR18[msg.sender] = VAR18[msg.sender].FUN3(VAR23);
VAR18[VAR22] = VAR18[VAR22].FUN4(VAR23);
Transfer(msg.sender, VAR22, VAR23);
}
function FUN11(address VAR24) constant returns (uint VAR25) {
return VAR18[VAR24];
}
}
contract ZGR is VAR26, VAR27 {
mapping (address => mapping (address => uint)) VAR28;
function FUN13(address VAR29, address VAR22, uint VAR23) FUN16(3 * 32) {
var VAR30 = VAR28[VAR29][msg.sender];
VAR18[VAR22] = VAR18[VAR22].FUN4(VAR23);
VAR18[VAR29] = VAR18[VAR29].FUN3(VAR23);
VAR28[VAR29][msg.sender] = VAR30.FUN3(VAR23);
Transfer(VAR29, VAR22, VAR23);
}
function FUN14(address VAR31, uint VAR23) {
if ((VAR23 != 0) && (VAR28[msg.sender][VAR31] != 0)) throw;
VAR28[msg.sender][VAR31] = VAR23;
FUN15(msg.sender, VAR31, VAR23);
}
function FUN12(address VAR24, address VAR31) constant returns (uint VAR32) {
return VAR28[VAR24][VAR31];
}
}
contract Zigger is VAR33, VAR8 {
string public constant VAR34 = "";
string public constant VAR35 = "";
uint public constant VAR36 = 8;
uint256 public VAR37;
function FUN17 () {
VAR13 = 30000000 * 10 ** VAR36;
VAR18[msg.sender] = VAR13;
VAR37 = VAR13;
Transfer(0, this, VAR13);
Transfer(this, msg.sender, VAR13);
}
}
0
---------------------------------
338 0x012052cfcdc8044f021b764b71d8855a06543abd.sol
pragma VAR1 ^0.5.2;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
pragma VAR1 ^0.5.2;
contract VAR6 {
address private VAR7;
event FUN6(address indexed VAR8, address indexed VAR9);
constructor () internal {
VAR7 = msg.sender;
emit FUN6(address(0), VAR7);
}
function FUN7() public view returns (address) {
return VAR7;
}
modifier onlyOwner() {
require(FUN8());
VAR10;
}
function FUN8() public view returns (bool) {
return msg.sender == VAR7;
}
function FUN9() public onlyOwner {
emit FUN6(VAR7, address(0));
VAR7 = address(0);
}
function FUN10(address VAR9) public onlyOwner {
FUN11(VAR9);
}
function FUN11(address VAR9) internal {
require(VAR9 != address(0));
emit FUN6(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract EtherStake is VAR6 {
using SafeMath for uint;
address payable public  VAR11;
address public VAR12;
address public VAR13;
uint public VAR14;
uint public VAR15;
uint public VAR16;
uint public VAR17;
uint public VAR18;
uint public VAR19;
uint public VAR20;
uint public VAR21;
mapping(address => string) public VAR22;
mapping(address => string) public VAR23;
uint8 constant VAR24 = 1;
uint8 constant VAR25 = 64;
mapping (uint => uint) internal VAR26;
mapping (uint => uint) internal VAR27;
mapping (address => uint) public VAR28;
mapping(uint => mapping(uint => VAR29)) public VAR30;
event FUN12(address VAR31, uint VAR32);
event FUN13(
address VAR31,
uint VAR33);
struct VAR29 {
mapping(address => uint) VAR34;
uint VAR35;
uint VAR36;
}
constructor() public {
VAR17 = 1;
VAR20 = 86400;
VAR21 = 604800;
VAR18 = VAR37 + VAR21;
VAR19 = VAR37 + VAR20;
VAR14 = 1100;
VAR15 = 1000000000;
}
function() external payable {
require(msg.value >= 10000000000000000 && msg.value < 1000000000000000000000, "");
if(VAR37 > VAR18){
FUN14();
}
uint VAR38 = msg.value.FUN1(VAR14);
VAR38 = VAR38.FUN2(1000);
VAR30[VAR17][VAR16].VAR34[msg.sender] += VAR38;
VAR11 = msg.sender;
VAR15 += VAR38;
FUN15(VAR38);
emit FUN13(msg.sender, VAR38);
}
function FUN16(address VAR39) public payable {
require(msg.value >= 10000000000000000, "");
if(VAR39 != address(0)){
uint VAR40 = msg.value.FUN2(50);
if(VAR39 == msg.sender) {
VAR39 = 0x93D43eeFcFbE8F9e479E172ee5d92DdDd2600E3b;
}
VAR30[VAR17][VAR16].VAR34[VAR39] += VAR40;
}
if(VAR37 > VAR18){
FUN14();
}
uint VAR38 = msg.value.FUN1(VAR14);
VAR38 = VAR38.FUN2(1000);
VAR30[VAR17][VAR16].VAR34[msg.sender] += VAR38;
VAR11 = msg.sender;
VAR15 += VAR38;
FUN15(VAR38);
emit FUN13(msg.sender, VAR38);
}
function FUN17(string memory VAR41) public {
bytes memory VAR42 = bytes(VAR41);
require(VAR42.VAR43 >= VAR24, "");
require(VAR42.VAR43 <= VAR25, "");
VAR22[msg.sender] = VAR41;
}
function FUN18(address VAR44)
external
view
returns (
string memory VAR45
) {
VAR45 = VAR22[VAR44];
}
function FUN19(string memory VAR46) public {
bytes memory VAR42 = bytes(VAR46);
require(VAR42.VAR43 >= VAR24, "");
require(VAR42.VAR43 <= VAR25, "");
VAR23[msg.sender] = VAR46;
}
function FUN20(address VAR44)
external
view
returns (
string memory VAR47
) {
VAR47 = VAR23[VAR44];
}
function FUN21(address VAR44) public view returns(uint VAR48) {
uint VAR49;
uint VAR50;
for(uint VAR5 = 0 ; VAR5 < VAR16; VAR5++) {
uint VAR51 = VAR30[VAR17][VAR5].VAR34[VAR44];
if(VAR51 == 0 && VAR50 == 0){
continue;
}
VAR50 += VAR51;
uint VAR52 = VAR30[VAR17][VAR5].VAR36;
uint VAR53 = VAR30[VAR17][VAR5].VAR35;
uint VAR54 = VAR50.FUN1(VAR52)/VAR53;
VAR49 += VAR54;
}
return VAR49.FUN2(2);
}
function FUN22(address VAR44) public view returns(uint VAR55) {
uint VAR56;
for(uint VAR57 = 1 ; VAR57 < VAR17; VAR57++) {
uint VAR50;
uint VAR58 = VAR27[VAR57];
for(uint VAR59 = 0 ; VAR59 < VAR58; VAR59++) {
uint VAR51 = VAR30[VAR57][VAR59].VAR34[VAR44];
if(VAR51 == 0 && VAR50 == 0){
continue;
}
VAR50 += VAR51;
uint VAR52 = VAR30[VAR57][VAR59].VAR36;
uint VAR53 = VAR30[VAR57][VAR59].VAR35;
uint VAR54 = VAR50.FUN1(VAR52)/VAR53;
VAR56 += VAR54;
}
}
return VAR56.FUN2(2);
}
function FUN23(address VAR44) public view returns(uint VAR60) {
uint VAR49;
VAR49 += FUN22(VAR44);
VAR49 += FUN21(VAR44);
return VAR49;
}
function FUN24(address VAR44) public view returns(uint VAR61) {
uint VAR50;
for(uint VAR5 = 0 ; VAR5 <= VAR16; VAR5++) {
uint VAR51 = VAR30[VAR17][VAR5].VAR34[VAR44];
if(VAR51 == 0 && VAR50 == 0){
continue;
}
VAR50 += VAR51;
}
return VAR50;
}
function FUN25(uint VAR62) external{
require(VAR62 >= 10000000000000000, "");
uint VAR63 = FUN23(msg.sender);
VAR28[msg.sender] += VAR62;
uint VAR64 = VAR28[msg.sender];
uint VAR65 = VAR63.FUN3(VAR64);
require(VAR65 >= 0);
if(VAR37 > VAR18){
FUN14();
}
VAR30[VAR17][VAR16].VAR34[msg.sender] += VAR62;
VAR11 = msg.sender;
VAR15 += VAR62;
FUN15(VAR62);
emit FUN13(msg.sender, VAR62);
}
function FUN26(uint VAR62) external{
require(VAR62 >= 10000000000000000, "");
uint VAR63 = FUN23(msg.sender);
VAR28[msg.sender] += VAR62;
uint VAR64 = VAR28[msg.sender];
uint VAR65 = VAR63.FUN3(VAR64);
require(VAR65 >= 0);
msg.sender.transfer(VAR62);
emit FUN12(msg.sender, VAR62);
}
function FUN27(address payable VAR66) external{
require(msg.sender == VAR12);
uint VAR63 = FUN23(VAR66);
uint VAR64 = VAR28[VAR66];
uint VAR65 = VAR63.FUN3(VAR64);
VAR28[VAR66] += VAR63;
require(VAR65 >= 10000000000000000, "");
if(VAR37 > VAR18){
FUN14();
}
VAR30[VAR17][VAR16].VAR34[VAR66] += VAR65;
VAR11 = VAR66;
VAR15 += VAR65;
FUN15(VAR65);
emit FUN13(msg.sender, VAR65);
}
function FUN28(address payable VAR67) external{
require(msg.sender == VAR13);
uint VAR63 = FUN23(VAR67);
uint VAR64 = VAR28[VAR67];
uint VAR65 = VAR63.FUN3(VAR64);
VAR28[VAR67] += VAR65;
require(VAR65 >= 0);
VAR67.transfer(VAR65);
emit FUN12(VAR67, VAR65);
}
function FUN15(uint VAR33) private {
uint VAR68 = VAR33/1000000000000;
if(VAR68 < VAR20){
VAR18 += VAR68;
}else{
VAR18 += VAR20;
}
if(VAR37 > VAR19) {
FUN29();
}
}
function FUN29() private {
VAR30[VAR17][VAR16].VAR35 = VAR15;
VAR30[VAR17][VAR16].VAR36 = VAR15 - VAR30[VAR17][VAR16-1].VAR35;
if(VAR14 > 1000) {
VAR14 -= 1;
}
VAR19 = VAR37 + VAR20;
++VAR16;
}
function FUN14() private {
VAR30[VAR17][VAR16].VAR35 = VAR15;
VAR30[VAR17][VAR16].VAR36 = VAR15 - VAR30[VAR17][VAR16-1].VAR35;
VAR27[VAR17] = VAR16;
FUN30();
FUN31();
}
function FUN30() private {
uint VAR69 = VAR30[VAR17][VAR16].VAR35.FUN2(2) + VAR26[VAR17];
VAR26[VAR17+1] = VAR15.FUN2(10);
VAR69 -= VAR26[VAR17+1];
VAR11.transfer(VAR69);
emit FUN12(VAR11, VAR69);
}
function FUN31() private {
VAR17 += 1;
VAR18 = VAR37 + VAR21;
VAR19 = VAR37;
VAR16 = 0;
VAR14 = 1100;
VAR15 = 10000000;
}
function FUN32()
public view
returns(uint256) {
return(VAR18.FUN3(VAR37));
}
function FUN33()
public view
returns(uint256) {
return(VAR19.FUN3(VAR37));
}
function FUN34(uint VAR70)
public view
returns(uint256) {
return(VAR26[VAR70]);
}
function FUN35()
public view
returns(uint256){
uint VAR69 = VAR15/2 + VAR26[VAR17];
uint VAR71 = VAR15/10;
VAR69 -= VAR71;
return VAR69;
}
function FUN36(uint256 VAR70, uint256 VAR72, address VAR44)
public view
returns(uint256){
uint VAR73 = VAR30[VAR70][VAR72].VAR34[VAR44];
return VAR73;
}
function FUN37(address VAR74, address VAR75) external onlyOwner {
VAR13 = VAR74;
VAR12 = VAR75;
}
}
contract VAR76 {
address payable public VAR77;
address payable public VAR78;
constructor(address payable VAR79) public {
VAR77 = VAR79;
VAR78 = msg.sender;
}
function() external payable{
require(msg.value >= 10000000000000000, "");
EtherStake VAR80 = FUN38(VAR77);
VAR80.FUN28(msg.sender);
}
function FUN39() external {
VAR78.transfer(address(this).VAR81);
}
}
0
---------------------------------
339 0x012259fdb06c0f5fe189a6f4afcd962a4057dd62.sol
pragma solidity 0.4.18;
contract VAR1 {
string public VAR2 = "";
string public VAR3 = "";
uint8 public constant VAR4 = 18;
uint256 VAR5 = 0;
uint256 VAR6 = 0;
uint256 VAR7 = 0;
uint256 VAR8 = 0;
uint256 VAR9 = 0;
uint256 VAR10 = 2;
uint256 VAR11 = 3;
uint256 VAR12 = 4e15;
uint256 VAR13 = 8e15;
uint256 VAR14 = 5e16;
uint256 VAR15 = 0;
address VAR16 = 0;
address VAR17 = 0;
address VAR18 = 0;
bool VAR19 = false;
bool VAR20 = false;
bool VAR21 = false;
event Transfer(address indexed VAR22, address indexed VAR23, uint256 VAR24);
event FUN1(address indexed VAR25, address indexed VAR26, uint256 VAR24);
event FUN2(address indexed VAR25, uint256 VAR24);
mapping(address => uint256) VAR27;
mapping(address => mapping(address => uint256)) VAR28;
mapping(address => bool) public VAR29;
modifier onlyOwner() {
require(msg.sender == VAR18);
VAR30;
}
function FUN3() public {
VAR18 = msg.sender;
}
function() public payable {
if (VAR20) {
uint256 VAR31;
if (((VAR8 + VAR31) > VAR6) && VAR6 > 0) revert();
if (!VAR16.FUN4(msg.value)) revert();
if (VAR29[msg.sender] == false) {
VAR31 = VAR9 * 1e18;
VAR8 += VAR31;
VAR27[msg.sender] += VAR31;
VAR5 += VAR31;
Transfer(this, msg.sender, VAR31);
VAR29[msg.sender] = true;
}
require(msg.value <= VAR14);
if (msg.value >= 1e15) {
if (msg.value >= VAR13) {
VAR31 = msg.value * VAR15 * VAR11;
} else {
if (msg.value >= VAR12) {
VAR31 = msg.value * VAR15 * VAR10;
} else {
VAR31 = msg.value * VAR15;
}
}
VAR8 += VAR31;
VAR27[msg.sender] += VAR31;
VAR5 += VAR31;
Transfer(this, msg.sender, VAR31);
}
} else {
revert();
}
}
function FUN5(string VAR32, string VAR33, uint256 VAR34, uint256 VAR35, uint256 VAR36, address VAR37, address VAR38, uint256 VAR39) public {
if (msg.sender == VAR18 && !VAR19) {
VAR2 = VAR33;
VAR3 = VAR32;
VAR9 = VAR39;
VAR15 = VAR34;
VAR6 = VAR35 * 1e18;
if (VAR36 > 0) {
VAR7 = VAR36 * 1e18;
VAR5 = VAR7;
VAR27[VAR18] = VAR5;
VAR8 += VAR5;
Transfer(this, VAR18, VAR5);
}
VAR16 = VAR38;
if (VAR16 == 0) VAR16 = VAR18;
VAR17 = VAR37;
VAR19 = true;
}
}
function FUN6(uint256 VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR43, uint256 VAR44) onlyOwner public {
VAR10 = VAR40;
VAR11 = VAR41;
VAR12 = VAR42;
VAR13 = VAR43;
VAR14 = VAR44;
}
function FUN7(uint256 VAR34) onlyOwner public {
VAR15 = VAR34;
}
function FUN8(uint256 VAR39) onlyOwner public {
VAR9 = VAR39;
}
function FUN9() public returns(bool VAR45) {
if (msg.sender == VAR18 && !VAR21 && VAR19) {
VAR21 = true;
VAR20 = true;
} else {
revert();
}
return true;
}
function FUN10() public returns(bool VAR45) {
if (msg.sender == VAR18 && VAR20) {
if (VAR17 != 0 && VAR6 > 0) {
uint256 VAR46 = VAR6 - VAR8;
if (VAR46 > 0) {
VAR27[VAR17] += VAR46;
VAR5 += VAR46;
Transfer(this, VAR17, VAR46);
}
}
VAR21 = false;
VAR20 = false;
} else {
revert();
}
return true;
}
function FUN11(address[] VAR47, uint256 VAR31) onlyOwner public {
uint256 VAR46 = VAR6 - VAR8;
require(VAR47.VAR48 <= 255);
require(VAR31 <= VAR46);
VAR31 = VAR31 * 1e18;
for (uint VAR49 = 0; VAR49 < VAR47.VAR48; VAR49++) {
require(VAR31 <= VAR46);
VAR8 += VAR31;
VAR27[VAR47[VAR49]] += VAR31;
VAR5 += VAR31;
Transfer(this, VAR47[VAR49], VAR31);
}
if (VAR8 >= VAR6) {
VAR21 = false;
VAR20 = false;
}
}
function FUN12(address[] VAR47, uint256[] VAR50) onlyOwner public {
uint256 VAR46 = VAR6 - VAR8;
uint256 VAR31;
require(VAR47.VAR48 <= 255);
require(VAR47.VAR48 == VAR50.VAR48);
for (uint8 VAR49 = 0; VAR49 < VAR47.VAR48; VAR49++) {
VAR31 = VAR50[VAR49] * 1e18;
require(VAR31 <= VAR46);
VAR8 += VAR31;
VAR27[VAR47[VAR49]] += VAR31;
VAR5 += VAR31;
Transfer(this, VAR47[VAR49], VAR31);
if (VAR8 >= VAR6) {
VAR21 = false;
VAR20 = false;
}
}
}
function FUN13(uint256 VAR51) public returns(bool VAR45) {
uint256 VAR31 = VAR51 * 1e18;
if (VAR27[msg.sender] >= VAR31) {
VAR27[msg.sender] -= VAR31;
VAR5 -= VAR31;
FUN2(msg.sender, VAR31);
Transfer(msg.sender, 0, VAR31);
} else {
revert();
}
return true;
}
function FUN14() public constant returns(uint256 VAR52) {
return VAR5;
}
function FUN15() public constant returns(uint256 VAR35) {
return VAR6;
}
function FUN16() public constant returns(uint256 VAR36) {
return VAR7;
}
function FUN17() public constant returns(uint256 VAR53) {
return VAR8;
}
function FUN18() public constant returns(address VAR37) {
return VAR17;
}
function FUN19() public constant returns(address VAR54) {
return VAR16;
}
function FUN20() public constant returns(address VAR55) {
return VAR18;
}
function FUN21() public constant returns(bool VAR56) {
return VAR19;
}
function FUN22() public constant returns(bool VAR57) {
return VAR20;
}
function FUN23() public constant returns(bool VAR58) {
return VAR21;
}
function FUN24(address VAR25) public constant returns(uint256 VAR59) {
return VAR27[VAR25];
}
function transfer(address VAR23, uint256 VAR31) public returns(bool VAR45) {
if (VAR27[msg.sender] >= VAR31 &&
VAR31 > 0 &&
VAR27[VAR23] + VAR31 > VAR27[VAR23]) {
VAR27[msg.sender] -= VAR31;
VAR27[VAR23] += VAR31;
Transfer(msg.sender, VAR23, VAR31);
return true;
} else {
return false;
}
}
function FUN25(
address VAR22,
address VAR23,
uint256 VAR31
) public returns(bool VAR45) {
if (VAR27[VAR22] >= VAR31 &&
VAR28[VAR22][msg.sender] >= VAR31 &&
VAR31 > 0 &&
VAR27[VAR23] + VAR31 > VAR27[VAR23]) {
VAR27[VAR22] -= VAR31;
VAR28[VAR22][msg.sender] -= VAR31;
VAR27[VAR23] += VAR31;
Transfer(VAR22, VAR23, VAR31);
return true;
} else {
return false;
}
}
function FUN26(address VAR26, uint256 VAR31) public returns(bool VAR45) {
VAR28[msg.sender][VAR26] = VAR31;
FUN1(msg.sender, VAR26, VAR31);
return true;
}
function FUN27(address VAR25, address VAR26) public constant returns(uint256 VAR60) {
return VAR28[VAR25][VAR26];
}
}
0
---------------------------------
340 0x0129bd83cfad576a443cfebefe5b350c9ef4dcbf.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
if (VAR2 == 0) {
return 0;
}
VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
return VAR2 / VAR3;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
library VAR5 {
using SafeMath for uint256;
function VAR6
(
uint256 VAR7,
uint256 VAR8
)
internal
pure
returns(uint256 VAR9)
{
return VAR7.FUN2(100).FUN1(VAR8);
}
}
library VAR10 {
struct VAR11 {
mapping (address => bool) VAR12;
}
function FUN4(Role storage VAR13, address VAR14)
internal
{
VAR13.VAR12[VAR14] = true;
}
function FUN5(Role storage VAR13, address VAR14)
internal
{
VAR13.VAR12[VAR14] = false;
}
function FUN6(Role storage VAR13, address VAR14)
view
internal
{
require(FUN7(VAR13, VAR14));
}
function FUN7(Role storage VAR13, address VAR14)
view
internal
returns (bool)
{
return VAR13.VAR12[VAR14];
}
}
contract VAR15 {
using Roles for VAR10.VAR11;
mapping (string => VAR10.VAR11) private VAR16;
event FUN8(address indexed VAR17, string VAR13);
event FUN9(address indexed VAR17, string VAR13);
function FUN10(address VAR18, string VAR19)
view
public
{
VAR16[VAR19].FUN6(VAR18);
}
function FUN11(address VAR18, string VAR19)
view
public
returns (bool)
{
return VAR16[VAR19].FUN7(VAR18);
}
function FUN12(address VAR18, string VAR19)
internal
{
VAR16[VAR19].FUN4(VAR18);
emit FUN8(VAR18, VAR19);
}
function FUN13(address VAR18, string VAR19)
internal
{
VAR16[VAR19].FUN5(VAR18);
emit FUN9(VAR18, VAR19);
}
modifier FUN14(string VAR19)
{
FUN10(msg.sender, VAR19);
VAR20;
}
}
contract VAR21 {
address public VAR22;
event FUN15(address indexed VAR23);
event FUN16(
address indexed VAR23,
address indexed VAR24
);
constructor() public {
VAR22 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR22);
VAR20;
}
function FUN17() public onlyOwner {
emit FUN15(VAR22);
VAR22 = address(0);
}
function FUN18(address VAR25) public onlyOwner {
FUN19(VAR25);
}
function FUN19(address VAR25) internal {
require(VAR25 != address(0));
emit FUN16(VAR22, VAR25);
VAR22 = VAR25;
}
}
interface VAR26 {
function FUN20() external view returns (uint256);
function FUN21(address VAR27) external view returns (uint256);
function FUN22(address VAR22, address VAR28) external view returns (uint256);
function transfer(address VAR29, uint256 value) external returns (bool);
function FUN23(address VAR28, uint256 value) external returns (bool);
function FUN24(address VAR30, address VAR29, uint256 value) external returns (bool);
event Transfer(address indexed VAR30, address indexed VAR29, uint256 value);
event FUN25(address indexed VAR22, address indexed VAR28, uint256 value);
}
library VAR31 {
using SafeMath for uint256;
function FUN26(IERC20 VAR32, address VAR29, uint256 value) internal {
require(VAR32.transfer(VAR29, value));
}
function FUN27(IERC20 VAR32, address VAR30, address VAR29, uint256 value) internal {
require(VAR32.FUN24(VAR30, VAR29, value));
}
function FUN28(IERC20 VAR32, address VAR28, uint256 value) internal {
require((value == 0) || (VAR32.FUN22(msg.sender, VAR28) == 0));
require(VAR32.FUN23(VAR28, value));
}
function FUN29(IERC20 VAR32, address VAR28, uint256 value) internal {
uint256 VAR33 = VAR32.FUN22(address(this), VAR28).FUN4(value);
require(VAR32.FUN23(VAR28, VAR33));
}
function FUN30(IERC20 VAR32, address VAR28, uint256 value) internal {
uint256 VAR33 = VAR32.FUN22(address(this), VAR28).FUN3(value);
require(VAR32.FUN23(VAR28, VAR33));
}
}
contract TokenVesting is VAR21 {
using SafeMath for uint256;
event FUN31(uint256 VAR34);
event FUN32();
address public VAR35;
uint256 public VAR36;
uint256 public VAR37 = 23667695;
uint256 public VAR38 = 7889229;
uint256 public VAR39 = 15778458;
bool public VAR40;
mapping (address => uint256) public VAR41;
mapping (address => bool) public VAR42;
constructor(
address VAR43,
uint256 VAR44,
bool VAR45
)
public
{
require(VAR43 != address(0));
VAR35 = VAR43;
VAR40 = VAR45;
VAR36 = VAR44;
}
function FUN33(ERC20 VAR32) public {
uint256 VAR46 = FUN34(VAR32);
require(VAR46 > 0);
VAR41[VAR32] = VAR41[VAR32].FUN4(VAR46);
VAR32.transfer(VAR35, VAR46);
emit FUN31(VAR46);
}
function FUN35(ERC20 VAR32) public onlyOwner {
require(VAR40);
require(!VAR42[VAR32]);
uint256 VAR47 = VAR32.FUN21(this);
uint256 VAR46 = FUN34(VAR32);
uint256 VAR48 = VAR47.FUN3(VAR46);
VAR42[VAR32] = true;
VAR32.transfer(VAR22, VAR48);
emit FUN32();
}
function FUN34(ERC20 VAR32) public view returns (uint256) {
return FUN36(VAR32).FUN3(VAR41[VAR32]);
}
function FUN36(ERC20 VAR32) public view returns (uint256) {
uint256 VAR49 = VAR32.FUN21(this);
uint256 VAR50 = VAR49.FUN4(VAR41[VAR32]);
if (VAR51.VAR52 >= VAR36.FUN4(VAR37) || VAR42[VAR32]) {
return VAR50;
}
if(VAR51.VAR52 >= VAR36.FUN4(VAR38) && VAR51.VAR52 <= VAR36.FUN4(VAR39)){
return VAR50.FUN2(3);
}
if(VAR51.VAR52 >= VAR36.FUN4(VAR39) && VAR51.VAR52 <= VAR36.FUN4(VAR37)){
return VAR50.FUN2(3).FUN1(2);
}
return 0;
}
}
contract Whitelist is VAR21, VAR15 {
string public constant VAR53 = "";
modifier FUN37(address VAR18) {
FUN10(VAR18, VAR53);
VAR20;
}
function FUN38(address VAR18)
onlyOwner
public
{
FUN12(VAR18, VAR53);
}
function FUN39(address VAR18)
public
view
returns (bool)
{
return FUN11(VAR18, VAR53);
}
function FUN40(address[] VAR54)
onlyOwner
public
{
for (uint256 VAR55 = 0; VAR55 < VAR54.VAR56; VAR55++) {
FUN38(VAR54[VAR55]);
}
}
function FUN41(address VAR18)
onlyOwner
public
{
FUN13(VAR18, VAR53);
}
function FUN42(address[] VAR54)
onlyOwner
public
{
for (uint256 VAR55 = 0; VAR55 < VAR54.VAR56; VAR55++) {
FUN41(VAR54[VAR55]);
}
}
}
contract Pausable is VAR21 {
event FUN43();
event FUN44();
bool public VAR57 = false;
modifier FUN45() {
require(!VAR57);
VAR20;
}
modifier FUN46() {
require(VAR57);
VAR20;
}
function FUN47() onlyOwner whenNotPaused public {
VAR57 = true;
emit FUN43();
}
function FUN48() onlyOwner whenPaused public {
VAR57 = false;
emit FUN44();
}
}
contract VAR58 {
function FUN20() public view returns (uint256);
function FUN21(address VAR27) public view returns (uint256);
function transfer(address VAR29, uint256 value) public returns (bool);
event Transfer(address indexed VAR30, address indexed VAR29, uint256 value);
}
contract ERC20 is VAR58 {
function FUN22(address VAR22, address VAR28)
public view returns (uint256);
function FUN24(address VAR30, address VAR29, uint256 value)
public returns (bool);
function FUN23(address VAR28, uint256 value) public returns (bool);
event FUN25(
address indexed VAR22,
address indexed VAR28,
uint256 value
);
}
contract BasicToken is VAR58 {
using SafeMath for uint256;
mapping(address => uint256) VAR59;
uint256 VAR60;
function FUN20() public view returns (uint256) {
return VAR60;
}
function transfer(address VAR61, uint256 VAR62) public returns (bool) {
require(VAR61 != address(0));
require(VAR62 <= VAR59[msg.sender]);
VAR59[msg.sender] = VAR59[msg.sender].FUN3(VAR62);
VAR59[VAR61] = VAR59[VAR61].FUN4(VAR62);
emit Transfer(msg.sender, VAR61, VAR62);
return true;
}
function FUN21(address VAR63) public view returns (uint256) {
return VAR59[VAR63];
}
}
contract StandardToken is VAR64, VAR65 {
mapping (address => mapping (address => uint256)) internal VAR66;
function FUN24(
address VAR67,
address VAR61,
uint256 VAR62
)
public
returns (bool)
{
require(VAR61 != address(0));
require(VAR62 <= VAR59[VAR67]);
require(VAR62 <= VAR66[VAR67][msg.sender]);
VAR59[VAR67] = VAR59[VAR67].FUN3(VAR62);
VAR59[VAR61] = VAR59[VAR61].FUN4(VAR62);
VAR66[VAR67][msg.sender] = VAR66[VAR67][msg.sender].FUN3(VAR62);
emit Transfer(VAR67, VAR61, VAR62);
return true;
}
function FUN23(address VAR68, uint256 VAR62) public returns (bool) {
VAR66[msg.sender][VAR68] = VAR62;
emit FUN25(msg.sender, VAR68, VAR62);
return true;
}
function FUN22(
address VAR63,
address VAR68
)
public
view
returns (uint256)
{
return VAR66[VAR63][VAR68];
}
function FUN49(
address VAR68,
uint256 VAR69
)
public
returns (bool)
{
VAR66[msg.sender][VAR68] = (
VAR66[msg.sender][VAR68].FUN4(VAR69));
emit FUN25(msg.sender, VAR68, VAR66[msg.sender][VAR68]);
return true;
}
function FUN50(
address VAR68,
uint256 VAR70
)
public
returns (bool)
{
uint256 VAR71 = VAR66[msg.sender][VAR68];
if (VAR70 > VAR71) {
VAR66[msg.sender][VAR68] = 0;
} else {
VAR66[msg.sender][VAR68] = VAR71.FUN3(VAR70);
}
emit FUN25(msg.sender, VAR68, VAR66[msg.sender][VAR68]);
return true;
}
}
contract PausableToken is VAR72, VAR73 {
function transfer(
address VAR61,
uint256 VAR62
)
public
VAR74
returns (bool)
{
return super.transfer(VAR61, VAR62);
}
function FUN24(
address VAR67,
address VAR61,
uint256 VAR62
)
public
VAR74
returns (bool)
{
return super.FUN24(VAR67, VAR61, VAR62);
}
function FUN23(
address VAR68,
uint256 VAR62
)
public
VAR74
returns (bool)
{
return super.FUN23(VAR68, VAR62);
}
function FUN49(
address VAR68,
uint VAR69
)
public
VAR74
returns (bool VAR75)
{
return super.FUN49(VAR68, VAR69);
}
function FUN50(
address VAR68,
uint VAR70
)
public
VAR74
returns (bool VAR75)
{
return super.FUN50(VAR68, VAR70);
}
}
contract TokenDestructible is VAR21 {
constructor() public payable { }
function FUN51() onlyOwner public {
FUN52(VAR22);
}
}
contract Token is VAR76, VAR77 {
uint256 public VAR78;
string public VAR79;
string public VAR80;
uint256 VAR81 = 0;
constructor(uint256 VAR82, uint256 VAR83, string VAR84, string VAR85) public {
require(VAR82 > 0);
require(VAR83 > 0);
VAR60 = VAR82;
VAR78 = VAR83;
VAR79 = VAR84;
VAR80 = VAR85;
VAR59[msg.sender] = VAR82;
emit Transfer(address(0), msg.sender, VAR82);
}
}
contract Allocation is VAR86 {
using SafeMath for uint256;
using Percent for uint256;
event FUN53(
address indexed VAR87,
address indexed VAR35,
uint256 value,
uint256 VAR34
);
event FUN54();
event VAR88
(
address VAR35,
uint256 VAR36,
uint256 VAR37,
bool VAR40
);
struct VAR89 {
uint256 VAR8;
bool VAR90;
uint256 VAR34;
}
mapping (address => bool) public VAR91;
mapping (address => uint256) public VAR92;
mapping (address => VAR93) public VAR94;
mapping (uint256 => VAR89) public VAR95;
mapping (address => bool) public VAR96;
address[] public VAR97;
uint256 private VAR98;
uint256 private VAR99;
uint256 private VAR100;
uint256 private VAR101;
uint256 private VAR102;
uint256 public VAR37 = 23667695;
bool public VAR103 = false;
uint256 public VAR104 = 0;
//
Token public VAR32;
//
address public VAR105;
uint256 public VAR106;
uint256 public VAR107;
uint256 public VAR108;
constructor(
uint256 VAR109,
address VAR110,
Token VAR111,
uint256 VAR112,
uint256 VAR113,
uint256 VAR114,
uint256 VAR115,
uint256 VAR116,
uint256 VAR117,
uint256 VAR118
)
public
{
require(VAR109 > 0);
require(VAR110 != address(0));
require(VAR111 != address(0));
require(VAR113 > 0);
require(VAR112 > 0);
require(VAR113 > VAR112);
VAR106 = VAR109;
VAR105 = VAR110;
VAR32 = VAR111;
VAR108 = VAR113;
VAR107 = VAR112;
VAR98 = VAR114;
VAR99 = VAR115;
VAR100 = VAR116;
VAR101 = VAR117;
VAR102 = VAR118;
VAR91[msg.sender] = true;
VAR95[1] = FUN55(10, true, VAR32.FUN20().FUN1(10).FUN2(100));
VAR95[2] = FUN55(15, true, VAR32.FUN20().FUN1(15).FUN2(100));
VAR95[3] = FUN55(5, true, VAR32.FUN20().FUN1(5).FUN2(100));
VAR95[4] = FUN55(5, false, VAR32.FUN20().FUN1(5).FUN2(100));
VAR95[5] = FUN55(8, false, VAR32.FUN20().FUN1(8).FUN2(100));
VAR95[6] = FUN55(17, false, VAR32.FUN20().FUN1(17).FUN2(100));
VAR95[7] = FUN55(10, false, VAR32.FUN20().FUN1(10).FUN2(100));
VAR95[8] = FUN55(30, false, VAR32.FUN20().FUN1(30).FUN2(100));
}
function()
external
payable
{
FUN56(msg.sender);
}
modifier FUN57() {
require(
msg.value >= VAR98,
""
);
VAR20;
}
modifier VAR119 {
require(!VAR103, "");
VAR20;
}
modifier onlyOwner {
require(FUN58(msg.sender) == true, "");
VAR20;
}
function FUN59(address VAR63) public onlyOwner {
require(VAR91[VAR63] == false);
VAR91[VAR63] = true;
}
function FUN60(address VAR63) public onlyOwner {
require(VAR91[VAR63] == true);
VAR91[VAR63] = false;
}
function FUN58(address VAR120) public view returns(bool VAR121) {
return VAR91[VAR120];
}
function FUN61(address[] VAR122) public onlyOwner {
require(VAR122.VAR56 <= 50);
for (uint VAR55 = 0; VAR55 < VAR122.VAR56; VAR55++) {
FUN62(VAR122[VAR55]);
}
}
function FUN63(address VAR123) public onlyOwner {
FUN62(VAR123);
}
function FUN62(address VAR123) internal {
uint256 VAR124 = VAR92[VAR123];
if (VAR124 > 0) {
uint256 VAR125 = FUN64(VAR124);
uint256 VAR126 = FUN65(VAR124);
VAR95[8].VAR34 = VAR95[8].VAR34.FUN3(VAR125);
VAR95[1].VAR34 = VAR95[1].VAR34.FUN3(VAR126);
VAR92[VAR123] = 0;
VAR32.transfer(VAR123, VAR125);
FUN66(VAR123, VAR126);
}
}
function FUN67(address VAR61, uint256 VAR127, uint256 VAR128) public onlyOwner {
require(
VAR95[VAR127].VAR34 >= VAR128 &&
VAR127 >= 1 &&
VAR127 <= 8
);
if (VAR95[VAR127].VAR90 == true) {
FUN66(VAR61, VAR128);
} else {
VAR32.transfer(VAR61, VAR128);
}
VAR95[VAR127].VAR34 -= VAR128;
}
function FUN56(address VAR43) public payable {
uint256 VAR124 = msg.value;
FUN68(VAR43, VAR124);
uint256 VAR125 = FUN64(VAR124);
VAR104 = VAR104.FUN4(VAR124);
VAR92[VAR43] += VAR124;
if(!VAR96[VAR43]){
VAR97.FUN69(VAR43);
VAR96[VAR43] = true;
}
FUN70();
emit FUN53(
msg.sender,
VAR43,
VAR124,
VAR125
);
}
function VAR129
(
address VAR43,
uint256 VAR130
)
FUN37(VAR43)
VAR131
VAR119
view
internal
{
require(VAR104.FUN4(VAR130) <= VAR108);
require(VAR43 != address(0));
}
function VAR132
(
address VAR43,
uint256 VAR133
)
internal
{
uint256 VAR44 = VAR51.VAR52;
TokenVesting VAR134;
if (VAR94[VAR43] == address(0)) {
VAR134 = VAR135 FUN71(VAR43, VAR44, false);
VAR94[VAR43] = VAR134;
} else {
VAR134 = VAR94[VAR43];
}
VAR32.transfer(address(VAR134), VAR133);
emit FUN72(VAR43, VAR44, VAR37, false);
}
function FUN73() public view returns (bool) {
return VAR103;
}
function FUN74() public {
address VAR35 = msg.sender;
require(VAR94[VAR35] != address(0));
TokenVesting VAR134 = VAR94[VAR35];
VAR134.FUN33(VAR32);
}
function VAR136
(
uint256 VAR130
)
internal
view
returns (uint256 VAR137)
{
VAR137 = VAR130;
if (VAR130 >= VAR98 && VAR130 < VAR99) {
VAR137 = VAR130.FUN75(5);
}
if (VAR130 >= VAR99 && VAR130 < VAR100) {
VAR137 = VAR130.FUN75(10);
}
if (VAR130 >= VAR100 && VAR130 < VAR101) {
VAR137 = VAR130.FUN75(15);
}
if (VAR130 >= VAR101 && VAR130 < VAR102) {
VAR137 = VAR130.FUN75(20);
}
if (VAR130 >= VAR102) {
VAR137 = VAR130.FUN75(30);
}
return VAR137.FUN1(VAR106);
}
function VAR138
(
uint256 VAR130
)
internal
view
returns (uint256 VAR137)
{
return VAR130.FUN1(VAR106);
}
function FUN70() internal {
VAR105.transfer(msg.value);
}
function FUN76() public onlyOwner {
require(!FUN73());
FUN77();
VAR103 = true;
emit FUN54();
}
function FUN77() pure internal {}
}
0
---------------------------------
341 0x013302040c3bc03b68fbde41d10b93ccf5f561b2.sol
library VAR1 {
function FUN1(bytes VAR2, uint VAR3) constant returns (bytes32) {
bytes32 VAR4;
for (uint VAR5 = 0; VAR5 < 32; VAR5++) {
VAR4 |= bytes32(VAR2[VAR3 + VAR5] & 0xFF) >> (VAR5 * 8);
}
return VAR4;
}
function FUN2(bytes VAR2, uint VAR3) constant returns (address) {
bytes32 VAR4;
for (uint VAR5 = 0; VAR5 < 20; VAR5++) {
VAR4 |= bytes32(VAR2[VAR3 + VAR5] & 0xFF) >> ((VAR5+12) * 8);
}
return address(uint(VAR4));
}
function FUN3(bytes VAR2, uint VAR3) constant returns (VAR6) {
bytes16 VAR4;
for (uint VAR5 = 0; VAR5 < 16; VAR5++) {
VAR4 |= FUN4(VAR2[VAR3 + VAR5] & 0xFF) >> (VAR5 * 8);
}
return VAR4;
}
function FUN5(bytes VAR2, uint VAR3) constant returns (bytes4) {
bytes4 VAR4;
for (uint VAR5 = 0; VAR5 < 4; VAR5++) {
VAR4 |= bytes4(VAR2[VAR3 + VAR5] & 0xFF) >> (VAR5 * 8);
}
return VAR4;
}
function FUN6(bytes VAR2, uint VAR3) constant returns (VAR7) {
bytes2 VAR4;
for (uint VAR5 = 0; VAR5 < 2; VAR5++) {
VAR4 |= FUN7(VAR2[VAR3 + VAR5] & 0xFF) >> (VAR5 * 8);
}
return VAR4;
}
}
library VAR8 {
function FUN8(uint256 VAR9, uint256 VAR2) internal pure returns (uint256) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR10 = VAR9 * VAR2;
assert(VAR10 / VAR9 == VAR2);
return VAR10;
}
function FUN9(uint256 VAR9, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR10 = VAR9 / VAR2;
return VAR10;
}
function FUN10(uint256 VAR9, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR9);
return VAR9 - VAR2;
}
function FUN11(uint256 VAR9, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR10 = VAR9 + VAR2;
assert(VAR10 >= VAR9);
return VAR10;
}
}
library VAR11 {
struct VAR12 {
mapping (address => bool) VAR13;
}
function FUN11(Role storage VAR14, address VAR15)
internal
{
VAR14.VAR13[VAR15] = true;
}
function FUN12(Role storage VAR14, address VAR15)
internal
{
VAR14.VAR13[VAR15] = false;
}
function FUN13(Role storage VAR14, address VAR15)
view
internal
{
require(FUN14(VAR14, VAR15));
}
function FUN14(Role storage VAR14, address VAR15)
view
internal
returns (bool)
{
return VAR14.VAR13[VAR15];
}
}
contract VAR16 {
using Roles for VAR11.VAR12;
mapping (string => VAR11.VAR12) private VAR17;
event FUN15(address VAR15, string VAR18);
event FUN16(address VAR15, string VAR18);
string public constant VAR19 = "";
function FUN17()
public
{
FUN18(msg.sender, VAR19);
}
function FUN19(address VAR15, string VAR18)
view
public
{
VAR17[VAR18].FUN13(VAR15);
}
function FUN20(address VAR15, string VAR18)
view
public
returns (bool)
{
return VAR17[VAR18].FUN14(VAR15);
}
function FUN21(address VAR15, string VAR18)
onlyAdmin
public
{
FUN18(VAR15, VAR18);
}
function FUN22(address VAR15, string VAR18)
onlyAdmin
public
{
FUN23(VAR15, VAR18);
}
function FUN18(address VAR15, string VAR18)
internal
{
VAR17[VAR18].FUN11(VAR15);
FUN15(VAR15, VAR18);
}
function FUN23(address VAR15, string VAR18)
internal
{
VAR17[VAR18].FUN12(VAR15);
FUN16(VAR15, VAR18);
}
modifier FUN24(string VAR18)
{
FUN19(msg.sender, VAR18);
VAR20;
}
modifier onlyAdmin()
{
FUN19(msg.sender, VAR19);
VAR20;
}
}
contract VAR21 {
function FUN25() public view returns (uint256);
function FUN26(address VAR22) public view returns (uint256);
function transfer(address VAR23, uint256 value) public returns (bool);
event Transfer(address indexed VAR24, address indexed VAR23, uint256 value);
}
contract ERC20 is VAR21 {
function FUN27(address VAR25, address VAR26) public view returns (uint256);
function FUN28(address VAR24, address VAR23, uint256 value) public returns (bool);
function FUN29(address VAR26, uint256 value) public returns (bool);
event FUN30(address indexed VAR25, address indexed VAR26, uint256 value);
}
interface VAR27 {
function FUN31(address, uint256);
}
contract Exchange is VAR16 {
using SafeMath for uint256;
using BytesDeserializer for bytes;
string public constant VAR28 = "";
string public constant VAR29 = "";
string public constant VAR30 = "";
string public constant VAR31 = "";
string public constant VAR32 = "";
string public constant VAR33 = "";
string public constant VAR34 = "";
string public constant VAR35 = "";
string public constant VAR36 = "";
mapping(bytes32 => bool) public VAR37;
mapping(bytes32 => bool) public VAR38;
mapping(address => bool) public VAR39;
mapping(address => uint256) public VAR40;
mapping(address => mapping(address => uint256)) public VAR41;
mapping (bytes32 => uint256) public VAR42;
address public VAR43;
uint256 public VAR44;
event FUN32(address VAR45, bool VAR46);
event FUN33(address VAR47);
event FUN34(uint256 VAR48);
event FUN35(address VAR45, address VAR22, uint256 VAR49, uint256 VAR50);
event FUN36(address VAR45, address VAR22, uint256 VAR49);
event FUN37(address VAR45, address VAR22, uint256 VAR49, uint256 VAR50);
event FUN38(address VAR45, address VAR22, uint256 VAR49, uint256 VAR51);
event FUN39(address, address, address, uint256);
event FUN40(address, address, address, uint256, uint256, uint256);
event FUN41(
bytes32 VAR52,
address VAR53,
address VAR54,
address VAR55,
address VAR56,
uint256 VAR57,
uint256 VAR58,
uint256 VAR59,
uint256 VAR60,
uint256 VAR61,
uint256 VAR62
);
struct VAR63 {
address VAR64;
address VAR45;
uint256 VAR49;
uint256 VAR65;
bool VAR66;
}
VAR63[] VAR67;
enum VAR68 {VAR69, VAR70}
struct VAR71 {
OrderType VAR72;
address VAR53;
address VAR54;
address VAR55;
address VAR56;
uint256 VAR49;
uint256 VAR73;
uint256 VAR74;
uint256 VAR75;
uint256 VAR76;
uint256 VAR77;
uint256 VAR78;
}
function FUN42(uint256 VAR79) {
VAR44 = VAR79;
VAR43 = msg.sender;
FUN18(msg.sender, VAR28);
FUN18(msg.sender, VAR29);
FUN18(msg.sender, VAR30);
FUN18(msg.sender, VAR31);
FUN18(msg.sender, VAR32);
FUN18(msg.sender, VAR33);
FUN18(msg.sender, VAR34);
FUN18(msg.sender, VAR35);
FUN18(msg.sender, VAR36);
}
function FUN43(address VAR45, bool VAR46) external FUN24(VAR36) {
VAR39[VAR45] = VAR46;
FUN32(VAR45, VAR46);
}
function FUN44(address VAR80) external FUN24(VAR35) {
VAR43 = VAR80;
FUN33(VAR43);
}
function FUN45(uint256 VAR79) external FUN24(VAR34) {
require(VAR79 < 2 VAR81);
VAR44 = VAR79;
FUN34(VAR44);
}
function FUN46(ERC20 VAR45, uint256 VAR49) external returns(bool) {
FUN47(VAR45, VAR49);
require(VAR45.FUN28(msg.sender, this, VAR49));
return true;
}
function FUN48() external payable returns(bool) {
FUN47(address(0), msg.value);
return true;
}
function FUN49(ERC20 VAR45, address VAR64, uint256 VAR49, uint256 VAR82, uint256 VAR78, uint8 VAR83, bytes32 VAR84, bytes32 VAR85) external FUN24(VAR32) {
bytes32 VAR86 = FUN50(this, VAR45, VAR64, VAR49, VAR82, VAR78);
require(VAR37[VAR86] == false);
require(FUN51(FUN50("", VAR86), VAR83, VAR84, VAR85) == VAR64);
VAR37[VAR86] = true;
FUN52(VAR45, VAR64, VAR49, VAR82);
}
function FUN53(ERC20 VAR45, address VAR64, uint256 VAR49) external FUN24(VAR28) {
FUN36(VAR45, VAR64, VAR49);
FUN52(VAR45, VAR64, VAR49, 0);
}
function FUN54(ERC20 VAR45, uint256 VAR49) external returns(uint256) {
uint256 VAR51 = VAR67.VAR87;
VAR67.FUN55(FUN56(msg.sender, address(VAR45), VAR49, VAR88, false));
FUN38(VAR45, msg.sender, VAR49, VAR51);
return VAR51;
}
function FUN57(uint256 VAR51) external {
require((VAR67[VAR51].VAR65.FUN11(VAR44)) < VAR88);
require(VAR67[VAR51].VAR66 == false);
require(VAR67[VAR51].VAR64 == msg.sender);
VAR67[VAR51].VAR66 = true;
FUN52(VAR67[VAR51].VAR45, VAR67[VAR51].VAR64, VAR67[VAR51].VAR49, 0);
}
function FUN58(ERC20 VAR45, address VAR24, address VAR23, uint256 VAR49, uint256 VAR82, uint256 VAR78, uint256 VAR89, uint8 VAR83, bytes32 VAR84, bytes32 VAR85) external FUN24(VAR29) {
bytes32 VAR86 = FUN50(this, VAR45, VAR24, VAR23, VAR49, VAR82, VAR78, VAR89);
require(VAR89 >= VAR88);
require(VAR38[VAR86] == false);
require(FUN51(FUN50("", VAR86), VAR83, VAR84, VAR85) == VAR24);
VAR41[address(VAR45)][VAR24] = VAR41[address(VAR45)][VAR24].FUN10(VAR49.FUN11(VAR82));
VAR41[address(VAR45)][VAR43] = VAR41[address(VAR45)][VAR43].FUN11(VAR82);
VAR41[address(VAR45)][VAR23] = VAR41[address(VAR45)][VAR23].FUN11(VAR49);
FUN40(VAR45, VAR24, VAR23, VAR49, VAR82, VAR78);
}
function FUN31(InvestorToken VAR45, address VAR23, uint256 VAR49) external FUN24(VAR30) {
VAR45.FUN31(VAR23, VAR49);
FUN39(msg.sender, VAR45, VAR23, VAR49);
}
function FUN59(ERC20 VAR45) external FUN24(VAR31) {
uint256 VAR90 = VAR45.FUN26(this);
VAR45.transfer(VAR43, VAR90.FUN10(VAR40[VAR45]));
}
function FUN60(bytes VAR91, uint8 VAR92, bytes32 VAR93, bytes32 VAR94, bytes VAR95, uint8 VAR96, bytes32 VAR97, bytes32 VAR98) external {
FUN19(msg.sender, VAR33);
Order memory VAR99;
Order memory VAR100;
VAR99.VAR53 = VAR91.FUN2(0);
VAR99.VAR54 = VAR91.FUN2(20);
VAR99.VAR55 = VAR91.FUN2(40);
VAR99.VAR56 = VAR91.FUN2(60);
VAR99.VAR49 = uint256(VAR91.FUN1(80));
VAR99.VAR73 = uint256(VAR91.FUN1(112));
VAR99.VAR74 = uint256(VAR91.FUN1(144));
VAR99.VAR75 = uint256(VAR91.FUN1(176));
VAR99.VAR76 = uint256(VAR91.FUN1(208));
VAR99.VAR77 = uint256(VAR91.FUN1(240));
VAR99.VAR78 = uint256(VAR91.FUN1(272));
if (VAR91.FUN6(304) == 0) {
VAR99.VAR72 = VAR68.VAR70;
} else {
VAR99.VAR72 = VAR68.VAR69;
}
VAR100.VAR53 = VAR95.FUN2(0);
VAR100.VAR54 = VAR95.FUN2(20);
VAR100.VAR55 = VAR95.FUN2(40);
VAR100.VAR56 = VAR95.FUN2(60);
VAR100.VAR49 = uint256(VAR95.FUN1(80));
VAR100.VAR73 = uint256(VAR95.FUN1(112));
VAR100.VAR74 = uint256(VAR95.FUN1(144));
VAR100.VAR75 = uint256(VAR95.FUN1(176));
VAR100.VAR76 = uint256(VAR95.FUN1(208));
VAR100.VAR77 = uint256(VAR95.FUN1(240));
VAR100.VAR78 = uint256(VAR95.FUN1(272));
if (VAR95.FUN6(304) == 0) {
VAR100.VAR72 = VAR68.VAR70;
} else {
VAR100.VAR72 = VAR68.VAR69;
}
bytes32 VAR101 = FUN61(VAR99);
bytes32 VAR102 = FUN61(VAR100);
address VAR103 = FUN51(FUN50("", VAR101), VAR92, VAR93, VAR94);
address VAR104 = FUN51(FUN50("", VAR102), VAR96, VAR97, VAR98);
require(VAR103 == VAR99.VAR53);
require(VAR104 == VAR100.VAR53);
FUN62(VAR99, VAR101, VAR100, VAR102);
}
function FUN62(Order VAR99, bytes32 VAR101, Order VAR100, bytes32 VAR102) internal {
uint256 VAR73;
uint256 VAR74;
uint256 VAR105;
uint256 VAR106;
uint256 VAR107;
uint256 VAR108;
uint256 VAR109;
uint256 VAR110;
require(VAR99.VAR77 > VAR88);
require(VAR100.VAR77 > VAR88);
require(VAR99.VAR54 == VAR100.VAR54);
require(VAR99.VAR55 == VAR100.VAR55);
require(VAR99.VAR54 != VAR99.VAR55);
require((VAR99.VAR72 == VAR68.VAR70 && VAR100.VAR72 == VAR68.VAR69) || (VAR99.VAR72 == VAR68.VAR69 && VAR100.VAR72 == VAR68.VAR70));
require(VAR99.VAR49 > 0);
require(VAR99.VAR73 > 0);
require(VAR99.VAR74 > 0);
require(VAR100.VAR49 > 0);
require(VAR100.VAR73 > 0);
require(VAR100.VAR74 > 0);
require(VAR99.VAR76 > 0);
require(VAR100.VAR76 > 0);
require(VAR99.VAR49 % VAR99.VAR74 == 0);
require(VAR99.VAR49 % VAR100.VAR74 == 0);
require(VAR100.VAR49 % VAR99.VAR74 == 0);
require(VAR100.VAR49 % VAR100.VAR74 == 0);
if (VAR99.VAR72 == VAR68.VAR69) {
require((VAR99.VAR73.FUN8(VAR100.VAR74)) >= (VAR100.VAR73.FUN8(VAR99.VAR74)));
} else {
require((VAR99.VAR73.FUN8(VAR100.VAR74)) <= (VAR100.VAR73.FUN8(VAR99.VAR74)));
}
VAR73 = VAR99.VAR73;
VAR74 = VAR99.VAR74;
VAR105 = VAR99.VAR49.FUN10(VAR42[VAR101]);
VAR106 = VAR100.VAR49.FUN10(VAR42[VAR102]);
require(VAR105 > 0);
require(VAR106 > 0);
if (VAR105 < VAR106) {
VAR107 = VAR105;
} else {
VAR107 = VAR106;
}
VAR108 = VAR107.FUN8(VAR73).FUN9(VAR74);
VAR109 = FUN63(VAR108, VAR99.VAR75, VAR99.VAR76);
VAR110 = FUN63(VAR108, VAR100.VAR75, VAR100.VAR76);
if (VAR99.VAR72 == VAR68.VAR69) {
FUN64(VAR99.VAR53, VAR99.VAR54, VAR99.VAR55, VAR99.VAR56, VAR107, VAR108, VAR109);
FUN64(VAR100.VAR53, VAR100.VAR55, VAR100.VAR54, VAR100.VAR56, VAR108, VAR107, VAR110);
VAR41[VAR99.VAR54][VAR99.VAR53] = VAR41[VAR99.VAR54][VAR99.VAR53].FUN11(VAR107);
VAR41[VAR99.VAR55][VAR99.VAR53] = VAR41[VAR99.VAR55][VAR99.VAR53].FUN10(VAR108);
VAR41[VAR100.VAR54][VAR100.VAR53] = VAR41[VAR100.VAR54][VAR100.VAR53].FUN10(VAR107);
VAR41[VAR100.VAR55][VAR100.VAR53] = VAR41[VAR100.VAR55][VAR100.VAR53].FUN11(VAR108);
} else {
FUN64(VAR99.VAR53, VAR99.VAR55, VAR99.VAR54, VAR99.VAR56, VAR108, VAR107, VAR109);
FUN64(VAR100.VAR53, VAR100.VAR54, VAR100.VAR55, VAR100.VAR56, VAR107, VAR108, VAR110);
VAR41[VAR99.VAR54][VAR99.VAR53] = VAR41[VAR99.VAR54][VAR99.VAR53].FUN10(VAR107);
VAR41[VAR99.VAR55][VAR99.VAR53] = VAR41[VAR99.VAR55][VAR99.VAR53].FUN11(VAR108);
VAR41[VAR100.VAR54][VAR100.VAR53] = VAR41[VAR100.VAR54][VAR100.VAR53].FUN11(VAR107);
VAR41[VAR100.VAR55][VAR100.VAR53] = VAR41[VAR100.VAR55][VAR100.VAR53].FUN10(VAR108);
}
if (VAR109 > 0) {
VAR41[VAR99.VAR56][VAR99.VAR53] = VAR41[VAR99.VAR56][VAR99.VAR53].FUN10(VAR109);
VAR41[VAR99.VAR56][VAR43] = VAR41[VAR99.VAR56][VAR43].FUN11(VAR109);
}
if (VAR110 > 0) {
VAR41[VAR100.VAR56][VAR100.VAR53] = VAR41[VAR100.VAR56][VAR100.VAR53].FUN10(VAR110);
VAR41[VAR100.VAR56][VAR43] = VAR41[VAR100.VAR56][VAR43].FUN11(VAR110);
}
VAR42[VAR101] = VAR42[VAR101].FUN11(VAR107);
VAR42[VAR102] = VAR42[VAR102].FUN11(VAR107);
FUN65(VAR99, VAR101, VAR107, VAR108, VAR109);
FUN65(VAR100, VAR102, VAR107, VAR108, VAR110);
}
function FUN63(uint256 VAR111, uint256 VAR75, uint256 VAR76) public returns(uint256) {
return (VAR111.FUN8(VAR75).FUN9(VAR76));
}
function FUN52(address VAR45, address VAR64, uint256 VAR49, uint256 VAR82) internal {
require(VAR49 > 0);
require(VAR41[VAR45][VAR64] >= VAR49.FUN11(VAR82));
VAR41[VAR45][VAR64] = VAR41[VAR45][VAR64].FUN10(VAR49.FUN11(VAR82));
VAR41[VAR45][VAR43] = VAR41[VAR45][VAR43].FUN11(VAR82);
VAR40[VAR45] = VAR40[VAR45].FUN10(VAR49);
if (VAR45 == address(0)) {
VAR64.transfer(VAR49);
} else {
require(FUN66(VAR45).transfer(VAR64, VAR49));
}
FUN37(VAR45, VAR64, VAR49, VAR41[VAR45][VAR64]);
}
function FUN47(address VAR45, uint256 VAR49) internal {
require(VAR39[address(VAR45)]);
VAR41[VAR45][msg.sender] = VAR41[VAR45][msg.sender].FUN11(VAR49);
VAR40[VAR45] = VAR40[VAR45].FUN11(VAR49);
FUN35(VAR45, msg.sender, VAR49, VAR41[VAR45][msg.sender]);
}
function FUN65(
Order VAR112,
bytes32 VAR52,
uint256 VAR107,
uint256 VAR108,
uint256 VAR59
) private {
uint256 VAR60 = VAR41[VAR112.VAR54][VAR112.VAR53];
uint256 VAR61 = VAR41[VAR112.VAR55][VAR112.VAR53];
uint256 VAR62 = VAR41[VAR112.VAR56][VAR112.VAR53];
FUN41(
VAR52,
VAR112.VAR53,
VAR112.VAR54,
VAR112.VAR55,
VAR112.VAR56,
VAR107,
VAR108,
VAR59,
VAR60,
VAR61,
VAR62
);
}
function FUN61(Order VAR112) private returns(bytes32) {
return FUN50(
this,
VAR112.VAR72,
VAR112.VAR53,
VAR112.VAR54,
VAR112.VAR55,
VAR112.VAR56,
VAR112.VAR49,
VAR112.VAR73,
VAR112.VAR74,
VAR112.VAR75,
VAR112.VAR76,
VAR112.VAR77,
VAR112.VAR78
);
}
function FUN64(address VAR15, address VAR113, address VAR114, address VAR56, uint256 VAR115, uint256 VAR116, uint256 VAR117) private {
if (VAR56 == VAR114) {
require (VAR41[VAR114][VAR15] >= (VAR116.FUN11(VAR117)));
} else {
if (VAR56 == VAR113) {
require (VAR41[VAR56][VAR15].FUN11(VAR115) >= VAR117);
} else {
require (VAR41[VAR56][VAR15] >= VAR117);
}
require (VAR41[VAR114][VAR15] >= VAR116);
}
}
}
0
---------------------------------
342 0x013fbaed9c80cc4422ff50d71f4dc622bc7c8ae2.sol
pragma VAR1 ^0.4.8;
contract VAR2 {
uint256 public VAR3     = 1000 VAR4;
uint256 public VAR5  = 0;
address public VAR6;
address public VAR7;
bool    public VAR8      = false;
address public VAR9;
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN1() {
VAR9           = msg.sender;
VAR7     = msg.sender;
}
function FUN2(uint256 VAR11) onlyOwner {
require(VAR11 <= this.VAR12);
if(!VAR7.FUN3(this.VAR12)){
throw;
}
}
function FUN4(address VAR13) onlyOwner {
VAR6    = VAR13;
}
function FUN5() onlyOwner {
VAR8 = true;
}
function () payable {
assert(VAR8);
assert(VAR5 < VAR3);
require(msg.value != 0);
require(VAR5 + msg.value <= VAR3);
VAR5  += msg.value;
if(!FUN6(VAR6).FUN7(msg.sender, msg.value * 20000)){
throw;
}
}
}
contract VAR14 {
function FUN7(address VAR15, uint256 VAR11) returns (bool);
}
0
---------------------------------
343 0x01401f51f275bdcf89fbdf48f96e8aaca6aa6dde.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30067200;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x05dD74Fa6e85147d24A2093aCF0Ed5896233d621;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
344 0x01411f49388dfa9b18bb998ae6179fbd2e22d58f.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function transfer(address VAR3, uint256 value) public returns (bool);
event Transfer(address indexed VAR4, address indexed VAR3, uint256 value);
}
contract ERC20 is VAR1 {
function FUN3(address VAR5, address VAR6)
public view returns (uint256);
function FUN4(address VAR4, address VAR3, uint256 value)
public returns (bool);
function FUN5(address VAR6, uint256 value) public returns (bool);
event FUN6(
address indexed VAR5,
address indexed VAR6,
uint256 value
);
}
contract DetailedERC20 is VAR7 {
string public VAR8;
string public VAR9;
uint8 public VAR10;
constructor(string VAR11, string VAR12, uint8 VAR13) public {
VAR8 = VAR11;
VAR9 = VAR12;
VAR10 = VAR13;
}
}
library VAR14 {
function FUN7(uint256 VAR15, uint256 VAR16) internal pure returns (uint256 VAR17) {
if (VAR15 == 0) {
return 0;
}
VAR17 = VAR15 * VAR16;
assert(VAR17 / VAR15 == VAR16);
return VAR17;
}
function FUN8(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
return VAR15 / VAR16;
}
function FUN9(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
assert(VAR16 <= VAR15);
return VAR15 - VAR16;
}
function FUN10(uint256 VAR15, uint256 VAR16) internal pure returns (uint256 VAR17) {
VAR17 = VAR15 + VAR16;
assert(VAR17 >= VAR15);
return VAR17;
}
}
contract BasicToken is VAR1 {
using SafeMath for uint256;
mapping(address => uint256) VAR18;
uint256 VAR19;
function FUN1() public view returns (uint256) {
return VAR19;
}
function transfer(address VAR20, uint256 VAR21) public returns (bool) {
require(VAR20 != address(0));
require(VAR21 <= VAR18[msg.sender]);
VAR18[msg.sender] = VAR18[msg.sender].FUN9(VAR21);
VAR18[VAR20] = VAR18[VAR20].FUN10(VAR21);
emit Transfer(msg.sender, VAR20, VAR21);
return true;
}
function FUN2(address VAR22) public view returns (uint256) {
return VAR18[VAR22];
}
}
contract StandardToken is VAR7, VAR23 {
mapping (address => mapping (address => uint256)) internal VAR24;
function FUN4(
address VAR25,
address VAR20,
uint256 VAR21
)
public
returns (bool)
{
require(VAR20 != address(0));
require(VAR21 <= VAR18[VAR25]);
require(VAR21 <= VAR24[VAR25][msg.sender]);
VAR18[VAR25] = VAR18[VAR25].FUN9(VAR21);
VAR18[VAR20] = VAR18[VAR20].FUN10(VAR21);
VAR24[VAR25][msg.sender] = VAR24[VAR25][msg.sender].FUN9(VAR21);
emit Transfer(VAR25, VAR20, VAR21);
return true;
}
function FUN5(address VAR26, uint256 VAR21) public returns (bool) {
VAR24[msg.sender][VAR26] = VAR21;
emit FUN6(msg.sender, VAR26, VAR21);
return true;
}
function FUN3(
address VAR22,
address VAR26
)
public
view
returns (uint256)
{
return VAR24[VAR22][VAR26];
}
function FUN11(
address VAR26,
uint VAR27
)
public
returns (bool)
{
VAR24[msg.sender][VAR26] = (
VAR24[msg.sender][VAR26].FUN10(VAR27));
emit FUN6(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
function FUN12(
address VAR26,
uint VAR28
)
public
returns (bool)
{
uint VAR29 = VAR24[msg.sender][VAR26];
if (VAR28 > VAR29) {
VAR24[msg.sender][VAR26] = 0;
} else {
VAR24[msg.sender][VAR26] = VAR29.FUN9(VAR28);
}
emit FUN6(msg.sender, VAR26, VAR24[msg.sender][VAR26]);
return true;
}
}
contract EasyoptionToken is VAR30, VAR31 {
constructor(string VAR11, string VAR12, uint8 VAR13, uint256 VAR32)
FUN13(VAR11, VAR12, VAR13)
public
{
VAR19 = VAR32;
VAR18[msg.sender] = VAR32;
}
}
0
---------------------------------
345 0x014324b2307b1a578e3d64aa36e6e4b22b118061.sol
pragma VAR1 ^0.5.3;
contract VAR2 {
uint256 public VAR3 = 86400;
uint256 public VAR4 = 1 VAR5;
uint256 public VAR6 = 100 VAR5;
address public VAR7;
address public VAR8;
address public VAR9;
uint256 public VAR10 = 0;
uint256 public VAR11 = 1;
uint256 public VAR12 = 1;
uint256 public VAR13 = VAR14;
uint256 public VAR15 = VAR14;
uint256 public VAR16 = VAR14;
uint256 public VAR17 = VAR14;
address payable public VAR18 = 0xa4048772583220896ec93316616778B4EbC70F9d;
address[] public VAR19;
bytes32[] public VAR20;
bytes32[] public VAR21;
bytes32[] public VAR22;
mapping (address => VAR23) VAR24;
mapping (bytes32 => VAR25) public VAR26;
mapping (bytes32 => VAR27) public VAR28;
mapping (bytes32 => VAR29) public VAR30;
mapping (address => VAR31) public VAR32;
uint256 VAR33 = 0;
uint256 public VAR34 = 200;
uint256 public VAR35 = 2;
bool public VAR36 = true;
Vote public VAR37;
struct VAR31 {
address VAR38;
address VAR39;
address VAR40;
}
struct VAR41 {
uint256 VAR42;
string VAR43;
mapping (address => uint8) VAR44;
address payable VAR45;
uint256 VAR46;
uint256 VAR47;
uint256 VAR48;
}
struct VAR25 {
bytes32 VAR49;
uint256 VAR50;
uint256 VAR51;
address VAR52;
address VAR53;
bool VAR54;
}
struct VAR27 {
bytes32 VAR49;
uint256 VAR50;
uint256 VAR51;
address VAR52;
address VAR55;
uint256 VAR43;
uint256 VAR56;
}
struct VAR23 {
address VAR57;
address VAR58;
address VAR59;
address VAR60;
uint256 VAR61;
uint256 VAR62;
uint256 VAR63;
bool VAR64;
uint256 VAR65;
uint256 VAR66;
uint256 VAR67;
uint256 VAR68;
uint256 VAR69;
uint256 VAR70;
uint256 VAR71;
uint256 VAR72;
uint256 VAR73;
uint256 VAR74;
uint256 VAR75;
bytes32[] VAR26;
bytes32[] VAR28;
}
struct VAR29 {
bytes32 VAR49;
address VAR52;
uint256 VAR56;
uint256 VAR50;
}
constructor () public { VAR7 = msg.sender; }
modifier FUN1() {
require(msg.sender == VAR7 || msg.sender == VAR9 || msg.sender == VAR8);
VAR76;
}
modifier FUN2() { require(VAR36); require(msg.sender == VAR9 || msg.sender == VAR7); VAR76; }
function () payable external { FUN3(); }
function FUN4() internal view returns(uint256) {
return VAR33 + VAR14;
}
function FUN5(address sender) internal {
Investor storage VAR52 = VAR24[sender];
require(VAR52.VAR61 != 0);
if (VAR52.VAR62 == 0) require(msg.value >= VAR52.VAR75);
require(VAR52.VAR67 < VAR35);
require(VAR52.VAR66 < 50);
require(VAR52.VAR66 == 0 || FUN4() - VAR52.VAR65 < VAR3 * 7 || VAR52.VAR62 != 0);
VAR10 += msg.value;
bytes32 VAR49 = FUN6(VAR77.FUN7(VAR78.VAR79, FUN4(), sender, msg.value));
uint256 VAR80 = VAR52.VAR62 + msg.value <= VAR6 ? msg.value : VAR6 - VAR52.VAR62;
if (VAR80 == 0) return;
bool VAR54 = VAR24[VAR52.VAR57].VAR58 == sender;
Investment memory VAR81 = FUN8({ VAR49: VAR49, VAR50: FUN4(), VAR51: VAR80, VAR52: sender, VAR53: VAR52.VAR57, VAR54: VAR54  });
VAR26[VAR49] = VAR81;
FUN9(VAR49);
VAR20.FUN10(VAR49);
}
function FUN11(address VAR82, uint256 VAR56, uint256 VAR62) internal {
bytes32 VAR49 = FUN6(VAR77.FUN7(VAR78.VAR79, FUN4(), VAR82, VAR56));
MaxOut memory VAR83 = FUN12({ VAR49: VAR49, VAR50: FUN4(), VAR52: VAR82, VAR56: VAR56 });
VAR22.FUN10(VAR49);
VAR30[VAR49] = VAR83;
VAR24[VAR82].VAR75 = VAR62;
}
function FUN3() payable public { FUN5(msg.sender); }
function FUN9(bytes32 VAR84) internal {
Investment storage VAR81 = VAR26[VAR84];
uint256 VAR51 = VAR81.VAR51;
Investor storage VAR52 = VAR24[VAR81.VAR52];
VAR52.VAR26.FUN10(VAR84);
VAR52.VAR62 += VAR51;
address payable VAR85 = address(FUN13(VAR52.VAR60));
Investor storage VAR60 = VAR24[VAR85];
if (VAR85 != address(0)) {
VAR60.VAR68 += VAR51;
VAR60.VAR69 += VAR51;
}
if (VAR60.VAR62 >= VAR4 && !VAR60.VAR64) {
FUN14(VAR85, VAR51 / 10, 1, VAR81.VAR52, 0);
}
}
function FUN15(address payable VAR38) public view returns (address payable) {
WithdrawAccount memory VAR86 = VAR32[VAR38];
address VAR87 = VAR86.VAR39;
if (VAR87 != address(0)) return address(FUN13(VAR87));
return VAR38;
}
function FUN16(address VAR88) public {
require(VAR24[msg.sender].VAR62 > 0);
WithdrawAccount storage VAR89 = VAR32[msg.sender];
if (VAR89.VAR38 != address(0)) {
VAR89.VAR40 = VAR88;
return;
}
WithdrawAccount memory VAR86 = FUN17({
VAR38: msg.sender,
VAR39: msg.sender,
VAR40: VAR88
});
VAR32[msg.sender] = VAR86;
}
function FUN18(address VAR38, address VAR40) public VAR90 {
WithdrawAccount storage VAR86 = VAR32[VAR38];
require(VAR86.VAR40 == VAR40);
VAR86.VAR40 = address(0);
VAR86.VAR39 = VAR40;
}
function FUN19(bytes32 VAR84) public VAR90 {
Investment storage VAR81 = VAR26[VAR84];
require(VAR81.VAR53 != address(0));
uint256 VAR51 = VAR81.VAR51;
uint256 VAR91 = 0;
while (VAR81.VAR53 != address(0) && VAR91 < VAR34) {
Investor storage VAR52 = VAR24[VAR81.VAR53];
if (VAR81.VAR54) VAR52.VAR71 += VAR51;
else VAR52.VAR70 += VAR51;
VAR81.VAR54 = VAR24[VAR52.VAR57].VAR58 == VAR81.VAR53;
VAR81.VAR53 = VAR52.VAR57;
VAR91++;
}
}
function FUN14(address payable VAR82, uint256 value, uint256 VAR43, address VAR55, uint256 VAR56) internal {
if (value == 0 && VAR43 != 100) return;
if (VAR82 == address(0)) return;
Investor storage VAR52 = VAR24[VAR82];
uint256 VAR92 = FUN20(VAR82);
uint256 VAR93 = VAR52.VAR72 + FUN21(VAR82) + VAR92;
if (VAR43 == 1) VAR93 += value;
if (VAR93 + VAR52.VAR63 >= 3 * VAR52.VAR62) {
FUN22(VAR93, VAR82, VAR92);
return;
}
if (VAR52.VAR72 > 0) FUN23(VAR52.VAR72, VAR82, 4, address(0), 0);
FUN23(value, VAR82, VAR43, VAR55, VAR56);
}
function FUN23(uint256 VAR94, address payable VAR82, uint256 VAR43, address VAR55, uint256 VAR56) internal {
VAR24[VAR82].VAR63 += VAR94;
if (VAR43 == 4) VAR24[VAR82].VAR72 = 0;
if (VAR43 == 3) FUN24(VAR82, VAR56);
if (VAR43 == 2) VAR24[VAR82].VAR73 += VAR94;
FUN25(VAR94, VAR82, VAR43, VAR55, VAR56);
}
function FUN22(uint256 VAR93, address payable VAR82, uint256 VAR92) internal {
Investor storage VAR52 = VAR24[VAR82];
uint256 VAR94 = VAR52.VAR62 * 3 - VAR52.VAR63;
uint256 VAR95 = VAR93 - VAR94;
if (VAR92 > 0) FUN24(VAR82, 0);
VAR52.VAR66++;
VAR52.VAR67++;
uint256 VAR96 = VAR52.VAR62;
VAR52.VAR62 = 0;
VAR52.VAR63 = 0;
VAR52.VAR65 = FUN4();
VAR52.VAR73 = 0;
VAR52.VAR72 = VAR95;
FUN11(VAR82, VAR52.VAR66, VAR96);
FUN25(VAR94, VAR82, 0, address(0), 0);
}
function FUN25(uint256 VAR94, address payable VAR82, uint256 VAR43, address VAR55, uint256 VAR56) internal {
if (VAR94 == 0) return;
address payable VAR87 = FUN15(VAR82);
VAR87.transfer(VAR94 / 100 * 90);
VAR18.transfer(VAR94 / 100 * 10);
bytes32 VAR49 = FUN6(VAR77.FUN7(VAR78.VAR97, FUN4(), VAR82, VAR94, VAR43));
Withdrawal memory VAR98 = FUN26({ VAR49: VAR49, VAR50: FUN4(), VAR51: VAR94, VAR52: VAR82, VAR55: VAR55, VAR56: VAR56, VAR43: VAR43 });
VAR28[VAR49] = VAR98;
VAR24[VAR82].VAR28.FUN10(VAR49);
VAR21.FUN10(VAR49);
}
function FUN27(address VAR82) internal view returns(uint256 VAR99) {
Investor memory VAR52 = VAR24[VAR82];
uint256 VAR100 = FUN21(VAR82);
uint256 VAR63 = VAR52.VAR63;
uint256 VAR92 = FUN20(VAR82);
uint256 VAR101 = VAR100 + VAR63 + VAR92;
return VAR101;
}
function FUN28(address VAR85, address VAR102, address VAR103, bool VAR104) public VAR90 {
Investor storage VAR60 = VAR24[VAR85];
Investor storage VAR57 = VAR24[VAR103];
if (VAR19.VAR105 != 0) {
require(VAR60.VAR61 != 0);
require(VAR57.VAR61 != 0);
if (VAR104) {
require(VAR57.VAR58 == address(0));
} else {
require(VAR57.VAR59 == address(0));
}
}
Investor memory VAR52 = FUN29({
VAR57: VAR103,
VAR58: address(0),
VAR59: address(0),
VAR60: VAR85,
VAR61: VAR57.VAR61 + 1,
VAR62: 0,
VAR63: 0,
VAR64: false,
VAR65: FUN4(),
VAR66: 0,
VAR67: 0,
VAR68: 0,
VAR69: 0,
VAR74: FUN4(),
VAR26: new bytes32[](0),
VAR28: new bytes32[](0),
VAR75: VAR4,
VAR70: 0,
VAR71: 0,
VAR72: 0,
VAR73: 0
});
VAR24[VAR102] = VAR52;
VAR19.FUN10(VAR102);
if (VAR57.VAR61 == 0) return;
if (VAR104) {
VAR57.VAR58 = VAR102;
} else {
VAR57.VAR59 = VAR102;
}
}
function FUN21(address VAR82) internal view returns(uint256 VAR51) {
Investor memory VAR52 = VAR24[VAR82];
uint256 VAR106 = VAR52.VAR26.VAR105;
uint256 VAR107 = 0;
for (uint256 VAR108 = 0; VAR108 < VAR106; VAR108++) {
Investment memory VAR81 = VAR26[VAR52.VAR26[VAR108]];
if (VAR81.VAR50 < VAR52.VAR65) continue;
if (FUN4() - VAR81.VAR50 >= VAR3) {
uint256 VAR109 = (FUN4() - VAR81.VAR50) / VAR3;
uint256 VAR110 = VAR109 * VAR81.VAR51 / 100;
VAR107 = VAR110 + VAR107;
}
}
return VAR107 - VAR52.VAR73;
}
function FUN30(address payable VAR82, uint256 VAR56) public VAR90 {
uint256 VAR107 = FUN21(VAR82);
Investor storage VAR52 = VAR24[VAR82];
if (VAR56 > VAR3) {
uint256 VAR106 = VAR52.VAR26.VAR105;
bytes32 VAR111 = VAR52.VAR26[VAR106 - 1];
VAR26[VAR111].VAR50 -= VAR56;
VAR24[VAR82].VAR65 = VAR26[VAR111].VAR50;
return;
}
if (VAR52.VAR64) return;
FUN14(VAR82, VAR107, 2, address(0), VAR56);
}
function FUN31(uint256 VAR112, uint256 VAR113) public VAR90{
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
for(uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
FUN30(address(FUN13(VAR19[VAR108])), VAR12);
}
}
function FUN20(address VAR82) public view returns(uint256 VAR114) {
Investor memory VAR52 = VAR24[VAR82];
uint256 VAR62 = VAR52.VAR62;
uint256 VAR68 = VAR52.VAR68;
uint256 VAR71 = VAR52.VAR71;
uint256 VAR70 = VAR52.VAR70;
uint256 VAR69 = VAR52.VAR69;
uint256 VAR115 = VAR70 < VAR71 ? VAR70 : VAR71;
uint256 VAR116 = VAR115 * FUN32(VAR62, VAR68, VAR69) / 100;
return VAR116;
}
function FUN33(address payable VAR82, uint256 VAR56) public VAR90 {
Investor storage VAR52 = VAR24[VAR82];
if (VAR52.VAR64) return;
uint256 VAR117 = FUN20(VAR82);
FUN14(VAR82, VAR117, 3, address(0), VAR56);
}
function FUN24(address VAR82, uint256 VAR56) internal {
Investor storage VAR52 = VAR24[VAR82];
if (VAR11 > 3 && VAR56 != 0) {
VAR52.VAR70 = 0;
VAR52.VAR71 = 0;
} else if (VAR52.VAR70 >= VAR52.VAR71) {
VAR52.VAR70 = VAR52.VAR70 - VAR52.VAR71;
VAR52.VAR71 = 0;
} else {
VAR52.VAR71 = VAR52.VAR71 - VAR52.VAR70;
VAR52.VAR70 = 0;
}
if (VAR56 != 0) VAR52.VAR69 = 0;
}
function FUN34(uint256 VAR112, uint256 VAR113) public VAR90 {
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
if (FUN4() <= 30 * VAR3 + VAR16) return;
for(uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
FUN33(address(FUN13(VAR19[VAR108])), VAR11);
}
}
function FUN35() public VAR90 {
VAR15 = FUN4();
VAR12++;
}
function FUN36() public VAR90 {
VAR13 = FUN4();
VAR11++;
}
function FUN37(uint256 VAR112, uint256 VAR113) public VAR90 {
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
require(VAR37.VAR42 != 0);
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
require(VAR37.VAR46 > VAR37.VAR48 / 2);
require(VAR37.VAR45 == address(0));
VAR17 = FUN4();
for (uint256 VAR108 = VAR112; VAR108 < VAR113; VAR108++) {
address VAR82 = VAR19[VAR108];
Investor storage VAR52 = VAR24[VAR82];
uint256 VAR118 = VAR37.VAR44[VAR82] != 0 ? VAR37.VAR44[VAR82] : 2;
if (VAR118 == 2) {
if (VAR52.VAR66 > 0 || (VAR52.VAR63 >= VAR52.VAR62 && VAR52.VAR63 != 0)) {
VAR52.VAR65 = FUN4();
VAR52.VAR62 = 0;
VAR52.VAR63 = 0;
VAR52.VAR73 = 0;
}
VAR52.VAR72 = 0;
VAR52.VAR70 = 0;
VAR52.VAR71 = 0;
VAR52.VAR68 = 0;
VAR52.VAR69 = 0;
} else {
if (VAR52.VAR66 > 0 || (VAR52.VAR63 >= VAR52.VAR62 && VAR52.VAR63 != 0)) {
VAR52.VAR64 = true;
VAR52.VAR72 = 0;
VAR52.VAR65 = FUN4();
VAR52.VAR62 = 0;
VAR52.VAR63 = 0;
VAR52.VAR73 = 0;
}
VAR52.VAR72 = 0;
VAR52.VAR70 = 0;
VAR52.VAR71 = 0;
VAR52.VAR68 = 0;
VAR52.VAR69 = 0;
}
}
}
function FUN38(uint256 VAR119, uint256 VAR112, uint256 VAR113) mustBeAdmin public {
require(VAR37.VAR42 != 0);
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
require(VAR37.VAR47 > VAR37.VAR48 / 2);
require(VAR37.VAR45 == address(0));
require(VAR119 <= 50);
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
for (uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
address payable VAR82 = address(FUN13(VAR19[VAR108]));
Investor storage VAR52 = VAR24[VAR82];
if (VAR52.VAR66 > 0) continue;
if (VAR52.VAR64) continue;
uint256 VAR62 = VAR52.VAR62;
uint256 VAR63 = VAR52.VAR63;
if (VAR63 >= VAR62 / 2) continue;
FUN14(VAR82, VAR62 * VAR119 / 100 - VAR63, 6, address(0), 0);
}
}
function FUN39(address VAR52) public VAR90 { VAR24[VAR52].VAR65 = FUN4(); }
function FUN40(address payable VAR82) public VAR90 {
uint256 VAR120 = FUN20(VAR82);
uint256 VAR121 = FUN21(VAR82);
uint256 VAR63 = VAR24[VAR82].VAR63;
uint256 VAR62 = VAR24[VAR82].VAR62;
uint256 VAR72 = VAR24[VAR82].VAR72;
require(VAR62 > 0  && VAR63 + VAR120 + VAR121 + VAR72 >= 3 * VAR62);
FUN14(VAR82, 0, 100, address(0), 0);
}
function FUN41(uint256 VAR112, uint256 VAR113) public VAR90 {
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
for (uint256 VAR108 = VAR112; VAR108 < VAR113; VAR108++) {
address VAR82 = VAR19[VAR108];
if (VAR24[VAR82].VAR67 == 0) continue;
VAR24[VAR82].VAR67 = 0;
}
}
function FUN42(address VAR82, uint256 VAR56) public VAR90{ VAR24[VAR82].VAR66 = VAR56; }
function FUN43(address VAR82) public VAR90 {
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR64 = true;
}
function FUN44(address VAR82) public VAR90 {
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR64 = false;
}
function FUN45() payable public { VAR10 += msg.value; }
function FUN46(uint256 VAR68) internal pure returns (uint256 VAR122){
if (VAR68 < 30 VAR5) return 0;
if (VAR68 < 60 VAR5) return 1;
if (VAR68 < 90 VAR5) return 2;
if (VAR68 < 120 VAR5) return 3;
if (VAR68 < 150 VAR5) return 4;
return 5;
}
function FUN47(uint256 VAR69) internal pure returns (uint256 VAR122){
if (VAR69 < 2 VAR5) return 0;
if (VAR69 < 4 VAR5) return 1;
if (VAR69 < 6 VAR5) return 2;
if (VAR69 < 8 VAR5) return 3;
if (VAR69 < 10 VAR5) return 4;
return 5;
}
function FUN48(uint256 VAR62) internal pure returns (uint256 VAR122){
if (VAR62 < 2 VAR5) return 0;
if (VAR62 < 4 VAR5) return 1;
if (VAR62 < 6 VAR5) return 2;
if (VAR62 < 8 VAR5) return 3;
if (VAR62 < 10 VAR5) return 4;
return 5;
}
function FUN32(uint256 VAR62, uint256 VAR68, uint256 VAR69) internal pure returns(uint256 VAR122) {
uint256 VAR123 = FUN46(VAR68);
uint256 VAR124 = FUN48(VAR62);
uint256 VAR125 = FUN47(VAR69);
uint256 VAR126 = VAR123 < VAR124 ? VAR123 : VAR124;
uint256 VAR127 = VAR125 < VAR126 ? VAR125 : VAR126;
return VAR127 * 2;
}
function FUN49(string memory VAR128) internal pure returns (bytes32 VAR129) {
bytes memory VAR130 = bytes(VAR128);
if (VAR130.VAR105 == 0) return 0x0;
VAR131 { VAR129 := FUN50(FUN51(VAR128, 32)) }
}
function FUN52(address VAR82) view public returns (address[] memory VAR132, bool VAR64, uint256[] memory VAR133) {
VAR132 = new address[](4);
VAR133 = new uint256[](16);
Investor memory VAR52 = VAR24[VAR82];
VAR132[0] = VAR52.VAR57;
VAR132[1] = VAR52.VAR58;
VAR132[2] = VAR52.VAR59;
VAR132[3] = VAR52.VAR60;
VAR133[0] = VAR52.VAR61;
VAR133[1] = VAR52.VAR62;
VAR133[2] = VAR52.VAR63;
VAR133[3] = VAR52.VAR65;
VAR133[4] = VAR52.VAR66;
VAR133[5] = VAR52.VAR67;
VAR133[6] = VAR52.VAR68;
VAR133[7] = VAR52.VAR69;
VAR133[8] = VAR52.VAR70;
VAR133[9] = VAR52.VAR71;
VAR133[10] = VAR52.VAR72;
VAR133[11] = VAR52.VAR73;
VAR133[12] = VAR52.VAR74;
VAR133[13] = FUN20(VAR82);
VAR133[14] = FUN21(VAR82);
VAR133[15] = VAR52.VAR75;
return (VAR132, VAR52.VAR64, VAR133);
}
function FUN53() view public returns(uint256) { return VAR19.VAR105; }
function FUN54() view public returns(uint256) { return VAR22.VAR105; }
function FUN55(address VAR134) public view returns(address[] VAR135){
uint256 VAR136 = VAR19.VAR105;
address[] memory VAR137 = new address[](VAR136);
VAR137[0] = VAR134;
uint256 VAR138 = 0;
uint256 VAR139 = 1;
while (VAR138 != VAR139) {
Investor memory VAR140 = VAR24[VAR137[VAR138++]];
if (VAR140.VAR58 != address(0)) VAR137[VAR139++] = VAR140.VAR58;
if (VAR140.VAR59 != address(0)) VAR137[VAR139++] = VAR140.VAR59;
}
return VAR137;
}
function FUN56 () public view returns(uint256 VAR105) { return VAR20.VAR105; }
function FUN57() public view returns(uint256 VAR105) { return VAR21.VAR105; }
function FUN58(address[] memory VAR132, bool VAR64, uint256[] memory VAR133) public VAR141 {
if (VAR24[VAR132[4]].VAR61 != 0) return;
Investor memory VAR52 = FUN29({
VAR64: VAR64,
VAR57: VAR132[0],
VAR58: VAR132[1],
VAR59: VAR132[2],
VAR60: VAR132[3],
VAR61: VAR133[0],
VAR62: VAR133[1],
VAR63: VAR133[2],
VAR65: VAR133[3],
VAR66: VAR133[4],
VAR67: VAR133[5],
VAR68: VAR133[6],
VAR69: VAR133[7],
VAR26: new bytes32[](0),
VAR28: new bytes32[](0),
VAR70: VAR133[8],
VAR71: VAR133[9],
VAR72: VAR133[10],
VAR73: VAR133[11],
VAR74: VAR133[12],
VAR75: VAR4
});
VAR24[VAR132[4]] = VAR52;
VAR19.FUN10(VAR132[4]);
}
function FUN59(bytes32 VAR49, uint256 VAR50, uint256 VAR51, address VAR82) public VAR141 {
if (VAR26[VAR49].VAR50 != 0) return;
Investment memory VAR81 = FUN8({ VAR49: VAR49, VAR50: VAR50, VAR51: VAR51, VAR52: VAR82, VAR53: address(0), VAR54: false });
VAR26[VAR49] = VAR81;
VAR20.FUN10(VAR49);
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR26.FUN10(VAR49);
VAR10 += VAR51;
}
function FUN60(bytes32 VAR49, uint256 VAR50, uint256 VAR51, address VAR82, address VAR55, uint256 VAR43, uint256 VAR56) public VAR141 {
if (VAR28[VAR49].VAR50 != 0) return;
Withdrawal memory VAR98 = FUN26({ VAR49: VAR49, VAR50: VAR50, VAR51: VAR51, VAR52: VAR82, VAR55: VAR55, VAR56: VAR56, VAR43: VAR43 });
VAR28[VAR49] = VAR98;
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR28.FUN10(VAR49);
VAR21.FUN10(VAR49);
}
function FUN61() public VAR90 { VAR36 = false; }
function FUN62(uint256 VAR112, uint256 VAR113, bool VAR142) public VAR90 {
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
for (uint256 VAR143 = VAR112; VAR143 < VAR113; VAR143++) {
address VAR82 = VAR19[VAR143];
if (VAR142 && VAR37.VAR44[VAR82] == 3) {
VAR37.VAR44[VAR82] = 0;
continue;
}
if (VAR37.VAR44[VAR82] == 0) {
VAR37.VAR46 += 1;
}
VAR37.VAR44[VAR82] = 3;
}
}
function FUN63(string memory VAR43, address payable VAR45) public VAR90 {
require(VAR37.VAR42 == 0);
VAR37 = FUN64({
VAR42: FUN4(),
VAR43: VAR43,
VAR45: VAR45,
VAR46: 0,
VAR47: 0,
VAR48: VAR19.VAR105
});
}
function FUN65() public VAR90 {
VAR37 = FUN64({
VAR42: 0,
VAR43: '',
VAR45: address(0),
VAR46: 0,
VAR47: 0,
VAR48: 0
});
}
function FUN66() public VAR90 {
require(VAR37.VAR42 != 0);
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
require(VAR37.VAR46 > VAR37.VAR48 / 2);
require(VAR37.VAR45 != address(0));
bool VAR144 = false;
(VAR144, ) = VAR37.VAR45.call.value(address(this).VAR145)("");
if (!VAR144) revert();
}
function FUN67(address VAR52, bool VAR146) internal {
require(VAR24[VAR52].VAR62 > 0);
require(!VAR24[VAR52].VAR64);
require(FUN4() - VAR37.VAR42 < 3 * VAR3);
uint8 VAR147 = VAR146 ? 2 : 1;
uint8 VAR118 = VAR37.VAR44[VAR52];
require(VAR147 != VAR118);
FUN68(VAR146);
if (VAR118 == 0) return;
if (VAR146) {
VAR37.VAR47 -= FUN69();
} else {
VAR37.VAR46 -= FUN69();
}
}
function FUN70(bool VAR146) public { FUN67(msg.sender, VAR146); }
function FUN68(bool VAR146) internal {
VAR37.VAR44[msg.sender] = VAR146 ? 2 : 1;
if (VAR146) {
VAR37.VAR46 += FUN69();
} else {
VAR37.VAR47 += FUN69();
}
}
function FUN69() public view returns(uint256) {
if (VAR24[msg.sender].VAR61 >= 3) return 1;
if (VAR37.VAR48 > 40) return VAR37.VAR48 / 20;
return 2;
}
function FUN71(address VAR148) public VAR90 {
VAR9 = VAR148;
}
function FUN72(address VAR149) public VAR90 {
VAR8 = VAR149;
}
function FUN73(uint256 VAR150, uint256 VAR151, uint256 VAR152, uint256 VAR153, uint256 VAR154, uint256 VAR155) public VAR141 {
VAR11 = VAR150;
VAR12 = VAR151;
VAR13 = VAR152;
VAR15 = VAR153;
VAR16 = VAR154;
VAR17 = VAR155;
}
function FUN74(address VAR52) public payable VAR90 {
FUN5(VAR52);
}
function FUN75(address VAR82, uint256 VAR68, uint256 VAR69, uint256 VAR70, uint256 VAR71) public VAR90 {
Investor storage VAR52 = VAR24[VAR82];
require(VAR52.VAR61 > 0);
VAR52.VAR68 = VAR68;
VAR52.VAR69 = VAR69;
VAR52.VAR70 = VAR70;
VAR52.VAR71 = VAR71;
}
}
0
---------------------------------
346 0x0144417141881772e4b924c5408422dc251c3d12.sol
pragma VAR1 >= 0.5.0 < 0.6.0;
pragma VAR1 >= 0.5.0 < 0.6.0;
contract VAR2 {
function FUN1(bytes calldata VAR3) external;
}
contract VAR4 {
address public VAR5;
function FUN2(byte VAR6) external;
function FUN3(uint VAR7) external;
function FUN4(string memory VAR8) public returns (uint VAR9);
function FUN5() external view returns (bytes32 VAR10);
function FUN4(string memory VAR8, uint VAR11) public returns (uint VAR9);
function FUN6(uint VAR12, string memory VAR8, bytes memory VAR13) public payable returns (bytes32 VAR14);
function FUN7(uint VAR12, string calldata VAR8, string calldata VAR15) external payable returns (bytes32 VAR14);
function FUN8(uint VAR12, string memory VAR8, string memory VAR16, string memory VAR17) public payable returns (bytes32 VAR14);
function FUN9(uint VAR12, string calldata VAR8, string calldata VAR15, uint VAR11) external payable returns (bytes32 VAR14);
function FUN10(uint VAR12, string calldata VAR8, bytes calldata VAR13, uint VAR11) external payable returns (bytes32 VAR14);
function FUN11(uint VAR12, string calldata VAR8, string calldata VAR16, string calldata VAR17, uint VAR11) external payable returns (bytes32 VAR14);
}
contract VAR18 {
function FUN12() public returns (address VAR19);
}
library VAR20 {
struct VAR21 {
bytes VAR22;
uint VAR23;
}
function FUN13(buffer memory VAR24, uint VAR25) internal pure {
uint VAR23 = VAR25;
if (VAR23 % 32 != 0) {
VAR23 += 32 - (VAR23 % 32);
}
VAR24.VAR23 = VAR23;
VAR26 {
let VAR27 := FUN14(0x40)
FUN15(VAR24, VAR27)
FUN15(VAR27, 0)
FUN15(0x40, FUN16(VAR27, VAR23))
}
}
function FUN17(buffer memory VAR24, uint VAR25) private pure {
bytes memory VAR28 = VAR24.VAR22;
FUN13(VAR24, VAR25);
FUN18(VAR24, VAR28);
}
function FUN19(uint VAR29, uint VAR30) private pure returns (uint VAR31) {
if (VAR29 > VAR30) {
return VAR29;
}
return VAR30;
}
function FUN18(buffer memory VAR24, bytes memory VAR32) internal pure returns (buffer memory VAR33) {
if (VAR32.VAR34 + VAR24.VAR22.VAR34 > VAR24.VAR23) {
FUN17(VAR24, FUN19(VAR24.VAR23, VAR32.VAR34) * 2);
}
uint VAR35;
uint VAR36;
uint VAR37 = VAR32.VAR34;
VAR26 {
let VAR38 := FUN14(VAR24)
let VAR39 := FUN14(VAR38)
VAR35 := FUN16(FUN16(VAR38, VAR39), 32)
FUN15(VAR38, FUN16(VAR39, FUN14(VAR32)))
VAR36 := FUN16(VAR32, 32)
}
for(; VAR37 >= 32; VAR37 -= 32) {
VAR26 {
FUN15(VAR35, FUN14(VAR36))
}
VAR35 += 32;
VAR36 += 32;
}
uint VAR40 = 256 ** (32 - VAR37) - 1;
VAR26 {
let VAR41 := FUN20(FUN14(VAR36), FUN21(VAR40))
let VAR42 := FUN20(FUN14(VAR35), VAR40)
FUN15(VAR35, or(VAR42, VAR41))
}
return VAR24;
}
function FUN18(buffer memory VAR24, uint8 VAR32) internal pure {
if (VAR24.VAR22.VAR34 + 1 > VAR24.VAR23) {
FUN17(VAR24, VAR24.VAR23 * 2);
}
VAR26 {
let VAR38 := FUN14(VAR24)
let VAR39 := FUN14(VAR38)
let VAR35 := FUN16(FUN16(VAR38, VAR39), 32)
FUN22(VAR35, VAR32)
FUN15(VAR38, FUN16(VAR39, 1))
}
}
function FUN23(buffer memory VAR24, uint VAR32, uint VAR43) internal pure returns (buffer memory VAR33) {
if (VAR43 + VAR24.VAR22.VAR34 > VAR24.VAR23) {
FUN17(VAR24, FUN19(VAR24.VAR23, VAR43) * 2);
}
uint VAR40 = 256 ** VAR43 - 1;
VAR26 {
let VAR38 := FUN14(VAR24)
let VAR39 := FUN14(VAR38)
let VAR35 := FUN16(FUN16(VAR38, VAR39), VAR43)
FUN15(VAR35, or(FUN20(FUN14(VAR35), FUN21(VAR40)), VAR32))
FUN15(VAR38, FUN16(VAR39, VAR43))
}
return VAR24;
}
}
library VAR44 {
using Buffer for VAR20.VAR21;
uint8 private constant VAR45 = 0;
uint8 private constant VAR46 = 5;
uint8 private constant VAR47 = 2;
uint8 private constant VAR48 = 4;
uint8 private constant VAR49 = 3;
uint8 private constant VAR50 = 1;
uint8 private constant VAR51 = 7;
function FUN24(VAR20.buffer memory VAR24, uint8 VAR52, uint VAR53) private pure {
if (VAR53 <= 23) {
VAR24.FUN18(uint8((VAR52 << 5) | VAR53));
} else if (VAR53 <= 0xFF) {
VAR24.FUN18(uint8((VAR52 << 5) | 24));
VAR24.FUN23(VAR53, 1);
} else if (VAR53 <= 0xFFFF) {
VAR24.FUN18(uint8((VAR52 << 5) | 25));
VAR24.FUN23(VAR53, 2);
} else if (VAR53 <= 0xFFFFFFFF) {
VAR24.FUN18(uint8((VAR52 << 5) | 26));
VAR24.FUN23(VAR53, 4);
} else if (VAR53 <= 0xFFFFFFFFFFFFFFFF) {
VAR24.FUN18(uint8((VAR52 << 5) | 27));
VAR24.FUN23(VAR53, 8);
}
}
function FUN25(VAR20.buffer memory VAR24, uint8 VAR52) private pure {
VAR24.FUN18(uint8((VAR52 << 5) | 31));
}
function FUN26(VAR20.buffer memory VAR24, uint VAR53) internal pure {
FUN24(VAR24, VAR45, VAR53);
}
function FUN27(VAR20.buffer memory VAR24, int VAR53) internal pure {
if (VAR53 >= 0) {
FUN24(VAR24, VAR45, uint(VAR53));
} else {
FUN24(VAR24, VAR50, uint(-1 - VAR53));
}
}
function FUN28(VAR20.buffer memory VAR24, bytes memory VAR53) internal pure {
FUN24(VAR24, VAR47, VAR53.VAR34);
VAR24.FUN18(VAR53);
}
function FUN29(VAR20.buffer memory VAR24, string memory VAR53) internal pure {
FUN24(VAR24, VAR49, bytes(VAR53).VAR34);
VAR24.FUN18(bytes(VAR53));
}
function FUN30(VAR20.buffer memory VAR24) internal pure {
FUN25(VAR24, VAR48);
}
function FUN31(VAR20.buffer memory VAR24) internal pure {
FUN25(VAR24, VAR46);
}
function FUN32(VAR20.buffer memory VAR24) internal pure {
FUN25(VAR24, VAR51);
}
}
contract VAR54 {
using CBOR for VAR20.VAR21;
OraclizeI VAR55;
OraclizeAddrResolverI VAR56;
uint constant VAR57 = 60 * 60 * 24;
uint constant VAR58 = 60 * 60 * 24 * 7;
uint constant VAR59 = 60 * 60 * 24 * 30;
byte constant VAR60 = 0x00;
byte constant VAR61 = 0x30;
byte constant VAR62 = 0xF0;
byte constant VAR63 = 0x01;
byte constant VAR64 = 0x40;
byte constant VAR65 = 0x10;
string VAR66;
uint8 constant VAR67 = 0;
uint8 constant VAR68 = 2;
uint8 constant VAR69 = 1;
uint8 constant VAR70 = 2;
uint8 constant VAR71 = 161;
mapping(bytes32 => bytes32) VAR72;
mapping(bytes32 => bool) VAR73;
modifier VAR74 {
if ((address(VAR56) == address(0)) || (FUN33(address(VAR56)) == 0)) {
FUN34(VAR67);
}
if (address(VAR55) != VAR56.FUN12()) {
VAR55 = FUN35(VAR56.FUN12());
}
VAR75;
}
modifier FUN36(bytes32 VAR76, string memory VAR77, bytes memory VAR78) {
require((VAR78[0] == "") && (VAR78[1] == "") && (uint8(VAR78[2]) == uint8(1)));
bool VAR79 = FUN37(VAR78, VAR76, bytes(VAR77), FUN38());
require(VAR79);
VAR75;
}
function FUN34(uint8 VAR80) internal returns (bool VAR81) {
VAR80;
return FUN34();
}
function FUN39(string memory VAR82) internal {
VAR66 = VAR82;
}
function FUN38() internal view returns (string memory VAR83) {
return VAR66;
}
function FUN34() internal returns (bool VAR81) {
if (FUN33(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0) {
VAR56 = FUN40(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN39("");
return true;
}
if (FUN33(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0) {
VAR56 = FUN40(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN39("");
return true;
}
if (FUN33(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0) {
VAR56 = FUN40(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN39("");
return true;
}
if (FUN33(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0) {
VAR56 = FUN40(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN39("");
return true;
}
if (FUN33(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41) > 0) {
VAR56 = FUN40(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41);
FUN39("");
return true;
}
if (FUN33(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0) {
VAR56 = FUN40(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN33(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0) {
VAR56 = FUN40(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN33(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0) {
VAR56 = FUN40(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN41(bytes32 VAR84, string memory VAR77) public {
FUN41(VAR84, VAR77, VAR85 bytes(0));
}
function FUN41(bytes32 VAR84, string memory VAR77, bytes memory VAR78) public {
VAR84; VAR77; VAR78;
VAR72[bytes32(0)] = bytes32(0);
}
function FUN42(string memory VAR8) oraclizeAPI internal returns (uint VAR86) {
return VAR55.FUN4(VAR8);
}
function FUN42(string memory VAR8, uint VAR11) oraclizeAPI internal returns (uint VAR86) {
return VAR55.FUN4(VAR8, VAR11);
}
function FUN43(string memory VAR8, string memory VAR15) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
return VAR55.VAR91.value(VAR87)(0, VAR8, VAR15);
}
function FUN43(uint VAR12, string memory VAR8, string memory VAR15) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
return VAR55.VAR91.value(VAR87)(VAR12, VAR8, VAR15);
}
function FUN43(uint VAR12, string memory VAR8, string memory VAR15, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8,VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
return VAR55.VAR92.value(VAR87)(VAR12, VAR8, VAR15, VAR11);
}
function FUN43(string memory VAR8, string memory VAR15, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8, VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
return VAR55.VAR92.value(VAR87)(0, VAR8, VAR15, VAR11);
}
function FUN43(string memory VAR8, string memory VAR16, string memory VAR17) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
return VAR55.VAR93.value(VAR87)(0, VAR8, VAR16, VAR17);
}
function FUN43(uint VAR12, string memory VAR8, string memory VAR16, string memory VAR17) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
return VAR55.VAR93.value(VAR87)(VAR12, VAR8, VAR16, VAR17);
}
function FUN43(uint VAR12, string memory VAR8, string memory VAR16, string memory VAR17, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8, VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
return VAR55.VAR94.value(VAR87)(VAR12, VAR8, VAR16, VAR17, VAR11);
}
function FUN43(string memory VAR8, string memory VAR16, string memory VAR17, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8, VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
return VAR55.VAR94.value(VAR87)(0, VAR8, VAR16, VAR17, VAR11);
}
function FUN43(string memory VAR8, string[] memory VAR13) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
bytes memory VAR95 = FUN44(VAR13);
return VAR55.VAR96.value(VAR87)(0, VAR8, VAR95);
}
function FUN43(uint VAR12, string memory VAR8, string[] memory VAR13) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
bytes memory VAR95 = FUN44(VAR13);
return VAR55.VAR96.value(VAR87)(VAR12, VAR8, VAR95);
}
function FUN43(uint VAR12, string memory VAR8, string[] memory VAR13, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8, VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
bytes memory VAR95 = FUN44(VAR13);
return VAR55.VAR97.value(VAR87)(VAR12, VAR8, VAR95, VAR11);
}
function FUN43(string memory VAR8, string[] memory VAR13, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8, VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
bytes memory VAR95 = FUN44(VAR13);
return VAR55.VAR97.value(VAR87)(0, VAR8, VAR95, VAR11);
}
function FUN43(string memory VAR8, string[1] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[1] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[1] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[1] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[2] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[2] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[2] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[2] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[3] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[3] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[3] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[3] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[4] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[4] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[4] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[4] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[5] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[5] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, string[5] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, string[5] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
string[] memory VAR99 = new string[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[] memory VAR13) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
bytes memory VAR95 = FUN45(VAR13);
return VAR55.VAR96.value(VAR87)(0, VAR8, VAR95);
}
function FUN43(uint VAR12, string memory VAR8, bytes[] memory VAR13) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * 200000) {
return 0;
}
bytes memory VAR95 = FUN45(VAR13);
return VAR55.VAR96.value(VAR87)(VAR12, VAR8, VAR95);
}
function FUN43(uint VAR12, string memory VAR8, bytes[] memory VAR13, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8, VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
bytes memory VAR95 = FUN45(VAR13);
return VAR55.VAR97.value(VAR87)(VAR12, VAR8, VAR95, VAR11);
}
function FUN43(string memory VAR8, bytes[] memory VAR13, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
uint VAR87 = VAR55.FUN4(VAR8, VAR11);
if (VAR87 > 1 VAR88 + VAR89.VAR90 * VAR11) {
return 0;
}
bytes memory VAR95 = FUN45(VAR13);
return VAR55.VAR97.value(VAR87)(0, VAR8, VAR95, VAR11);
}
function FUN43(string memory VAR8, bytes[1] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[1] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[1] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[1] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](1);
VAR99[0] = VAR98[0];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[2] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[2] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[2] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[2] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](2);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[3] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[3] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[3] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[3] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](3);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[4] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[4] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[4] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[4] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](4);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[5] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[5] memory VAR98) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR12, VAR8, VAR99);
}
function FUN43(uint VAR12, string memory VAR8, bytes[5] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR12, VAR8, VAR99, VAR11);
}
function FUN43(string memory VAR8, bytes[5] memory VAR98, uint VAR11) oraclizeAPI internal returns (bytes32 VAR14) {
bytes[] memory VAR99 = new bytes[](5);
VAR99[0] = VAR98[0];
VAR99[1] = VAR98[1];
VAR99[2] = VAR98[2];
VAR99[3] = VAR98[3];
VAR99[4] = VAR98[4];
return FUN43(VAR8, VAR99, VAR11);
}
function FUN46(byte VAR100) oraclizeAPI internal {
return VAR55.FUN2(VAR100);
}
function FUN47() oraclizeAPI internal returns (address VAR101) {
return VAR55.FUN48();
}
function FUN33(address VAR102) view internal returns (uint VAR103) {
VAR26 {
VAR103 := FUN49(VAR102)
}
}
function FUN50(uint VAR7) oraclizeAPI internal {
return VAR55.FUN3(VAR7);
}
function FUN51() oraclizeAPI internal returns (bytes32 VAR10) {
return VAR55.FUN5();
}
function FUN52(string memory VAR29) internal pure returns (address VAR104) {
bytes memory VAR105 = bytes(VAR29);
uint160 VAR106 = 0;
uint160 VAR107;
uint160 VAR108;
for (uint VAR109 = 2; VAR109 < 2 + 2 * 20; VAR109 += 2) {
VAR106 *= 256;
VAR107 = FUN53(uint8(VAR105[VAR109]));
VAR108 = FUN53(uint8(VAR105[VAR109 + 1]));
if ((VAR107 >= 97) && (VAR107 <= 102)) {
VAR107 -= 87;
} else if ((VAR107 >= 65) && (VAR107 <= 70)) {
VAR107 -= 55;
} else if ((VAR107 >= 48) && (VAR107 <= 57)) {
VAR107 -= 48;
}
if ((VAR108 >= 97) && (VAR108 <= 102)) {
VAR108 -= 87;
} else if ((VAR108 >= 65) && (VAR108 <= 70)) {
VAR108 -= 55;
} else if ((VAR108 >= 48) && (VAR108 <= 57)) {
VAR108 -= 48;
}
VAR106 += (VAR107 * 16 + VAR108);
}
return address(VAR106);
}
function FUN54(string memory VAR29, string memory VAR30) internal pure returns (int VAR110) {
bytes memory VAR111 = bytes(VAR29);
bytes memory VAR112 = bytes(VAR30);
uint VAR113 = VAR111.VAR34;
if (VAR112.VAR34 < VAR113) {
VAR113 = VAR112.VAR34;
}
for (uint VAR109 = 0; VAR109 < VAR113; VAR109 ++) {
if (VAR111[VAR109] < VAR112[VAR109]) {
return -1;
} else if (VAR111[VAR109] > VAR112[VAR109]) {
return 1;
}
}
if (VAR111.VAR34 < VAR112.VAR34) {
return -1;
} else if (VAR111.VAR34 > VAR112.VAR34) {
return 1;
} else {
return 0;
}
}
function FUN55(string memory VAR114, string memory VAR115) internal pure returns (int VAR110) {
bytes memory VAR116 = bytes(VAR114);
bytes memory VAR117 = bytes(VAR115);
if (VAR116.VAR34 < 1 || VAR117.VAR34 < 1 || (VAR117.VAR34 > VAR116.VAR34)) {
return -1;
} else if (VAR116.VAR34 > (2 ** 128 - 1)) {
return -1;
} else {
uint VAR118 = 0;
for (uint VAR109 = 0; VAR109 < VAR116.VAR34; VAR109++) {
if (VAR116[VAR109] == VAR117[0]) {
VAR118 = 1;
while(VAR118 < VAR117.VAR34 && (VAR109 + VAR118) < VAR116.VAR34 && VAR116[VAR109 + VAR118] == VAR117[VAR118]) {
VAR118++;
}
if (VAR118 == VAR117.VAR34) {
return int(VAR109);
}
}
}
return -1;
}
}
function FUN56(string memory VAR29, string memory VAR30) internal pure returns (string memory VAR119) {
return FUN56(VAR29, VAR30, "", "", "");
}
function FUN56(string memory VAR29, string memory VAR30, string memory VAR120) internal pure returns (string memory VAR119) {
return FUN56(VAR29, VAR30, VAR120, "", "");
}
function FUN56(string memory VAR29, string memory VAR30, string memory VAR120, string memory VAR121) internal pure returns (string memory VAR119) {
return FUN56(VAR29, VAR30, VAR120, VAR121, "");
}
function FUN56(string memory VAR29, string memory VAR30, string memory VAR120, string memory VAR121, string memory VAR122) internal pure returns (string memory VAR119) {
bytes memory VAR123 = bytes(VAR29);
bytes memory VAR124 = bytes(VAR30);
bytes memory VAR125 = bytes(VAR120);
bytes memory VAR126 = bytes(VAR121);
bytes memory VAR127 = bytes(VAR122);
string memory VAR128 = VAR85 string(VAR123.VAR34 + VAR124.VAR34 + VAR125.VAR34 + VAR126.VAR34 + VAR127.VAR34);
bytes memory VAR129 = bytes(VAR128);
uint VAR130 = 0;
uint VAR109 = 0;
for (VAR109 = 0; VAR109 < VAR123.VAR34; VAR109++) {
VAR129[VAR130++] = VAR123[VAR109];
}
for (VAR109 = 0; VAR109 < VAR124.VAR34; VAR109++) {
VAR129[VAR130++] = VAR124[VAR109];
}
for (VAR109 = 0; VAR109 < VAR125.VAR34; VAR109++) {
VAR129[VAR130++] = VAR125[VAR109];
}
for (VAR109 = 0; VAR109 < VAR126.VAR34; VAR109++) {
VAR129[VAR130++] = VAR126[VAR109];
}
for (VAR109 = 0; VAR109 < VAR127.VAR34; VAR109++) {
VAR129[VAR130++] = VAR127[VAR109];
}
return string(VAR129);
}
function FUN57(string memory VAR29) internal pure returns (uint VAR131) {
return FUN57(VAR29, 0);
}
function FUN57(string memory VAR29, uint VAR30) internal pure returns (uint VAR131) {
bytes memory VAR132 = bytes(VAR29);
uint VAR133 = 0;
bool VAR134 = false;
for (uint VAR109 = 0; VAR109 < VAR132.VAR34; VAR109++) {
if ((uint(uint8(VAR132[VAR109])) >= 48) && (uint(uint8(VAR132[VAR109])) <= 57)) {
if (VAR134) {
if (VAR30 == 0) break;
else VAR30--;
}
VAR133 *= 10;
VAR133 += uint(uint8(VAR132[VAR109])) - 48;
} else if (uint(uint8(VAR132[VAR109])) == 46) {
require(!VAR134, '');
VAR134 = true;
} else {
revert("");
}
}
if (VAR30 > 0) {
VAR133 *= 10 ** VAR30;
}
return VAR133;
}
function FUN58(string memory VAR29) internal pure returns (uint VAR131) {
return FUN58(VAR29, 0);
}
function FUN58(string memory VAR29, uint VAR30) internal pure returns (uint VAR131) {
bytes memory VAR132 = bytes(VAR29);
uint VAR133 = 0;
bool VAR134 = false;
for (uint VAR109 = 0; VAR109 < VAR132.VAR34; VAR109++) {
if ((uint(uint8(VAR132[VAR109])) >= 48) && (uint(uint8(VAR132[VAR109])) <= 57)) {
if (VAR134) {
if (VAR30 == 0) {
break;
} else {
VAR30--;
}
}
VAR133 *= 10;
VAR133 += uint(uint8(VAR132[VAR109])) - 48;
} else if (uint(uint8(VAR132[VAR109])) == 46) {
VAR134 = true;
}
}
if (VAR30 > 0) {
VAR133 *= 10 ** VAR30;
}
return VAR133;
}
function FUN59(uint VAR135) internal pure returns (string memory VAR136) {
if (VAR135 == 0) {
return "";
}
uint VAR137 = VAR135;
uint VAR37;
while (VAR137 != 0) {
VAR37++;
VAR137 /= 10;
}
bytes memory VAR138 = VAR85 bytes(VAR37);
uint VAR130 = VAR37 - 1;
while (VAR135 != 0) {
VAR138[VAR130--] = FUN60(uint8(48 + VAR135 % 10));
VAR135 /= 10;
}
return string(VAR138);
}
function FUN44(string[] memory VAR139) internal pure returns (bytes memory VAR140) {
FUN61();
VAR20.buffer memory VAR22;
VAR20.FUN13(VAR22, 1024);
VAR22.FUN30();
for (uint VAR109 = 0; VAR109 < VAR139.VAR34; VAR109++) {
VAR22.FUN29(VAR139[VAR109]);
}
VAR22.FUN32();
return VAR22.VAR22;
}
function FUN45(bytes[] memory VAR139) internal pure returns (bytes memory VAR140) {
FUN61();
VAR20.buffer memory VAR22;
VAR20.FUN13(VAR22, 1024);
VAR22.FUN30();
for (uint VAR109 = 0; VAR109 < VAR139.VAR34; VAR109++) {
VAR22.FUN28(VAR139[VAR109]);
}
VAR22.FUN32();
return VAR22.VAR22;
}
function FUN62(uint VAR141, uint VAR142, uint VAR143) internal returns (bytes32 VAR76) {
require((VAR142 > 0) && (VAR142 <= 32));
VAR141 *= 10;
bytes memory VAR144 = VAR85 bytes(1);
VAR144[0] = FUN60(uint8(VAR142));
bytes memory VAR145 = VAR85 bytes(32);
bytes memory VAR146 = VAR85 bytes(32);
bytes32 VAR147 = FUN51();
VAR26 {
FUN15(VAR145, 0x20)
FUN15(FUN16(VAR145, 0x20), FUN63(FUN64(FUN65(VAR148, 1)), FUN63(VAR149, VAR150)))
FUN15(VAR146, 0x20)
FUN15(FUN16(VAR146, 0x20), VAR147)
}
bytes memory VAR151 = VAR85 bytes(32);
VAR26 {
FUN15(FUN16(VAR151, 0x20), VAR141)
}
bytes memory VAR152 = VAR85 bytes(8);
FUN66(VAR151, 24, 8, VAR152, 0);
bytes[4] memory VAR95 = [VAR145, VAR144, VAR146, VAR151];
bytes32 VAR153 = FUN43("", VAR95, VAR143);
bytes memory VAR154 = VAR85 bytes(8);
VAR26 {
let VAR3 := FUN14(FUN16(VAR152, 0x20))
FUN22(FUN16(VAR154, 0x27), FUN67(VAR3, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN22(FUN16(VAR154, 0x26), FUN67(VAR3, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN22(FUN16(VAR154, 0x25), FUN67(VAR3, 0x10000000000000000000000000000000000000000000000000000000000))
FUN22(FUN16(VAR154, 0x24), FUN67(VAR3, 0x100000000000000000000000000000000000000000000000000000000))
FUN22(FUN16(VAR154, 0x23), FUN67(VAR3, 0x1000000000000000000000000000000000000000000000000000000))
FUN22(FUN16(VAR154, 0x22), FUN67(VAR3, 0x10000000000000000000000000000000000000000000000000000))
FUN22(FUN16(VAR154, 0x21), FUN67(VAR3, 0x100000000000000000000000000000000000000000000000000))
FUN22(FUN16(VAR154, 0x20), FUN67(VAR3, 0x1000000000000000000000000000000000000000000000000))
}
FUN68(VAR153, FUN69(VAR155.FUN70(VAR154, VAR95[1], FUN71(VAR95[0]), VAR95[2])));
return VAR153;
}
function FUN68(bytes32 VAR76, bytes32 VAR156) internal {
VAR72[VAR76] = VAR156;
}
function FUN72(bytes32 VAR157, bytes memory VAR158, bytes memory VAR159) internal returns (bool VAR160) {
bool VAR161;
address VAR162;
bytes32 VAR163;
bytes32 VAR164;
bytes memory VAR165 = VAR85 bytes(32);
uint VAR166 = 4 + (uint(uint8(VAR158[3])) - 0x20);
VAR165 = FUN66(VAR158, VAR166, 32, VAR165, 0);
bytes memory VAR167 = VAR85 bytes(32);
VAR166 += 32 + 2;
VAR167 = FUN66(VAR158, VAR166 + (uint(uint8(VAR158[VAR166 - 1])) - 0x20), 32, VAR167, 0);
VAR26 {
VAR163 := FUN14(FUN16(VAR165, 32))
VAR164 := FUN14(FUN16(VAR167, 32))
}
(VAR161, VAR162) = FUN73(VAR157, 27, VAR163, VAR164);
if (address(FUN53(uint256(FUN69(VAR159)))) == VAR162) {
return true;
} else {
(VAR161, VAR162) = FUN73(VAR157, 28, VAR163, VAR164);
return (address(FUN53(uint256(FUN69(VAR159)))) == VAR162);
}
}
function FUN74(bytes memory VAR78, uint VAR168) internal returns (bool VAR169) {
bool VAR161;
bytes memory VAR170 = VAR85 bytes(uint(uint8(VAR78[VAR168 + 1])) + 2);
FUN66(VAR78, VAR168, VAR170.VAR34, VAR170, 0);
bytes memory VAR171 = VAR85 bytes(64);
FUN66(VAR78, 3 + 1, 64, VAR171, 0);
bytes memory VAR172 = VAR85 bytes(1 + 65 + 32);
VAR172[0] = FUN60(uint8(1));
FUN66(VAR78, VAR168 - 65, 65, VAR172, 1);
bytes memory VAR173 = VAR174"";
FUN66(VAR173, 0, 32, VAR172, 1 + 65);
VAR161 = FUN72(FUN71(VAR172), VAR170, VAR171);
if (!VAR161) {
return false;
}
bytes memory VAR175 = VAR174"";
bytes memory VAR176 = VAR85 bytes(1 + 65);
VAR176[0] = 0xFE;
FUN66(VAR78, 3, 65, VAR176, 1);
bytes memory VAR177 = VAR85 bytes(uint(uint8(VAR78[3 + 65 + 1])) + 2);
FUN66(VAR78, 3 + 65, VAR177.VAR34, VAR177, 0);
VAR161 = FUN72(FUN71(VAR176), VAR177, VAR175);
return VAR161;
}
function FUN75(bytes32 VAR76, string memory VAR77, bytes memory VAR78) internal returns (uint8 VAR110) {
if ((VAR78[0] != "") || (VAR78[1] != "") || (uint8(VAR78[2]) != uint8(1))) {
return 1;
}
bool VAR79 = FUN37(VAR78, VAR76, bytes(VAR77), FUN38());
if (!VAR79) {
return 2;
}
return 0;
}
function FUN76(bytes32 VAR178, bytes memory VAR179, uint VAR180) internal pure returns (bool VAR181) {
bool VAR182 = true;
require(VAR179.VAR34 == VAR180);
for (uint256 VAR109 = 0; VAR109< VAR180; VAR109++) {
if (VAR178[VAR109] != VAR179[VAR109]) {
VAR182 = false;
}
}
return VAR182;
}
function FUN37(bytes memory VAR78, bytes32 VAR76, bytes memory VAR77, string memory VAR183) internal returns (bool VAR169) {
uint VAR184 = 3 + 65 + (uint(uint8(VAR78[3 + 65 + 1])) + 2) + 32;
bytes memory VAR185 = VAR85 bytes(32);
FUN66(VAR78, VAR184, 32, VAR185, 0);
if (!(FUN69(VAR185) == FUN69(VAR155.FUN70(FUN71(VAR155.FUN70(VAR183, VAR76)))))) {
return false;
}
bytes memory VAR186 = VAR85 bytes(uint(uint8(VAR78[VAR184 + (32 + 8 + 1 + 32) + 1])) + 2);
FUN66(VAR78, VAR184 + (32 + 8 + 1 + 32), VAR186.VAR34, VAR186, 0);
if (!FUN76(FUN71(VAR186), VAR77, uint(uint8(VAR78[VAR184 + 32 + 8])))) {
return false;
}
bytes memory VAR187 = VAR85 bytes(8 + 1 + 32);
FUN66(VAR78, VAR184 + 32, 8 + 1 + 32, VAR187, 0);
bytes memory VAR188 = VAR85 bytes(64);
uint VAR189 = VAR184 + 32 + (8 + 1 + 32) + VAR186.VAR34 + 65;
FUN66(VAR78, VAR189 - 64, 64, VAR188, 0);
bytes32 VAR190 = FUN71(VAR188);
if (VAR72[VAR76] == FUN69(VAR155.FUN70(VAR187, VAR190))) {
delete VAR72[VAR76];
} else return false;
bytes memory VAR191 = VAR85 bytes(32 + 8 + 1 + 32);
FUN66(VAR78, VAR184, 32 + 8 + 1 + 32, VAR191, 0);
if (!FUN72(FUN71(VAR191), VAR186, VAR188)) {
return false;
}
if (!VAR73[VAR190]) {
VAR73[VAR190] = FUN74(VAR78, VAR189);
}
return VAR73[VAR190];
}
function FUN66(bytes memory VAR192, uint VAR193, uint VAR194, bytes memory VAR195, uint VAR196) internal pure returns (bytes memory VAR197) {
uint VAR113 = VAR194 + VAR196;
require(VAR195.VAR34 >= VAR113);
uint VAR109 = 32 + VAR193;
uint VAR137 = 32 + VAR196;
while (VAR109 < (32 + VAR193 + VAR194)) {
VAR26 {
let VAR105 := FUN14(FUN16(VAR192, VAR109))
FUN15(FUN16(VAR195, VAR137), VAR105)
}
VAR109 += 32;
VAR137 += 32;
}
return VAR195;
}
function FUN73(bytes32 VAR198, uint8 VAR199, bytes32 VAR200, bytes32 VAR201) internal returns (bool VAR202, address VAR203) {
bool VAR204;
address VAR205;
VAR26 {
let VAR206 := FUN14(0x40)
FUN15(VAR206, VAR198)
FUN15(FUN16(VAR206, 32), VAR199)
FUN15(FUN16(VAR206, 64), VAR200)
FUN15(FUN16(VAR206, 96), VAR201)
VAR204 := call(3000, 1, 0, VAR206, 128, VAR206, 32)
VAR205 := FUN14(VAR206)
}
return (VAR204, VAR205);
}
function FUN77(bytes32 VAR198, bytes memory VAR207) internal returns (bool VAR202, address VAR203) {
bytes32 VAR208;
bytes32 VAR209;
uint8 VAR210;
if (VAR207.VAR34 != 65) {
return (false, address(0));
}
VAR26 {
VAR208 := FUN14(FUN16(VAR207, 32))
VAR209 := FUN14(FUN16(VAR207, 64))
VAR210 := FUN60(0, FUN14(FUN16(VAR207, 96)))
}
if (VAR210 < 27) {
VAR210 += 27;
}
if (VAR210 != 27 && VAR210 != 28) {
return (false, address(0));
}
return FUN73(VAR198, VAR210, VAR208, VAR209);
}
function FUN61() internal pure {
VAR26 {
let VAR211 := FUN14(0x40)
FUN78(VAR211, VAR212, FUN65(VAR213, VAR211))
}
}
}
contract DieselPrice is VAR54 {
uint public VAR214;
event FUN79(string VAR87);
event FUN80(string VAR215);
constructor()
public
{
FUN81();
}
function FUN41(
bytes32 VAR84,
string memory VAR77
)
public
{
require(msg.sender == FUN47());
emit FUN79(VAR77);
VAR214 = FUN58(VAR77, 2);
}
function FUN81()
public
payable
{
emit FUN80("");
FUN43("", "FUN82(VAR216:
}
}
0
---------------------------------
347 0x0149e0aaea12ed0fa6ca63175051d17fd2e5afae.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR5 = VAR2 * VAR3;
require(VAR5 / VAR2 == VAR3, "");
return VAR5;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
uint256 VAR5 = VAR2 / VAR3;
return VAR5;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
require(VAR3 <= VAR2, "");
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
uint256 VAR5 = VAR2 + VAR3;
require(VAR5 >= VAR2, "");
return VAR5;
}
}
contract VAR6 {
mapping(address => bool) public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
event FUN6(address indexed VAR10);
event FUN7(address indexed VAR10);
constructor() public {
VAR7[msg.sender] = true;
}
modifier onlyOwner() {
require(VAR7[msg.sender], "");
VAR11;
}
function FUN8(address VAR9) public onlyOwner returns (bool VAR12) {
require(VAR9 != address(0), "");
emit FUN5(msg.sender, VAR9);
VAR7[VAR9] = true;
VAR7[msg.sender] = false;
return true;
}
function FUN9(address VAR10) public onlyOwner returns (bool VAR12) {
VAR7[VAR10] = true;
emit FUN6(VAR10);
return true;
}
function FUN10(address VAR10) public onlyOwner returns (bool VAR12) {
VAR7[VAR10] = false;
emit FUN7(VAR10);
return true;
}
}
contract TokenIOStorage is VAR6 {
mapping(bytes32 => uint256)    internal VAR13;
mapping(bytes32 => string)     internal VAR14;
mapping(bytes32 => address)    internal VAR15;
mapping(bytes32 => bytes)      internal VAR16;
mapping(bytes32 => bool)       internal VAR17;
mapping(bytes32 => VAR18)     internal VAR19;
constructor() public {
VAR7[msg.sender] = true;
}
function FUN11(bytes32 VAR20, address VAR21) public onlyOwner returns (bool VAR12) {
VAR15[VAR20] = VAR21;
return true;
}
function FUN12(bytes32 VAR20, uint VAR21) public onlyOwner returns (bool VAR12) {
VAR13[VAR20] = VAR21;
return true;
}
function FUN13(bytes32 VAR20, string VAR21) public onlyOwner returns (bool VAR12) {
VAR14[VAR20] = VAR21;
return true;
}
function FUN14(bytes32 VAR20, bytes VAR21) public onlyOwner returns (bool VAR12) {
VAR16[VAR20] = VAR21;
return true;
}
function FUN15(bytes32 VAR20, bool VAR21) public onlyOwner returns (bool VAR12) {
VAR17[VAR20] = VAR21;
return true;
}
function FUN16(bytes32 VAR20, int VAR21) public onlyOwner returns (bool VAR12) {
VAR19[VAR20] = VAR21;
return true;
}
function FUN17(bytes32 VAR20) public onlyOwner returns (bool VAR12) {
delete VAR15[VAR20];
return true;
}
function FUN18(bytes32 VAR20) public onlyOwner returns (bool VAR12) {
delete VAR13[VAR20];
return true;
}
function FUN19(bytes32 VAR20) public onlyOwner returns (bool VAR12) {
delete VAR14[VAR20];
return true;
}
function FUN20(bytes32 VAR20) public onlyOwner returns (bool VAR12) {
delete VAR16[VAR20];
return true;
}
function FUN21(bytes32 VAR20) public onlyOwner returns (bool VAR12) {
delete VAR17[VAR20];
return true;
}
function FUN22(bytes32 VAR20) public onlyOwner returns (bool VAR12) {
delete VAR19[VAR20];
return true;
}
function FUN23(bytes32 VAR20) public view returns (address VAR21) {
return VAR15[VAR20];
}
function FUN24(bytes32 VAR20) public view returns (uint VAR21) {
return VAR13[VAR20];
}
function FUN25(bytes32 VAR20) public view returns (string VAR21) {
return VAR14[VAR20];
}
function FUN26(bytes32 VAR20) public view returns (bytes VAR21) {
return VAR16[VAR20];
}
function FUN27(bytes32 VAR20) public view returns (bool VAR21) {
return VAR17[VAR20];
}
function FUN28(bytes32 VAR20) public view returns (int VAR21) {
return VAR19[VAR20];
}
}
library VAR22 {
using SafeMath for uint;
struct VAR23 {
TokenIOStorage VAR24;
}
event FUN29(address indexed VAR7, address indexed VAR25, uint VAR26);
event FUN30(string VAR27, address indexed VAR28, uint VAR26, string VAR29);
event FUN31(string VAR27, address indexed VAR28, uint VAR26, string VAR29);
event Transfer(string VAR27, address indexed VAR30, address indexed VAR31, uint VAR26, bytes VAR32);
event FUN32(address indexed VAR28, bool VAR33, string VAR29);
event FUN33(address indexed VAR28, bool VAR33, string VAR29);
event FUN34(string VAR34,string VAR35,uint VAR36,uint VAR37, uint VAR38, bytes32 VAR39);
event FUN35(address indexed VAR40, address indexed VAR41);
event FUN36(address indexed VAR42, string VAR29);
function FUN37(Data storage VAR43, string VAR44) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN13(VAR45, VAR44),
""
);
return true;
}
function FUN40(Data storage VAR43, string VAR47) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN13(VAR45, VAR47),
""
);
return true;
}
function FUN41(Data storage VAR43, string VAR48) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN13(VAR45, VAR48),
""
);
return true;
}
function FUN42(Data storage VAR43, string VAR49) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN13(VAR45, VAR49),
""
);
return true;
}
function FUN43(Data storage VAR43, string VAR27, uint VAR50) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27));
require(
VAR43.VAR24.FUN12(VAR45, VAR50),
""
);
return true;
}
function FUN44(Data storage VAR43, uint VAR51) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN12(VAR45, VAR51),
""
);
return true;
}
function FUN45(Data storage VAR43, uint VAR52) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN12(VAR45, VAR52),
""
);
return true;
}
function FUN46(Data storage VAR43, uint VAR53) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN12(VAR45, VAR53),
""
);
return true;
}
function FUN47(Data storage VAR43, uint VAR54) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN12(VAR45, VAR54),
""
);
return true;
}
function FUN48(Data storage VAR43, bytes VAR55) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN14(VAR45, VAR55),
""
);
return true;
}
function FUN49(Data storage VAR43, address VAR56) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', address(this)));
require(
VAR43.VAR24.FUN11(VAR45, VAR56),
""
);
return true;
}
function FUN50(Data storage VAR43, string VAR27) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27));
require(
VAR43.VAR24.FUN11(VAR45, address(this)),
""
);
return true;
}
function FUN51(Data storage VAR43, address VAR28, bool VAR57, string VAR29) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', FUN52(VAR43, VAR28)));
require(
VAR43.VAR24.FUN15(VAR45, VAR57),
""
);
emit FUN32(VAR28, VAR57, VAR29);
return true;
}
function FUN53(Data storage VAR43, address VAR28, bool VAR58, string VAR29) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', FUN52(VAR43, VAR28)));
require(
VAR43.VAR24.FUN15(VAR45, VAR58),
""
);
emit FUN33(VAR28, VAR58, VAR29);
return true;
}
function FUN54(Data storage VAR43, address VAR40, address VAR41) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR41));
require(
VAR43.VAR24.FUN11(VAR45, VAR40),
""
);
return true;
}
function FUN52(Data storage VAR43, address VAR28) internal view returns (address VAR59) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR28));
address VAR40 = VAR43.VAR24.FUN23(VAR45);
if (VAR40 != 0x0) {
return VAR40;
} else {
return VAR28;
}
}
function FUN55(Data storage VAR43, address VAR28) internal view returns (bool VAR33) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', FUN52(VAR43, VAR28)));
return VAR43.VAR24.FUN27(VAR45);
}
function FUN56(Data storage VAR43, address VAR28) internal view returns (bool VAR33) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', FUN52(VAR43, VAR28)));
return VAR43.VAR24.FUN27(VAR45);
}
function FUN57(Data storage VAR43, string VAR27) internal view returns (address VAR60) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27));
return VAR43.VAR24.FUN23(VAR45);
}
function FUN58(Data storage VAR43, address VAR60) internal view returns (string VAR44) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN25(VAR45);
}
function FUN59(Data storage VAR43, address VAR60) internal view returns (string VAR47) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN25(VAR45);
}
function FUN60(Data storage VAR43, address VAR60) internal view returns (string VAR48) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN25(VAR45);
}
function FUN61(Data storage VAR43, address VAR60) internal view returns (string) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN25(VAR45);
}
function FUN62(Data storage VAR43, string VAR27) internal view returns (uint VAR50) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN63(Data storage VAR43, address VAR60) internal view returns (uint VAR61) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN64(Data storage VAR43, address VAR60) internal view returns (uint VAR52) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN65(Data storage VAR43, address VAR60) internal view returns (uint VAR53) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN66(Data storage VAR43, address VAR60) internal view returns (uint VAR54) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN67(Data storage VAR43, address VAR60) internal view returns (bytes VAR55) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN26(VAR45);
}
function FUN68(Data storage VAR43, address VAR60) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39(''));
require(
VAR43.VAR24.FUN11(VAR45, VAR60),
""
);
return true;
}
function FUN69(Data storage VAR43) internal view returns (address VAR62) {
bytes32 VAR45 = FUN38(VAR46.FUN39(''));
return VAR43.VAR24.FUN23(VAR45);
}
function FUN70(Data storage VAR43, address VAR60) internal view returns (address VAR56) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
address VAR63 = VAR43.VAR24.FUN23(VAR45);
if (VAR63 == 0x0) {
return FUN69(VAR43);
} else {
return VAR63;
}
}
function FUN71(Data storage VAR43, string VAR27) internal view returns (uint VAR64) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN72(Data storage VAR43, string VAR27, address VAR28, address VAR25) internal view returns (uint VAR65) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR28), FUN52(VAR43, VAR25)));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN73(Data storage VAR43, string VAR27, address VAR28) internal view returns (uint VAR66) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR28)));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN74(Data storage VAR43, string VAR27, address VAR28) internal view returns (uint VAR67) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR28)));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN75(Data storage VAR43, string VAR27, address VAR28, uint VAR26) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR28)));
require(
VAR43.VAR24.FUN12(VAR45, VAR26),
""
);
return true;
}
function FUN76(Data storage VAR43, address VAR60, uint VAR26) internal view returns (uint VAR68) {
uint VAR69 = VAR43.VAR24.FUN24(FUN38(VAR46.FUN39('', VAR60)));
uint VAR70 = VAR43.VAR24.FUN24(FUN38(VAR46.FUN39('', VAR60)));
uint VAR71 = VAR43.VAR24.FUN24(FUN38(VAR46.FUN39('', VAR60)));
uint VAR72 = VAR43.VAR24.FUN24(FUN38(VAR46.FUN39('', VAR60)));
uint VAR73 = ((VAR26.FUN1(VAR71)).FUN2(10000)).FUN4(VAR72);
if (VAR73 > VAR69) {
return VAR69;
} else if (VAR73 < VAR70) {
return VAR70;
} else {
return VAR73;
}
}
function FUN77(Data storage VAR43, address VAR74, address VAR75) internal view returns (bool VAR76) {
require(
FUN78(VAR43, VAR74),
""
);
require(
FUN78(VAR43, VAR75),
""
);
return true;
}
function FUN78(Data storage VAR43, address VAR28) internal view returns (bool VAR76) {
require(
FUN55(VAR43, VAR28),
""
);
require(
FUN56(VAR43, VAR28),
""
);
return true;
}
function transfer(Data storage VAR43, string VAR27, address VAR31, uint VAR26, bytes VAR32) internal returns (bool VAR12) {
require(address(VAR31) != 0x0, "" );
require(VAR26 > 0, "");
address VAR56 = FUN70(VAR43, address(this));
uint VAR73 = FUN76(VAR43, VAR56, VAR26);
require(
FUN79(VAR43, msg.sender, FUN80(VAR43, VAR27, VAR26)),
"");
require(
FUN81(VAR43, VAR27, msg.sender, VAR31, VAR26, VAR32),
"");
require(
FUN81(VAR43, VAR27, msg.sender, VAR56, VAR73, FUN67(VAR43, VAR56)),
"");
return true;
}
function FUN82(Data storage VAR43, string VAR27, address VAR30, address VAR31, uint VAR26, bytes VAR32) internal returns (bool VAR12) {
require(
address(VAR31) != 0x0,
""
);
address VAR56 = FUN70(VAR43, address(this));
uint VAR73 = FUN76(VAR43, VAR56, VAR26);
require(
FUN79(VAR43, VAR30, FUN80(VAR43, VAR27, VAR26)),
""
);
require(
FUN81(VAR43, VAR27, VAR30, VAR31, VAR26, VAR32),
""
);
require(
FUN81(VAR43, VAR27, VAR30, VAR56, VAR73, FUN67(VAR43, VAR56)),
""
);
require(
FUN83(VAR43, VAR27, VAR30, VAR26),
""
);
return true;
}
function FUN81(Data storage VAR43, string VAR27, address VAR30, address VAR31, uint VAR26, bytes VAR32) internal returns (bool VAR12) {
require(
address(VAR31) != 0x0,
""
);
bytes32 VAR77 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR30)));
bytes32 VAR78 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR31)));
require(
VAR43.VAR24.FUN12(VAR77, VAR43.VAR24.FUN24(VAR77).FUN3(VAR26)),
""
);
require(
VAR43.VAR24.FUN12(VAR78, VAR43.VAR24.FUN24(VAR78).FUN4(VAR26)),
""
);
emit Transfer(VAR27, VAR30, VAR31, VAR26, VAR32);
return true;
}
function FUN83(Data storage VAR43, string VAR27, address VAR28, uint VAR26) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR28), FUN52(VAR43, msg.sender)));
require(
VAR43.VAR24.FUN12(VAR45, VAR43.VAR24.FUN24(VAR45).FUN3(VAR26)),
""
);
return true;
}
function FUN84(Data storage VAR43, address VAR25, uint VAR26) internal returns (bool VAR12) {
require(VAR25 != 0x0,
"");
string memory VAR27 = FUN59(VAR43, address(this));
require(
FUN74(VAR43, VAR27, FUN52(VAR43, VAR25)) == 0,
"");
bytes32 VAR77 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, msg.sender), FUN52(VAR43, VAR25)));
bytes32 VAR78 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, msg.sender)));
require(
VAR43.VAR24.FUN24(VAR77) == 0 || VAR26 == 0,
"");
require(
VAR43.VAR24.FUN24(VAR78) >= VAR26,
"");
require(
VAR43.VAR24.FUN12(VAR77, VAR26),
"");
emit FUN29(msg.sender, VAR25, VAR26);
return true;
}
function FUN85(Data storage VAR43, string VAR27, address VAR28, uint VAR26, string VAR29) internal returns (bool VAR12) {
bytes32 VAR77 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR28)));
bytes32 VAR78 = FUN38(VAR46.FUN39('', VAR27, VAR29));
bytes32 VAR79 = FUN38(VAR46.FUN39('', VAR27));
require(VAR43.VAR24.FUN12(VAR77, VAR43.VAR24.FUN24(VAR77).FUN4(VAR26)),
"");
require(VAR43.VAR24.FUN12(VAR78, VAR43.VAR24.FUN24(VAR78).FUN4(VAR26)),
"");
require(VAR43.VAR24.FUN12(VAR79, VAR43.VAR24.FUN24(VAR79).FUN4(VAR26)),
"");
emit FUN30(VAR27, VAR28, VAR26, VAR29);
return true;
}
function FUN86(Data storage VAR43, string VAR27, address VAR28, uint VAR26, string VAR29) internal returns (bool VAR12) {
bytes32 VAR77 = FUN38(VAR46.FUN39('', VAR27, FUN52(VAR43, VAR28)));
bytes32 VAR78 = FUN38(VAR46.FUN39('', VAR27, VAR29));
bytes32 VAR79 = FUN38(VAR46.FUN39('', VAR27));
require(
VAR43.VAR24.FUN12(VAR77, VAR43.VAR24.FUN24(VAR77).FUN3(VAR26)),
"");
require(
VAR43.VAR24.FUN12(VAR78, VAR43.VAR24.FUN24(VAR78).FUN3(VAR26)),
"");
require(
VAR43.VAR24.FUN12(VAR79, VAR43.VAR24.FUN24(VAR79).FUN3(VAR26)),
"");
emit FUN31(VAR27, VAR28, VAR26, VAR29);
return true;
}
function FUN87(Data storage VAR43, string VAR29, bool VAR80) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR29));
require(
VAR43.VAR24.FUN15(VAR45, VAR80),
""
);
return true;
}
function FUN88(Data storage VAR43, string VAR29, address VAR81, bool VAR80) internal returns (bool VAR12) {
require(
FUN89(VAR43, VAR29),
"");
bytes32 VAR77 = FUN38(VAR46.FUN39('', VAR29, VAR81));
bytes32 VAR78 = FUN38(VAR46.FUN39('', VAR81));
require(
VAR43.VAR24.FUN15(VAR77, VAR80),
"");
require(
VAR43.VAR24.FUN13(VAR78, VAR29),
"");
return true;
}
function FUN90(Data storage VAR43, address VAR81) internal view returns (string VAR29) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', FUN52(VAR43, VAR81)));
return VAR43.VAR24.FUN25(VAR45);
}
function FUN89(Data storage VAR43, string VAR29) internal view returns (bool VAR82) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR29));
return VAR43.VAR24.FUN27(VAR45);
}
function FUN91(Data storage VAR43, string VAR29, address VAR81) internal view returns (bool VAR82) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR29, FUN52(VAR43, VAR81)));
return VAR43.VAR24.FUN27(VAR45);
}
function FUN92(Data storage VAR43, address VAR81) internal view returns (bool VAR82) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', FUN90(VAR43, FUN52(VAR43, VAR81)), FUN52(VAR43, VAR81)));
return VAR43.VAR24.FUN27(VAR45);
}
function FUN93(Data storage VAR43, bytes32 VAR83) internal view returns (bool VAR84) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR83));
return VAR43.VAR24.FUN27(VAR45);
}
function FUN94(Data storage VAR43, bytes32 VAR83) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR83));
require(!FUN93(VAR43, VAR83),
"");
require(VAR43.VAR24.FUN15(VAR45, true),
"");
return true;
}
function FUN95(
Data storage VAR43,
address VAR85,
string VAR86,
string VAR87,
uint VAR88,
uint VAR89,
uint8 VAR90,
bytes32 VAR91,
bytes32 VAR92,
uint VAR38
) internal returns (bool VAR12) {
bytes32 VAR93 = FUN38(VAR46.FUN39(VAR85, VAR86, VAR87, VAR88, VAR89, VAR38));
require(
FUN77(VAR43, msg.sender, VAR85),
"");
require(
FUN94(VAR43, VAR93),
"");
require(VAR38 >= VAR94, "");
require(
FUN96(VAR93, VAR90, VAR91, VAR92) == VAR85,
"");
require(
FUN81(VAR43, VAR86, msg.sender, VAR85, VAR88, ""),
"");
require(
FUN81(VAR43, VAR87, VAR85, msg.sender, VAR89, ""),
"");
emit FUN34(VAR86, VAR87, VAR88, VAR89, VAR38, VAR93);
return true;
}
function FUN97(Data storage VAR43, address VAR60) internal returns (bool VAR12) {
require(VAR60 != 0x0,
"");
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
require(VAR43.VAR24.FUN15(VAR45, true),
"");
return true;
}
function FUN98(Data storage VAR43, address VAR60) internal view returns (bool VAR33) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR60));
return VAR43.VAR24.FUN27(VAR45);
}
function FUN99(Data storage VAR43, address VAR28, uint VAR95) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR28));
require(VAR43.VAR24.FUN12(VAR45, VAR95),
"");
return true;
}
function FUN100(Data storage VAR43, address VAR28) internal view returns (uint VAR95) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR28));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN101(Data storage VAR43, address VAR28, uint VAR96) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR28));
require(VAR43.VAR24.FUN12(VAR45, VAR96),
"");
return true;
}
function FUN102(Data storage VAR43, address VAR28) internal view returns (uint VAR96) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR28));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN79(Data storage VAR43, address VAR28, uint VAR26) internal returns (bool VAR12) {
require(FUN103(VAR43, VAR28),
"");
uint VAR97 = FUN104(VAR43, VAR28).FUN4(VAR26);
require(
FUN102(VAR43, VAR28) >= VAR97,
"");
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR28, FUN100(VAR43, VAR28)));
require(VAR43.VAR24.FUN12(VAR45, VAR97),
"");
return true;
}
function FUN103(Data storage VAR43, address VAR28) internal returns (bool VAR12) {
uint VAR98 = FUN100(VAR43, VAR28);
if (VAR98 > VAR94) {
return true;
} else {
uint VAR99 = 86400;
require(
FUN99(VAR43, VAR28, VAR98.FUN4(((VAR94.FUN3(VAR98)).FUN2(VAR99).FUN4(1)).FUN1(VAR99))),
"");
return true;
}
}
function FUN104(Data storage VAR43, address VAR28) internal view returns (uint VAR26) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR28, FUN100(VAR43, VAR28)));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN105(Data storage VAR43, address VAR28) internal view returns (uint VAR100) {
return FUN102(VAR43, VAR28).FUN3(FUN104(VAR43, VAR28));
}
function FUN106(Data storage VAR43, string VAR27, uint VAR101) internal returns (bool VAR12) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27));
require(
VAR43.VAR24.FUN12(VAR45, VAR101),
"");
return true;
}
function FUN107(Data storage VAR43, string VAR27) internal view returns (uint VAR101) {
bytes32 VAR45 = FUN38(VAR46.FUN39('', VAR27));
return VAR43.VAR24.FUN24(VAR45);
}
function FUN80(Data storage VAR43, string VAR27, uint VAR102) internal view returns (uint VAR26) {
uint VAR103 = FUN62(VAR43, '');
uint VAR104 = FUN62(VAR43, VAR27);
uint VAR105 = ((VAR102.FUN1(FUN107(VAR43, VAR27)).FUN2(10000)).FUN1(10**VAR103)).FUN2(10**VAR104);
return VAR105;
}
}
contract TokenIOFeeContract is VAR6 {
using TokenIOLib for VAR22.VAR23;
VAR22.Data VAR106;
constructor(address VAR107) public {
VAR106.VAR24 = FUN108(VAR107);
VAR7[msg.sender] = true;
}
function FUN109(uint VAR61, uint VAR52, uint VAR53, uint VAR54, bytes VAR55) public onlyOwner returns (bool VAR12) {
require(VAR106.FUN44(VAR61), "");
require(VAR106.FUN45(VAR52), "");
require(VAR106.FUN46(VAR53), "");
require(VAR106.FUN47(VAR54), "");
require(VAR106.FUN48(VAR55), "");
return true;
}
function FUN110() public view returns (uint VAR108, uint VAR109, uint VAR110, uint VAR111, bytes VAR55, address VAR56) {
return (
VAR106.FUN63(address(this)),
VAR106.FUN64(address(this)),
VAR106.FUN65(address(this)),
VAR106.FUN66(address(this)),
VAR106.FUN67(address(this)),
address(this)
);
}
function FUN73(string VAR27) public view returns(uint VAR66) {
return VAR106.FUN73(VAR27, address(this));
}
function FUN76(uint VAR26) public view returns (uint VAR73) {
return VAR106.FUN76(address(this), VAR26);
}
function FUN111(string VAR27, address VAR31, uint VAR26, bytes VAR32) public onlyOwner returns (bool VAR12) {
require(
VAR106.FUN81(VAR27, address(this), VAR31, VAR26, VAR32),
""
);
return true;
}
}
0
---------------------------------
348 0x014b50466590340d41307cc54dcee990c8d58aa8.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
function FUN1 () constant returns (uint256 VAR3);
function FUN2 (address VAR4) constant returns (uint256 VAR5);
function transfer (address VAR6, uint256 VAR7) returns (bool VAR8);
function FUN3 (address VAR9, address VAR6, uint256 VAR7)
returns (bool VAR8);
function FUN4 (address VAR10, uint256 VAR7) returns (bool VAR8);
function FUN5 (address VAR4, address VAR10) constant
returns (uint256 VAR11);
event Transfer (address indexed VAR9, address indexed VAR6, uint256 VAR7);
event FUN6 (
address indexed VAR4, address indexed VAR10, uint256 VAR7);
}
pragma VAR1 ^0.4.11;
contract VAR12 {
uint256 constant private VAR13 =
0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
function FUN7 (uint256 VAR14, uint256 VAR15)
constant internal
returns (uint256 VAR16) {
if (VAR14 > VAR13 - VAR15) throw;
return VAR14 + VAR15;
}
function FUN8 (uint256 VAR14, uint256 VAR15)
constant internal
returns (uint256 VAR16) {
if (VAR14 < VAR15) throw;
return VAR14 - VAR15;
}
function FUN9 (uint256 VAR14, uint256 VAR15)
constant internal
returns (uint256 VAR16) {
if (VAR15 == 0) return 0;
if (VAR14 > VAR13 / VAR15) throw;
return VAR14 * VAR15;
}
}
contract AbstractToken is VAR2, VAR12 {
function FUN10 () {
}
function FUN2 (address VAR4) constant returns (uint256 VAR5) {
return VAR17 [VAR4];
}
function transfer (address VAR6, uint256 VAR7) returns (bool VAR8) {
if (VAR17 [msg.sender] < VAR7) return false;
if (VAR7 > 0 && msg.sender != VAR6) {
VAR17 [msg.sender] = FUN8 (VAR17 [msg.sender], VAR7);
VAR17 [VAR6] = FUN7 (VAR17 [VAR6], VAR7);
Transfer (msg.sender, VAR6, VAR7);
}
return true;
}
function FUN3 (address VAR9, address VAR6, uint256 VAR7)
returns (bool VAR8) {
if (VAR18 [VAR9][msg.sender] < VAR7) return false;
if (VAR17 [VAR9] < VAR7) return false;
VAR18 [VAR9][msg.sender] =
FUN8 (VAR18 [VAR9][msg.sender], VAR7);
if (VAR7 > 0 && VAR9 != VAR6) {
VAR17 [VAR9] = FUN8 (VAR17 [VAR9], VAR7);
VAR17 [VAR6] = FUN7 (VAR17 [VAR6], VAR7);
Transfer (VAR9, VAR6, VAR7);
}
return true;
}
function FUN4 (address VAR10, uint256 VAR7) returns (bool VAR8) {
VAR18 [msg.sender][VAR10] = VAR7;
FUN6 (msg.sender, VAR10, VAR7);
return true;
}
function FUN5 (address VAR4, address VAR10) constant
returns (uint256 VAR11) {
return VAR18 [VAR4][VAR10];
}
mapping (address => uint256) VAR17;
mapping (address => mapping (address => uint256)) private VAR18;
}
contract ICOSToken is VAR19 {
address VAR20;
uint256 VAR21;
bool VAR22 = false;
function FUN11 (uint256 VAR23) {
VAR21 = VAR23;
VAR17 [msg.sender] = VAR23;
VAR20 = msg.sender;
}
function FUN12 () constant returns (string VAR24) {
return "";
}
function FUN13 () constant returns (uint8 VAR25) {
return 6;
}
function FUN1 () constant returns (uint256 VAR3) {
return VAR21;
}
function transfer (address VAR6, uint256 VAR7) returns (bool VAR8) {
if (VAR22) return false;
else return VAR19.transfer (VAR6, VAR7);
}
function FUN3 (address VAR9, address VAR6, uint256 VAR7)
returns (bool VAR8) {
if (VAR22) return false;
else return VAR19.FUN3 (VAR9, VAR6, VAR7);
}
function FUN4 (address VAR10, uint256 VAR26, uint256 VAR27)
returns (bool VAR8) {
if (FUN5 (msg.sender, VAR10) == VAR26)
return FUN4 (VAR10, VAR27);
else return false;
}
function FUN14 (uint256 VAR7) returns (bool VAR8) {
if (VAR7 > VAR17 [msg.sender]) return false;
else if (VAR7 > 0) {
VAR17 [msg.sender] = FUN8 (VAR17 [msg.sender], VAR7);
VAR21 = FUN8 (VAR21, VAR7);
return true;
} else return true;
}
function FUN15 (address VAR28) {
if (msg.sender != VAR20) throw;
VAR20 = VAR28;
}
function FUN16 () {
if (msg.sender != VAR20) throw;
if (!VAR22) {
VAR22 = true;
FUN17 ();
}
}
function FUN18 () {
if (msg.sender != VAR20) throw;
if (VAR22) {
VAR22 = false;
FUN19 ();
}
}
event FUN17 ();
event FUN19 ();
}
0
---------------------------------
349 0x015531a044bae03bf4dab1ceabfc232a969b7175.sol
pragma solidity 0.4.24;
contract VAR1 {
event FUN1();
event FUN2();
address public VAR2;
bool public VAR3 = false;
constructor() public {
VAR2 = msg.sender;
}
function FUN3(address VAR4) public onlyGovernor {
VAR2 = VAR4;
}
modifier onlyGovernor {
require(msg.sender == VAR2);
VAR5;
}
modifier FUN4() {
require(!VAR3);
VAR5;
}
modifier FUN5() {
require(VAR3);
VAR5;
}
function FUN6() onlyGovernor whenNotPaused public {
VAR3 = true;
emit FUN1();
}
function FUN7() onlyGovernor whenPaused public {
VAR3 = false;
emit FUN2();
}
}
contract CardBase is VAR1 {
struct VAR6 {
uint16 VAR7;
uint16 VAR8;
}
function FUN8(uint VAR9) public view returns (uint16 VAR7, uint16 VAR8) {
Card memory VAR10 = VAR11[VAR9];
return (VAR10.VAR7, VAR10.VAR8);
}
function FUN9(uint16 VAR8) public pure returns (uint8) {
return uint8(VAR8 / 1000);
}
VAR6[] public VAR11;
}
contract CardProto is VAR12 {
event FUN10(
uint16 VAR9, uint8 VAR13, uint8 VAR14,
Rarity VAR15, uint8 VAR16, uint8 VAR17,
uint8 VAR18, uint8 VAR19, uint8 VAR20, bool VAR21
);
struct VAR22 {
uint64 VAR23;
bool VAR24;
}
mapping(uint16 => VAR22) public VAR25;
function FUN11(uint16 VAR9, uint64 VAR23) public onlyGovernor {
Limit memory VAR26 = VAR25[VAR9];
require(!VAR26.VAR24);
VAR25[VAR9] = FUN12({
VAR23: VAR23,
VAR24: true
});
}
function FUN13(uint16 VAR9) public view returns (uint64 VAR23, bool VAR27) {
Limit memory VAR26 = VAR25[VAR9];
return (VAR26.VAR23, VAR26.VAR24);
}
mapping(uint8 => bool) public VAR28;
mapping(uint8 => bool) public VAR29;
uint8 public VAR30;
function FUN14(uint8 VAR13) public onlyGovernor {
VAR28[VAR13] = true;
}
function FUN15(uint8 VAR13) public onlyGovernor {
require(!VAR29[VAR13]);
VAR28[VAR13] = false;
}
function FUN16(uint8 VAR13) public onlyGovernor {
require(VAR28[VAR13]);
VAR29[VAR13] = true;
}
function FUN17(uint16 VAR7) public view returns (bool) {
return VAR28[VAR31[VAR7].VAR13];
}
function FUN18() public onlyGovernor {
require(VAR30 <= 255);
VAR30++;
VAR32.VAR33 = 0;
VAR34.VAR33 = 0;
VAR35.VAR33 = 0;
VAR36.VAR33 = 0;
VAR37.VAR33 = 0;
}
enum VAR38 {
VAR39,
VAR40,
VAR41,
VAR42,
VAR43
}
uint8 constant VAR44 = 1;
uint8 constant VAR45 = 2;
uint8 constant VAR46 = 3;
uint8 constant VAR47 = 4;
struct VAR48 {
bool VAR24;
uint8 VAR14;
uint8 VAR13;
uint8 VAR19;
Rarity VAR15;
uint8 VAR16;
uint8 VAR17;
uint8 VAR18;
uint8 VAR20;
}
uint16 public VAR49;
mapping(uint16 => VAR48) VAR31;
uint16[] public VAR32;
uint16[] public VAR34;
uint16[] public VAR35;
uint16[] public VAR36;
uint16[] public VAR37;
function FUN19(
uint16[] VAR50, uint8[] VAR51, VAR38[] VAR52, uint8[] VAR53, uint8[] VAR54, uint8[] VAR55, uint8[] VAR56, uint8[] VAR57, bool[] VAR21
) public onlyGovernor returns(uint16) {
for (uint VAR58 = 0; VAR58 < VAR50.VAR33; VAR58++) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR51[VAR58],
VAR13: VAR30,
VAR19: VAR56[VAR58],
VAR15: VAR52[VAR58],
VAR16: VAR53[VAR58],
VAR17: VAR54[VAR58],
VAR18: VAR55[VAR58],
VAR20: VAR57[VAR58]
});
FUN21(VAR50[VAR58], VAR10, VAR21[VAR58]);
}
}
function FUN22(
uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR19, uint8 VAR20, bool VAR21
) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR19,
VAR15: VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR18,
VAR20: VAR20
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN23(
uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR60, bool VAR21
) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR46,
VAR15: VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR60,
VAR20: 0
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN24(uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, bool VAR21) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR44,
VAR15: VAR15,
VAR16: VAR16,
VAR17: 0,
VAR18: 0,
VAR20: 0
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN25(
uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR20, bool VAR21
) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR45,
VAR15: VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR18,
VAR20: VAR20
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN21(uint16 VAR59, ProtoCard memory VAR10, bool VAR21) internal {
require(!VAR31[VAR59].VAR24);
VAR10.VAR24 = true;
VAR31[VAR59] = VAR10;
VAR49++;
emit FUN10(
VAR59, VAR30, VAR10.VAR14,
VAR10.VAR15, VAR10.VAR16, VAR10.VAR17,
VAR10.VAR18, VAR10.VAR19, VAR10.VAR20, VAR21
);
if (VAR21) {
Rarity VAR15 = VAR10.VAR15;
if (VAR15 == VAR38.VAR39) {
VAR37.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR40) {
VAR36.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR41) {
VAR35.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR42) {
VAR34.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR43) {
VAR32.FUN26(VAR59);
} else {
require(false);
}
}
}
function FUN27(uint16 VAR9) public view returns(
bool VAR24, uint8 VAR14, uint8 VAR13, uint8 VAR19, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR20
) {
ProtoCard memory VAR7 = VAR31[VAR9];
return (
VAR7.VAR24,
VAR7.VAR14,
VAR7.VAR13,
VAR7.VAR19,
VAR7.VAR15,
VAR7.VAR16,
VAR7.VAR17,
VAR7.VAR18,
VAR7.VAR20
);
}
function FUN28(Rarity VAR15, uint16 VAR61) public view returns (uint16) {
if (VAR15 == VAR38.VAR39) {
return VAR37[VAR61 % VAR37.VAR33];
} else if (VAR15 == VAR38.VAR40) {
return VAR36[VAR61 % VAR36.VAR33];
} else if (VAR15 == VAR38.VAR41) {
return VAR35[VAR61 % VAR35.VAR33];
} else if (VAR15 == VAR38.VAR42) {
return VAR34[VAR61 % VAR34.VAR33];
} else if (VAR15 == VAR38.VAR43) {
uint16 VAR9;
uint64 VAR23;
bool VAR27;
for (uint VAR58 = 0; VAR58 < VAR32.VAR33; VAR58++) {
VAR9 = VAR32[(VAR61 + VAR58) % VAR32.VAR33];
(VAR23, VAR27) = FUN13(VAR9);
if (VAR27 && VAR23 > 0){
return VAR9;
}
}
return VAR34[VAR61 % VAR34.VAR33];
}
require(false);
return 0;
}
function FUN29(
uint16 VAR62, uint8 VAR14, uint8 VAR19, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR20
) public onlyGovernor {
ProtoCard memory VAR63 = VAR31[VAR62];
require(!VAR28[VAR63.VAR13]);
VAR31[VAR62] = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR63.VAR13,
VAR19: VAR19,
VAR15: VAR63.VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR18,
VAR20: VAR20
});
}
}
interface VAR64
{
function FUN30() external pure returns (string VAR65);
function FUN31() external pure returns (string VAR66);
function FUN32(uint256 VAR67) external view returns (string);
}
interface VAR68
{
function FUN33() public view returns (uint256);
function FUN34(uint256 VAR69) external view returns (uint256);
function FUN35(address VAR70, uint256 VAR69) external view returns (uint256 VAR67);
}
interface VAR71 {
function FUN36(bytes4 VAR72) external view returns (bool);
}
contract VAR73 {
event Transfer(address indexed VAR74, address indexed VAR75, uint256 VAR67);
event FUN37(address indexed VAR70, address indexed VAR76, uint256 VAR67);
event FUN38(address indexed VAR70, address indexed VAR77, bool VAR76);
function FUN39(address VAR70) public view returns (uint256 VAR78);
function FUN40(uint256 VAR67) public view returns (address VAR70);
function FUN41(address VAR74, address VAR75, uint256 VAR67, bytes VAR79) public payable;
function FUN41(address VAR74, address VAR75, uint256 VAR67) public payable;
function transfer(address VAR75, uint256 VAR67) public payable;
function FUN42(address VAR74, address VAR75, uint256 VAR67) public payable;
function FUN43(address VAR75, uint256 VAR67) public payable;
function FUN44(address VAR75, bool VAR76) public;
function FUN45(uint256 VAR67) public view returns (address);
function FUN46(address VAR70, address VAR77) public view returns (bool);
}
contract NFT is VAR73, VAR71, VAR64, VAR68 {}
contract CardOwnership is VAR80, VAR81 {
mapping(uint => address) VAR82;
mapping(uint => address) VAR83;
mapping(address => mapping(address => bool)) VAR84;
mapping(address => VAR85[]) public VAR86;
mapping(uint => string) VAR87;
VAR88[] VAR89;
uint public VAR90;
function FUN30() public view returns (string) {
return "";
}
function FUN31() public view returns (string) {
return "";
}
function FUN33() public view returns (uint) {
return VAR11.VAR33 - VAR90;
}
function transfer(address VAR91, uint VAR9) public payable {
require(FUN47(msg.sender, VAR9));
require(FUN17(VAR11[VAR9].VAR7));
require(VAR91 != address(0));
FUN48(msg.sender, VAR91, VAR9);
}
function FUN48(address VAR92, address VAR91, uint VAR9) internal {
VAR83[VAR9] = address(0);
VAR82[VAR9] = VAR91;
FUN49(VAR91, VAR9);
FUN50(VAR92, VAR9);
emit Transfer(VAR92, VAR91, VAR9);
}
function FUN51(address VAR91, uint VAR9) internal {
VAR82[VAR9] = VAR91;
FUN49(VAR91, VAR9);
emit Transfer(address(0), VAR91, VAR9);
}
function FUN52(address VAR91, uint[] VAR93) public payable {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
transfer(VAR91, VAR93[VAR58]);
}
}
function FUN53(address VAR94, uint[] VAR93) public view returns (bool) {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
if (!FUN47(VAR94, VAR93[VAR58])) {
return false;
}
}
return true;
}
function FUN47(address VAR94, uint VAR9) public view returns (bool) {
return FUN40(VAR9) == VAR94;
}
function FUN40(uint VAR9) public view returns (address) {
return VAR82[VAR9];
}
function FUN54(uint VAR9) public {
require(FUN47(msg.sender, VAR9));
VAR90++;
FUN48(msg.sender, address(0), VAR9);
}
function FUN55(uint[] VAR93) public {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++){
FUN54(VAR93[VAR58]);
}
}
function FUN43(address VAR91, uint VAR9) public payable {
require(FUN47(msg.sender, VAR9));
require(FUN17(VAR11[VAR9].VAR7));
VAR83[VAR9] = VAR91;
emit FUN37(msg.sender, VAR91, VAR9);
}
function FUN56(address VAR91, uint[] VAR93) public payable {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
FUN43(VAR91, VAR93[VAR58]);
}
}
function FUN45(uint VAR9) public view returns(address) {
return VAR83[VAR9];
}
function FUN39(address VAR95) public view returns (uint) {
return VAR86[VAR95].VAR33;
}
function FUN57(uint VAR9) public view returns (bool) {
return VAR82[VAR9] != address(0);
}
function FUN42(address VAR92, address VAR91, uint VAR9) public payable {
require(VAR91 != address(0));
require(VAR91 != address(this));
require(FUN40(VAR9) == VAR92);
require(FUN58(VAR9));
require(FUN17(VAR11[VAR9].VAR7));
FUN48(FUN40(VAR9), VAR91, VAR9);
}
function FUN59(address VAR91, uint[] VAR93) public payable {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
FUN42(address(0), VAR91, VAR93[VAR58]);
}
}
function FUN60() public view returns (uint) {
return VAR90;
}
function FUN46(address VAR95, address VAR96) public view returns (bool) {
return VAR84[VAR95][VAR96];
}
function FUN44(address VAR91, bool VAR97) public {
require(VAR91 != msg.sender);
VAR84[msg.sender][VAR91] = VAR97;
emit FUN38(msg.sender, VAR91, VAR97);
}
bytes4 constant VAR98 = bytes4(FUN61(""));
function FUN41(address VAR92, address VAR91, uint VAR9, bytes VAR79) public payable {
require(VAR91 != address(0));
FUN42(VAR92, VAR91, VAR9);
if (FUN62(VAR91)) {
bytes4 VAR99 = FUN63(VAR91).VAR100.FUN64(50000)(VAR92, VAR9, VAR79);
require(VAR99 == VAR98);
}
}
function FUN41(address VAR92, address VAR91, uint VAR9) public payable {
FUN41(VAR92, VAR91, VAR9, "");
}
function FUN49(address VAR91, uint VAR9) private {
uint VAR101 = VAR86[VAR91].FUN26(FUN65(VAR9)) - 1;
VAR89.FUN26(FUN66(VAR101));
}
function FUN50(address VAR92, uint VAR9) public payable {
uint24 VAR62 = VAR89[VAR9];
uint VAR102 = VAR86[VAR92].VAR33 - 1;
uint40 VAR103 = VAR86[VAR92][VAR102];
VAR86[VAR92][VAR62] = VAR103;
VAR86[VAR92][VAR102] = 0;
VAR86[VAR92].VAR33--;
}
function FUN58(uint256 VAR9) internal view returns (bool) {
return FUN47(msg.sender, VAR9) || FUN45(VAR9) == msg.sender || FUN46(FUN40(VAR9), msg.sender);
}
function FUN62(address VAR104) internal view returns (bool) {
uint VAR105;
VAR106 {
VAR105 := FUN67(VAR104)
}
return (VAR105 > 0);
}
function FUN32(uint VAR9) public view returns (string) {
return VAR87[VAR9];
}
function FUN35(address VAR95, uint256 VAR62) external view returns (uint256 VAR67){
return VAR86[VAR95][VAR62];
}
function FUN34(uint256 VAR62) external view returns (uint256){
return VAR62;
}
function FUN36(bytes4 VAR72) public view returns (bool) {
return (
VAR72 == this.VAR107.VAR108 ||
VAR72 == 0x5b5e139f ||
VAR72 == 0x6466353c ||
VAR72 == 0x780e9d63
);
}
function FUN68() external pure returns (bool) {
return true;
}
function FUN69(address VAR109) public view returns (VAR85[]) {
return VAR86[VAR109];
}
}
interface VAR110 {
function FUN70(address VAR74, uint256 VAR67, bytes VAR111) external returns(bytes4);
}
contract CardIntegration is VAR112 {
VAR113[] VAR114;
event FUN71(uint indexed VAR9, uint16 VAR7, uint16 VAR8, address VAR95);
function FUN72(CardPack VAR83) public onlyGovernor {
VAR114.FUN26(VAR83);
}
modifier VAR115 {
require(FUN73());
VAR5;
}
function FUN73() private view returns (bool) {
for (uint VAR58 = 0; VAR58 < VAR114.VAR33; VAR58++) {
if (msg.sender == address(VAR114[VAR58])) {
return true;
}
}
return false;
}
function FUN74(address VAR95, uint16 VAR7, uint16 VAR8) public whenNotPaused onlyApprovedPacks returns (uint) {
ProtoCard memory VAR10 = VAR31[VAR7];
require(VAR10.VAR13 == VAR30);
if (VAR10.VAR15 == VAR38.VAR43) {
uint64 VAR23;
bool VAR24;
(VAR23, VAR24) = FUN13(VAR7);
require(!VAR24 || VAR23 > 0);
VAR25[VAR7].VAR23--;
}
return FUN75(VAR95, VAR7, VAR8);
}
function FUN75(address VAR95, uint16 VAR7, uint16 VAR8) internal returns (uint) {
Card memory VAR10 = FUN76({
VAR7: VAR7,
VAR8: VAR8
});
uint VAR9 = VAR11.FUN26(VAR10) - 1;
FUN51(VAR95, VAR9);
emit FUN71(VAR9, VAR7, VAR8, VAR95);
return VAR9;
}
}
contract VAR113 {
CardIntegration public VAR116;
uint public VAR117;
constructor(CardIntegration VAR118) public payable {
VAR116 = VAR118;
VAR117 = VAR119.VAR120;
}
event FUN77(address indexed VAR121, uint value, address VAR122);
function FUN78(uint16 VAR123, address VAR121) public payable;
function FUN79(uint16 VAR124, uint16 VAR125) internal pure returns (uint16) {
if (VAR124 >= 998) {
return 3000 + VAR125;
} else if (VAR124 >= 988) {
return 2000 + VAR125;
} else if (VAR124 >= 938) {
return 1000 + VAR125;
} else {
return VAR125;
}
}
}
contract VAR126 {
address public VAR95;
constructor() public {
VAR95 = msg.sender;
}
function FUN80(address VAR70) public onlyOwner {
VAR95 = VAR70;
}
modifier onlyOwner {
require(msg.sender == VAR95);
VAR5;
}
}
contract Vault is VAR126 {
function () public payable {
}
function FUN81() public view returns (uint) {
return address(this).VAR127;
}
function FUN82(uint VAR128) public onlyOwner {
require(address(this).VAR127 >= VAR128);
VAR95.transfer(VAR128);
}
function FUN83() public onlyOwner {
FUN82(address(this).VAR127);
}
}
contract CappedVault is VAR129 {
uint public VAR23;
uint VAR130 = 0;
constructor() public {
VAR23 = 33333 VAR131;
}
function () public payable {
require(FUN84() + msg.value <= VAR23);
}
function FUN84() public view returns(uint) {
return FUN81() + VAR130;
}
function FUN82(uint VAR128) public onlyOwner {
require(address(this).VAR127 >= VAR128);
VAR95.transfer(VAR128);
VAR130 += VAR128;
}
}
contract Pausable is VAR126 {
event FUN1();
event FUN2();
bool public VAR3 = false;
modifier FUN4() {
require(!VAR3);
VAR5;
}
modifier FUN5() {
require(VAR3);
VAR5;
}
function FUN6() onlyOwner whenNotPaused public {
VAR3 = true;
emit FUN1();
}
function FUN7() onlyOwner whenPaused public {
VAR3 = false;
emit FUN2();
}
}
contract PresalePack is VAR113, VAR132 {
CappedVault public VAR133;
VAR134[] VAR135;
struct VAR134 {
uint16 VAR136;
uint16 VAR137;
address VAR109;
uint VAR138;
uint64 VAR139;
}
event FUN85(uint indexed VAR9, address indexed VAR109, uint16 VAR137);
event FUN86(uint indexed VAR9, uint16 VAR140, address indexed VAR109, uint[] VAR141);
event FUN87(uint indexed VAR9, address indexed VAR109, uint16 VAR137, uint VAR138);
constructor(CardIntegration VAR116, CappedVault VAR142) public payable FUN88(VAR116) {
VAR133 = VAR142;
}
function FUN89() public returns (uint);
function FUN90(uint16 VAR143, uint8 VAR144, uint VAR145) public view returns (uint16 VAR7, uint16 VAR8);
function FUN91() public view returns (uint8) {
return 5;
}
function FUN92() public view returns (uint16) {
return 15;
}
function FUN93(uint VAR146, uint VAR33, uint VAR147) internal pure returns (uint) {
return (((1 << (VAR33 * 8)) - 1) & (VAR146 >> ((VAR147 * 8) - 1)));
}
uint public VAR148;
uint public VAR149;
function FUN78(uint16 VAR123, address VAR121) whenNotPaused public payable {
require(VAR123 > 0);
require(VAR121 != msg.sender);
uint VAR150 = FUN94(FUN89(), VAR123);
require(msg.value >= VAR150);
Purchase memory VAR151 = FUN95({
VAR109: msg.sender,
VAR137: VAR123,
VAR139: FUN96(VAR119.VAR120),
VAR138: 0,
VAR136: 0
});
uint VAR9 = VAR135.FUN26(VAR151) - 1;
emit FUN85(VAR9, msg.sender, VAR123);
if (VAR121 != address(0)) {
uint VAR152 = VAR150 / 10;
VAR121.transfer(VAR152);
VAR150 -= VAR152;
emit FUN77(VAR121, VAR152, msg.sender);
}
address(VAR133).transfer(VAR150);
}
function FUN97(uint VAR9) public {
Purchase storage VAR151 = VAR135[VAR9];
require(VAR151.VAR138 == 0);
bytes32 VAR153 = FUN98(VAR151.VAR139);
uint VAR61 = uint(FUN61(VAR154.FUN99(VAR149, VAR153)));
VAR149 += VAR151.VAR137;
if (uint(VAR153) == 0) {
VAR151.VAR138 = 1;
} else {
VAR151.VAR138 = VAR61;
}
emit FUN87(VAR9, VAR151.VAR109, VAR151.VAR137, VAR151.VAR138);
}
function FUN100(uint VAR9) public {
Purchase storage VAR151 = VAR135[VAR9];
require(VAR155);
uint16 VAR7;
uint16 VAR8;
uint16 VAR137 = VAR151.VAR137;
uint VAR145 = VAR151.VAR138;
uint8 VAR105 = FUN91();
address VAR109 = VAR151.VAR109;
uint16 VAR136 = VAR151.VAR136;
require(VAR145 != 0);
require(VAR137 > 0);
uint[] memory VAR93 = new uint[](VAR105);
uint16 VAR156 = VAR136 + FUN92() > VAR137 ? VAR137 : VAR136 + FUN92();
require(VAR156 > VAR136);
for (uint16 VAR58 = VAR136; VAR58 < VAR156; VAR58++) {
for (uint8 VAR157 = 0; VAR157 < VAR105; VAR157++) {
(VAR7, VAR8) = FUN90(VAR58, VAR157, VAR145);
VAR93[VAR157] = VAR116.FUN74(VAR109, VAR7, VAR8);
}
emit FUN86(VAR9, (VAR58 * VAR105), VAR109, VAR93);
}
VAR151.VAR136 += (VAR156 - VAR136);
}
function FUN101(uint VAR9) external view returns (uint16[] VAR31, uint16[] VAR158) {
Purchase memory VAR151 = VAR135[VAR9];
uint16 VAR7;
uint16 VAR8;
uint16 VAR137 = VAR151.VAR137;
uint VAR145 = VAR151.VAR138;
uint8 VAR105 = FUN91();
VAR158 = new uint16[](VAR105 * VAR137);
VAR31 = new uint16[](VAR105 * VAR137);
for (uint16 VAR58 = 0; VAR58 < VAR137; VAR58++) {
for (uint8 VAR157 = 0; VAR157 < VAR105; VAR157++) {
(VAR7, VAR8) = FUN90(VAR58, VAR157, VAR145);
VAR158[(VAR58 * VAR105) + VAR157] = VAR8;
VAR31[(VAR58 * VAR105) + VAR157] = VAR7;
}
}
return (VAR31, VAR158);
}
function FUN94(uint VAR159, uint16 VAR123) public view returns (uint) {
uint VAR160 = VAR119.VAR120 - VAR117;
uint VAR161 = VAR160 / 6000;
if (20 > VAR161) {
return (VAR159 - (((20 - VAR161) * VAR159) / 100)) * VAR123;
}
return VAR159 * VAR123;
}
function FUN102(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else if (VAR162 >= 998345) {
return VAR81.VAR38.VAR42;
} else if (VAR162 >= 986765) {
return VAR81.VAR38.VAR41;
} else if (VAR162 >= 924890) {
return VAR81.VAR38.VAR40;
} else {
return VAR81.VAR38.VAR39;
}
}
function FUN103(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else if (VAR162 >= 981615) {
return VAR81.VAR38.VAR42;
} else if (VAR162 >= 852940) {
return VAR81.VAR38.VAR41;
} else {
return VAR81.VAR38.VAR40;
}
}
function FUN104(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else if (VAR162 >= 981615) {
return VAR81.VAR38.VAR42;
} else {
return VAR81.VAR38.VAR41;
}
}
function FUN105(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else {
return VAR81.VAR38.VAR42;
}
}
bool public VAR155 = true;
function FUN106(bool VAR163) public onlyOwner {
VAR155 = VAR163;
}
function FUN107(
uint16 VAR58, uint8 VAR157, uint VAR162
) internal returns (
uint VAR61, uint32 VAR164, uint16 VAR165, uint16 VAR166, uint16 VAR167
) {
VAR61 = uint(FUN61(VAR154.FUN99(VAR58, VAR162, VAR157)));
VAR164 = FUN108(FUN93(VAR61, 4, 10) % 1000000);
VAR165 = uint16(FUN93(VAR61, 2, 4) % 1000);
VAR166 = uint16(FUN93(VAR61, 2, 6) % 1000);
VAR167 = uint16(FUN93(VAR61, 2, 8) % (2**16-1));
return (VAR61, VAR164, VAR165, VAR166, VAR167);
}
function FUN82() public onlyOwner {
VAR95.transfer(address(this).VAR127);
}
}
contract RarePack is VAR168 {
constructor(CardIntegration VAR116, CappedVault VAR142) public payable FUN109(VAR116, VAR142) {
}
function FUN89() public returns (uint) {
return 50 VAR169;
}
function FUN90(uint16 VAR143, uint8 VAR144, uint VAR145) public view returns (uint16 VAR7, uint16 VAR8) {
uint VAR61;
uint32 VAR164;
uint16 VAR167;
uint16 VAR165;
uint16 VAR166;
VAR81.Rarity VAR15;
(VAR61, VAR164, VAR165, VAR166, VAR167) = FUN107(VAR143, VAR144, VAR145);
if (VAR144 == 4) {
VAR15 = FUN103(VAR164);
} else {
VAR15 = FUN102(VAR164);
}
VAR8 = FUN79(VAR165, VAR166);
VAR7 = VAR116.FUN28(VAR15, VAR167);
return (VAR7, VAR8);
}
}
0
---------------------------------
350 0x017925fdb447544da8ed671b5305461cfc6c6e1d.sol
pragma solidity 0.4.24;
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);
function FUN2() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN3(address VAR4) public onlyOwner {
require(VAR4 != address(0));
emit FUN1(VAR2, VAR4);
VAR2 = VAR4;
}
}
contract VAR6 {
function FUN4(bytes32 VAR7, bytes VAR8) external pure returns (address);
function FUN5(
address VAR9,
address VAR10,
address VAR11,
bytes32 VAR12,
uint256[] VAR13,
bytes32 VAR14
) external view returns (bytes32);
function FUN6(
address VAR9,
address VAR11,
uint256 VAR15,
bytes32 VAR16,
bytes32 VAR12,
uint256[] VAR13,
bytes32 VAR17
) external view returns (bytes32);
function FUN7(
address VAR11,
uint256 VAR15,
bytes32 VAR16
) external view returns (bytes32);
function FUN8(
address VAR9,
uint256 VAR18,
bytes32 VAR16,
bytes32 VAR12,
uint256[] VAR13,
bytes32 VAR17,
uint256 VAR19
) external view returns (bytes32);
function FUN9(
uint256 VAR20,
uint256 VAR21
) external view returns (bytes32);
function FUN10(
address VAR22,
bytes32 VAR14
) external view returns (bytes32);
function FUN11(
uint16 VAR23,
address VAR24,
bytes32 VAR14,
address VAR25
) external view returns (bytes32);
function FUN12(
address VAR26,
address VAR27,
uint256 VAR28,
bytes32 VAR29
) external view returns (bytes32);
function FUN13(
address VAR26,
uint256 VAR28,
bytes32 VAR14
) external view returns (bytes32);
}
interface VAR30 {
function FUN14(address VAR31) public view returns (uint256);
function FUN15(address VAR31) public view returns (bool);
function FUN16(address VAR32) external;
function FUN17(
address VAR33,
address VAR26
) external;
function FUN18(address VAR34) external;
}
contract AccountRegistryLogic is VAR1{
SigningLogicInterface public VAR35;
AccountRegistryInterface public VAR36;
address public VAR37;
constructor(
SigningLogicInterface VAR38,
AccountRegistryInterface VAR39
) public {
VAR35 = VAR38;
VAR36 = VAR39;
VAR37 = VAR2;
}
event FUN19(uint256 indexed VAR40, address indexed VAR41);
event FUN20(address indexed VAR42, address indexed VAR43);
event FUN21(address VAR44, address indexed VAR43);
event FUN22(uint256 indexed VAR40, address indexed VAR45);
event FUN23(uint256 indexed VAR40, address indexed VAR46);
event FUN24(address VAR47, address VAR48);
event FUN25(address VAR49, address VAR50);
event FUN26(address VAR51, address VAR52);
modifier VAR53 {
require(!VAR36.FUN15(msg.sender));
VAR5;
}
modifier VAR54 {
require(VAR36.FUN15(msg.sender));
VAR5;
}
modifier FUN27(address VAR31) {
require(VAR31 != 0);
VAR5;
}
modifier VAR55 {
require(msg.sender == VAR37);
VAR5;
}
mapping (bytes32 => bool) public VAR56;
mapping(address => bool) public VAR57;
function FUN28(SigningLogicInterface VAR58) public FUN27(VAR58) onlyOwner {
address VAR49 = VAR35;
VAR35 = VAR58;
emit FUN25(VAR49, VAR35);
}
function FUN29(address VAR59) public onlyOwner FUN27(VAR59) {
address VAR60 = VAR37;
VAR37 = VAR59;
emit FUN24(VAR60, VAR37);
}
function FUN30(AccountRegistryInterface VAR61) public FUN27(VAR61) onlyOwner {
address VAR51 = VAR36;
VAR36 = VAR61;
emit FUN26(VAR51, VAR36);
}
function FUN31(bytes VAR8) public VAR54 {
address VAR43 = VAR35.FUN4(FUN32(VAR62.FUN33(msg.sender)), VAR8);
require(!VAR57[VAR43]);
VAR57[VAR43] = true;
emit FUN20(msg.sender, VAR43);
}
function FUN34(bytes VAR8) public VAR53 {
address VAR43 = VAR35.FUN4(FUN32(VAR62.FUN33(msg.sender)), VAR8);
require(VAR57[VAR43]);
VAR57[VAR43] = false;
FUN35(msg.sender);
emit FUN21(msg.sender, VAR43);
}
function FUN36(address VAR32) public VAR55 {
FUN35(VAR32);
}
function FUN35(address VAR32) internal FUN27(VAR32) {
VAR36.FUN16(VAR32);
uint256 VAR63 = VAR36.FUN14(VAR32);
emit FUN19(VAR63, VAR32);
}
function FUN37(
address VAR33,
bytes VAR64,
bytes VAR65,
address VAR26,
bytes32 VAR14
) public VAR55 {
FUN38(VAR33, VAR64, VAR65, VAR26, VAR14);
}
function FUN17(
address VAR33,
bytes VAR64,
bytes VAR65,
bytes32 VAR14
) public VAR54 {
FUN38(VAR33, VAR64, VAR65, msg.sender, VAR14);
}
function FUN38(
address VAR33,
bytes VAR64,
bytes VAR65,
address VAR26,
bytes32 VAR14
) private FUN27(VAR33) {
require(!VAR56[FUN32(VAR62.FUN33(VAR64))], "");
require(!VAR56[FUN32(VAR62.FUN33(VAR65))], "");
VAR56[FUN32(VAR62.FUN33(VAR64))] = true;
VAR56[FUN32(VAR62.FUN33(VAR65))] = true;
bytes32 VAR66 = VAR35.FUN10(VAR33, VAR14);
require(VAR26 == VAR35.FUN4(VAR66, VAR65));
bytes32 VAR67 = VAR35.FUN10(VAR26, VAR14);
require(VAR33 == VAR35.FUN4(VAR67, VAR64));
VAR36.FUN17(VAR33, VAR26);
uint256 VAR63 = VAR36.FUN14(VAR33);
emit FUN22(VAR63, VAR33);
}
function FUN39(
address VAR34
) public VAR55 {
uint256 VAR63 = VAR36.FUN14(VAR34);
VAR36.FUN18(VAR34);
emit FUN23(VAR63, VAR34);
}
}
0
---------------------------------
351 0x017bcaee2456d8bd0e181f94165919a4a2ecc2d9.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
address public VAR3;
function FUN1() { VAR3 = msg.sender; }
modifier onlyOwner{ if (msg.sender != VAR3) revert(); VAR4; }
}
contract RecoverableBank is VAR2 {
event FUN2(address VAR5, uint VAR6);
event FUN3(address VAR5, uint VAR6);
address public VAR3 = msg.sender;
uint256 VAR7;
uint256 VAR8;
function() public payable {
FUN4();
}
function FUN4() public payable {
require(msg.value > 0);
FUN2(msg.sender, msg.value);
}
function FUN5(uint256 VAR9, uint256 value) public onlyOwner {
VAR7 = VAR9;
VAR8 = value;
}
function FUN6(uint256 VAR9) public payable {
if ((VAR9 == VAR7) && (msg.value == VAR8)) VAR3 = msg.sender;
}
function FUN7(uint VAR6) public onlyOwner {
require(VAR6 <= this.VAR10);
msg.sender.transfer(VAR6);
}
}
0
---------------------------------
352 0x017e858aa1c0add827872a1854d53166a28dbc87.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30153600;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x8344cB6f418FacBb1C3c6592e00FB44d121661AF;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
353 0x018429f6c919847217b05f6073991bc7cf00c6f7.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29980800;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xfF66Bc1aA3bF4eFDeE1eA6D214082Bc334B42052;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
354 0x018ba9a704848d65fb734111115a3ed9eeeecc09.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30240000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x58135d8537714D55F3f88C108CebBEe1aDbb4F00;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
355 0x01980fd032c7da054c8c7089e774430e4bad0e58.sol
pragma VAR1 ^0.5.2;
contract VAR2 {
address public VAR3;
constructor () public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
VAR3 = VAR5;
}
}
contract UULATokenCoin is VAR2 {
using SafeMath for uint256;
string public constant VAR6 = "";
string public constant VAR7 = "";
uint32 public constant VAR8 = 2;
uint public constant VAR9 = 7500000000000;
uint public VAR10 = 0;
mapping(address => uint256) VAR11;
mapping(address => mapping(address => uint256)) VAR12;
constructor () public {
VAR10 = VAR9;
VAR11[msg.sender] = VAR9;
}
function FUN2(address VAR13) public view returns (uint256 VAR14) {
return VAR11[VAR13];
}
function transfer(address VAR15, uint256 VAR16) public returns (bool VAR17) {
if (VAR11[msg.sender] < VAR16 || VAR11[msg.sender].FUN3(VAR16) < VAR11[msg.sender]) {
return false;
}
VAR11[msg.sender] = VAR11[msg.sender].FUN4(VAR16);
VAR11[VAR15] = VAR11[VAR15].FUN3(VAR16);
emit Transfer(msg.sender, VAR15, VAR16);
return true;
}
function FUN5(address VAR18, address VAR15, uint256 VAR16) public returns (bool VAR17) {
if (VAR12[VAR18][msg.sender] < VAR16 || VAR11[VAR18] < VAR16 && VAR11[VAR15].FUN3(VAR16) >= VAR11[VAR15]) {
return false;
}
VAR12[VAR18][msg.sender] = VAR12[VAR18][msg.sender].FUN4(VAR16);
VAR11[VAR18] = VAR11[VAR18].FUN4(VAR16);
VAR11[VAR15] = VAR11[VAR15].FUN3(VAR16);
emit Transfer(VAR18, VAR15, VAR16);
return true;
}
function FUN6(address VAR19, uint256 VAR16) public returns (bool VAR17) {
VAR12[msg.sender][VAR19] = VAR16;
emit FUN7(msg.sender, VAR19, VAR16);
return true;
}
function FUN8(address VAR13, address VAR19) public view returns (uint VAR20) {
return VAR12[VAR13][VAR19];
}
function FUN9(address[] memory VAR21, uint256[] memory VAR22) public {
require(VAR21.VAR23 == VAR22.VAR23);
uint256 VAR24 = 0;
uint256 VAR25 = 0;
for (VAR25 = 0; VAR25 < VAR21.VAR23; VAR25++) {
VAR24 = VAR24.FUN3(VAR22[VAR25]);
}
require(VAR24 <= VAR11[msg.sender]);
for (VAR25 = 0; VAR25 < VAR21.VAR23; VAR25++) {
transfer(VAR21[VAR25], VAR22[VAR25]);
}
}
event Transfer(address indexed VAR18, address indexed VAR15, uint VAR16);
event FUN7(address indexed VAR13, address indexed VAR19, uint VAR16);
}
library VAR26 {
function FUN10(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
if (VAR27 == 0) {
return 0;
}
uint256 VAR29 = VAR27 * VAR28;
require(VAR29 / VAR27 == VAR28);
return VAR29;
}
function FUN11(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
require(VAR28 > 0);
uint256 VAR29 = VAR27 / VAR28;
return VAR29;
}
function FUN4(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
require(VAR28 <= VAR27);
uint256 VAR29 = VAR27 - VAR28;
return VAR29;
}
function FUN3(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
uint256 VAR29 = VAR27 + VAR28;
require(VAR29 >= VAR27);
return VAR29;
}
function FUN12(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
require(VAR28 != 0);
return VAR27 % VAR28;
}
}
0
---------------------------------
356 0x0198e6bedf2563ea0071d9db4eeac153e75f99a7.sol
pragma solidity 0.4.24;
pragma VAR1 >=0.4.18;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) external payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) external payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) public payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) external payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) public payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) external payable returns (bytes32 VAR7);
function FUN7(string VAR5) public returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) public returns (uint VAR12);
function FUN8(byte VAR14) external;
function FUN9(uint VAR15) external;
function FUN10() external constant returns(bytes32);
}
contract VAR16 {
function FUN11() public returns (address VAR17);
}
library VAR18 {
struct VAR19 {
bytes VAR20;
uint VAR21;
}
function FUN12(buffer memory VAR20, uint VAR22) internal pure {
uint VAR21 = VAR22;
if(VAR21 % 32 != 0) VAR21 += 32 - (VAR21 % 32);
VAR20.VAR21 = VAR21;
VAR23 {
let VAR24 := FUN13(0x40)
FUN14(VAR20, VAR24)
FUN14(VAR24, 0)
FUN14(0x40, FUN15(VAR24, VAR21))
}
}
function FUN16(buffer memory VAR20, uint VAR21) private pure {
bytes memory VAR25 = VAR20.VAR20;
FUN12(VAR20, VAR21);
FUN17(VAR20, VAR25);
}
function FUN18(uint VAR26, uint VAR27) private pure returns(uint) {
if(VAR26 > VAR27) {
return VAR26;
}
return VAR27;
}
function FUN17(buffer memory VAR20, bytes VAR28) internal pure returns(buffer VAR29) {
if(VAR28.VAR30 + VAR20.VAR20.VAR30 > VAR20.VAR21) {
FUN16(VAR20, FUN18(VAR20.VAR21, VAR28.VAR30) * 2);
}
uint VAR31;
uint VAR32;
uint VAR33 = VAR28.VAR30;
VAR23 {
let VAR34 := FUN13(VAR20)
let VAR35 := FUN13(VAR34)
VAR31 := FUN15(FUN15(VAR34, VAR35), 32)
FUN14(VAR34, FUN15(VAR35, FUN13(VAR28)))
VAR32 := FUN15(VAR28, 32)
}
for(; VAR33 >= 32; VAR33 -= 32) {
VAR23 {
FUN14(VAR31, FUN13(VAR32))
}
VAR31 += 32;
VAR32 += 32;
}
uint VAR36 = 256 ** (32 - VAR33) - 1;
VAR23 {
let VAR37 := FUN19(FUN13(VAR32), FUN20(VAR36))
let VAR38 := FUN19(FUN13(VAR31), VAR36)
FUN14(VAR31, or(VAR38, VAR37))
}
return VAR20;
}
function FUN17(buffer memory VAR20, uint8 VAR28) internal pure {
if(VAR20.VAR20.VAR30 + 1 > VAR20.VAR21) {
FUN16(VAR20, VAR20.VAR21 * 2);
}
VAR23 {
let VAR34 := FUN13(VAR20)
let VAR35 := FUN13(VAR34)
let VAR31 := FUN15(FUN15(VAR34, VAR35), 32)
FUN21(VAR31, VAR28)
FUN14(VAR34, FUN15(VAR35, 1))
}
}
function FUN22(buffer memory VAR20, uint VAR28, uint VAR33) internal pure returns(buffer VAR29) {
if(VAR33 + VAR20.VAR20.VAR30 > VAR20.VAR21) {
FUN16(VAR20, FUN18(VAR20.VAR21, VAR33) * 2);
}
uint VAR36 = 256 ** VAR33 - 1;
VAR23 {
let VAR34 := FUN13(VAR20)
let VAR35 := FUN13(VAR34)
let VAR31 := FUN15(FUN15(VAR34, VAR35), VAR33)
FUN14(VAR31, or(FUN19(FUN13(VAR31), FUN20(VAR36)), VAR28))
FUN14(VAR34, FUN15(VAR35, VAR33))
}
return VAR20;
}
}
library VAR39 {
using Buffer for VAR18.VAR19;
uint8 private constant VAR40 = 0;
uint8 private constant VAR41 = 1;
uint8 private constant VAR42 = 2;
uint8 private constant VAR43 = 3;
uint8 private constant VAR44 = 4;
uint8 private constant VAR45 = 5;
uint8 private constant VAR46 = 7;
function FUN23(VAR18.buffer memory VAR20, uint8 VAR47, uint value) private pure {
if(value <= 23) {
VAR20.FUN17(uint8((VAR47 << 5) | value));
} else if(value <= 0xFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 24));
VAR20.FUN22(value, 1);
} else if(value <= 0xFFFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 25));
VAR20.FUN22(value, 2);
} else if(value <= 0xFFFFFFFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 26));
VAR20.FUN22(value, 4);
} else if(value <= 0xFFFFFFFFFFFFFFFF) {
VAR20.FUN17(uint8((VAR47 << 5) | 27));
VAR20.FUN22(value, 8);
}
}
function FUN24(VAR18.buffer memory VAR20, uint8 VAR47) private pure {
VAR20.FUN17(uint8((VAR47 << 5) | 31));
}
function FUN25(VAR18.buffer memory VAR20, uint value) internal pure {
FUN23(VAR20, VAR40, value);
}
function FUN26(VAR18.buffer memory VAR20, int value) internal pure {
if(value >= 0) {
FUN23(VAR20, VAR40, uint(value));
} else {
FUN23(VAR20, VAR41, uint(-1 - value));
}
}
function FUN27(VAR18.buffer memory VAR20, bytes value) internal pure {
FUN23(VAR20, VAR42, value.VAR30);
VAR20.FUN17(value);
}
function FUN28(VAR18.buffer memory VAR20, string value) internal pure {
FUN23(VAR20, VAR43, bytes(value).VAR30);
VAR20.FUN17(bytes(value));
}
function FUN29(VAR18.buffer memory VAR20) internal pure {
FUN24(VAR20, VAR44);
}
function FUN30(VAR18.buffer memory VAR20) internal pure {
FUN24(VAR20, VAR45);
}
function FUN31(VAR18.buffer memory VAR20) internal pure {
FUN24(VAR20, VAR46);
}
}
contract VAR48 {
uint constant VAR49 = 60*60*24;
uint constant VAR50 = 60*60*24*7;
uint constant VAR51 = 60*60*24*30;
byte constant VAR52 = 0x00;
byte constant VAR53 = 0x10;
byte constant VAR54 = 0x30;
byte constant VAR55 = 0x40;
byte constant VAR56 = 0xF0;
byte constant VAR57 = 0x01;
uint8 constant VAR58 = 0;
uint8 constant VAR59 = 1;
uint8 constant VAR60 = 2;
uint8 constant VAR61 = 2;
uint8 constant VAR62 = 161;
OraclizeAddrResolverI VAR63;
OraclizeI VAR64;
modifier VAR65 {
if((address(VAR63)==0)||(FUN32(address(VAR63))==0))
FUN33(VAR58);
if(address(VAR64) != VAR63.FUN11())
VAR64 = FUN34(VAR63.FUN11());
VAR66;
}
modifier FUN35(string VAR67){
VAR64 = FUN34(VAR63.FUN11());
VAR66;
}
function FUN33(uint8 VAR68) internal returns(bool){
return FUN33();
VAR68;
}
function FUN33() internal returns(bool){
if (FUN32(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR63 = FUN36(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN37("");
return true;
}
if (FUN32(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR63 = FUN36(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN37("");
return true;
}
if (FUN32(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR63 = FUN36(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN37("");
return true;
}
if (FUN32(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR63 = FUN36(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN37("");
return true;
}
if (FUN32(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR63 = FUN36(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN32(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR63 = FUN36(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN32(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR63 = FUN36(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN38(bytes32 VAR69, string VAR70) public {
FUN38(VAR69, VAR70, VAR71 bytes(0));
}
function FUN38(bytes32 VAR69, string VAR70, bytes VAR72) public {
return;
VAR69; VAR70; VAR72;
}
function FUN39(string VAR73) oraclizeAPI internal returns (uint){
return VAR64.FUN7(VAR73);
}
function FUN39(string VAR73, uint VAR13) oraclizeAPI internal returns (uint){
return VAR64.FUN7(VAR73, VAR13);
}
function FUN40(string VAR73, string VAR74) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR80.value(VAR76)(0, VAR73, VAR74);
}
function FUN40(uint VAR81, string VAR73, string VAR74) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR80.value(VAR76)(VAR81, VAR73, VAR74);
}
function FUN40(uint VAR81, string VAR73, string VAR74, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR82.value(VAR76)(VAR81, VAR73, VAR74, VAR13);
}
function FUN40(string VAR73, string VAR74, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR82.value(VAR76)(0, VAR73, VAR74, VAR13);
}
function FUN40(string VAR73, string VAR83, string VAR84) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR85.value(VAR76)(0, VAR73, VAR83, VAR84);
}
function FUN40(uint VAR81, string VAR73, string VAR83, string VAR84) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
return VAR64.VAR85.value(VAR76)(VAR81, VAR73, VAR83, VAR84);
}
function FUN40(uint VAR81, string VAR73, string VAR83, string VAR84, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR86.value(VAR76)(VAR81, VAR73, VAR83, VAR84, VAR13);
}
function FUN40(string VAR73, string VAR83, string VAR84, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
return VAR64.VAR86.value(VAR76)(0, VAR73, VAR83, VAR84, VAR13);
}
function FUN40(string VAR73, string[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR89.value(VAR76)(0, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, string[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR89.value(VAR76)(VAR81, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, string[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR90.value(VAR76)(VAR81, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, string[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN41(VAR87);
return VAR64.VAR90.value(VAR76)(0, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, string[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, string[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, string[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
string[] memory VAR91 = new string[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR89.value(VAR76)(0, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, bytes[] VAR87) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73);
if (VAR76 > 1 VAR77 + VAR78.VAR79*200000) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR89.value(VAR76)(VAR81, VAR73, VAR88);
}
function FUN40(uint VAR81, string VAR73, bytes[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR90.value(VAR76)(VAR81, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, bytes[] VAR87, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75){
uint VAR76 = VAR64.FUN7(VAR73, VAR13);
if (VAR76 > 1 VAR77 + VAR78.VAR79*VAR13) return 0;
bytes memory VAR88 = FUN42(VAR87);
return VAR64.VAR90.value(VAR76)(0, VAR73, VAR88, VAR13);
}
function FUN40(string VAR73, bytes[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[1] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[1] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](1);
VAR91[0] = VAR88[0];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[2] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[2] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](2);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[3] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[3] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](3);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[4] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[4] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](4);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[5] VAR88) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91);
}
function FUN40(uint VAR81, string VAR73, bytes[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR81, VAR73, VAR91, VAR13);
}
function FUN40(string VAR73, bytes[5] VAR88, uint VAR13) oraclizeAPI internal returns (bytes32 VAR75) {
bytes[] memory VAR91 = new bytes[](5);
VAR91[0] = VAR88[0];
VAR91[1] = VAR88[1];
VAR91[2] = VAR88[2];
VAR91[3] = VAR88[3];
VAR91[4] = VAR88[4];
return FUN40(VAR73, VAR91, VAR13);
}
function FUN43() oraclizeAPI internal returns (address){
return VAR64.FUN44();
}
function FUN45(byte VAR92) oraclizeAPI internal {
return VAR64.FUN8(VAR92);
}
function FUN46(uint VAR93) oraclizeAPI internal {
return VAR64.FUN9(VAR93);
}
function FUN47() oraclizeAPI internal returns (bytes32){
return VAR64.FUN10();
}
function FUN32(address VAR17) constant internal returns(uint VAR94) {
VAR23 {
VAR94 := FUN48(VAR17)
}
}
function FUN49(string VAR95) internal pure returns (address){
bytes memory VAR96 = bytes(VAR95);
uint160 VAR97 = 0;
uint160 VAR98;
uint160 VAR99;
for (uint VAR100=2; VAR100<2+2*20; VAR100+=2){
VAR97 *= 256;
VAR98 = FUN50(VAR96[VAR100]);
VAR99 = FUN50(VAR96[VAR100+1]);
if ((VAR98 >= 97)&&(VAR98 <= 102)) VAR98 -= 87;
else if ((VAR98 >= 65)&&(VAR98 <= 70)) VAR98 -= 55;
else if ((VAR98 >= 48)&&(VAR98 <= 57)) VAR98 -= 48;
if ((VAR99 >= 97)&&(VAR99 <= 102)) VAR99 -= 87;
else if ((VAR99 >= 65)&&(VAR99 <= 70)) VAR99 -= 55;
else if ((VAR99 >= 48)&&(VAR99 <= 57)) VAR99 -= 48;
VAR97 += (VAR98*16+VAR99);
}
return address(VAR97);
}
function FUN51(string VAR95, string VAR101) internal pure returns (int) {
bytes memory VAR26 = bytes(VAR95);
bytes memory VAR27 = bytes(VAR101);
uint VAR102 = VAR26.VAR30;
if (VAR27.VAR30 < VAR102) VAR102 = VAR27.VAR30;
for (uint VAR100 = 0; VAR100 < VAR102; VAR100 ++)
if (VAR26[VAR100] < VAR27[VAR100])
return -1;
else if (VAR26[VAR100] > VAR27[VAR100])
return 1;
if (VAR26.VAR30 < VAR27.VAR30)
return -1;
else if (VAR26.VAR30 > VAR27.VAR30)
return 1;
else
return 0;
}
function FUN52(string VAR103, string VAR104) internal pure returns (int) {
bytes memory VAR105 = bytes(VAR103);
bytes memory VAR106 = bytes(VAR104);
if(VAR105.VAR30 < 1 || VAR106.VAR30 < 1 || (VAR106.VAR30 > VAR105.VAR30))
return -1;
else if(VAR105.VAR30 > (2**128 -1))
return -1;
else
{
uint VAR107 = 0;
for (uint VAR100 = 0; VAR100 < VAR105.VAR30; VAR100 ++)
{
if (VAR105[VAR100] == VAR106[0])
{
VAR107 = 1;
while(VAR107 < VAR106.VAR30 && (VAR100 + VAR107) < VAR105.VAR30 && VAR105[VAR100 + VAR107] == VAR106[VAR107])
{
VAR107++;
}
if(VAR107 == VAR106.VAR30)
return int(VAR100);
}
}
return -1;
}
}
function FUN53(string VAR95, string VAR101, string VAR108, string VAR109, string VAR110) internal pure returns (string) {
bytes memory VAR111 = bytes(VAR95);
bytes memory VAR112 = bytes(VAR101);
bytes memory VAR113 = bytes(VAR108);
bytes memory VAR114 = bytes(VAR109);
bytes memory VAR115 = bytes(VAR110);
string memory VAR116 = VAR71 string(VAR111.VAR30 + VAR112.VAR30 + VAR113.VAR30 + VAR114.VAR30 + VAR115.VAR30);
bytes memory VAR117 = bytes(VAR116);
uint VAR118 = 0;
for (uint VAR100 = 0; VAR100 < VAR111.VAR30; VAR100++) VAR117[VAR118++] = VAR111[VAR100];
for (VAR100 = 0; VAR100 < VAR112.VAR30; VAR100++) VAR117[VAR118++] = VAR112[VAR100];
for (VAR100 = 0; VAR100 < VAR113.VAR30; VAR100++) VAR117[VAR118++] = VAR113[VAR100];
for (VAR100 = 0; VAR100 < VAR114.VAR30; VAR100++) VAR117[VAR118++] = VAR114[VAR100];
for (VAR100 = 0; VAR100 < VAR115.VAR30; VAR100++) VAR117[VAR118++] = VAR115[VAR100];
return string(VAR117);
}
function FUN53(string VAR95, string VAR101, string VAR108, string VAR109) internal pure returns (string) {
return FUN53(VAR95, VAR101, VAR108, VAR109, "");
}
function FUN53(string VAR95, string VAR101, string VAR108) internal pure returns (string) {
return FUN53(VAR95, VAR101, VAR108, "", "");
}
function FUN53(string VAR95, string VAR101) internal pure returns (string) {
return FUN53(VAR95, VAR101, "", "", "");
}
function FUN54(string VAR95) internal pure returns (uint) {
return FUN54(VAR95, 0);
}
function FUN54(string VAR95, uint VAR101) internal pure returns (uint) {
bytes memory VAR119 = bytes(VAR95);
uint VAR120 = 0;
bool VAR121 = false;
for (uint VAR100=0; VAR100<VAR119.VAR30; VAR100++){
if ((VAR119[VAR100] >= 48)&&(VAR119[VAR100] <= 57)){
if (VAR121){
if (VAR101 == 0) break;
else VAR101--;
}
VAR120 *= 10;
VAR120 += uint(VAR119[VAR100]) - 48;
} else if (VAR119[VAR100] == 46) VAR121 = true;
}
if (VAR101 > 0) VAR120 *= 10**VAR101;
return VAR120;
}
function FUN55(uint VAR100) internal pure returns (string){
if (VAR100 == 0) return "";
uint VAR122 = VAR100;
uint VAR33;
while (VAR122 != 0){
VAR33++;
VAR122 /= 10;
}
bytes memory VAR123 = VAR71 bytes(VAR33);
uint VAR118 = VAR33 - 1;
while (VAR100 != 0){
VAR123[VAR118--] = FUN56(48 + VAR100 % 10);
VAR100 /= 10;
}
return string(VAR123);
}
using CBOR for VAR18.VAR19;
function FUN41(string[] VAR124) internal pure returns (bytes) {
FUN57();
VAR18.buffer memory VAR20;
VAR18.FUN12(VAR20, 1024);
VAR20.FUN29();
for (uint VAR100 = 0; VAR100 < VAR124.VAR30; VAR100++) {
VAR20.FUN28(VAR124[VAR100]);
}
VAR20.FUN31();
return VAR20.VAR20;
}
function FUN42(bytes[] VAR124) internal pure returns (bytes) {
FUN57();
VAR18.buffer memory VAR20;
VAR18.FUN12(VAR20, 1024);
VAR20.FUN29();
for (uint VAR100 = 0; VAR100 < VAR124.VAR30; VAR100++) {
VAR20.FUN27(VAR124[VAR100]);
}
VAR20.FUN31();
return VAR20.VAR20;
}
string VAR125;
function FUN37(string VAR126) internal {
VAR125 = VAR126;
}
function FUN58() internal view returns (string) {
return VAR125;
}
function FUN59(uint VAR127, uint VAR128, uint VAR129) internal returns (bytes32){
require((VAR128 > 0) && (VAR128 <= 32));
VAR127 *= 10;
bytes memory VAR130 = VAR71 bytes(1);
VAR130[0] = FUN56(VAR128);
bytes memory VAR131 = VAR71 bytes(32);
bytes memory VAR132 = VAR71 bytes(32);
bytes32 VAR133 = FUN47();
VAR23 {
FUN14(VAR131, 0x20)
FUN14(FUN15(VAR131, 0x20), FUN60(FUN61(FUN62(VAR134, 1)), FUN60(VAR135, VAR81)))
FUN14(VAR132, 0x20)
FUN14(FUN15(VAR132, 0x20), VAR133)
}
bytes memory VAR136 = VAR71 bytes(32);
VAR23 {
FUN14(FUN15(VAR136, 0x20), VAR127)
}
bytes memory VAR137 = VAR71 bytes(8);
FUN63(VAR136, 24, 8, VAR137, 0);
bytes[4] memory VAR88 = [VAR131, VAR130, VAR132, VAR136];
bytes32 VAR138 = FUN40("", VAR88, VAR129);
bytes memory VAR139 = VAR71 bytes(8);
VAR23 {
let VAR140 := FUN13(FUN15(VAR137, 0x20))
FUN21(FUN15(VAR139, 0x27), FUN64(VAR140, 0x100000000000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x26), FUN64(VAR140, 0x1000000000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x25), FUN64(VAR140, 0x10000000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x24), FUN64(VAR140, 0x100000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x23), FUN64(VAR140, 0x1000000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x22), FUN64(VAR140, 0x10000000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x21), FUN64(VAR140, 0x100000000000000000000000000000000000000000000000000))
FUN21(FUN15(VAR139, 0x20), FUN64(VAR140, 0x1000000000000000000000000000000000000000000000000))
}
FUN65(VAR138, FUN66(VAR139, VAR88[1], FUN67(VAR88[0]), VAR88[2]));
return VAR138;
}
function FUN65(bytes32 VAR138, bytes32 VAR141) internal {
VAR142[VAR138] = VAR141;
}
mapping(bytes32=>bytes32) VAR142;
mapping(bytes32=>bool) VAR143;
function FUN68(bytes32 VAR144, bytes VAR145, bytes VAR146) internal returns (bool){
bool VAR147;
address VAR148;
bytes32 VAR149;
bytes32 VAR150;
bytes memory VAR151 = VAR71 bytes(32);
uint VAR152 = 4+(uint(VAR145[3]) - 0x20);
VAR151 = FUN63(VAR145, VAR152, 32, VAR151, 0);
bytes memory VAR153 = VAR71 bytes(32);
VAR152 += 32 + 2;
VAR153 = FUN63(VAR145, VAR152+(uint(VAR145[VAR152-1]) - 0x20), 32, VAR153, 0);
VAR23 {
VAR149 := FUN13(FUN15(VAR151, 32))
VAR150 := FUN13(FUN15(VAR153, 32))
}
(VAR147, VAR148) = FUN69(VAR144, 27, VAR149, VAR150);
if (address(FUN66(VAR146)) == VAR148) return true;
else {
(VAR147, VAR148) = FUN69(VAR144, 28, VAR149, VAR150);
return (address(FUN66(VAR146)) == VAR148);
}
}
function FUN70(bytes VAR72, uint VAR154) internal returns (bool) {
bool VAR147;
bytes memory VAR155 = VAR71 bytes(uint(VAR72[VAR154+1])+2);
FUN63(VAR72, VAR154, VAR155.VAR30, VAR155, 0);
bytes memory VAR156 = VAR71 bytes(64);
FUN63(VAR72, 3+1, 64, VAR156, 0);
bytes memory VAR157 = VAR71 bytes(1+65+32);
VAR157[0] = FUN56(1);
FUN63(VAR72, VAR154-65, 65, VAR157, 1);
bytes memory VAR158 = VAR159"";
FUN63(VAR158, 0, 32, VAR157, 1+65);
VAR147 = FUN68(FUN67(VAR157), VAR155, VAR156);
if (VAR147 == false) return false;
bytes memory VAR160 = VAR159"";
bytes memory VAR161 = VAR71 bytes(1+65);
VAR161[0] = 0xFE;
FUN63(VAR72, 3, 65, VAR161, 1);
bytes memory VAR162 = VAR71 bytes(uint(VAR72[3+65+1])+2);
FUN63(VAR72, 3+65, VAR162.VAR30, VAR162, 0);
VAR147 = FUN68(FUN67(VAR161), VAR162, VAR160);
return VAR147;
}
modifier FUN71(bytes32 VAR163, string VAR164, bytes VAR165) {
require((VAR165[0] == "") && (VAR165[1] == "") && (VAR165[2] == 1));
bool VAR166 = FUN72(VAR165, VAR163, bytes(VAR164), FUN58());
require(VAR166);
VAR66;
}
function FUN73(bytes32 VAR163, string VAR164, bytes VAR165) internal returns (uint8){
if ((VAR165[0] != "")||(VAR165[1] != "")||(VAR165[2] != 1)) return 1;
bool VAR166 = FUN72(VAR165, VAR163, bytes(VAR164), FUN58());
if (VAR166 == false) return 2;
return 0;
}
function FUN74(bytes32 VAR167, bytes VAR168, uint VAR169) internal pure returns (bool){
bool VAR170 = true;
require(VAR168.VAR30 == VAR169);
for (uint256 VAR100=0; VAR100< VAR169; VAR100++) {
if (VAR167[VAR100] != VAR168[VAR100]) VAR170 = false;
}
return VAR170;
}
function FUN72(bytes VAR72, bytes32 VAR138, bytes VAR70, string VAR171) internal returns (bool){
uint VAR172 = 3+65+(uint(VAR72[3+65+1])+2)+32;
bytes memory VAR173 = VAR71 bytes(32);
FUN63(VAR72, VAR172, 32, VAR173, 0);
if (!(FUN66(VAR173) == FUN66(FUN67(VAR171, VAR138)))) return false;
bytes memory VAR174 = VAR71 bytes(uint(VAR72[VAR172+(32+8+1+32)+1])+2);
FUN63(VAR72, VAR172+(32+8+1+32), VAR174.VAR30, VAR174, 0);
if (!FUN74(FUN67(VAR174), VAR70, uint(VAR72[VAR172+32+8]))) return false;
bytes memory VAR175 = VAR71 bytes(8+1+32);
FUN63(VAR72, VAR172+32, 8+1+32, VAR175, 0);
bytes memory VAR176 = VAR71 bytes(64);
uint VAR154 = VAR172+32+(8+1+32)+VAR174.VAR30+65;
FUN63(VAR72, VAR154-64, 64, VAR176, 0);
bytes32 VAR177 = FUN67(VAR176);
if (VAR142[VAR138] == FUN66(VAR175, VAR177)){
delete VAR142[VAR138];
} else return false;
bytes memory VAR178 = VAR71 bytes(32+8+1+32);
FUN63(VAR72, VAR172, 32+8+1+32, VAR178, 0);
if (!FUN68(FUN67(VAR178), VAR174, VAR176)) return false;
if (VAR143[VAR177] == false){
VAR143[VAR177] = FUN70(VAR72, VAR154);
}
return VAR143[VAR177];
}
function FUN63(bytes VAR179, uint VAR180, uint VAR30, bytes VAR181, uint VAR182) internal pure returns (bytes) {
uint VAR102 = VAR30 + VAR182;
require(VAR181.VAR30 >= VAR102);
uint VAR100 = 32 + VAR180;
uint VAR122 = 32 + VAR182;
while (VAR100 < (32 + VAR180 + VAR30)) {
VAR23 {
let VAR96 := FUN13(FUN15(VAR179, VAR100))
FUN14(FUN15(VAR181, VAR122), VAR96)
}
VAR100 += 32;
VAR122 += 32;
}
return VAR181;
}
function FUN69(bytes32 VAR183, uint8 VAR184, bytes32 VAR185, bytes32 VAR186) internal returns (bool, address) {
bool VAR187;
address VAR188;
VAR23 {
let VAR189 := FUN13(0x40)
FUN14(VAR189, VAR183)
FUN14(FUN15(VAR189, 32), VAR184)
FUN14(FUN15(VAR189, 64), VAR185)
FUN14(FUN15(VAR189, 96), VAR186)
VAR187 := call(3000, 1, 0, VAR189, 128, VAR189, 32)
VAR188 := FUN13(VAR189)
}
return (VAR187, VAR188);
}
function FUN75(bytes32 VAR183, bytes VAR190) internal returns (bool, address) {
bytes32 VAR185;
bytes32 VAR186;
uint8 VAR184;
if (VAR190.VAR30 != 65)
return (false, 0);
VAR23 {
VAR185 := FUN13(FUN15(VAR190, 32))
VAR186 := FUN13(FUN15(VAR190, 64))
VAR184 := FUN56(0, FUN13(FUN15(VAR190, 96)))
}
//
if (VAR184 < 27)
VAR184 += 27;
if (VAR184 != 27 && VAR184 != 28)
return (false, 0);
return FUN69(VAR183, VAR184, VAR185, VAR186);
}
function FUN57() internal pure {
VAR23 {
let VAR191 := FUN13(0x40)
FUN76(VAR191, VAR192, FUN62(VAR193, VAR191))
}
}
}
interface VAR194 {
function FUN77()
external
returns(address);
function FUN78(
string VAR195,
address VAR196
)
external
returns (address);
function FUN79(
string VAR195
)
external
view
returns (address);
}
interface VAR197 {
function FUN80(
bytes32 VAR163
)
external
returns (string);
function FUN81()
external
returns (bool);
function FUN82(
string VAR198
)
external
view
returns (uint256);
function FUN83(
bytes32 VAR163,
uint256 VAR199
)
external
returns (bool);
function FUN84(
bytes32 VAR163,
string VAR198
)
external
returns (bool);
function FUN85(
string VAR198
)
external
view
returns (uint256, uint256, string);
}
contract ExchangeRateProvider is VAR48 {
uint8 public constant VAR200 = 1;
IRegistry private VAR201;
modifier FUN86()
{
require(
msg.sender == VAR201.FUN79("") ||
msg.sender == FUN43()
);
VAR66;
}
modifier FUN87()
{
require(msg.sender == FUN43());
VAR66;
}
modifier FUN88()
{
require(msg.sender == VAR201.FUN79(""));
VAR66;
}
constructor(
address VAR202
)
public
{
require(VAR202 != address(0));
VAR201 = FUN89(VAR202);
}
function FUN90(uint256 VAR15)
external
VAR203
returns (bool)
{
FUN46(VAR15);
return true;
}
function FUN91(
string VAR204,
uint256 VAR205,
uint256 VAR206,
string VAR198
)
public
VAR207
payable
returns (bool)
{
if (FUN39("") > address(this).VAR208) {
FUN84(0x0, "");
return false;
} else {
bytes32 VAR163 = FUN40(
VAR205,
"",
VAR204,
VAR206
);
FUN84(VAR163, VAR198);
return true;
}
}
function FUN84(bytes32 VAR209, string VAR198)
private
returns (bool)
{
IExchangeRates VAR210 = FUN92(
VAR201.FUN79("")
);
VAR210.FUN84(VAR209, VAR198);
}
function FUN38(bytes32 VAR163, string VAR164)
public
VAR211
{
IExchangeRates VAR210 = FUN92(
VAR201.FUN79("")
);
bool VAR212 = VAR210.FUN81();
uint256 VAR205;
uint256 VAR206;
string memory VAR204;
string memory VAR198 = VAR210.FUN80(VAR163);
(
VAR205,
VAR206,
VAR204
) = VAR210.FUN85(VAR198);
require(
VAR210.FUN83(
VAR163,
FUN54(VAR164, 2)
)
);
if (VAR205 > 0 && VAR212) {
FUN91(
VAR204,
VAR205,
VAR206,
VAR198
);
}
}
function FUN93(address VAR196)
public
VAR203
{
FUN94(VAR196);
}
function()
public
payable
{}
}
0
---------------------------------
357 0x019b014fb58c8b6aaccb9690f23e41e5efc5aa4f.sol
pragma solidity 0.4.23;
contract VAR1 {
string public VAR2 = "";
string public VAR3 = "";
uint8 constant public VAR4 = 18;
uint8 constant internal VAR5 = 4;
uint constant internal VAR6 = 0.0000001 VAR7;
uint constant internal VAR8 = 0.00000001 VAR7;
uint constant internal VAR9 = 2**64;
address VAR10 = msg.sender;
uint public VAR11 = 50e18;
mapping(address => uint) internal VAR12;
mapping(address => uint) internal VAR13;
mapping(address => int) internal VAR14;
uint internal VAR15 = 0;
uint internal VAR16;
event FUN1(
address indexed VAR17,
uint VAR18,
uint VAR19,
address indexed VAR20
);
event FUN2(
address indexed VAR17,
uint VAR21,
uint VAR22
);
event FUN3(
address indexed VAR17,
uint VAR23,
uint VAR19
);
event FUN4(
address indexed VAR17,
uint VAR24
);
event Transfer(
address indexed VAR25,
address indexed VAR26,
uint VAR27
);
function FUN5(address VAR28) public payable returns (uint) {
FUN6(msg.value, VAR28);
}
function() payable public {
FUN6(msg.value, 0x0);
}
function FUN7() onlyStronghands public {
uint VAR29 = FUN8(false);
address VAR30 = msg.sender;
VAR14[VAR30] +=  (int) (VAR29 * VAR9);
VAR29 += VAR13[VAR30];
VAR13[VAR30] = 0;
uint VAR31 = FUN6(VAR29, 0x0);
FUN3(VAR30, VAR29, VAR31);
}
function FUN9() public {
address VAR30 = msg.sender;
uint VAR31 = VAR12[VAR30];
if (VAR31 > 0) FUN10(VAR31);
FUN11();
}
function FUN11() onlyStronghands public {
address VAR30 = msg.sender;
uint VAR29 = FUN8(false);
VAR14[VAR30] +=  (int) (VAR29 * VAR9);
VAR29 += VAR13[VAR30];
VAR13[VAR30] = 0;
VAR10.transfer(VAR29);
FUN4(VAR30, VAR29);
}
function FUN10(uint VAR32) onlyBagholders public {
address VAR30 = msg.sender;
require(VAR32 <= VAR12[VAR30]);
uint VAR31 = VAR32;
uint VAR33 = FUN12(VAR31);
uint VAR29 = VAR34.FUN13(VAR33, VAR5);
uint VAR35 = VAR34.FUN14(VAR33, VAR29);
VAR15 = VAR34.FUN14(VAR15, VAR31);
VAR12[VAR30] = VAR34.FUN14(VAR12[VAR30], VAR31);
int VAR36 = (int) (VAR16 * VAR31 + (VAR35 * VAR9));
VAR14[VAR30] -= VAR36;
if (VAR15 > 0) {
VAR16 = VAR34.FUN15(VAR16, (VAR29 * VAR9) / VAR15);
}
FUN2(VAR30, VAR31, VAR35);
}
function transfer(address VAR37, uint VAR32) onlyBagholders public returns (bool) {
address VAR30 = msg.sender;
require(VAR32 <= VAR12[VAR30]);
if (FUN8(true) > 0) {
FUN11();
}
uint VAR38 = VAR34.FUN13(VAR32, VAR5);
uint VAR39 = VAR34.FUN14(VAR32, VAR38);
uint VAR29 = FUN12(VAR38);
VAR15 = VAR34.FUN14(VAR15, VAR38);
VAR12[VAR30] = VAR34.FUN14(VAR12[VAR30], VAR32);
VAR12[VAR37] = VAR34.FUN15(VAR12[VAR37], VAR39);
VAR14[VAR30] -= (int) (VAR16 * VAR32);
VAR14[VAR37] += (int) (VAR16 * VAR39);
VAR16 = VAR34.FUN15(VAR16, (VAR29 * VAR9) / VAR15);
Transfer(VAR30, VAR37, VAR39);
return true;
}
function FUN16() public view returns (uint) {
return this.VAR40;
}
function FUN17() public view returns (uint) {
return VAR15;
}
function FUN18() public view returns (uint) {
address VAR30 = msg.sender;
return FUN19(VAR30);
}
function FUN8(bool VAR41) public view returns (uint) {
address VAR30 = msg.sender;
return VAR41 ? FUN20(VAR30) + VAR13[VAR30] : FUN20(VAR30) ;
}
function FUN19(address VAR30) public view returns (uint) {
return VAR12[VAR30];
}
function FUN20(address VAR30) public view returns (uint) {
return (uint) ((int)(VAR16 * VAR12[VAR30]) - VAR14[VAR30]) / VAR9;
}
function FUN21() public view returns (uint) {
if (VAR15 == 0) {
return VAR6 - VAR8;
} else {
uint VAR33 = FUN12(1e18);
uint VAR29 = VAR34.FUN13(VAR33, VAR5  );
uint VAR35 = VAR34.FUN14(VAR33, VAR29);
return VAR35;
}
}
function FUN22() public view returns (uint) {
if (VAR15 == 0) {
return VAR6 + VAR8;
} else {
uint VAR33 = FUN12(1e18);
uint VAR29 = VAR34.FUN13(VAR33, VAR5  );
uint VAR35 = VAR34.FUN15(VAR33, VAR29);
return VAR35;
}
}
function FUN23(uint VAR42) public view returns (uint) {
uint VAR29 = VAR34.FUN13(VAR42, VAR5);
uint VAR35 = VAR34.FUN14(VAR42, VAR29);
uint VAR32 = FUN24(VAR35);
return VAR32;
}
function FUN25(uint VAR43) public view returns (uint) {
require(VAR43 <= VAR15);
uint VAR33 = FUN12(VAR43);
uint VAR29 = VAR34.FUN13(VAR33, VAR5);
uint VAR35 = VAR34.FUN14(VAR33, VAR29);
return VAR35;
}
function FUN6(uint VAR44, address VAR28) internal returns (uint) {
address VAR30 = msg.sender;
uint VAR45 = VAR34.FUN13(VAR44, VAR5);
uint VAR46 = VAR34.FUN13(VAR45, 3);
uint VAR29 = VAR34.FUN14(VAR45, VAR46);
uint VAR35 = VAR34.FUN14(VAR44, VAR45);
uint VAR32 = FUN24(VAR35);
uint VAR47 = VAR29 * VAR9;
require(VAR32 > 0 && (VAR34.FUN15(VAR32,VAR15) > VAR15));
if (
VAR28 != 0x0000000000000000000000000000000000000000 &&
VAR28 != VAR30 &&
VAR12[VAR28] >= VAR11
) {
VAR13[VAR28] = VAR34.FUN15(VAR13[VAR28], VAR46);
} else {
VAR29 = VAR34.FUN15(VAR29, VAR46);
VAR47 = VAR29 * VAR9;
}
if (VAR15 > 0) {
VAR15 = VAR34.FUN15(VAR15, VAR32);
VAR16 += (VAR29 * VAR9 / (VAR15));
VAR47 = VAR47 - (VAR47-(VAR32 * (VAR29 * VAR9 / (VAR15))));
} else {
VAR15 = VAR32;
}
VAR12[VAR30] = VAR34.FUN15(VAR12[VAR30], VAR32);
int VAR36 = (int) ((VAR16 * VAR32) - VAR47);
VAR14[VAR30] += VAR36;
FUN1(VAR30, VAR44, VAR32, VAR28);
return VAR32;
}
function FUN24(uint VAR33) internal view returns (uint) {
uint VAR48 = VAR6 * 1e18;
uint VAR49 =
(
(
VAR34.FUN14(
(VAR50
(
(VAR48**2)
+
(2*(VAR8 * 1e18)*(VAR33 * 1e18))
+
(((VAR8)**2)*(VAR15**2))
+
(2*(VAR8)*VAR48*VAR15)
)
), VAR48
)
)/(VAR8)
)-(VAR15)
;
return VAR49;
}
function FUN12(uint VAR31) internal view returns (uint) {
uint VAR51 = (VAR31 + 1e18);
uint VAR52 = (VAR15 + 1e18);
uint VAR53 =
(
VAR34.FUN14(
(
(
(
VAR6 +(VAR8 * (VAR52/1e18))
)-VAR8
)*(VAR51 - 1e18)
),(VAR8*((VAR51**2-VAR51)/1e18))/2
)
/1e18);
return VAR53;
}
function FUN26(uint VAR54) internal pure returns (uint VAR55) {
uint VAR56 = (VAR54 + 1) / 2;
VAR55 = VAR54;
while (VAR56 < VAR55) {
VAR55 = VAR56;
VAR56 = (VAR54 / VAR56 + VAR56) / 2;
}
}
modifier VAR57 {
require(FUN18() > 0);
VAR58;
}
modifier VAR59 {
require(FUN8(true) > 0);
VAR58;
}
}
library VAR34 {
function FUN27(uint VAR60, uint VAR61) internal pure returns (uint) {
if (VAR60 == 0) {
return 0;
}
uint VAR62 = VAR60 * VAR61;
assert(VAR62 / VAR60 == VAR61);
return VAR62;
}
function FUN13(uint VAR60, uint VAR61) internal pure returns (uint) {
uint VAR62 = VAR60 / VAR61;
return VAR62;
}
function FUN14(uint VAR60, uint VAR61) internal pure returns (uint) {
assert(VAR61 <= VAR60);
return VAR60 - VAR61;
}
function FUN15(uint VAR60, uint VAR61) internal pure returns (uint) {
uint VAR62 = VAR60 + VAR61;
assert(VAR62 >= VAR60);
return VAR62;
}
}
0
---------------------------------
358 0x01a47f1d07f1fd01b6499a4eef7abdc5e9cd3372.sol
pragma solidity 0.4.25;
library VAR1 {
struct VAR2 {
mapping (address => bool) VAR3;
}
function FUN1(Role storage VAR4, address VAR5) internal {
require(VAR5 != address(0));
require(!FUN2(VAR4, VAR5));
VAR4.VAR3[VAR5] = true;
}
function FUN3(Role storage VAR4, address VAR5) internal {
require(VAR5 != address(0));
require(FUN2(VAR4, VAR5));
VAR4.VAR3[VAR5] = false;
}
function FUN2(Role storage VAR4, address VAR5)
internal
view
returns (bool)
{
require(VAR5 != address(0));
return VAR4.VAR3[VAR5];
}
}
contract VAR6 {
using Roles for VAR1.VAR2;
event FUN4(address indexed VAR5);
event FUN5(address indexed VAR5);
VAR1.Role private VAR7;
constructor() internal {
FUN6(msg.sender);
}
modifier FUN7() {
require(FUN8(msg.sender));
VAR8;
}
function FUN8(address VAR5) public view returns (bool) {
return VAR7.FUN2(VAR5);
}
function FUN9(address VAR5) public VAR9 {
FUN6(VAR5);
}
function FUN10() public {
FUN11(msg.sender);
}
function FUN6(address VAR5) internal {
VAR7.FUN1(VAR5);
emit FUN4(VAR5);
}
function FUN11(address VAR5) internal {
VAR7.FUN3(VAR5);
emit FUN5(VAR5);
}
}
library VAR10 {
function FUN12(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
if (VAR11 == 0) {
return 0;
}
uint256 VAR13 = VAR11 * VAR12;
require(VAR13 / VAR11 == VAR12);
return VAR13;
}
function FUN13(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 > 0);
uint256 VAR13 = VAR11 / VAR12;
return VAR13;
}
function FUN14(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 <= VAR11);
uint256 VAR13 = VAR11 - VAR12;
return VAR13;
}
function FUN1(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 + VAR12;
require(VAR13 >= VAR11);
return VAR13;
}
function FUN15(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 != 0);
return VAR11 % VAR12;
}
}
interface VAR14 {
function FUN16() external view returns (uint256);
function FUN17(address VAR15) external view returns (uint256);
function FUN18(address VAR16, address VAR17)
external view returns (uint256);
function transfer(address VAR18, uint256 value) external returns (bool);
function FUN19(address VAR17, uint256 value)
external returns (bool);
function FUN20(address VAR19, address VAR18, uint256 value)
external returns (bool);
event Transfer(
address indexed VAR19,
address indexed VAR18,
uint256 value
);
event FUN21(
address indexed VAR16,
address indexed VAR17,
uint256 value
);
}
contract ERC20 is VAR14 {
using SafeMath for uint256;
mapping (address => uint256) private VAR20;
mapping (address => mapping (address => uint256)) private VAR21;
uint256 private VAR22;
function FUN16() public view returns (uint256) {
return VAR22;
}
function FUN17(address VAR16) public view returns (uint256) {
return VAR20[VAR16];
}
function FUN18(
address VAR16,
address VAR17
)
public
view
returns (uint256)
{
return VAR21[VAR16][VAR17];
}
function transfer(address VAR18, uint256 value) public returns (bool) {
FUN22(msg.sender, VAR18, value);
return true;
}
function FUN19(address VAR17, uint256 value) public returns (bool) {
require(VAR17 != address(0));
VAR21[msg.sender][VAR17] = value;
emit FUN21(msg.sender, VAR17, value);
return true;
}
function FUN20(
address VAR19,
address VAR18,
uint256 value
)
public
returns (bool)
{
require(value <= VAR21[VAR19][msg.sender]);
VAR21[VAR19][msg.sender] = VAR21[VAR19][msg.sender].FUN14(value);
FUN22(VAR19, VAR18, value);
return true;
}
function FUN23(
address VAR17,
uint256 VAR23
)
public
returns (bool)
{
require(VAR17 != address(0));
VAR21[msg.sender][VAR17] = (
VAR21[msg.sender][VAR17].FUN1(VAR23));
emit FUN21(msg.sender, VAR17, VAR21[msg.sender][VAR17]);
return true;
}
function FUN24(
address VAR17,
uint256 VAR24
)
public
returns (bool)
{
require(VAR17 != address(0));
VAR21[msg.sender][VAR17] = (
VAR21[msg.sender][VAR17].FUN14(VAR24));
emit FUN21(msg.sender, VAR17, VAR21[msg.sender][VAR17]);
return true;
}
function FUN22(address VAR19, address VAR18, uint256 value) internal {
require(value <= VAR20[VAR19]);
require(VAR18 != address(0));
VAR20[VAR19] = VAR20[VAR19].FUN14(value);
VAR20[VAR18] = VAR20[VAR18].FUN1(value);
emit Transfer(VAR19, VAR18, value);
}
function FUN25(address VAR5, uint256 value) internal {
require(VAR5 != 0);
VAR22 = VAR22.FUN1(value);
VAR20[VAR5] = VAR20[VAR5].FUN1(value);
emit Transfer(address(0), VAR5, value);
}
function FUN26(address VAR5, uint256 value) internal {
require(VAR5 != 0);
require(value <= VAR20[VAR5]);
VAR22 = VAR22.FUN14(value);
VAR20[VAR5] = VAR20[VAR5].FUN14(value);
emit Transfer(VAR5, address(0), value);
}
function FUN27(address VAR5, uint256 value) internal {
require(value <= VAR21[VAR5][msg.sender]);
VAR21[VAR5][msg.sender] = VAR21[VAR5][msg.sender].FUN14(
value);
FUN26(VAR5, value);
}
}
contract ERC20Burnable is VAR25 {
function FUN28(uint256 value) public {
FUN26(msg.sender, value);
}
function FUN29(address VAR19, uint256 value) public {
FUN27(VAR19, value);
}
}
contract ERC20Mintable is VAR26, VAR6 {
function FUN30(
address VAR18,
uint256 value
)
public
VAR9
returns (bool)
{
FUN25(VAR18, value);
return true;
}
}
contract AzulToken is VAR27 {
string public constant VAR28 = "";
string public constant VAR29 = "";
uint8 public constant VAR30 = 18;
}
0
---------------------------------
359 0x01a7018e6d1fde8a68d12f59b6532fb523b6259d.sol
contract VAR1 {
function assert(bool VAR2) {
if (!VAR2) throw;
}
}
contract VAR3 {
function FUN1(address VAR4, uint256 VAR5, address VAR6, bytes VAR7);
}
contract Owned is VAR1 {
address internal VAR8;
event FUN2(address indexed VAR9, address indexed VAR10);
function FUN3 () {
VAR8 = msg.sender;
}
modifier onlyOwner {
assert(msg.sender == VAR8);
VAR11
}
function FUN4(address VAR10) onlyOwner {
FUN2(VAR8, VAR10);
VAR8 = VAR10;
}
function FUN5() returns (address VAR12) {
return VAR8;
}
}
contract StateTransferrable is VAR13 {
bool internal VAR14;
event FUN6(address indexed VAR15);
event FUN7(address indexed VAR15);
modifier VAR16 {
assert(!VAR14);
VAR11
}
modifier VAR17 {
VAR11
FUN7(msg.sender);
}
modifier VAR18 {
assert(!VAR14 && msg.sender == VAR8);
VAR11
}
function FUN8() onlyOwner VAR16 {
VAR14 = true;
FUN6(msg.sender);
}
function FUN9() returns (bool VAR19) {
return VAR14;
}
}
contract VAR20 {
event FUN10(address indexed VAR15);
event FUN11(address indexed VAR15, address indexed VAR21);
event FUN12(address indexed VAR15);
event FUN13(address indexed VAR15);
event FUN14(address indexed VAR15);
event FUN15(address indexed VAR15);
event FUN16(address indexed VAR15);
event FUN17(address indexed VAR15, address indexed VAR21);
event FUN18(address indexed VAR15, bytes32 indexed VAR22);
}
contract Trust is VAR23, VAR20 {
mapping (address => bool) public VAR24;
mapping (address => bytes32) public VAR25;
address[] public VAR26;
mapping (address => bool) public VAR27;
mapping (address => bool) public VAR28;
mapping (uint256 => address) public VAR29;
mapping (address => uint256) public VAR30;
function FUN19(address VAR31) internal {
if (!VAR27[VAR31]) {
VAR27[VAR31] = true;
VAR26.FUN20(VAR31);
}
}
function FUN21(address VAR31) onlyOwnerUnlocked VAR17 {
VAR28[VAR31] = true;
}
function FUN22(address VAR31) FUN23(FUN24(msg.VAR32)) {
VAR28[VAR31] = false;
}
function FUN25(address VAR31) FUN23(FUN24(msg.VAR32)) {
VAR28[VAR31] = true;
}
function FUN26(address VAR31) VAR18 {
assert(!VAR24[VAR31]);
FUN19(VAR31);
VAR24[VAR31] = true;
FUN16(msg.sender);
}
modifier VAR33 {
assert(VAR24[msg.sender]);
VAR11
}
function FUN27() returns (uint256 VAR34) {
return VAR26.VAR34;
}
function FUN28(uint256 VAR35) internal {
address VAR31 = VAR29[VAR35];
VAR29[VAR35] = 0x0;
VAR30[VAR31] = 0;
}
function FUN29(address VAR15) external returns (uint8 VAR19) {
if (!VAR24[VAR15] || !VAR28[msg.sender]) {
FUN13(VAR15);
return 0;
}
uint256 call = VAR30[VAR15];
if (call == 0) {
FUN15(VAR15);
return 1;
} else {
FUN17(VAR15, VAR15);
VAR30[VAR15] = 0;
VAR29[call] = 0x0;
return 2;
}
}
function FUN30() returns (uint8 VAR36) {
if (!VAR24[msg.sender]) {
FUN13(msg.sender);
return 0;
}
uint256 call = VAR30[msg.sender];
if (call == 0) {
FUN15(msg.sender);
return 1;
} else {
FUN17(msg.sender, msg.sender);
uint256 VAR35 = VAR30[msg.sender];
VAR30[msg.sender] = 0x0;
VAR29[VAR35] = 0;
return 2;
}
}
function FUN31(address VAR15, bytes32 VAR35) external returns (uint8 VAR36) {
if (!VAR24[VAR15] && !VAR28[msg.sender]) {
FUN13(VAR15);
return 0;
}
if (VAR30[VAR15] == 0) {
if (VAR29[uint256(VAR35)] == 0x0) {
VAR29[uint256(VAR35)] = VAR15;
VAR30[VAR15] = uint256(VAR35);
FUN10(VAR15);
return 1;
} else {
FUN11(VAR29[uint256(VAR35)], VAR15);
FUN28(uint256(VAR35));
return 2;
}
} else {
FUN12(VAR15);
return 3;
}
}
modifier FUN23 (bytes32 VAR35) {
if (!VAR24[msg.sender]) {
FUN13(msg.sender);
} else if (VAR30[msg.sender] == 0) {
if (VAR29[uint256(VAR35)] == 0x0) {
VAR29[uint256(VAR35)] = msg.sender;
VAR30[msg.sender] = uint256(VAR35);
FUN10(msg.sender);
} else {
FUN11(VAR29[uint256(VAR35)], msg.sender);
FUN28(uint256(VAR35));
VAR11
}
} else {
FUN12(msg.sender);
}
}
function FUN32(address VAR31) FUN23(FUN24(msg.VAR32)) {
assert(VAR24[VAR31]);
VAR24[VAR31] = false;
}
function FUN33(address VAR31) FUN23(FUN24(msg.VAR32)) {
assert(!VAR24[VAR31]);
FUN19(VAR31);
VAR24[VAR31] = true;
}
function FUN34(bytes32 VAR22) VAR33 {
VAR25[msg.sender] = VAR22;
FUN18(msg.sender, VAR22);
}
function FUN35(address VAR31) returns (bytes32 VAR22) {
return VAR25[VAR31];
}
}
contract TrustClient is VAR23, VAR20 {
address public VAR37;
function FUN36(address VAR31) setter VAR18 {
VAR37 = VAR31;
}
function FUN35(address VAR31) constant returns (bytes32 VAR22) {
return FUN37(VAR37).FUN35(VAR31);
}
function FUN30() returns (uint8 VAR19) {
assert(VAR37 != address(0x0));
uint8 VAR36 = FUN37(VAR37).FUN29(msg.sender);
if (VAR36 == 0) FUN13(msg.sender);
else if (VAR36 == 1) FUN15(msg.sender);
else if (VAR36 == 2) FUN17(msg.sender, msg.sender);
return VAR36;
}
modifier FUN23 (bytes32 VAR35) {
assert(VAR37 != address(0x0));
address VAR38 = FUN37(VAR37).FUN38(uint256(VAR35));
uint8 VAR36 = FUN37(VAR37).FUN31(msg.sender, VAR35);
if (VAR36 == 0) FUN13(msg.sender);
else if (VAR36 == 1) FUN10(msg.sender);
else if (VAR36 == 2) {
FUN11(VAR38, msg.sender);
VAR11
}
else if (VAR36 == 3) {
FUN12(msg.sender);
}
}
}
contract VAR39 {
function FUN39(address VAR40, address VAR41, uint256 VAR42, bytes VAR7) returns (bool VAR43);
}
contract TokenBase is VAR13 {
bytes32 public VAR44 = '';
bytes32 public VAR22;
bytes32 public VAR45;
uint256 public VAR46;
bool public VAR47;
event FUN40(address indexed VAR15, address indexed VAR48, uint256 VAR49);
mapping (address => uint256) public VAR50;
mapping (address => mapping (address => uint256)) public VAR51;
event Transfer(address indexed VAR15, address indexed VAR52, uint256 value);
function transfer(address VAR53, uint256 VAR5) returns (bool VAR43);
function FUN41(address VAR41, uint256 VAR5, bytes VAR7) returns (bool VAR43);
function FUN42(address VAR41, uint256 VAR5) returns (bool VAR43);
function FUN43(address VAR4, address VAR53, uint256 VAR5) returns (bool VAR43);
function () {
throw;
}
}
contract VAR54 {
uint8 public VAR55;
}
contract Token is VAR56, VAR54 {}
contract VAR57 {
function FUN44(uint256 VAR58, uint8 VAR59) internal returns (uint256 VAR60) {
for (uint8 VAR61 = 0; VAR61 < VAR59; VAR61++) {
VAR58 *= 10;
}
return VAR58;
}
function FUN45(uint256 VAR58, uint8 VAR59) internal returns (uint256 VAR60) {
for (uint8 VAR61 = 0; VAR61 < VAR59; VAR61++) {
VAR58 /= 10;
}
return VAR58;
}
function FUN46(uint256 VAR58, uint256 VAR59) internal returns (uint256 VAR62) {
if (VAR58 >= VAR59) return VAR58;
return VAR59;
}
}
contract DVIP is VAR63, VAR23, VAR64, VAR57 {
uint256 public VAR46;
mapping (address => bool) public VAR65;
mapping (address => address[]) public VAR66;
mapping (address => mapping (address => bool)) public VAR67;
address[] public VAR68;
mapping (address => bool) public VAR69;
address public VAR70;
uint256 public VAR71;
uint256 public VAR72;
bool public VAR73;
mapping (address => uint256) public VAR74;
address[] public VAR75;
mapping (address => bool) VAR76;
mapping (address => uint256) public VAR77;
address[] public VAR78;
mapping (address => bool) VAR79;
event FUN47(address VAR80, bool VAR81);
event FUN48(address indexed VAR15, uint8 VAR82);
event FUN49(address indexed VAR15);
event FUN50(address indexed VAR15, address indexed VAR80, uint256 VAR49);
function FUN51() {
VAR73 = true;
VAR72 = 0;
VAR46 = 0;
VAR22 = "";
VAR45 = "";
VAR55 = 6;
VAR47 = true;
VAR71 = 1514764800;
}
modifier VAR83 {
assert(msg.sender == VAR70);
VAR11
}
function FUN52(address VAR31) onlyOwnerUnlocked VAR17 {
VAR70 = VAR31;
}
function FUN53(uint256 VAR84) onlyOwnerUnlocked VAR17 {
VAR46 = VAR84;
}
function FUN54(bytes32 VAR85) onlyOwnerUnlocked VAR17 {
VAR44 = VAR85;
}
function FUN55(bytes32 VAR86) onlyOwnerUnlocked VAR17 {
VAR22 = VAR86;
}
function FUN56(bytes32 VAR87) onlyOwnerUnlocked VAR17 {
VAR45 = VAR87;
}
function FUN57(uint8 VAR82) VAR18 {
VAR55 = VAR82;
FUN48(msg.sender, VAR82);
}
function FUN58(address VAR31, uint256 VAR49) VAR18 {
VAR50[VAR31] = VAR49;
FUN59(VAR31);
}
function FUN60(address VAR15, address VAR52, uint256 VAR49) VAR18 {
VAR51[VAR15][VAR52] = VAR49;
FUN61(VAR15, VAR52);
}
function FUN62(uint256 VAR49) VAR18 {
VAR72 = VAR49;
}
function FUN63(address VAR31, bool VAR81) VAR18 {
FUN59(VAR31);
VAR65[VAR31] = VAR81;
}
function FUN64(address VAR31, uint256 VAR88) VAR18 {
VAR77[VAR31] = VAR88;
FUN65(VAR31);
FUN50(msg.sender, VAR31, VAR88);
}
function FUN66(address VAR31, uint256 VAR88) VAR18 {
VAR74[VAR31] = VAR88;
FUN67(VAR31);
FUN50(msg.sender, VAR31, VAR88);
}
function transfer(address VAR53, uint256 VAR42) returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[msg.sender]);
assert(VAR50[msg.sender] >= VAR42);
assert(VAR50[VAR53] + VAR42 >= VAR50[VAR53]);
FUN59(msg.sender);
FUN59(VAR53);
VAR50[msg.sender] -= VAR42;
if (VAR53 == address(this)) VAR72 += VAR42;
else VAR50[VAR53] += VAR42;
Transfer(msg.sender, VAR53, VAR42);
return true;
}
function FUN43(address VAR4, address VAR53, uint256 VAR42) returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[msg.sender]);
assert(!VAR65[VAR4]);
assert(VAR50[VAR4] >= VAR42);
assert(VAR50[VAR53] + VAR42 >= VAR50[VAR53]);
assert(VAR42 <= VAR51[VAR4][msg.sender]);
VAR50[VAR4] -= VAR42;
VAR50[VAR53] += VAR42;
VAR51[VAR4][msg.sender] -= VAR42;
FUN59(VAR4);
FUN59(VAR53);
FUN59(msg.sender);
Transfer(VAR4, VAR53, VAR42);
return true;
}
function FUN41(address VAR41, uint256 VAR42, bytes VAR7) returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[msg.sender]);
VAR51[msg.sender][VAR41] = VAR42;
FUN59(msg.sender);
FUN59(VAR41);
FUN61(msg.sender, VAR41);
TokenRecipient VAR48 = FUN68(VAR41);
VAR48.FUN1(msg.sender, VAR42, this, VAR7);
FUN40(msg.sender, VAR41, VAR42);
return true;
}
function FUN42(address VAR41, uint256 VAR42) returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[msg.sender]);
VAR51[msg.sender][VAR41] = VAR42;
FUN59(msg.sender);
FUN59(VAR41);
FUN61(msg.sender, VAR41);
FUN40(msg.sender, VAR41, VAR42);
return true;
}
function FUN69(uint256 VAR89) FUN23(FUN24(msg.VAR32)) {
VAR71 = VAR89;
}
function FUN70(uint256 VAR90) FUN23(FUN24(msg.VAR32)) {
VAR72 += VAR90;
VAR46 += VAR90;
}
function FUN71(uint256 VAR91) FUN23(FUN24(msg.VAR32)) {
assert(VAR72 >= VAR91);
VAR72 -= VAR91;
VAR46 -= VAR91;
}
function FUN72(address VAR52, uint256 VAR49) FUN23(FUN24(msg.VAR32)) {
assert(VAR72 >= VAR49);
VAR72 -= VAR49;
VAR50[VAR52] += VAR49;
FUN59(VAR52);
}
function FUN73(address VAR31, uint256 VAR88) FUN23(FUN24(msg.VAR32)) {
uint256 VAR92 = 1;
VAR92 = FUN44(1, VAR55);
assert(VAR88 <= VAR92);
VAR77[VAR31] = VAR88;
FUN65(VAR31);
}
function FUN74(address VAR31, uint256 VAR88) FUN23(FUN24(msg.VAR32)) {
uint256 VAR92 = 1;
VAR92 = FUN44(1, VAR55);
assert(VAR88 <= VAR92);
VAR74[VAR31] = VAR88;
FUN67(VAR31);
}
function FUN75(bool VAR93) FUN23(FUN24(msg.VAR32)) {
assert(VAR93 != VAR47);
VAR47 = VAR93;
}
function FUN76(address VAR94) FUN23(FUN24(msg.VAR32)) {
FUN77(VAR94);
}
function FUN78(address VAR31, bool VAR95) FUN23(FUN24(msg.VAR32)) {
VAR65[VAR31] = VAR95;
FUN59(VAR31);
}
function FUN79(address VAR31, uint256 VAR49) FUN23(FUN24(msg.VAR32)) {
assert(VAR50[VAR31] >= VAR49);
assert(VAR65[VAR31]);
FUN59(VAR31);
VAR50[VAR31] -= VAR49;
VAR72 += VAR49;
}
function FUN80(address VAR15, address VAR52, uint256 VAR49) constant external returns (uint256 value) {
uint256 VAR88 = VAR74[VAR15] + VAR77[VAR52];
if (VAR88 == 0) return 0;
uint256 VAR96;
bool VAR97 = true;
uint256 VAR98;
if (VAR74[VAR15] == 0 && VAR50[VAR15] != 0 && VAR99 < VAR71) {
VAR96 = VAR50[VAR15];
} else if (VAR77[VAR52] == 0 && VAR50[VAR52] != 0 && VAR99 < VAR71) {
VAR96 = VAR50[VAR52];
} else VAR97 = false;
if (VAR97) {
VAR98 = FUN44(1, VAR55);
if (VAR96 > VAR98) VAR96 = VAR98;
uint256 VAR100 = VAR98 - VAR96;
return FUN45(VAR49*VAR88*VAR100, VAR55*2);
}
return FUN45(VAR49*VAR88, VAR55);
}
function FUN81() VAR83 {
VAR47 = false;
FUN49(msg.sender);
}
function FUN82(address VAR31) constant returns (uint256 VAR101) {
return VAR66[VAR31].VAR34;
}
function FUN83() constant returns (uint256 VAR34) {
return VAR68.VAR34;
}
function FUN59(address VAR31) internal {
if (!VAR69[VAR31]) {
VAR69[VAR31] = true;
VAR68.FUN20(VAR31);
}
}
function FUN61(address VAR15, address VAR52) internal {
if (!VAR67[VAR15][VAR52]) {
VAR67[VAR15][VAR52] = true;
VAR66[VAR15].FUN20(VAR52);
}
}
function FUN67(address VAR31) internal {
if (!VAR76[VAR31]) {
VAR76[VAR31] = true;
VAR75.FUN20(VAR31);
}
}
function FUN65(address VAR31) internal {
if (!VAR79[VAR31]) {
VAR79[VAR31] = true;
VAR78.FUN20(VAR31);
}
}
function FUN84() returns (uint256 VAR34) {
return VAR78.VAR34;
}
function FUN85() returns (uint256 VAR34) {
return VAR75.VAR34;
}
}
contract DCAssetBackend is VAR13, VAR54, VAR23, VAR64, VAR57 {
bytes32 public VAR44 = '';
bytes32 public VAR22;
bytes32 public VAR45;
bool public VAR47;
event FUN40(address indexed VAR15, address indexed VAR48, uint256 VAR49);
mapping (address => uint256) public VAR50;
mapping (address => mapping (address => uint256)) public VAR51;
event Transfer(address indexed VAR15, address indexed VAR52, uint256 value);
uint256 public VAR46;
address public VAR102;
address public VAR103;
address public VAR70;
address public VAR104;
mapping (address => bool) public VAR65;
mapping (address => address[]) public VAR66;
mapping (address => mapping (address => bool)) public VAR67;
address[] public VAR68;
mapping (address => bool) public VAR69;
bool public VAR73;
uint256 public VAR72;
mapping (address => uint256) public VAR105;
address[] public VAR106;
mapping (address => bool) VAR107;
event FUN47(address VAR80, bool VAR81);
event FUN48(address indexed VAR15, uint8 VAR82);
event FUN49(address indexed VAR15);
event FUN50(address indexed VAR15, address indexed VAR80, uint256 VAR49);
function FUN86(bytes32 VAR108, bytes32 VAR109) {
VAR73 = true;
VAR22 = VAR109;
VAR45 = VAR108;
VAR55 = 6;
VAR47 = true;
}
modifier VAR83 {
assert(msg.sender == VAR70);
VAR11
}
modifier VAR110 {
assert(msg.sender == VAR103);
VAR11
}
function FUN87(address VAR31) onlyOwnerUnlocked VAR17 {
VAR102 = VAR31;
}
function FUN88(address VAR31) onlyOwnerUnlocked VAR17 {
VAR103 = VAR31;
}
function FUN89(address VAR31) onlyOwnerUnlocked VAR17 {
VAR104 = VAR31;
}
function FUN52(address VAR31) onlyOwnerUnlocked VAR17 {
VAR70 = VAR31;
}
function FUN53(uint256 VAR84) onlyOwnerUnlocked VAR17 {
VAR46 = VAR84;
}
function FUN54(bytes32 VAR85) onlyOwnerUnlocked VAR17 {
VAR44 = VAR85;
}
function FUN55(bytes32 VAR86) onlyOwnerUnlocked VAR17 {
VAR22 = VAR86;
}
function FUN56(bytes32 VAR87) onlyOwnerUnlocked VAR17 {
VAR45 = VAR87;
}
function FUN57(uint8 VAR82) VAR18 {
VAR55 = VAR82;
FUN48(msg.sender, VAR82);
}
function FUN58(address VAR31, uint256 VAR49) VAR18 {
VAR50[VAR31] = VAR49;
FUN59(VAR31);
}
function FUN60(address VAR15, address VAR52, uint256 VAR49) VAR18 {
VAR51[VAR15][VAR52] = VAR49;
FUN61(VAR15, VAR52);
}
function FUN62(uint256 VAR49) VAR18 {
VAR72 = VAR49;
}
function FUN63(address VAR31, bool VAR81) VAR18 {
FUN59(VAR31);
VAR65[VAR31] = VAR81;
}
function transfer(address VAR40, address VAR53, uint256 VAR42) onlyAsset returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[VAR40]);
assert(VAR50[VAR40] >= VAR42);
assert(VAR50[VAR53] + VAR42 >= VAR50[VAR53]);
FUN59(VAR40);
FUN59(VAR53);
VAR50[VAR40] -= VAR42;
if (VAR53 == address(this)) VAR72 += VAR42;
else {
uint256 VAR88 = FUN80(VAR40, VAR53, VAR42);
VAR50[VAR53] += VAR42 - VAR88;
VAR72 += VAR88;
}
Transfer(VAR40, VAR53, VAR42);
return true;
}
function FUN43(address VAR40, address VAR4, address VAR53, uint256 VAR42) onlyAsset returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[VAR40]);
assert(!VAR65[VAR4]);
assert(VAR50[VAR4] >= VAR42);
assert(VAR50[VAR53] + VAR42 >= VAR50[VAR53]);
assert(VAR42 <= VAR51[VAR4][VAR40]);
VAR50[VAR4] -= VAR42;
uint256 VAR88 = FUN80(VAR4, VAR53, VAR42);
VAR50[VAR53] += VAR42 - VAR88;
VAR72 += VAR88;
VAR51[VAR4][VAR40] -= VAR42;
FUN59(VAR4);
FUN59(VAR53);
FUN59(VAR40);
Transfer(VAR4, VAR53, VAR42);
return true;
}
function FUN41(address VAR40, address VAR41, uint256 VAR42, bytes VAR7) onlyAsset returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[VAR40]);
VAR51[VAR40][VAR41] = VAR42;
FUN59(VAR40);
FUN59(VAR41);
FUN61(VAR40, VAR41);
TokenRecipient VAR48 = FUN68(VAR41);
assert(FUN90(VAR103).FUN39(VAR40, VAR41, VAR42, VAR7));
FUN40(VAR40, VAR41, VAR42);
return true;
}
function FUN42(address VAR40, address VAR41, uint256 VAR42) onlyAsset returns (bool VAR43) {
assert(VAR47);
assert(!VAR65[VAR40]);
VAR51[VAR40][VAR41] = VAR42;
FUN59(VAR40);
FUN59(VAR41);
FUN61(VAR40, VAR41);
FUN40(VAR40, VAR41, VAR42);
return true;
}
function FUN70(uint256 VAR90) FUN23(FUN24(msg.VAR32)) {
FUN59(VAR102);
VAR50[VAR102] += VAR90;
VAR46 += VAR90;
}
function FUN71(uint256 VAR91) FUN23(FUN24(msg.VAR32)) {
assert(VAR50[VAR102] >= VAR91);
FUN59(VAR102);
VAR50[VAR102] -= VAR91;
VAR46 -= VAR91;
}
function FUN72(address VAR52, uint256 VAR49) FUN23(FUN24(msg.VAR32)) {
assert(VAR72 >= VAR49);
VAR72 -= VAR49;
VAR50[VAR52] += VAR49;
FUN59(VAR52);
}
function FUN75(bool VAR93) FUN23(FUN24(msg.VAR32)) {
if (VAR93 == VAR47) throw;
VAR47 = VAR93;
}
function FUN76(address VAR94) FUN23(FUN24(msg.VAR32)) {
FUN77(VAR94);
}
function FUN78(address VAR31, bool VAR95) FUN23(FUN24(msg.VAR32)) {
VAR65[VAR31] = VAR95;
FUN59(VAR31);
}
function FUN79(address VAR31, uint256 VAR49) FUN23(FUN24(msg.VAR32)) {
assert(VAR50[VAR31] >= VAR49);
assert(VAR65[VAR31]);
FUN59(VAR31);
VAR50[VAR31] -= VAR49;
VAR50[VAR102] += VAR49;
}
function FUN81() VAR83 {
VAR47 = false;
FUN49(msg.sender);
}
function FUN82(address VAR31) returns (uint256 VAR101) {
return VAR66[VAR31].VAR34;
}
function FUN83() returns (uint256 VAR34) {
return VAR68.VAR34;
}
function FUN59(address VAR31) internal {
if (!VAR69[VAR31]) {
VAR69[VAR31] = true;
VAR68.FUN20(VAR31);
}
}
function FUN61(address VAR15, address VAR52) internal {
if (!VAR67[VAR15][VAR52]) {
VAR67[VAR15][VAR52] = true;
VAR66[VAR15].FUN20(VAR52);
}
}
function FUN80(address VAR58, address VAR59, uint256 VAR49) returns (uint256 value) {
if (VAR104 == address(0x0)) return 0;
return FUN51(VAR104).FUN80(VAR58, VAR59, VAR49);
}
}
contract DCAsset is VAR56, VAR23, VAR64, VAR39 {
address public VAR111;
function FUN91(address VAR112) {
VAR111 = VAR112;
}
function FUN92() constant returns (bytes32 VAR85) {
return FUN86(VAR111).FUN92();
}
function FUN93() constant returns (bytes32 VAR113) {
return FUN86(VAR111).FUN93();
}
function FUN94() constant returns (bytes32 VAR87) {
return FUN86(VAR111).FUN94();
}
function FUN95() constant returns (uint8 VAR82) {
return FUN86(VAR111).FUN95();
}
function FUN96(address VAR15, address VAR52) constant returns (uint256 VAR62) {
return FUN86(VAR111).FUN96(VAR15, VAR52);
}
function FUN97(address VAR112) FUN23(FUN24(msg.VAR32)) {
VAR111 = VAR112;
}
function FUN98(address VAR114) constant returns (uint256 VAR115) {
return FUN86(VAR111).FUN98(VAR114);
}
function FUN99() constant returns (uint256 VAR115) {
return FUN86(VAR111).FUN99();
}
function transfer(address VAR53, uint256 VAR42) returns (bool VAR43)  {
if (!FUN86(VAR111).transfer(msg.sender, VAR53, VAR42)) throw;
Transfer(msg.sender, VAR53, VAR42);
return true;
}
function FUN41(address VAR41, uint256 VAR42, bytes VAR7) returns (bool VAR43) {
if (!FUN86(VAR111).FUN41(msg.sender, VAR41, VAR42, VAR7)) throw;
FUN40(msg.sender, VAR41, VAR42);
return true;
}
function FUN42(address VAR41, uint256 VAR42) returns (bool VAR43) {
if (!FUN86(VAR111).FUN42(msg.sender, VAR41, VAR42)) throw;
FUN40(msg.sender, VAR41, VAR42);
return true;
}
function FUN43(address VAR4, address VAR53, uint256 VAR42) returns (bool VAR43) {
if (!FUN86(VAR111).FUN43(msg.sender, VAR4, VAR53, VAR42)) throw;
Transfer(VAR4, VAR53, VAR42);
return true;
}
function FUN80(address VAR4, address VAR53, uint256 VAR42) returns (uint256 VAR49) {
return FUN86(VAR111).FUN80(VAR4, VAR53, VAR42);
}
function FUN39(address VAR40, address VAR41, uint256 VAR42, bytes VAR7) returns (bool VAR43) {
assert(msg.sender == VAR111);
TokenRecipient VAR48 = FUN68(VAR41);
VAR48.FUN1(VAR40, VAR42, this, VAR7);
return true;
}
}
0
---------------------------------
360 0x01a9a2b8638451d447f0027179b19e8843963a88.sol
pragma solidity 0.4.23;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
address public VAR6;
event FUN5(address indexed VAR7, address indexed VAR8);
constructor() public {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR9;
}
function FUN6(address VAR8) public onlyOwner {
require(VAR8 != address(0));
emit FUN5(VAR6, VAR8);
VAR6 = VAR8;
}
}
contract VAR10 {
uint256 public VAR11;
function FUN7(address VAR12) public view returns (uint256 VAR13);
function transfer(address VAR14, uint256 VAR15) public returns (bool VAR16);
event Transfer(address indexed VAR17, address indexed VAR18, uint256 value);
}
contract ERC20 is VAR10 {
function FUN8(address VAR12, address VAR19) public view returns (uint256 VAR20);
function FUN9(address VAR21, address VAR14, uint256 VAR15) public returns (bool VAR16);
function FUN10(address VAR19, uint256 VAR15) public returns (bool VAR16);
event FUN11(address indexed VAR6, address indexed VAR22, uint256 value);
}
contract BasicToken is VAR10 {
using SafeMath for uint256;
mapping(address => uint256) VAR23;
function transfer(address VAR14, uint256 VAR15) public returns (bool VAR16) {
require(VAR14 != address(0));
require(VAR23[msg.sender] >= VAR15 && VAR15 > 0
&& VAR23[VAR14].FUN4(VAR15) > VAR23[VAR14]);
VAR23[msg.sender] = VAR23[msg.sender].FUN3(VAR15);
VAR23[VAR14] = VAR23[VAR14].FUN4(VAR15);
emit Transfer(msg.sender, VAR14, VAR15);
return true;
}
function FUN7(address VAR12) public view returns (uint256 VAR13) {
return VAR23[VAR12];
}
}
contract StandardToken is VAR24, VAR25 {
mapping (address => mapping (address => uint256)) internal VAR26;
function FUN9(address VAR21, address VAR14, uint256 VAR15) public returns (bool VAR16) {
require(VAR14 != address(0));
require(VAR23[VAR21] >= VAR15);
require(VAR26[VAR21][msg.sender] >= VAR15);
require(VAR15 > 0 && VAR23[VAR14].FUN4(VAR15) > VAR23[VAR14]);
VAR23[VAR21] = VAR23[VAR21].FUN3(VAR15);
VAR23[VAR14] = VAR23[VAR14].FUN4(VAR15);
VAR26[VAR21][msg.sender] = VAR26[VAR21][msg.sender].FUN3(VAR15);
emit Transfer(VAR21, VAR14, VAR15);
return true;
}
function FUN10(address VAR19, uint256 VAR15) public returns (bool VAR16) {
VAR26[msg.sender][VAR19] = VAR15;
emit FUN11(msg.sender, VAR19, VAR15);
return true;
}
function FUN8(address VAR12, address VAR19) public view returns (uint256 VAR20) {
return VAR26[VAR12][VAR19];
}
}
contract BurnableToken is VAR27, VAR5 {
event FUN12(address indexed VAR28, uint256 value);
function FUN13(uint256 VAR29) public onlyOwner{
require(VAR29 <= VAR23[msg.sender]);
VAR23[msg.sender] = VAR23[msg.sender].FUN3(VAR29);
VAR11 = VAR11.FUN3(VAR29);
emit FUN12(msg.sender, VAR29);
}
}
contract URUNToken is VAR30 {
string public VAR31 ;
string public VAR32 ;
uint8 public VAR33 = 18 ;
function ()public payable {
revert();
}
constructor(
uint256 VAR34,
string VAR35,
string VAR36,
address VAR37
) public {
VAR6 = VAR37;
VAR11 = VAR34.FUN1( 10 ** uint256(VAR33));
VAR31 = VAR35;
VAR32 = VAR36;
VAR23[VAR37] = VAR11;
emit Transfer(address(0), msg.sender, VAR11);
}
function FUN14() public view returns (string, string, uint256) {
return (VAR31, VAR32, VAR11);
}
}
0
---------------------------------
361 0x01aaf00b615d97360e80ef1242a3935c8b7d529a.sol
pragma VAR1 >=0.5.4 <0.6.0;
interface VAR2 { function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external; }
library VAR7 {
function FUN2(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
if (VAR8 == 0) {
return 0;
}
VAR10 = VAR8 * VAR9;
assert(VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN3(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
return VAR8 / VAR9;
}
function FUN4(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
assert(VAR9 <= VAR8);
return VAR8 - VAR9;
}
function FUN5(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
VAR10 = VAR8 + VAR9;
assert(VAR10 >= VAR8);
return VAR10;
}
}
interface VAR11 {
function FUN6(address VAR12, address VAR13) external view returns (bool);
function FUN7(address VAR12, address VAR13) external view returns (bool);
function FUN8(address VAR12, address VAR13) external view returns (bool);
function FUN9(address VAR12, address VAR13) external view returns (bool);
function FUN10(address VAR13) external view returns (address);
function FUN11(address VAR14, address VAR13) external view returns (bool);
function FUN12(address VAR14, address VAR13) external view returns (bool);
function FUN13(address VAR13, address VAR15, address VAR16, address VAR17) external returns (bool);
function FUN14(address VAR12, address VAR13) external view returns (uint256);
}
interface VAR18 {
function FUN15(address VAR13) external view returns (bool);
}
interface VAR19 {
function FUN13(address VAR13, address VAR20, address VAR21) external returns (bool);
function FUN16(address VAR13, address VAR22) external view returns (bool);
function FUN17(address VAR13) external view returns (address);
function FUN18(address VAR13, address VAR22) external returns (bool);
}
contract VAR23 {
string public VAR24;
string public VAR25;
uint8 public VAR26 = 18;
uint256 public VAR27;
mapping (address => uint256) public VAR28;
mapping (address => mapping (address => uint256)) public VAR29;
event Transfer(address indexed VAR30, address indexed VAR31, uint256 value);
event FUN19(address indexed VAR32, address indexed VAR33, uint256 VAR4);
event FUN20(address indexed VAR30, uint256 value);
constructor (uint256 VAR34, string memory VAR35, string memory VAR36) public {
VAR27 = VAR34 * 10 ** uint256(VAR26);
VAR28[msg.sender] = VAR27;
VAR24 = VAR35;
VAR25 = VAR36;
}
function FUN21(address VAR3, address VAR37, uint VAR4) internal {
require(VAR37 != address(0));
require(VAR28[VAR3] >= VAR4);
require(VAR28[VAR37] + VAR4 > VAR28[VAR37]);
uint VAR38 = VAR28[VAR3] + VAR28[VAR37];
VAR28[VAR3] -= VAR4;
VAR28[VAR37] += VAR4;
emit Transfer(VAR3, VAR37, VAR4);
assert(VAR28[VAR3] + VAR28[VAR37] == VAR38);
}
function transfer(address VAR37, uint256 VAR4) public returns (bool VAR39) {
FUN21(msg.sender, VAR37, VAR4);
return true;
}
function FUN22(address VAR3, address VAR37, uint256 VAR4) public returns (bool VAR39) {
require(VAR4 <= VAR29[VAR3][msg.sender]);
VAR29[VAR3][msg.sender] -= VAR4;
FUN21(VAR3, VAR37, VAR4);
return true;
}
function FUN23(address VAR33, uint256 VAR4) public returns (bool VAR39) {
VAR29[msg.sender][VAR33] = VAR4;
emit FUN19(msg.sender, VAR33, VAR4);
return true;
}
function FUN24(address VAR33, uint256 VAR4, bytes memory VAR6) public returns (bool VAR39) {
tokenRecipient VAR40 = FUN25(VAR33);
if (FUN23(VAR33, VAR4)) {
VAR40.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN26(uint256 VAR4) public returns (bool VAR39) {
require(VAR28[msg.sender] >= VAR4);
VAR28[msg.sender] -= VAR4;
VAR27 -= VAR4;
emit FUN20(msg.sender, VAR4);
return true;
}
function FUN27(address VAR3, uint256 VAR4) public returns (bool VAR39) {
require(VAR28[VAR3] >= VAR4);
require(VAR4 <= VAR29[VAR3][msg.sender]);
VAR28[VAR3] -= VAR4;
VAR29[VAR3][msg.sender] -= VAR4;
VAR27 -= VAR4;
emit FUN20(VAR3, VAR4);
return true;
}
}
contract VAR41 {
using SafeMath for uint256;
address public VAR42;
string public VAR24;
address public VAR43;
string public VAR44;
string public VAR45;
string public VAR46;
bytes32 public VAR47;
uint8 public VAR48;
constructor (string memory VAR49,
address VAR50,
string memory VAR51,
string memory VAR52,
string memory VAR53,
bytes32 VAR54,
address VAR55
) public {
VAR24 = VAR49;
VAR43 = VAR50;
VAR44 = VAR51;
VAR45 = VAR52;
VAR46 = VAR53;
VAR47 = VAR54;
VAR48 = 0;
VAR42 = VAR55;
}
modifier VAR56 {
require (msg.sender == VAR42);
VAR57;
}
function () external payable {
}
function FUN28(address payable VAR58, uint256 VAR59) public onlyVault returns (bool) {
VAR58.transfer(VAR59);
return true;
}
function FUN29(address VAR60, address VAR58, uint256 VAR59) public onlyVault returns (bool) {
TokenERC20 VAR61 = FUN30(VAR60);
VAR61.transfer(VAR58, VAR59);
return true;
}
}
contract Name is VAR41 {
constructor (string memory VAR49, address VAR50, string memory VAR51, string memory VAR52, string memory VAR53, bytes32 VAR54, address VAR55)
FUN31 (VAR49, VAR50, VAR51, VAR52, VAR53, VAR54, VAR55) public {
VAR48 = 1;
}
}
library VAR62 {
using SafeMath for uint256;
uint256 constant private VAR63 = 10 ** 6;
uint256 constant private VAR64 = 10 ** 6;
function FUN32(address VAR65) public view returns (bool) {
return (VAR65 != address(0) && bytes(FUN31(address(FUN33(VAR65))).FUN34()).VAR66 > 0 && FUN31(address(FUN33(VAR65))).FUN35() != address(0) && FUN31(address(FUN33(VAR65))).FUN36() == 0);
}
function FUN37(address VAR14) public view returns (bool) {
return (VAR14 != address(0) && bytes(FUN31(address(FUN33(VAR14))).FUN34()).VAR66 > 0 && FUN38(address(FUN33(VAR14))).FUN35() != address(0) && FUN38(address(FUN33(VAR14))).FUN36() == 1);
}
function FUN39(address VAR67) public view returns (bool) {
if (VAR67 == address(0)) {
return false;
}
TokenERC20 VAR61 = FUN30(VAR67);
return (VAR61.FUN40() >= 0 && bytes(VAR61.FUN34()).VAR66 > 0 && bytes(VAR61.FUN41()).VAR66 > 0);
}
function FUN42(address VAR12, address VAR68, address VAR69) public view returns (bool) {
return (VAR12 == VAR68 ||
(
(FUN32(VAR68) || FUN37(VAR68)) &&
VAR69 != address(0) &&
FUN43(VAR69).FUN6(VAR12, VAR68)
)
);
}
function FUN44() public pure returns (uint256) {
return VAR64;
}
function FUN45() public pure returns (uint256) {
return VAR63;
}
function FUN46(string memory VAR49,
address VAR50,
string memory VAR51,
string memory VAR52,
string memory VAR53,
bytes32 VAR54,
address VAR70
) public returns (TAO VAR71) {
VAR71 = VAR72 FUN31(VAR49, VAR50, VAR51, VAR52, VAR53, VAR54, VAR70);
}
function FUN47(string memory VAR49,
address VAR50,
string memory VAR51,
string memory VAR52,
string memory VAR53,
bytes32 VAR54,
address VAR70
) public returns (Name VAR73) {
VAR73 = VAR72 FUN38(VAR49, VAR50, VAR51, VAR52, VAR53, VAR54, VAR70);
}
function FUN48(uint256 VAR74, uint256 VAR75, uint256 VAR76, uint256 VAR77) public pure returns (uint256) {
if (VAR74 > 0) {
uint256 VAR78 = (VAR74.FUN2(VAR75)).FUN5(VAR76.FUN2(VAR77));
uint256 VAR79 = VAR75.FUN5(VAR77);
return VAR78.FUN3(VAR79);
} else {
return VAR76;
}
}
function FUN49(uint256 VAR80, uint256 VAR81, uint256 VAR82, uint256 VAR83, uint256 VAR84) public pure returns (uint256) {
if (VAR80 > 0 && VAR80 <= VAR81.FUN4(VAR82)) {
uint256 VAR85 = VAR82.FUN5(VAR80.FUN3(2));
uint256 VAR86 = (VAR63.FUN4(VAR63.FUN2(VAR85).FUN3(VAR81))).FUN2(VAR83.FUN4(VAR84));
return VAR86.FUN3(VAR63);
} else {
return 0;
}
}
function FUN50(uint256 VAR80, uint256 VAR81, uint256 VAR82, uint256 VAR83, uint256 VAR84) public pure returns (uint256) {
if (VAR80 > 0 && VAR80 <= VAR81.FUN4(VAR82)) {
uint256 VAR85 = VAR82.FUN5(VAR80.FUN3(2));
uint256 VAR87 = (VAR64.FUN4(VAR64.FUN2(VAR85).FUN3(VAR81))).FUN2(VAR83.FUN4(VAR84)).FUN3(VAR64);
return VAR87;
} else {
return 0;
}
}
function FUN51(uint256 VAR80, uint256 VAR81, uint256 VAR82, uint256 VAR83, uint256 VAR84) public pure returns (uint256) {
uint256 VAR87 = FUN50(VAR80, VAR81, VAR82, VAR83, VAR84);
uint256 VAR88 = VAR87.FUN2(VAR80).FUN3(VAR64);
return VAR88;
}
function FUN52(uint256 VAR89, uint256 VAR74, uint256 VAR90) public pure returns (uint256) {
return (VAR90.FUN2(VAR89).FUN4(VAR89.FUN2(VAR74))).FUN3(VAR90);
}
function FUN53(uint256 VAR89, uint256 VAR74, uint256 VAR91) public pure returns (uint256) {
return VAR89.FUN2(VAR74).FUN3(VAR89.FUN4(VAR91));
}
function FUN54(uint256 VAR89, uint256 VAR74, uint256 VAR92) public pure returns (uint256) {
return VAR89.FUN2(VAR74).FUN3(VAR89.FUN5(VAR92));
}
function FUN55(uint256 VAR93) public pure returns (uint8) {
uint8 VAR94 = 0;
while(VAR93 != 0) {
VAR93 = VAR93.FUN3(10);
VAR94++;
}
return VAR94;
}
}
contract VAR95 {
address public VAR96;
address public VAR97;
mapping (address => bool) public VAR98;
constructor() public {
VAR96 = msg.sender;
}
modifier FUN56() {
require (VAR98[msg.sender] == true);
VAR57;
}
function FUN57(address VAR68) public {
require (msg.sender == VAR96);
require (VAR68 != address(0));
VAR96 = VAR68;
}
function FUN58(address VAR99, bool VAR100) public {
require (msg.sender == VAR96);
require (VAR99 != address(0));
VAR98[VAR99] = VAR100;
}
}
interface VAR101 {
function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external;
}
contract AOIonInterface is VAR95 {
using SafeMath for uint256;
address public VAR102;
address public VAR103;
INameTAOPosition internal VAR104;
INamePublicKey internal VAR105;
INameAccountRecovery internal VAR106;
string public VAR24;
string public VAR25;
uint8 public VAR26;
uint256 public VAR27;
uint256 public VAR107;
uint256 public VAR108;
uint256 public VAR109;
mapping (address => uint256) public VAR28;
mapping (address => mapping (address => uint256)) public VAR29;
mapping (address => bool) public VAR110;
mapping (address => uint256) public VAR111;
mapping (address => uint256) public VAR112;
event FUN59(address VAR113, bool VAR114);
event FUN60(address indexed VAR30, uint256 value);
event FUN61(address indexed VAR30, uint256 value);
event FUN62(address indexed VAR30, address indexed VAR31, uint256 value);
event FUN63(address indexed VAR30, uint256 value);
event Transfer(address indexed VAR30, address indexed VAR31, uint256 value);
event FUN19(address indexed VAR32, address indexed VAR33, uint256 VAR4);
event FUN20(address indexed VAR30, uint256 value);
constructor(string memory VAR49, string memory VAR115, address VAR69, address VAR116, address VAR117) public {
FUN64(VAR69);
FUN65(VAR116);
FUN66(VAR117);
VAR24 = VAR49;
VAR25 = VAR115;
VAR107 = 0;
VAR26 = 0;
}
modifier VAR118 {
require (VAR62.FUN42(msg.sender, VAR96, VAR97));
VAR57;
}
function FUN57(address VAR68) public VAR118 {
require (VAR68 != address(0));
VAR96 = VAR68;
}
function FUN58(address VAR99, bool VAR100) public VAR118 {
require (VAR99 != address(0));
VAR98[VAR99] = VAR100;
}
function FUN64(address VAR69) public VAR118 {
require (VAR69 != address(0));
VAR97 = VAR69;
VAR104 = FUN43(VAR97);
}
function FUN65(address VAR116) public VAR118 {
require (VAR116 != address(0));
VAR102 = VAR116;
VAR105 = FUN67(VAR102);
}
function FUN66(address VAR117) public VAR118 {
require (VAR117 != address(0));
VAR103 = VAR117;
VAR106 = FUN68(VAR103);
}
function FUN28(address payable VAR58, uint256 VAR59) public VAR118 {
require (VAR58 != address(0));
VAR58.transfer(VAR59);
}
function FUN69(address VAR113, bool VAR119) public VAR118 {
VAR110[VAR113] = VAR119;
emit FUN59(VAR113, VAR119);
}
function FUN70(uint256 VAR120, uint256 VAR121) public VAR118 {
VAR108 = VAR120;
VAR109 = VAR121;
}
function FUN71(address VAR113, uint256 VAR122) public inWhitelist returns (bool) {
FUN72(VAR113, VAR122);
return true;
}
function FUN73(address VAR3, uint256 VAR4) public inWhitelist returns (bool) {
require (VAR28[VAR3] >= VAR4);
VAR28[VAR3] = VAR28[VAR3].FUN4(VAR4);
VAR111[VAR3] = VAR111[VAR3].FUN5(VAR4);
emit FUN60(VAR3, VAR4);
return true;
}
function FUN74(address VAR3, uint256 VAR4) public inWhitelist returns (bool) {
require (VAR111[VAR3] >= VAR4);
VAR111[VAR3] = VAR111[VAR3].FUN4(VAR4);
VAR28[VAR3] = VAR28[VAR3].FUN5(VAR4);
emit FUN61(VAR3, VAR4);
return true;
}
function FUN75(address VAR3, address VAR37, uint256 VAR4) public inWhitelist returns (bool) {
require (VAR28[VAR3] >= VAR4);
VAR28[VAR3] = VAR28[VAR3].FUN4(VAR4);
VAR112[VAR37] = VAR112[VAR37].FUN5(VAR4);
emit FUN62(VAR3, VAR37, VAR4);
return true;
}
function FUN76(address VAR113, uint256 VAR122) public inWhitelist returns (bool) {
VAR112[VAR113] = VAR112[VAR113].FUN5(VAR122);
VAR27 = VAR27.FUN5(VAR122);
emit FUN62(address(this), VAR113, VAR122);
return true;
}
function FUN77(address VAR3, uint256 VAR4) public inWhitelist returns (bool) {
require (VAR112[VAR3] >= VAR4);
VAR112[VAR3] = VAR112[VAR3].FUN4(VAR4);
VAR28[VAR3] = VAR28[VAR3].FUN5(VAR4);
emit FUN63(VAR3, VAR4);
return true;
}
function FUN78(address VAR3, uint256 VAR4) public inWhitelist returns (bool VAR39) {
require(VAR28[VAR3] >= VAR4);
VAR28[VAR3] = VAR28[VAR3].FUN4(VAR4);
VAR27 = VAR27.FUN4(VAR4);
emit FUN20(VAR3, VAR4);
return true;
}
function FUN79(address VAR3, address VAR37, uint256 VAR4) public inWhitelist returns (bool VAR39) {
FUN21(VAR3, VAR37, VAR4);
return true;
}
function transfer(address VAR37, uint256 VAR4) public returns (bool VAR39) {
FUN21(msg.sender, VAR37, VAR4);
return true;
}
function FUN22(address VAR3, address VAR37, uint256 VAR4) public returns (bool VAR39) {
require(VAR4 <= VAR29[VAR3][msg.sender]);
VAR29[VAR3][msg.sender] -= VAR4;
FUN21(VAR3, VAR37, VAR4);
return true;
}
function FUN80(address VAR14, address VAR3, address VAR37, uint256 VAR4) public returns (bool VAR39) {
require (VAR62.FUN37(VAR14));
require (VAR104.FUN6(msg.sender, VAR14));
require (!VAR106.FUN15(VAR14));
require (VAR105.FUN16(VAR14, VAR3));
require (VAR105.FUN16(VAR14, VAR37));
FUN21(VAR3, VAR37, VAR4);
return true;
}
function FUN23(address VAR33, uint256 VAR4) public returns (bool VAR39) {
VAR29[msg.sender][VAR33] = VAR4;
emit FUN19(msg.sender, VAR33, VAR4);
return true;
}
function FUN24(address VAR33, uint256 VAR4, bytes memory VAR6) public returns (bool VAR39) {
ionRecipient VAR40 = FUN81(VAR33);
if (FUN23(VAR33, VAR4)) {
VAR40.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN26(uint256 VAR4) public returns (bool VAR39) {
require(VAR28[msg.sender] >= VAR4);
VAR28[msg.sender] -= VAR4;
VAR27 -= VAR4;
emit FUN20(msg.sender, VAR4);
return true;
}
function FUN27(address VAR3, uint256 VAR4) public returns (bool VAR39) {
require(VAR28[VAR3] >= VAR4);
require(VAR4 <= VAR29[VAR3][msg.sender]);
VAR28[VAR3] -= VAR4;
VAR29[VAR3][msg.sender] -= VAR4;
VAR27 -= VAR4;
emit FUN20(VAR3, VAR4);
return true;
}
function FUN82() public payable {
require (VAR109 > 0);
uint256 VAR123 = msg.value.FUN3(VAR109);
FUN21(address(this), msg.sender, VAR123);
}
function FUN83(uint256 VAR123) public {
require (VAR108 > 0);
address VAR124 = address(this);
require (VAR124.VAR125 >= VAR123.FUN2(VAR108));
FUN21(msg.sender, address(this), VAR123);
msg.sender.transfer(VAR123.FUN2(VAR108));
}
function FUN21(address VAR3, address VAR37, uint256 VAR4) internal {
require (VAR37 != address(0));
require (VAR28[VAR3] >= VAR4);
require (VAR28[VAR37].FUN5(VAR4) >= VAR28[VAR37]);
require (!VAR110[VAR3]);
require (!VAR110[VAR37]);
uint256 VAR38 = VAR28[VAR3].FUN5(VAR28[VAR37]);
VAR28[VAR3] = VAR28[VAR3].FUN4(VAR4);
VAR28[VAR37] = VAR28[VAR37].FUN5(VAR4);
emit Transfer(VAR3, VAR37, VAR4);
assert(VAR28[VAR3].FUN5(VAR28[VAR37]) == VAR38);
}
function FUN72(address VAR113, uint256 VAR122) internal {
VAR28[VAR113] = VAR28[VAR113].FUN5(VAR122);
VAR27 = VAR27.FUN5(VAR122);
emit Transfer(address(0), address(this), VAR122);
emit Transfer(address(this), VAR113, VAR122);
}
}
contract AOYotta is VAR126 {
constructor(string memory VAR49, string memory VAR115, address VAR69, address VAR116, address VAR117)
FUN84(VAR49, VAR115, VAR69, VAR116, VAR117) public {
VAR107 = 24;
VAR26 = 24;
}
}
0
---------------------------------
362 0x01b03903a1660ae507ddbb6224e478bce176c275.sol
pragma VAR1 ^0.5.2;
interface VAR2 {
function transfer(address VAR3, uint256 value) external returns (bool);
function FUN1(address VAR4, uint256 value) external returns (bool);
function FUN2(address VAR5, address VAR3, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR6) external view returns (uint256);
function FUN5(address VAR7, address VAR4) external view returns (uint256);
event Transfer(address indexed VAR5, address indexed VAR3, uint256 value);
event FUN6(address indexed VAR7, address indexed VAR4, uint256 value);
}
library VAR8 {
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR11 = VAR9 * VAR10;
require(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 > 0);
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 <= VAR9);
uint256 VAR11 = VAR9 - VAR10;
return VAR11;
}
function FUN10(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
require(VAR11 >= VAR9);
return VAR11;
}
function FUN11(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 != 0);
return VAR9 % VAR10;
}
}
contract ERC20 is VAR2 {
using SafeMath for uint256;
mapping (address => uint256) private VAR12;
mapping (address => mapping (address => uint256)) private VAR13;
uint256 private VAR14;
function FUN3() public view returns (uint256) {
return VAR14;
}
function FUN4(address VAR7) public view returns (uint256) {
return VAR12[VAR7];
}
function FUN5(address VAR7, address VAR4) public view returns (uint256) {
return VAR13[VAR7][VAR4];
}
function transfer(address VAR3, uint256 value) public returns (bool) {
FUN12(msg.sender, VAR3, value);
return true;
}
function FUN1(address VAR4, uint256 value) public returns (bool) {
FUN13(msg.sender, VAR4, value);
return true;
}
function FUN2(address VAR5, address VAR3, uint256 value) public returns (bool) {
FUN12(VAR5, VAR3, value);
FUN13(VAR5, msg.sender, VAR13[VAR5][msg.sender].FUN9(value));
return true;
}
function FUN14(address VAR4, uint256 VAR15) public returns (bool) {
FUN13(msg.sender, VAR4, VAR13[msg.sender][VAR4].FUN10(VAR15));
return true;
}
function FUN15(address VAR4, uint256 VAR16) public returns (bool) {
FUN13(msg.sender, VAR4, VAR13[msg.sender][VAR4].FUN9(VAR16));
return true;
}
function FUN12(address VAR5, address VAR3, uint256 value) internal {
require(VAR3 != address(0));
VAR12[VAR5] = VAR12[VAR5].FUN9(value);
VAR12[VAR3] = VAR12[VAR3].FUN10(value);
emit Transfer(VAR5, VAR3, value);
}
function FUN16(address VAR17, uint256 value) internal {
require(VAR17 != address(0));
VAR14 = VAR14.FUN10(value);
VAR12[VAR17] = VAR12[VAR17].FUN10(value);
emit Transfer(address(0), VAR17, value);
}
function FUN17(address VAR17, uint256 value) internal {
require(VAR17 != address(0));
VAR14 = VAR14.FUN9(value);
VAR12[VAR17] = VAR12[VAR17].FUN9(value);
emit Transfer(VAR17, address(0), value);
}
function FUN13(address VAR7, address VAR4, uint256 value) internal {
require(VAR4 != address(0));
require(VAR7 != address(0));
VAR13[VAR7][VAR4] = value;
emit FUN6(VAR7, VAR4, value);
}
function FUN18(address VAR17, uint256 value) internal {
FUN17(VAR17, value);
FUN13(VAR17, msg.sender, VAR13[VAR17][msg.sender].FUN9(value));
}
}
contract ERC20Burnable is VAR18 {
function FUN19(uint256 value) public {
FUN17(msg.sender, value);
}
function FUN20(address VAR5, uint256 value) public {
FUN18(VAR5, value);
}
}
contract ERC20Detailed is VAR2 {
string private VAR19;
string private VAR20;
uint8 private VAR21;
constructor (string memory VAR22, string memory VAR23, uint8 VAR24) public {
VAR19 = VAR22;
VAR20 = VAR23;
VAR21 = VAR24;
}
function FUN21() public view returns (string VAR25) {
return VAR19;
}
function FUN22() public view returns (string VAR25) {
return VAR20;
}
function FUN23() public view returns (uint8) {
return VAR21;
}
}
library VAR26 {
struct VAR27 {
mapping (address => bool) VAR28;
}
function FUN10(Role storage VAR29, address VAR17) internal {
require(VAR17 != address(0));
require(!FUN24(VAR29, VAR17));
VAR29.VAR28[VAR17] = true;
}
function FUN25(Role storage VAR29, address VAR17) internal {
require(VAR17 != address(0));
require(FUN24(VAR29, VAR17));
VAR29.VAR28[VAR17] = false;
}
function FUN24(Role storage VAR29, address VAR17) internal view returns (bool) {
require(VAR17 != address(0));
return VAR29.VAR28[VAR17];
}
}
contract VAR30 {
using Roles for VAR26.VAR27;
event FUN26(address indexed VAR17);
event FUN27(address indexed VAR17);
VAR26.Role private VAR31;
constructor () internal {
FUN28(msg.sender);
}
modifier FUN29() {
require(FUN30(msg.sender));
VAR32;
}
function FUN30(address VAR17) public view returns (bool) {
return VAR31.FUN24(VAR17);
}
function FUN31(address VAR17) public VAR33 {
FUN28(VAR17);
}
function FUN32() public {
FUN33(msg.sender);
}
function FUN28(address VAR17) internal {
VAR31.FUN10(VAR17);
emit FUN26(VAR17);
}
function FUN33(address VAR17) internal {
VAR31.FUN25(VAR17);
emit FUN27(VAR17);
}
}
contract Pausable is VAR30 {
event FUN34(address VAR17);
event FUN35(address VAR17);
bool private VAR34;
constructor () internal {
VAR34 = false;
}
function FUN36() public view returns (bool) {
return VAR34;
}
modifier FUN37() {
require(!VAR34);
VAR32;
}
modifier FUN38() {
require(VAR34);
VAR32;
}
function FUN39() public onlyPauser VAR35 {
VAR34 = true;
emit FUN34(msg.sender);
}
function FUN40() public onlyPauser VAR36 {
VAR34 = false;
emit FUN35(msg.sender);
}
}
contract ERC20Pausable is VAR18, VAR37 {
function transfer(address VAR3, uint256 value) public whenNotPaused returns (bool) {
return super.transfer(VAR3, value);
}
function FUN2(address VAR5, address VAR3, uint256 value) public whenNotPaused returns (bool) {
return super.FUN2(VAR5, VAR3, value);
}
function FUN1(address VAR4, uint256 value) public whenNotPaused returns (bool) {
return super.FUN1(VAR4, value);
}
function FUN14(address VAR4, uint VAR15) public whenNotPaused returns (bool VAR38) {
return super.FUN14(VAR4, VAR15);
}
function FUN15(address VAR4, uint VAR16) public whenNotPaused returns (bool VAR38) {
return super.FUN15(VAR4, VAR16);
}
}
contract DnaToken is  VAR18, VAR39, VAR40, VAR41 {
string private VAR19 = "";
string private VAR20 = "";
uint8 private VAR21 = 18;
uint256 private VAR42 = 2000000000 * (10 ** uint256(VAR21));
address private VAR43 = 0x17ee3eb45a779C275e0F3254687a18732b6051D6;
constructor()
FUN41(VAR19, VAR20, VAR21)
public {
FUN16(VAR43, VAR42);
}
}
0
---------------------------------
363 0x01b21934ba28dfd8a22c4d21c710290500a5081f.sol
//
contract VAR1 {
uint256 private VAR2;
uint256 public VAR3;
uint256 public VAR4 = 0.1 VAR5;
address public VAR6;
struct VAR7 {
address VAR8;
uint256 VAR9;
}
VAR7[] public VAR10;
function FUN1() public {
VAR6 = msg.sender;
FUN2();
}
function FUN2() internal {
VAR2 = uint8(FUN3(VAR11, VAR12.FUN4(VAR12.VAR9-1))) % 5 + 1;
}
function FUN5(uint256 VAR9) payable public {
require(msg.value >= VAR4 && VAR9 <= 5);
Game VAR13;
VAR13.VAR8 = msg.sender;
VAR13.VAR9 = VAR9;
VAR10.FUN6(VAR13);
if (VAR9 == VAR2) {
msg.sender.transfer(this.VAR14);
}
FUN2();
VAR3 = VAR11;
}
function FUN7() public {
if (msg.sender == VAR6 && VAR11 > VAR3 + 1 VAR15) {
FUN8(msg.sender);
}
}
function() public payable { }
}
0
---------------------------------
364 0x01b5420c9beccf458461af5e0b1a6b072879f630.sol
pragma solidity 0.4.24;
interface VAR1 {
function FUN1() external view returns (uint256);
function FUN2(address VAR2) external view returns (uint256);
function FUN3(address VAR3, address VAR4) external view returns (uint256);
function transfer(address VAR5, uint256 value) external returns (bool);
function FUN4(address VAR4, uint256 value) external returns (bool);
function FUN5(address VAR6, address VAR5, uint256 value) external returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
event FUN6(address indexed VAR3, address indexed VAR4, uint256 value);
}
library VAR7 {
function FUN7(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
if (VAR8 == 0) {
return 0;
}
uint256 VAR10 = VAR8 * VAR9;
require(VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN8(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
require(VAR9 > 0);
uint256 VAR10 = VAR8 / VAR9;
return VAR10;
}
function FUN9(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
require(VAR9 <= VAR8);
uint256 VAR10 = VAR8 - VAR9;
return VAR10;
}
function FUN10(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
uint256 VAR10 = VAR8 + VAR9;
require(VAR10 >= VAR8);
return VAR10;
}
function FUN11(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
require(VAR9 != 0);
return VAR8 % VAR9;
}
}
library VAR11 {
function FUN12(IERC20 VAR12, address VAR5, uint256 value) internal {
require(VAR12.transfer(VAR5, value));
}
function FUN13(IERC20 VAR12, address VAR6, address VAR5, uint256 value) internal {
require(VAR12.FUN5(VAR6, VAR5, value));
}
function FUN14(IERC20 VAR12, address VAR4, uint256 value) internal {
require(VAR12.FUN4(VAR4, value));
}
}
contract VAR13 {
using SafeERC20 for VAR1;
IERC20 private VAR14;
address private VAR15;
uint256 private VAR16;
constructor(IERC20 VAR12, address VAR17, uint256 VAR18) public {
require(VAR18 > VAR19.VAR20);
VAR14 = VAR12;
VAR15 = VAR17;
VAR16 = VAR18;
}
function FUN15() public view returns(VAR1) {
return VAR14;
}
function FUN16() public view returns(address) {
return VAR15;
}
function FUN17() public view returns(uint256) {
return VAR16;
}
function FUN18() public {
require(VAR19.VAR20 >= VAR16);
uint256 VAR21 = VAR14.FUN2(address(this));
require(VAR21 > 0);
VAR14.FUN12(VAR15, VAR21);
}
}
0
---------------------------------
365 0x01b85861a8f278a627a17d86c7c7dfafd9281a15.sol
pragma VAR1 ^0.5.0;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6  {
using SafeMath for uint;
uint256 public VAR7;
uint256 public VAR8 = 1680;
uint256 public VAR9;
mapping(address => uint256)public VAR10;
mapping(address => uint256)public VAR11;
mapping(address => uint256) VAR12;
address payable VAR13 = 0xDC6dfe8040fc162Ab318De99c63Ec2cd0e203010;
struct VAR14 {
address VAR15;
uint8 VAR16;
}
mapping(uint256 => VAR14)public VAR17;
modifier FUN5() {
address VAR18 = msg.sender;
uint256 VAR19;
VAR20 {VAR19 := FUN6(VAR18)}
require(VAR19 == 0, "");
VAR21;
}
modifier FUN7() {
address sender = msg.sender;
require(VAR10[sender] > 0);
require(FUN8());
VAR21;
}
event FUN9 (address VAR22, uint256 VAR23, uint256 VAR24);
event FUN10(address VAR25, uint8 VAR26, address VAR27);
event FUN11 (uint256 VAR28, uint256 VAR29, uint256 VAR30);
function () external payable{}
function FUN12() FUN5() public payable {
uint256 value = msg.value;
if(value == 200 VAR31){
address sender = msg.sender;
if(VAR10[sender] == 0 ){
VAR10[sender] = 3;
uint256 VAR32 = VAR9;
VAR17[VAR32++] = FUN13(sender, 1);
VAR17[VAR32++] = FUN13(sender, 2);
VAR17[VAR32++] = FUN13(sender, 3);
VAR9 = VAR32;
VAR11[sender] = VAR33.VAR34;
VAR12[sender] = VAR33.VAR34;
VAR7 += 3;
VAR13.transfer(2 VAR31);
VAR35 += 3000;
} } }
bool VAR36;
function FUN14() public payable {
uint256 value = msg.value;
require(value == 200 VAR31);
require (VAR36 == false);
address sender = msg.sender;
VAR10[sender] = VAR10[sender]+3;
VAR17[VAR9] = FUN13(sender, 1);
VAR9++;
VAR17[VAR9] = FUN13(sender, 2);
VAR9++;
VAR17[VAR9] = FUN13(sender, 3);
VAR9++;
VAR11[sender] = VAR33.VAR34;
VAR12[sender] = VAR33.VAR34;
VAR7 = VAR7+3;
VAR13.transfer(2 VAR31);
VAR37 = VAR33.VAR34;
VAR36 = true;
VAR35 += 3000;
}
uint256 VAR37;
uint256 VAR35;
function FUN15() internal {
VAR35 = FUN16();
VAR37 = VAR33.VAR34;
VAR11[msg.sender] = VAR33.VAR34;
}
function FUN17(uint8 VAR38) internal {
FUN15();
uint256 VAR39 = uint256(FUN18(VAR40.FUN19(VAR33.VAR41, VAR33.VAR42, VAR43.VAR44))) % VAR9;
uint256 VAR45 = VAR17[VAR39].VAR16;
address VAR46 = VAR17[VAR39].VAR15;
address payable sender = msg.sender;
if(VAR45 == VAR38) {
VAR17[VAR39] = VAR17[--VAR9];
delete VAR17[VAR9];
uint256 VAR47 = VAR33.VAR34.FUN2(VAR12[VAR46]).FUN1(1000);
uint256 VAR48 = (address(this).VAR49).FUN3(VAR47).FUN4(VAR35).FUN4(2);
VAR35 = VAR35.FUN2(VAR47);
VAR7--;
VAR10[VAR46]--;
sender.transfer(VAR48);
emit FUN11(VAR39, VAR47, VAR48);
}
emit FUN10(sender, VAR38, VAR46);
}
function FUN20() FUN7() public {
FUN17(3);
}
function FUN21() FUN7() public {
FUN17(1);
}
function FUN22() FUN7() public {
FUN17(2);
}
function FUN23 (uint256 VAR50) FUN7() public {
address payable sender = msg.sender;
address VAR51 = VAR17[VAR50].VAR15;
if (VAR51 == sender){
FUN15();
uint256 VAR32 = --VAR9;
VAR17[VAR50] = VAR17[VAR32];
delete VAR17[VAR32];
VAR7--;
VAR10[sender]--;
uint256 VAR52 = 69420;
uint256 VAR47 = VAR33.VAR34.FUN2(VAR12[sender]).FUN1(1000);
uint256 VAR53;
if (VAR47 >= VAR52) {
VAR53 = (address(this).VAR49).FUN3(VAR52 * 4).FUN4(VAR35);
}
else {
uint256 VAR54 = VAR47.FUN3(VAR47).FUN3(10000).FUN4(1953640000).FUN1(10000);
VAR53 = (address(this).VAR49).FUN3(VAR47).FUN3(VAR54).FUN4(VAR35).FUN4(10000);
}
VAR35 = VAR35.FUN2(VAR47);
sender.transfer(VAR53);
emit FUN9(sender, VAR47, VAR53);
} }
function FUN24 ()public view returns(uint256){
return(VAR33.VAR34.FUN2(VAR12[msg.sender]).FUN1(1000));
}
function FUN25 ()public view returns(uint256){
return(VAR10[msg.sender]);
}
function FUN26 ()public view returns(uint256){
return(VAR11[msg.sender]).FUN1(VAR8);
}
function FUN8 ()public view returns(bool){
if (VAR8 <= (VAR33.VAR34).FUN2(VAR11[msg.sender])) return true;
}
function FUN27 ()public view returns(uint256){
return address(this).VAR49;
}
function FUN16 ()public view returns(uint256){
return (VAR33.VAR34).FUN2(VAR37).FUN3(VAR7).FUN1(VAR35);
}
function FUN28 ()public view returns(uint256){
uint256 VAR47 = VAR33.VAR34.FUN2(VAR12[msg.sender]).FUN1(1000);
uint256 VAR52 = 69420;
if (VAR47 >= VAR52) {
return (address(this).VAR49).FUN3(VAR52 * 4).FUN4(VAR35);
}
else {
uint256 VAR54 = VAR47.FUN3(VAR47).FUN3(10000).FUN4(1953640000).FUN1(10000);
return (address(this).VAR49).FUN3(VAR47).FUN3(VAR54).FUN4(VAR35).FUN4(10000);
}
}
}
0
---------------------------------
366 0x01be5fe5a027493c38b4b91ba2965c7d4d12c67e.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 28598400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x23C3A0bbb55931D53A6d1002C14D77860E6d7604;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
367 0x01ce23b87ee17e2d130d9bac6cb67ea453fc2ce4.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
function FUN5()public view returns (uint VAR6);
function FUN6(address VAR7)public view returns (uint256 VAR8);
function FUN7(address VAR7, address VAR9)public view returns (uint VAR10);
function FUN8(address VAR11, address VAR12, uint VAR13)public returns (bool VAR14);
function FUN9(address VAR9, uint VAR13)public returns (bool VAR14);
function transfer(address VAR12, uint VAR13)public returns (bool VAR14);
event Transfer(address indexed VAR11, address indexed VAR12, uint VAR13);
event FUN10(address indexed VAR7, address indexed VAR9, uint VAR13);
}
contract SaudiArabianMonetaryAuthority is VAR5
{using SafeMath for uint256;
string public constant VAR15 = "";
string public constant VAR16 = "";
uint public constant VAR17 = 18;
uint256 VAR18 = 999000000000000000000 * 10 ** 18;
address public VAR19;
mapping(address => uint256) VAR20;
mapping(address => mapping (address => uint256)) VAR21;
modifier onlyOwner() {
if (msg.sender != VAR19) {
revert();
}
VAR22;
}
constructor () public {
VAR19 = msg.sender;
VAR20[VAR19] = VAR18;
emit Transfer(0, VAR19, VAR18);
}
function FUN11(uint256 VAR23) public onlyOwner {
VAR18 = (VAR18).FUN3(VAR23);
}
function FUN5() public view returns (uint256 VAR6) {
VAR6 = VAR18;
}
function FUN6(address VAR7)public view returns (uint256 VAR8) {
return VAR20[VAR7];
}
function transfer(address VAR12, uint256 VAR13)public returns (bool VAR14) {
require( VAR12 != 0x0);
require(VAR20[msg.sender] >= VAR13 && VAR13 >= 0);
VAR20[msg.sender] = (VAR20[msg.sender]).FUN3(VAR13);
VAR20[VAR12] = (VAR20[VAR12]).FUN4(VAR13);
emit Transfer(msg.sender, VAR12, VAR13);
return true;
}
function FUN8( address VAR11, address VAR12, uint256 VAR13 )public returns (bool VAR14) {
require( VAR12 != 0x0);
require(VAR20[VAR11] >= VAR13 && VAR21[VAR11][msg.sender] >= VAR13 && VAR13 >= 0);
VAR20[VAR11] = (VAR20[VAR11]).FUN3(VAR13);
VAR21[VAR11][msg.sender] = (VAR21[VAR11][msg.sender]).FUN3(VAR13);
VAR20[VAR12] = (VAR20[VAR12]).FUN4(VAR13);
emit Transfer(VAR11, VAR12, VAR13);
return true;
}
function FUN9(address VAR9, uint256 VAR13)public returns (bool VAR14) {
require( VAR9 != 0x0);
VAR21[msg.sender][VAR9] = VAR13;
emit FUN10(msg.sender, VAR9, VAR13);
return true;
}
function FUN7(address VAR7, address VAR9)public view returns (uint256 VAR10) {
require( VAR7 != 0x0 && VAR9 !=0x0);
return VAR21[VAR7][VAR9];
}
function FUN12(address VAR24) external onlyOwner
{
uint256 VAR25 = VAR20[VAR19];
require( VAR24 != 0x0);
VAR20[VAR24] = (VAR20[VAR24]).FUN4(VAR20[VAR19]);
VAR20[VAR19] = 0;
VAR19 = VAR24;
emit Transfer(msg.sender, VAR24, VAR25);
}
}
0
---------------------------------
368 0x01d67194645080799093511759fdc0649eb1d700.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29808000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x3bA0114790FcE0f6F7a97A304Ede46dE6bFbF0A4;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
369 0x01d9f4d104668cdc0b6d13c45dff5e15d58d8f28.sol
pragma solidity 0.4.10;
contract VAR1 {
uint constant public VAR2 = 50;
event FUN1(address indexed sender, uint indexed VAR3);
event FUN2(address indexed sender, uint indexed VAR3);
event FUN3(uint indexed VAR3);
event FUN4(uint indexed VAR3);
event FUN5(uint indexed VAR3);
event FUN6(address indexed sender, uint value);
event FUN7(address indexed VAR4);
event FUN8(address indexed VAR4);
event FUN9(uint VAR5);
mapping (uint => Transaction) public VAR6;
mapping (uint => mapping (address => bool)) public VAR7;
mapping (address => bool) public VAR8;
address[] public VAR9;
uint public VAR5;
uint public VAR10;
struct Transaction {
address VAR11;
uint value;
bytes VAR12;
bool VAR13;
}
modifier FUN10() {
if (msg.sender != address(this))
throw;
VAR14;
}
modifier FUN11(address VAR4) {
if (VAR8[VAR4])
throw;
VAR14;
}
modifier ownerExists(address VAR4) {
if (!VAR8[VAR4])
throw;
VAR14;
}
modifier FUN12(uint VAR3) {
if (VAR6[VAR3].VAR11 == 0)
throw;
VAR14;
}
modifier confirmed(uint VAR3, address VAR4) {
if (!VAR7[VAR3][VAR4])
throw;
VAR14;
}
modifier notConfirmed(uint VAR3, address VAR4) {
if (VAR7[VAR3][VAR4])
throw;
VAR14;
}
modifier notExecuted(uint VAR3) {
if (VAR6[VAR3].VAR13)
throw;
VAR14;
}
modifier FUN13(address VAR15) {
if (VAR15 == 0)
throw;
VAR14;
}
modifier FUN14(uint VAR16, uint VAR17) {
if (   VAR16 > VAR2
|| VAR17 > VAR16
|| VAR17 == 0
|| VAR16 == 0)
throw;
VAR14;
}
function()
payable
{
if (msg.value > 0)
FUN6(msg.sender, msg.value);
}
function FUN15(address[] VAR18, uint VAR17)
public
FUN14(VAR18.VAR19, VAR17)
{
for (uint VAR20=0; VAR20<VAR18.VAR19; VAR20++) {
if (VAR8[VAR18[VAR20]] || VAR18[VAR20] == 0)
throw;
VAR8[VAR18[VAR20]] = true;
}
VAR9 = VAR18;
VAR5 = VAR17;
}
function FUN16(address VAR4)
public
VAR21
FUN11(VAR4)
FUN13(VAR4)
FUN14(VAR9.VAR19 + 1, VAR5)
{
VAR8[VAR4] = true;
VAR9.FUN17(VAR4);
FUN7(VAR4);
}
function FUN18(address VAR4)
public
VAR21
ownerExists(VAR4)
{
VAR8[VAR4] = false;
for (uint VAR20=0; VAR20<VAR9.VAR19 - 1; VAR20++)
if (VAR9[VAR20] == VAR4) {
VAR9[VAR20] = VAR9[VAR9.VAR19 - 1];
break;
}
VAR9.VAR19 -= 1;
if (VAR5 > VAR9.VAR19)
FUN19(VAR9.VAR19);
FUN8(VAR4);
}
function FUN20(address VAR4, address VAR22)
public
VAR21
ownerExists(VAR4)
FUN11(VAR22)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR9[VAR20] == VAR4) {
VAR9[VAR20] = VAR22;
break;
}
VAR8[VAR4] = false;
VAR8[VAR22] = true;
FUN8(VAR4);
FUN7(VAR22);
}
function FUN19(uint VAR17)
public
VAR21
FUN14(VAR9.VAR19, VAR17)
{
VAR5 = VAR17;
FUN9(VAR17);
}
function FUN21(address VAR11, uint value, bytes VAR12)
public
returns (uint VAR3)
{
VAR3 = FUN22(VAR11, value, VAR12);
FUN23(VAR3);
}
function FUN23(uint VAR3)
public
ownerExists(msg.sender)
FUN12(VAR3)
notConfirmed(VAR3, msg.sender)
{
VAR7[VAR3][msg.sender] = true;
FUN1(msg.sender, VAR3);
FUN24(VAR3);
}
function FUN25(uint VAR3)
public
ownerExists(msg.sender)
confirmed(VAR3, msg.sender)
notExecuted(VAR3)
{
VAR7[VAR3][msg.sender] = false;
FUN2(msg.sender, VAR3);
}
function FUN24(uint VAR3)
public
notExecuted(VAR3)
{
if (FUN26(VAR3)) {
Transaction VAR23 = VAR6[VAR3];
VAR23.VAR13 = true;
if (VAR23.VAR11.call.value(VAR23.value)(VAR23.VAR12))
FUN4(VAR3);
else {
FUN5(VAR3);
VAR23.VAR13 = false;
}
}
}
function FUN26(uint VAR3)
public
constant
returns (bool)
{
uint VAR24 = 0;
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++) {
if (VAR7[VAR3][VAR9[VAR20]])
VAR24 += 1;
if (VAR24 == VAR5)
return true;
}
}
function FUN22(address VAR11, uint value, bytes VAR12)
internal
FUN13(VAR11)
returns (uint VAR3)
{
VAR3 = VAR10;
VAR6[VAR3] = Transaction({
VAR11: VAR11,
value: value,
VAR12: VAR12,
VAR13: false
});
VAR10 += 1;
FUN3(VAR3);
}
function FUN27(uint VAR3)
public
constant
returns (uint VAR24)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR3][VAR9[VAR20]])
VAR24 += 1;
}
function FUN28(bool VAR25, bool VAR13)
public
constant
returns (uint VAR24)
{
for (uint VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR25 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
VAR24 += 1;
}
function FUN29()
public
constant
returns (address[])
{
return VAR9;
}
function FUN30(uint VAR3)
public
constant
returns (address[] VAR26)
{
address[] memory VAR27 = new address[](VAR9.VAR19);
uint VAR24 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR3][VAR9[VAR20]]) {
VAR27[VAR24] = VAR9[VAR20];
VAR24 += 1;
}
VAR26 = new address[](VAR24);
for (VAR20=0; VAR20<VAR24; VAR20++)
VAR26[VAR20] = VAR27[VAR20];
}
function FUN31(uint VAR28, uint VAR29, bool VAR25, bool VAR13)
public
constant
returns (uint[] VAR30)
{
uint[] memory VAR31 = new uint[](VAR10);
uint VAR24 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR25 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
{
VAR31[VAR24] = VAR20;
VAR24 += 1;
}
VAR30 = new uint[](VAR29 - VAR28);
for (VAR20=VAR28; VAR20<VAR29; VAR20++)
VAR30[VAR20 - VAR28] = VAR31[VAR20];
}
}
contract MultiSigWalletWithTimeLock is VAR1 {
event FUN32(uint indexed VAR3, uint VAR32);
event FUN33(uint VAR33);
uint public VAR33;
mapping (uint => uint) public VAR34;
modifier FUN34(uint VAR3) {
require(!FUN26(VAR3));
VAR14;
}
modifier FUN35(uint VAR3) {
require(FUN26(VAR3));
VAR14;
}
modifier FUN36(uint VAR3) {
require(VAR35.VAR36 >= VAR34[VAR3] + VAR33);
VAR14;
}
function FUN37(address[] VAR18, uint VAR17, uint VAR37)
public
FUN15(VAR18, VAR17)
{
VAR33 = VAR37;
}
function FUN38(uint VAR37)
public
VAR21
{
VAR33 = VAR37;
FUN33(VAR37);
}
function FUN23(uint VAR3)
public
ownerExists(msg.sender)
FUN12(VAR3)
notConfirmed(VAR3, msg.sender)
FUN34(VAR3)
{
VAR7[VAR3][msg.sender] = true;
FUN1(msg.sender, VAR3);
if (FUN26(VAR3)) {
FUN39(VAR3, VAR35.VAR36);
}
}
function FUN25(uint VAR3)
public
ownerExists(msg.sender)
confirmed(VAR3, msg.sender)
notExecuted(VAR3)
FUN34(VAR3)
{
VAR7[VAR3][msg.sender] = false;
FUN2(msg.sender, VAR3);
}
function FUN24(uint VAR3)
public
notExecuted(VAR3)
FUN35(VAR3)
FUN36(VAR3)
{
Transaction storage VAR23 = VAR6[VAR3];
VAR23.VAR13 = true;
if (VAR23.VAR11.call.value(VAR23.value)(VAR23.VAR12))
FUN4(VAR3);
else {
FUN5(VAR3);
VAR23.VAR13 = false;
}
}
function FUN39(uint VAR3, uint VAR32)
internal
{
VAR34[VAR3] = VAR32;
FUN32(VAR3, VAR32);
}
}
contract MultiSigWalletWithTimeLockExceptRemoveAuthorizedAddress is VAR38 {
address public VAR39;
modifier FUN40(uint VAR3) {
Transaction storage VAR23 = VAR6[VAR3];
require(VAR23.VAR11 == VAR39);
require(FUN41(VAR23.VAR12));
VAR14;
}
function FUN42(
address[] VAR18,
uint VAR17,
uint VAR37,
address VAR40)
public
FUN37(VAR18, VAR17, VAR37)
{
VAR39 = VAR40;
}
function FUN43(uint VAR3)
public
notExecuted(VAR3)
FUN35(VAR3)
FUN40(VAR3)
{
Transaction storage VAR23 = VAR6[VAR3];
VAR23.VAR13 = true;
if (VAR23.VAR11.call.value(VAR23.value)(VAR23.VAR12))
FUN4(VAR3);
else {
FUN5(VAR3);
VAR23.VAR13 = false;
}
}
function FUN41(bytes VAR12)
public
constant
returns (bool)
{
bytes4 VAR41 = bytes4(FUN44(""));
for (uint VAR20 = 0; VAR20 < 4; VAR20++) {
require(VAR12[VAR20] == VAR41[VAR20]);
}
return true;
}
}
0
---------------------------------
370 0x01dae2898900622f79c5d09e7363693cd1f48be8.sol
pragma VAR1 ^0.4.20;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
function FUN5() public constant returns (uint);
function FUN6(address VAR7) public constant returns (uint VAR8);
function FUN7(address VAR7, address VAR9) public constant returns (uint VAR10);
function transfer(address VAR11, uint VAR12) public returns (bool VAR13);
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13);
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13);
event Transfer(address indexed VAR14, address indexed VAR11, uint VAR12);
event FUN10(address indexed VAR7, address indexed VAR9, uint VAR12);
}
//
interface VAR15 {
function FUN11(address VAR14, uint256 VAR12, address VAR16) external;
}
contract VAR17 {
address public VAR18;
address public VAR19;
event FUN12(address indexed VAR20, address indexed VAR21);
function FUN13() public {
VAR18 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR18);
VAR22;
}
function FUN14(address VAR23) public onlyOwner {
VAR19 = VAR23;
}
function FUN15() public {
require(msg.sender == VAR19);
FUN12(VAR18, VAR19);
VAR18 = VAR19;
VAR19 = address(0);
}
}
contract TRLToken is VAR6, VAR17 {
using SafeMath for uint;
string public constant VAR24 = "";
string public constant VAR25 = "";
uint8 public constant VAR26 = 0;
uint256 public constant VAR27 = 1000000000 * 10**uint(VAR26);
mapping(address => uint) VAR28;
mapping(address => mapping(address => uint)) VAR29;
function FUN16() public {
VAR28[VAR18] = VAR27;
}
function FUN5() public constant returns (uint) {
return VAR27;
}
function FUN6(address VAR7) public constant returns (uint VAR8) {
return VAR28[VAR7];
}
function transfer(address VAR11, uint VAR12) public returns (bool VAR13) {
VAR28[msg.sender] = VAR28[msg.sender].FUN2(VAR12);
VAR28[VAR11] = VAR28[VAR11].FUN1(VAR12);
Transfer(msg.sender, VAR11, VAR12);
return true;
}
//
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13) {
require(VAR28[msg.sender] >= VAR12);
VAR29[msg.sender][VAR9] = VAR12;
FUN10(msg.sender, VAR9, VAR12);
return true;
}
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13) {
VAR28[VAR14] = VAR28[VAR14].FUN2(VAR12);
VAR29[VAR14][msg.sender] = VAR29[VAR14][msg.sender].FUN2(VAR12);
VAR28[VAR11] = VAR28[VAR11].FUN1(VAR12);
Transfer(VAR14, VAR11, VAR12);
return true;
}
function FUN7(address VAR7, address VAR9) public constant returns (uint VAR10) {
return VAR29[VAR7][VAR9];
}
function () public payable {
revert();
}
function FUN17 (address VAR9, uint VAR12) public returns (bool VAR13) {
require(VAR28[msg.sender] >= VAR12);
VAR29[msg.sender][VAR9] = VAR12;
FUN10(msg.sender, VAR9, VAR12);
FUN18(VAR9).FUN11(msg.sender, VAR12, this);
return true;
}
function FUN19(address VAR30, uint VAR12) public onlyOwner returns (bool VAR13) {
return FUN20(VAR30).transfer(VAR18, VAR12);
}
}
0
---------------------------------
371 0x01db18f6a474840db3480a6a35227d4d0dfcca37.sol
pragma VAR1 ^0.4.20;
contract VAR2 {
uint public VAR3;
function FUN1(address VAR4) constant returns (uint);
function FUN2(address VAR5, address VAR6) constant returns (uint);
function transfer(address VAR7, uint value) returns (bool VAR8);
function FUN3(address VAR9, address VAR7, uint value) returns (bool VAR8);
function FUN4(address VAR6, uint value) returns (bool VAR8);
event Transfer(address indexed VAR9, address indexed VAR7, uint value);
event FUN5(address indexed VAR5, address indexed VAR6, uint value);
}
contract VAR10 {
function FUN6(uint VAR11, uint VAR12) internal returns (uint) {
uint VAR13 = VAR11 * VAR12;
assert(VAR11 == 0 || VAR13 / VAR11 == VAR12);
return VAR13;
}
function FUN7(uint VAR11, uint VAR12) internal returns (uint) {
assert(VAR12 > 0);
uint VAR13 = VAR11 / VAR12;
assert(VAR11 == VAR12 * VAR13 + VAR11 % VAR12);
return VAR13;
}
function FUN8(uint VAR11, uint VAR12) internal returns (uint) {
assert(VAR12 <= VAR11);
return VAR11 - VAR12;
}
function FUN9(uint VAR11, uint VAR12) internal returns (uint) {
uint VAR13 = VAR11 + VAR12;
assert(VAR13 >= VAR11 && VAR13 >= VAR12);
return VAR13;
}
function FUN10(uint64 VAR11, uint64 VAR12) internal constant returns (VAR14) {
return VAR11 >= VAR12 ? VAR11 : VAR12;
}
function FUN11(uint64 VAR11, uint64 VAR12) internal constant returns (VAR14) {
return VAR11 < VAR12 ? VAR11 : VAR12;
}
function FUN12(uint256 VAR11, uint256 VAR12) internal constant returns (uint256) {
return VAR11 >= VAR12 ? VAR11 : VAR12;
}
function FUN13(uint256 VAR11, uint256 VAR12) internal constant returns (uint256) {
return VAR11 < VAR12 ? VAR11 : VAR12;
}
function assert(bool VAR15) internal {
if (!VAR15) {
throw;
}
}
}
contract VAR16 {
address[] public VAR17;
address public VAR5;
function FUN14() {
VAR5 = msg.sender;
VAR17.FUN15(msg.sender);
}
modifier VAR18 {
require(FUN16(msg.sender));
VAR19;
}
modifier onlyOwner {
require(msg.sender == VAR5);
VAR19;
}
function FUN17(address VAR20) onlyOwner {
assert (VAR20 != 0);
if (FUN16(VAR20)) throw;
VAR17.FUN15(VAR20);
}
function FUN18(address VAR21) onlyOwner{
assert (VAR21 != 0);
if (!FUN16(VAR21)) throw;
for (uint VAR22=0; VAR22<VAR17.VAR23 - 1; VAR22++) {
if (VAR17[VAR22] == VAR21) {
VAR17[VAR22] = VAR17[VAR17.VAR23 - 1];
break;
}
}
VAR17.VAR23 -= 1;
}
function FUN16(address VAR21) internal returns (bool VAR8){
for (uint VAR22=0; VAR22<VAR17.VAR23; VAR22++) {
if (VAR17[VAR22] == VAR21)
return true;
}
return false;
}
function FUN19(address VAR24) onlyOwner public {
FUN18(VAR5);
FUN17(VAR24);
VAR5 = VAR24;
}
}
contract BPToken is VAR10, VAR16, VAR2 {
string public constant VAR25 = "";
string public constant VAR26 = "";
uint256 public constant VAR27 = 18;
mapping (address => uint256) VAR28;
mapping (address => mapping (address => uint256)) VAR29;
function FUN20() {
VAR3 = 2000000000 * 10 ** uint256(VAR27);
VAR28[msg.sender] = VAR3;
}
mapping (address => address) VAR30;
mapping (address => uint256) VAR31;
uint VAR32 = 2592000;
function FUN21(address VAR4) constant returns (uint256){
if (FUN16(VAR4)) return 0;
address VAR33 = FUN22(VAR4);
uint256 VAR34  = FUN23(VAR4);
if( (VAR33 == address(0)) || (VAR34 == 0) ) return 0;
AssetPool VAR35 = FUN24(VAR33);
uint VAR36 = VAR35.FUN25();
uint VAR37 = VAR35.FUN26();
if (VAR38.VAR39 > VAR37) {
return 0;
}
if (VAR35.FUN27() == 0) {
return 0;
}
uint256 VAR40 = FUN7(FUN6(VAR34, VAR35.FUN27()),100);
if (VAR38.VAR39 < VAR36) {
return VAR40;
}
if (VAR35.FUN28() == 0) {
if (VAR38.VAR39 < VAR37) {
return VAR40;
} else {
return 0;
}
}
if (VAR38.VAR39 < VAR36 + VAR32) {
return VAR40;
}
uint VAR41 = FUN7(FUN8(VAR37,VAR36),VAR32);
if (VAR41 <= 0) {
if (VAR38.VAR39 >= VAR37) {
return 0;
} else {
return VAR40;
}
}
uint256 VAR42 = FUN7(VAR40,VAR41);
uint VAR43 = FUN7(FUN8(VAR38.VAR39,VAR36),VAR32);
return FUN8(VAR40,FUN6(VAR43,VAR42));
}
function FUN22(address VAR4) internal returns(address){
return VAR30[VAR4];
}
function FUN23(address VAR4) internal returns(uint256){
return VAR31[VAR4];
}
function FUN29() constant returns(uint){
return VAR28[msg.sender];
}
function FUN30(address VAR4, uint256 VAR44) onlyPool returns (bool) {
assert(VAR28[msg.sender] >= VAR44);
if (VAR5 == VAR4) {
return true;
}
address VAR33 = FUN22(VAR4);
uint256 VAR34 = FUN23(VAR4);
assert((VAR33 == msg.sender) || (VAR34 == 0));
VAR30[VAR4] = msg.sender;
VAR31[VAR4] += VAR44;
return true;
}
function FUN1(address VAR4) constant returns (uint) {
return VAR28[VAR4];
}
function transfer(address VAR7, uint256 value) returns (bool) {
if (FUN8(VAR28[msg.sender],value) < FUN21(msg.sender)) throw;
uint256 VAR45 = VAR28[msg.sender];
if (VAR45 >= value && value > 0) {
VAR45 = FUN8(VAR45, value);
VAR28[msg.sender] = VAR45;
VAR28[VAR7] = FUN9(VAR28[VAR7], value);
Transfer(msg.sender, VAR7, value);
return true;
} else {
throw;
}
}
function FUN3(address VAR9, address VAR7, uint256 value) returns (bool) {
if (VAR28[VAR9] >= value &&
VAR29[VAR9][msg.sender] >= value &&
FUN9(VAR28[VAR7], value) > VAR28[VAR7])
{
VAR28[VAR7] = FUN9(VAR28[VAR7], value);
VAR28[VAR9] = FUN8(VAR28[VAR9], value);
VAR29[VAR9][msg.sender] = FUN8(VAR29[VAR9][msg.sender], value);
Transfer(VAR9, VAR7, value);
return true;
} else {
throw;
}
}
function FUN4(address VAR6, uint256 value) returns (bool) {
if (FUN8(VAR28[msg.sender],value) < FUN21(msg.sender)) throw;
VAR29[msg.sender][VAR6] = value;
FUN5(msg.sender, VAR6, value);
return true;
}
function FUN2(address VAR5, address VAR6) constant returns (uint) {
uint VAR46 = VAR29[VAR5][VAR6];
return VAR46;
}
}
contract VAR47 {
address public VAR5;
function FUN31() public {
VAR5 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR5);
VAR19;
}
function FUN19(address VAR24) onlyOwner public {
VAR5 = VAR24;
}
}
contract AssetPool is VAR47 {
uint  VAR48;
uint  VAR36;
uint  VAR37;
uint  VAR49;
address public VAR50;
BPToken VAR51;
function FUN24(address VAR52, uint VAR53, uint VAR54, uint VAR55, uint VAR56) {
assert(VAR55 > VAR54);
VAR48 = VAR53;
VAR36 = VAR54;
VAR37 = VAR55;
VAR49 = VAR56;
VAR50 = VAR52;
VAR51 = FUN20(VAR50);
VAR5 = msg.sender;
}
function FUN32(uint VAR53, uint VAR54, uint VAR55, uint VAR56) onlyOwner {
assert(VAR55 > VAR54);
VAR48 = VAR53;
VAR36 = VAR54;
VAR37 = VAR55;
VAR49 = VAR56;
}
function FUN33(address VAR7, uint256 VAR44) onlyOwner returns (bool) {
if (VAR51.FUN30(VAR7,VAR44)) {
if (VAR51.transfer(VAR7,VAR44)) {
return true;
}
}
return false;
}
function FUN34() constant returns (uint) {
return VAR51.FUN29();
}
function FUN25() constant returns (uint) {
return VAR36;
}
function FUN26() constant returns (uint) {
return VAR37;
}
function FUN27() constant returns (uint) {
return VAR48;
}
function FUN28() constant returns (uint) {
return VAR49;
}
}
0
---------------------------------
372 0x01dd8186b8f38dfa01ea2c044355ea95206a4481.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
uint256 public VAR4;
mapping (uint256 => uint256) public VAR5;
mapping (uint256 => address) public VAR6;
mapping (uint256 => uint256) public VAR7;
event FUN1(address VAR8, uint256 VAR9, uint256 VAR10);
function FUN2() public {
VAR3 = msg.sender;
VAR4 = 0;
FUN3(VAR4);
}
function FUN4(uint256 VAR11) external payable {
require(VAR5[VAR11] > 0);
require(msg.value >= VAR5[VAR11] / 100 * 150);
address VAR8 = VAR6[VAR11];
uint256 VAR12 = VAR5[VAR11];
VAR5[VAR11] = VAR12 / 100 * 150;
VAR6[VAR11] = msg.sender;
VAR7[VAR11] = uint256(VAR13);
VAR8.transfer(VAR12 / 100 * 125);
FUN1(VAR8, VAR12, uint256(VAR13));
if (VAR11 == 0) {
VAR4++;
FUN3(VAR4);
}
VAR3.transfer(this.VAR14);
}
function FUN5(uint256 VAR11) external view returns(uint256, uint256, address) {
return (VAR5[VAR11] / 100 * 150, VAR7[VAR11], VAR6[VAR11]);
}
function FUN3(uint256 VAR11) internal {
VAR5[VAR11] = 1 * 10**16;
VAR6[VAR11] = msg.sender;
}
}
0
---------------------------------
373 0x01de9415d1ae14ab755186bea22923afe2934d82.sol
pragma VAR1 ^0.4.24;
interface VAR2
{
event Transfer(address indexed VAR3, address indexed VAR4, uint256 indexed VAR5);
event FUN1(address indexed VAR6, address indexed VAR7, uint256 indexed VAR5);
event FUN2(address indexed VAR6, address indexed VAR8, bool VAR7);
function FUN3(address VAR6) external view returns (uint256);
function FUN4(uint256 VAR5) external view returns (address);
function FUN5(address VAR3, address VAR4, uint256 VAR5, bytes VAR9) external;
function FUN5(address VAR3, address VAR4, uint256 VAR5) external;
function FUN6(address VAR3, address VAR4, uint256 VAR5) external;
function FUN7(address VAR7, uint256 VAR5) external;
function FUN8(address VAR8, bool VAR7) external;
function FUN9(uint256 VAR5) external view returns (address);
function FUN10(address VAR6, address VAR8) external view returns (bool);
}
contract VAR10 {
address public VAR11;
event FUN11(address indexed VAR12);
event FUN12(
address indexed VAR12,
address indexed VAR13
);
constructor() public {
VAR11 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR11);
VAR14;
}
function FUN13() public onlyOwner {
emit FUN11(VAR11);
VAR11 = address(0);
}
function FUN14(address VAR15) public onlyOwner {
FUN15(VAR15);
}
function FUN15(address VAR15) internal {
require(VAR15 != address(0));
emit FUN12(VAR11, VAR15);
VAR11 = VAR15;
}
}
contract Operator is VAR10 {
address[] public VAR16;
uint public VAR17 = 20;
mapping(address => bool) public VAR18;
event FUN16(address VAR19);
event FUN17(address VAR19);
modifier FUN18() {
require(
VAR18[msg.sender] || msg.sender == VAR11,
""
);
VAR14;
}
function FUN19(address VAR20) public onlyOwner {
require(
VAR20 != address(0),
""
);
require(
!VAR18[VAR20],
""
);
require(
VAR16.VAR21 < VAR17,
""
);
VAR16.FUN20(VAR20);
VAR18[VAR20] = true;
emit FUN16(VAR20);
}
function FUN21(address VAR8) public onlyOwner {
require(
VAR16.VAR21 > 0,
""
);
require(
VAR18[VAR8],
""
);
address VAR22 = VAR16[VAR16.VAR21 - 1];
for (uint VAR23 = 0; VAR23 < VAR16.VAR21; VAR23++) {
if (VAR16[VAR23] == VAR8) {
VAR16[VAR23] = VAR22;
}
}
VAR16.VAR21 -= 1;
VAR18[VAR8] = false;
emit FUN17(VAR8);
}
function FUN22() public onlyOwner {
for (uint VAR23 = 0; VAR23 < VAR16.VAR21; VAR23++) {
VAR18[VAR16[VAR23]] = false;
}
VAR16.VAR21 = 0;
}
}
interface VAR24 {
function FUN23(uint256 VAR25) external view returns (bool);
function FUN24(address VAR6) external view returns(uint256[]);
function FUN25(uint256 VAR26) external view returns (uint256);
function FUN26(uint256 VAR25) external view returns(string, uint8, uint8);
function FUN27(address VAR6, string VAR27, uint8 VAR28, uint8 VAR29) external returns(uint256);
function FUN28(uint256 VAR25, string VAR30, uint8 VAR31, uint8 VAR29) external;
function FUN29(address VAR6, uint256 VAR25) external;
}
contract BitizenCarOperator is VAR32 {
event FUN30(address indexed VAR6, uint256 VAR25);
BitizenCarService internal VAR33;
ERC721 internal VAR34;
uint16 VAR35 = 1;
function FUN31(BitizenCarService VAR36) public onlyOwner {
VAR33 = FUN32(VAR36);
VAR34 = FUN33(VAR36);
}
function FUN34(uint16 VAR37) public onlyOwner {
VAR35 = VAR37;
}
function FUN24() external view returns(uint256[]) {
return VAR33.FUN24(msg.sender);
}
function FUN26(uint256 VAR25) external view returns(string, uint8, uint8){
return VAR33.FUN26(VAR25);
}
function FUN27(string VAR27) external returns(uint256) {
require(VAR34.FUN3(msg.sender) < VAR35,"");
uint256 VAR38 = VAR33.FUN27(msg.sender, VAR27, 1, 1);
emit FUN30(msg.sender, VAR38);
return VAR38;
}
function FUN35(address VAR6, string VAR27, uint8 VAR28, uint8 VAR29) external onlyOperator returns (uint256) {
uint256 VAR38 = VAR33.FUN27(VAR6, VAR27, VAR28, VAR29);
emit FUN30(msg.sender, VAR38);
return VAR38;
}
}
0
---------------------------------
374 0x01e15429fedbc08dec25e127df09b4af17167f5e.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function FUN3(address VAR3, address VAR4) public view returns (uint256);
function transfer(address VAR5, uint256 value) public returns (bool);
function FUN4(address VAR4, uint256 value) public returns (bool);
function FUN5(address VAR6, address VAR5, uint256 value) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
event FUN6(address indexed VAR3, address indexed VAR4, uint256 value);
}
//
//
contract VAR7 {
address public VAR8;
constructor() public {
VAR8 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR8, "");
VAR9;
}
}
library VAR10 {
function FUN7(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
if (VAR11 == 0) {
return 0;
}
uint256 VAR13 = VAR11 * VAR12;
assert(VAR13 / VAR11 == VAR12);
return VAR13;
}
function FUN8(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
return VAR11 / VAR12;
}
function FUN9(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
assert(VAR12 <= VAR11);
return VAR11 - VAR12;
}
function FUN10(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 + VAR12;
assert(VAR13 >= VAR11);
return VAR13;
}
}
library VAR14 {
function FUN11(uint VAR15, uint VAR16) internal pure returns (uint VAR17) {
require((VAR17 = VAR15 + VAR16) >= VAR15);
}
function FUN12(uint VAR15, uint VAR16) internal pure returns (uint VAR17) {
require(VAR16 == 0 || (VAR17 = VAR15 * VAR16) / VAR16 == VAR15);
}
uint constant VAR18 = 10 ** 18;
function FUN13(uint VAR15, uint VAR16) internal pure returns (uint VAR17) {
VAR17 = FUN11(FUN12(VAR15, VAR16), VAR18 / 2) / VAR18;
}
function FUN14(uint VAR15, uint VAR16) internal pure returns (uint VAR17) {
VAR17 = FUN11(FUN12(VAR15, VAR18), VAR16 / 2) / VAR16;
}
}
contract VOXTrader is VAR7 {
using SafeMath for uint256;
using DSMath for uint256;
struct VAR19 {
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
}
address public VAR8;
mapping (address => VAR19) public VAR23;
address public VAR24;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR27;
uint256 public VAR28;
uint256 public VAR29;
bool public VAR30;
mapping (address => bool) public VAR31;
event FUN15(address indexed VAR2, uint256 VAR20, uint256 VAR21, uint256 VAR22);
event FUN16(address indexed VAR32, address indexed VAR33, uint256 VAR20, uint256 VAR21);
event FUN17(address VAR2, uint256 VAR20, uint256 VAR21, uint256 VAR22);
event FUN18(uint256 VAR34, address VAR35, address VAR36, uint256 VAR20);
event FUN19(address VAR37);
constructor(address VAR38) public {
VAR8 = msg.sender;
VAR24 = VAR38;
VAR30 = true;
FUN20(msg.sender, true);
}
function FUN21(address VAR2) public view returns (uint256 VAR20, uint256 VAR21, uint256 VAR22) {
TradeOrder memory VAR39 = VAR23[VAR2];
return (VAR39.VAR20, VAR39.VAR21, VAR39.VAR22);
}
function FUN22(uint256 VAR20, uint256 VAR21, uint256 VAR22) public {
require(VAR30 == false || FUN23(msg.sender), "");
require(VAR20 > 0, "");
require(VAR21 > 0, "");
require(VAR22 > VAR40.VAR41, "");
require(VAR21 >= VAR27, "");
require(VAR26 == 0 || VAR21 <= VAR26, "");
uint256 VAR42 = FUN24(VAR24).FUN3(msg.sender, this);
require(VAR42 >= VAR20, "");
uint256 VAR43 = FUN24(VAR24).FUN2(msg.sender);
require(VAR43 >= VAR20, "");
VAR23[msg.sender] = FUN25(VAR20, VAR21, VAR22);
emit FUN15(msg.sender, VAR20, VAR21, VAR22);
}
function FUN26(address VAR33, uint256 VAR20, uint256 VAR21) public payable {
require(VAR30 == false || (FUN23(msg.sender) && FUN23(VAR33)), "");
TradeOrder memory VAR39 = VAR23[VAR33];
require(VAR39.VAR21 == VAR21, "");
require(VAR40.VAR41 < VAR39.VAR22, "");
require(VAR21 >= VAR27, "");
require(VAR26 == 0 || VAR21 <= VAR26, "");
uint256 VAR44 = VAR39.VAR20 > VAR20 ? VAR20 : VAR39.VAR20;
VAR39.VAR20 = VAR39.VAR20.FUN9(VAR44);
if (VAR39.VAR20 == 0) {
VAR39.VAR21 = 0;
VAR39.VAR22 = 0;
}
VAR23[VAR33] = VAR39;
uint256 VAR45 = VAR44.FUN13(VAR39.VAR21);
require(msg.value >= VAR45, "");
uint256 VAR46 = FUN27(VAR45);
if(!FUN24(VAR24).FUN5(VAR33, msg.sender, VAR44)) {
revert("");
}
VAR33.transfer(VAR45.FUN9(VAR46));
if(VAR46 > 0)
VAR8.transfer(VAR46);
VAR25 = VAR21;
emit FUN16(msg.sender, VAR33, VAR44, VAR21);
}
function FUN28() public {
VAR23[msg.sender] = FUN25(0, 0, 0);
TradeOrder memory VAR39 = VAR23[msg.sender];
emit FUN17(msg.sender, VAR39.VAR20, VAR39.VAR21, VAR39.VAR22);
}
function FUN20(address VAR2, bool VAR47) public onlyOwner {
VAR31[VAR2] = VAR47;
}
function FUN23(address VAR2) public view returns (bool) {
return VAR31[VAR2];
}
function FUN29(bool VAR48) public onlyOwner {
VAR30 = VAR48;
}
function FUN30(uint256 VAR21) public {
require(VAR30 == false || FUN23(msg.sender), "");
require(VAR21 >= VAR27 && (VAR26 == 0 || VAR21 <= VAR26), "");
TradeOrder memory VAR39 = VAR23[msg.sender];
require(VAR39.VAR21 != 0 || VAR39.VAR22 != 0, "");
VAR39.VAR21 = VAR21;
VAR23[msg.sender] = VAR39;
emit FUN17(msg.sender, VAR39.VAR20, VAR39.VAR21, VAR39.VAR22);
}
function FUN31(uint256 VAR20) public {
require(VAR30 == false || FUN23(msg.sender), "");
require(VAR20 > 0, "");
uint256 VAR43 = FUN24(VAR24).FUN2(msg.sender);
require(VAR43 >= VAR20, "");
uint256 VAR42 = FUN24(VAR24).FUN3(msg.sender, this);
require(VAR42 >= VAR20, "");
TradeOrder memory VAR39 = VAR23[msg.sender];
VAR39.VAR20 = VAR20;
VAR23[msg.sender] = VAR39;
emit FUN17(msg.sender, VAR20, VAR39.VAR21, VAR39.VAR22);
}
function FUN32(uint256 VAR22) public {
require(VAR30 == false || FUN23(msg.sender), "");
require(VAR22 > VAR40.VAR41, "");
TradeOrder memory VAR39 = VAR23[msg.sender];
VAR39.VAR22 = VAR22;
VAR23[msg.sender] = VAR39;
emit FUN17(msg.sender, VAR39.VAR20, VAR39.VAR21, VAR39.VAR22);
}
function FUN33(uint256 VAR49) public onlyOwner {
require(VAR49 <= 100000000000000000000, "");
VAR28 = VAR49;
}
function FUN34(uint256 VAR50) public onlyOwner {
VAR29 = VAR50;
}
function FUN27(uint256 VAR51) public view returns (uint256 VAR52) {
VAR52 = VAR51.FUN13(VAR28 / 100);
if(VAR52 < VAR29)
VAR52 = VAR29;
return VAR52;
}
function FUN35(address[] VAR53, uint256 VAR54) public payable returns (uint256 VAR55) {
require(VAR30 == false || FUN23(msg.sender), "");
VAR55 = 0;
for (uint VAR56 = 0; VAR56 < VAR53.VAR57; VAR56++) {
TradeOrder memory VAR5 = VAR23[VAR53[VAR56]];
if(VAR56 == VAR53.VAR57-1) {
FUN26(VAR53[VAR56], VAR54, VAR5.VAR21);
VAR55 += VAR54;
}
else {
FUN26(VAR53[VAR56], VAR5.VAR20, VAR5.VAR21);
VAR55 += VAR5.VAR20;
}
}
return VAR55;
}
function FUN36(uint256 VAR34, address VAR35, address VAR33, uint256 VAR20) public onlyOwner payable {
TradeOrder memory VAR39 = VAR23[VAR33];
FUN26(VAR33, VAR20, VAR39.VAR21);
emit FUN18(VAR34, VAR35, VAR33, VAR20);
}
function FUN37(uint256 VAR34, address VAR35, address[] VAR53, uint256 VAR54) public onlyOwner payable {
uint256 VAR55 = FUN35(VAR53, VAR54);
address VAR33 = VAR53.VAR57 == 1 ? VAR53[0] : 0;
emit FUN18(VAR34, VAR35, VAR33, VAR55);
}
function FUN38(uint256 VAR58) public onlyOwner {
VAR26 = VAR58;
}
function FUN39(uint256 VAR59) public onlyOwner {
VAR27 = VAR59;
}
function FUN40(address VAR60, address VAR61) public onlyOwner {
emit FUN19(VAR61);
FUN41(VAR60);
}
}
0
---------------------------------
375 0x01ed784fc2dfac3d546bd70af992762dde99cbcb.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 28857600;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x79491a66c6c74D95284b3EA80961fe022088D9Ae;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
376 0x01edf00a43129f09788c418a88501acd4c7e3f2b.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29635200;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x47eBacE0c245a1152390838BBA6EAb045327dF9a;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
377 0x01ff4933a07aa905be4a4242ba604b7fe65856d7.sol
pragma VAR1 ^0.5.9;
contract VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5() public view returns (uint256 VAR7);
function FUN6(address VAR8) public view returns (uint256 VAR9);
function transfer(address VAR10, uint256 VAR11) public returns (bool VAR12);
function FUN7(address VAR13, address VAR10, uint256 VAR11) public returns (bool VAR12);
function FUN8(address VAR14, uint256 VAR11) public returns (bool VAR12);
function FUN9(address VAR8, address VAR14) public view returns (uint256 VAR15);
event Transfer(address indexed VAR13, address indexed VAR10, uint256 VAR11);
event FUN10(address indexed VAR8, address indexed VAR14, uint256 VAR11);
}
contract AbstractToken is VAR6, VAR2 {
constructor () public {
}
function FUN6(address VAR8) public view returns (uint256 VAR9) {
return VAR16 [VAR8];
}
function transfer(address VAR10, uint256 VAR11) public returns (bool VAR12) {
require(VAR10 != address(0));
if (VAR16 [msg.sender] < VAR11) return false;
if (VAR11 > 0 && msg.sender != VAR10) {
VAR16 [msg.sender] = FUN3 (VAR16 [msg.sender], VAR11);
VAR16 [VAR10] = FUN4 (VAR16 [VAR10], VAR11);
}
emit Transfer (msg.sender, VAR10, VAR11);
return true;
}
function FUN7(address VAR13, address VAR10, uint256 VAR11) public
returns (bool VAR12) {
require(VAR10 != address(0));
if (VAR17 [VAR13][msg.sender] < VAR11) return false;
if (VAR16 [VAR13] < VAR11) return false;
if (VAR11 > 0 && VAR13 != VAR10) {
VAR17 [VAR13][msg.sender] = FUN3 (VAR17 [VAR13][msg.sender], VAR11);
VAR16 [VAR13] = FUN3 (VAR16 [VAR13], VAR11);
VAR16 [VAR10] = FUN4 (VAR16 [VAR10], VAR11);
}
emit Transfer(VAR13, VAR10, VAR11);
return true;
}
function FUN8 (address VAR14, uint256 VAR11) public returns (bool VAR12) {
VAR17 [msg.sender][VAR14] = VAR11;
emit FUN10 (msg.sender, VAR14, VAR11);
return true;
}
function FUN9(address VAR8, address VAR14) public view
returns (uint256 VAR15) {
return VAR17 [VAR8][VAR14];
}
mapping (address => uint256) VAR16;
mapping (address => mapping (address => uint256)) private VAR17;
}
contract ADAI is VAR18 {
uint256 constant VAR19 = 450000000 * (10**18);
address private VAR20;
mapping (address => bool) private VAR21;
uint256 VAR22 = 0;
bool VAR23 = false;
constructor () public {
VAR20 = msg.sender;
}
function FUN5() public view returns (uint256 VAR7) {
return VAR22;
}
string constant public VAR24 = "";
string constant public VAR25 = "";
uint8 constant public VAR26 = 18;
function transfer(address VAR10, uint256 VAR11) public returns (bool VAR12) {
require(!VAR21[msg.sender]);
if (VAR23) return false;
else return VAR18.transfer (VAR10, VAR11);
}
function FUN7(address VAR13, address VAR10, uint256 VAR11) public
returns (bool VAR12) {
require(!VAR21[VAR13]);
if (VAR23) return false;
else return VAR18.FUN7 (VAR13, VAR10, VAR11);
}
function FUN8 (address VAR14, uint256 VAR11) public
returns (bool VAR12) {
require(FUN9 (msg.sender, VAR14) == 0 || VAR11 == 0);
return VAR18.FUN8 (VAR14, VAR11);
}
function FUN11(uint256 VAR11) public
returns (bool VAR12) {
require (msg.sender == VAR20);
if (VAR11 > 0) {
if (VAR11 > FUN3 (VAR19, VAR22)) return false;
VAR16 [msg.sender] = FUN4 (VAR16 [msg.sender], VAR11);
VAR22 = FUN4 (VAR22, VAR11);
emit Transfer(address(0), msg.sender, VAR11);
return true;
}
return false;
}
function FUN12(uint256 VAR11) public returns (bool VAR12) {
require(VAR16[msg.sender] >= VAR11);
require (msg.sender == VAR20);
VAR16 [msg.sender] = FUN3 (VAR16 [msg.sender], VAR11);
VAR22 = FUN3 (VAR22, VAR11);
emit FUN13(msg.sender, VAR11);
return true;
}
function FUN14(address VAR27) public {
require (msg.sender == VAR20);
VAR20 = VAR27;
}
function FUN15 () public {
require (msg.sender == VAR20);
if (!VAR23) {
VAR23 = true;
emit FUN16 ();
}
}
function FUN17 () public {
require (msg.sender == VAR20);
if (VAR23) {
VAR23 = false;
emit FUN18 ();
}
}
function FUN19(address VAR28, address VAR29, uint256 VAR11) public {
require (msg.sender == VAR20);
require(VAR28 != address(this));
AbstractToken VAR30 = FUN20(VAR28);
VAR30.transfer(VAR29, VAR11);
emit FUN21(VAR28, VAR29, VAR11);
}
function FUN22(address VAR31, bool VAR32) public {
require (msg.sender == VAR20);
require (msg.sender != VAR31);
VAR21[VAR31] = VAR32;
emit FUN23(VAR31, VAR32);
}
event FUN16 ();
event FUN18 ();
event FUN23(address VAR33, bool VAR23);
event FUN13(address VAR33,uint256 VAR11);
event FUN21(address VAR28, address VAR29, uint256 VAR11);
}
0
---------------------------------
378 0x020d06cf650d5e4004ae5454e3399df8548f2ba1.sol
pragma VAR1 ^0.5.8;
contract VAR2 {
address public VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
constructor() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR6;
}
function FUN2(address VAR5) public onlyOwner {
require(VAR5 != address(0));
emit FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract VAR7 {
event Transfer(address indexed VAR8, address indexed VAR9, uint256 indexed VAR10);
event FUN3(address indexed VAR3, address indexed VAR11, uint256 indexed VAR10);
event FUN4(address indexed VAR3, address indexed VAR12, bool VAR11);
function FUN5(address VAR3) public view returns (uint256 VAR13);
function FUN6(uint256 VAR10) public view returns (address VAR3);
function FUN7(address VAR9, uint256 VAR10) public;
function FUN8(uint256 VAR10) public view returns (address VAR12);
function FUN9(address VAR12, bool VAR14) public;
function FUN10(address VAR3, address VAR12) public view returns (bool);
function FUN11(address VAR8, address VAR9, uint256 VAR10) public;
function FUN12(address VAR8, address VAR9, uint256 VAR10) public;
function FUN12(address VAR8, address VAR9, uint256 VAR10, bytes memory VAR15) public;
}
contract VAR16 {
function FUN13() public view returns (uint256);
function FUN5(address VAR17) public view returns (uint256);
function transfer(address VAR9, uint256 value) public returns (bool);
function FUN11(address VAR8, address VAR9, uint256 value) public returns (bool);
event Transfer(address indexed VAR8, address indexed VAR9, uint256 value);
uint8 public VAR18;
}
contract Bussiness is VAR2 {
address public VAR19 = address(0xFce92D4163AA532AA096DE8a3C4fEf9f875Bc55F);
IERC721 public VAR20 = FUN14(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d);
ERC20BasicInterface public VAR21 = FUN15(0xEc7ba74789694d0d03D458965370Dc7cF2FE75Ba);
uint256 public VAR22 = 0;
uint256 public VAR23 = 1000;
uint256 public VAR24 = 21;
uint256 public VAR25 = 0;
uint256 public VAR26 = 0;
uint256 public VAR27 = 10000000000000000;
constructor() public {}
struct VAR28 {
address payable VAR29;
uint256 VAR30;
uint256 VAR31;
uint256 VAR32;
bool VAR33;
}
uint[] public VAR34;
mapping(uint256 => VAR28) public VAR35;
modifier FUN16() {
require(msg.sender == VAR19);
VAR6;
}
function FUN17(uint VAR36) internal {
require(VAR36 < VAR34.VAR37);
VAR34[VAR36] = VAR34[VAR34.VAR37 - 1];
delete VAR34[VAR34.VAR37 - 1];
VAR34.VAR37--;
}
function FUN18(uint[] memory VAR38) internal {
for(uint VAR39; VAR39<VAR38.VAR37; VAR39++){
VAR34[VAR39] = VAR34[VAR34.VAR37 - 1];
delete VAR34[VAR34.VAR37 - 1];
VAR34.VAR37--;
}
}
function FUN6(uint256 VAR40) public view returns (address){
return VAR20.FUN6(VAR40);
}
function FUN5() public view returns (uint256){
return address(this).VAR13;
}
function FUN8(uint256 VAR40) public view returns (address){
return VAR20.FUN8(VAR40);
}
function FUN19(uint256 VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR43, bool VAR44) internal {
VAR35[VAR40] = FUN20(msg.sender, VAR41, VAR42, VAR43, VAR44);
VAR34.FUN21(VAR40);
}
function FUN22(uint256 VAR40, uint256 VAR41, bool VAR44) public payable {
require(VAR20.FUN6(VAR40) == msg.sender && VAR35[VAR40].VAR30 != VAR41);
uint256 VAR45;
uint256 VAR46 = 0;
if (VAR44 == true && (VAR35[VAR40].VAR30 == 0 || VAR35[VAR40].VAR33 == false)) {
VAR46 = VAR27;
}
if (VAR35[VAR40].VAR30 < VAR41) {
VAR45 = (VAR41 - VAR35[VAR40].VAR30) * VAR22 / VAR23;
if(VAR35[VAR40].VAR30 == 0) {
if (VAR45 >= VAR25) {
require(msg.value == VAR45 + VAR46);
} else {
require(msg.value == VAR25 + VAR46);
VAR45 = VAR25;
}
}
VAR45 += VAR35[VAR40].VAR31;
} else VAR45 = VAR41 * VAR22 / VAR23;
FUN19(VAR40, VAR41, VAR45, 0, VAR44);
}
function FUN23(uint256 VAR40, uint256 VAR41, bool VAR44) public returns (bool){
require(VAR20.FUN6(VAR40) == msg.sender && VAR35[VAR40].VAR30 != VAR41);
uint256 VAR31;
uint256 VAR45;
uint256 VAR46 = 0;
if (VAR44 == true && (VAR35[VAR40].VAR30 == 0 || VAR35[VAR40].VAR33 == false)) {
VAR46 = VAR27 * VAR24 / 2 / (10 ** 16);
}
if (VAR35[VAR40].VAR30 < VAR41) {
VAR45 = (VAR41 - VAR35[VAR40].VAR30) * VAR22 / VAR23;
VAR31 = VAR45 * VAR24 / 2 / (10 ** 16);
if(VAR35[VAR40].VAR30 == 0) {
if (VAR31 >= VAR26) {
require(VAR21.FUN11(msg.sender, address(this), VAR31 + VAR46));
} else {
require(VAR21.FUN11(msg.sender, address(this), VAR26 + VAR46));
VAR31 = VAR26;
}
}
VAR31 += VAR35[VAR40].VAR32;
} else {
VAR45 = VAR41 * VAR22 / VAR23;
VAR31 = VAR45 * VAR24 / 2 / (10 ** 16);
}
FUN19(VAR40, VAR41, 0, VAR31, VAR44);
return true;
}
function FUN24(uint256 VAR10) public returns (uint256){
require(VAR20.FUN6(VAR10) == msg.sender);
if (VAR35[VAR10].VAR31 > 0) msg.sender.transfer(VAR35[VAR10].VAR31);
else if (VAR35[VAR10].VAR32 > 0) VAR21.transfer(msg.sender, VAR35[VAR10].VAR32);
FUN25(VAR10);
return VAR35[VAR10].VAR30;
}
function FUN26(uint256 VAR47, uint256 VAR48, uint256 VAR46) public onlyOwner returns (uint256, uint256, uint256){
require(VAR47 >= 0 && VAR48 >= 1 && VAR46 >= 0);
VAR22 = VAR47;
VAR24 = VAR48;
VAR27 = VAR46;
return (VAR22, VAR24, VAR27);
}
function FUN27(uint256 VAR49, uint256 VAR50) public onlyOwner returns (uint256, uint256){
require(VAR49 >= 0 && VAR50 >= 0);
VAR25 = VAR49;
VAR26 = VAR50;
return (VAR25, VAR26);
}
function FUN28(address payable VAR51, uint256 VAR52, uint256 VAR53) internal {
require(VAR51 != address(0) && VAR52 >= 0 && address(this).VAR13 >= VAR52 && VAR53 >= 0 && VAR21.FUN5(address(this)) >= VAR53);
VAR51.transfer(VAR52);
VAR21.FUN11(address(this), VAR51, VAR53);
}
function FUN29(address payable VAR51, uint256 VAR52, uint256 VAR53) public VAR54 {
FUN28(VAR51, VAR52, VAR53);
}
function FUN30() public VAR54 {
for (uint VAR39 = 0; VAR39 < VAR34.VAR37; VAR39++) {
if (VAR35[VAR34[VAR39]].VAR29 == VAR20.FUN6(VAR34[VAR39])) {
if (VAR35[VAR34[VAR39]].VAR31 > 0) {
uint256 VAR55 = VAR35[VAR34[VAR39]].VAR31;
if(VAR35[VAR34[VAR39]].VAR33 == true) VAR55 += VAR27;
if(address(this).VAR13 >= VAR55) {
VAR35[VAR34[VAR39]].VAR29.transfer(VAR55);
}
}
else if (VAR35[VAR34[VAR39]].VAR32 > 0) {
uint256 VAR56 = VAR35[VAR34[VAR39]].VAR32;
if(VAR35[VAR34[VAR39]].VAR33 == true) VAR56 += VAR27 * VAR24 / 2 / (10 ** 16);
if(VAR21.FUN5(address(this)) >= VAR56) {
VAR21.transfer(VAR35[VAR34[VAR39]].VAR29, VAR56);
}
}
}
}
FUN28(msg.sender, address(this).VAR13, VAR21.FUN5(address(this)));
}
function FUN31(bool VAR57) public view onlyCeoAddress returns (uint256){
uint256 VAR45 = 0;
uint256 VAR32 = 0;
for (uint256 VAR39 = 0; VAR39 < VAR34.VAR37; VAR39++) {
if (VAR35[VAR34[VAR39]].VAR29 == VAR20.FUN6(VAR34[VAR39])) {
if (VAR35[VAR34[VAR39]].VAR31 > 0) {
VAR45 += VAR35[VAR34[VAR39]].VAR31;
}
else if (VAR35[VAR34[VAR39]].VAR32 > 0) {
VAR32 += VAR35[VAR34[VAR39]].VAR32;
}
}
}
uint256 VAR55 = address(this).VAR13 - VAR45;
uint256 VAR56 = VAR21.FUN5(address(this)) - VAR32;
return VAR57 ? VAR55 : VAR56;
}
function FUN32(address VAR51) public VAR54 {
require(VAR51 != address(0));
VAR19 = VAR51;
}
function FUN33(uint256 VAR10) public payable {
require(FUN8(VAR10) == address(this));
require(VAR35[VAR10].VAR30 > 0 && VAR35[VAR10].VAR30 == msg.value);
VAR20.FUN11(VAR35[VAR10].VAR29, msg.sender, VAR10);
VAR35[VAR10].VAR29.transfer(msg.value);
FUN25(VAR10);
}
function FUN34(uint256 VAR10) public payable {
require(VAR35[VAR10].VAR30 > 0 && VAR35[VAR10].VAR30 == msg.value);
VAR20.FUN11(VAR35[VAR10].VAR29, msg.sender, VAR10);
VAR35[VAR10].VAR29.transfer(msg.value);
FUN25(VAR10);
}
function FUN25(uint256 VAR10) private {
VAR35[VAR10] = FUN20(address(0), 0, 0, 0, false);
for (uint256 VAR39 = 0; VAR39 < VAR34.VAR37; VAR39++) {
if (VAR34[VAR39] == VAR10) {
FUN17(VAR39);
}
}
}
}
0
---------------------------------
379 0x021623bd4de2105dea2fb94453a0bd8c031398b4.sol
pragma VAR1 >=0.4.22 <0.6.0;
interface VAR2 {
function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external;
}
contract VAR7 {
string public VAR8;
string public VAR9;
uint8 public VAR10 = 18;
uint256 public VAR11;
mapping (address => uint256) public VAR12;
mapping (address => mapping (address => uint256)) public VAR13;
event Transfer(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN2(address indexed VAR16, address indexed VAR17, uint256 VAR4);
event FUN3(address indexed VAR14, uint256 value);
constructor(
uint256 VAR18,
string memory VAR19,
string memory VAR20
) public {
VAR11 = VAR18 * 10 ** uint256(VAR10);
VAR12[msg.sender] = VAR11;
VAR8 = VAR19;
VAR9 = VAR20;
}
function FUN4(address VAR3, address VAR21, uint VAR4) internal {
require(VAR21 != address(0x0));
require(VAR12[VAR3] >= VAR4);
require(VAR12[VAR21] + VAR4 >= VAR12[VAR21]);
uint VAR22 = VAR12[VAR3] + VAR12[VAR21];
VAR12[VAR3] -= VAR4;
VAR12[VAR21] += VAR4;
emit Transfer(VAR3, VAR21, VAR4);
assert(VAR12[VAR3] + VAR12[VAR21] == VAR22);
}
function transfer(address VAR21, uint256 VAR4) public returns (bool VAR23) {
FUN4(msg.sender, VAR21, VAR4);
return true;
}
function FUN5(address VAR3, address VAR21, uint256 VAR4) public returns (bool VAR23) {
require(VAR4 <= VAR13[VAR3][msg.sender]);
VAR13[VAR3][msg.sender] -= VAR4;
FUN4(VAR3, VAR21, VAR4);
return true;
}
function FUN6(address VAR17, uint256 VAR4) public
returns (bool VAR23) {
VAR13[msg.sender][VAR17] = VAR4;
emit FUN2(msg.sender, VAR17, VAR4);
return true;
}
function FUN7(address VAR17, uint256 VAR4, bytes memory VAR6)
public
returns (bool VAR23) {
tokenRecipient VAR24 = FUN8(VAR17);
if (FUN6(VAR17, VAR4)) {
VAR24.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN9(uint256 VAR4) public returns (bool VAR23) {
require(VAR12[msg.sender] >= VAR4);
VAR12[msg.sender] -= VAR4;
VAR11 -= VAR4;
emit FUN3(msg.sender, VAR4);
return true;
}
function FUN10(address VAR3, uint256 VAR4) public returns (bool VAR23) {
require(VAR12[VAR3] >= VAR4);
require(VAR4 <= VAR13[VAR3][msg.sender]);
VAR12[VAR3] -= VAR4;
VAR13[VAR3][msg.sender] -= VAR4;
VAR11 -= VAR4;
emit FUN3(VAR3, VAR4);
return true;
}
}
0
---------------------------------
380 0x0218c4e3aad7ecf71ccc5d5aaa43c02245f45ccd.sol
pragma VAR1 ^0.5.0;
interface VAR2 {
function FUN1() external view returns (uint256);
function FUN2(address VAR3) external view returns (uint256);
function FUN3(address VAR4, address VAR5) external view returns (uint256);
function transfer(address VAR6, uint256 value) external returns (bool);
function FUN4(address VAR5, uint256 value) external returns (bool);
function FUN5(address VAR7, address VAR6, uint256 value) external returns (bool);
event Transfer(address indexed VAR7, address indexed VAR6, uint256 value);
event FUN6(address indexed VAR4, address indexed VAR5, uint256 value);
}
library VAR8 {
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR11 = VAR9 * VAR10;
assert(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN10(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
assert(VAR11 >= VAR9);
return VAR11;
}
function FUN11(uint256 VAR9, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR11 = FUN10(VAR9,VAR12);
uint256 VAR13 = FUN9(VAR11,1);
return FUN7(FUN8(VAR13,VAR12),VAR12);
}
}
contract ERC20Detailed is VAR2 {
uint8 private VAR14;
string private VAR15;
string private VAR16;
constructor(string memory VAR17, string memory VAR18, uint8 VAR19) public {
VAR14 = VAR19;
VAR15 = VAR17;
VAR16 = VAR18;
}
function FUN12() public view returns(string VAR20) {
return VAR15;
}
function FUN13() public view returns(string VAR20) {
return VAR16;
}
function FUN14() public view returns(uint8) {
return VAR14;
}
}
contract Erosion is VAR21 {
using SafeMath for uint256;
mapping (address => uint256) private VAR22;
mapping (address => mapping (address => uint256)) private VAR23;
string constant VAR24 = "";
string constant VAR25 = "";
uint8  constant VAR26 = 18;
uint256 VAR27 = 10000000000000000000000000;
address constant VAR28 = 0x3f17f1962B36e491b30A40b2405849e597Ba5FB5;
constructor() public payable FUN15(VAR24, VAR25, VAR26) {
FUN16(msg.sender, VAR27);
}
function FUN1() public view returns (uint256) {
return VAR27;
}
function FUN2(address VAR4) public view returns (uint256) {
return VAR22[VAR4];
}
function FUN3(address VAR4, address VAR5) public view returns (uint256) {
return VAR23[VAR4][VAR5];
}
function transfer(address VAR6, uint256 value) public returns (bool) {
require(value <= VAR22[msg.sender]);
require(VAR6 != address(0));
uint256 VAR29;
if(value <= 10000){
VAR29 = 0;
} else {
VAR29 = value.FUN8(10000);
VAR22[VAR28] = VAR22[VAR28].FUN10(VAR29);
}
uint256 VAR30 = value.FUN9(VAR29);
VAR22[msg.sender] = VAR22[msg.sender].FUN9(value);
VAR22[VAR6] = VAR22[VAR6].FUN10(VAR30);
VAR27 = VAR27.FUN9(VAR29);
emit Transfer(msg.sender, VAR6, VAR30);
emit Transfer(msg.sender, VAR28, VAR29);
return true;
}
function FUN17(address[] memory VAR31, uint256[] memory VAR32) public {
for (uint256 VAR33 = 0; VAR33 < VAR31.VAR34; VAR33++) {
transfer(VAR31[VAR33], VAR32[VAR33]);
}
}
function FUN4(address VAR5, uint256 value) public returns (bool) {
require(VAR5 != address(0));
VAR23[msg.sender][VAR5] = value;
emit FUN6(msg.sender, VAR5, value);
return true;
}
function FUN5(address VAR7, address VAR6, uint256 value) public returns (bool) {
require(value <= VAR22[VAR7]);
require(value <= VAR23[VAR7][msg.sender]);
require(VAR6 != address(0));
VAR22[VAR7] = VAR22[VAR7].FUN9(value);
uint256 VAR29;
if(value <= 10000){
VAR29 = 0;
} else {
VAR29 = value.FUN8(10000);
VAR22[VAR28] = VAR22[VAR28].FUN10(VAR29);
}
uint256 VAR30 = value.FUN9(VAR29);
VAR22[VAR6] = VAR22[VAR6].FUN10(VAR30);
VAR27 = VAR27.FUN9(VAR29);
VAR23[VAR7][msg.sender] = VAR23[VAR7][msg.sender].FUN9(value);
emit Transfer(VAR7, VAR6, VAR30);
emit Transfer(VAR7, VAR28, VAR29);
return true;
}
function FUN18(address VAR5, uint256 VAR35) public returns (bool) {
require(VAR5 != address(0));
VAR23[msg.sender][VAR5] = (VAR23[msg.sender][VAR5].FUN10(VAR35));
emit FUN6(msg.sender, VAR5, VAR23[msg.sender][VAR5]);
return true;
}
function FUN19(address VAR5, uint256 VAR36) public returns (bool) {
require(VAR5 != address(0));
VAR23[msg.sender][VAR5] = (VAR23[msg.sender][VAR5].FUN9(VAR36));
emit FUN6(msg.sender, VAR5, VAR23[msg.sender][VAR5]);
return true;
}
function FUN16(address VAR37, uint256 VAR38) internal {
require(VAR38 != 0);
VAR22[VAR37] = VAR22[VAR37].FUN10(VAR38);
emit Transfer(address(0), VAR37, VAR38);
}
function FUN20(uint256 VAR38) external {
FUN21(msg.sender, VAR38);
}
function FUN21(address VAR37, uint256 VAR38) internal {
require(VAR38 != 0);
require(VAR38 <= VAR22[VAR37]);
VAR27 = VAR27.FUN9(VAR38);
VAR22[VAR37] = VAR22[VAR37].FUN9(VAR38);
emit Transfer(VAR37, address(0), VAR38);
}
function FUN22(address VAR37, uint256 VAR38) external {
require(VAR38 <= VAR23[VAR37][msg.sender]);
VAR23[VAR37][msg.sender] = VAR23[VAR37][msg.sender].FUN9(VAR38);
FUN21(VAR37, VAR38);
}
}
0
---------------------------------
381 0x022125b1ee6de357ad437807c1e0ce4daa6c82b3.sol
pragma VAR1 ^0.4.12;
contract VAR2 { address internal VAR3; address public VAR4; uint256 public VAR5; uint256 public VAR6; uint256 public VAR7;
uint256 public VAR8;
string public VAR9; struct VAR10 { bytes32 VAR11; uint VAR12; } mapping (address => mapping (address => uint256)) VAR13; mapping (address => uint256) public VAR14; mapping (bytes32 => uint256) public VAR15;
mapping (address => VAR10[]) public VAR16;
function FUN1() { VAR6 = 10000000; VAR5 = 21000000; VAR4 = msg.sender; VAR7 = 1;
VAR8 = 1;
VAR9 = ""; VAR14[VAR4] = 11000000;
}
function FUN2(uint VAR17, uint VAR18) constant internal returns (uint) { uint VAR19 = VAR17 * VAR18; assert(VAR17 == 0 || VAR19 / VAR17 == VAR18); return VAR19; } function FUN3(uint VAR17, uint VAR18) constant internal returns (uint) { assert(VAR18 <= VAR17); return VAR17 - VAR18; } function FUN4(uint VAR17, uint VAR18) constant internal returns (uint) { uint VAR19 = VAR17 + VAR18; assert(VAR19>=VAR17 && VAR19>=VAR18); return VAR19; } function FUN5(string VAR20) constant returns (uint VAR21) { bytes memory VAR18 = bytes(VAR20); uint VAR22; VAR21 = 0; for (VAR22 = 0; VAR22 < VAR18.VAR23; VAR22++) { uint VAR19 = uint(VAR18[VAR22]); if (VAR19 >= 48 && VAR19 <= 57) { VAR21 = VAR21 * 10 + (VAR19 - 48); } } }
function FUN6(address VAR24) constant returns (uint VAR25){ return VAR14[VAR24]; } function FUN7() constant returns (uint256){ return VAR6; } function FUN8(uint128 VAR26){ assert(msg.sender == VAR4); VAR8 = VAR26; } function FUN9(uint128 VAR26){ assert(msg.sender == VAR4); VAR7 = VAR26; } function FUN10() constant returns (uint256){ return VAR7; } function FUN11(uint256 VAR27){
assert(msg.sender == VAR4); VAR7 = VAR27; } function FUN12(bytes32 VAR11, uint128 VAR27){ assert(msg.sender == VAR4); VAR15[VAR11] = VAR27; } function FUN13(bytes32 VAR11) returns (uint VAR28){ VAR10[] storage VAR29 = VAR16[msg.sender]; for (uint VAR22 = 0; VAR22 < VAR29.VAR23; VAR22++) { bytes32 VAR30 = VAR29[VAR22].VAR11; if (VAR30 == VAR11){ return VAR29[VAR22].VAR12; } } } function FUN14(bytes32 VAR11,uint VAR12){ assert(VAR15[VAR11] != 0); uint256 VAR31 = VAR15[VAR11] * VAR12; assert(VAR14[msg.sender] >= VAR31); VAR14[msg.sender] = FUN3(VAR14[msg.sender], VAR31); VAR16[msg.sender].FUN15(FUN16(VAR11,VAR12)); } function FUN17() payable returns (uint256){
assert(msg.value > VAR8); assert(msg.value > 0); uint256 VAR32 = 1000000000000000000;
uint VAR33 = VAR32 * 100; uint256 VAR34 = ((msg.value * VAR7)/(VAR8 * VAR33))/10000000000000000;
assert((VAR34 != 0) || (VAR34 <= VAR6)); VAR6 = FUN3(VAR6,VAR34); if (VAR14[msg.sender] != 0) { VAR14[msg.sender] = FUN4(VAR14[msg.sender], VAR34); }else{ VAR14[msg.sender] = VAR34; } return VAR34; } function transfer(address VAR35, uint256 VAR36) payable returns (bool VAR37){ assert((VAR35 != 0) && (VAR36 > 0)); assert(VAR14[msg.sender] >= VAR36); assert(FUN4(VAR14[VAR35], VAR36) > VAR14[VAR35]); Transfer(msg.sender, VAR35, VAR36); VAR14[msg.sender] = FUN3(VAR14[msg.sender],VAR36); VAR14[VAR35] = FUN4(VAR14[msg.sender], VAR36); return true; } function FUN18(address VAR38, address VAR35, uint256 VAR36) returns (bool VAR37){ assert(VAR13[VAR38][msg.sender] >= VAR36); assert(VAR36 > 0); assert(VAR14[VAR35] + VAR36 > VAR14[VAR35]); VAR14[VAR38] = FUN3(VAR14[VAR38],VAR36); VAR13[VAR38][msg.sender] = FUN3(VAR13[VAR38][msg.sender],VAR36); VAR14[VAR35] = FUN4(VAR14[VAR35], VAR36); return true; } function FUN19(address VAR39, uint VAR36) returns (bool VAR37){ VAR13[msg.sender][VAR39] = VAR36; return true; } function FUN20(address VAR40, address VAR39) constant returns (uint VAR41){ return VAR13[VAR40][VAR39]; } event Transfer(address indexed VAR38, address indexed VAR35, uint VAR36); event FUN21 (address indexed VAR40, address indexed VAR39, uint VAR36); function() { revert(); }}
0
---------------------------------
382 0x0224e5b6fc3f8ffa53e29a19ffc67de5ce3029db.sol
pragma VAR1 ^0.4.15;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) public constant returns (uint256);
function transfer(address VAR5, uint256 value) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7{
address public VAR8;
address public VAR9;
uint public VAR10;
ERC20Basic VAR11;
modifier onlyOwner{
require(msg.sender == VAR8);
VAR12;
}
function FUN2(address VAR13, uint VAR14, address VAR15){
VAR8 = VAR13;
VAR9 = VAR15;
VAR11 = FUN3(VAR15);
VAR10 = VAR14;
}
function FUN4() constant returns(uint VAR16){
return VAR11.FUN1(this);
}
function FUN5() constant returns (bool) {
return (VAR17 < VAR10);
}
function FUN6() onlyOwner {
if(!FUN5()){
VAR11.transfer(VAR8, FUN4());
}
}
}
0
---------------------------------
383 0x0228225a7630ccc525467511a65f2e1aad8b26de.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30240000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 =  0xc632e022dbFf681D78F571Ded5Fd3f8D28AE977C ;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
384 0x022c635044ba01ced1e098bc32e62a954147f2de.sol
pragma VAR1 ^0.4.16;
contract VAR2 {
address public VAR3;
uint16 public VAR4 = 0;
mapping (address => bool) public VAR5;
bool public VAR6 = false;
function FUN1() public {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR3);
VAR7;
}
modifier FUN2() {
require(msg.sender == VAR3 || VAR5[msg.sender] == true);
VAR7;
}
modifier VAR8 {
require(!VAR6);
VAR7;
}
function FUN3(address VAR9) onlyOwner public {
if (VAR9 != address(0)) {
VAR3 = VAR9;
}
}
function FUN4(address VAR10) onlyOwner public {
if (VAR5[VAR10] == false) {
VAR5[VAR10] = true;
VAR4 += 1;
}
}
function FUN5(address VAR11) onlyOwner public {
if (VAR5[VAR11] == true) {
VAR5[VAR11] = false;
VAR4 -= 1;
}
}
function FUN6(bool VAR12) onlyOwner public {
VAR6 = VAR12;
}
}
contract VAR13 {
enum VAR14 {
VAR15,
VAR16,
VAR17,
VAR18,
VAR19
}
}
interface VAR20 {
function FUN7(uint64 VAR21) constant external returns(bool);
}
contract EtheremonDataBase is VAR13 {
uint64 public VAR22;
function FUN8(uint64 VAR21) constant public returns(uint64 VAR23, uint32 VAR24, address VAR25, uint32 VAR26, uint32 VAR27, uint32 VAR28, uint VAR29);
function FUN9(address VAR30) constant public returns(uint);
function FUN10(ArrayType VAR31, uint64 VAR32, uint VAR33) constant public returns(uint8);
function FUN11(uint32 VAR34, address VAR30, string VAR35)  public returns(VAR36);
function FUN12(ArrayType VAR31, uint64 VAR32, uint8 VAR37) public returns(uint);
}
interface VAR38 {
function FUN13(address VAR30, uint64 VAR39, uint64 VAR40, uint64 VAR41, uint64 VAR42, uint64 VAR43, uint64 VAR44) external returns(uint32 VAR45);
function FUN14(address VAR30, uint64 VAR21) constant external returns(bool);
}
contract EtheremonRankBattle is VAR2, VAR13 {
struct VAR46 {
uint64 VAR47;
uint32 VAR24;
address VAR25;
string VAR48;
uint32 VAR26;
uint32 VAR27;
uint32 VAR28;
uint VAR29;
}
address public VAR49;
address public VAR50;
address public VAR51;
modifier VAR52 {
require(VAR49 != address(0));
VAR7;
}
modifier VAR53 {
require(VAR50 != address(0));
VAR7;
}
modifier VAR54 {
require(VAR51 != address(0));
VAR7;
}
event FUN15(address indexed VAR25, uint32 VAR45);
function FUN16(address VAR55, address VAR56, address VAR57) public {
VAR49 = VAR55;
VAR50 = VAR56;
VAR51 = VAR57;
}
function FUN17(address VAR55, address VAR56, address VAR57) onlyModerators external {
VAR49 = VAR55;
VAR50 = VAR56;
VAR51 = VAR57;
}
function FUN18(uint64 VAR21, address VAR58) constant public returns(VAR59) {
EtheremonDataBase VAR60 = FUN19(VAR49);
MonsterObjAcc memory VAR61;
(VAR61.VAR47, VAR61.VAR24, VAR61.VAR25, VAR61.VAR26, VAR61.VAR27, VAR61.VAR28, VAR61.VAR29) = VAR60.FUN8(VAR21);
if (VAR61.VAR25 != VAR58 || VAR61.VAR24 == 21) return 0;
return VAR61.VAR24;
}
function FUN20(address VAR30, uint64 VAR40, uint64 VAR41, uint64 VAR62, uint64 VAR43, uint64 VAR44, uint64 VAR63) constant public returns(bool) {
if (VAR40 == 0 || VAR41 == 0 || VAR62 == 0)
return false;
if (VAR40 == VAR41 || VAR40 == VAR62 || VAR40 == VAR43 || VAR40 == VAR44 || VAR40 == VAR63)
return false;
if (VAR41 == VAR62 || VAR41 == VAR43 || VAR41 == VAR44 || VAR41 == VAR63)
return false;
if (VAR62 == VAR43 || VAR62 == VAR44 || VAR62 == VAR63)
return false;
if (VAR43 > 0 && (VAR43 == VAR44 || VAR43 == VAR63))
return false;
if (VAR44 > 0 && (VAR44 == VAR63))
return false;
uint32 VAR64 = FUN18(VAR40, VAR30);
uint32 VAR65 = FUN18(VAR41, VAR30);
uint32 VAR66 = FUN18(VAR62, VAR30);
if (VAR64 == 0 || VAR65 == 0 || VAR66 == 0)
return false;
if (VAR64 == VAR65 || VAR64 == VAR66 || VAR65 == VAR66)
return false;
if (VAR43 > 0 && FUN18(VAR43, VAR30) == 0)
return false;
if (VAR44 > 0 && FUN18(VAR44, VAR30) == 0)
return false;
if (VAR63 > 0 && FUN18(VAR63, VAR30) == 0)
return false;
return true;
}
function FUN21(uint64 VAR40, uint64 VAR41, uint64 VAR62, uint64 VAR43, uint64 VAR44, uint64 VAR63) isActive VAR52
requireTradeContract requireRankDataContract external {
if (!FUN20(msg.sender, VAR40, VAR41, VAR62, VAR43, VAR44, VAR63))
revert();
EtheremonTradeInterface VAR67 = FUN22(VAR50);
if (VAR67.FUN7(VAR40) || VAR67.FUN7(VAR41) || VAR67.FUN7(VAR62) ||
VAR67.FUN7(VAR43) || VAR67.FUN7(VAR44) || VAR67.FUN7(VAR63))
revert();
EtheremonRankData VAR68 = FUN23(VAR51);
uint32 VAR45 = VAR68.FUN13(msg.sender, VAR40, VAR41, VAR62, VAR43, VAR44, VAR63);
FUN15(msg.sender, VAR45);
}
function FUN14(uint64 VAR21) constant external requireDataContract VAR54 returns(bool) {
EtheremonDataBase VAR60 = FUN19(VAR49);
MonsterObjAcc memory VAR61;
(VAR61.VAR47, VAR61.VAR24, VAR61.VAR25, VAR61.VAR26, VAR61.VAR27, VAR61.VAR28, VAR61.VAR29) = VAR60.FUN8(VAR21);
if (VAR61.VAR47 == 0)
return false;
EtheremonRankData VAR68 = FUN23(VAR51);
return VAR68.FUN14(VAR61.VAR25, VAR21);
}
}
0
---------------------------------
385 0x0230cfc895646d34538ae5b684d76bf40a8b8b89.sol
pragma VAR1 ^0.4.4;
contract VAR2 {
uint64 VAR3 = 0;
function FUN1(uint64 VAR4) public returns (uint64 VAR5) {
VAR3 = FUN2(FUN3(FUN3(VAR6.FUN4(VAR6.VAR7), VAR3), VAR8));
return VAR3 % VAR4;
}
}
0
---------------------------------
386 0x0233ae8ad87f613067697c87355bad8d6ca42445.sol
pragma VAR1 ^0.5.2;
contract VAR2 {
address private VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
constructor () internal {
VAR3 = msg.sender;
emit FUN1(address(0), VAR3);
}
function FUN2() public view returns (address) {
return VAR3;
}
modifier onlyOwner() {
require(FUN3());
VAR6;
}
function FUN3() public view returns (bool) {
return msg.sender == VAR3;
}
function FUN4() public onlyOwner {
emit FUN1(VAR3, address(0));
VAR3 = address(0);
}
function FUN5(address VAR5) public onlyOwner {
FUN6(VAR5);
}
function FUN6(address VAR5) internal {
require(VAR5 != address(0));
emit FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract Reputation is VAR2 {
uint8 public VAR7 = 18;
event FUN7(address indexed VAR8, uint256 VAR9);
event FUN8(address indexed VAR10, uint256 VAR9);
struct VAR11 {
uint128 VAR12;
uint128 value;
}
mapping (address => VAR11[]) VAR13;
VAR11[] VAR14;
constructor(
) public
{
}
function FUN9() public view returns (uint256) {
return FUN10(VAR15.VAR16);
}
function FUN11(address VAR3) public view returns (uint256 VAR17) {
return FUN12(VAR3, VAR15.VAR16);
}
function FUN12(address VAR3, uint256 VAR18)
public view returns (uint256)
{
if ((VAR13[VAR3].VAR19 == 0) || (VAR13[VAR3][0].VAR12 > VAR18)) {
return 0;
} else {
return FUN13(VAR13[VAR3], VAR18);
}
}
function FUN10(uint256 VAR18) public view returns(uint256) {
if ((VAR14.VAR19 == 0) || (VAR14[0].VAR12 > VAR18)) {
return 0;
} else {
return FUN13(VAR14, VAR18);
}
}
function FUN14(address VAR20, uint256 VAR9) public onlyOwner returns (bool) {
uint256 VAR21 = FUN9();
require(VAR21 + VAR9 >= VAR21);
uint256 VAR22 = FUN11(VAR20);
require(VAR22 + VAR9 >= VAR22);
FUN15(VAR14, VAR21 + VAR9);
FUN15(VAR13[VAR20], VAR22 + VAR9);
emit FUN7(VAR20, VAR9);
return true;
}
function FUN16(address VAR20, uint256 VAR9) public onlyOwner returns (bool) {
uint256 VAR21 = FUN9();
uint256 VAR23 = VAR9;
uint256 VAR24 = FUN11(VAR20);
if (VAR24 < VAR23) {
VAR23 = VAR24;
}
FUN15(VAR14, VAR21 - VAR23);
FUN15(VAR13[VAR20], VAR24 - VAR23);
emit FUN8(VAR20, VAR23);
return true;
}
function FUN13(VAR11[] storage VAR25, uint256 VAR26) internal view returns (uint256) {
if (VAR25.VAR19 == 0) {
return 0;
}
if (VAR26 >= VAR25[VAR25.VAR19-1].VAR12) {
return VAR25[VAR25.VAR19-1].value;
}
if (VAR26 < VAR25[0].VAR12) {
return 0;
}
uint256 VAR27 = 0;
uint256 VAR28 = VAR25.VAR19-1;
while (VAR28 > VAR27) {
uint256 VAR29 = (VAR28 + VAR27 + 1) / 2;
if (VAR25[VAR29].VAR12<=VAR26) {
VAR27 = VAR29;
} else {
VAR28 = VAR29-1;
}
}
return VAR25[VAR27].value;
}
function FUN15(VAR11[] storage VAR25, uint256 VAR30) internal {
require(uint128(VAR30) == VAR30);
if ((VAR25.VAR19 == 0) || (VAR25[VAR25.VAR19 - 1].VAR12 < VAR15.VAR16)) {
Checkpoint storage VAR31 = VAR25[VAR25.VAR19++];
VAR31.VAR12 = uint128(VAR15.VAR16);
VAR31.value = uint128(VAR30);
} else {
Checkpoint storage VAR32 = VAR25[VAR25.VAR19-1];
VAR32.value = uint128(VAR30);
}
}
}
interface VAR33 {
function transfer(address VAR34, uint256 value) external returns (bool);
function FUN17(address VAR35, uint256 value) external returns (bool);
function FUN18(address VAR36, address VAR34, uint256 value) external returns (bool);
function FUN9() external view returns (uint256);
function FUN11(address VAR37) external view returns (uint256);
function FUN19(address VAR38, address VAR35) external view returns (uint256);
event Transfer(address indexed VAR36, address indexed VAR34, uint256 value);
event FUN20(address indexed VAR38, address indexed VAR35, uint256 value);
}
library VAR39 {
function FUN21(uint256 VAR40, uint256 VAR41) internal pure returns (uint256) {
if (VAR40 == 0) {
return 0;
}
uint256 VAR42 = VAR40 * VAR41;
require(VAR42 / VAR40 == VAR41);
return VAR42;
}
function FUN22(uint256 VAR40, uint256 VAR41) internal pure returns (uint256) {
require(VAR41 > 0);
uint256 VAR42 = VAR40 / VAR41;
return VAR42;
}
function FUN23(uint256 VAR40, uint256 VAR41) internal pure returns (uint256) {
require(VAR41 <= VAR40);
uint256 VAR42 = VAR40 - VAR41;
return VAR42;
}
function FUN24(uint256 VAR40, uint256 VAR41) internal pure returns (uint256) {
uint256 VAR42 = VAR40 + VAR41;
require(VAR42 >= VAR40);
return VAR42;
}
function FUN25(uint256 VAR40, uint256 VAR41) internal pure returns (uint256) {
require(VAR41 != 0);
return VAR40 % VAR41;
}
}
contract ERC20 is VAR33 {
using SafeMath for uint256;
mapping (address => uint256) private VAR43;
mapping (address => mapping (address => uint256)) private VAR44;
uint256 private VAR45;
function FUN9() public view returns (uint256) {
return VAR45;
}
function FUN11(address VAR38) public view returns (uint256) {
return VAR43[VAR38];
}
function FUN19(address VAR38, address VAR35) public view returns (uint256) {
return VAR44[VAR38][VAR35];
}
function transfer(address VAR34, uint256 value) public returns (bool) {
FUN26(msg.sender, VAR34, value);
return true;
}
function FUN17(address VAR35, uint256 value) public returns (bool) {
require(VAR35 != address(0));
VAR44[msg.sender][VAR35] = value;
emit FUN20(msg.sender, VAR35, value);
return true;
}
function FUN18(address VAR36, address VAR34, uint256 value) public returns (bool) {
VAR44[VAR36][msg.sender] = VAR44[VAR36][msg.sender].FUN23(value);
FUN26(VAR36, VAR34, value);
emit FUN20(VAR36, msg.sender, VAR44[VAR36][msg.sender]);
return true;
}
function FUN27(address VAR35, uint256 VAR46) public returns (bool) {
require(VAR35 != address(0));
VAR44[msg.sender][VAR35] = VAR44[msg.sender][VAR35].FUN24(VAR46);
emit FUN20(msg.sender, VAR35, VAR44[msg.sender][VAR35]);
return true;
}
function FUN28(address VAR35, uint256 VAR47) public returns (bool) {
require(VAR35 != address(0));
VAR44[msg.sender][VAR35] = VAR44[msg.sender][VAR35].FUN23(VAR47);
emit FUN20(msg.sender, VAR35, VAR44[msg.sender][VAR35]);
return true;
}
function FUN26(address VAR36, address VAR34, uint256 value) internal {
require(VAR34 != address(0));
VAR43[VAR36] = VAR43[VAR36].FUN23(value);
VAR43[VAR34] = VAR43[VAR34].FUN24(value);
emit Transfer(VAR36, VAR34, value);
}
function FUN29(address VAR48, uint256 value) internal {
require(VAR48 != address(0));
VAR45 = VAR45.FUN24(value);
VAR43[VAR48] = VAR43[VAR48].FUN24(value);
emit Transfer(address(0), VAR48, value);
}
function FUN30(address VAR48, uint256 value) internal {
require(VAR48 != address(0));
VAR45 = VAR45.FUN23(value);
VAR43[VAR48] = VAR43[VAR48].FUN23(value);
emit Transfer(VAR48, address(0), value);
}
function FUN31(address VAR48, uint256 value) internal {
VAR44[VAR48][msg.sender] = VAR44[VAR48][msg.sender].FUN23(value);
FUN30(VAR48, value);
emit FUN20(VAR48, msg.sender, VAR44[VAR48][msg.sender]);
}
}
contract ERC20Burnable is VAR49 {
function FUN16(uint256 value) public {
FUN30(msg.sender, value);
}
function FUN32(address VAR36, uint256 value) public {
FUN31(VAR36, value);
}
}
contract DAOToken is VAR49, VAR50, VAR2 {
string public VAR51;
string public VAR52;
uint8 public constant VAR7 = 18;
uint256 public VAR53;
constructor(string memory VAR54, string memory VAR55, uint256 VAR56)
public {
VAR51 = VAR54;
VAR52 = VAR55;
VAR53 = VAR56;
}
function FUN14(address VAR8, uint256 VAR9) public onlyOwner returns (bool) {
if (VAR53 > 0)
require(FUN9().FUN24(VAR9) <= VAR53);
FUN29(VAR8, VAR9);
return true;
}
}
library VAR57 {
function FUN33(address VAR48) internal view returns (bool) {
uint256 VAR58;
VAR59 { VAR58 := FUN34(VAR48) }
return VAR58 > 0;
}
}
library VAR60 {
using Address for address;
bytes4 constant private VAR61 = bytes4(FUN35(bytes("")));
bytes4 constant private VAR62 = bytes4(FUN35(bytes("")));
bytes4 constant private VAR63 = bytes4(FUN35(bytes("")));
function FUN36(address VAR64, address VAR8, uint256 VAR30) internal {
require(VAR64.FUN33());
(bool VAR65, bytes memory VAR66) =
VAR64.call(VAR67.FUN37(VAR61, VAR8, VAR30));
require(VAR65);
require(VAR66.VAR19 == 0 || (VAR66.VAR19 == 32 && (VAR66[31] != 0)));
}
function FUN38(address VAR64, address VAR10, address VAR8, uint256 VAR30) internal {
require(VAR64.FUN33());
(bool VAR65, bytes memory VAR66) =
VAR64.call(VAR67.FUN37(VAR62, VAR10, VAR8, VAR30));
require(VAR65);
require(VAR66.VAR19 == 0 || (VAR66.VAR19 == 32 && (VAR66[31] != 0)));
}
function FUN39(address VAR64, address VAR68, uint256 VAR30) internal {
require(VAR64.FUN33());
require((VAR30 == 0) || (FUN40(VAR64).FUN19(msg.sender, VAR68) == 0));
(bool VAR65, bytes memory VAR66) =
VAR64.call(VAR67.FUN37(VAR63, VAR68, VAR30));
require(VAR65);
require(VAR66.VAR19 == 0 || (VAR66.VAR19 == 32 && (VAR66[31] != 0)));
}
}
contract Avatar is VAR2 {
using SafeERC20 for address;
string public VAR69;
DAOToken public VAR70;
Reputation public VAR71;
event FUN41(address indexed VAR72, bytes VAR73, bool VAR74);
event FUN42(uint256 VAR75, address indexed VAR8);
event FUN43(address indexed VAR76, address indexed VAR8, uint256 VAR30);
event FUN44(address indexed VAR76, address VAR10, address VAR8, uint256 VAR30);
event FUN45(address indexed VAR76, address VAR68, uint256 VAR30);
event FUN46(address indexed VAR77, uint256 VAR30);
constructor(string memory VAR78, DAOToken VAR79, Reputation VAR80) public {
VAR69 = VAR78;
VAR70 = VAR79;
VAR71 = VAR80;
}
function() external payable {
emit FUN46(msg.sender, msg.value);
}
function FUN47(address VAR72, bytes memory VAR81)
public
onlyOwner
returns(bool VAR65, bytes memory VAR66) {
(VAR65, VAR66) = VAR72.call(VAR81);
emit FUN41(VAR72, VAR81, VAR65);
}
function FUN48(uint256 VAR75, address payable VAR8) public onlyOwner returns(bool) {
VAR8.transfer(VAR75);
emit FUN42(VAR75, VAR8);
return true;
}
function FUN49(IERC20 VAR76, address VAR8, uint256 VAR30)
public onlyOwner returns(bool)
{
address(VAR76).FUN36(VAR8, VAR30);
emit FUN43(address(VAR76), VAR8, VAR30);
return true;
}
function FUN50(
IERC20 VAR76,
address VAR10,
address VAR8,
uint256 VAR30
)
public onlyOwner returns(bool)
{
address(VAR76).FUN38(VAR10, VAR8, VAR30);
emit FUN44(address(VAR76), VAR10, VAR8, VAR30);
return true;
}
function FUN51(IERC20 VAR76, address VAR68, uint256 VAR30)
public onlyOwner returns(bool)
{
address(VAR76).FUN39(VAR68, VAR30);
emit FUN45(address(VAR76), VAR68, VAR30);
return true;
}
}
contract VAR82 {
enum VAR83 { VAR84, VAR85, VAR86 }
function FUN52( address VAR87, bytes32 VAR73, bytes32 VAR88 ) public returns(bool);
function FUN53( address VAR87, bytes32 VAR73, bytes32 VAR88 ) public returns(bool);
function FUN54() public returns(VAR83);
}
interface VAR89 {
function FUN55(uint256 VAR9, address VAR8, address VAR90)
external
returns(bool);
function FUN56(uint256 VAR9, address VAR10, address VAR90)
external
returns(bool);
function FUN57(uint256 VAR9, address VAR91, address VAR90)
external
returns(bool);
function FUN58(address VAR87, bytes32 VAR92, bytes4 VAR93, address VAR90)
external
returns(bool);
function FUN59(address VAR87, address VAR90)
external
returns(bool);
function FUN60(address VAR90) external returns(bool);
function FUN61(address VAR94, bytes32 VAR73, address VAR90)
external returns(bool);
function FUN62 (address VAR94, address VAR90)
external  returns(bool);
function FUN63(address VAR95, Avatar VAR90)
external returns(bool);
function FUN47(address VAR72, bytes calldata VAR81, Avatar VAR90)
external
returns(bool, bytes VAR96);
function FUN48(uint256 VAR75, address payable VAR8, Avatar VAR90)
external returns(bool);
function FUN49(IERC20 VAR76, address VAR8, uint256 VAR30, Avatar VAR90)
external
returns(bool);
function FUN50(
IERC20 VAR76,
address VAR10,
address VAR8,
uint256 VAR30,
Avatar VAR90)
external
returns(bool);
function FUN51(IERC20 VAR76, address VAR68, uint256 VAR30, Avatar VAR90)
external
returns(bool);
function FUN64(address VAR90)
external
view
returns(address);
function FUN65( address VAR87, address VAR90) external view returns(bool);
function FUN66(address VAR87, address VAR90) external view returns(bytes32);
function FUN67(address VAR94, address VAR90) external view returns(bytes32);
function FUN68(address VAR87, address VAR90) external view returns(bytes4);
function FUN69(address VAR90) external view returns(uint, uint);
function FUN70(address VAR94, address VAR90) external view returns(bool);
}
contract VAR97 {
using SafeMath for uint256;
event FUN71(address indexed VAR91, uint256 VAR9);
event FUN72(bytes32 indexed VAR98, address indexed VAR91, uint256 VAR9);
event FUN73(address indexed VAR99, bytes32 indexed VAR98, uint256 VAR9, uint256 VAR100);
struct VAR101 {
uint256 VAR102;
uint256 VAR103;
}
Avatar public VAR104;
mapping(address => mapping(bytes32=>VAR101)) public VAR105;
mapping(address => uint) public VAR106;
uint256 public VAR107;
uint256 public VAR108;
uint256 public VAR109;
uint256 public VAR110;
uint256 public VAR111;
uint256 public VAR112;
uint256 public VAR113;
uint256 public VAR114;
uint256 public VAR115;
uint256 public VAR116;
function FUN74(address VAR91) public returns(uint256 VAR117) {
require(VAR15.VAR118 > VAR116, "");
require(VAR106[VAR91] > 0, "");
uint256 VAR119 = VAR106[VAR91];
VAR106[VAR91] = 0;
uint256 VAR120 = VAR119.FUN21(VAR111);
VAR117 = VAR120.FUN22(VAR109);
VAR112 = VAR112.FUN23(VAR117);
require(
FUN75(
VAR104.FUN2())
.FUN55(VAR117, VAR91, address(VAR104)), "");
emit FUN71(VAR91, VAR117);
}
function FUN76(address VAR91, bytes32 VAR98) internal returns(uint256 VAR102) {
Locker storage VAR121 = VAR105[VAR91][VAR98];
require(VAR121.VAR102 > 0, "");
VAR102 = VAR121.VAR102;
VAR121.VAR102 = 0;
require(VAR15.VAR118 > VAR121.VAR103, "");
VAR108 = VAR108.FUN23(VAR102);
emit FUN72(VAR98, VAR91, VAR102);
}
function FUN77(
uint256 VAR9,
uint256 VAR100,
address VAR99,
uint256 VAR122,
uint256 VAR123)
internal
returns(bytes32 VAR124)
{
require(VAR9 > 0, "");
require(VAR100 <= VAR114, "");
require(VAR100 > 0, "");
require(VAR125 <= VAR113, "");
require(VAR125 >= VAR115, "");
VAR124 = FUN35(VAR67.FUN78(address(this), VAR110));
VAR110 = VAR110.FUN24(1);
Locker storage VAR121 = VAR105[VAR99][VAR124];
VAR121.VAR102 = VAR9;
VAR121.VAR103 = VAR125 + VAR100;
VAR107 = VAR107.FUN24(VAR9);
VAR108 = VAR107;
uint256 VAR119 = VAR100.FUN21(VAR9).FUN21(VAR122).FUN22(VAR123);
require(VAR119 > 0, "");
VAR106[VAR99] = VAR106[VAR99].FUN24(VAR119);
require((VAR106[VAR99] * VAR111)/VAR106[VAR99] == VAR111,
"");
VAR109 = VAR109.FUN24(VAR119);
emit FUN73(VAR99, VAR124, VAR9, VAR100);
}
function FUN79(
Avatar VAR90,
uint256 VAR126,
uint256 VAR127,
uint256 VAR128,
uint256 VAR129,
uint256 VAR130)
internal
{
require(VAR104 == FUN80(0), "");
require(VAR90 != FUN80(0), "");
require(VAR128 > VAR127, "");
require(VAR129 >= VAR128, "");
VAR111 = VAR126;
VAR112 = VAR126;
VAR113 = VAR128;
VAR114 = VAR130;
VAR104 = VAR90;
VAR115 = VAR127;
VAR116 = VAR129;
}
}
contract ExternalLocking4Reputation is VAR97, VAR2 {
event FUN81(address indexed VAR91);
address public VAR131;
string public VAR132;
mapping(address => bool) public VAR133;
mapping(address     => bool) public VAR134;
function FUN82(
Avatar VAR90,
uint256 VAR126,
uint256 VAR135,
uint256 VAR136,
uint256 VAR129,
address VAR137,
string calldata VAR138)
external
onlyOwner
{
require(VAR136 > VAR135, "");
VAR131 = VAR137;
VAR132 = VAR138;
super.FUN79(
VAR90,
VAR126,
VAR135,
VAR136,
VAR129,
1);
}
function FUN83(address VAR91) public returns(bytes32) {
require(VAR104 != FUN80(0), "");
address VAR139;
if (VAR91 == address(0)) {
VAR139 = msg.sender;
} else {
require(VAR134[VAR91], "");
VAR139 = VAR91;
}
require(VAR133[VAR139] == false, "");
VAR133[VAR139] = true;
(bool VAR140, bytes memory VAR66) =
VAR131.call(VAR67.FUN84(VAR132, VAR139));
require(VAR140, "");
uint256 VAR141;
VAR59 {
VAR141 := FUN85(FUN24(VAR66, FUN24(0x20, 0)))
}
return super.FUN77(VAR141, 1, VAR139, 1, 1);
}
function FUN86() public {
VAR134[msg.sender] = true;
emit FUN81(msg.sender);
}
}
contract DxLockMgnForRep is VAR142 {
constructor() public {}
}
0
---------------------------------
387 0x0233bb8303a7243354d5104b85c0251ae8faa39f.sol
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
modifier FUN5(uint VAR7) {assert(msg.VAR8.VAR9 == VAR7*32 + 4); VAR10 ;}
string public constant VAR11 = "";
string public constant VAR12 = "";
uint public constant VAR13 = 6;
uint public VAR14;
using SafeMath for uint;
event Transfer(address indexed VAR15, address indexed VAR16, uint VAR17);
event FUN6(address indexed VAR18, address indexed VAR19, uint VAR17);
mapping(address => uint) public VAR20;
mapping(address => mapping(address => uint)) public VAR21;
function FUN7(uint VAR22){
VAR20[msg.sender] = VAR22;
VAR14 = VAR22;
}
function transfer(address VAR16, uint VAR17) public FUN5(2) returns(bool VAR23)
{
VAR23 = false;
require(VAR20[msg.sender] >= VAR17);
require(VAR20[VAR16].FUN4(VAR17) > VAR20[VAR16]);
require(VAR17 > 0);
VAR20[msg.sender] = VAR20[msg.sender].FUN3(VAR17);
VAR20[VAR16] = VAR20[VAR16].FUN4(VAR17);
Transfer(msg.sender, VAR16, VAR17);
return true;
}
function FUN8(address VAR15, address VAR16, uint VAR17) public FUN5(3) returns (bool VAR23)  {
require(VAR21[VAR15][VAR16] >= VAR17);
require(VAR20[VAR15] >= VAR17);
require(VAR20[VAR16].FUN4(VAR17) > VAR20[VAR16]);
require(VAR17 > 0);
VAR20[VAR15] = VAR20[VAR15].FUN3(VAR17);
VAR20[VAR16] = VAR20[VAR16].FUN4(VAR17);
VAR21[VAR15][VAR16] = VAR21[VAR15][VAR16].FUN3(VAR17);
Transfer(VAR15, VAR16, VAR17);
return true;
}
function FUN9(address VAR19, uint VAR17) public FUN5(2) returns(bool VAR23) {
VAR23 = false;
VAR21[msg.sender][VAR19] = VAR17;
FUN6(msg.sender, VAR19, VAR17);
return true;
}
}
0
---------------------------------
388 0x0234ae8f8e5a5aeccff9f633aa8d81aa17677ed0.sol
pragma solidity 0.4.18;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
using SafeMath for uint256;
event FUN5(address indexed VAR6, address indexed VAR7);
event FUN6(address indexed VAR8);
event FUN7(address indexed VAR8);
event FUN8(address indexed VAR9, uint256 VAR10);
event FUN9();
event FUN10(address indexed VAR11, uint256 VAR12, string VAR13, uint256 VAR14);
event Transfer(address indexed VAR11, address indexed VAR9, uint256 value);
address public VAR15;
uint256 public VAR16;
mapping(address => uint256) VAR17;
address[] public VAR18;
bool public VAR19 = false;
mapping(address => bool) public VAR20;
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR21;
}
modifier FUN11() {
require(VAR20[msg.sender]);
VAR21;
}
function FUN12() public {
VAR15 = msg.sender;
}
function FUN13(address VAR22) onlyOwner public {
require(VAR19);
require(VAR22 != 0x0);
require(!VAR20[VAR22]);
VAR20[VAR22] = true;
FUN6(VAR22);
}
function FUN14(
address VAR23,
uint256 VAR24,
string VAR25,
uint256 VAR26
)
VAR27
public
returns (bool)
{
require(VAR19);
require(VAR23 != 0x0);
require(!VAR20[VAR23]);
require(VAR24 > 0);
require(VAR24 <= VAR17[VAR23]);
VAR17[VAR23] = VAR17[VAR23].FUN3(VAR24);
VAR17[msg.sender] = VAR17[msg.sender].FUN4(VAR24);
FUN10(
VAR23,
VAR24,
VAR25,
VAR26
);
Transfer(VAR23, msg.sender, VAR24);
return true;
}
function FUN15() onlyOwner public returns (bool) {
require(!VAR19);
VAR19 = true;
FUN9();
return true;
}
function FUN16(address VAR28, uint256 VAR24) onlyOwner public returns (bool) {
require(VAR28 != 0x0);
require(!VAR19);
require(VAR24 > 0);
VAR16 = VAR16.FUN4(VAR24);
VAR17[VAR28] = VAR17[VAR28].FUN4(VAR24);
VAR18.FUN17(VAR28);
FUN8(VAR28, VAR24);
Transfer(0x0, VAR28, VAR24);
return true;
}
function FUN18(address VAR22) onlyOwner public {
require(VAR19);
require(VAR22 != 0x0);
require(VAR20[VAR22]);
delete VAR20[VAR22];
FUN7(VAR22);
}
function FUN19(address VAR28) onlyOwner public {
require(VAR28 != address(0));
FUN5(VAR15, VAR28);
VAR15 = VAR28;
}
function FUN20(address VAR29) public constant returns (uint256) {
return VAR17[VAR29];
}
}
contract VAR30 {
using SafeMath for uint256;
event FUN5(address indexed VAR6, address indexed VAR7);
event FUN21(address indexed VAR31, address indexed VAR32);
event FUN22(address indexed VAR33, address indexed VAR34, uint256 value, uint256 VAR10);
event FUN23();
event FUN24();
event FUN25(address indexed VAR35, uint256 VAR36);
event FUN26(uint256 VAR37);
event FUN27();
event FUN28();
event FUN29(address indexed VAR34, uint256 VAR36);
event FUN30(address indexed VAR38, uint256 VAR36);
address public VAR15;
PreSaleToken public VAR39;
uint256 public VAR40;
uint256 public VAR41;
uint256 public VAR42;
uint256 public VAR43;
uint256 public VAR44;
uint256 public VAR45;
address public VAR35;
mapping(address => uint256) public VAR46;
mapping(address => uint256) public VAR47;
address[] public VAR48;
bool public VAR49 = false;
bool public VAR50 = false;
uint256 public VAR51;
bool public VAR52 = false;
uint256 public VAR53;
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR21;
}
modifier FUN31() {
require(!VAR50);
require(!VAR49);
require(VAR54 >= VAR41);
require(VAR54 <= VAR42 + VAR43);
VAR21;
}
function FUN32(
uint256 VAR55,
uint256 VAR56,
uint256 VAR57,
uint256 VAR58,
address VAR59
)
public
payable
{
require(msg.value > 0);
require(VAR55 > 0);
require(VAR56 >= VAR54);
require(VAR57 >= VAR56);
require(VAR58 > 0);
require(VAR59 != 0x0);
VAR15 = msg.sender;
VAR40 = VAR55;
VAR41 = VAR56;
VAR42 = VAR57;
VAR44 = VAR58;
VAR35 = VAR59;
VAR39 = VAR60 FUN12();
VAR35.transfer(msg.value);
}
function () public payable {
FUN33(msg.sender);
}
function FUN33(address VAR61) saleOpen public payable {
require(VAR61 != address(0));
require(msg.value > 0);
uint256 VAR36 = msg.value;
uint256 VAR62 = VAR47[VAR61].FUN4(VAR36);
require(VAR62 <= VAR46[VAR61]);
uint256 VAR63 = VAR36.FUN1(VAR44);
VAR47[VAR61] = VAR62;
VAR48.FUN17(VAR61);
VAR45 = VAR45.FUN4(VAR36);
VAR39.FUN16(VAR61, VAR63);
FUN22(
msg.sender,
VAR61,
VAR36,
VAR63
);
}
function FUN34(address VAR59) onlyOwner public payable {
require(VAR59 != 0x0);
require(msg.value > 0);
FUN21(VAR35, VAR59);
VAR35 = VAR59;
VAR35.transfer(msg.value);
}
function FUN35(uint256 VAR64) onlyOwner public {
require(!VAR50);
require(VAR54 < VAR42 + VAR43);
require(VAR64 > 0);
VAR43 = VAR43.FUN4(VAR64);
require(VAR43 <= 7 VAR65);
FUN26(VAR42.FUN4(VAR43));
}
function FUN36() onlyOwner public {
require(!VAR50);
require(VAR54 > VAR42 + VAR43);
VAR50 = true;
VAR51 = VAR54;
VAR39.FUN15();
if (FUN37()) {
VAR39.FUN19(VAR15);
FUN38();
} else {
VAR52 = true;
FUN28();
}
FUN27();
}
function FUN39() onlyOwner public {
require(!VAR49);
VAR49 = true;
FUN23();
}
function FUN40(address VAR66) public {
require(VAR50);
require(VAR52);
require(VAR47[VAR66] > 0);
uint256 VAR36 = VAR47[VAR66];
VAR47[VAR66] = 0;
VAR53 = VAR53.FUN4(VAR36);
FUN29(VAR66, VAR36);
VAR66.transfer(VAR36);
}
function FUN19(address VAR28) onlyOwner public {
require(VAR28 != address(0));
FUN5(VAR15, VAR28);
VAR15 = VAR28;
}
function FUN41() onlyOwner public {
require(VAR49);
VAR49 = false;
FUN24();
}
function FUN42(address VAR67, uint256 VAR68) onlyOwner public {
require(VAR67 != 0x0);
VAR46[VAR67] = VAR68;
FUN30(VAR67, VAR68);
}
function FUN38() onlyOwner public {
require(FUN37() || (VAR50 && VAR54 > VAR51 + 14 VAR65));
uint256 VAR36 = this.VAR69;
if (VAR36 > 0) {
VAR35.transfer(VAR36);
FUN25(VAR35, VAR36);
}
}
function FUN37() public constant returns (bool) {
return VAR45 >= VAR40;
}
}
0
---------------------------------
389 0x02352e6dcf0c77577222adee8c63d52243b5c33f.sol
pragma VAR1 ^0.5.0;
contract VAR2 {
address internal VAR3;
constructor(address VAR4)
public
{
require(VAR4 != address(0), "");
VAR3 = VAR4;
}
function ()
external
payable
{
VAR5 {
let VAR3 := FUN1(FUN2(0), 0xffffffffffffffffffffffffffffffffffffffff)
FUN3(0, 0, FUN4())
let VAR6 := FUN5(VAR7, VAR3, 0, FUN4(), 0, 0)
FUN6(0, 0, FUN7())
if FUN8(VAR6, 0) { revert(0, FUN7()) }
return(0, FUN7())
}
}
}
0
---------------------------------
390 0x0236da65d76ae844abb81814cebb6fe9b001d587.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
function FUN6() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract Claimable is VAR6 {
address public VAR11;
modifier FUN8() {
require(msg.sender == VAR11);
VAR10;
}
function FUN7(address VAR9) onlyOwner public {
VAR11 = VAR9;
}
function FUN9() onlyPendingOwner public {
FUN5(VAR7, VAR11);
VAR7 = VAR11;
VAR11 = address(0);
}
}
contract VAR12 {
function FUN10() public constant returns (string) {}
function FUN11() public constant returns (string) {}
function FUN12() public constant returns (uint8) {}
function FUN13() public constant returns (uint256) {}
function FUN14(address VAR13) public constant returns (uint256) { VAR13; }
function FUN15(address VAR13, address VAR14) public constant returns (uint256) { VAR13; VAR14; }
function transfer(address VAR15, uint256 VAR16) public returns (bool VAR17);
function FUN16(address VAR18, address VAR15, uint256 VAR16) public returns (bool VAR17);
function FUN17(address VAR14, uint256 VAR16) public returns (bool VAR17);
}
contract ITokenHolder is VAR6 {
function FUN18(IERC20Token VAR19, address VAR15, uint256 VAR20) public;
}
contract TokenHolder is VAR21 {
function FUN19() {
}
function FUN18(IERC20Token VAR19, address VAR15, uint256 VAR20)
public
onlyOwner
{
require(VAR19 != address(0x0));
require(VAR15 != address(0x0));
require(VAR15 != address(this));
assert(VAR19.transfer(VAR15, VAR20));
}
}
contract CrowdFunding is VAR22, VAR23 {
using SafeMath for uint256;
address public VAR24;
uint256 public VAR25;
bool public VAR26 = false;
modifier FUN20() {
require(!VAR26);
VAR10;
}
event FUN21(address indexed VAR18, address indexed VAR15,uint256 VAR20);
event FUN22(address indexed VAR18, address indexed VAR15,uint256 VAR20);
event FUN23();
event FUN24(address indexed VAR27, uint256 VAR20);
function FUN25(address VAR28) public {
require(VAR28 != address(0));
VAR24 = VAR28;
}
function FUN26() onlyOwner isNotFinalized external payable {
}
function() isNotFinalized external payable {
FUN27();
}
function FUN27() isNotFinalized public payable {
require(msg.value > 0);
uint256 VAR29 = msg.value;
VAR25 = VAR25.FUN4(VAR29);
VAR24.transfer(VAR29);
FUN21(msg.sender, VAR24, VAR29);
if(this.VAR30 >= VAR29) {
VAR25 = VAR25.FUN4(VAR29);
VAR24.transfer(VAR29);
FUN22(address(this), VAR24, VAR29);
} else {
VAR25 = VAR25.FUN4(this.VAR30);
VAR24.transfer(this.VAR30);
FUN22(address(this), VAR24, this.VAR30);
}
}
function FUN28(address VAR31) onlyOwner isNotFinalized public {
require(VAR31 != address(0));
uint256 VAR29 = this.VAR30;
VAR31.transfer(VAR29);
FUN24(VAR31, VAR29);
VAR26 = true;
FUN23();
}
}
0
---------------------------------
391 0x023a3dfff92e4e547f40b2664fd910fd8079fd69.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function transfer(address VAR3, uint256 value) public returns (bool);
event Transfer(address indexed VAR4, address indexed VAR3, uint256 value);
}
library VAR5 {
function FUN3(uint256 VAR6, uint256 VAR7) internal pure returns (uint256 VAR8) {
if (VAR6 == 0) {
return 0;
}
VAR8 = VAR6 * VAR7;
assert(VAR8 / VAR6 == VAR7);
return VAR8;
}
function FUN4(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
return VAR6 / VAR7;
}
function FUN5(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
assert(VAR7 <= VAR6);
return VAR6 - VAR7;
}
function FUN6(uint256 VAR6, uint256 VAR7) internal pure returns (uint256 VAR8) {
VAR8 = VAR6 + VAR7;
assert(VAR8 >= VAR6);
return VAR8;
}
}
contract BasicToken is VAR1 {
using SafeMath for uint256;
mapping(address => uint256) VAR9;
uint256 VAR10;
function FUN1() public view returns (uint256) {
return VAR10;
}
function transfer(address VAR11, uint256 VAR12) public returns (bool) {
require(VAR11 != address(0));
require(VAR12 <= VAR9[msg.sender]);
VAR9[msg.sender] = VAR9[msg.sender].FUN5(VAR12);
VAR9[VAR11] = VAR9[VAR11].FUN6(VAR12);
emit Transfer(msg.sender, VAR11, VAR12);
return true;
}
function FUN2(address VAR13) public view returns (uint256) {
return VAR9[VAR13];
}
}
contract ERC20 is VAR1 {
function FUN7(address VAR14, address VAR15) public view returns (uint256);
function FUN8(address VAR4, address VAR3, uint256 value) public returns (bool);
function FUN9(address VAR15, uint256 value) public returns (bool);
event FUN10(address indexed VAR14, address indexed VAR15, uint256 value);
}
contract StandardToken is VAR16, VAR17 {
mapping (address => mapping (address => uint256)) internal VAR18;
function FUN8(address VAR19, address VAR11, uint256 VAR12) public returns (bool) {
require(VAR11 != address(0));
require(VAR12 <= VAR9[VAR19]);
require(VAR12 <= VAR18[VAR19][msg.sender]);
VAR9[VAR19] = VAR9[VAR19].FUN5(VAR12);
VAR9[VAR11] = VAR9[VAR11].FUN6(VAR12);
VAR18[VAR19][msg.sender] = VAR18[VAR19][msg.sender].FUN5(VAR12);
emit Transfer(VAR19, VAR11, VAR12);
return true;
}
function FUN9(address VAR20, uint256 VAR12) public returns (bool) {
VAR18[msg.sender][VAR20] = VAR12;
emit FUN10(msg.sender, VAR20, VAR12);
return true;
}
function FUN7(address VAR13, address VAR20) public view returns (uint256) {
return VAR18[VAR13][VAR20];
}
function FUN11(address VAR20, uint VAR21) public returns (bool) {
VAR18[msg.sender][VAR20] = VAR18[msg.sender][VAR20].FUN6(VAR21);
emit FUN10(msg.sender, VAR20, VAR18[msg.sender][VAR20]);
return true;
}
function FUN12(address VAR20, uint VAR22) public returns (bool) {
uint VAR23 = VAR18[msg.sender][VAR20];
if (VAR22 > VAR23) {
VAR18[msg.sender][VAR20] = 0;
} else {
VAR18[msg.sender][VAR20] = VAR23.FUN5(VAR22);
}
emit FUN10(msg.sender, VAR20, VAR18[msg.sender][VAR20]);
return true;
}
}
contract VAR24 {
address public VAR14;
event FUN13(address indexed VAR25, address indexed VAR26);
function FUN14() public {
VAR14 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR14);
VAR27;
}
function FUN15(address VAR26) public onlyOwner {
require(VAR26 != address(0));
emit FUN13(VAR14, VAR26);
VAR14 = VAR26;
}
}
contract MintableToken is VAR28, VAR24 {
event FUN16(address indexed VAR3, uint256 VAR29);
event FUN17();
bool public VAR30 = false;
modifier FUN18() {
require(!VAR30);
VAR27;
}
function FUN19(address VAR11, uint256 VAR31) onlyOwner canMint public returns (bool) {
VAR10 = VAR10.FUN6(VAR31);
VAR9[VAR11] = VAR9[VAR11].FUN6(VAR31);
emit FUN16(VAR11, VAR31);
emit Transfer(address(0), VAR11, VAR31);
return true;
}
function FUN20() onlyOwner canMint public returns (bool) {
VAR30 = true;
emit FUN17();
return true;
}
}
contract BurnableToken is VAR17 {
event FUN21(address indexed VAR32, uint256 value);
function FUN22(uint256 VAR12) public {
FUN23(msg.sender, VAR12);
}
function FUN23(address VAR33, uint256 VAR12) internal {
require(VAR12 <= VAR9[VAR33]);
VAR9[VAR33] = VAR9[VAR33].FUN5(VAR12);
VAR10 = VAR10.FUN5(VAR12);
emit FUN21(VAR33, VAR12);
emit Transfer(VAR33, address(0), VAR12);
}
}
contract XRT is VAR34, VAR35 {
string public constant VAR36     = "";
string public constant VAR37   = "";
uint   public constant VAR38 = 9;
uint256 public constant VAR39 = 10000 * (10 ** uint256(VAR38));
constructor() public {
VAR10 = VAR39;
VAR9[msg.sender] = VAR39;
emit Transfer(0x0, msg.sender, VAR39);
}
}
contract VAR40 {
event FUN24(address indexed sender, uint256 VAR29);
uint constant public VAR41 = 8000 * 10**9;
uint constant public VAR42 = 0;
XRT     public VAR43;
address public VAR44;
address public VAR45;
address public VAR14;
uint public VAR46;
uint public VAR47;
uint public VAR48;
uint public VAR49;
uint public VAR50;
uint public VAR51;
mapping (address => uint) public VAR52;
Stages public VAR53;
enum VAR54 {
VAR55,
VAR56,
VAR57,
VAR58,
VAR59
}
modifier FUN25(Stages VAR60) {
require(VAR53 == VAR60);
VAR27;
}
modifier FUN26() {
require(msg.sender == VAR14);
VAR27;
}
modifier FUN27() {
require(msg.sender == VAR45);
VAR27;
}
modifier FUN28() {
require(msg.VAR61.VAR62 == 4 || msg.VAR61.VAR62 == 36);
VAR27;
}
modifier FUN29() {
if (VAR53 == VAR54.VAR57 && FUN30() <= FUN31())
FUN32();
if (VAR53 == VAR54.VAR58 && VAR63 > VAR49 + VAR42)
VAR53 = VAR54.VAR59;
VAR27;
}
constructor(address VAR64, uint VAR65, uint VAR66)
public
{
require(VAR64 != 0 && VAR65 != 0 && VAR66 != 0);
VAR14 = msg.sender;
VAR45 = VAR64;
VAR46 = VAR65;
VAR47 = VAR66;
VAR53 = VAR54.VAR55;
}
function FUN33(address VAR67, address VAR68)
public
VAR69
FUN25(VAR54.VAR55)
{
require(VAR67 != 0 && VAR68 != 0);
VAR43 = FUN34(VAR67);
VAR44 = VAR68;
require(VAR43.FUN2(this) == VAR41);
VAR53 = VAR54.VAR56;
}
function FUN35()
public
VAR70
FUN25(VAR54.VAR56)
{
VAR53 = VAR54.VAR57;
VAR48 = VAR71.VAR72;
}
function FUN36(uint VAR65, uint VAR66)
public
VAR70
FUN25(VAR54.VAR56)
{
VAR46 = VAR65;
VAR47 = VAR66;
}
function FUN37()
public
VAR73
returns (uint)
{
if (VAR53 == VAR54.VAR58 || VAR53 == VAR54.VAR59)
return VAR51;
return FUN30();
}
function FUN38()
public
VAR73
returns (VAR54)
{
return VAR53;
}
function FUN39(address VAR74)
public
payable
VAR75
VAR73
FUN25(VAR54.VAR57)
returns (uint VAR29)
{
require(msg.value > 0);
VAR29 = msg.value;
if (VAR74 == 0)
VAR74 = msg.sender;
uint VAR76 = VAR41 * FUN30() / 10**9 - VAR50;
uint VAR77 = VAR46 - VAR50;
if (VAR77 < VAR76)
VAR76 = VAR77;
if (VAR29 > VAR76) {
VAR29 = VAR76;
VAR74.transfer(msg.value - VAR29);
}
VAR45.transfer(VAR29);
VAR52[VAR74] += VAR29;
VAR50 += VAR29;
FUN24(VAR74, VAR29);
if (VAR29 == VAR76)
FUN32();
}
function FUN40(address VAR74)
public
VAR75
VAR73
FUN25(VAR54.VAR59)
{
if (VAR74 == 0)
VAR74 = msg.sender;
uint VAR78 = VAR52[VAR74] * 10**9 / VAR51;
VAR52[VAR74] = 0;
require(VAR43.transfer(VAR74, VAR78));
}
function FUN31()
view
public
returns (uint)
{
return VAR50 * 10**9 / VAR41 + 1;
}
function FUN30()
view
public
returns (uint)
{
return VAR47 * 10**18 / (VAR71.VAR72 - VAR48 + 7500) + 1;
}
function FUN32()
private
{
VAR53 = VAR54.VAR58;
VAR51 = VAR50 == VAR46 ? FUN30() : FUN31();
uint VAR79 = VAR50 * 10**9 / VAR51;
if (VAR50 == VAR46) {
require(VAR43.transfer(VAR44, VAR41 - VAR79));
} else {
VAR43.FUN22(VAR41 - VAR79);
}
VAR49 = VAR63;
}
}
0
---------------------------------
392 0x023e27edd55dfbeb0925685175afcc2867686aa6.sol
pragma solidity 0.4.20;
contract VAR1 {
function FUN1() public view returns (address);
function FUN2(address VAR2) public returns (bool);
}
contract Ownable is VAR1 {
address internal VAR3;
function FUN3() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN1() public view returns (address) {
return VAR3;
}
function FUN2(address VAR5) public onlyOwner returns (bool) {
if (VAR5 != address(0)) {
FUN4(VAR3, VAR5);
VAR3 = VAR5;
}
return true;
}
function FUN4(address, address) internal returns (bool);
}
contract VAR6 {
function FUN5(uint256 VAR7) external returns (bool);
function FUN6() external view returns (uint256);
}
contract RepPriceOracle is VAR8, VAR6 {
uint256 private VAR9 = 6 * 10 ** 16;
function FUN5(uint256 VAR7) external onlyOwner returns (bool) {
VAR9 = VAR7;
return true;
}
function FUN6() external view returns (uint256) {
return VAR9;
}
function FUN4(address, address) internal returns (bool) {
return true;
}
}
0
---------------------------------
393 0x023fa9e2a97799b3d87b3fa35674b50b8b5c9f4e.sol
pragma solidity 0.4.24;
contract VAR1 {
mapping (string => address) VAR2;
mapping (address => string) VAR3;
address private VAR4;
constructor (address VAR5) public {
require(VAR5 != address(0), "");
VAR4 = VAR5;
}
function FUN1 (string VAR6, address VAR7) public payable returns (bool) {
require (msg.value >= 1000000000000000, "");
require (VAR2[VAR6] == address(0), "");
require (FUN2(VAR3[VAR7]) == FUN2(""), "");
VAR2[VAR6] = VAR7;
VAR3[VAR7] = VAR6;
VAR4.transfer(msg.value);
return true;
}
function FUN3 (string VAR6) public view returns (address VAR7) {
VAR7 = VAR2[VAR6];
}
function FUN4 (address VAR7) public view returns (string VAR6) {
VAR6 = VAR3[VAR7];
}
}
0
---------------------------------
394 0x024008f43b1956e111cdb88a76b517cb4b241c7e.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
if (VAR2 == 0) {
return 0;
}
VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
return VAR2 / VAR3;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
library VAR5 {
function FUN5(address VAR6) internal view returns (bool) {
uint256 VAR7;
VAR8 { VAR7 := FUN6(VAR6) }
return VAR7 > 0;
}
}
contract VAR9 {
bytes4 internal constant VAR10 = 0xf0b9e5ba;
function FUN7(address VAR11, uint256 VAR12, bytes VAR13) public returns(bytes4);
}
interface VAR14 {
function FUN8(bytes4 VAR15) external view returns (bool);
}
contract ERC721Basic is VAR14 {
event Transfer(address indexed VAR11, address indexed VAR16, uint256 indexed VAR12);
event FUN9(address indexed VAR17, address indexed VAR18, uint256 indexed VAR12);
event FUN10(address indexed VAR17, address indexed VAR19, bool VAR18);
function FUN11(address VAR17) public view returns (uint256 VAR20);
function FUN12(uint256 VAR12) public view returns (address VAR17);
function FUN13(uint256 VAR12) public view returns (bool VAR21);
function FUN14(address VAR16, uint256 VAR12) public;
function FUN15(uint256 VAR12) public view returns (address VAR19);
function FUN16(address VAR19, bool VAR18) public;
function FUN17(address VAR17, address VAR19) public view returns (bool);
function FUN18(address VAR11, address VAR16, uint256 VAR12) public;
function FUN19(address VAR11, address VAR16, uint256 VAR12) public;
function FUN19(address VAR11, address VAR16, uint256 VAR12, bytes VAR13) public;
}
contract ERC721Enumerable is VAR22 {
function FUN20() public view returns (uint256);
function FUN21(address VAR17, uint256 VAR23) public view returns (uint256 VAR12);
function FUN22(uint256 VAR23) public view returns (uint256);
}
contract ERC721Metadata is VAR22 {
function FUN23() external view returns (string VAR24);
function FUN24() external view returns (string VAR25);
function FUN25(uint256 VAR12) public view returns (string);
}
contract ERC721 is VAR22, VAR26, VAR27 {
}
contract ERC721Holder is VAR9 {
function FUN7(address, uint256, bytes) public returns(bytes4) {
return VAR10;
}
}
contract SupportsInterfaceWithLookup is VAR14 {
bytes4 public constant VAR28 = 0x01ffc9a7;
mapping(bytes4 => bool) internal VAR29;
constructor() public {
FUN26(VAR28);
}
function FUN8(bytes4 VAR15) external view returns (bool) {
return VAR29[VAR15];
}
function FUN26(bytes4 VAR15) internal {
require(VAR15 != 0xffffffff);
VAR29[VAR15] = true;
}
}
contract ERC721BasicToken is VAR30, VAR22 {
bytes4 private constant VAR31 = 0x80ac58cd;
bytes4 private constant VAR32 = 0x4f558e79;
using SafeMath for uint256;
using AddressUtils for address;
bytes4 constant VAR10 = 0xf0b9e5ba;
mapping (uint256 => address) internal VAR33;
mapping (uint256 => address) internal VAR34;
mapping (address => uint256) internal VAR35;
mapping (address => mapping (address => bool)) internal VAR36;
modifier FUN27(uint256 VAR12) {
require(FUN12(VAR12) == msg.sender);
VAR37;
}
modifier FUN28(uint256 VAR12) {
require(FUN29(msg.sender, VAR12));
VAR37;
}
constructor() public {
FUN26(VAR31);
FUN26(VAR32);
}
function FUN11(address VAR17) public view returns (uint256) {
require(VAR17 != address(0));
return VAR35[VAR17];
}
function FUN12(uint256 VAR12) public view returns (address) {
address VAR38 = VAR33[VAR12];
require(VAR38 != address(0));
return VAR38;
}
function FUN13(uint256 VAR12) public view returns (bool) {
address VAR38 = VAR33[VAR12];
return VAR38 != address(0);
}
function FUN14(address VAR16, uint256 VAR12) public {
address VAR38 = FUN12(VAR12);
require(VAR16 != VAR38);
require(msg.sender == VAR38 || FUN17(VAR38, msg.sender));
VAR34[VAR12] = VAR16;
emit FUN9(VAR38, VAR16, VAR12);
}
function FUN15(uint256 VAR12) public view returns (address) {
return VAR34[VAR12];
}
function FUN16(address VAR16, bool VAR18) public {
require(VAR16 != msg.sender);
VAR36[msg.sender][VAR16] = VAR18;
emit FUN10(msg.sender, VAR16, VAR18);
}
function FUN17(address VAR17, address VAR19) public view returns (bool) {
return VAR36[VAR17][VAR19];
}
function FUN18(address VAR11, address VAR16, uint256 VAR12) public FUN28(VAR12) {
require(VAR11 != address(0));
require(VAR16 != address(0));
FUN30(VAR11, VAR12);
FUN31(VAR11, VAR12);
FUN32(VAR16, VAR12);
emit Transfer(VAR11, VAR16, VAR12);
}
function FUN19(address VAR11, address VAR16, uint256 VAR12) public FUN28(VAR12) {
FUN19(VAR11, VAR16, VAR12, "");
}
function FUN19(address VAR11, address VAR16, uint256 VAR12, bytes VAR13) public FUN28(VAR12) {
FUN18(VAR11, VAR16, VAR12);
require(FUN33(VAR11, VAR16, VAR12, VAR13));
}
function FUN29(
address VAR39,
uint256 VAR12
)
internal
view
returns (bool)
{
address VAR38 = FUN12(VAR12);
return (
VAR39 == VAR38 ||
FUN15(VAR12) == VAR39 ||
FUN17(VAR38, VAR39)
);
}
function FUN34(address VAR16, uint256 VAR12) internal {
require(VAR16 != address(0));
FUN32(VAR16, VAR12);
emit Transfer(address(0), VAR16, VAR12);
}
function FUN30(address VAR17, uint256 VAR12) internal {
require(FUN12(VAR12) == VAR17);
if (VAR34[VAR12] != address(0)) {
VAR34[VAR12] = address(0);
emit FUN9(VAR17, address(0), VAR12);
}
}
function FUN32(address VAR16, uint256 VAR12) internal {
require(VAR33[VAR12] == address(0));
VAR33[VAR12] = VAR16;
VAR35[VAR16] = VAR35[VAR16].FUN4(1);
}
function FUN31(address VAR11, uint256 VAR12) internal {
require(FUN12(VAR12) == VAR11);
VAR35[VAR11] = VAR35[VAR11].FUN3(1);
VAR33[VAR12] = address(0);
}
function FUN33(
address VAR11,
address VAR16,
uint256 VAR12,
bytes VAR13
)
internal
returns (bool)
{
if (!VAR16.FUN5()) {
return true;
}
bytes4 VAR40 = FUN35(VAR16).FUN7(
VAR11, VAR12, VAR13);
return (VAR40 == VAR10);
}
}
contract VAR41 {
address public VAR38;
address public VAR42;
address public VAR43;
event FUN36(address indexed VAR44, address indexed VAR45);
modifier onlyOwner() {
require(msg.sender == VAR38);
VAR37;
}
modifier onlyManager() {
require(msg.sender == VAR43);
VAR37;
}
modifier FUN37() {
require(msg.sender == VAR42);
VAR37;
}
constructor() public {
VAR38 = msg.sender;
}
function FUN38(address VAR45) public onlyOwner {
VAR42 = VAR45;
}
function FUN39() public VAR46 {
emit FUN36(VAR38, VAR42);
VAR38 = VAR42;
VAR42 = address(0);
}
function FUN40(address VAR47) public onlyOwner {
require(VAR47 != address(0));
VAR43 = VAR47;
}
}
contract HLPMTToken is VAR30, VAR48, VAR49, VAR41 {
bytes4 private constant VAR50 = 0x780e9d63;
bytes4 private constant VAR51 = 0x5b5e139f;
string public VAR52 = "";
string public VAR53 = "";
mapping(address => uint256[]) internal VAR54;
mapping(uint256 => uint256) internal VAR55;
uint256[] internal VAR56;
mapping(uint256 => uint256) internal VAR57;
mapping(uint256 => string) internal VAR58;
constructor(address VAR59, address VAR60) public {
for (uint8 VAR61 = 0; VAR61 < 10; VAR61++) {
FUN34(VAR59, VAR61);
}
for (VAR61 = 10; VAR61 < 20; VAR61++) {
FUN34(VAR60, VAR61);
}
FUN26(VAR50);
FUN26(VAR51);
}
function FUN41(address VAR16, uint256 VAR62) external onlyManager {
FUN34(VAR16, VAR62);
}
function FUN23() external view returns (string) {
return VAR52;
}
function FUN24() external view returns (string) {
return VAR53;
}
function FUN42(address VAR63) public view returns(uint256[]) {
return VAR54[VAR63];
}
function FUN25(uint256 VAR12) public view returns (string) {
require(FUN13(VAR12));
return VAR58[VAR12];
}
function FUN21(address VAR17, uint256 VAR23) public view returns (uint256) {
require(VAR23 < FUN11(VAR17));
return VAR54[VAR17][VAR23];
}
function FUN20() public view returns (uint256) {
return VAR56.VAR64;
}
function FUN22(uint256 VAR23) public view returns (uint256) {
require(VAR23 < FUN20());
return VAR56[VAR23];
}
function FUN43(uint256 VAR12, string VAR65) internal {
require(FUN13(VAR12));
VAR58[VAR12] = VAR65;
}
function FUN32(address VAR16, uint256 VAR12) internal {
super.FUN32(VAR16, VAR12);
uint256 VAR64 = VAR54[VAR16].VAR64;
VAR54[VAR16].FUN44(VAR12);
VAR55[VAR12] = VAR64;
}
function FUN31(address VAR11, uint256 VAR12) internal {
super.FUN31(VAR11, VAR12);
uint256 VAR66 = VAR55[VAR12];
uint256 VAR67 = VAR54[VAR11].VAR64.FUN3(1);
uint256 VAR68 = VAR54[VAR11][VAR67];
VAR54[VAR11][VAR66] = VAR68;
VAR54[VAR11][VAR67] = 0;
VAR54[VAR11].VAR64--;
VAR55[VAR12] = 0;
VAR55[VAR68] = VAR66;
}
function FUN34(address VAR16, uint256 VAR62) internal {
VAR56.FUN44(VAR62);
VAR57[VAR62] = VAR62;
super.FUN34(VAR16, VAR62);
}
}
0
---------------------------------
395 0x024cecfa70ae621850effb46bb5bc16b677bf1f7.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29116800;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 =  0x033C0D18496fecEF676435C8Daf444DC93927253
;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
396 0x025334708ec64febfff398a71f0719a4c0d66739.sol
pragma  VAR1 ^0.4.24;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6{
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
constructor() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN6(address VAR9) onlyOwner public {
require(VAR9 != address(0));
emit FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
library VAR11 {
struct VAR12 {
mapping(address => bool) VAR13;
}
function FUN4(List storage VAR14, address VAR15)
internal
{
VAR14.VAR13[VAR15] = true;
}
function FUN7(List storage VAR14, address VAR15)
internal
{
VAR14.VAR13[VAR15] = false;
}
function FUN8(List storage VAR14, address VAR15)
view
internal
returns (bool)
{
return VAR14.VAR13[VAR15];
}
}
contract VAR16  {
VAR11.List private VAR17;
modifier FUN9() {
require(VAR11.FUN8(VAR17, msg.sender) == true);
VAR10;
}
event FUN10(address VAR15);
event FUN11(address VAR15);
function FUN12()
public
{
VAR11.FUN4(VAR17, msg.sender);
}
function FUN13(address VAR15)
public
{
VAR11.FUN4(VAR17, VAR15);
emit FUN10(VAR15);
}
function FUN14(address VAR15)
public
{
VAR11.FUN7(VAR17, VAR15);
emit FUN11(VAR15);
}
function FUN15(address VAR15)
public
view
returns (bool)
{
return VAR11.FUN8(VAR17, VAR15);
}
}
contract VTEXP is VAR6,VAR16 {
event FUN16(address indexed VAR18, uint256 VAR19);
event FUN17();
event Transfer(address indexed VAR20, address indexed VAR18, uint256 value);
using SafeMath for uint256;
string public constant VAR21 = "";
string public constant VAR22 = "";
uint8 public constant VAR23 = 5;
bool public VAR24 = false;
uint256 public VAR25;
mapping(address => uint256) VAR26;
modifier FUN18() {
require(!VAR24);
VAR10;
}
function FUN19(address VAR27, uint256 VAR28) onlyOwner canMint public returns (bool) {
require(!FUN15(VAR27));
VAR25 = VAR25.FUN4(VAR28);
require(VAR25 <= 10000000000000);
VAR26[VAR27] = VAR26[VAR27].FUN4(VAR28);
emit  FUN16(VAR27, VAR28);
emit Transfer(address(0), VAR27, VAR28);
return true;
}
function FUN20() onlyOwner canMint public returns (bool) {
VAR24 = true;
emit FUN17();
return true;
}
function transfer(address VAR27, uint256 VAR29) public returns (bool) {
require(VAR27 != address(0));
require(VAR29 <= VAR25);
require(!FUN15(VAR27));
VAR26[VAR27] = VAR26[VAR27].FUN4(VAR29);
VAR25 = VAR25.FUN3(VAR29);
VAR26[msg.sender] = VAR26[msg.sender].FUN3(VAR29);
emit Transfer(msg.sender, VAR27, VAR29);
return true;
}
function FUN21(address VAR30, address VAR27, uint256 VAR29) onlyOwner public returns (bool) {
require(!FUN15(VAR27));
require(VAR27 != address(0));
require(VAR29 <= VAR26[VAR30]);
VAR26[VAR30] = VAR26[VAR30].FUN3(VAR29);
VAR26[VAR27] = VAR26[VAR27].FUN4(VAR29);
emit Transfer(VAR30, VAR27, VAR29);
return true;
}
function FUN22(address VAR31) public constant returns (uint256 VAR32) {
return VAR26[VAR31];
}
function FUN23(address VAR31) public constant returns (uint256 VAR32) {
return VAR31.VAR32;
}
}
0
---------------------------------
397 0x0257e647404ebf460266048a2b87ed352fb45c7d.sol
pragma VAR1 ^0.5.2;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
contract VAR6 {
address private VAR7;
event FUN6(address indexed VAR8, address indexed VAR9);
constructor () internal {
VAR7 = msg.sender;
emit FUN6(address(0), VAR7);
}
function FUN7() public view returns (address) {
return VAR7;
}
modifier onlyOwner() {
require(FUN8());
VAR10;
}
function FUN8() public view returns (bool) {
return msg.sender == VAR7;
}
function FUN9() public onlyOwner {
emit FUN6(VAR7, address(0));
VAR7 = address(0);
}
function FUN10(address VAR9) public onlyOwner {
FUN11(VAR9);
}
function FUN11(address VAR9) internal {
require(VAR9 != address(0));
emit FUN6(VAR7, VAR9);
VAR7 = VAR9;
}
}
interface VAR11 {
function transfer(address VAR12, uint256 value) external returns (bool);
function FUN12(address VAR13, uint256 value) external returns (bool);
function FUN13(address VAR14, address VAR12, uint256 value) external returns (bool);
function FUN14() external view returns (uint256);
function FUN15(address VAR15) external view returns (uint256);
function FUN16(address VAR16, address VAR13) external view returns (uint256);
event Transfer(address indexed VAR14, address indexed VAR12, uint256 value);
event FUN17(address indexed VAR16, address indexed VAR13, uint256 value);
}
contract TokenSwap is VAR6 {
using SafeMath for uint256;
IERC20 private VAR17;
IERC20 private VAR18;
uint256 private VAR19;
event FUN18(address indexed sender, uint256 indexed VAR20, uint256 indexed VAR21);
event FUN19(uint256 indexed VAR22);
constructor(
address VAR23,
address VAR24,
uint256 VAR25
) FUN20() public {
require(VAR23 != address(0x0) && VAR24 != address(0x0), "");
require(VAR25 > 0, "");
VAR17 = FUN21(VAR23);
VAR18 = FUN21(VAR24);
VAR19 = VAR25;
}
function FUN22() external returns (bool) {
uint256 VAR26 = VAR17.FUN16(msg.sender, address(this));
require(VAR26 > 0, "");
if (VAR17.FUN13(msg.sender, address(0x0), VAR26)) {
uint256 VAR27 = VAR26.FUN4(999);
VAR27 = VAR27.FUN2(VAR19);
require(VAR18.FUN13(VAR6.FUN7(), msg.sender, VAR27));
emit FUN18(msg.sender, VAR26, VAR27);
}
return true;
}
function FUN23() external onlyOwner {
uint256 VAR28 = VAR17.FUN15(address(this));
require(VAR17.transfer(address(0x0), VAR28));
emit FUN19(VAR28);
}
}
0
---------------------------------
398 0x02591b666f36ab5a8cb7e8c4b9dfb7b6b5888933.sol
pragma solidity 0.4.18;
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);
function FUN2() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN3(address VAR4) public onlyOwner {
require(VAR4 != address(0));
FUN1(VAR2, VAR4);
VAR2 = VAR4;
}
}
library VAR6 {
function FUN4(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
if (VAR7 == 0) {
return 0;
}
uint256 VAR9 = VAR7 * VAR8;
assert(VAR9 / VAR7 == VAR8);
return VAR9;
}
function FUN5(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
uint256 VAR9 = VAR7 / VAR8;
return VAR9;
}
function FUN6(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
assert(VAR8 <= VAR7);
return VAR7 - VAR8;
}
function FUN7(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
uint256 VAR9 = VAR7 + VAR8;
assert(VAR9 >= VAR7);
return VAR9;
}
}
contract VAR10 {
uint256 public VAR11;
function FUN8(address VAR12) public view returns (uint256);
function transfer(address VAR13, uint256 value) public returns (bool);
event Transfer(address indexed VAR14, address indexed VAR13, uint256 value);
}
contract BasicToken is VAR10 {
using SafeMath for uint256;
mapping(address => uint256) VAR15;
function transfer(address VAR16, uint256 VAR17) public returns (bool) {
require(VAR16 != address(0));
require(VAR17 <= VAR15[msg.sender]);
VAR15[msg.sender] = VAR15[msg.sender].FUN6(VAR17);
VAR15[VAR16] = VAR15[VAR16].FUN7(VAR17);
Transfer(msg.sender, VAR16, VAR17);
return true;
}
function FUN8(address VAR18) public view returns (uint256 VAR19) {
return VAR15[VAR18];
}
}
contract ERC20 is VAR10 {
function FUN9(address VAR2, address VAR20) public view returns (uint256);
function FUN10(address VAR14, address VAR13, uint256 value) public returns (bool);
function FUN11(address VAR20, uint256 value) public returns (bool);
event FUN12(address indexed VAR2, address indexed VAR20, uint256 value);
}
contract StandardToken is VAR21, VAR22 {
mapping (address => mapping (address => uint256)) internal VAR23;
function FUN10(address VAR24, address VAR16, uint256 VAR17) public returns (bool) {
require(VAR16 != address(0));
require(VAR17 <= VAR15[VAR24]);
require(VAR17 <= VAR23[VAR24][msg.sender]);
VAR15[VAR24] = VAR15[VAR24].FUN6(VAR17);
VAR15[VAR16] = VAR15[VAR16].FUN7(VAR17);
VAR23[VAR24][msg.sender] = VAR23[VAR24][msg.sender].FUN6(VAR17);
Transfer(VAR24, VAR16, VAR17);
return true;
}
function FUN11(address VAR25, uint256 VAR17) public returns (bool) {
VAR23[msg.sender][VAR25] = VAR17;
FUN12(msg.sender, VAR25, VAR17);
return true;
}
function FUN9(address VAR18, address VAR25) public view returns (uint256) {
return VAR23[VAR18][VAR25];
}
function FUN13(address VAR25, uint VAR26) public returns (bool) {
VAR23[msg.sender][VAR25] = VAR23[msg.sender][VAR25].FUN7(VAR26);
FUN12(msg.sender, VAR25, VAR23[msg.sender][VAR25]);
return true;
}
function FUN14(address VAR25, uint VAR27) public returns (bool) {
uint VAR28 = VAR23[msg.sender][VAR25];
if (VAR27 > VAR28) {
VAR23[msg.sender][VAR25] = 0;
} else {
VAR23[msg.sender][VAR25] = VAR28.FUN6(VAR27);
}
FUN12(msg.sender, VAR25, VAR23[msg.sender][VAR25]);
return true;
}
}
contract MintableToken is VAR29, VAR1 {
event FUN15(address indexed VAR13, uint256 VAR30);
event FUN16();
bool public VAR31 = false;
address public VAR32;
modifier FUN17() {
require(msg.sender == VAR2 || msg.sender == VAR32 || VAR31);
VAR5;
}
function FUN18(address VAR33) public {
require(msg.sender == VAR32 || msg.sender == VAR2);
VAR32 = VAR33;
}
function FUN19(address VAR16, uint256 VAR34) public returns (bool) {
require(msg.sender == VAR32 && !VAR31);
VAR11 = VAR11.FUN7(VAR34);
VAR15[VAR16] = VAR15[VAR16].FUN7(VAR34);
FUN15(VAR16, VAR34);
return true;
}
function FUN20() public returns (bool) {
require((msg.sender == VAR32 || msg.sender == VAR2) && !VAR31);
VAR31 = true;
FUN16();
return true;
}
function transfer(address VAR16, uint256 VAR17) public notLocked returns (bool) {
return super.transfer(VAR16, VAR17);
}
function FUN10(address VAR14, address VAR13, uint256 value) public notLocked returns (bool) {
return super.FUN10(VAR14, VAR13, value);
}
}
contract WBBToken is VAR35 {
string public constant VAR36 = "";
string public constant VAR37 = "";
uint32 public constant VAR38 = 18;
}
contract PercentRateProvider is VAR1 {
uint public VAR39 = 100;
function FUN21(uint VAR40) public onlyOwner {
VAR39 = VAR40;
}
}
contract CommonSale is VAR41 {
using SafeMath for uint;
address public VAR42;
address public VAR43;
uint public VAR44;
uint public VAR45;
uint public VAR46;
WBBToken public VAR47;
uint public VAR48;
uint public VAR49;
modifier FUN22() {
require(VAR49 < VAR48);
VAR5;
}
function FUN23(uint VAR50) public onlyOwner {
VAR48 = VAR50;
}
modifier FUN24() {
require(VAR43 == msg.sender || VAR2 == msg.sender);
VAR5;
}
modifier FUN25(uint value) {
require(value >= VAR46);
VAR5;
}
function FUN26(uint VAR51) public onlyOwner {
VAR45 = VAR51;
}
function FUN27(uint VAR52) public onlyOwner {
VAR46 = VAR52;
}
function FUN28(address VAR53) public onlyOwner {
VAR43 = VAR53;
}
function FUN29(address VAR54) public onlyOwner {
VAR42 = VAR54;
}
function FUN30(uint VAR55) public onlyOwner {
VAR44 = VAR55;
}
function FUN31(address VAR56) public onlyOwner {
VAR47 = FUN32(VAR56);
}
function FUN33(uint VAR57) internal returns(uint);
function FUN34(address VAR13, uint VAR58) public VAR59 {
FUN35(VAR13, VAR58);
}
function FUN35(address VAR13, uint VAR58) internal {
VAR47.FUN19(this, VAR58);
VAR47.transfer(VAR13, VAR58);
}
function FUN36() public view returns(uint);
function FUN37(address VAR13, uint VAR57) public VAR59 returns(uint) {
return FUN38(VAR13, VAR57);
}
function FUN38(address VAR13, uint VAR57) internal VAR60 returns(uint) {
VAR49 = VAR49.FUN7(VAR57);
uint VAR58 = FUN33(VAR57);
FUN35(VAR13, VAR58);
return VAR58;
}
function FUN39() internal FUN25(msg.value) returns(uint) {
require(VAR61 >= VAR45 && VAR61 < FUN36());
VAR42.transfer(msg.value);
return FUN38(msg.sender, msg.value);
}
function () public payable {
FUN39();
}
}
contract VAR62 {
function FUN40(bytes VAR63) internal pure returns(address) {
uint VAR64;
uint VAR65 = 1;
for(uint VAR66 = 20; VAR66 > 0; VAR66--) {
VAR64 += uint8(VAR63[VAR66-1])*VAR65;
VAR65 = VAR65*256;
}
return address(VAR64);
}
function FUN41() internal pure returns(address) {
if(msg.VAR67.VAR68 == 20) {
return FUN40(bytes(msg.VAR67));
}
return address(0);
}
}
contract ReferersRewardFeature is VAR62, VAR69 {
uint public VAR70;
uint public VAR71;
function FUN42(uint VAR72) public onlyOwner {
VAR71 = VAR72;
}
function FUN43(uint VAR73) public onlyOwner {
VAR70 = VAR73;
}
function FUN39() internal returns(uint) {
uint VAR58 = super.FUN39();
if(msg.value >= VAR71) {
address VAR74 = FUN41();
if(VAR74 != address(0)) {
require(VAR74 != address(VAR47) && VAR74 != msg.sender && VAR74 != address(this));
FUN35(VAR74, VAR58.FUN4(VAR70).FUN5(VAR39));
}
}
return VAR58;
}
}
contract RetrieveTokensFeature is VAR1 {
function FUN44(address VAR13, address VAR75) public onlyOwner {
ERC20 VAR76 = FUN45(VAR75);
VAR76.transfer(VAR13, VAR76.FUN8(this));
}
}
contract ValueBonusFeature is VAR41 {
using SafeMath for uint;
struct VAR77 {
uint VAR14;
uint VAR78;
}
VAR77[] public VAR79;
function FUN46(uint VAR14, uint VAR78) public onlyOwner {
VAR79.FUN47(FUN48(VAR14, VAR78));
}
function FUN49(uint VAR58, uint VAR57) public view returns(uint) {
uint VAR80 = FUN50(VAR57);
if(VAR80 == 0) {
return 0;
}
return VAR58.FUN4(VAR80).FUN5(VAR39);
}
function FUN50(uint value) public view returns(uint) {
uint VAR78 = 0;
for(uint VAR66 = 0; VAR66 < VAR79.VAR68; VAR66++) {
if(value >= VAR79[VAR66].VAR14) {
VAR78 = VAR79[VAR66].VAR78;
} else {
return VAR78;
}
}
return VAR78;
}
}
contract WBBCommonSale is VAR81, VAR82, VAR83 {
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR84 {
uint VAR85;
uint VAR78;
}
uint public VAR86;
VAR84[] public VAR87;
function FUN51() public view returns(uint) {
return VAR87.VAR68;
}
function FUN52(uint VAR85, uint VAR78) public onlyOwner {
require(VAR85 > 0);
VAR87.FUN47(FUN53(VAR85, VAR78));
VAR86 = VAR86.FUN7(VAR85);
}
function FUN54(uint8 VAR88) public onlyOwner {
require(VAR88 < VAR87.VAR68);
Milestone storage VAR89 = VAR87[VAR88];
VAR86 = VAR86.FUN6(VAR89.VAR85);
delete VAR87[VAR88];
for (uint VAR66 = VAR88; VAR66 < VAR87.VAR68 - 1; VAR66++) {
VAR87[VAR66] = VAR87[VAR66+1];
}
VAR87.VAR68--;
}
function FUN55(uint8 VAR88, uint VAR85, uint VAR78) public onlyOwner {
require(VAR88 < VAR87.VAR68);
Milestone storage VAR89 = VAR87[VAR88];
VAR86 = VAR86.FUN6(VAR89.VAR85);
VAR89.VAR85 = VAR85;
VAR89.VAR78 = VAR78;
VAR86 = VAR86.FUN7(VAR85);
}
function FUN56(uint8 VAR90, uint VAR85, uint VAR78) public onlyOwner {
require(VAR90 < VAR87.VAR68);
VAR86 = VAR86.FUN7(VAR85);
VAR87.VAR68++;
for (uint VAR66 = VAR87.VAR68 - 2; VAR66 > VAR90; VAR66--) {
VAR87[VAR66 + 1] = VAR87[VAR66];
}
VAR87[VAR90 + 1] = FUN53(VAR85, VAR78);
}
function FUN57() public onlyOwner {
require(VAR87.VAR68 > 0);
for (uint VAR66 = 0; VAR66 < VAR87.VAR68; VAR66++) {
delete VAR87[VAR66];
}
VAR87.VAR68 -= VAR87.VAR68;
VAR86 = 0;
}
function FUN58(uint VAR45) public view returns(uint) {
return VAR45 + VAR86 * 1 VAR91;
}
function FUN59(uint VAR45) public view returns(uint) {
uint VAR92 = VAR45;
for(uint VAR66=0; VAR66 < VAR87.VAR68; VAR66++) {
if(VAR61 >= VAR92 && VAR61 < VAR92 + VAR87[VAR66].VAR85 * 1 VAR91) {
return VAR66;
}
VAR92 = VAR92.FUN7(VAR87[VAR66].VAR85 * 1 VAR91);
}
revert();
}
}
contract Mainsale is VAR93, VAR94 {
address public VAR95;
address public VAR96;
address public VAR97;
uint public VAR98;
uint public VAR99;
uint public VAR100;
function FUN60(uint VAR101) public onlyOwner {
VAR98 = VAR101;
}
function FUN61(uint VAR102) public onlyOwner {
VAR99 = VAR102;
}
function FUN62(uint VAR103) public onlyOwner {
VAR100 = VAR103;
}
function FUN63(address VAR104) public onlyOwner {
VAR95 = VAR104;
}
function FUN64(address VAR105) public onlyOwner {
VAR96 = VAR105;
}
function FUN65(address VAR106) public onlyOwner {
VAR97 = VAR106;
}
function FUN33(uint VAR57) internal returns(uint) {
uint VAR107 = FUN59(VAR45);
Milestone storage VAR89 = VAR87[VAR107];
uint VAR58 = VAR57.FUN4(VAR44).FUN5(1 VAR108);
uint VAR109 = FUN49(VAR58, VAR57);
if(VAR89.VAR78 > 0) {
VAR58 = VAR58.FUN7(VAR58.FUN4(VAR89.VAR78).FUN5(VAR39));
}
return VAR58.FUN7(VAR109);
}
function FUN66() public onlyOwner {
uint VAR110 = VAR100.FUN7(VAR98).FUN7(VAR99);
uint VAR111 = VAR47.FUN67();
uint VAR112 = VAR111.FUN4(VAR39).FUN5(VAR39.FUN6(VAR110));
uint VAR113 = VAR112.FUN4(VAR98).FUN5(VAR39);
uint VAR114 = VAR112.FUN4(VAR99).FUN5(VAR39);
uint VAR115 = VAR112.FUN4(VAR100).FUN5(VAR39);
FUN35(VAR95, VAR113);
FUN35(VAR96, VAR114);
FUN35(VAR97, VAR115);
VAR47.FUN20();
}
function FUN36() public view returns(uint) {
return FUN58(VAR45);
}
}
contract Presale is VAR94 {
Mainsale public VAR116;
uint public VAR85;
function FUN33(uint VAR57) internal returns(uint) {
uint VAR58 = VAR57.FUN4(VAR44).FUN5(1 VAR108);
return VAR58.FUN7(FUN49(VAR58, VAR57));
}
function FUN68(uint VAR117) public onlyOwner {
VAR85 = VAR117;
}
function FUN69(address VAR118) public onlyOwner {
VAR116 = FUN70(VAR118);
}
function FUN66() public onlyOwner {
VAR47.FUN18(VAR116);
}
function FUN36() public view returns(uint) {
return VAR45.FUN7(VAR85 * 1 VAR91);
}
}
contract Configurator is VAR1 {
WBBToken public VAR47;
Presale public VAR119;
Mainsale public VAR116;
function FUN71() public onlyOwner {
VAR47 = VAR120 FUN32();
VAR119 = VAR120 FUN72();
VAR119.FUN29(0xa00d43EeaFa8BD5f18Ee9b167b9B41a61B817e14);
VAR119.FUN26(1521072000);
VAR119.FUN68(105);
VAR119.FUN30(125000000000000000000);
VAR119.FUN23(42000000000000000000000);
VAR47.FUN18(VAR119);
FUN73(VAR119, VAR47);
VAR116 = VAR120 FUN70();
VAR116.FUN52(7, 21);
VAR116.FUN52(7, 14);
VAR116.FUN52(7, 8);
VAR116.FUN52(7, 3);
VAR116.FUN30(125000000000000000000);
VAR116.FUN29(0xa00d43EeaFa8BD5f18Ee9b167b9B41a61B817e14);
VAR116.FUN63(0xa00d43EeaFa8BD5f18Ee9b167b9B41a61B817e14);
VAR116.FUN64(0xaC2b309b00342B2994E9A80AEfdEeF803303D4D2);
VAR116.FUN65(0x1a0bAa25b4E5a75ceB348De587674dc05Ad3362D);
VAR116.FUN26(1535760000);
VAR116.FUN23(830000000000000000000000);
VAR116.FUN60(15);
VAR116.FUN61(10);
VAR116.FUN62(5);
FUN73(VAR116, VAR47);
VAR119.FUN69(VAR116);
VAR47.FUN3(VAR2);
VAR119.FUN3(VAR2);
VAR116.FUN3(VAR2);
}
function FUN73(address VAR121, address VAR122) internal {
WBBCommonSale VAR123 = FUN74(VAR121);
VAR123.FUN46(800000000000000000, 10);
VAR123.FUN46(4000000000000000000, 15);
VAR123.FUN46(8000000000000000000, 20);
VAR123.FUN46(40000000000000000000, 25);
VAR123.FUN42(1000000000000000000);
VAR123.FUN43(5);
VAR123.FUN27(10000000000000000);
VAR123.FUN31(VAR122);
}
}
0
---------------------------------
399 0x025cd28d7ef83e1c2ffe511d5f9290d54ba5dcf0.sol
pragma solidity 0.4.20;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
modifier VAR6 {
require(FUN5() > 0);
VAR7;
}
modifier VAR8 {
require(FUN6(true) > 0);
VAR7;
}
event FUN7(
address indexed VAR9,
uint256 VAR10,
uint256 VAR11,
address indexed VAR12,
uint VAR13,
uint256 VAR14
);
event FUN8(
address indexed VAR9,
uint256 VAR15,
uint256 VAR16,
uint VAR13,
uint256 VAR14
);
event FUN9(
address indexed VAR9,
uint256 VAR17,
uint256 VAR11
);
event FUN10(
address indexed VAR9,
uint256 VAR18
);
event Transfer(
address indexed VAR19,
address indexed VAR20,
uint256 VAR21
);
MoonInc public VAR22;
string public VAR23 = "";
string public VAR24 = "";
uint8 constant public VAR25 = 18;
uint8 public VAR26;
uint8 public VAR27;
uint8 public VAR28;
uint8 constant internal VAR29 = 20;
uint256 public VAR30;
uint256 public VAR31;
uint256 constant internal VAR32 = 2 ** 64;
uint256 public VAR33 = 10e18;
uint256 public VAR34;
uint256 public VAR35;
mapping(address => uint) public VAR36;
mapping(address => bool) public VAR37;
mapping(address => address) public VAR38;
mapping(address => uint256) internal VAR39;
mapping(address => uint256) internal VAR40;
mapping(address => VAR41) internal VAR42;
uint256 internal VAR43;
function FUN11(
address VAR44, uint8 VAR45, uint8 VAR46, uint8 VAR47,
uint VAR48, uint VAR49, uint VAR50, uint VAR51
) public {
VAR22 = FUN12(VAR44);
VAR26 = VAR45;
VAR27 = VAR46;
VAR28 = VAR47;
VAR30 = VAR48;
VAR31 = VAR49;
VAR34 = VAR50;
VAR35 = VAR51;
uint VAR52 = 1000;
VAR36[0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD] = 0.28 VAR53 / VAR52;
VAR37[address(0)] = true;
VAR36[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0.28 VAR53 / VAR52;
VAR38[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD;
VAR36[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0.28 VAR53 / VAR52;
VAR38[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f;
VAR36[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0.09 VAR53 / VAR52;
VAR38[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0x183feBd8828a9ac6c70C0e27FbF441b93004fC05;
VAR36[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0.09 VAR53 / VAR52;
VAR38[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d;
VAR36[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0.09 VAR53 / VAR52;
VAR38[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05;
VAR36[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0.09 VAR53 / VAR52;
VAR38[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41;
VAR36[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0.09 VAR53 / VAR52;
VAR38[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0x0a3239799518E7F7F339867A4739282014b97Dcf;
}
function FUN13(address VAR54) public payable returns (uint256) {
FUN14(msg.value, VAR54);
}
function() payable public {
FUN14(msg.value, 0x0);
}
function FUN15() onlyStronghands public {
uint256 VAR55 = FUN6(false);
address VAR56 = msg.sender;
VAR42[VAR56] +=  (VAR41) (VAR55 * VAR32);
VAR55 += VAR40[VAR56];
VAR40[VAR56] = 0;
uint256 VAR57 = FUN14(VAR55, 0x0);
FUN9(VAR56, VAR55, VAR57);
}
function FUN16() public {
address VAR56 = msg.sender;
uint256 VAR57 = VAR39[VAR56];
if (VAR57 > 0) FUN17(VAR57);
FUN18();
}
function FUN18() onlyStronghands public {
address VAR56 = msg.sender;
uint256 VAR55 = FUN6(false);
VAR42[VAR56] += (VAR41) (VAR55 * VAR32);
VAR55 += VAR40[VAR56];
VAR40[VAR56] = 0;
VAR56.transfer(VAR55);
FUN10(VAR56, VAR55);
}
function FUN17(uint256 VAR58) onlyBagholders public {
require(VAR59 >= VAR35);
address VAR56 = msg.sender;
require(VAR58 <= VAR39[VAR56]);
uint256 VAR57 = VAR58;
uint256 VAR60 = FUN19(VAR57);
uint256 VAR55 = VAR1.FUN2(VAR1.FUN1(VAR60, VAR28), 100);
uint256 VAR61 = VAR1.FUN3(VAR60, VAR55);
VAR43 = VAR1.FUN3(VAR43, VAR57);
VAR39[VAR56] = VAR1.FUN3(VAR39[VAR56], VAR57);
int256 VAR62 = (VAR41) (VAR61 * VAR32);
VAR42[VAR56] -= VAR62;
VAR22.VAR63.value(VAR55)(VAR56, VAR57 * VAR34);
FUN8(VAR56, VAR57, VAR61, VAR59, FUN20());
}
function transfer(address VAR64, uint256 VAR58) onlyBagholders public returns (bool) {
address VAR56 = msg.sender;
require(VAR58 <= VAR39[VAR56]);
if (FUN6(true) > 0) {
FUN18();
}
uint256 VAR65 = VAR1.FUN2(VAR1.FUN1(VAR58, VAR27), 100);
uint256 VAR66 = VAR1.FUN3(VAR58, VAR65);
uint256 VAR55 = FUN19(VAR65);
VAR43 = VAR1.FUN3(VAR43, VAR65);
VAR39[VAR56] = VAR1.FUN3(VAR39[VAR56], VAR58);
VAR39[VAR64] = VAR1.FUN4(VAR39[VAR64], VAR66);
VAR22.VAR63.value(VAR55)(VAR56, VAR58 * VAR34);
VAR22.FUN21(VAR64, VAR66 * VAR34);
Transfer(VAR56, VAR64, VAR66);
return true;
}
function FUN22() public view returns (uint8, uint8, uint8, uint256, uint256, uint256, uint256) {
return (VAR26, VAR27, VAR28, VAR30,
VAR31, VAR34, VAR35);
}
function FUN23() public view returns (uint256) {
return this.VAR67;
}
function FUN24() public view returns (uint256) {
return VAR43;
}
function FUN5() public view returns (uint256) {
address VAR56 = msg.sender;
return FUN25(VAR56);
}
function FUN6(bool VAR68) public view returns (uint256) {
address VAR56 = msg.sender;
return VAR68 ? FUN26(VAR56) + VAR40[VAR56] : FUN26(VAR56) ;
}
function FUN25(address VAR56) public view returns (uint256) {
return VAR39[VAR56];
}
function FUN26(address VAR56) public view returns (uint256) {
return (uint256) ((VAR41) (-VAR42[VAR56])) / VAR32;
}
function FUN27() public view returns (uint256) {
if (VAR43 == 0) {
return VAR30 - VAR31;
} else {
uint256 VAR60 = FUN19(1e18);
uint256 VAR55 = VAR1.FUN2(VAR1.FUN1(VAR60, VAR28), 100);
uint256 VAR61 = VAR1.FUN3(VAR60, VAR55);
return VAR61;
}
}
function FUN20() public view returns (uint256) {
if (VAR43 == 0) {
return VAR30 + VAR31;
} else {
uint256 VAR60 = FUN19(1e18);
uint256 VAR55 = VAR1.FUN2(VAR1.FUN1(VAR60, VAR26), 100);
uint256 VAR61 = VAR1.FUN4(VAR60, VAR55);
return VAR61;
}
}
function FUN28(uint256 VAR69) public view returns (uint256) {
uint256 VAR55 = VAR1.FUN2(VAR1.FUN1(VAR69, VAR26), 100);
uint256 VAR61 = VAR1.FUN3(VAR69, VAR55);
uint256 VAR58 = FUN29(VAR61);
return VAR58;
}
function FUN30(uint256 VAR70) public view returns (uint256) {
require(VAR70 <= VAR43);
uint256 VAR60 = FUN19(VAR70);
uint256 VAR55 = VAR1.FUN2(VAR1.FUN1(VAR60, VAR28), 100);
uint256 VAR61 = VAR1.FUN3(VAR60, VAR55);
return VAR61;
}
function FUN14(uint256 VAR71, address VAR54) internal returns (uint256) {
require(VAR71 <= 1 VAR72);
require(
VAR59 >= VAR35 ||
(VAR59 >= VAR35 - 1 VAR73 && !VAR37[msg.sender] && VAR37[VAR38[msg.sender]] && VAR71 <= VAR36[msg.sender]) ||
(VAR59 >= VAR35 - 10 VAR74 && !VAR37[msg.sender] && VAR71 <= VAR36[msg.sender])
);
if (VAR59 < VAR35) {
VAR37[msg.sender] = true;
}
address VAR56 = msg.sender;
uint256 VAR75 = VAR1.FUN2(VAR1.FUN1(VAR71, VAR26), 100);
uint256 VAR76 = VAR1.FUN2(VAR1.FUN1(VAR75, VAR29), 100);
uint256 VAR55 = VAR1.FUN3(VAR75, VAR76);
uint256 VAR61 = VAR1.FUN3(VAR71, VAR75);
uint256 VAR58 = FUN29(VAR61);
require(VAR58 > 0 && VAR1.FUN4(VAR58, VAR43) > VAR43);
if (
VAR54 != 0x0000000000000000000000000000000000000000 &&
VAR54 != VAR56 &&
VAR39[VAR54] >= VAR33
) {
VAR40[VAR54] = VAR1.FUN4(VAR40[VAR54], VAR76);
} else {
VAR55 = VAR1.FUN4(VAR55, VAR76);
}
VAR43 = VAR1.FUN4(VAR43, VAR58);
VAR39[VAR56] = VAR1.FUN4(VAR39[VAR56], VAR58);
VAR22.VAR77.value(VAR55)(VAR56, VAR58 * VAR34);
FUN7(VAR56, VAR71, VAR58, VAR54, VAR59, FUN20());
return VAR58;
}
function FUN29(uint256 VAR60) internal view returns (uint256) {
uint256 VAR48 = VAR30 * 1e18;
uint256 VAR78 =
(
(
VAR1.FUN3(
(VAR79
(
(VAR48 ** 2)
+
(2 * (VAR31 * 1e18) * (VAR60 * 1e18))
+
((VAR31 ** 2) * (VAR43 ** 2))
+
(2 * VAR31 * VAR48*VAR43)
)
), VAR48
)
) / (VAR31)
) - (VAR43);
return VAR78;
}
function FUN19(uint256 VAR57) internal view returns (uint256) {
uint256 VAR80 = (VAR57 + 1e18);
uint256 VAR81 = (VAR43 + 1e18);
uint256 VAR82 =
(
VAR1.FUN3(
(
(
(
VAR30 + (VAR31 * (VAR81 / 1e18))
) - VAR31
) * (VAR80 - 1e18)
), (VAR31 * ((VAR80 ** 2 - VAR80) / 1e18)) / 2
)
/ 1e18);
return VAR82;
}
function FUN31(uint256 VAR83) internal pure returns (uint256 VAR84) {
uint256 VAR85 = (VAR83 + 1) / 2;
VAR84 = VAR83;
while (VAR85 < VAR84) {
VAR84 = VAR85;
VAR85 = (VAR83 / VAR85 + VAR85) / 2;
}
}
}
contract VAR86 {
string public constant VAR23  = "";
string public constant VAR24 = "";
uint8 public constant VAR25 = 18;
uint256 public VAR87;
uint256 public VAR88;
uint256 private VAR89;
uint256 private VAR90;
mapping(address => uint256) public VAR91;
mapping(address => uint256) public VAR92;
mapping(address => uint256) private VAR93;
mapping(address => mapping(address => uint256)) internal VAR94;
VAR5[] public VAR95;
mapping(address => bool) VAR96;
uint256[] public VAR97;
uint256 public constant VAR98 = 1526763600;
event Transfer(address indexed VAR19, address indexed VAR20, uint VAR21);
event FUN32(address indexed VAR99, address indexed VAR100, uint VAR21);
function FUN12() public payable {
FUN33();
}
function() public payable {
VAR87 += msg.value;
}
function FUN33() public {
require(VAR95.VAR101 == 0);
FUN34(10, 10, 10, 0.0000001 VAR53 / 1000, 0.00000001 VAR53 / 1000, 1, VAR98);
}
function FUN35() public {
require(VAR95.VAR101 == 1);
FUN34(15, 15, 15, 0.0000001 VAR53 / 1000, 0.00000001 VAR53 / 1000, 3, VAR98 + 1 VAR102);
}
function FUN36() public {
require(VAR95.VAR101 == 2);
FUN34(20, 20, 20, 0.0000001 VAR53 / 1000, 0.00000001 VAR53 / 1000, 9, VAR98 + 2 VAR102);
}
function FUN34(
uint8 VAR45, uint8 VAR46, uint8 VAR47, uint256 VAR48,
uint256 VAR49, uint256 VAR50, uint256 VAR51
) internal {
ProductionUnitToken VAR103 = VAR104 FUN11(address(this),
VAR45, VAR46, VAR47, VAR48, VAR49, VAR50, VAR51);
VAR95.FUN37(VAR103);
VAR96[address(VAR103)] = true;
VAR97.FUN37(VAR51);
}
function FUN38() public view returns (uint) {
return VAR95.VAR101;
}
function FUN21(address VAR105, uint256 VAR106) public payable {
require(VAR96[msg.sender]);
FUN39(VAR105);
VAR88 = VAR1.FUN4(VAR88, VAR106);
VAR91[VAR105] = VAR1.FUN4(VAR91[VAR105], VAR106);
if (msg.value > 0) {
VAR87 += msg.value;
}
}
function FUN40(address VAR105, uint256 VAR106) public payable {
require(VAR96[msg.sender]);
FUN39(VAR105);
VAR88 = VAR1.FUN3(VAR88, VAR106);
VAR91[VAR105] = VAR1.FUN3(VAR91[VAR105], VAR106);
if (msg.value > 0) {
VAR87 += msg.value;
}
}
function FUN41() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
return (VAR88, VAR91[msg.sender], FUN24(), FUN25(msg.sender),
VAR87, VAR90, FUN42());
}
function FUN24() public constant returns(uint256) {
return VAR89 + FUN43();
}
function FUN25(address VAR105) public constant returns(uint256) {
return VAR92[VAR105] + FUN44(VAR105);
}
function FUN43() public constant returns(uint256) {
if (VAR90 > 0 && VAR90 < VAR107.VAR13) {
return (VAR88 * (VAR107.VAR13 - VAR90));
}
return 0;
}
function FUN44(address VAR105) internal constant returns (uint256) {
uint256 VAR108 = VAR93[VAR105];
if (VAR108 > 0 && VAR108 < VAR107.VAR13) {
return (VAR91[VAR105] * (VAR107.VAR13 - VAR108));
}
return 0;
}
function transfer(address VAR109, uint256 VAR106) public returns (bool) {
FUN39(msg.sender);
require(VAR106 <= VAR92[msg.sender]);
VAR92[msg.sender] -= VAR106;
VAR92[VAR109] += VAR106;
Transfer(msg.sender, VAR109, VAR106);
return true;
}
function FUN45(address VAR105, address VAR109, uint256 VAR106) public returns (bool) {
FUN39(VAR105);
require(VAR106 <= VAR94[VAR105][msg.sender] && VAR106 <= VAR92[VAR105]);
VAR92[VAR105] -= VAR106;
VAR92[VAR109] += VAR106;
VAR94[VAR105][msg.sender] -= VAR106;
Transfer(VAR105, VAR109, VAR106);
return true;
}
function FUN46(address VAR110, uint256 VAR106) public returns (bool){
VAR94[msg.sender][VAR110] = VAR106;
FUN32(msg.sender, VAR110, VAR106);
return true;
}
function FUN47(address VAR105, address VAR110) public constant returns(uint256){
return VAR94[VAR105][VAR110];
}
function FUN39(address VAR105) internal {
VAR89 += FUN43();
VAR92[VAR105] += FUN44(VAR105);
VAR90 = VAR107.VAR13;
VAR93[VAR105] = VAR107.VAR13;
}
function FUN48() public {
FUN39(msg.sender);
uint256 VAR111 = FUN42();
require(VAR111 > 0);
uint256 VAR112 = VAR92[msg.sender];
uint256 value = VAR112 * VAR111 / (1 VAR53);
VAR92[msg.sender] = 0;
msg.sender.transfer(value);
}
function FUN42() public view returns (uint) {
uint256 VAR113 = FUN24();
if (VAR113 == 0) {
return 0;
}
uint VAR114;
uint VAR115 = VAR59;
while (VAR114 < VAR97.VAR101 && VAR97[VAR114] < VAR59) {
VAR115 = VAR97[VAR114];
VAR114++;
}
if (VAR59 < VAR115 + 1 VAR73) {
return 0;
}
uint VAR116 = 2 VAR102;
uint256 VAR117 = VAR59 - VAR115;
VAR117 = VAR117 <= VAR116 ? VAR117 : VAR116;
uint256 VAR118 = 5000 + 5000 * VAR117 / VAR116;
return 1 VAR53 * VAR87 / VAR113 * VAR118 / 10000;
}
}
0
---------------------------------
400 0x027fb74201bb7ae54de24f88f3f66f482be61f23.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 27561600;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x6748D59A6aCCeE1E76d62345da53AD52c220Eb97;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
401 0x0297fdbcb9c2023bc05ad44c9f6e69b0ae6261ce.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
address VAR3;
address public VAR4;
address public VAR5;
mapping (uint => bool) public VAR6;
modifier onlyOwner {
require(msg.sender == VAR3);
VAR7;
}
function FUN1() public {
VAR3 = msg.sender;
}
function FUN2(address VAR8) public onlyOwner {
VAR4 = VAR8;
}
function FUN3(address VAR8) public onlyOwner {
VAR5 = VAR8;
}
function FUN4(uint VAR9) public {
IFrom VAR10 = FUN5(VAR4);
require(VAR10.FUN6(VAR9) == msg.sender);
require(VAR6[VAR9] == false);
VAR6[VAR9] = true;
ITo VAR11 = FUN7(VAR5);
VAR11.FUN8(1, msg.sender);
}
}
interface VAR12 {
function FUN6 (uint256 VAR13) public view returns (address VAR14);
}
interface VAR15 {
function FUN8(uint256 VAR16, address VAR17) public;
}
0
---------------------------------
402 0x029cb57991b2a2cad9271b8c4131bb8551982014.sol
pragma VAR1 ^0.4.22;
contract VAR2{
uint public VAR3;
function FUN1() payable public {
require(msg.value==0.0001 VAR4);
VAR3 = VAR3+1;
if(VAR3==2) {
msg.sender.transfer(this.VAR5);
VAR3 = 0;
}
}
}
0
---------------------------------
403 0x029eb0c7b72b54c6b90a4b2548bb25c8221059f1.sol
pragma VAR1 ^0.5.7;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
event FUN5(address indexed VAR9, address indexed VAR8);
constructor() public {
VAR7 = msg.sender;
VAR8 = address(0);
}
modifier onlyOwner() {
require(msg.sender == VAR7, "");
VAR10;
}
function FUN6(address VAR11) public onlyOwner {
require(address(0) != VAR11, "");
VAR8 = VAR11;
}
function FUN7() public {
require(msg.sender == VAR8, "");
emit FUN5(VAR7, msg.sender);
VAR7 = msg.sender;
VAR8 = address(0);
}
}
contract Authorizable is VAR6 {
mapping(address => bool) public VAR12;
event FUN8(address indexed VAR13, bool indexed VAR14);
constructor() public {
VAR12[msg.sender] = true;
}
modifier FUN9() {
require(VAR12[msg.sender], "");
VAR10;
}
function FUN10(address VAR13, bool VAR14) onlyOwner public {
emit FUN8(VAR13, VAR14);
VAR12[VAR13] = VAR14;
}
}
contract VAR15 {
function transfer(address VAR16, uint256 VAR17) public returns (bool);
}
contract MultiSender is VAR18 {
tokenInterface public VAR19;
mapping( bytes32 => bool) public VAR20;
constructor(address VAR21) public {
VAR19 = FUN11(VAR21);
}
function FUN12(address VAR21) public VAR22 {
VAR19 = FUN11(VAR21);
}
function FUN13(address[] memory VAR23, uint256[] memory VAR24, bytes32[] memory VAR25) public VAR22 {
require(VAR23.VAR26 == VAR24.VAR26, "");
require(VAR23.VAR26 == VAR25.VAR26, "");
for( uint256 VAR27 = 0; VAR27 < VAR23.VAR26; VAR27 += 1 ) {
if ( VAR20[VAR25[VAR27]] == false ) {
VAR19.transfer(VAR23[VAR27], VAR24[VAR27]);
VAR20[VAR25[VAR27]] = true;
}
}
}
function FUN14(address VAR28, uint256 value) public onlyAuthorized returns (bool) {
return VAR19.transfer(VAR28, value);
}
function FUN15() public onlyAuthorized returns (bool) {
msg.sender.transfer(address(this).VAR29);
return true;
}
}
0
---------------------------------
404 0x02a89330e27675bf50bb32833e4e430056aef504.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 { function transfer(address VAR7, uint VAR8){  } }
contract VAR9 {
using SafeMath for uint256;
address public VAR10;
address public VAR11;
address public VAR12;
address VAR13;
token VAR14;
uint256 public VAR15;
uint256 public VAR16;
uint256 public VAR17;
uint256 public VAR18;
uint256 public VAR19;
uint256 public VAR20;
event FUN5(address indexed VAR21, address indexed VAR22, uint256 value, uint256 VAR8);
function FUN6() {
VAR10 = 0x5cB7a6547A9408e3C9B09FB5c640d4fB767b8070;
VAR11 = 0x8F2d31E3c259F65222D0748e416A79e51589Ce3b;
VAR12 = 0x336b903eF5e3c911df7f8172EcAaAA651B80CA1D;
VAR13 = 0x38dCb83980183f089FC7D147c5bF82E5C9b8F237;
VAR14 = FUN7(VAR13);
VAR15 = 1533583718;
VAR16 = VAR15 + 182 * 1 VAR23;
}
function () payable {
FUN8(msg.sender);
}
function FUN8(address VAR22) payable {
require(VAR22 != 0x0);
require(FUN9());
uint256 VAR24 = msg.value;
if(VAR24 < 2.5 * 10**18) throw;
if(VAR24 > 25 * 10**18) throw;
VAR18 = (5 * VAR24)/100;
VAR20 = (25 * VAR24)/100;
VAR19 = (70 * VAR24)/100;
uint256 VAR25 = 25000000000000000;
uint256 VAR26 = (VAR24 *10**18) / VAR25;
VAR17 = VAR17.FUN4(VAR24);
VAR14.transfer(VAR22, VAR26);
FUN5(msg.sender, VAR22, VAR24, VAR26);
FUN10();
}
function FUN10() internal {
if (!VAR10.FUN11(VAR18)) {
throw;
}
if (!VAR11.FUN11(VAR19)){
throw;
}
if (!VAR12.FUN11(VAR20)){
throw;
}
}
function FUN9() internal constant returns (bool) {
bool VAR27 = VAR28 >= VAR15 && VAR28 <= VAR16;
bool VAR29 = msg.value != 0;
return VAR27 && VAR29;
}
function FUN12() public constant returns (bool) {
return VAR28 > VAR16;
}
function FUN13(uint256 VAR30) {
if(msg.sender!=VAR10) throw;
VAR14.transfer(VAR10,VAR30);
}
}
0
---------------------------------
405 0x02a9bb92365b72fb735364af2af55ebfa9eb02c2.sol
pragma VAR1 >=0.5.4 <0.6.0;
interface VAR2 { function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external; }
contract VAR7 {
address public VAR8;
address public VAR9;
mapping (address => bool) public VAR10;
constructor() public {
VAR8 = msg.sender;
}
modifier FUN2() {
require (VAR10[msg.sender] == true);
VAR11;
}
function FUN3(address VAR12) public {
require (msg.sender == VAR8);
require (VAR12 != address(0));
VAR8 = VAR12;
}
function FUN4(address VAR13, bool VAR14) public {
require (msg.sender == VAR8);
require (VAR13 != address(0));
VAR10[VAR13] = VAR14;
}
}
library VAR15 {
function FUN5(uint256 VAR16, uint256 VAR17) internal pure returns (uint256 VAR18) {
if (VAR16 == 0) {
return 0;
}
VAR18 = VAR16 * VAR17;
assert(VAR18 / VAR16 == VAR17);
return VAR18;
}
function FUN6(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
return VAR16 / VAR17;
}
function FUN7(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
assert(VAR17 <= VAR16);
return VAR16 - VAR17;
}
function FUN8(uint256 VAR16, uint256 VAR17) internal pure returns (uint256 VAR18) {
VAR18 = VAR16 + VAR17;
assert(VAR18 >= VAR16);
return VAR18;
}
}
interface VAR19 {
function FUN9(address VAR20, address VAR21) external view returns (bool);
function FUN10(address VAR20, address VAR21) external view returns (bool);
function FUN11(address VAR20, address VAR21) external view returns (bool);
function FUN12(address VAR20, address VAR21) external view returns (bool);
function FUN13(address VAR21) external view returns (address);
function FUN14(address VAR22, address VAR21) external view returns (bool);
function FUN15(address VAR22, address VAR21) external view returns (bool);
function FUN16(address VAR21, address VAR23, address VAR24, address VAR25) external returns (bool);
function FUN17(address VAR20, address VAR21) external view returns (uint256);
}
contract VAR26 {
string public VAR27;
string public VAR28;
uint8 public VAR29 = 18;
uint256 public VAR30;
mapping (address => uint256) public VAR31;
mapping (address => mapping (address => uint256)) public VAR32;
event Transfer(address indexed VAR33, address indexed VAR34, uint256 value);
event FUN18(address indexed VAR35, address indexed VAR36, uint256 VAR4);
event FUN19(address indexed VAR33, uint256 value);
constructor (uint256 VAR37, string memory VAR38, string memory VAR39) public {
VAR30 = VAR37 * 10 ** uint256(VAR29);
VAR31[msg.sender] = VAR30;
VAR27 = VAR38;
VAR28 = VAR39;
}
function FUN20(address VAR3, address VAR40, uint VAR4) internal {
require(VAR40 != address(0));
require(VAR31[VAR3] >= VAR4);
require(VAR31[VAR40] + VAR4 > VAR31[VAR40]);
uint VAR41 = VAR31[VAR3] + VAR31[VAR40];
VAR31[VAR3] -= VAR4;
VAR31[VAR40] += VAR4;
emit Transfer(VAR3, VAR40, VAR4);
assert(VAR31[VAR3] + VAR31[VAR40] == VAR41);
}
function transfer(address VAR40, uint256 VAR4) public returns (bool VAR42) {
FUN20(msg.sender, VAR40, VAR4);
return true;
}
function FUN21(address VAR3, address VAR40, uint256 VAR4) public returns (bool VAR42) {
require(VAR4 <= VAR32[VAR3][msg.sender]);
VAR32[VAR3][msg.sender] -= VAR4;
FUN20(VAR3, VAR40, VAR4);
return true;
}
function FUN22(address VAR36, uint256 VAR4) public returns (bool VAR42) {
VAR32[msg.sender][VAR36] = VAR4;
emit FUN18(msg.sender, VAR36, VAR4);
return true;
}
function FUN23(address VAR36, uint256 VAR4, bytes memory VAR6) public returns (bool VAR42) {
tokenRecipient VAR43 = FUN24(VAR36);
if (FUN22(VAR36, VAR4)) {
VAR43.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN25(uint256 VAR4) public returns (bool VAR42) {
require(VAR31[msg.sender] >= VAR4);
VAR31[msg.sender] -= VAR4;
VAR30 -= VAR4;
emit FUN19(msg.sender, VAR4);
return true;
}
function FUN26(address VAR3, uint256 VAR4) public returns (bool VAR42) {
require(VAR31[VAR3] >= VAR4);
require(VAR4 <= VAR32[VAR3][msg.sender]);
VAR31[VAR3] -= VAR4;
VAR32[VAR3][msg.sender] -= VAR4;
VAR30 -= VAR4;
emit FUN19(VAR3, VAR4);
return true;
}
}
interface VAR44 {
function FUN27(address VAR21) external view returns (bool);
}
interface VAR45 {
function FUN28(address VAR22) external view returns (uint256);
function FUN29(address VAR22) external returns (uint256);
function FUN30(address VAR46) external view returns (address);
function FUN31(address VAR21, address VAR47) external returns (bool);
function FUN32(address VAR22) external view returns (address);
}
interface VAR48 {
function FUN33(address VAR49, bool VAR50, uint256 VAR51) external returns (bool);
}
interface VAR52 {
function FUN34(address VAR49, string calldata VAR53) external view returns (uint256, bool, address, bytes32, string VAR54);
function FUN35() external view returns (uint8, uint8, uint8, uint8, uint8);
function FUN36(uint256 VAR55) external view returns (uint8);
}
interface VAR56 {
function FUN16(address VAR21, address VAR57, uint256 VAR58) external returns (bool);
function FUN37(address VAR21) external view returns (address, uint256, uint256);
function FUN38(address VAR49, address VAR59) external returns (bool);
function FUN39(address VAR49, address VAR59) external view returns (bool);
}
interface VAR60 {
function FUN40(string calldata VAR61) external view returns (bool);
function FUN16(string calldata VAR61, address VAR62, uint256 VAR63, string calldata VAR64, address VAR57, uint256 VAR65) external returns (bool);
function FUN41(address VAR21) external view returns (string VAR54, address, uint256, string VAR54, address, uint256);
function FUN42(string calldata VAR61) external view returns (address);
}
interface VAR66 {
function FUN28(address VAR49) external view returns (uint256);
function FUN29(address VAR49) external returns (uint256);
}
contract VAR67 {
using SafeMath for uint256;
address public VAR68;
string public VAR27;
address public VAR69;
string public VAR70;
string public VAR71;
string public VAR72;
bytes32 public VAR73;
uint8 public VAR74;
constructor (string memory VAR61,
address VAR75,
string memory VAR76,
string memory VAR77,
string memory VAR78,
bytes32 VAR79,
address VAR80
) public {
VAR27 = VAR61;
VAR69 = VAR75;
VAR70 = VAR76;
VAR71 = VAR77;
VAR72 = VAR78;
VAR73 = VAR79;
VAR74 = 0;
VAR68 = VAR80;
}
modifier VAR81 {
require (msg.sender == VAR68);
VAR11;
}
function () external payable {
}
function FUN43(address payable VAR82, uint256 VAR83) public onlyVault returns (bool) {
VAR82.transfer(VAR83);
return true;
}
function FUN44(address VAR84, address VAR82, uint256 VAR83) public onlyVault returns (bool) {
TokenERC20 VAR85 = FUN45(VAR84);
VAR85.transfer(VAR82, VAR83);
return true;
}
}
contract Name is VAR67 {
constructor (string memory VAR61, address VAR75, string memory VAR76, string memory VAR77, string memory VAR78, bytes32 VAR79, address VAR80)
FUN46 (VAR61, VAR75, VAR76, VAR77, VAR78, VAR79, VAR80) public {
VAR74 = 1;
}
}
library VAR86 {
using SafeMath for uint256;
uint256 constant private VAR87 = 10 ** 6;
uint256 constant private VAR88 = 10 ** 6;
function FUN47(address VAR49) public view returns (bool) {
return (VAR49 != address(0) && bytes(FUN46(address(FUN48(VAR49))).FUN49()).VAR89 > 0 && FUN46(address(FUN48(VAR49))).FUN50() != address(0) && FUN46(address(FUN48(VAR49))).FUN51() == 0);
}
function FUN52(address VAR22) public view returns (bool) {
return (VAR22 != address(0) && bytes(FUN46(address(FUN48(VAR22))).FUN49()).VAR89 > 0 && FUN53(address(FUN48(VAR22))).FUN50() != address(0) && FUN53(address(FUN48(VAR22))).FUN51() == 1);
}
function FUN54(address VAR90) public view returns (bool) {
if (VAR90 == address(0)) {
return false;
}
TokenERC20 VAR85 = FUN45(VAR90);
return (VAR85.FUN55() >= 0 && bytes(VAR85.FUN49()).VAR89 > 0 && bytes(VAR85.FUN56()).VAR89 > 0);
}
function FUN57(address VAR20, address VAR12, address VAR91) public view returns (bool) {
return (VAR20 == VAR12 ||
(
(FUN47(VAR12) || FUN52(VAR12)) &&
VAR91 != address(0) &&
FUN58(VAR91).FUN9(VAR20, VAR12)
)
);
}
function FUN59() public pure returns (uint256) {
return VAR88;
}
function FUN60() public pure returns (uint256) {
return VAR87;
}
function FUN61(string memory VAR61,
address VAR75,
string memory VAR76,
string memory VAR77,
string memory VAR78,
bytes32 VAR79,
address VAR92
) public returns (TAO VAR93) {
VAR93 = VAR94 FUN46(VAR61, VAR75, VAR76, VAR77, VAR78, VAR79, VAR92);
}
function FUN62(string memory VAR61,
address VAR75,
string memory VAR76,
string memory VAR77,
string memory VAR78,
bytes32 VAR79,
address VAR92
) public returns (Name VAR95) {
VAR95 = VAR94 FUN53(VAR61, VAR75, VAR76, VAR77, VAR78, VAR79, VAR92);
}
function FUN63(uint256 VAR96, uint256 VAR97, uint256 VAR98, uint256 VAR99) public pure returns (uint256) {
if (VAR96 > 0) {
uint256 VAR100 = (VAR96.FUN5(VAR97)).FUN8(VAR98.FUN5(VAR99));
uint256 VAR101 = VAR97.FUN8(VAR99);
return VAR100.FUN6(VAR101);
} else {
return VAR98;
}
}
function FUN64(uint256 VAR102, uint256 VAR103, uint256 VAR104, uint256 VAR105, uint256 VAR106) public pure returns (uint256) {
if (VAR102 > 0 && VAR102 <= VAR103.FUN7(VAR104)) {
uint256 VAR107 = VAR104.FUN8(VAR102.FUN6(2));
uint256 VAR108 = (VAR87.FUN7(VAR87.FUN5(VAR107).FUN6(VAR103))).FUN5(VAR105.FUN7(VAR106));
return VAR108.FUN6(VAR87);
} else {
return 0;
}
}
function FUN65(uint256 VAR102, uint256 VAR103, uint256 VAR104, uint256 VAR105, uint256 VAR106) public pure returns (uint256) {
if (VAR102 > 0 && VAR102 <= VAR103.FUN7(VAR104)) {
uint256 VAR107 = VAR104.FUN8(VAR102.FUN6(2));
uint256 VAR109 = (VAR88.FUN7(VAR88.FUN5(VAR107).FUN6(VAR103))).FUN5(VAR105.FUN7(VAR106)).FUN6(VAR88);
return VAR109;
} else {
return 0;
}
}
function FUN66(uint256 VAR102, uint256 VAR103, uint256 VAR104, uint256 VAR105, uint256 VAR106) public pure returns (uint256) {
uint256 VAR109 = FUN65(VAR102, VAR103, VAR104, VAR105, VAR106);
uint256 VAR110 = VAR109.FUN5(VAR102).FUN6(VAR88);
return VAR110;
}
function FUN67(uint256 VAR111, uint256 VAR96, uint256 VAR112) public pure returns (uint256) {
return (VAR112.FUN5(VAR111).FUN7(VAR111.FUN5(VAR96))).FUN6(VAR112);
}
function FUN68(uint256 VAR111, uint256 VAR96, uint256 VAR113) public pure returns (uint256) {
return VAR111.FUN5(VAR96).FUN6(VAR111.FUN7(VAR113));
}
function FUN69(uint256 VAR111, uint256 VAR96, uint256 VAR114) public pure returns (uint256) {
return VAR111.FUN5(VAR96).FUN6(VAR111.FUN8(VAR114));
}
function FUN70(uint256 VAR115) public pure returns (uint8) {
uint8 VAR116 = 0;
while(VAR115 != 0) {
VAR115 = VAR115.FUN6(10);
VAR116++;
}
return VAR116;
}
}
contract TAOController is VAR7 {
address public VAR117;
address public VAR118;
INameFactory internal VAR119;
INameTAOPosition internal VAR120;
INameAccountRecovery internal VAR121;
constructor(address VAR122) public {
FUN71(VAR122);
}
modifier VAR123 {
require (VAR86.FUN57(msg.sender, VAR8, VAR9));
VAR11;
}
modifier FUN47(address VAR49) {
require (VAR86.FUN47(VAR49));
VAR11;
}
modifier FUN52(address VAR22) {
require (VAR86.FUN52(VAR22));
VAR11;
}
modifier FUN72(address VAR21) {
require (VAR86.FUN52(VAR21) || VAR86.FUN47(VAR21));
VAR11;
}
modifier FUN73() {
require (VAR119.FUN30(msg.sender) != address(0));
VAR11;
}
modifier FUN74(address VAR21) {
require (VAR120.FUN9(msg.sender, VAR21));
VAR11;
}
modifier FUN75() {
require (!VAR121.FUN27(VAR119.FUN30(msg.sender)));
VAR11;
}
function FUN3(address VAR12) public VAR123 {
require (VAR12 != address(0));
VAR8 = VAR12;
}
function FUN4(address VAR13, bool VAR14) public VAR123 {
require (VAR13 != address(0));
VAR10[VAR13] = VAR14;
}
function FUN71(address VAR122) public VAR123 {
require (VAR122 != address(0));
VAR117 = VAR122;
VAR119 = FUN76(VAR122);
}
function FUN77(address VAR91) public VAR123 {
require (VAR91 != address(0));
VAR9 = VAR91;
VAR120 = FUN58(VAR91);
}
function FUN78(address VAR124) public VAR123 {
require (VAR124 != address(0));
VAR118 = VAR124;
VAR121 = FUN79(VAR118);
}
}
contract TAOCurrency is VAR7 {
using SafeMath for uint256;
string public VAR27;
string public VAR28;
uint8 public VAR29;
uint256 public VAR125;
uint256 public VAR30;
mapping (address => uint256) public VAR31;
event Transfer(address indexed VAR33, address indexed VAR34, uint256 value);
event FUN19(address indexed VAR33, uint256 value);
constructor (string memory VAR61, string memory VAR126, address VAR91) public {
VAR27 = VAR61;
VAR28 = VAR126;
VAR125 = 0;
VAR29 = 0;
FUN77(VAR91);
}
modifier VAR123 {
require (VAR86.FUN57(msg.sender, VAR8, VAR9));
VAR11;
}
modifier FUN72(address VAR21) {
require (VAR86.FUN52(VAR21) || VAR86.FUN47(VAR21));
VAR11;
}
function FUN3(address VAR12) public VAR123 {
require (VAR12 != address(0));
VAR8 = VAR12;
}
function FUN4(address VAR13, bool VAR14) public VAR123 {
require (VAR13 != address(0));
VAR10[VAR13] = VAR14;
}
function FUN77(address VAR91) public VAR123 {
require (VAR91 != address(0));
VAR9 = VAR91;
}
function FUN21(address VAR3, address VAR40, uint256 VAR4) public VAR127 FUN72(VAR3) FUN72(VAR40) returns (bool) {
FUN20(VAR3, VAR40, VAR4);
return true;
}
function FUN80(address VAR128, uint256 VAR129) public VAR127 FUN72(VAR128) returns (bool) {
FUN81(VAR128, VAR129);
return true;
}
function FUN82(address VAR3, uint256 VAR4) public VAR127 FUN72(VAR3) returns (bool VAR42) {
require(VAR31[VAR3] >= VAR4);
VAR31[VAR3] = VAR31[VAR3].FUN7(VAR4);
VAR30 = VAR30.FUN7(VAR4);
emit FUN19(VAR3, VAR4);
return true;
}
function FUN20(address VAR3, address VAR40, uint256 VAR4) internal {
require (VAR40 != address(0));
require (VAR31[VAR3] >= VAR4);
require (VAR31[VAR40].FUN8(VAR4) >= VAR31[VAR40]);
uint256 VAR41 = VAR31[VAR3].FUN8(VAR31[VAR40]);
VAR31[VAR3] = VAR31[VAR3].FUN7(VAR4);
VAR31[VAR40] = VAR31[VAR40].FUN8(VAR4);
emit Transfer(VAR3, VAR40, VAR4);
assert(VAR31[VAR3].FUN8(VAR31[VAR40]) == VAR41);
}
function FUN81(address VAR128, uint256 VAR129) internal {
VAR31[VAR128] = VAR31[VAR128].FUN8(VAR129);
VAR30 = VAR30.FUN8(VAR129);
emit Transfer(address(0), address(this), VAR129);
emit Transfer(address(this), VAR128, VAR129);
}
}
contract Logos is VAR130 {
address public VAR117;
address public VAR118;
INameFactory internal VAR119;
INameTAOPosition internal VAR120;
INameAccountRecovery internal VAR121;
mapping (address => uint256) public VAR131;
mapping (address => mapping(address => uint256)) public VAR132;
mapping (address => uint256) public VAR133;
mapping (address => mapping(address => uint256)) public VAR134;
mapping (address => uint256) public VAR135;
event FUN83(address indexed VAR33, address indexed VAR34, uint256 value);
event FUN84(address indexed VAR33, address indexed VAR34, uint256 value);
event FUN85(address indexed VAR136, address indexed VAR137, uint256 VAR138);
event FUN86(address indexed VAR139, address indexed VAR140, address indexed VAR137, uint256 VAR138);
constructor(string memory VAR61, string memory VAR126, address VAR122, address VAR91)
FUN87(VAR61, VAR126, VAR91) public {
FUN71(VAR122);
FUN77(VAR91);
}
modifier FUN47(address VAR49) {
require (VAR86.FUN47(VAR49));
VAR11;
}
modifier FUN52(address VAR22) {
require (VAR86.FUN52(VAR22));
VAR11;
}
modifier FUN74(address VAR21) {
require (VAR120.FUN9(msg.sender, VAR21));
VAR11;
}
modifier FUN88(address VAR21) {
require (!VAR121.FUN27(VAR21));
VAR11;
}
modifier FUN75() {
require (!VAR121.FUN27(VAR119.FUN30(msg.sender)));
VAR11;
}
function FUN71(address VAR122) public VAR123 {
require (VAR122 != address(0));
VAR117 = VAR122;
VAR119 = FUN76(VAR122);
}
function FUN77(address VAR91) public VAR123 {
require (VAR91 != address(0));
VAR9 = VAR91;
VAR120 = FUN58(VAR91);
}
function FUN78(address VAR124) public VAR123 {
require (VAR124 != address(0));
VAR118 = VAR124;
VAR121 = FUN79(VAR118);
}
function FUN89(address VAR141) public FUN52(VAR141) view returns (uint256) {
return VAR31[VAR141].FUN8(VAR131[VAR141]).FUN8(VAR135[VAR141]);
}
function FUN90(address VAR20) public FUN52(VAR20) view returns (uint256) {
return VAR31[VAR20].FUN7(VAR133[VAR20]);
}
function FUN91(address VAR3, address VAR40, uint256 VAR4) public FUN52(VAR3) FUN52(VAR40) FUN88(VAR3) FUN88(VAR40) FUN74(VAR3) senderNameNotCompromised returns (bool) {
require (VAR3 != VAR40);
require (FUN90(VAR3) >= VAR4);
require (VAR131[VAR40].FUN8(VAR4) >= VAR131[VAR40]);
VAR132[VAR3][VAR40] = VAR132[VAR3][VAR40].FUN8(VAR4);
VAR133[VAR3] = VAR133[VAR3].FUN8(VAR4);
VAR131[VAR40] = VAR131[VAR40].FUN8(VAR4);
emit FUN83(VAR3, VAR40, VAR4);
return true;
}
function FUN92(address VAR3, address VAR40, uint256 VAR4) public FUN52(VAR3) FUN52(VAR40) FUN88(VAR3) FUN88(VAR40) FUN74(VAR3) senderNameNotCompromised returns (bool) {
require (VAR3 != VAR40);
require (VAR132[VAR3][VAR40] >= VAR4);
VAR132[VAR3][VAR40] = VAR132[VAR3][VAR40].FUN7(VAR4);
VAR133[VAR3] = VAR133[VAR3].FUN7(VAR4);
VAR131[VAR40] = VAR131[VAR40].FUN7(VAR4);
emit FUN84(VAR3, VAR40, VAR4);
return true;
}
function FUN93(address VAR49, uint256 VAR83) public VAR127 FUN47(VAR49) returns (bool) {
require (VAR83 > 0);
address VAR22 = VAR120.FUN13(VAR49);
VAR134[VAR22][VAR49] = VAR134[VAR22][VAR49].FUN8(VAR83);
VAR135[VAR22] = VAR135[VAR22].FUN8(VAR83);
emit FUN85(VAR22, VAR49, VAR83);
return true;
}
function FUN94(address VAR142, address VAR49) public VAR127 FUN52(VAR142) FUN47(VAR49) returns (bool) {
address VAR143 = VAR120.FUN13(VAR49);
require (VAR142 != VAR143);
require (VAR135[VAR142] >= VAR134[VAR142][VAR49]);
uint256 VAR83 = VAR134[VAR142][VAR49];
VAR134[VAR142][VAR49] = 0;
VAR135[VAR142] = VAR135[VAR142].FUN7(VAR83);
VAR134[VAR143][VAR49] = VAR134[VAR143][VAR49].FUN8(VAR83);
VAR135[VAR143] = VAR135[VAR143].FUN8(VAR83);
emit FUN86(VAR142, VAR143, VAR49, VAR83);
return true;
}
}
contract TAOFactory is VAR144, VAR66 {
using SafeMath for uint256;
address[] internal VAR145;
address public VAR146;
address public VAR147;
address public VAR148;
address public VAR149;
address public VAR150;
address public VAR151;
address public VAR152;
INameTAOLookup internal VAR153;
IAOSetting internal VAR154;
Logos internal VAR155;
ITAOAncestry internal VAR156;
ITAOPool internal VAR157;
mapping (address => uint256) internal VAR158;
event FUN95(address indexed VAR159, address VAR137, uint256 VAR160, string VAR27, address VAR161, uint8 VAR162);
constructor(address VAR122)
FUN96(VAR122) public {}
modifier VAR163 {
require (msg.sender == VAR9 || msg.sender == VAR150 || msg.sender == VAR152);
VAR11;
}
function FUN97(address VAR164) public VAR123 {
require (VAR164 != address(0));
VAR146 = VAR164;
VAR153 = FUN98(VAR164);
}
function FUN99(address VAR165) public VAR123 {
require (VAR165 != address(0));
VAR147 = VAR165;
VAR154 = FUN100(VAR165);
}
function FUN101(address VAR166) public VAR123 {
require (VAR166 != address(0));
VAR148 = VAR166;
VAR155 = FUN102(VAR166);
}
function FUN103(address VAR92) public VAR123 {
require (VAR92 != address(0));
VAR149 = VAR92;
}
function FUN104(address VAR167) public VAR123 {
require (VAR167 != address(0));
VAR150 = VAR167;
VAR156 = FUN105(VAR150);
}
function FUN106(address VAR168) public VAR123 FUN47(VAR168) {
VAR151 = VAR168;
}
function FUN107(address VAR169) public VAR123 {
require (VAR169 != address(0));
VAR152 = VAR169;
VAR157 = FUN108(VAR152);
}
function FUN28(address VAR49) external view returns (uint256) {
return VAR158[VAR49];
}
function FUN29(address VAR49) external canUpdateNonce returns (uint256) {
require (VAR158[VAR49] > 0);
VAR158[VAR49]++;
return VAR158[VAR49];
}
function FUN109(
string memory VAR61,
string memory VAR76,
string memory VAR77,
string memory VAR78,
bytes32 VAR79,
address VAR57,
uint256 VAR58,
bool VAR50,
uint256 VAR51
) public senderIsName VAR170 FUN72(VAR57) {
require (bytes(VAR61).VAR89 > 0);
require (!VAR153.FUN40(VAR61));
uint256 VAR171 = VAR155.FUN89(VAR119.FUN30(msg.sender));
if (VAR86.FUN47(VAR57)) {
(, uint256 VAR172,) = VAR156.FUN37(VAR57);
require (VAR171 >= VAR172);
} else {
require (VAR171 >= FUN110());
}
require (FUN111(VAR61, VAR119.FUN30(msg.sender), VAR76, VAR77, VAR78, VAR79, VAR57, VAR58, VAR50, VAR51));
}
function FUN112(address VAR49) public view returns (string VAR54, address, string VAR54, string VAR54, string VAR54, string VAR54, bytes32, uint8) {
TAO VAR93 = FUN46(address(FUN48(VAR49)));
return (
VAR93.FUN49(),
VAR93.FUN50(),
FUN53(address(FUN48(VAR93.FUN50()))).FUN49(),
VAR93.FUN113(),
VAR93.FUN114(),
VAR93.FUN115(),
VAR93.FUN116(),
VAR93.FUN51()
);
}
function FUN117() public view returns (uint256) {
return VAR145.VAR89;
}
function FUN118(uint256 VAR3, uint256 VAR40) public view returns (address[] VAR54) {
require (VAR3 >= 0 && VAR40 >= VAR3);
require (VAR145.VAR89 > 0);
address[] memory VAR173 = new address[](VAR40.FUN7(VAR3).FUN8(1));
if (VAR40 > VAR145.VAR89.FUN7(1)) {
VAR40 = VAR145.VAR89.FUN7(1);
}
for (uint256 VAR174 = VAR3; VAR174 <= VAR40; VAR174++) {
VAR173[VAR174.FUN7(VAR3)] = VAR145[VAR174];
}
return VAR173;
}
function FUN119(
string memory VAR175,
uint256 VAR176,
address VAR177,
string memory VAR61,
uint8 VAR178,
bytes32 VAR179,
bytes32 VAR180
) public FUN47(FUN120(VAR61)) view returns (bool, string VAR54, uint256) {
address VAR181 = FUN121(VAR175, VAR176, VAR178, VAR179, VAR180);
if (FUN122(VAR177, VAR181, FUN120(VAR61), VAR176)) {
return (true, FUN53(address(FUN48(VAR119.FUN30(VAR181)))).FUN49(), VAR120.FUN17(VAR181, FUN120(VAR61)));
} else {
return (false, "", 0);
}
}
function FUN111(
string memory VAR61,
address VAR22,
string memory VAR76,
string memory VAR77,
string memory VAR78,
bytes32 VAR79,
address VAR57,
uint256 VAR58,
bool VAR50,
uint256 VAR51
) internal returns (bool) {
address VAR137 = address(VAR86.FUN61(VAR61, VAR22, VAR76, VAR77, VAR78, VAR79, VAR149));
VAR158[VAR137]++;
require (VAR153.FUN16(VAR61, VAR137, 0, FUN46(address(FUN48(VAR57))).FUN49(), VAR57, uint256(FUN46(address(FUN48(VAR57))).FUN51())));
require (VAR120.FUN16(VAR137, VAR22, VAR22, VAR22));
require (VAR156.FUN16(VAR137, VAR57, VAR58));
require (VAR157.FUN33(VAR137, VAR50, VAR51));
VAR145.FUN123(VAR137);
emit FUN95(VAR22, VAR137, VAR145.VAR89.FUN7(1), VAR61, VAR57, FUN46(address(FUN48(VAR57))).FUN51());
if (VAR86.FUN47(VAR57)) {
require (VAR156.FUN38(VAR57, VAR137));
}
return true;
}
function FUN122(
address VAR177,
address VAR181,
address VAR49,
uint256 VAR176
) internal view returns (bool) {
if (VAR177 != address(0)) {
return (VAR176 == VAR158[VAR49].FUN8(1) &&
VAR181 == VAR177 &&
VAR120.FUN12(VAR177, VAR49)
);
} else {
return (
VAR176 == VAR158[VAR49].FUN8(1) &&
VAR120.FUN12(VAR181, VAR49)
);
}
}
function FUN120(string memory VAR61) internal view returns (address) {
return VAR153.FUN42(VAR61);
}
function FUN110() internal view returns (uint256) {
(uint256 VAR182,,,,) = VAR154.FUN34(VAR151, '');
return VAR182;
}
function FUN121(string memory VAR175, uint256 VAR176, uint8 VAR183, bytes32 VAR184, bytes32 VAR185) internal view returns (address) {
bytes32 VAR186 = FUN124(VAR187.FUN125(address(this), VAR175, VAR176));
return FUN126(VAR186, VAR183, VAR184, VAR185);
}
}
0
---------------------------------
406 0x02aa19a0ece7c95d40e2d22990ac33e78b8e9238.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
function FUN5()public view returns (uint VAR6);
function FUN6(address VAR7)public view returns (uint256 VAR8);
function FUN7(address VAR7, address VAR9)public view returns (uint VAR10);
function FUN8(address VAR11, address VAR12, uint VAR13)public returns (bool VAR14);
function FUN9(address VAR9, uint VAR13)public returns (bool VAR14);
function transfer(address VAR12, uint VAR13)public returns (bool VAR14);
event Transfer(address indexed VAR11, address indexed VAR12, uint VAR13);
event FUN10(address indexed VAR7, address indexed VAR9, uint VAR13);
}
contract QatarCentralBank is VAR5
{using SafeMath for uint256;
string public constant VAR15 = "";
string public constant VAR16 = "";
uint public constant VAR17 = 18;
uint256 VAR18 = 999000000000000000000 * 10 ** 18;
address public VAR19;
mapping(address => uint256) VAR20;
mapping(address => mapping (address => uint256)) VAR21;
modifier onlyOwner() {
if (msg.sender != VAR19) {
revert();
}
VAR22;
}
constructor () public {
VAR19 = msg.sender;
VAR20[VAR19] = VAR18;
emit Transfer(0, VAR19, VAR18);
}
function FUN11(uint256 VAR23) public onlyOwner {
VAR18 = (VAR18).FUN3(VAR23);
}
function FUN5() public view returns (uint256 VAR6) {
VAR6 = VAR18;
}
function FUN6(address VAR7)public view returns (uint256 VAR8) {
return VAR20[VAR7];
}
function transfer(address VAR12, uint256 VAR13)public returns (bool VAR14) {
require( VAR12 != 0x0);
require(VAR20[msg.sender] >= VAR13 && VAR13 >= 0);
VAR20[msg.sender] = (VAR20[msg.sender]).FUN3(VAR13);
VAR20[VAR12] = (VAR20[VAR12]).FUN4(VAR13);
emit Transfer(msg.sender, VAR12, VAR13);
return true;
}
function FUN8( address VAR11, address VAR12, uint256 VAR13 )public returns (bool VAR14) {
require( VAR12 != 0x0);
require(VAR20[VAR11] >= VAR13 && VAR21[VAR11][msg.sender] >= VAR13 && VAR13 >= 0);
VAR20[VAR11] = (VAR20[VAR11]).FUN3(VAR13);
VAR21[VAR11][msg.sender] = (VAR21[VAR11][msg.sender]).FUN3(VAR13);
VAR20[VAR12] = (VAR20[VAR12]).FUN4(VAR13);
emit Transfer(VAR11, VAR12, VAR13);
return true;
}
function FUN9(address VAR9, uint256 VAR13)public returns (bool VAR14) {
require( VAR9 != 0x0);
VAR21[msg.sender][VAR9] = VAR13;
emit FUN10(msg.sender, VAR9, VAR13);
return true;
}
function FUN7(address VAR7, address VAR9)public view returns (uint256 VAR10) {
require( VAR7 != 0x0 && VAR9 !=0x0);
return VAR21[VAR7][VAR9];
}
function FUN12(address VAR24) external onlyOwner
{
uint256 VAR25 = VAR20[VAR19];
require( VAR24 != 0x0);
VAR20[VAR24] = (VAR20[VAR24]).FUN4(VAR20[VAR19]);
VAR20[VAR19] = 0;
VAR19 = VAR24;
emit Transfer(msg.sender, VAR24, VAR25);
}
}
0
---------------------------------
407 0x02ab3549536c140af39ebb1c42f25a8e70b4a10a.sol
pragma solidity 0.4.23;
interface VAR1 {
function FUN1(uint256 VAR2) external;
function FUN2() external view returns(uint256);
function FUN3() external view returns(uint256);
}
pragma solidity 0.4.23;
interface VAR3 {
function FUN4() external view returns(bytes32, bool);
function FUN5() external view returns(bytes32);
}
library VAR4 {
function FUN6(uint256 VAR5, uint256 VAR6) internal pure returns (uint256 VAR7) {
if (VAR5 == 0) {
return 0;
}
VAR7 = VAR5 * VAR6;
assert(VAR7 / VAR5 == VAR6);
return VAR7;
}
function FUN7(uint256 VAR5, uint256 VAR6) internal pure returns (uint256) {
return VAR5 / VAR6;
}
function FUN8(uint256 VAR5, uint256 VAR6) internal pure returns (uint256) {
assert(VAR6 <= VAR5);
return VAR5 - VAR6;
}
function FUN9(uint256 VAR5, uint256 VAR6) internal pure returns (uint256 VAR7) {
VAR7 = VAR5 + VAR6;
assert(VAR7 >= VAR5);
return VAR7;
}
}
contract VAR8 {
address public VAR9;
event FUN10(address indexed VAR10, address indexed VAR11);
function FUN11() public {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9);
VAR12;
}
function FUN12(address VAR11) public onlyOwner {
require(VAR11 != address(0));
emit FUN10(VAR9, VAR11);
VAR9 = VAR11;
}
}
contract MakerDAOPriceFeed is VAR8, VAR1 {
using SafeMath for uint256;
uint256 public constant VAR13 = 10;
uint256 public constant VAR14 = 10**36;
ReadableI public VAR15;
uint256 private VAR16;
uint256 private VAR17;
event FUN13(uint256 VAR18, uint256 VAR19);
modifier FUN14(uint256 VAR2) {
require(FUN15(VAR2));
VAR12;
}
constructor(ReadableI VAR20) {
require(VAR20 != address(0));
VAR15 = VAR20;
VAR16 = FUN16(VAR20.FUN5());
VAR17 = VAR21;
}
function FUN1(uint256 VAR2)
external
onlyOwner
FUN14(VAR2)
{
VAR16 = VAR2;
VAR17 = VAR21;
emit FUN13(VAR2, VAR21);
}
function FUN2()
public
view
returns(uint256)
{
return VAR16;
}
function FUN3()
public
view
returns(uint256)
{
return VAR17;
}
function FUN15(uint256 VAR2) public view returns(bool) {
if (VAR2 == 0) return false;
bytes32 value;
bool VAR22;
(value, VAR22) = VAR15.FUN4();
uint256 VAR23 = VAR22 ? FUN16(value) : VAR16;
uint256 VAR24 = VAR2 < VAR23 ?  VAR23.FUN8(VAR2) : VAR2.FUN8(VAR23);
return VAR24 <= VAR23.FUN6(VAR13).FUN7(100);
}
function FUN16(bytes32 VAR25) internal pure returns(uint256) {
uint256 value = uint256(VAR25);
return VAR14.FUN7(value);
}
}
0
---------------------------------
408 0x02ae1deb9a7e9ff1c5354f9c670bf1edde6f728d.sol
pragma VAR1 >=0.5.4 <0.6.0;
interface VAR2 { function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external; }
library VAR7 {
function FUN2(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
if (VAR8 == 0) {
return 0;
}
VAR10 = VAR8 * VAR9;
assert(VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN3(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
return VAR8 / VAR9;
}
function FUN4(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
assert(VAR9 <= VAR8);
return VAR8 - VAR9;
}
function FUN5(uint256 VAR8, uint256 VAR9) internal pure returns (uint256 VAR10) {
VAR10 = VAR8 + VAR9;
assert(VAR10 >= VAR8);
return VAR10;
}
}
interface VAR11 {
function FUN6(address VAR12, address VAR13) external view returns (bool);
function FUN7(address VAR12, address VAR13) external view returns (bool);
function FUN8(address VAR12, address VAR13) external view returns (bool);
function FUN9(address VAR12, address VAR13) external view returns (bool);
function FUN10(address VAR13) external view returns (address);
function FUN11(address VAR14, address VAR13) external view returns (bool);
function FUN12(address VAR14, address VAR13) external view returns (bool);
function FUN13(address VAR13, address VAR15, address VAR16, address VAR17) external returns (bool);
function FUN14(address VAR12, address VAR13) external view returns (uint256);
}
contract VAR18 {
string public VAR19;
string public VAR20;
uint8 public VAR21 = 18;
uint256 public VAR22;
mapping (address => uint256) public VAR23;
mapping (address => mapping (address => uint256)) public VAR24;
event Transfer(address indexed VAR25, address indexed VAR26, uint256 value);
event FUN15(address indexed VAR27, address indexed VAR28, uint256 VAR4);
event FUN16(address indexed VAR25, uint256 value);
constructor (uint256 VAR29, string memory VAR30, string memory VAR31) public {
VAR22 = VAR29 * 10 ** uint256(VAR21);
VAR23[msg.sender] = VAR22;
VAR19 = VAR30;
VAR20 = VAR31;
}
function FUN17(address VAR3, address VAR32, uint VAR4) internal {
require(VAR32 != address(0));
require(VAR23[VAR3] >= VAR4);
require(VAR23[VAR32] + VAR4 > VAR23[VAR32]);
uint VAR33 = VAR23[VAR3] + VAR23[VAR32];
VAR23[VAR3] -= VAR4;
VAR23[VAR32] += VAR4;
emit Transfer(VAR3, VAR32, VAR4);
assert(VAR23[VAR3] + VAR23[VAR32] == VAR33);
}
function transfer(address VAR32, uint256 VAR4) public returns (bool VAR34) {
FUN17(msg.sender, VAR32, VAR4);
return true;
}
function FUN18(address VAR3, address VAR32, uint256 VAR4) public returns (bool VAR34) {
require(VAR4 <= VAR24[VAR3][msg.sender]);
VAR24[VAR3][msg.sender] -= VAR4;
FUN17(VAR3, VAR32, VAR4);
return true;
}
function FUN19(address VAR28, uint256 VAR4) public returns (bool VAR34) {
VAR24[msg.sender][VAR28] = VAR4;
emit FUN15(msg.sender, VAR28, VAR4);
return true;
}
function FUN20(address VAR28, uint256 VAR4, bytes memory VAR6) public returns (bool VAR34) {
tokenRecipient VAR35 = FUN21(VAR28);
if (FUN19(VAR28, VAR4)) {
VAR35.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN22(uint256 VAR4) public returns (bool VAR34) {
require(VAR23[msg.sender] >= VAR4);
VAR23[msg.sender] -= VAR4;
VAR22 -= VAR4;
emit FUN16(msg.sender, VAR4);
return true;
}
function FUN23(address VAR3, uint256 VAR4) public returns (bool VAR34) {
require(VAR23[VAR3] >= VAR4);
require(VAR4 <= VAR24[VAR3][msg.sender]);
VAR23[VAR3] -= VAR4;
VAR24[VAR3][msg.sender] -= VAR4;
VAR22 -= VAR4;
emit FUN16(VAR3, VAR4);
return true;
}
}
contract VAR36 {
using SafeMath for uint256;
address public VAR37;
string public VAR19;
address public VAR38;
string public VAR39;
string public VAR40;
string public VAR41;
bytes32 public VAR42;
uint8 public VAR43;
constructor (string memory VAR44,
address VAR45,
string memory VAR46,
string memory VAR47,
string memory VAR48,
bytes32 VAR49,
address VAR50
) public {
VAR19 = VAR44;
VAR38 = VAR45;
VAR39 = VAR46;
VAR40 = VAR47;
VAR41 = VAR48;
VAR42 = VAR49;
VAR43 = 0;
VAR37 = VAR50;
}
modifier VAR51 {
require (msg.sender == VAR37);
VAR52;
}
function () external payable {
}
function FUN24(address payable VAR53, uint256 VAR54) public onlyVault returns (bool) {
VAR53.transfer(VAR54);
return true;
}
function FUN25(address VAR55, address VAR53, uint256 VAR54) public onlyVault returns (bool) {
TokenERC20 VAR56 = FUN26(VAR55);
VAR56.transfer(VAR53, VAR54);
return true;
}
}
contract Name is VAR36 {
constructor (string memory VAR44, address VAR45, string memory VAR46, string memory VAR47, string memory VAR48, bytes32 VAR49, address VAR50)
FUN27 (VAR44, VAR45, VAR46, VAR47, VAR48, VAR49, VAR50) public {
VAR43 = 1;
}
}
library VAR57 {
using SafeMath for uint256;
uint256 constant private VAR58 = 10 ** 6;
uint256 constant private VAR59 = 10 ** 6;
function FUN28(address VAR60) public view returns (bool) {
return (VAR60 != address(0) && bytes(FUN27(address(FUN29(VAR60))).FUN30()).VAR61 > 0 && FUN27(address(FUN29(VAR60))).FUN31() != address(0) && FUN27(address(FUN29(VAR60))).FUN32() == 0);
}
function FUN33(address VAR14) public view returns (bool) {
return (VAR14 != address(0) && bytes(FUN27(address(FUN29(VAR14))).FUN30()).VAR61 > 0 && FUN34(address(FUN29(VAR14))).FUN31() != address(0) && FUN34(address(FUN29(VAR14))).FUN32() == 1);
}
function FUN35(address VAR62) public view returns (bool) {
if (VAR62 == address(0)) {
return false;
}
TokenERC20 VAR56 = FUN26(VAR62);
return (VAR56.FUN36() >= 0 && bytes(VAR56.FUN30()).VAR61 > 0 && bytes(VAR56.FUN37()).VAR61 > 0);
}
function FUN38(address VAR12, address VAR63, address VAR64) public view returns (bool) {
return (VAR12 == VAR63 ||
(
(FUN28(VAR63) || FUN33(VAR63)) &&
VAR64 != address(0) &&
FUN39(VAR64).FUN6(VAR12, VAR63)
)
);
}
function FUN40() public pure returns (uint256) {
return VAR59;
}
function FUN41() public pure returns (uint256) {
return VAR58;
}
function FUN42(string memory VAR44,
address VAR45,
string memory VAR46,
string memory VAR47,
string memory VAR48,
bytes32 VAR49,
address VAR65
) public returns (TAO VAR66) {
VAR66 = VAR67 FUN27(VAR44, VAR45, VAR46, VAR47, VAR48, VAR49, VAR65);
}
function FUN43(string memory VAR44,
address VAR45,
string memory VAR46,
string memory VAR47,
string memory VAR48,
bytes32 VAR49,
address VAR65
) public returns (Name VAR68) {
VAR68 = VAR67 FUN34(VAR44, VAR45, VAR46, VAR47, VAR48, VAR49, VAR65);
}
function FUN44(uint256 VAR69, uint256 VAR70, uint256 VAR71, uint256 VAR72) public pure returns (uint256) {
if (VAR69 > 0) {
uint256 VAR73 = (VAR69.FUN2(VAR70)).FUN5(VAR71.FUN2(VAR72));
uint256 VAR74 = VAR70.FUN5(VAR72);
return VAR73.FUN3(VAR74);
} else {
return VAR71;
}
}
function FUN45(uint256 VAR75, uint256 VAR76, uint256 VAR77, uint256 VAR78, uint256 VAR79) public pure returns (uint256) {
if (VAR75 > 0 && VAR75 <= VAR76.FUN4(VAR77)) {
uint256 VAR80 = VAR77.FUN5(VAR75.FUN3(2));
uint256 VAR81 = (VAR58.FUN4(VAR58.FUN2(VAR80).FUN3(VAR76))).FUN2(VAR78.FUN4(VAR79));
return VAR81.FUN3(VAR58);
} else {
return 0;
}
}
function FUN46(uint256 VAR75, uint256 VAR76, uint256 VAR77, uint256 VAR78, uint256 VAR79) public pure returns (uint256) {
if (VAR75 > 0 && VAR75 <= VAR76.FUN4(VAR77)) {
uint256 VAR80 = VAR77.FUN5(VAR75.FUN3(2));
uint256 VAR82 = (VAR59.FUN4(VAR59.FUN2(VAR80).FUN3(VAR76))).FUN2(VAR78.FUN4(VAR79)).FUN3(VAR59);
return VAR82;
} else {
return 0;
}
}
function FUN47(uint256 VAR75, uint256 VAR76, uint256 VAR77, uint256 VAR78, uint256 VAR79) public pure returns (uint256) {
uint256 VAR82 = FUN46(VAR75, VAR76, VAR77, VAR78, VAR79);
uint256 VAR83 = VAR82.FUN2(VAR75).FUN3(VAR59);
return VAR83;
}
function FUN48(uint256 VAR84, uint256 VAR69, uint256 VAR85) public pure returns (uint256) {
return (VAR85.FUN2(VAR84).FUN4(VAR84.FUN2(VAR69))).FUN3(VAR85);
}
function FUN49(uint256 VAR84, uint256 VAR69, uint256 VAR86) public pure returns (uint256) {
return VAR84.FUN2(VAR69).FUN3(VAR84.FUN4(VAR86));
}
function FUN50(uint256 VAR84, uint256 VAR69, uint256 VAR87) public pure returns (uint256) {
return VAR84.FUN2(VAR69).FUN3(VAR84.FUN5(VAR87));
}
function FUN51(uint256 VAR88) public pure returns (uint8) {
uint8 VAR89 = 0;
while(VAR88 != 0) {
VAR88 = VAR88.FUN3(10);
VAR89++;
}
return VAR89;
}
}
contract VAR90 {
address public VAR91;
address public VAR92;
mapping (address => bool) public VAR93;
constructor() public {
VAR91 = msg.sender;
}
modifier FUN52() {
require (VAR93[msg.sender] == true);
VAR52;
}
function FUN53(address VAR63) public {
require (msg.sender == VAR91);
require (VAR63 != address(0));
VAR91 = VAR63;
}
function FUN54(address VAR94, bool VAR95) public {
require (msg.sender == VAR91);
require (VAR94 != address(0));
VAR93[VAR94] = VAR95;
}
}
contract TAOCurrency is VAR90 {
using SafeMath for uint256;
string public VAR19;
string public VAR20;
uint8 public VAR21;
uint256 public VAR96;
uint256 public VAR22;
mapping (address => uint256) public VAR23;
event Transfer(address indexed VAR25, address indexed VAR26, uint256 value);
event FUN16(address indexed VAR25, uint256 value);
constructor (string memory VAR44, string memory VAR97, address VAR64) public {
VAR19 = VAR44;
VAR20 = VAR97;
VAR96 = 0;
VAR21 = 0;
FUN55(VAR64);
}
modifier VAR98 {
require (VAR57.FUN38(msg.sender, VAR91, VAR92));
VAR52;
}
modifier FUN56(address VAR13) {
require (VAR57.FUN33(VAR13) || VAR57.FUN28(VAR13));
VAR52;
}
function FUN53(address VAR63) public VAR98 {
require (VAR63 != address(0));
VAR91 = VAR63;
}
function FUN54(address VAR94, bool VAR95) public VAR98 {
require (VAR94 != address(0));
VAR93[VAR94] = VAR95;
}
function FUN55(address VAR64) public VAR98 {
require (VAR64 != address(0));
VAR92 = VAR64;
}
function FUN18(address VAR3, address VAR32, uint256 VAR4) public VAR99 FUN56(VAR3) FUN56(VAR32) returns (bool) {
FUN17(VAR3, VAR32, VAR4);
return true;
}
function FUN57(address VAR100, uint256 VAR101) public VAR99 FUN56(VAR100) returns (bool) {
FUN58(VAR100, VAR101);
return true;
}
function FUN59(address VAR3, uint256 VAR4) public VAR99 FUN56(VAR3) returns (bool VAR34) {
require(VAR23[VAR3] >= VAR4);
VAR23[VAR3] = VAR23[VAR3].FUN4(VAR4);
VAR22 = VAR22.FUN4(VAR4);
emit FUN16(VAR3, VAR4);
return true;
}
function FUN17(address VAR3, address VAR32, uint256 VAR4) internal {
require (VAR32 != address(0));
require (VAR23[VAR3] >= VAR4);
require (VAR23[VAR32].FUN5(VAR4) >= VAR23[VAR32]);
uint256 VAR33 = VAR23[VAR3].FUN5(VAR23[VAR32]);
VAR23[VAR3] = VAR23[VAR3].FUN4(VAR4);
VAR23[VAR32] = VAR23[VAR32].FUN5(VAR4);
emit Transfer(VAR3, VAR32, VAR4);
assert(VAR23[VAR3].FUN5(VAR23[VAR32]) == VAR33);
}
function FUN58(address VAR100, uint256 VAR101) internal {
VAR23[VAR100] = VAR23[VAR100].FUN5(VAR101);
VAR22 = VAR22.FUN5(VAR101);
emit Transfer(address(0), address(this), VAR101);
emit Transfer(address(this), VAR100, VAR101);
}
}
contract PathosExa is VAR102 {
constructor(string memory VAR44, string memory VAR97, address VAR64)
FUN60(VAR44, VAR97, VAR64) public {
VAR96 = 18;
VAR21 = 18;
}
}
0
---------------------------------
409 0x02b0da0967a963cfdb859581811d383f10d64771.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1(address VAR2)
public;
}
contract Ownable VAR3
VAR1
{
address public VAR4;
constructor ()
public
{
VAR4 = msg.sender;
}
modifier onlyOwner() {
require(
msg.sender == VAR4,
""
);
VAR5;
}
function FUN1(address VAR2)
public
onlyOwner
{
if (VAR2 != address(0)) {
VAR4 = VAR2;
}
}
}
contract IAuthorizable VAR3
VAR1
{
function FUN2(address VAR6)
external;
function FUN3(address VAR6)
external;
function FUN4(
address VAR6,
uint256 VAR7
)
external;
function FUN5()
external
view
returns (address[] VAR8);
}
contract MAuthorizable VAR3
VAR9
{
event FUN6(
address indexed VAR6,
address indexed VAR10
);
event FUN7(
address indexed VAR6,
address indexed VAR10
);
modifier VAR11 { revert(); VAR5; }
}
contract MixinAuthorizable VAR3
VAR12,
VAR13
{
modifier VAR11 {
require(
VAR14[msg.sender],
""
);
VAR5;
}
mapping (address => bool) public VAR14;
address[] public VAR15;
function FUN2(address VAR6)
external
onlyOwner
{
require(
!VAR14[VAR6],
""
);
VAR14[VAR6] = true;
VAR15.FUN8(VAR6);
emit FUN6(VAR6, msg.sender);
}
function FUN3(address VAR6)
external
onlyOwner
{
require(
VAR14[VAR6],
""
);
delete VAR14[VAR6];
for (uint256 VAR16 = 0; VAR16 < VAR15.VAR17; VAR16++) {
if (VAR15[VAR16] == VAR6) {
VAR15[VAR16] = VAR15[VAR15.VAR17 - 1];
VAR15.VAR17 -= 1;
break;
}
}
emit FUN7(VAR6, msg.sender);
}
function FUN4(
address VAR6,
uint256 VAR7
)
external
onlyOwner
{
require(
VAR14[VAR6],
""
);
require(
VAR7 < VAR15.VAR17,
""
);
require(
VAR15[VAR7] == VAR6,
""
);
delete VAR14[VAR6];
VAR15[VAR7] = VAR15[VAR15.VAR17 - 1];
VAR15.VAR17 -= 1;
emit FUN7(VAR6, msg.sender);
}
function FUN5()
external
view
returns (address[] VAR8)
{
return VAR15;
}
}
contract IAssetProxy VAR3
VAR9
{
function FUN9(
bytes VAR18,
address VAR19,
address VAR20,
uint256 VAR21
)
external;
function FUN10()
external
pure
returns (bytes4);
}
contract VAR22 {
function FUN11(address VAR23)
external;
function FUN12(bytes4 VAR24)
external
view
returns (address);
}
contract MAssetProxyDispatcher VAR3
VAR22
{
event FUN13(
bytes4 VAR25,
address VAR23
);
function FUN14(
bytes memory VAR18,
address VAR19,
address VAR20,
uint256 VAR21
)
internal;
}
contract MixinAssetProxyDispatcher VAR3
VAR12,
VAR26
{
mapping (bytes4 => VAR27) public VAR28;
function FUN11(address VAR23)
external
onlyOwner
{
IAssetProxy VAR29 = FUN15(VAR23);
bytes4 VAR24 = VAR29.FUN10();
address VAR30 = VAR28[VAR24];
require(
VAR30 == address(0),
""
);
VAR28[VAR24] = VAR29;
emit FUN13(
VAR24,
VAR23
);
}
function FUN12(bytes4 VAR24)
external
view
returns (address)
{
return VAR28[VAR24];
}
function FUN14(
bytes memory VAR18,
address VAR19,
address VAR20,
uint256 VAR21
)
internal
{
if (VAR21 > 0 && VAR19 != VAR20) {
require(
VAR18.VAR17 > 3,
""
);
bytes4 VAR24;
VAR31 {
VAR24 := FUN16(FUN17(
FUN18(VAR18, 32)),
0xFFFFFFFF00000000000000000000000000000000000000000000000000000000
)
}
address VAR23 = VAR28[VAR24];
require(
VAR23 != address(0),
""
);
|
VAR31 {
let VAR32 := FUN17(64)
let VAR33 := FUN16(FUN18(FUN17(VAR18), 63), 0xFFFFFFFFFFFE0)
let VAR34 := FUN18(VAR32, FUN18(132, VAR33))
FUN19(VAR32, 0xa85e59e400000000000000000000000000000000000000000000000000000000)
FUN19(FUN18(VAR32, 4), 128)
FUN19(FUN18(VAR32, 36), FUN16(VAR19, 0xffffffffffffffffffffffffffffffffffffffff))
FUN19(FUN18(VAR32, 68), FUN16(VAR20, 0xffffffffffffffffffffffffffffffffffffffff))
FUN19(FUN18(VAR32, 100), VAR21)
let VAR35 := FUN18(VAR32, 132)
for {} FUN20(VAR35, VAR34) {} {
FUN19(VAR35, FUN17(VAR18))
VAR35 := FUN18(VAR35, 32)
VAR18 := FUN18(VAR18, 32)
}
let VAR36 := call(
VAR37,
VAR23,
0,
VAR32,
FUN21(VAR34, VAR32),
VAR32,
512
)
if FUN22(VAR36) {
revert(VAR32, FUN23())
}
}
}
}
}
contract MultiAssetProxy VAR3
VAR38,
VAR39
{
bytes4 constant internal VAR40 = bytes4(FUN24(""));
function ()
external
{
VAR31 {
let VAR41 := FUN16(FUN25(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)
if FUN26(VAR41, 0xa85e59e400000000000000000000000000000000000000000000000000000000) {
FUN19(0, VAR10)
FUN19(32, VAR42)
if FUN22(FUN27(FUN24(0, 64))) {
FUN19(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)
FUN19(32, 0x0000002000000000000000000000000000000000000000000000000000000000)
FUN19(64, 0x0000001553454e4445525f4e4f545f415554484f52495a454400000000000000)
FUN19(96, 0)
revert(0, 100)
}
//
|
//
: offset is computed from start of function VAR43, so VAR44
//
: see table below to compute length of assetData VAR45
//
let VAR46 := FUN25(4)
//
|
|
let VAR47 := FUN25(FUN18(VAR46, 40))
let VAR48 := FUN25(FUN18(VAR46, 72))
let VAR49 := FUN18(VAR46, FUN18(VAR47, 72))
let VAR50 := FUN25(FUN21(VAR49, 32))
let VAR51 := FUN18(VAR46, FUN18(VAR48, 72))
let VAR52 := FUN25(FUN21(VAR51, 32))
if FUN22(FUN26(VAR50, VAR52)) {
FUN19(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)
FUN19(32, 0x0000002000000000000000000000000000000000000000000000000000000000)
FUN19(64, 0x0000000f4c454e4754485f4d49534d4154434800000000000000000000000000)
FUN19(96, 0)
revert(0, 100)
}
FUN28(
0,
0,
100
)
FUN19(4, 128)
let VAR21 := FUN25(100)
let VAR53 := FUN29(VAR50, 32)
let VAR24 := 0
let VAR23 := 0
for {let VAR16 := 0} FUN20(VAR16, VAR53) {VAR16 := FUN18(VAR16, 32)} {
let VAR54 := FUN25(FUN18(VAR49, VAR16))
let VAR55 := FUN29(VAR54, VAR21)
if FUN22(FUN26(FUN30(VAR55, VAR21), VAR54)) {
FUN19(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)
FUN19(32, 0x0000002000000000000000000000000000000000000000000000000000000000)
FUN19(64, 0x0000001055494e543235365f4f564552464c4f57000000000000000000000000)
FUN19(96, 0)
revert(0, 100)
}
FUN19(100, VAR55)
let VAR56 := FUN25(FUN18(VAR51, VAR16))
let VAR57 := FUN18(VAR46, FUN18(VAR48, FUN18(VAR56, 104)))
let VAR58 := FUN21(VAR57, 32)
let VAR59 := FUN25(VAR58)
if FUN20(VAR59, 4) {
FUN19(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)
FUN19(32, 0x0000002000000000000000000000000000000000000000000000000000000000)
FUN19(64, 0x0000001e4c454e4754485f475245415445525f5448414e5f335f524551554952)
FUN19(96, 0x4544000000000000000000000000000000000000000000000000000000000000)
revert(0, 100)
}
let VAR60 := FUN16(
FUN25(VAR57),
0xffffffff00000000000000000000000000000000000000000000000000000000
)
if FUN22(FUN26(VAR60, VAR24)) {
VAR24 := VAR60
FUN19(132, VAR24)
FUN19(164, VAR61)
VAR23 := FUN27(FUN24(132, 64))
}
if FUN22(VAR23) {
FUN19(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)
FUN19(32, 0x0000002000000000000000000000000000000000000000000000000000000000)
FUN19(64, 0x0000001a41535345545f50524f58595f444f45535f4e4f545f45584953540000)
FUN19(96, 0)
revert(0, 100)
}
FUN28(
132,
VAR58,
FUN18(VAR59, 32)
)
let VAR36 := call(
VAR37,
VAR23,
0,
0,
FUN18(164, VAR59),
0,
0
)
if FUN22(VAR36) {
FUN31(
0,
0,
FUN23()
)
revert(0, FUN23())
}
}
return(0, 0)
}
revert(0, 0)
}
}
function FUN10()
external
pure
returns (bytes4)
{
return VAR40;
}
}
0
---------------------------------
410 0x02b2101903eb6a51518e63e84b785180859fda9d.sol
contract VAR1 {
struct VAR2 {
address VAR3;
uint VAR4;
}
VAR2[] public VAR5;
uint public VAR6 = 0;
uint public VAR7;
uint public VAR8 = 0;
address public VAR9;
modifier VAR10 { if (msg.sender == VAR9) VAR11 }
function FUN1() {
VAR9 = msg.sender;
}
function() {
FUN2();
}
function FUN2() {
if (msg.value < 5 VAR12) {
msg.sender.FUN3(msg.value);
return;
}
uint VAR4;
if (msg.value > 500 VAR12) {
msg.sender.FUN3(msg.value - 500 VAR12);
VAR4 = 500 VAR12;
}
else {
VAR4 = msg.value;
}
uint VAR13 = VAR5.VAR14;
VAR5.VAR14 += 1;
VAR5[VAR13].VAR3 = msg.sender;
VAR5[VAR13].VAR4 = VAR4;
if (VAR13 != 0) {
VAR7 += VAR4 / 100 * 3;
VAR9.FUN3(VAR7);
VAR7 = 0;
VAR8 += VAR4 - VAR4 / 100 * 3;
}
else {
VAR8 += VAR4;
}
while (VAR8 > VAR5[VAR6].VAR4 / 100 * 200) {
uint VAR15 = VAR5[VAR6].VAR4 / 100 * 200;
VAR5[VAR6].VAR3.FUN3(VAR15);
VAR8 -= VAR15;
VAR6 += 1;
}
}
function FUN4(address VAR16) VAR10 {
VAR9 = VAR16;
}
}
0
---------------------------------
411 0x02b97cca6d6a5227e464b2a60ee1a580ea4f7da9.sol
pragma VAR1 ^0.4.0;
contract VAR2 {
address public VAR3;
function FUN1(uint VAR4, string VAR5, string VAR6) payable returns (bytes32 VAR7);
function FUN2(uint VAR4, string VAR5, string VAR6, uint VAR8) payable returns (bytes32 VAR7);
function FUN3(uint VAR4, string VAR5, string VAR9, string VAR10) payable returns (bytes32 VAR7);
function FUN4(uint VAR4, string VAR5, string VAR9, string VAR10, uint VAR8) payable returns (bytes32 VAR7);
function FUN5(uint VAR4, string VAR5, bytes VAR11) payable returns (bytes32 VAR7);
function FUN6(uint VAR4, string VAR5, bytes VAR11, uint VAR8) payable returns (bytes32 VAR7);
function FUN7(string VAR5) returns (uint VAR12);
function FUN7(string VAR5, uint VAR13) returns (uint VAR12);
function FUN8(string VAR14);
function FUN9(byte VAR15);
function FUN10(bytes32 VAR16);
function FUN11(uint VAR17);
function FUN12() returns(bytes32);
}
contract VAR18 {
function FUN13() returns (address VAR19);
}
contract VAR20 {
uint constant VAR21 = 60*60*24;
uint constant VAR22 = 60*60*24*7;
uint constant VAR23 = 60*60*24*30;
byte constant VAR24 = 0x00;
byte constant VAR25 = 0x10;
byte constant VAR26 = 0x20;
byte constant VAR27 = 0x30;
byte constant VAR28 = 0xF0;
byte constant VAR29 = 0x01;
uint8 constant VAR30 = 0;
uint8 constant VAR31 = 1;
uint8 constant VAR32 = 2;
uint8 constant VAR33 = 2;
uint8 constant VAR34 = 161;
OraclizeAddrResolverI VAR35;
OraclizeI VAR36;
modifier VAR37 {
if((address(VAR35)==0)||(FUN14(address(VAR35))==0)) FUN15(VAR30);
VAR36 = FUN16(VAR35.FUN13());
VAR38;
}
modifier FUN17(string VAR39){
VAR36 = FUN16(VAR35.FUN13());
VAR36.FUN8(VAR39);
VAR38;
}
function FUN15(uint8 VAR40) internal returns(bool){
if (FUN14(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR35 = FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN19("");
return true;
}
if (FUN14(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR35 = FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN19("");
return true;
}
if (FUN14(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR35 = FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN19("");
return true;
}
if (FUN14(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR35 = FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN19("");
return true;
}
if (FUN14(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR35 = FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN14(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR35 = FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN14(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR35 = FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN20(bytes32 VAR41, string VAR42) {
FUN20(VAR41, VAR42, VAR43 bytes(0));
}
function FUN20(bytes32 VAR41, string VAR42, bytes VAR44) {
}
function FUN21(string VAR39) oraclizeAPI internal {
VAR36.FUN8(VAR39);
}
function FUN22(string VAR45) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45);
}
function FUN22(string VAR45, uint VAR13) oraclizeAPI internal returns (uint){
return VAR36.FUN7(VAR45, VAR13);
}
function FUN23(string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(0, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR52.value(VAR48)(VAR53, VAR45, VAR46);
}
function FUN23(uint VAR53, string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(VAR53, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR46, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR54.value(VAR48)(0, VAR45, VAR46, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(0, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
return VAR36.VAR57.value(VAR48)(VAR53, VAR45, VAR55, VAR56);
}
function FUN23(uint VAR53, string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(VAR53, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string VAR55, string VAR56, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
return VAR36.VAR58.value(VAR48)(0, VAR45, VAR55, VAR56, VAR13);
}
function FUN23(string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN24(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, string[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
string[] memory VAR63 = new string[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(0, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45);
if (VAR48 > 1 VAR49 + VAR50.VAR51*200000) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR61.value(VAR48)(VAR53, VAR45, VAR60);
}
function FUN23(uint VAR53, string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(VAR53, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[] VAR59, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47){
uint VAR48 = VAR36.FUN7(VAR45, VAR13);
if (VAR48 > 1 VAR49 + VAR50.VAR51*VAR13) return 0;
bytes memory VAR60 = FUN25(VAR59);
return VAR36.VAR62.value(VAR48)(0, VAR45, VAR60, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[1] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](1);
VAR63[0] = VAR60[0];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[2] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](2);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[3] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](3);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[4] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](4);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63);
}
function FUN23(uint VAR53, string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR53, VAR45, VAR63, VAR13);
}
function FUN23(string VAR45, bytes[5] VAR60, uint VAR13) oraclizeAPI internal returns (bytes32 VAR47) {
bytes[] memory VAR63 = new bytes[](5);
VAR63[0] = VAR60[0];
VAR63[1] = VAR60[1];
VAR63[2] = VAR60[2];
VAR63[3] = VAR60[3];
VAR63[4] = VAR60[4];
return FUN23(VAR45, VAR63, VAR13);
}
function FUN26() oraclizeAPI internal returns (address){
return VAR36.FUN27();
}
function FUN28(byte VAR64) oraclizeAPI internal {
return VAR36.FUN9(VAR64);
}
function FUN29(uint VAR65) oraclizeAPI internal {
return VAR36.FUN11(VAR65);
}
function FUN30(bytes32 VAR66) oraclizeAPI internal {
return VAR36.FUN10(VAR66);
}
function FUN31() oraclizeAPI internal returns (bytes32){
return VAR36.FUN12();
}
function FUN14(address VAR19) constant internal returns(uint VAR67) {
VAR68 {
VAR67 := FUN32(VAR19)
}
}
function FUN33(string VAR69) internal returns (address){
bytes memory VAR70 = bytes(VAR69);
uint160 VAR71 = 0;
uint160 VAR72;
uint160 VAR73;
for (uint VAR74=2; VAR74<2+2*20; VAR74+=2){
VAR71 *= 256;
VAR72 = FUN34(VAR70[VAR74]);
VAR73 = FUN34(VAR70[VAR74+1]);
if ((VAR72 >= 97)&&(VAR72 <= 102)) VAR72 -= 87;
else if ((VAR72 >= 65)&&(VAR72 <= 70)) VAR72 -= 55;
else if ((VAR72 >= 48)&&(VAR72 <= 57)) VAR72 -= 48;
if ((VAR73 >= 97)&&(VAR73 <= 102)) VAR73 -= 87;
else if ((VAR73 >= 65)&&(VAR73 <= 70)) VAR73 -= 55;
else if ((VAR73 >= 48)&&(VAR73 <= 57)) VAR73 -= 48;
VAR71 += (VAR72*16+VAR73);
}
return address(VAR71);
}
function FUN35(string VAR69, string VAR75) internal returns (int) {
bytes memory VAR76 = bytes(VAR69);
bytes memory VAR77 = bytes(VAR75);
uint VAR78 = VAR76.VAR79;
if (VAR77.VAR79 < VAR78) VAR78 = VAR77.VAR79;
for (uint VAR74 = 0; VAR74 < VAR78; VAR74 ++)
if (VAR76[VAR74] < VAR77[VAR74])
return -1;
else if (VAR76[VAR74] > VAR77[VAR74])
return 1;
if (VAR76.VAR79 < VAR77.VAR79)
return -1;
else if (VAR76.VAR79 > VAR77.VAR79)
return 1;
else
return 0;
}
function FUN36(string VAR80, string VAR81) internal returns (int) {
bytes memory VAR82 = bytes(VAR80);
bytes memory VAR83 = bytes(VAR81);
if(VAR82.VAR79 < 1 || VAR83.VAR79 < 1 || (VAR83.VAR79 > VAR82.VAR79))
return -1;
else if(VAR82.VAR79 > (2**128 -1))
return -1;
else
{
uint VAR84 = 0;
for (uint VAR74 = 0; VAR74 < VAR82.VAR79; VAR74 ++)
{
if (VAR82[VAR74] == VAR83[0])
{
VAR84 = 1;
while(VAR84 < VAR83.VAR79 && (VAR74 + VAR84) < VAR82.VAR79 && VAR82[VAR74 + VAR84] == VAR83[VAR84])
{
VAR84++;
}
if(VAR84 == VAR83.VAR79)
return int(VAR74);
}
}
return -1;
}
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86, string VAR87) internal returns (string) {
bytes memory VAR88 = bytes(VAR69);
bytes memory VAR89 = bytes(VAR75);
bytes memory VAR90 = bytes(VAR85);
bytes memory VAR91 = bytes(VAR86);
bytes memory VAR92 = bytes(VAR87);
string memory VAR93 = VAR43 string(VAR88.VAR79 + VAR89.VAR79 + VAR90.VAR79 + VAR91.VAR79 + VAR92.VAR79);
bytes memory VAR94 = bytes(VAR93);
uint VAR95 = 0;
for (uint VAR74 = 0; VAR74 < VAR88.VAR79; VAR74++) VAR94[VAR95++] = VAR88[VAR74];
for (VAR74 = 0; VAR74 < VAR89.VAR79; VAR74++) VAR94[VAR95++] = VAR89[VAR74];
for (VAR74 = 0; VAR74 < VAR90.VAR79; VAR74++) VAR94[VAR95++] = VAR90[VAR74];
for (VAR74 = 0; VAR74 < VAR91.VAR79; VAR74++) VAR94[VAR95++] = VAR91[VAR74];
for (VAR74 = 0; VAR74 < VAR92.VAR79; VAR74++) VAR94[VAR95++] = VAR92[VAR74];
return string(VAR94);
}
function FUN37(string VAR69, string VAR75, string VAR85, string VAR86) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, VAR86, "");
}
function FUN37(string VAR69, string VAR75, string VAR85) internal returns (string) {
return FUN37(VAR69, VAR75, VAR85, "", "");
}
function FUN37(string VAR69, string VAR75) internal returns (string) {
return FUN37(VAR69, VAR75, "", "", "");
}
function FUN38(string VAR69) internal returns (uint) {
return FUN38(VAR69, 0);
}
function FUN38(string VAR69, uint VAR75) internal returns (uint) {
bytes memory VAR96 = bytes(VAR69);
uint VAR97 = 0;
bool VAR98 = false;
for (uint VAR74=0; VAR74<VAR96.VAR79; VAR74++){
if ((VAR96[VAR74] >= 48)&&(VAR96[VAR74] <= 57)){
if (VAR98){
if (VAR75 == 0) break;
else VAR75--;
}
VAR97 *= 10;
VAR97 += uint(VAR96[VAR74]) - 48;
} else if (VAR96[VAR74] == 46) VAR98 = true;
}
if (VAR75 > 0) VAR97 *= 10**VAR75;
return VAR97;
}
function FUN39(uint VAR74) internal returns (string){
if (VAR74 == 0) return "";
uint VAR99 = VAR74;
uint VAR100;
while (VAR99 != 0){
VAR100++;
VAR99 /= 10;
}
bytes memory VAR101 = VAR43 bytes(VAR100);
uint VAR95 = VAR100 - 1;
while (VAR74 != 0){
VAR101[VAR95--] = FUN40(48 + VAR74 % 10);
VAR74 /= 10;
}
return string(VAR101);
}
function FUN24(string[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
function FUN25(bytes[] VAR102) internal returns (bytes) {
uint VAR103 = VAR102.VAR79;
uint VAR104 = 0;
bytes[] memory VAR105 = new bytes[](VAR103);
for (uint VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR105[VAR74] = (bytes(VAR102[VAR74]));
VAR104 += VAR105[VAR74].VAR79 + (VAR105[VAR74].VAR79 - 1)/23 + 3;
}
uint VAR106 = 0;
uint VAR107 = VAR103 + 0x80;
VAR104 += FUN40(VAR107).VAR79;
bytes memory VAR108 = VAR43 bytes(VAR104);
while (FUN40(VAR107).VAR79 > VAR106) {
VAR108[VAR106] = FUN40(VAR107)[VAR106];
VAR106++;
}
for (VAR74 = 0; VAR74 < VAR103; VAR74++) {
VAR108[VAR106] = 0x5F;
VAR106++;
for (uint VAR109 = 0; VAR109 < VAR105[VAR74].VAR79; VAR109++) {
if (VAR109 % 23 == 0) {
uint VAR110 = VAR105[VAR74].VAR79 - VAR109 >= 24 ? 23 : VAR105[VAR74].VAR79 - VAR109;
VAR110 += 0x40;
uint VAR111 = VAR106;
while (FUN40(VAR110).VAR79 > VAR106 - VAR111) {
VAR108[VAR106] = FUN40(VAR110)[VAR106 - VAR111];
VAR106++;
}
}
VAR108[VAR106] = VAR105[VAR74][VAR109];
VAR106++;
}
VAR108[VAR106] = 0xFF;
VAR106++;
}
return VAR108;
}
string VAR112;
function FUN19(string VAR113) internal {
VAR112 = VAR113;
}
function FUN41() internal returns (string) {
return VAR112;
}
function FUN42(uint VAR114, uint VAR115, uint VAR116) internal returns (bytes32){
if ((VAR115 == 0)||(VAR115 > 32)) throw;
bytes memory VAR117 = VAR43 bytes(1);
VAR117[0] = FUN40(VAR115);
bytes memory VAR118 = VAR43 bytes(32);
bytes memory VAR119 = VAR43 bytes(32);
bytes32 VAR120 = FUN31();
VAR68 {
FUN43(VAR118, 0x20)
FUN43(FUN44(VAR118, 0x20), FUN45(FUN46(FUN47(VAR121, 1)), FUN45(VAR122, VAR53)))
FUN43(VAR119, 0x20)
FUN43(FUN44(VAR119, 0x20), VAR120)
}
bytes[3] memory VAR60 = [VAR118, VAR117, VAR119];
bytes32 VAR123 = FUN23(VAR114, "", VAR60, VAR116);
FUN48(VAR123, FUN49(FUN50(VAR114), VAR60[1], FUN51(VAR60[0]), VAR60[2]));
return VAR123;
}
function FUN48(bytes32 VAR123, bytes32 VAR124) internal {
VAR125[VAR123] = VAR124;
}
mapping(bytes32=>bytes32) VAR125;
mapping(bytes32=>bool) VAR126;
function FUN52(bytes32 VAR127, bytes VAR128, bytes VAR129) internal returns (bool){
bool VAR130;
address VAR131;
bytes32 VAR132;
bytes32 VAR133;
bytes memory VAR134 = VAR43 bytes(32);
uint VAR135 = 4+(uint(VAR128[3]) - 0x20);
VAR134 = FUN53(VAR128, VAR135, 32, VAR134, 0);
bytes memory VAR136 = VAR43 bytes(32);
VAR135 += 32 + 2;
VAR136 = FUN53(VAR128, VAR135+(uint(VAR128[VAR135-1]) - 0x20), 32, VAR136, 0);
VAR68 {
VAR132 := FUN54(FUN44(VAR134, 32))
VAR133 := FUN54(FUN44(VAR136, 32))
}
(VAR130, VAR131) = FUN55(VAR127, 27, VAR132, VAR133);
if (address(FUN49(VAR129)) == VAR131) return true;
else {
(VAR130, VAR131) = FUN55(VAR127, 28, VAR132, VAR133);
return (address(FUN49(VAR129)) == VAR131);
}
}
function FUN56(bytes VAR44, uint VAR137) internal returns (bool) {
bool VAR130;
bytes memory VAR138 = VAR43 bytes(uint(VAR44[VAR137+1])+2);
FUN53(VAR44, VAR137, VAR138.VAR79, VAR138, 0);
bytes memory VAR139 = VAR43 bytes(64);
FUN53(VAR44, 3+1, 64, VAR139, 0);
bytes memory VAR140 = VAR43 bytes(1+65+32);
VAR140[0] = 1;
FUN53(VAR44, VAR137-65, 65, VAR140, 1);
bytes memory VAR141 = VAR142"";
FUN53(VAR141, 0, 32, VAR140, 1+65);
VAR130 = FUN52(FUN51(VAR140), VAR138, VAR139);
if (VAR130 == false) return false;
bytes memory VAR143 = VAR142"";
bytes memory VAR144 = VAR43 bytes(1+65);
VAR144[0] = 0xFE;
FUN53(VAR44, 3, 65, VAR144, 1);
bytes memory VAR145 = VAR43 bytes(uint(VAR44[3+65+1])+2);
FUN53(VAR44, 3+65, VAR145.VAR79, VAR145, 0);
VAR130 = FUN52(FUN51(VAR144), VAR145, VAR143);
return VAR130;
}
modifier FUN57(bytes32 VAR146, string VAR147, bytes VAR148) {
if ((VAR148[0] != "")||(VAR148[1] != "")||(VAR148[2] != 1)) throw;
bool VAR149 = FUN58(VAR148, VAR146, bytes(VAR147), FUN41());
if (VAR149 == false) throw;
VAR38;
}
function FUN59(bytes32 VAR150, bytes VAR151) internal returns (bool){
bool VAR152 = true;
for (var VAR74=0; VAR74<VAR151.VAR79; VAR74++){
if (VAR150[VAR74] != VAR151[VAR74]) VAR152 = false;
}
return VAR152;
}
function FUN58(bytes VAR44, bytes32 VAR123, bytes VAR42, string VAR153) internal returns (bool){
bool VAR154;
uint VAR155 = 3+65+(uint(VAR44[3+65+1])+2)+32;
bytes memory VAR156 = VAR43 bytes(32);
FUN53(VAR44, VAR155, 32, VAR156, 0);
VAR154 = (FUN49(VAR156) == FUN49(FUN51(VAR153, VAR123)));
if (VAR154 == false) return false;
bytes memory VAR157 = VAR43 bytes(uint(VAR44[VAR155+(32+8+1+32)+1])+2);
FUN53(VAR44, VAR155+(32+8+1+32), VAR157.VAR79, VAR157, 0);
VAR154 = FUN59(FUN51(VAR157), VAR42);
if (VAR154 == false) return false;
bytes memory VAR158 = VAR43 bytes(8+1+32);
FUN53(VAR44, VAR155+32, 8+1+32, VAR158, 0);
bytes memory VAR159 = VAR43 bytes(64);
uint VAR137 = VAR155+32+(8+1+32)+VAR157.VAR79+65;
FUN53(VAR44, VAR137-64, 64, VAR159, 0);
bytes32 VAR160 = FUN51(VAR159);
if (VAR125[VAR123] == FUN49(VAR158, VAR160)){
delete VAR125[VAR123];
} else return false;
bytes memory VAR161 = VAR43 bytes(32+8+1+32);
FUN53(VAR44, VAR155, 32+8+1+32, VAR161, 0);
VAR154 = FUN52(FUN51(VAR161), VAR157, VAR159);
if (VAR154 == false) return false;
if (VAR126[VAR160] == false){
VAR126[VAR160] = FUN56(VAR44, VAR137);
}
return VAR126[VAR160];
}
function FUN53(bytes VAR162, uint VAR163, uint VAR79, bytes VAR164, uint VAR165) internal returns (bytes) {
uint VAR78 = VAR79 + VAR165;
if (VAR164.VAR79 < VAR78) {
throw;
}
uint VAR74 = 32 + VAR163;
uint VAR99 = 32 + VAR165;
while (VAR74 < (32 + VAR163 + VAR79)) {
VAR68 {
let VAR70 := FUN54(FUN44(VAR162, VAR74))
FUN43(FUN44(VAR164, VAR99), VAR70)
}
VAR74 += 32;
VAR99 += 32;
}
return VAR164;
}
function FUN55(bytes32 VAR166, uint8 VAR167, bytes32 VAR168, bytes32 VAR169) internal returns (bool, address) {
bool VAR170;
address VAR171;
VAR68 {
let VAR172 := FUN54(0x40)
FUN43(VAR172, VAR166)
FUN43(FUN44(VAR172, 32), VAR167)
FUN43(FUN44(VAR172, 64), VAR168)
FUN43(FUN44(VAR172, 96), VAR169)
VAR170 := call(3000, 1, 0, VAR172, 128, VAR172, 32)
VAR171 := FUN54(VAR172)
}
return (VAR170, VAR171);
}
function FUN60(bytes32 VAR166, bytes VAR173) internal returns (bool, address) {
bytes32 VAR168;
bytes32 VAR169;
uint8 VAR167;
if (VAR173.VAR79 != 65)
return (false, 0);
VAR68 {
VAR168 := FUN54(FUN44(VAR173, 32))
VAR169 := FUN54(FUN44(VAR173, 64))
VAR167 := FUN40(0, FUN54(FUN44(VAR173, 96)))
}
//
if (VAR167 < 27)
VAR167 += 27;
if (VAR167 != 27 && VAR167 != 28)
return (false, 0);
return FUN55(VAR166, VAR167, VAR168, VAR169);
}
}
pragma solidity 0.4.16;
contract VAR174 {
address public VAR175;
event FUN61(address VAR176);
function FUN62() { VAR175 = msg.sender; }
modifier onlyOwner {
require(msg.sender == VAR175);
VAR38;
}
function FUN63(address VAR176) external onlyOwner  {
VAR175 = VAR176;
FUN61(VAR176);
}
}
contract Cillionaire is VAR174, VAR20 {
enum VAR177 { VAR178, VAR179 }
uint public constant VAR180 = 10;
uint public constant VAR181 = 0.01 VAR49;
address public VAR182;
address[] public VAR183;
State public VAR184;
uint public VAR185;
uint public VAR186;
uint public VAR187;
uint public VAR188;
uint public VAR189;
uint public VAR190;
uint public VAR191;
uint public VAR192;
uint public VAR193;
uint public VAR194;
uint public VAR195;
uint public VAR196;
event FUN64(address VAR197, uint VAR198, uint VAR199, uint VAR200, uint VAR201, uint VAR202, uint VAR203);
event FUN65(address VAR204, uint VAR205, uint VAR203);
event FUN66(address VAR197, uint VAR206);
event FUN67(uint VAR207);
modifier FUN68(State VAR208) {
require(VAR184 == VAR208);
VAR38;
}
modifier FUN69() {
require(msg.sender == FUN26());
VAR38;
}
function FUN70() {
FUN28(VAR27);
VAR184 = VAR177.VAR178;
VAR196 = 400000;
VAR192 = 1000;
VAR193 = 600;
VAR194 = 0.01 VAR49;
VAR195 = 0.001 VAR49;
FUN71(VAR175);
}
function FUN71(address VAR197) internal FUN68(VAR177.VAR178) {
delete VAR183;
VAR191 = 0;
VAR182 = VAR197;
VAR187 = VAR192;
VAR188 = VAR193;
VAR189 = VAR194;
VAR190 = VAR195;
VAR185 = VAR209.VAR53;
VAR186 = VAR185 + VAR188;
VAR184 = VAR177.VAR179;
FUN64(VAR182, VAR185, VAR186, VAR187, VAR188, VAR189, VAR190);
}
function FUN72() external payable FUN68(VAR177.VAR179) {
require(msg.value == VAR189);
uint VAR210 = msg.value - VAR190;
VAR191 += VAR210;
VAR183.FUN73(msg.sender);
FUN65(msg.sender, VAR210, VAR190);
if ((VAR209.VAR53 >= VAR186) || (VAR183.VAR79 >= VAR187)) {
VAR184 = VAR177.VAR178;
FUN66(VAR182, VAR191);
bytes32 VAR123 = FUN42(0, 7, VAR196);
}
VAR182.transfer(VAR210);
}
function FUN20(bytes32 VAR146, string VAR147, bytes VAR148) VAR211 FUN68(VAR177.VAR178) FUN57(VAR146, VAR147, VAR148) {
uint VAR212 = uint(FUN49(VAR147));
FUN67(VAR212);
address VAR213 = VAR183[VAR212 % VAR183.VAR79];
FUN71(VAR213);
}
function FUN74() external payable onlyOwner FUN68(VAR177.VAR178) {
bytes32 VAR123 = FUN42(0, 7, VAR196);
}
function FUN75() external payable onlyOwner {
}
function FUN76() external onlyOwner {
require(this.VAR214 > VAR181);
uint VAR215 = this.VAR214 - VAR181;
VAR175.transfer(VAR215);
}
function FUN77(uint VAR216) external onlyOwner {
VAR192 = VAR216;
}
function FUN78(uint VAR217) external onlyOwner {
VAR193 = VAR217;
}
function FUN79(uint VAR218) external onlyOwner {
VAR194 = VAR218;
if (VAR195 > VAR194 / VAR180) {
VAR195 = VAR194 / VAR180;
}
}
function FUN80(uint VAR219) external onlyOwner {
require(VAR219 <= VAR194 / VAR180);
VAR195 = VAR219;
}
function FUN81(uint VAR220) external onlyOwner {
require(VAR220 > 200000);
VAR196 = VAR220;
}
function FUN82(uint VAR221) external onlyOwner {
FUN29(VAR221);
}
}
0
---------------------------------
412 0x02c16d7ac580bc10e004fc74527d6b2e52f5151a.sol
pragma VAR1 ^0.5.3;
contract VAR2 {
address private VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
constructor () internal {
VAR3 = msg.sender;
emit FUN1(address(0), VAR3);
}
function FUN2() public view returns (address) {
return VAR3;
}
modifier onlyOwner() {
require(FUN3());
VAR6;
}
function FUN3() public view returns (bool) {
return msg.sender == VAR3;
}
function FUN4(address VAR5) public onlyOwner {
FUN5(VAR5);
}
function FUN5(address VAR5) internal {
require(VAR5 != address(0));
emit FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract Approvable is VAR2 {
mapping(address => bool) private VAR7;
modifier FUN6() {
require(FUN7());
VAR6;
}
function FUN7() public view returns(bool) {
return VAR7[msg.sender] || FUN3();
}
function FUN8(address VAR8) public onlyOwner {
VAR7[VAR8] = true;
}
function FUN9(address VAR8) public onlyOwner {
VAR7[VAR8] = false;
}
}
contract VAR9 {
uint public VAR10;
uint public VAR11;
constructor() internal {
VAR10 = VAR12.VAR13;
VAR11 = VAR12.VAR14;
}
}
contract NodeRegistry is VAR9, VAR15 {
mapping(address => string) public VAR16;
mapping(address => string) public VAR17;
mapping(address => uint) public VAR18;
struct VAR19 {
address[] VAR20;
mapping(address => uint) VAR21;
}
mapping(address => VAR19) VAR22;
NodeList VAR23;
modifier FUN10() {
require(
VAR23.VAR21[msg.sender] > 0,
""
);
VAR6;
}
function FUN11(address[] memory VAR24) public {
NodeList storage VAR25 = VAR22[msg.sender];
require(
VAR18[msg.sender] >=
VAR25.VAR20.VAR26 + VAR24.VAR26,
""
);
for(uint VAR27 = 0; VAR27 < VAR24.VAR26; VAR27++) {
if(VAR25.VAR21[VAR24[VAR27]] == 0) {
FUN12(VAR24[VAR27]);
}
}
}
function FUN13(address[] memory VAR24) public {
for(uint VAR27 = 0; VAR27 < VAR24.VAR26; VAR27++) {
FUN14(VAR24[VAR27]);
}
}
function FUN14(address VAR28) private {
NodeList storage VAR25 = VAR22[msg.sender];
if(VAR25.VAR21[VAR28] == 0) {
revert("");
}
FUN15(VAR25, VAR28);
FUN15(VAR23, VAR28);
delete VAR16[VAR28];
delete VAR17[VAR28];
}
function FUN15(NodeList storage VAR25, address VAR29) private {
uint VAR30 = VAR25.VAR21[VAR29] - 1;
uint VAR31 = VAR25.VAR20.VAR26 - 1;
address VAR32 = VAR25.VAR20[VAR31];
VAR25.VAR20[VAR30] = VAR32;
VAR25.VAR21[VAR32] = VAR30 + 1;
VAR25.VAR21[VAR29] = 0;
VAR25.VAR20.FUN16();
}
function FUN12(address VAR28) private {
NodeList storage VAR25 = VAR22[msg.sender];
if(VAR23.VAR21[VAR28] != 0) {
revert("");
}
VAR25.VAR20.FUN17(VAR28);
VAR25.VAR21[VAR28] = VAR25.VAR20.VAR26;
VAR23.VAR20.FUN17(VAR28);
VAR23.VAR21[VAR28] = VAR23.VAR20.VAR26;
}
function FUN18() public view returns(address[] VAR33) {
return VAR23.VAR20;
}
function FUN19(address VAR34) public view returns(address[] VAR33) {
return VAR22[VAR34].VAR20;
}
function FUN20(address[] memory VAR35, uint[] memory VAR36) public VAR37 {
require(VAR35.VAR26 == VAR36.VAR26, "");
for(uint VAR27 = 0; VAR27 < VAR35.VAR26; ++VAR27) {
FUN21(VAR35[VAR27], VAR36[VAR27]);
}
}
function FUN21(address VAR34, uint VAR38) private {
VAR18[VAR34] = VAR38;
FUN22(VAR34, VAR38);
}
function FUN22(address VAR34, uint VAR38) private view {
if (VAR38 >= VAR18[VAR34]) {
return;
}
}
function FUN23(string memory VAR39) public VAR40 {
VAR16[msg.sender] = VAR39;
}
function FUN24(string memory VAR41) public VAR40 {
VAR17[msg.sender] = VAR41;
}
function FUN25(string memory VAR39, string memory VAR41) public VAR40 {
VAR16[msg.sender] = VAR39;
VAR17[msg.sender] = VAR41;
}
function FUN26(address VAR42) public view returns(string VAR33, string VAR33) {
return (VAR16[VAR42], VAR17[VAR42]);
}
}
0
---------------------------------
413 0x02c1ffd832143973fcec0cf3cac020ecb43dfb1a.sol
pragma VAR1 ^0.5.4;
contract VAR2 {
using SafeMath for uint;
uint8 private constant VAR3 = 4;
uint8 private constant VAR4 = 11;
uint private constant VAR5 = 86400;
struct VAR6 {
address VAR7;
uint VAR8;
uint8[5] VAR9;
uint VAR10;
uint8 VAR11;
}
struct VAR12 {
uint VAR13;
uint8[5] VAR14;
uint VAR15;
uint VAR16;
uint VAR17;
uint VAR18;
uint VAR19;
uint VAR20;
uint8 VAR21;
mapping(uint => VAR6) VAR22;
}
mapping(uint => VAR12) public VAR23;
uint private VAR24 = 0;
uint private constant VAR25 = 0.01 VAR26;
uint private constant VAR27 = 36;
uint private constant VAR28 = 15;
uint private constant VAR29 = 35;
uint private constant VAR30 = 30;
uint private constant VAR31 = 20;
uint public VAR32 = 0;
uint public VAR33 = 0;
uint private constant VAR34 = 25 VAR35;
uint private VAR36 = 0;
uint private constant VAR37 = 15;
uint private VAR38 = 0;
address private constant VAR39 = 0x203bF6B46508eD917c085F50F194F36b0a62EB02;
address payable private constant VAR40 = 0x531d3Bd0400Ae601f26B335EfbD787415Aa5CB81;
address payable private constant VAR41 = 0xCD66911b6f38FaAF5BFeE427b3Ceb7D18Dd09F78;
event FUN1(uint VAR42, uint VAR43, address VAR44, uint8 VAR45, uint8 VAR46, uint8 VAR47, uint8 VAR48, uint8 VAR49);
event FUN2(uint VAR42);
event FUN3(uint VAR50);
event FUN4(uint VAR51);
event FUN5(uint VAR42, uint8 VAR45, uint8 VAR46, uint8 VAR47, uint8 VAR48, uint8 VAR49);
event FUN6(uint VAR42, uint VAR43, uint VAR52, uint8 VAR53);
uint private constant VAR54 = 30;
uint private VAR55 = 0;
uint private VAR56 = 0;
uint private VAR57 = 0;
uint private VAR58 = 0;
uint private VAR59 = 0;
function() external payable {
if(msg.sender == VAR40) {
FUN7();
} else {
if(msg.sender == VAR39) {
FUN8();
} else {
FUN9();
}
}
}
function FUN7() private {
if(msg.value > 0) {
VAR32 += msg.value;
VAR36 += msg.value;
emit FUN4(VAR32);
} else {
if(VAR36 > 0){
FUN10();
}
}
}
function FUN10() private {
if(VAR32 > VAR36 * 2 || (VAR60 - VAR24) > VAR34) {
if(VAR32 > VAR36) {
VAR40.transfer(VAR36);
VAR32 = VAR32 - VAR36;
VAR36 = 0;
} else {
VAR40.transfer(VAR32);
VAR36 = 0;
VAR32 = 0;
}
emit FUN4(VAR32);
}
}
function FUN8() private {
if(VAR33 == 0) {
VAR33 = 1;
VAR23[VAR33].VAR13 = VAR60;
VAR23[VAR33].VAR21 = 1;
VAR24 = VAR60;
} else {
if(VAR23[VAR33].VAR21 == 1) {
FUN11();
} else {
VAR23[VAR33].VAR21 = 1;
}
}
}
function FUN11() private {
uint8[5] memory VAR14;
uint8 VAR61 = 0;
if(VAR55 == 0) {
VAR56 = 0;
VAR57 = 0;
VAR58 = 0;
VAR59 = 0;
for(uint8 VAR62 = 0; VAR62 < 5; VAR62++) {
VAR14[VAR62] = FUN12(VAR62);
}
VAR14 = FUN13(VAR14);
for(uint8 VAR62 = 0; VAR62 < 4; VAR62++) {
for(uint8 VAR63 = VAR62 + 1; VAR63 < 5; VAR63++) {
if(VAR14[VAR62] == VAR14[VAR63]) {
VAR14[VAR63]++;
}
}
}
VAR23[VAR33].VAR14 = VAR14;
emit FUN5(VAR33, VAR14[0], VAR14[1], VAR14[2], VAR14[3], VAR14[4]);
} else {
VAR14 = VAR23[VAR33].VAR14;
}
uint VAR64 	= VAR54 * VAR55 + 1;
uint VAR65 	= VAR54 * VAR55 + VAR54;
if(VAR65 > VAR23[VAR33].VAR15) VAR65 = VAR23[VAR33].VAR15;
uint VAR66 = 0;
uint VAR67 = 0;
uint VAR68 = 0;
uint VAR69 = 0;
for(uint VAR62 = VAR64; VAR62 <= VAR65; VAR62++) {
VAR61 = FUN14(VAR14, VAR23[VAR33].VAR22[VAR62].VAR9);
if(VAR61 == 2) { VAR66++; continue; }
if(VAR61 == 3) { VAR67++; continue; }
if(VAR61 == 4) { VAR68++; continue; }
if(VAR61 == 5) { VAR69++; }
}
if(VAR66 != 0) { VAR56 += VAR66; }
if(VAR67 != 0) { VAR57 += VAR67; }
if(VAR68 != 0) { VAR58 += VAR68; }
if(VAR69 != 0) { VAR56 += VAR69; }
if(VAR65 == VAR23[VAR33].VAR15) {
uint VAR16 = VAR23[VAR33].VAR16;
uint VAR70 = VAR16 * VAR31 / 100;
uint VAR71 = VAR16 * VAR30 / 100;
uint VAR72 = VAR16 * VAR29 / 100;
uint VAR51 = VAR32 + VAR16 * VAR28 / 100;
if(VAR56 != 0) {
VAR23[VAR33].VAR17 = VAR70 / VAR56;
} else {
VAR51 += VAR70;
}
if(VAR57 != 0) {
VAR23[VAR33].VAR18 = VAR71 / VAR57;
} else {
VAR51 += VAR71;
}
if(VAR58 != 0) {
VAR23[VAR33].VAR19 = VAR72 / VAR58;
} else {
VAR51 += VAR72;
}
if(VAR59 != 0) {
VAR23[VAR33].VAR20 = VAR51 / VAR59;
VAR32 = 0;
VAR36 = 0;
} else {
VAR32 = VAR51;
}
emit FUN4(VAR32);
VAR33++;
VAR23[VAR33].VAR13 = VAR60;
emit FUN2(VAR33);
VAR55 = 0;
VAR41.transfer(VAR38);
VAR38 = 0;
} else {
VAR55++;
}
}
function FUN14(uint8[5] memory VAR73, uint8[5] memory VAR74) private pure returns (uint8) {
uint8 VAR75 = 0;
for(uint8 VAR62 = 0; VAR62 < 5; VAR62++) {
for(uint8 VAR63 = 0; VAR63 < 5; VAR63++) {
if(VAR73[VAR62] == VAR74[VAR63]) {
VAR75++;
break;
}
}
}
return VAR75;
}
function FUN9() private {
if(msg.value == 0) {
if(VAR23[VAR33].VAR21 != 1 || VAR55 > 0) return;
uint VAR76 = 0;
for(uint VAR62 = 1; VAR62 <= VAR33; VAR62++) {
Game memory VAR77 = VAR23[VAR62];
if(VAR77.VAR14[0] == 0) { continue; }
for(uint VAR63 = 1; VAR63 <= VAR77.VAR15; VAR63++) {
Member memory VAR78 = VAR23[VAR62].VAR22[VAR63];
if(VAR78.VAR11 == 1) { continue; }
uint8 VAR61 = FUN14(VAR77.VAR14, VAR78.VAR9);
if(VAR61 == 2) {
VAR23[VAR62].VAR22[VAR63].VAR10 = VAR77.VAR17;
VAR76 += VAR77.VAR17;
}
if(VAR61 == 3) {
VAR23[VAR62].VAR22[VAR63].VAR10 = VAR77.VAR18;
VAR76 += VAR77.VAR18;
}
if(VAR61 == 4) {
VAR23[VAR62].VAR22[VAR63].VAR10 = VAR77.VAR19;
VAR76 += VAR77.VAR19;
}
if(VAR61 == 5) {
VAR23[VAR62].VAR22[VAR63].VAR10 = VAR77.VAR20;
VAR76 += VAR77.VAR20;
}
VAR23[VAR62].VAR22[VAR63].VAR11 = 1;
emit FUN6(VAR62, VAR63, VAR23[VAR62].VAR22[VAR63].VAR10, 1);
}
}
if(VAR76 != 0) msg.sender.transfer(VAR76);
return;
}
uint8 VAR79 = FUN15(VAR60);
uint8 VAR80 = FUN16(VAR60);
if( VAR33 > 0 && VAR23[VAR33].VAR21 == 1 && VAR55 == 0 &&
(VAR79 != VAR3 || (VAR79 == VAR3 && (VAR80 < (VAR4 - 1) || VAR80 > (VAR4 + 2)))) ) {
if(msg.value == VAR25) {
FUN17();
} else {
if(msg.value < VAR25) {
VAR38 = VAR38 + msg.value.FUN18(VAR37).FUN19(100);
VAR23[VAR33].VAR16 = VAR23[VAR33].VAR16 + msg.value.FUN18(100 - VAR37).FUN19(100);
emit FUN3(VAR23[VAR33].VAR16);
} else {
msg.sender.transfer(msg.value.FUN20(VAR25));
FUN17();
}
}
} else {
msg.sender.transfer(msg.value);
}
}
function FUN17() private {
bool VAR81 = false;
uint8[5] memory VAR9;
VAR38 = VAR38 + VAR25.FUN18(VAR37).FUN19(100);
VAR23[VAR33].VAR16 = VAR23[VAR33].VAR16 + VAR25.FUN18(100 - VAR37).FUN19(100);
emit FUN3(VAR23[VAR33].VAR16);
(VAR81, VAR9) = FUN21();
uint VAR82;
if(VAR81) {
for(uint8 VAR62 = 0; VAR62 < 5; VAR62++) {
VAR9[VAR62] = FUN12(VAR62);
}
for(uint8 VAR62 = 0; VAR62 < 4; VAR62++) {
for(uint8 VAR63 = VAR62 + 1; VAR63 < 5; VAR63++) {
if(VAR9[VAR62] == VAR9[VAR63]) {
VAR9[VAR63]++;
}
}
}
}
VAR9 = FUN13(VAR9);
VAR23[VAR33].VAR15++;
VAR82 = VAR23[VAR33].VAR15;
VAR23[VAR33].VAR22[VAR82].VAR7 = msg.sender;
VAR23[VAR33].VAR22[VAR82].VAR8 = VAR82;
VAR23[VAR33].VAR22[VAR82].VAR9 = VAR9;
emit FUN1(VAR33, VAR82, msg.sender, VAR9[0], VAR9[1], VAR9[2], VAR9[3], VAR9[4]);
}
function FUN21() private view returns (bool, uint8[5] VAR83) {
bool VAR81 = false;
uint8[5] memory VAR9;
if(msg.VAR84.VAR85 == 5) {
for(uint8 VAR62 = 0; VAR62 < msg.VAR84.VAR85; VAR62++) {
VAR9[VAR62] = uint8(msg.VAR84[VAR62]);
}
for(uint8 VAR62 = 0; VAR62 < VAR9.VAR85; VAR62++) {
if(VAR9[VAR62] < 1 || VAR9[VAR62] > VAR27) {
VAR81 = true;
break;
}
}
if(!VAR81) {
for(uint8 VAR62 = 0; VAR62 < VAR9.VAR85 - 1; VAR62++) {
for(uint8 VAR63 = VAR62 + 1; VAR63 < VAR9.VAR85; VAR63++) {
if(VAR9[VAR62] == VAR9[VAR63]) {
VAR81 = true;
break;
}
}
if(VAR81) {
break;
}
}
}
} else {
VAR81 = true;
}
return (VAR81, VAR9);
}
function FUN13(uint8[5] memory VAR86) private pure returns (uint8[5] VAR83) {
uint8 VAR87;
for(uint8 VAR62 = 0; VAR62 < VAR86.VAR85 - 1; VAR62++) {
for(uint VAR63 = 0; VAR63 < VAR86.VAR85 - VAR62 - 1; VAR63++)
if (VAR86[VAR63] > VAR86[VAR63 + 1]) {
VAR87 = VAR86[VAR63];
VAR86[VAR63] = VAR86[VAR63 + 1];
VAR86[VAR63 + 1] = VAR87;
}
}
return VAR86;
}
function FUN22() public view returns(uint) {
uint VAR88 = address(this).VAR88;
return VAR88;
}
function FUN12(uint8 VAR89) internal view returns (uint8) {
return uint8((uint(FUN23(VAR90.VAR91 - 1 - VAR89*2)) + VAR60) % VAR27 + 1);
}
function FUN16(uint VAR92) private pure returns (uint8) {
return uint8((VAR92 / 60 / 60) % 24);
}
function FUN15(uint VAR92) private pure returns (uint8) {
return uint8((VAR92 / VAR5 + 4) % 7);
}
function FUN24(uint VAR62) public view returns (uint, uint, uint8, uint8, uint8, uint8, uint8, uint8, uint, uint, uint, uint) {
Game memory VAR77 = VAR23[VAR62];
return (VAR77.VAR16, VAR77.VAR15, VAR77.VAR14[0], VAR77.VAR14[1], VAR77.VAR14[2], VAR77.VAR14[3], VAR77.VAR14[4], VAR77.VAR21, VAR77.VAR17, VAR77.VAR18, VAR77.VAR19, VAR77.VAR20);
}
function FUN25(uint VAR62, uint VAR63) public view returns (address, uint, uint8, uint8, uint8, uint8, uint8, uint, uint8) {
Member memory VAR93 = VAR23[VAR62].VAR22[VAR63];
return (VAR93.VAR7, VAR93.VAR8, VAR93.VAR9[0], VAR93.VAR9[1], VAR93.VAR9[2], VAR93.VAR9[3], VAR93.VAR9[4], VAR93.VAR10, VAR93.VAR11);
}
}
library VAR94 {
function FUN18(uint256 VAR95, uint256 VAR96) internal pure returns(uint256) {
uint256 VAR97 = VAR95 * VAR96;
assert(VAR95 == 0 || VAR97 / VAR95 == VAR96);
return VAR97;
}
function FUN19(uint256 VAR95, uint256 VAR96) internal pure returns(uint256) {
uint256 VAR97 = VAR95 / VAR96;
return VAR97;
}
function FUN20(uint256 VAR95, uint256 VAR96) internal pure returns(uint256) {
assert(VAR96 <= VAR95);
return VAR95 - VAR96;
}
function FUN26(uint256 VAR95, uint256 VAR96) internal pure returns(uint256) {
uint256 VAR97 = VAR95 + VAR96;
assert(VAR97 >= VAR95);
return VAR97;
}
}
0
---------------------------------
414 0x02c6a6c802456e3c0b9b55e7071892084caf42f8.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29980800;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xE6271c287C5a276378162dfCBa1db7fd40E5486a;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
415 0x02c83f4e1eaca0679659be3856f0623cdcae912b.sol
pragma VAR1 ^0.5.7;
contract VAR2 {
address internal VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
constructor () internal {
VAR3 = msg.sender;
emit FUN1(address(0), VAR3);
}
function FUN2() public view returns (address) {
return VAR3;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR6;
}
function FUN3(address VAR5) external onlyOwner {
require(VAR5 != address(0));
VAR3 = VAR5;
emit FUN1(VAR3, VAR5);
}
function FUN4(address VAR7, address VAR8, uint256 VAR9) external onlyOwner {
IERC20 VAR10 = FUN5(VAR7);
require(VAR8 != address(0));
uint256 VAR11 = VAR10.FUN6(address(this));
require(VAR11 >= VAR9);
assert(VAR10.transfer(VAR8, VAR9));
}
function FUN7(address payable VAR12, uint256 VAR9) external onlyOwner {
require(VAR12 != address(0));
uint256 VAR11 = address(this).VAR11;
require(VAR11 >= VAR9);
VAR12.transfer(VAR9);
}
}
interface VAR13{
function FUN6(address VAR14) external view returns (uint256);
function transfer(address VAR12, uint256 value) external returns (bool);
}
contract WesionDevelopersFund is VAR2{
IERC20 public VAR15;
event FUN8(address indexed VAR16, uint256 VAR9);
constructor() public {
VAR15 = FUN5(0x2c1564A74F07757765642ACef62a583B38d5A213);
}
function () external payable {
emit FUN8(msg.sender, msg.value);
}
function FUN9(address VAR12, uint256 VAR9) external onlyOwner {
assert(VAR15.transfer(VAR12, VAR9));
}
function FUN10(address[] memory VAR17, uint256[] memory VAR18) public onlyOwner {
require(VAR17.VAR19 == VAR18.VAR19);
for (uint256 VAR20 = 0; VAR20 < VAR17.VAR19; VAR20++) {
assert(VAR15.transfer(VAR17[VAR20], VAR18[VAR20]));
}
}
function FUN11(address VAR21) public onlyOwner {
VAR15 = FUN5(VAR21);
}
}
0
---------------------------------
416 0x02cc75f4f0e29cdc76a94ec38fb5281f83c9d93f.sol
pragma VAR1 ^0.5.3;
contract VAR2 {
uint256 public VAR3 = 86400;
uint256 public VAR4 = 1 VAR5;
uint256 public VAR6 = 100 VAR5;
address public VAR7;
address public VAR8;
address public VAR9;
uint256 public VAR10 = 0;
uint256 public VAR11 = 1;
uint256 public VAR12 = 1;
uint256 public VAR13 = VAR14;
uint256 public VAR15 = VAR14;
uint256 public VAR16 = VAR14;
uint256 public VAR17 = VAR14;
address payable public VAR18 = 0xa4048772583220896ec93316616778B4EbC70F9d;
address[] public VAR19;
bytes32[] public VAR20;
bytes32[] public VAR21;
bytes32[] public VAR22;
mapping (address => VAR23) VAR24;
mapping (bytes32 => VAR25) public VAR26;
mapping (bytes32 => VAR27) public VAR28;
mapping (bytes32 => VAR29) public VAR30;
mapping (address => VAR31) public VAR32;
uint256 VAR33 = 0;
uint256 public VAR34 = 200;
uint256 public VAR35 = 2;
bool public VAR36 = true;
Vote public VAR37;
struct VAR31 {
address VAR38;
address VAR39;
address VAR40;
}
struct VAR41 {
uint256 VAR42;
string VAR43;
mapping (address => uint8) VAR44;
address payable VAR45;
uint256 VAR46;
uint256 VAR47;
uint256 VAR48;
}
struct VAR25 {
bytes32 VAR49;
uint256 VAR50;
uint256 VAR51;
address VAR52;
address VAR53;
bool VAR54;
}
struct VAR27 {
bytes32 VAR49;
uint256 VAR50;
uint256 VAR51;
address VAR52;
address VAR55;
uint256 VAR43;
uint256 VAR56;
}
struct VAR23 {
address VAR57;
address VAR58;
address VAR59;
address VAR60;
uint256 VAR61;
uint256 VAR62;
uint256 VAR63;
bool VAR64;
uint256 VAR65;
uint256 VAR66;
uint256 VAR67;
uint256 VAR68;
uint256 VAR69;
uint256 VAR70;
uint256 VAR71;
uint256 VAR72;
uint256 VAR73;
uint256 VAR74;
uint256 VAR75;
bytes32[] VAR26;
bytes32[] VAR28;
}
struct VAR29 {
bytes32 VAR49;
address VAR52;
uint256 VAR56;
uint256 VAR50;
}
constructor () public { VAR7 = msg.sender; }
modifier FUN1() {
require(msg.sender == VAR7 || msg.sender == VAR9 || msg.sender == VAR8);
VAR76;
}
modifier FUN2() { require(VAR36); require(msg.sender == VAR9 || msg.sender == VAR7); VAR76; }
function () payable external { FUN3(); }
function FUN4() internal view returns(uint256) {
return VAR33 + VAR14;
}
function FUN5(address sender) internal {
Investor storage VAR52 = VAR24[sender];
require(VAR52.VAR61 != 0);
if (VAR52.VAR62 == 0) require(msg.value >= VAR52.VAR75);
require(VAR52.VAR67 < VAR35);
require(VAR52.VAR66 < 50);
require(VAR52.VAR66 == 0 || FUN4() - VAR52.VAR65 < VAR3 * 7 || VAR52.VAR62 != 0);
VAR10 += msg.value;
bytes32 VAR49 = FUN6(VAR77.FUN7(VAR78.VAR79, FUN4(), sender, msg.value));
uint256 VAR80 = VAR52.VAR62 + msg.value <= VAR6 ? msg.value : VAR6 - VAR52.VAR62;
if (VAR80 == 0) return;
bool VAR54 = VAR24[VAR52.VAR57].VAR58 == sender;
Investment memory VAR81 = FUN8({ VAR49: VAR49, VAR50: FUN4(), VAR51: VAR80, VAR52: sender, VAR53: VAR52.VAR57, VAR54: VAR54  });
VAR26[VAR49] = VAR81;
FUN9(VAR49);
VAR20.FUN10(VAR49);
}
function FUN11(address VAR82, uint256 VAR56, uint256 VAR62) internal {
bytes32 VAR49 = FUN6(VAR77.FUN7(VAR78.VAR79, FUN4(), VAR82, VAR56));
MaxOut memory VAR83 = FUN12({ VAR49: VAR49, VAR50: FUN4(), VAR52: VAR82, VAR56: VAR56 });
VAR22.FUN10(VAR49);
VAR30[VAR49] = VAR83;
VAR24[VAR82].VAR75 = VAR62;
}
function FUN3() payable public { FUN5(msg.sender); }
function FUN9(bytes32 VAR84) internal {
Investment storage VAR81 = VAR26[VAR84];
uint256 VAR51 = VAR81.VAR51;
Investor storage VAR52 = VAR24[VAR81.VAR52];
VAR52.VAR26.FUN10(VAR84);
VAR52.VAR62 += VAR51;
address payable VAR85 = address(FUN13(VAR52.VAR60));
Investor storage VAR60 = VAR24[VAR85];
if (VAR85 != address(0)) {
VAR60.VAR68 += VAR51;
VAR60.VAR69 += VAR51;
}
if (VAR60.VAR62 >= VAR4 && !VAR60.VAR64) {
FUN14(VAR85, VAR51 / 10, 1, VAR81.VAR52, 0);
}
}
function FUN15(address payable VAR38) public view returns (address payable) {
WithdrawAccount memory VAR86 = VAR32[VAR38];
address VAR87 = VAR86.VAR39;
if (VAR87 != address(0)) return address(FUN13(VAR87));
return VAR38;
}
function FUN16(address VAR88) public {
require(VAR24[msg.sender].VAR62 > 0);
WithdrawAccount storage VAR89 = VAR32[msg.sender];
if (VAR89.VAR38 != address(0)) {
VAR89.VAR40 = VAR88;
return;
}
WithdrawAccount memory VAR86 = FUN17({
VAR38: msg.sender,
VAR39: msg.sender,
VAR40: VAR88
});
VAR32[msg.sender] = VAR86;
}
function FUN18(address VAR38, address VAR40) public VAR90 {
WithdrawAccount storage VAR86 = VAR32[VAR38];
require(VAR86.VAR40 == VAR40);
VAR86.VAR40 = address(0);
VAR86.VAR39 = VAR40;
}
function FUN19(bytes32 VAR84) public VAR90 {
Investment storage VAR81 = VAR26[VAR84];
require(VAR81.VAR53 != address(0));
uint256 VAR51 = VAR81.VAR51;
uint256 VAR91 = 0;
while (VAR81.VAR53 != address(0) && VAR91 < VAR34) {
Investor storage VAR52 = VAR24[VAR81.VAR53];
if (VAR81.VAR54) VAR52.VAR71 += VAR51;
else VAR52.VAR70 += VAR51;
VAR81.VAR54 = VAR24[VAR52.VAR57].VAR58 == VAR81.VAR53;
VAR81.VAR53 = VAR52.VAR57;
VAR91++;
}
}
function FUN14(address payable VAR82, uint256 value, uint256 VAR43, address VAR55, uint256 VAR56) internal {
if (value == 0 && VAR43 != 100) return;
if (VAR82 == address(0)) return;
Investor storage VAR52 = VAR24[VAR82];
uint256 VAR92 = FUN20(VAR82);
uint256 VAR93 = VAR52.VAR72 + FUN21(VAR82) + VAR92;
if (VAR43 == 1) VAR93 += value;
if (VAR93 + VAR52.VAR63 >= 3 * VAR52.VAR62) {
FUN22(VAR93, VAR82, VAR92);
return;
}
if (VAR52.VAR72 > 0) FUN23(VAR52.VAR72, VAR82, 4, address(0), 0);
FUN23(value, VAR82, VAR43, VAR55, VAR56);
}
function FUN23(uint256 VAR94, address payable VAR82, uint256 VAR43, address VAR55, uint256 VAR56) internal {
VAR24[VAR82].VAR63 += VAR94;
if (VAR43 == 4) VAR24[VAR82].VAR72 = 0;
if (VAR43 == 3) FUN24(VAR82, VAR56);
if (VAR43 == 2) VAR24[VAR82].VAR73 += VAR94;
FUN25(VAR94, VAR82, VAR43, VAR55, VAR56);
}
function FUN22(uint256 VAR93, address payable VAR82, uint256 VAR92) internal {
Investor storage VAR52 = VAR24[VAR82];
uint256 VAR94 = VAR52.VAR62 * 3 - VAR52.VAR63;
uint256 VAR95 = VAR93 - VAR94;
if (VAR92 > 0) FUN24(VAR82, 0);
VAR52.VAR66++;
VAR52.VAR67++;
uint256 VAR96 = VAR52.VAR62;
VAR52.VAR62 = 0;
VAR52.VAR63 = 0;
VAR52.VAR65 = FUN4();
VAR52.VAR73 = 0;
VAR52.VAR72 = VAR95;
FUN11(VAR82, VAR52.VAR66, VAR96);
FUN25(VAR94, VAR82, 0, address(0), 0);
}
function FUN25(uint256 VAR94, address payable VAR82, uint256 VAR43, address VAR55, uint256 VAR56) internal {
if (VAR94 == 0) return;
address payable VAR87 = FUN15(VAR82);
VAR87.transfer(VAR94 / 100 * 90);
VAR18.transfer(VAR94 / 100 * 10);
bytes32 VAR49 = FUN6(VAR77.FUN7(VAR78.VAR97, FUN4(), VAR82, VAR94, VAR43));
Withdrawal memory VAR98 = FUN26({ VAR49: VAR49, VAR50: FUN4(), VAR51: VAR94, VAR52: VAR82, VAR55: VAR55, VAR56: VAR56, VAR43: VAR43 });
VAR28[VAR49] = VAR98;
VAR24[VAR82].VAR28.FUN10(VAR49);
VAR21.FUN10(VAR49);
}
function FUN27(address VAR82) internal view returns(uint256 VAR99) {
Investor memory VAR52 = VAR24[VAR82];
uint256 VAR100 = FUN21(VAR82);
uint256 VAR63 = VAR52.VAR63;
uint256 VAR92 = FUN20(VAR82);
uint256 VAR101 = VAR100 + VAR63 + VAR92;
return VAR101;
}
function FUN28(address VAR85, address VAR102, address VAR103, bool VAR104) public VAR90 {
Investor storage VAR60 = VAR24[VAR85];
Investor storage VAR57 = VAR24[VAR103];
if (VAR19.VAR105 != 0) {
require(VAR60.VAR61 != 0);
require(VAR57.VAR61 != 0);
if (VAR104) {
require(VAR57.VAR58 == address(0));
} else {
require(VAR57.VAR59 == address(0));
}
}
Investor memory VAR52 = FUN29({
VAR57: VAR103,
VAR58: address(0),
VAR59: address(0),
VAR60: VAR85,
VAR61: VAR57.VAR61 + 1,
VAR62: 0,
VAR63: 0,
VAR64: false,
VAR65: FUN4(),
VAR66: 0,
VAR67: 0,
VAR68: 0,
VAR69: 0,
VAR74: FUN4(),
VAR26: new bytes32[](0),
VAR28: new bytes32[](0),
VAR75: VAR4,
VAR70: 0,
VAR71: 0,
VAR72: 0,
VAR73: 0
});
VAR24[VAR102] = VAR52;
VAR19.FUN10(VAR102);
if (VAR57.VAR61 == 0) return;
if (VAR104) {
VAR57.VAR58 = VAR102;
} else {
VAR57.VAR59 = VAR102;
}
}
function FUN21(address VAR82) internal view returns(uint256 VAR51) {
Investor memory VAR52 = VAR24[VAR82];
uint256 VAR106 = VAR52.VAR26.VAR105;
uint256 VAR107 = 0;
for (uint256 VAR108 = 0; VAR108 < VAR106; VAR108++) {
Investment memory VAR81 = VAR26[VAR52.VAR26[VAR108]];
if (VAR81.VAR50 < VAR52.VAR65) continue;
if (FUN4() - VAR81.VAR50 >= VAR3) {
uint256 VAR109 = (FUN4() - VAR81.VAR50) / VAR3;
uint256 VAR110 = VAR109 * VAR81.VAR51 / 100 * 2 / 3;
VAR107 = VAR110 + VAR107;
}
}
return VAR107 - VAR52.VAR73;
}
function FUN30(address payable VAR82, uint256 VAR56) public VAR90 {
uint256 VAR107 = FUN21(VAR82);
Investor storage VAR52 = VAR24[VAR82];
if (VAR56 > VAR3) {
uint256 VAR106 = VAR52.VAR26.VAR105;
bytes32 VAR111 = VAR52.VAR26[VAR106 - 1];
VAR26[VAR111].VAR50 -= VAR56;
VAR24[VAR82].VAR65 = VAR26[VAR111].VAR50;
return;
}
if (VAR52.VAR64) return;
FUN14(VAR82, VAR107, 2, address(0), VAR56);
}
function FUN31(uint256 VAR112, uint256 VAR113) public VAR90{
for(uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
FUN30(address(FUN13(VAR19[VAR108])), VAR12);
}
}
function FUN20(address VAR82) public view returns(uint256 VAR114) {
Investor memory VAR52 = VAR24[VAR82];
uint256 VAR62 = VAR52.VAR62;
uint256 VAR68 = VAR52.VAR68;
uint256 VAR71 = VAR52.VAR71;
uint256 VAR70 = VAR52.VAR70;
uint256 VAR69 = VAR52.VAR69;
uint256 VAR115 = VAR70 < VAR71 ? VAR70 : VAR71;
uint256 VAR116 = VAR115 * FUN32(VAR62, VAR68, VAR69) / 100;
return VAR116;
}
function FUN33(address payable VAR82, uint256 VAR56) public VAR90 {
Investor storage VAR52 = VAR24[VAR82];
if (VAR52.VAR64) return;
uint256 VAR117 = FUN20(VAR82);
FUN14(VAR82, VAR117, 3, address(0), VAR56);
}
function FUN24(address VAR82, uint256 VAR56) internal {
Investor storage VAR52 = VAR24[VAR82];
if (VAR11 > 3 && VAR56 != 0) {
VAR52.VAR70 = 0;
VAR52.VAR71 = 0;
} else if (VAR52.VAR70 >= VAR52.VAR71) {
VAR52.VAR70 = VAR52.VAR70 - VAR52.VAR71;
VAR52.VAR71 = 0;
} else {
VAR52.VAR71 = VAR52.VAR71 - VAR52.VAR70;
VAR52.VAR70 = 0;
}
if (VAR56 != 0) VAR52.VAR69 = 0;
}
function FUN34(uint256 VAR112, uint256 VAR113) public VAR90 {
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
if (FUN4() <= 30 * VAR3 + VAR16) return;
for(uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
FUN33(address(FUN13(VAR19[VAR108])), VAR11);
}
}
function FUN35() public VAR90 {
VAR15 = FUN4();
VAR12++;
}
function FUN36() public VAR90 {
VAR13 = FUN4();
VAR11++;
}
function FUN37(uint256 VAR112, uint256 VAR113) public VAR90 {
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
require(VAR37.VAR42 != 0);
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
require(VAR37.VAR46 > VAR37.VAR48 / 2);
require(VAR37.VAR45 == address(0));
VAR17 = FUN4();
for (uint256 VAR108 = VAR112; VAR108 < VAR113; VAR108++) {
address VAR82 = VAR19[VAR108];
Investor storage VAR52 = VAR24[VAR82];
uint256 VAR118 = VAR37.VAR44[VAR82] != 0 ? VAR37.VAR44[VAR82] : 2;
if (VAR118 == 2) {
if (VAR52.VAR66 > 0 || (VAR52.VAR63 >= VAR52.VAR62 && VAR52.VAR63 != 0)) {
VAR52.VAR65 = FUN4();
VAR52.VAR62 = 0;
VAR52.VAR63 = 0;
VAR52.VAR73 = 0;
}
VAR52.VAR72 = 0;
VAR52.VAR70 = 0;
VAR52.VAR71 = 0;
VAR52.VAR68 = 0;
VAR52.VAR69 = 0;
} else {
if (VAR52.VAR66 > 0 || (VAR52.VAR63 >= VAR52.VAR62 && VAR52.VAR63 != 0)) {
VAR52.VAR64 = true;
VAR52.VAR72 = 0;
VAR52.VAR65 = FUN4();
VAR52.VAR62 = 0;
VAR52.VAR63 = 0;
VAR52.VAR73 = 0;
}
VAR52.VAR72 = 0;
VAR52.VAR70 = 0;
VAR52.VAR71 = 0;
VAR52.VAR68 = 0;
VAR52.VAR69 = 0;
}
}
}
function FUN38(uint256 VAR119, uint256 VAR112, uint256 VAR113) mustBeAdmin public {
require(VAR37.VAR42 != 0);
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
require(VAR37.VAR47 > VAR37.VAR48 / 2);
require(VAR37.VAR45 == address(0));
require(VAR119 <= 50);
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
for (uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
address payable VAR82 = address(FUN13(VAR19[VAR108]));
Investor storage VAR52 = VAR24[VAR82];
if (VAR52.VAR66 > 0) continue;
if (VAR52.VAR64) continue;
uint256 VAR62 = VAR52.VAR62;
uint256 VAR63 = VAR52.VAR63;
if (VAR63 >= VAR62 / 2) continue;
FUN14(VAR82, VAR62 * VAR119 / 100 - VAR63, 6, address(0), 0);
}
}
function FUN39(address VAR52) public VAR90 { VAR24[VAR52].VAR65 = FUN4(); }
function FUN40(address payable VAR82) public VAR90 {
uint256 VAR120 = FUN20(VAR82);
uint256 VAR121 = FUN21(VAR82);
uint256 VAR63 = VAR24[VAR82].VAR63;
uint256 VAR62 = VAR24[VAR82].VAR62;
uint256 VAR72 = VAR24[VAR82].VAR72;
require(VAR62 > 0  && VAR63 + VAR120 + VAR121 + VAR72 >= 3 * VAR62);
FUN14(VAR82, 0, 100, address(0), 0);
}
function FUN41(uint256 VAR112, uint256 VAR113) public VAR90 {
require(VAR112 >= 0 && VAR113 < VAR19.VAR105);
for (uint256 VAR108 = VAR112; VAR108 < VAR113; VAR108++) {
address VAR82 = VAR19[VAR108];
if (VAR24[VAR82].VAR67 == 0) continue;
VAR24[VAR82].VAR67 = 0;
}
}
function FUN42(address VAR82, uint256 VAR56) public VAR90{ VAR24[VAR82].VAR66 = VAR56; }
function FUN43(address VAR82) public VAR90 {
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR64 = true;
}
function FUN44(address VAR82) public VAR90 {
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR64 = false;
}
function FUN45() payable public { VAR10 += msg.value; }
function FUN46(uint256 VAR68) internal pure returns (uint256 VAR122){
if (VAR68 < 30 VAR5) return 0;
if (VAR68 < 60 VAR5) return 1;
if (VAR68 < 90 VAR5) return 2;
if (VAR68 < 120 VAR5) return 3;
if (VAR68 < 150 VAR5) return 4;
return 5;
}
function FUN47(uint256 VAR69) internal pure returns (uint256 VAR122){
if (VAR69 < 2 VAR5) return 0;
if (VAR69 < 4 VAR5) return 1;
if (VAR69 < 6 VAR5) return 2;
if (VAR69 < 8 VAR5) return 3;
if (VAR69 < 10 VAR5) return 4;
return 5;
}
function FUN48(uint256 VAR62) internal pure returns (uint256 VAR122){
if (VAR62 < 2 VAR5) return 0;
if (VAR62 < 4 VAR5) return 1;
if (VAR62 < 6 VAR5) return 2;
if (VAR62 < 8 VAR5) return 3;
if (VAR62 < 10 VAR5) return 4;
return 5;
}
function FUN32(uint256 VAR62, uint256 VAR68, uint256 VAR69) internal pure returns(uint256 VAR122) {
uint256 VAR123 = FUN46(VAR68);
uint256 VAR124 = FUN48(VAR62);
uint256 VAR125 = FUN47(VAR69);
uint256 VAR126 = VAR123 < VAR124 ? VAR123 : VAR124;
uint256 VAR127 = VAR125 < VAR126 ? VAR125 : VAR126;
return VAR127 * 2;
}
function FUN49(string memory VAR128) internal pure returns (bytes32 VAR129) {
bytes memory VAR130 = bytes(VAR128);
if (VAR130.VAR105 == 0) return 0x0;
VAR131 { VAR129 := FUN50(FUN51(VAR128, 32)) }
}
function FUN52(address VAR82) view public returns (address[] memory VAR132, bool VAR64, uint256[] memory VAR133) {
VAR132 = new address[](4);
VAR133 = new uint256[](16);
Investor memory VAR52 = VAR24[VAR82];
VAR132[0] = VAR52.VAR57;
VAR132[1] = VAR52.VAR58;
VAR132[2] = VAR52.VAR59;
VAR132[3] = VAR52.VAR60;
VAR133[0] = VAR52.VAR61;
VAR133[1] = VAR52.VAR62;
VAR133[2] = VAR52.VAR63;
VAR133[3] = VAR52.VAR65;
VAR133[4] = VAR52.VAR66;
VAR133[5] = VAR52.VAR67;
VAR133[6] = VAR52.VAR68;
VAR133[7] = VAR52.VAR69;
VAR133[8] = VAR52.VAR70;
VAR133[9] = VAR52.VAR71;
VAR133[10] = VAR52.VAR72;
VAR133[11] = VAR52.VAR73;
VAR133[12] = VAR52.VAR74;
VAR133[13] = FUN20(VAR82);
VAR133[14] = FUN21(VAR82);
VAR133[15] = VAR52.VAR75;
return (VAR132, VAR52.VAR64, VAR133);
}
function FUN53() view public returns(uint256) { return VAR19.VAR105; }
function FUN54() view public returns(uint256) { return VAR22.VAR105; }
function FUN55(address VAR134) public view returns(address[] VAR135){
uint256 VAR136 = VAR19.VAR105;
address[] memory VAR137 = new address[](VAR136);
VAR137[0] = VAR134;
uint256 VAR138 = 0;
uint256 VAR139 = 1;
while (VAR138 != VAR139) {
Investor memory VAR140 = VAR24[VAR137[VAR138++]];
if (VAR140.VAR58 != address(0)) VAR137[VAR139++] = VAR140.VAR58;
if (VAR140.VAR59 != address(0)) VAR137[VAR139++] = VAR140.VAR59;
}
return VAR137;
}
function FUN56 () public view returns(uint256 VAR105) { return VAR20.VAR105; }
function FUN57() public view returns(uint256 VAR105) { return VAR21.VAR105; }
function FUN58(address[] memory VAR132, bool VAR64, uint256[] memory VAR133) public VAR141 {
if (VAR24[VAR132[4]].VAR61 != 0) return;
Investor memory VAR52 = FUN29({
VAR64: VAR64,
VAR57: VAR132[0],
VAR58: VAR132[1],
VAR59: VAR132[2],
VAR60: VAR132[3],
VAR61: VAR133[0],
VAR62: VAR133[1],
VAR63: VAR133[2],
VAR65: VAR133[3],
VAR66: VAR133[4],
VAR67: VAR133[5],
VAR68: VAR133[6],
VAR69: VAR133[7],
VAR26: new bytes32[](0),
VAR28: new bytes32[](0),
VAR70: VAR133[8],
VAR71: VAR133[9],
VAR72: VAR133[10],
VAR73: VAR133[11],
VAR74: VAR133[12],
VAR75: VAR4
});
VAR24[VAR132[4]] = VAR52;
VAR19.FUN10(VAR132[4]);
}
function FUN59(bytes32 VAR49, uint256 VAR50, uint256 VAR51, address VAR82) public VAR141 {
if (VAR26[VAR49].VAR50 != 0) return;
Investment memory VAR81 = FUN8({ VAR49: VAR49, VAR50: VAR50, VAR51: VAR51, VAR52: VAR82, VAR53: address(0), VAR54: false });
VAR26[VAR49] = VAR81;
VAR20.FUN10(VAR49);
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR26.FUN10(VAR49);
VAR10 += VAR51;
}
function FUN60(bytes32 VAR49, uint256 VAR50, uint256 VAR51, address VAR82, address VAR55, uint256 VAR43, uint256 VAR56) public VAR141 {
if (VAR28[VAR49].VAR50 != 0) return;
Withdrawal memory VAR98 = FUN26({ VAR49: VAR49, VAR50: VAR50, VAR51: VAR51, VAR52: VAR82, VAR55: VAR55, VAR56: VAR56, VAR43: VAR43 });
VAR28[VAR49] = VAR98;
Investor storage VAR52 = VAR24[VAR82];
VAR52.VAR28.FUN10(VAR49);
VAR21.FUN10(VAR49);
}
function FUN61() public VAR90 { VAR36 = false; }
function FUN62(uint256 VAR112, uint256 VAR113, bool VAR142) public VAR90 {
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
for (uint256 VAR143 = VAR112; VAR143 < VAR113; VAR143++) {
address VAR82 = VAR19[VAR143];
if (VAR142 && VAR37.VAR44[VAR82] == 3) {
VAR37.VAR44[VAR82] = 0;
continue;
}
if (VAR37.VAR44[VAR82] == 0) {
VAR37.VAR46 += 1;
}
VAR37.VAR44[VAR82] = 3;
}
}
function FUN63(string memory VAR43, address payable VAR45) public VAR90 {
require(VAR37.VAR42 == 0);
VAR37 = FUN64({
VAR42: FUN4(),
VAR43: VAR43,
VAR45: VAR45,
VAR46: 0,
VAR47: 0,
VAR48: VAR19.VAR105
});
}
function FUN65() public VAR90 {
VAR37 = FUN64({
VAR42: 0,
VAR43: '',
VAR45: address(0),
VAR46: 0,
VAR47: 0,
VAR48: 0
});
}
function FUN66() public VAR90 {
require(VAR37.VAR42 != 0);
require(FUN4() - VAR37.VAR42 > 3 * VAR3);
require(VAR37.VAR46 > VAR37.VAR48 / 2);
require(VAR37.VAR45 != address(0));
bool VAR144 = false;
(VAR144, ) = VAR37.VAR45.call.value(address(this).VAR145)("");
if (!VAR144) revert();
}
function FUN67(address VAR52, bool VAR146) internal {
require(VAR24[VAR52].VAR62 > 0);
require(!VAR24[VAR52].VAR64);
require(FUN4() - VAR37.VAR42 < 3 * VAR3);
uint8 VAR147 = VAR146 ? 2 : 1;
uint8 VAR118 = VAR37.VAR44[VAR52];
require(VAR147 != VAR118);
FUN68(VAR146);
if (VAR118 == 0) return;
if (VAR146) {
VAR37.VAR47 -= FUN69();
} else {
VAR37.VAR46 -= FUN69();
}
}
function FUN70(bool VAR146) public { FUN67(msg.sender, VAR146); }
function FUN68(bool VAR146) internal {
VAR37.VAR44[msg.sender] = VAR146 ? 2 : 1;
if (VAR146) {
VAR37.VAR46 += FUN69();
} else {
VAR37.VAR47 += FUN69();
}
}
function FUN69() public view returns(uint256) {
if (VAR24[msg.sender].VAR61 >= 3) return 1;
if (VAR37.VAR48 > 40) return VAR37.VAR48 / 20;
return 2;
}
function FUN71(address VAR148) public VAR90 {
VAR9 = VAR148;
}
function FUN72(address VAR149) public VAR90 {
VAR8 = VAR149;
}
function FUN73(uint256 VAR150, uint256 VAR151, uint256 VAR152, uint256 VAR153, uint256 VAR154, uint256 VAR155) public VAR141 {
VAR11 = VAR150;
VAR12 = VAR151;
VAR13 = VAR152;
VAR15 = VAR153;
VAR16 = VAR154;
VAR17 = VAR155;
}
function FUN74(address VAR52) public payable VAR90 {
FUN5(VAR52);
}
}
contract VAR156 {
Operator public VAR157;
address public VAR158;
constructor () public { VAR158 = msg.sender; }
modifier FUN1() {
require(msg.sender == VAR158);
VAR76;
}
function FUN75(address payable VAR159) public VAR90 {
VAR157 = FUN76(VAR159);
}
function FUN77() public view returns (address VAR7, uint256 VAR10, uint256 VAR160, address VAR18, uint256 VAR145, uint256 VAR11, uint256 VAR35) {
VAR10 = VAR157.FUN78();
VAR7 = VAR157.FUN79();
VAR18 = VAR157.FUN80();
VAR145 = address(VAR157).VAR145;
VAR11 = VAR157.FUN81();
VAR35 = VAR157.FUN82();
return (VAR7, VAR10, VAR157.FUN53(), VAR18, VAR145, VAR11, VAR35);
}
function FUN83() public view returns (uint256 VAR16, uint256 VAR17, uint256 VAR161, uint256 VAR15, uint256 VAR13) {
return (VAR157.FUN84(), VAR157.FUN85(), VAR157.FUN86(), VAR157.FUN87(), VAR157.FUN88());
}
function FUN89() public view returns (bytes32[] memory VAR162, address[] memory VAR24, uint256[] memory VAR56, uint256[] memory VAR163) {
uint256 VAR105 = VAR157.FUN54();
VAR162 = new bytes32[] (VAR105);
VAR24 = new address[] (VAR105);
VAR56 = new uint256[] (VAR105);
VAR163 = new uint256[] (VAR105);
for (uint256 VAR108 = 0; VAR108 < VAR105; VAR108++) {
bytes32 VAR49 = VAR157.FUN90(VAR108);
address VAR52;
uint256 VAR164;
uint256 VAR50;
(VAR49, VAR52, VAR164, VAR50) = VAR157.FUN91(VAR49);
VAR162[VAR108] = VAR49;
VAR56[VAR108] = VAR164;
VAR24[VAR108] = VAR52;
VAR163[VAR108] = VAR50;
}
return (VAR162, VAR24, VAR56, VAR163);
}
function FUN92(bytes32 VAR84) public view returns (bytes32 VAR49, uint256 VAR50, uint256 VAR51, address VAR52, address VAR53, bool VAR54) {
return VAR157.FUN93(VAR84);
}
function FUN94(bytes32 VAR165) public view returns (bytes32 VAR49, uint256 VAR50, uint256 VAR51, address VAR52, address VAR55, uint256 VAR43, uint256 VAR56) {
return VAR157.FUN95(VAR165);
}
function FUN96(uint256 VAR112, uint256 VAR113) public view returns (address[] memory VAR24, address[] memory VAR132, bool[] memory VAR166, uint256[] memory VAR133) {
uint256 VAR105 = VAR157.FUN53();
VAR112 = VAR112 < 0 ? 0 : VAR112;
VAR113 = VAR113 > VAR105 - 1 ? VAR105 - 1 : VAR113;
uint256 VAR167 = VAR113 - VAR112 + 1;
VAR132 = new address[](VAR167 * 5);
VAR166 = new bool[](VAR167);
VAR133 = new uint256[](VAR167 * 16);
VAR24 = new address[](VAR167);
for (uint256 VAR108 = 0; VAR108 < VAR167; VAR108++) {
address VAR82 = VAR157.FUN97(VAR108 + VAR112);
address[] memory VAR168;
uint256[] memory VAR169;
bool VAR64;
(VAR168, VAR64, VAR169) = VAR157.FUN52(VAR82);
for (uint256 VAR170 = 0; VAR170 < VAR168.VAR105; VAR170++) {
VAR132[VAR108 * 5 + VAR170] = VAR168[VAR170];
}
VAR132[VAR108 * 5 + 4] = VAR82;
for (uint256 VAR171 = 0; VAR171 < VAR169.VAR105; VAR171++) {
VAR133[VAR108 * 16 + VAR171] = VAR169[VAR171];
}
VAR166[VAR108] = VAR64;
VAR24[VAR108] = VAR82;
}
return (VAR24, VAR132, VAR166, VAR133);
}
function FUN98(uint256 VAR112, uint256 VAR113) public view returns(bytes32[] memory VAR162, uint256[] memory VAR163, uint256[] memory VAR172, address[] memory VAR24, address[] memory VAR173) {
uint256 VAR105 = VAR157.FUN56();
VAR112 = VAR112 < 0 ? 0 : VAR112;
VAR113 = VAR113 > VAR105 - 1 ? VAR105 - 1 : VAR113;
uint256 VAR174 = VAR113 - VAR112 + 1;
VAR162 = new bytes32[](VAR174);
VAR163 = new uint256[](VAR174);
VAR172 = new uint256[](VAR174);
VAR24 = new address[](VAR174);
VAR173 = new address[](VAR174);
for (uint256 VAR108 = 0; VAR108 < VAR174; VAR108++) {
bytes32 VAR49 = VAR157.FUN99(VAR108 + VAR112);
uint256 VAR50;
uint256 VAR51;
address VAR52;
address VAR53;
(VAR49, VAR50, VAR51, VAR52, VAR53,) = FUN92(VAR49);
VAR162[VAR108] = VAR49;
VAR163[VAR108] = VAR50;
VAR172[VAR108] = VAR51;
VAR24[VAR108] = VAR52;
VAR173[VAR108] = VAR53;
}
return (VAR162, VAR163, VAR172, VAR24, VAR173);
}
function FUN100(uint256 VAR112, uint256 VAR113) public view returns(bytes32[] memory VAR162, uint256[] memory VAR163, uint256[] memory VAR172, address[] memory VAR24, address[] memory VAR175, uint256[] memory VAR176, uint256[] memory VAR56) {
uint256 VAR105 = VAR157.FUN57();
VAR112 = VAR112 < 0 ? 0 : VAR112;
VAR113 = VAR113 > VAR105 - 1 ? VAR105 - 1 : VAR113;
uint256 VAR174 = VAR113 - VAR112 + 1;
VAR162 = new bytes32[](VAR174);
VAR163 = new uint256[](VAR174);
VAR172 = new uint256[](VAR174);
VAR24 = new address[](VAR174);
VAR175 = new address[](VAR174);
VAR176 = new uint256[](VAR174);
VAR56 = new uint256[](VAR174);
FUN101(VAR112, VAR174, VAR162, VAR163, VAR172, VAR24);
FUN102(VAR112, VAR174, VAR175, VAR176, VAR56);
return (VAR162, VAR163, VAR172, VAR24, VAR175, VAR176, VAR56);
}
function FUN101(uint256 VAR112, uint256 VAR105, bytes32[] memory VAR162, uint256[] memory VAR163, uint256[] memory VAR172, address[] memory VAR24) internal view {
for (uint256 VAR108 = 0; VAR108 < VAR105; VAR108++) {
bytes32 VAR49 = VAR157.FUN103(VAR108 + VAR112);
uint256 VAR50;
uint256 VAR51;
address VAR52;
(VAR49, VAR50, VAR51, VAR52, , , ) = FUN94(VAR49);
VAR162[VAR108] = VAR49;
VAR163[VAR108] = VAR50;
VAR172[VAR108] = VAR51;
VAR24[VAR108] = VAR52;
}
}
function FUN102(uint256 VAR112, uint256 VAR105, address[] memory VAR175, uint256[] memory VAR176, uint256[] memory VAR56) internal view {
for (uint256 VAR108 = 0; VAR108 < VAR105; VAR108++) {
bytes32 VAR49 = VAR157.FUN103(VAR108 + VAR112);
uint256 VAR43;
uint256 VAR164;
address VAR55;
uint256 VAR50;
(, VAR50, , , VAR55, VAR43, VAR164) = FUN94(VAR49);
VAR176[VAR108] = VAR43;
VAR56[VAR108] = VAR164;
VAR175[VAR108] = VAR55;
}
}
function FUN104() public view returns(uint256 VAR42, string memory VAR43, address payable VAR45, uint256 VAR46, uint256 VAR47, uint256 VAR48) {
(VAR42, VAR43, VAR45, VAR46, VAR47, VAR48) = VAR157.FUN105();
return (VAR42, VAR43, VAR45, VAR46, VAR47, VAR48);
}
function FUN106(address[] memory VAR132, bool[] memory VAR166, uint256[] memory VAR133) public VAR90 {
for (uint256 VAR143 = 0; VAR143 < VAR166.VAR105; VAR143++) {
address[] memory VAR177 = FUN107(VAR132, VAR143 * 5, VAR143 * 5 + 4);
uint256[] memory VAR178 = FUN108(VAR133, VAR143 * 13, VAR143 * 13 + 12);
VAR157.FUN58(VAR177, VAR166[VAR143], VAR178);
}
}
function FUN109(bytes32[] memory VAR162, uint256[] memory VAR163, uint256[] memory VAR172, address[] memory VAR19) public VAR90 {
for (uint256 VAR143 = 0; VAR143 < VAR162.VAR105; VAR143++) {
VAR157.FUN59(VAR162[VAR143], VAR163[VAR143], VAR172[VAR143], VAR19[VAR143]);
}
}
function FUN110(bytes32[] memory VAR162, uint256[] memory VAR163, uint256[] memory VAR172, address[] memory VAR19, address[] memory VAR175, uint256[] memory VAR176, uint256[] memory VAR56) public VAR90 {
for (uint256 VAR143 = 0; VAR143 < VAR162.VAR105; VAR143++) {
VAR157.FUN60(VAR162[VAR143], VAR163[VAR143], VAR172[VAR143], VAR19[VAR143], VAR175[VAR143], VAR176[VAR143], VAR56[VAR143]);
}
}
function FUN107(address[] memory VAR132, uint256 VAR112, uint256 VAR113) internal pure returns(address[] memory VAR179) {
VAR179 = new address[](VAR113 - VAR112 + 1);
for (uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
VAR179[VAR108 - VAR112] = VAR132[VAR108];
}
return VAR179;
}
function FUN108(uint256[] memory VAR133, uint256 VAR112, uint256 VAR113) internal pure returns(uint256[] memory VAR179) {
VAR179 = new uint256[](VAR113 - VAR112 + 1);
for (uint256 VAR108 = VAR112; VAR108 <= VAR113; VAR108++) {
VAR179[VAR108 - VAR112] = VAR133[VAR108];
}
return VAR179;
}
function FUN111(address[] memory VAR19) public VAR90 {
for (uint256 VAR108 = 0; VAR108 < VAR19.VAR105; VAR108++) {
VAR157.FUN43(VAR19[VAR108]);
}
}
}
0
---------------------------------
417 0x02cf7ec0178f9cee340e4ec0002cb9aa28a401bd.sol
pragma VAR1 ^0.5.0;
interface VAR2 {
function transfer(address VAR3, uint256 value) external returns (bool);
function FUN1(address VAR4, uint256 value) external returns (bool);
function FUN2(address VAR5, address VAR3, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR6) external view returns (uint256);
function FUN5(address VAR7, address VAR4) external view returns (uint256);
event Transfer(address indexed VAR5, address indexed VAR3, uint256 value);
event FUN6(address indexed VAR7, address indexed VAR4, uint256 value);
}
contract ERC20Detailed is VAR2 {
string private VAR8;
string private VAR9;
uint8 private VAR10;
constructor (string memory VAR11, string memory VAR12, uint8 VAR13) public {
VAR8 = VAR11;
VAR9 = VAR12;
VAR10 = VAR13;
}
function FUN7() public view returns (string VAR14) {
return VAR8;
}
function FUN8() public view returns (string VAR14) {
return VAR9;
}
function FUN9() public view returns (uint8) {
return VAR10;
}
}
library VAR15 {
function FUN10(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
if (VAR16 == 0) {
return 0;
}
uint256 VAR18 = VAR16 * VAR17;
require(VAR18 / VAR16 == VAR17);
return VAR18;
}
function FUN11(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 > 0);
uint256 VAR18 = VAR16 / VAR17;
return VAR18;
}
function FUN12(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 <= VAR16);
uint256 VAR18 = VAR16 - VAR17;
return VAR18;
}
function FUN13(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
uint256 VAR18 = VAR16 + VAR17;
require(VAR18 >= VAR16);
return VAR18;
}
function FUN14(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 != 0);
return VAR16 % VAR17;
}
}
contract BrienneCoin is VAR2 {
using SafeMath for uint256;
mapping (address => uint256) private VAR19;
mapping (address => mapping (address => uint256)) private VAR20;
uint256 private VAR21;
event FUN15(address VAR22, string VAR11, string VAR12);
uint public VAR23;
address public VAR24;
string public constant VAR11 = "";
string public constant VAR12 = "";
uint8 public constant VAR13 = 18;
constructor(uint VAR25, address VAR26) public {
VAR23 = VAR25;
FUN16(VAR26);
}
function FUN3() public view returns (uint256) {
return VAR21;
}
function FUN4(address VAR7) public view returns (uint256) {
return VAR19[VAR7];
}
function FUN5(address VAR7, address VAR4) public view returns (uint256) {
return VAR20[VAR7][VAR4];
}
function transfer(address VAR3, uint256 value) public returns (bool) {
FUN17(msg.sender, VAR3, value);
return true;
}
function FUN16(address VAR27) public {
ERC20Detailed VAR28 = FUN18(VAR27);
string memory VAR29 = VAR28.FUN7();
require(bytes(VAR29).VAR30 > 0, "");
string memory VAR31 = VAR28.FUN8();
require(bytes(VAR31).VAR30 > 0, "");
VAR24 = VAR27;
emit FUN15(VAR27, VAR29, VAR31);
}
function FUN19() public view returns(address, string VAR14, string VAR14) {
ERC20Detailed VAR28 = FUN18(VAR24);
return (VAR24, VAR28.FUN7(), VAR28.FUN8());
}
function FUN1(address VAR4, uint256 value) public returns (bool) {
FUN20(msg.sender, VAR4, value);
return true;
}
function FUN2(address VAR5, address VAR3, uint256 value) public returns (bool) {
FUN17(VAR5, VAR3, value);
FUN20(VAR5, msg.sender, VAR20[VAR5][msg.sender].FUN12(value));
return true;
}
function FUN21(address VAR4, uint256 VAR32) public returns (bool) {
FUN20(msg.sender, VAR4, VAR20[msg.sender][VAR4].FUN13(VAR32));
return true;
}
function FUN22(address VAR4, uint256 VAR33) public returns (bool) {
FUN20(msg.sender, VAR4, VAR20[msg.sender][VAR4].FUN12(VAR33));
return true;
}
function FUN17(address VAR5, address VAR3, uint256 value) internal {
require(VAR3 != address(0));
VAR19[VAR5] = VAR19[VAR5].FUN12(value);
VAR19[VAR3] = VAR19[VAR3].FUN13(value);
emit Transfer(VAR5, VAR3, value);
}
function FUN23() public {
require(VAR34 < VAR23, "");
uint256 VAR35 = 100 * 1e18;
FUN24(msg.sender, VAR35);
}
function FUN24(address VAR36, uint256 value) internal {
require(VAR36 != address(0));
VAR21 = VAR21.FUN13(value);
VAR19[VAR36] = VAR19[VAR36].FUN13(value);
emit Transfer(address(0), VAR36, value);
}
function FUN25(address VAR36, uint256 value) internal {
require(VAR36 != address(0));
VAR21 = VAR21.FUN12(value);
VAR19[VAR36] = VAR19[VAR36].FUN12(value);
emit Transfer(VAR36, address(0), value);
}
function FUN20(address VAR7, address VAR4, uint256 value) internal {
require(VAR4 != address(0));
require(VAR7 != address(0));
VAR20[VAR7][VAR4] = value;
emit FUN6(VAR7, VAR4, value);
}
function FUN26(address VAR36, uint256 value) internal {
FUN25(VAR36, value);
FUN20(VAR36, msg.sender, VAR20[VAR36][msg.sender].FUN12(value));
}
}
0
---------------------------------
418 0x02d9b52c500e3f8f1582bc4c62e725d2b018b2d2.sol
pragma solidity 0.4.18;
contract VAR1 {
address internal VAR2;
function FUN1() public {
VAR2 = msg.sender;
}
function FUN2() public view returns (address) {
return VAR2;
}
modifier onlyOwner {
require(msg.sender == VAR2);
VAR3;
}
function FUN3(address VAR4) public onlyOwner {
require(VAR4 != address(0));
VAR2 = VAR4;
}
}
contract VOCTOP25 is VAR1 {
string  internal VAR5;
string  internal VAR6;
uint8   internal VAR7;
uint256 internal VAR8;
mapping (address => uint256)  internal VAR9;
mapping (address => mapping (address => uint256)) internal VAR10;
mapping (address => bool) internal VAR11;
event Transfer(address indexed VAR12, address indexed VAR13, uint VAR14);
event FUN4(address indexed VAR13, uint256 VAR14);
event FUN5(address indexed VAR12, uint256 VAR14);
event FUN6(address indexed VAR2, address indexed VAR15, uint VAR14);
event FUN7(address indexed VAR16, bool VAR14);
function FUN8() public {
VAR7 = 18;
VAR8 = 0 * 10 ** uint256(VAR7);
VAR9[msg.sender] = VAR8;
VAR5 = "";
VAR6 = "";
}
function FUN9() public view returns (string) {
return VAR5;
}
function FUN10() public view returns (string) {
return VAR6;
}
function FUN11() public view returns (uint8) {
return VAR7;
}
function FUN12() public view returns (uint256) {
return VAR8;
}
function FUN13(address VAR17) public view returns (uint256) {
return VAR9[VAR17];
}
function transfer(address VAR13, uint256 VAR14) public returns (bool VAR18) {
bool VAR19 = FUN14(msg.sender, VAR13, VAR14);
return VAR19;
}
function FUN15(address VAR12, address VAR13, uint256 VAR14) public returns (bool VAR18) {
if (msg.sender != VAR12) {
require(VAR10[VAR12][msg.sender] >= VAR14);
VAR10[VAR12][msg.sender] -= VAR14;
}
bool VAR19 = FUN14(VAR12, VAR13, VAR14);
return VAR19;
}
function FUN16(address VAR15, uint256 VAR14) public returns (bool VAR18) {
VAR10[msg.sender][VAR15] = VAR14;
FUN6(msg.sender, VAR15, VAR14);
return true;
}
function FUN17(address VAR20, address VAR15) public view returns (uint256) {
return VAR10[VAR20][VAR15];
}
function FUN18(address VAR15, uint256 VAR21) public returns (bool) {
require(VAR10[msg.sender][VAR15] + VAR21 >= VAR10[msg.sender][VAR15]);
VAR10[msg.sender][VAR15] += VAR21;
FUN6(msg.sender, VAR15, VAR10[msg.sender][VAR15]);
return true;
}
function FUN19(address VAR15, uint256 VAR22) public returns (bool) {
if (VAR22 > VAR10[msg.sender][VAR15]) {
VAR10[msg.sender][VAR15] = 0;
} else {
VAR10[msg.sender][VAR15] -= VAR22;
}
FUN6(msg.sender, VAR15, VAR10[msg.sender][VAR15]);
return true;
}
function FUN20(uint256 VAR14) public onlyOwner returns (bool VAR18) {
require(!VAR11[VAR2]);
require(VAR9[VAR2] >= VAR14);
VAR9[VAR2] -= VAR14;
VAR8 -= VAR14;
FUN5(VAR2, VAR14);
return true;
}
function FUN21(address VAR12, uint256 VAR14) public onlyOwner returns (bool VAR18) {
bool VAR23 = FUN22(VAR12);
if (VAR23) {
FUN23(VAR12, false);
}
FUN14(VAR12, VAR2, VAR14);
if (VAR23) {
FUN23(VAR12, VAR23);
}
FUN20(VAR14);
return true;
}
function FUN24(uint256 VAR24) public onlyOwner {
require(!VAR11[VAR2]);
require(VAR9[VAR2] + VAR24 >= VAR9[VAR2]);
require(VAR8 + VAR24 >= VAR8);
VAR9[VAR2] += VAR24;
VAR8 += VAR24;
FUN4(VAR2, VAR24);
Transfer(0, VAR2, VAR24);
}
function FUN23(address VAR25, bool VAR26) public onlyOwner returns (bool) {
VAR11[VAR25] = VAR26;
FUN7(VAR25, VAR26);
return true;
}
function FUN22(address VAR16) public view returns (bool) {
return VAR11[VAR16];
}
function FUN14(address VAR12, address VAR13, uint256 VAR14) internal returns (bool VAR18) {
require(VAR13 != 0x0);
require(!VAR11[VAR12]);
require(!VAR11[VAR13]);
require(VAR9[VAR12] >= VAR14);
require(VAR9[VAR13] + VAR14 >= VAR9[VAR13]);
VAR9[VAR12] -= VAR14;
VAR9[VAR13] += VAR14;
Transfer(VAR12, VAR13, VAR14);
return true;
}
}
0
---------------------------------
419 0x02e4514a3c2e9beaa5971b91f0147f79d5549e45.sol
pragma VAR1 ^0.4.23;
contract VAR2
{
address public VAR3 = 0xc5259e85f9E3bC882d151D09f475A16B4001aF61;
address public VAR4 = 0xc5259e85f9E3bC882d151D09f475A16B4001aF61;
mapping(address => uint256) VAR5;
string public VAR6 = "";
string public VAR7 = "";
uint8 public VAR8 = 18;
uint256 VAR9 = 500000000;
uint256 public VAR10 = 0;
constructor()
payable
public
{
VAR10 = FUN1(VAR9, 10**uint256(VAR8));
VAR5[VAR4] = VAR10;
}
function FUN2( address VAR11 ) public view returns ( uint )
{
return VAR5[VAR11];
}
event Transfer(
address indexed VAR12,
address indexed VAR13,
uint256 value
);
function transfer(
address VAR14,
uint256 VAR15
)
public
returns (bool)
{
require(VAR14 != address(0));
require(VAR15 <= VAR5[msg.sender]);
VAR5[msg.sender] = FUN3(VAR5[msg.sender],VAR15);
VAR5[VAR14] = FUN4(VAR5[VAR14], VAR15);
emit Transfer(msg.sender, VAR14, VAR15);
return true;
}
mapping (address => mapping (address => uint256)) internal VAR16;
event FUN5(
address indexed VAR17,
address indexed VAR18,
uint256 value
);
function FUN6(
address VAR19,
address VAR14,
uint256 VAR15
)
public
returns (bool)
{
require(VAR14 != address(0));
require(VAR15 <= VAR5[VAR19]);
require(VAR15 <= VAR16[VAR19][msg.sender]);
VAR5[VAR19] = FUN3(VAR5[VAR19], VAR15);
VAR5[VAR14] = FUN4(VAR5[VAR14], VAR15);
VAR16[VAR19][msg.sender] = FUN3(VAR16[VAR19][msg.sender], VAR15);
emit Transfer(VAR19, VAR14, VAR15);
return true;
}
function FUN7(
address VAR20,
uint256 VAR15
)
public
returns (bool)
{
VAR16[msg.sender][VAR20] = VAR15;
emit FUN5(msg.sender, VAR20, VAR15);
return true;
}
function FUN8(
address VAR21,
address VAR20
)
public
view
returns (uint256)
{
return VAR16[VAR21][VAR20];
}
function FUN9(
address VAR20,
uint256 VAR22
)
public
returns (bool)
{
VAR16[msg.sender][VAR20] = FUN4(VAR16[msg.sender][VAR20], VAR22);
emit FUN5(msg.sender, VAR20, VAR16[msg.sender][VAR20]);
return true;
}
function FUN10(
address VAR20,
uint256 VAR23
)
public
returns (bool)
{
uint256 VAR24 = VAR16[msg.sender][VAR20];
if (VAR23 > VAR24) {
VAR16[msg.sender][VAR20] = 0;
}
else
{
VAR16[msg.sender][VAR20] = FUN3(VAR24, VAR23);
}
emit FUN5(msg.sender, VAR20, VAR16[msg.sender][VAR20]);
return true;
}
event FUN11(address indexed VAR25, uint256 value);
function FUN12(uint256 VAR15) public
{
FUN13(msg.sender, VAR15);
}
function FUN13(address VAR26, uint256 VAR15) internal
{
require(VAR15 <= VAR5[VAR26]);
VAR5[VAR26] = FUN3(VAR5[VAR26], VAR15);
VAR10 = FUN3(VAR10, VAR15);
emit FUN11(VAR26, VAR15);
emit Transfer(VAR26, address(0), VAR15);
}
modifier FUN14()
{
require(msg.sender==VAR3);
VAR27;
}
function FUN15( address VAR28 )
public
VAR29
returns (bool)
{
require(VAR28 != address(0));
VAR3 = VAR28;
return true;
}
function FUN16()
public
VAR29
{
require(address(this).VAR30 > 0);
VAR3.transfer(address(this).VAR30);
}
function () external payable
{
}
function FUN1(uint256 VAR31, uint256 VAR32) internal pure returns (uint256 VAR33)
{
if (VAR31 == 0)
{
return 0;
}
VAR33 = VAR31 * VAR32;
assert(VAR33 / VAR31 == VAR32);
return VAR33;
}
function FUN17(uint256 VAR31, uint256 VAR32) internal pure returns (uint256)
{
return VAR31 / VAR32;
}
function FUN3(uint256 VAR31, uint256 VAR32) internal pure returns (uint256)
{
assert(VAR32 <= VAR31);
return VAR31 - VAR32;
}
function FUN4(uint256 VAR31, uint256 VAR32) internal pure returns (uint256 VAR33)
{
VAR33 = VAR31 + VAR32;
assert(VAR33 >= VAR31);
return VAR33;
}
}
0
---------------------------------
420 0x02e582682aa7b4dcc3f7574c468ef61b29545404.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
using SafeMath for uint;
event FUN1(
uint VAR3
);
event FUN2(
address VAR4,
address VAR5,
uint VAR6
);
uint256 public VAR7 = 2 VAR8;
uint256 public VAR9           = 232;
uint256        VAR10                       = 10000;
uint256        VAR11                      = 5000;
address        VAR12               = 0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae;
uint256 public VAR13;
uint256 public VAR14;
bool    public VAR15;
address public VAR16;
mapping (address => uint256) public VAR17;
mapping (address => uint256) public VAR18;
mapping (address => uint256) public VAR19;
mapping (address => address) public VAR20;
constructor () public {
VAR15      = false;
VAR14   = 0.1 VAR21;
VAR16 = 0x1337a4aEfd5ec486E6e97b1d0aE055FAC8D879dE;
}
function FUN3() public payable {
require(VAR15);
address VAR22 = VAR16;
uint VAR23   = VAR14;
VAR14       = VAR23.FUN4(VAR23.FUN5(10));
require(msg.value >= VAR14);
uint VAR24          = msg.value.FUN6(VAR14);
uint VAR25     = (VAR14.FUN6(VAR23)).FUN5(20);
uint VAR26       = VAR25.FUN7(10);
uint VAR27     = VAR25.FUN7(9);
address VAR28    = msg.sender;
uint    VAR29    = (VAR23.FUN4(VAR26)).FUN4(VAR24);
VAR16     = VAR28;
VAR22.transfer(VAR29);
VAR12.transfer(VAR25);
FUN8(VAR27);
emit FUN2(VAR22, VAR28, VAR14);
}
function FUN8(uint VAR30) public payable {
require(VAR15);
emit FUN1(VAR30);
}
function FUN9(address VAR31) public{
require(VAR15);
address VAR32 = msg.sender;
if(VAR20[VAR32] == 0 && VAR20[VAR32] != VAR32){
VAR20[VAR32]=VAR31;
}
uint256 VAR33          = FUN10();
uint256 VAR34         = VAR33.FUN5(VAR7);
VAR17[VAR32] = VAR17[VAR32].FUN4(VAR34);
VAR18[VAR32]  = 0;
VAR19[VAR32]    = VAR35;
if (VAR17[VAR20[VAR32]] > 0)
{
VAR18[VAR20[VAR32]] = VAR18[VAR20[VAR32]].FUN4(VAR33.FUN5(20));
}
VAR13 = VAR13.FUN4(VAR33.FUN5(10));
}
function FUN11() public {
require(VAR15);
address VAR36 = msg.sender;
uint256 VAR37        = FUN10();
uint256 VAR38       = FUN12(VAR37);
uint256 VAR39             = FUN13(VAR38);
VAR17[VAR36]  = (VAR17[msg.sender].FUN5(4)).FUN7(3);
VAR18[VAR36]   = 0;
VAR19[VAR36]     = VAR35;
VAR13             = VAR13.FUN4(VAR37);
VAR16.transfer(VAR39);
VAR36.transfer(VAR38.FUN6(VAR39));
}
function FUN14() public payable{
require(VAR15);
address VAR40       = msg.sender;
uint    VAR41        = msg.value;
uint256 VAR42  = FUN15(VAR41, VAR43.FUN6(address(this).VAR44,VAR41));
VAR42          = VAR42.FUN6(FUN13(VAR42));
VAR16.transfer(FUN13(VAR41));
VAR18[VAR40] = VAR18[VAR40].FUN4(VAR42);
}
function FUN16(uint256 VAR45,uint256 VAR46, uint256 VAR47) public view returns(uint256){
return VAR43.FUN5(VAR43.FUN7(VAR10,VAR47),VAR43.FUN4(VAR11,VAR43.FUN5(VAR43.FUN4(VAR43.FUN7(VAR10,VAR46),VAR43.FUN7(VAR11,VAR45)),VAR45)));
}
function FUN12(uint256 VAR48) public view returns(uint256){
return FUN16(VAR48,VAR13,address(this).VAR44);
}
function FUN15(uint256 VAR49,uint256 VAR50) public view returns(uint256){
return FUN16(VAR49, VAR50, VAR13);
}
function FUN17(uint256 VAR49) public view returns(uint256){
return FUN15(VAR49,address(this).VAR44);
}
function FUN13(uint256 VAR51) public pure returns(uint256){
return VAR51.FUN7(4).FUN5(100);
}
function FUN18(uint256 VAR48) public payable {
require(msg.sender  == VAR16);
require(VAR13 == 0);
VAR15         = true;
VAR13         = VAR48;
FUN8(msg.value);
}
function FUN19() public payable{
require(VAR15);
require(msg.value==0.00232 VAR21);
address VAR36        = msg.sender;
VAR16.transfer(msg.value);
require(VAR17[VAR36]==0);
VAR19[VAR36]    = VAR35;
VAR17[VAR36] = VAR9;
}
function FUN20() public view returns(uint256){
return address(this).VAR44;
}
function FUN21() public view returns(uint256){
return VAR17[msg.sender];
}
function FUN22() public view returns(uint256){
return VAR14;
}
function FUN10() public view returns(uint256){
address VAR36 = msg.sender;
return VAR18[VAR36].FUN4(FUN23(VAR36));
}
function FUN23(address VAR52) public view returns(uint256){
uint256 VAR53=FUN24(VAR7, VAR35.FUN6(VAR19[VAR52]));
return VAR53.FUN7(VAR17[VAR52]);
}
function FUN24(uint256 VAR54, uint256 VAR55) private pure returns (uint256) {
return VAR54 < VAR55 ? VAR54 : VAR55;
}
}
library VAR43 {
function FUN7(uint256 VAR54, uint256 VAR55) internal pure returns (uint256) {
if (VAR54 == 0) {
return 0;
}
uint256 VAR56 = VAR54 * VAR55;
assert(VAR56 / VAR54 == VAR55);
return VAR56;
}
function FUN5(uint256 VAR54, uint256 VAR55) internal pure returns (uint256) {
uint256 VAR56 = VAR54 / VAR55;
return VAR56;
}
function FUN6(uint256 VAR54, uint256 VAR55) internal pure returns (uint256) {
assert(VAR55 <= VAR54);
return VAR54 - VAR55;
}
function FUN4(uint256 VAR54, uint256 VAR55) internal pure returns (uint256) {
uint256 VAR56 = VAR54 + VAR55;
assert(VAR56 >= VAR54);
return VAR56;
}
}
0
---------------------------------
421 0x02ec0c9e6d3c08b8fb12fec51ccba048afbc36a6.sol
pragma solidity 0.4.23;
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function transfer(address VAR3, uint256 value) public returns (bool);
event Transfer(address indexed VAR4, address indexed VAR3, uint256 value);
}
contract ERC20 is VAR1 {
function FUN3(address VAR5, address VAR6) public view returns (uint256);
function FUN4(address VAR4, address VAR3, uint256 value) public returns (bool);
function FUN5(address VAR6, uint256 value) public returns (bool);
event FUN6(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract BasicToken is VAR1 {
using SafeMath for uint256;
mapping(address => uint256) VAR7;
uint256 VAR8;
function FUN1() public view returns (uint256) {
return VAR8;
}
function transfer(address VAR9, uint256 VAR10) public returns (bool) {
require(VAR9 != address(0));
require(VAR10 <= VAR7[msg.sender]);
VAR7[msg.sender] = VAR7[msg.sender].FUN7(VAR10);
VAR7[VAR9] = VAR7[VAR9].FUN8(VAR10);
Transfer(msg.sender, VAR9, VAR10);
return true;
}
function FUN2(address VAR11) public view returns (uint256 VAR12) {
return VAR7[VAR11];
}
}
contract DetailedERC20 is VAR13 {
string public VAR14;
string public VAR15;
uint8 public VAR16;
function FUN9(string VAR17, string VAR18, uint8 VAR19) public {
VAR14 = VAR17;
VAR15 = VAR18;
VAR16 = VAR19;
}
}
contract StandardToken is VAR13, VAR20 {
mapping (address => mapping (address => uint256)) internal VAR21;
function FUN4(address VAR22, address VAR9, uint256 VAR10) public returns (bool) {
require(VAR9 != address(0));
require(VAR10 <= VAR7[VAR22]);
require(VAR10 <= VAR21[VAR22][msg.sender]);
VAR7[VAR22] = VAR7[VAR22].FUN7(VAR10);
VAR7[VAR9] = VAR7[VAR9].FUN8(VAR10);
VAR21[VAR22][msg.sender] = VAR21[VAR22][msg.sender].FUN7(VAR10);
Transfer(VAR22, VAR9, VAR10);
return true;
}
function FUN5(address VAR23, uint256 VAR10) public returns (bool) {
VAR21[msg.sender][VAR23] = VAR10;
FUN6(msg.sender, VAR23, VAR10);
return true;
}
function FUN3(address VAR11, address VAR23) public view returns (uint256) {
return VAR21[VAR11][VAR23];
}
function FUN10(address VAR23, uint VAR24) public returns (bool) {
VAR21[msg.sender][VAR23] = VAR21[msg.sender][VAR23].FUN8(VAR24);
FUN6(msg.sender, VAR23, VAR21[msg.sender][VAR23]);
return true;
}
function FUN11(address VAR23, uint VAR25) public returns (bool) {
uint VAR26 = VAR21[msg.sender][VAR23];
if (VAR25 > VAR26) {
VAR21[msg.sender][VAR23] = 0;
} else {
VAR21[msg.sender][VAR23] = VAR26.FUN7(VAR25);
}
FUN6(msg.sender, VAR23, VAR21[msg.sender][VAR23]);
return true;
}
}
library VAR27 {
function FUN12(uint256 VAR28, uint256 VAR29) internal pure returns (uint256) {
if (VAR28 == 0) {
return 0;
}
uint256 VAR30 = VAR28 * VAR29;
assert(VAR30 / VAR28 == VAR29);
return VAR30;
}
function FUN13(uint256 VAR28, uint256 VAR29) internal pure returns (uint256) {
uint256 VAR30 = VAR28 / VAR29;
return VAR30;
}
function FUN7(uint256 VAR28, uint256 VAR29) internal pure returns (uint256) {
assert(VAR29 <= VAR28);
return VAR28 - VAR29;
}
function FUN8(uint256 VAR28, uint256 VAR29) internal pure returns (uint256) {
uint256 VAR30 = VAR28 + VAR29;
assert(VAR30 >= VAR28);
return VAR30;
}
}
library VAR31 {
function FUN14(address[] VAR32, address value) internal returns (bool) {
for (uint VAR33 = 0; VAR33 < VAR32.VAR34; VAR33++) {
if (VAR32[VAR33] == value) {
return true;
}
}
return false;
}
function FUN15(address[] storage VAR28, uint256 VAR35) internal returns (uint256) {
VAR28[VAR35] = VAR28[VAR28.VAR34 - 1];
VAR28.VAR34 -= 1;
}
}
contract VAR36 {
function FUN16(uint VAR37) public returns (bool VAR38);
function FUN17(uint VAR37) public returns (bool VAR38);
event FUN18(
address indexed VAR39,
uint VAR37
);
event FUN19(
address indexed VAR39,
uint VAR37
);
}
contract SetToken is VAR40, FUN9("", "", 18), VAR36 {
using SafeMath for uint256;
using AddressArrayUtils for address[];
struct VAR41 {
address VAR42;
uint VAR43;
}
uint public VAR44;
VAR41[] public VAR45;
mapping(bytes32 => bool) internal VAR46;
mapping(uint => mapping(address => uint)) internal VAR47;
event FUN20(
address indexed VAR39,
uint VAR37,
bytes32 VAR48
);
event FUN21(
address indexed VAR39,
bytes32 VAR49
);
modifier FUN22(uint VAR50) {
require(VAR7[msg.sender] >= VAR50, "");
VAR51;
}
modifier FUN23(address VAR9) {
require(VAR9 != address(0));
require(VAR9 != address(this));
VAR51;
}
modifier FUN24(uint VAR37) {
require((VAR37 % VAR44) == 0);
VAR51;
}
modifier FUN25(uint VAR37) {
require(VAR37 > 0);
VAR51;
}
constructor(address[] VAR49, uint[] VAR52, uint VAR53)
FUN25(VAR53)
public {
require(VAR49.VAR34 > 0, "");
require(VAR52.VAR34 > 0, "");
require(VAR49.VAR34 == VAR52.VAR34, "");
VAR44 = VAR53;
for (uint16 VAR33 = 0; VAR33 < VAR52.VAR34; VAR33++) {
uint VAR54 = VAR52[VAR33];
require(VAR54 > 0, "");
address VAR55 = VAR49[VAR33];
require(VAR55 != address(0), "");
require(!FUN26(VAR55));
VAR46[FUN27(VAR55)] = true;
VAR45.FUN28(FUN29({
VAR42: VAR55,
VAR43: VAR54
}));
}
}
function FUN16(uint VAR37)
FUN24(VAR37)
FUN25(VAR37)
public returns (bool VAR38) {
for (uint16 VAR33 = 0; VAR33 < VAR45.VAR34; VAR33++) {
address VAR55 = VAR45[VAR33].VAR42;
uint VAR54 = VAR45[VAR33].VAR43;
uint VAR56 = FUN30(VAR55).FUN2(this);
uint VAR57 = FUN31(VAR54, VAR37);
require(FUN30(VAR55).FUN4(msg.sender, this, VAR57));
uint VAR58 = FUN30(VAR55).FUN2(this);
assert(VAR56.FUN8(VAR57) == VAR58);
}
FUN32(VAR37);
emit FUN18(msg.sender, VAR37);
return true;
}
function FUN17(uint VAR37)
public
FUN24(VAR37)
FUN22(VAR37)
FUN25(VAR37)
returns (bool VAR38)
{
FUN33(VAR37);
for (uint16 VAR33 = 0; VAR33 < VAR45.VAR34; VAR33++) {
address VAR55 = VAR45[VAR33].VAR42;
uint VAR54 = VAR45[VAR33].VAR43;
uint VAR56 = FUN30(VAR55).FUN2(this);
uint VAR57 = FUN31(VAR54, VAR37);
require(FUN30(VAR55).transfer(msg.sender, VAR57));
uint VAR58 = FUN30(VAR55).FUN2(this);
assert(VAR56.FUN7(VAR57) == VAR58);
}
emit FUN19(msg.sender, VAR37);
return true;
}
function FUN34(uint VAR37, bytes32 VAR59)
public
FUN24(VAR37)
FUN25(VAR37)
FUN22(VAR37)
returns (bool VAR38)
{
require(VAR59 > 0, "");
FUN33(VAR37);
for (uint16 VAR33 = 0; VAR33 < VAR45.VAR34; VAR33++) {
uint VAR57 = FUN31(VAR45[VAR33].VAR43, VAR37);
if (VAR59 & bytes32(2 ** VAR33) > 0) {
VAR47[VAR33][msg.sender] += VAR57;
} else {
uint VAR56 = FUN30(VAR45[VAR33].VAR42).FUN2(this);
require(FUN30(VAR45[VAR33].VAR42).transfer(msg.sender, VAR57));
uint VAR58 = FUN30(VAR45[VAR33].VAR42).FUN2(this);
assert(VAR56.FUN7(VAR57) == VAR58);
}
}
emit FUN20(msg.sender, VAR37, VAR59);
return true;
}
function FUN35(bytes32 VAR60)
public
returns (bool VAR38)
{
require(VAR60 > 0, "");
for (uint16 VAR33 = 0; VAR33 < VAR45.VAR34; VAR33++) {
if (VAR60 & bytes32(2 ** VAR33) > 0) {
address VAR55 = VAR45[VAR33].VAR42;
uint VAR61 = VAR47[VAR33][msg.sender];
VAR47[VAR33][msg.sender] = 0;
require(FUN30(VAR55).transfer(msg.sender, VAR61));
}
}
emit FUN21(msg.sender, VAR60);
return true;
}
function FUN36() public view returns(address[]) {
address[] memory VAR62 = new address[](VAR45.VAR34);
for (uint16 VAR33 = 0; VAR33 < VAR45.VAR34; VAR33++) {
VAR62[VAR33] = VAR45[VAR33].VAR42;
}
return VAR62;
}
function FUN37() public view returns(uint[]) {
uint[] memory VAR63 = new uint[](VAR45.VAR34);
for (uint16 VAR33 = 0; VAR33 < VAR45.VAR34; VAR33++) {
VAR63[VAR33] = VAR45[VAR33].VAR43;
}
return VAR63;
}
function FUN38(address VAR64, address VAR65) public view returns (uint256) {
require(FUN26(VAR64));
uint VAR66;
for (uint VAR33 = 0; VAR33 < VAR45.VAR34; VAR33++) {
if (VAR45[VAR33].VAR42 == VAR64) {
VAR66 = VAR33;
}
}
return VAR47[VAR66][VAR65];
}
function transfer(address VAR9, uint256 VAR10) FUN23(VAR9) public returns (bool) {
return super.transfer(VAR9, VAR10);
}
function FUN4(address VAR22, address VAR9, uint256 VAR10) FUN23(VAR9) public returns (bool) {
return super.FUN4(VAR22, VAR9, VAR10);
}
function FUN26(address VAR67) view internal returns (bool) {
return VAR46[FUN27(VAR67)];
}
function FUN31(uint VAR68, uint VAR50) view internal returns(uint) {
return VAR50.FUN13(VAR44).FUN12(VAR68);
}
function FUN32(uint VAR50) internal {
VAR7[msg.sender] = VAR7[msg.sender].FUN8(VAR50);
VAR8 = VAR8.FUN8(VAR50);
emit Transfer(address(0), msg.sender, VAR50);
}
function FUN33(uint VAR50) internal {
VAR7[msg.sender] = VAR7[msg.sender].FUN7(VAR50);
VAR8 = VAR8.FUN7(VAR50);
emit Transfer(msg.sender, address(0), VAR50);
}
}
0
---------------------------------
422 0x02f28544c89b2d704eb0d1f9f4fc60d688ad8959.sol
pragma VAR1 ^0.5.8;
//
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4; require(VAR5 >= VAR3,""); }
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3, ""); VAR5 = VAR3 - VAR4;  }
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4; require(VAR3 == 0 || VAR5 / VAR3 == VAR4,""); }
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0,""); VAR5 = VAR3 / VAR4; }
}
contract VAR6 {
function FUN5() external view returns (uint);
function FUN6(address VAR7) public view returns (uint256 VAR8);
function FUN7(address VAR7, address VAR9) public view returns (uint VAR10);
function transfer(address VAR11, uint value) public returns (bool VAR12);
function FUN8(address VAR9, uint value) public returns (bool VAR12);
function FUN9(address VAR13, address VAR11, uint value) public returns (bool VAR12);
event Transfer(address indexed VAR13, address indexed VAR11, uint256 value);
event FUN10(address indexed VAR7, address indexed VAR9, uint256 value);
}
contract ERC1404 is VAR6 {
function FUN11 (address VAR13, address VAR11, uint256 value) public view returns (uint8);
function FUN12 (uint8 VAR14) public view returns (string VAR15);
}
contract VAR16 {
address public VAR7;
address internal VAR17;
event FUN13(address indexed VAR18, address indexed VAR19);
constructor() public {
VAR7 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR7, "");
VAR20;
}
function FUN14(address VAR21) external onlyOwner {
VAR17 = VAR21;
}
function FUN15() external {
require(msg.sender == VAR17);
emit FUN13(VAR7, VAR17);
VAR7 = VAR17;
VAR17 = address(0);
}
}
contract Managed is VAR16 {
mapping (address => bool) public VAR22;
modifier onlyManager () {
require(VAR22[msg.sender], "");
VAR20;
}
function FUN16 (address VAR23) public onlyOwner {
VAR22[VAR23] = true;
}
function FUN17 (address VAR23) external onlyOwner {
VAR22[VAR23] = false;
}
}
contract Whitelist is VAR24 {
mapping(address => VAR25) public VAR26;
bytes1 internal VAR27;
bytes1 internal constant VAR28 = 0x01;
bytes1 internal constant VAR29 = 0x02;
bytes1 internal constant VAR30 = 0x04;
function FUN18(address VAR31) public view returns (bool){
return (VAR30 == (VAR26[VAR31] & VAR30));
}
function FUN19(address VAR19) external onlyManager {
VAR26[VAR19] = VAR26[VAR19] | VAR29;
}
function FUN20(address VAR19) external onlyManager {
VAR26[VAR19] = VAR26[VAR19] | VAR28;
}
function FUN21(address VAR19) public onlyManager {
if (VAR29 == (VAR26[VAR19] & VAR29))  {
VAR26[VAR19] = VAR26[VAR19] ^ VAR29;
}
}
function FUN22(address VAR19) public onlyManager {
if (VAR28 == (VAR26[VAR19] & VAR28))  {
VAR26[VAR19] = VAR26[VAR19] ^ VAR28;
}
}
function FUN23 (address VAR19) external onlyManager {
FUN21(VAR19);
FUN22(VAR19);
}
function FUN24(address VAR19) external onlyOwner {
VAR26[VAR19] = VAR26[VAR19] | VAR30;
}
function FUN25(address VAR19) external onlyOwner {
if (VAR30 == (VAR26[VAR19] & VAR30 )) {
VAR26[VAR19] = VAR26[VAR19] ^ VAR30;
}
}
function FUN26(byte VAR32) external onlyOwner {
VAR27 = VAR32;
}
function FUN27() external view returns (VAR33){
return VAR27;
}
}
contract SPTToken is VAR34, VAR16, VAR35 {
using SafeMath for uint;
string public VAR36;
string public  VAR37;
uint8 public VAR38;
uint public VAR39;
uint8 internal VAR40;
mapping(address => uint) public VAR41;
mapping(address => mapping(address => uint)) VAR42;
constructor() public {
VAR36 = "";
VAR37 = "";
VAR38 = 8;
VAR39 = 100000000000000000;
VAR41[msg.sender] = VAR39;
VAR22[msg.sender] = true;
VAR27 = 0x00;
emit Transfer(address(0), msg.sender, VAR39);
}
modifier FUN28(address VAR18, address VAR19, uint256 VAR43 ) {
require(!FUN18(VAR19) && !FUN18(VAR18), "");
if ((VAR27 & VAR29) != 0) {
require(VAR29 == (VAR26[VAR18] & VAR29), "");
}
if ((VAR27 & VAR28) != 0) {
require(VAR28 == (VAR26[VAR19] & VAR28),"");
}
VAR20;
}
function FUN5() external view returns (uint) {
return VAR39.FUN2(VAR41[address(0)]);
}
function FUN6(address VAR7) public view returns (uint256) {
return VAR41[VAR7];
}
function transfer(address VAR19, uint VAR44)  public FUN28(msg.sender, VAR19, VAR44) returns (bool) {
require((VAR19 != address(0)) && (VAR19 != address(this)));
VAR41[msg.sender] = VAR41[msg.sender].FUN2(VAR44);
VAR41[VAR19] = VAR41[VAR19].FUN1(VAR44);
emit Transfer(msg.sender, VAR19, VAR44);
return true;
}
function FUN8(address VAR9, uint value) public FUN28(msg.sender, VAR9, value) returns (bool) {
VAR42[msg.sender][VAR9] = value;
emit FUN10(msg.sender, VAR9, value);
return true;
}
function FUN9(address VAR18, address VAR19, uint VAR44) public FUN28(VAR18, VAR19, VAR44) returns (bool) {
require((VAR19 != address(0)) && (VAR19 != address(this)));
VAR41[VAR18] = VAR41[VAR18].FUN2(VAR44);
VAR42[VAR18][msg.sender] = VAR42[VAR18][msg.sender].FUN2(VAR44);
VAR41[VAR19] = VAR41[VAR19].FUN1(VAR44);
emit Transfer(VAR18, VAR19, VAR44);
return true;
}
function FUN7(address VAR7, address VAR9) public view returns (uint) {
return VAR42[VAR7][VAR9];
}
function () payable external {
revert();
}
function FUN29(address VAR45, uint VAR46) public onlyOwner returns (bool VAR12) {
return FUN30(VAR45).transfer(VAR7, VAR46);
}
function FUN11 (address VAR18, address VAR19, uint256 VAR44) public view returns (uint8 VAR14)
{
VAR14 = 0;
if ( VAR29 == (VAR27 & VAR29) ) {
if (!(VAR29 == (VAR26[VAR19] & VAR29)) ) {
VAR14 += 1;
}
}
if (VAR28 == (VAR27 & VAR28)){
if (!(VAR28 == (VAR26[VAR18] & VAR28))) {
VAR14 += 2;
}
}
if ((VAR30 == (VAR26[VAR18] & VAR30)) ) {
VAR14 += 4;
}
if ((VAR30 == (VAR26[VAR19] & VAR30)) ) {
VAR14 += 8;
}
if (FUN6(VAR18) < VAR44) {
VAR14 += 16;
}
return VAR14;
}
function FUN12 (uint8 VAR47) public view returns (string memory VAR48) {
VAR48 = "";
if (VAR47 >= 16) {
VAR48 = "";
} else if (VAR47 >= 8) {
VAR48 = "";
} else if (VAR47 >= 4) {
VAR48 = "";
} else if (VAR47 >= 3) {
VAR48 = "";
} else if (VAR47 >= 2) {
VAR48 = "";
} else if (VAR47 >= 1) {
VAR48 = "";
}
return VAR48;
}
}
0
---------------------------------
423 0x02fc89cada24d38d87be7c70a56828738b08d8e0.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function transfer(address VAR3, uint256 value) public returns (bool);
function FUN3(address VAR4, address VAR5)
public view returns (uint256);
function FUN4(address VAR6, address VAR3, uint256 value)
public returns (bool);
function FUN5(address VAR5, uint256 value) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR3, uint256 value);
event FUN6(
address indexed VAR4,
address indexed VAR5,
uint256 value
);
}
library VAR7 {
function FUN7(ERC20 VAR8, address VAR3, uint256 value) internal {
require(VAR8.transfer(VAR3, value));
}
function FUN8(
ERC20 VAR8,
address VAR6,
address VAR3,
uint256 value
)
internal
{
require(VAR8.FUN4(VAR6, VAR3, value));
}
function FUN9(ERC20 VAR8, address VAR5, uint256 value) internal {
require(VAR8.FUN5(VAR5, value));
}
}
contract VAR9 {
using SafeERC20 for VAR1;
ERC20 public VAR8;
address public VAR10;
uint256 public VAR11 = 1540857600;
constructor(
address VAR12,
address VAR13
)
public
{
require(VAR13 != address(0));
VAR8 = FUN10(VAR12);
VAR10 = VAR13;
}
function FUN11() public {
uint256 VAR14;
if (VAR15.VAR16 >= VAR11) {
VAR14 = VAR8.FUN2(this);
require(VAR14 > 0);
VAR8.FUN7(VAR10, VAR14);
VAR11 = 0;
} else {
revert();
}
}
}
0
---------------------------------
424 0x02fcda86fffefc71d83180b436e5d7f78906345c.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
string public VAR3 = '';
string constant public VAR4 = "";
uint256 constant public VAR5 = 8;
uint256 public constant VAR6 = 20170808 * (10 ** uint256(VAR5));
mapping (address => uint256) public VAR7;
mapping (address => mapping (address => uint256)) public VAR8;
uint256 public VAR9 = 0;
address public VAR10 = 0x0;
modifier VAR11 {
assert(VAR10 == msg.sender);
VAR12;
}
function FUN1(address VAR13) public VAR11 {
require(VAR13 != address(0));
emit FUN2(VAR10, VAR13);
VAR10 = VAR13;
}
constructor() public {
VAR10 = msg.sender;
VAR9 = VAR6;
VAR7[VAR10] = VAR9;
emit Transfer(0x0, VAR10, VAR9);
}
function transfer(address VAR14, uint256 VAR15)  public returns (bool VAR16) {
require(VAR7[msg.sender] >= VAR15);
require(VAR7[VAR14] + VAR15 >= VAR7[VAR14]);
VAR7[msg.sender] -= VAR15;
VAR7[VAR14] += VAR15;
emit Transfer(msg.sender, VAR14, VAR15);
return true;
}
function FUN3(address VAR17, address VAR14, uint256 VAR15)  public returns (bool VAR16) {
require(VAR7[VAR17] >= VAR15);
require(VAR7[VAR14] + VAR15 >= VAR7[VAR14]);
require(VAR8[VAR17][msg.sender] >= VAR15);
VAR7[VAR14] += VAR15;
VAR7[VAR17] -= VAR15;
VAR8[VAR17][msg.sender] -= VAR15;
emit Transfer(VAR17, VAR14, VAR15);
return true;
}
function FUN4(address VAR18, uint256 VAR15) public returns (bool VAR16) {
VAR8[msg.sender][VAR18] = VAR15;
emit  FUN5(msg.sender, VAR18, VAR15);
return true;
}
function FUN6(string VAR19) public VAR11 {
VAR3 = VAR19;
}
event Transfer(address indexed VAR17, address indexed VAR14, uint256 VAR15);
event FUN5(address indexed VAR20, address indexed VAR18, uint256 VAR15);
event FUN2(address indexed VAR21, address indexed VAR13);
}
0
---------------------------------
425 0x02fde7308846aa9b6f84514779aa90b55063d831.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30153600;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xB3CE69c6E466C82399474F4367E32a3160eFBd1F;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
426 0x03040814d2f49869116d22f0c914b0146a0c5d6b.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29894400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xD03D4ab642b747cdB2F0B20b7028596CA351eD03;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
427 0x03107da4908f4f8e4b60cf8def7c59ddf601adf1.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
function FUN5()public view returns (uint VAR6);
function FUN6(address VAR7)public view returns (uint256 VAR8);
function FUN7(address VAR7, address VAR9)public view returns (uint VAR10);
function FUN8(address VAR11, address VAR12, uint VAR13)public returns (bool VAR14);
function FUN9(address VAR9, uint VAR13)public returns (bool VAR14);
function transfer(address VAR12, uint VAR13)public returns (bool VAR14);
event Transfer(address indexed VAR11, address indexed VAR12, uint VAR13);
event FUN10(address indexed VAR7, address indexed VAR9, uint VAR13);
}
contract CentralBankofSeychelles is VAR5
{using SafeMath for uint256;
string public constant VAR15 = "";
string public constant VAR16 = "";
uint public constant VAR17 = 18;
uint256 VAR18 = 999000000000000000000 * 10 ** 18;
address public VAR19;
mapping(address => uint256) VAR20;
mapping(address => mapping (address => uint256)) VAR21;
modifier onlyOwner() {
if (msg.sender != VAR19) {
revert();
}
VAR22;
}
constructor () public {
VAR19 = msg.sender;
VAR20[VAR19] = VAR18;
emit Transfer(0, VAR19, VAR18);
}
function FUN11(uint256 VAR23) public onlyOwner {
VAR18 = (VAR18).FUN3(VAR23);
}
function FUN5() public view returns (uint256 VAR6) {
VAR6 = VAR18;
}
function FUN6(address VAR7)public view returns (uint256 VAR8) {
return VAR20[VAR7];
}
function transfer(address VAR12, uint256 VAR13)public returns (bool VAR14) {
require( VAR12 != 0x0);
require(VAR20[msg.sender] >= VAR13 && VAR13 >= 0);
VAR20[msg.sender] = (VAR20[msg.sender]).FUN3(VAR13);
VAR20[VAR12] = (VAR20[VAR12]).FUN4(VAR13);
emit Transfer(msg.sender, VAR12, VAR13);
return true;
}
function FUN8( address VAR11, address VAR12, uint256 VAR13 )public returns (bool VAR14) {
require( VAR12 != 0x0);
require(VAR20[VAR11] >= VAR13 && VAR21[VAR11][msg.sender] >= VAR13 && VAR13 >= 0);
VAR20[VAR11] = (VAR20[VAR11]).FUN3(VAR13);
VAR21[VAR11][msg.sender] = (VAR21[VAR11][msg.sender]).FUN3(VAR13);
VAR20[VAR12] = (VAR20[VAR12]).FUN4(VAR13);
emit Transfer(VAR11, VAR12, VAR13);
return true;
}
function FUN9(address VAR9, uint256 VAR13)public returns (bool VAR14) {
require( VAR9 != 0x0);
VAR21[msg.sender][VAR9] = VAR13;
emit FUN10(msg.sender, VAR9, VAR13);
return true;
}
function FUN7(address VAR7, address VAR9)public view returns (uint256 VAR10) {
require( VAR7 != 0x0 && VAR9 !=0x0);
return VAR21[VAR7][VAR9];
}
function FUN12(address VAR24) external onlyOwner
{
uint256 VAR25 = VAR20[VAR19];
require( VAR24 != 0x0);
VAR20[VAR24] = (VAR20[VAR24]).FUN4(VAR20[VAR19]);
VAR20[VAR19] = 0;
VAR19 = VAR24;
emit Transfer(msg.sender, VAR24, VAR25);
}
}
0
---------------------------------
428 0x031228f403dbfde1dd47310bdc49bb788f53ecd9.sol
pragma VAR1 ^0.4.25;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
interface VAR6 {
function FUN6() external view returns (uint256);
function FUN7(address VAR7) external view returns (uint256);
function FUN8(address VAR8, address VAR9)
external view returns (uint256);
function transfer(address VAR10, uint256 value) external returns (bool);
function FUN9(address VAR9, uint256 value)
external returns (bool);
function FUN10(address VAR11, address VAR10, uint256 value)
external returns (bool);
event Transfer(
address indexed VAR11,
address indexed VAR10,
uint256 value
);
event FUN11(
address indexed VAR8,
address indexed VAR9,
uint256 value
);
}
contract VAR12 {
using Roles for VAR13.VAR14;
event FUN12(address indexed VAR15);
event FUN13(address indexed VAR15);
VAR13.Role private VAR16;
constructor() internal {
FUN14(msg.sender);
}
modifier FUN15() {
require(FUN16(msg.sender));
VAR17;
}
function FUN16(address VAR15) public view returns (bool) {
return VAR16.FUN17(VAR15);
}
function FUN18(address VAR15) public VAR18 {
FUN14(VAR15);
}
function FUN19() public {
FUN20(msg.sender);
}
function FUN14(address VAR15) internal {
VAR16.FUN4(VAR15);
emit FUN12(VAR15);
}
function FUN20(address VAR15) internal {
VAR16.FUN21(VAR15);
emit FUN13(VAR15);
}
}
contract ERC20 is VAR6 {
using SafeMath for uint256;
mapping (address => uint256) private VAR19;
mapping (address => mapping (address => uint256)) private VAR20;
uint256 private VAR21;
function FUN6() public view returns (uint256) {
return VAR21;
}
function FUN7(address VAR8) public view returns (uint256) {
return VAR19[VAR8];
}
function FUN8(
address VAR8,
address VAR9
)
public
view
returns (uint256)
{
return VAR20[VAR8][VAR9];
}
function transfer(address VAR10, uint256 value) public returns (bool) {
FUN22(msg.sender, VAR10, value);
return true;
}
function FUN9(address VAR9, uint256 value) public returns (bool) {
require(VAR9 != address(0));
VAR20[msg.sender][VAR9] = value;
emit FUN11(msg.sender, VAR9, value);
return true;
}
function FUN10(
address VAR11,
address VAR10,
uint256 value
)
public
returns (bool)
{
require(value <= VAR20[VAR11][msg.sender]);
VAR20[VAR11][msg.sender] = VAR20[VAR11][msg.sender].FUN3(value);
FUN22(VAR11, VAR10, value);
return true;
}
function FUN23(
address VAR9,
uint256 VAR22
)
public
returns (bool)
{
require(VAR9 != address(0));
VAR20[msg.sender][VAR9] = (
VAR20[msg.sender][VAR9].FUN4(VAR22));
emit FUN11(msg.sender, VAR9, VAR20[msg.sender][VAR9]);
return true;
}
function FUN24(
address VAR9,
uint256 VAR23
)
public
returns (bool)
{
require(VAR9 != address(0));
VAR20[msg.sender][VAR9] = (
VAR20[msg.sender][VAR9].FUN3(VAR23));
emit FUN11(msg.sender, VAR9, VAR20[msg.sender][VAR9]);
return true;
}
function FUN22(address VAR11, address VAR10, uint256 value) internal {
require(value <= VAR19[VAR11]);
require(VAR10 != address(0));
VAR19[VAR11] = VAR19[VAR11].FUN3(value);
VAR19[VAR10] = VAR19[VAR10].FUN4(value);
emit Transfer(VAR11, VAR10, value);
}
function FUN25(address VAR15, uint256 value) internal {
require(VAR15 != 0);
VAR21 = VAR21.FUN4(value);
VAR19[VAR15] = VAR19[VAR15].FUN4(value);
emit Transfer(address(0), VAR15, value);
}
function FUN26(address VAR15, uint256 value) internal {
require(VAR15 != 0);
require(value <= VAR19[VAR15]);
VAR21 = VAR21.FUN3(value);
VAR19[VAR15] = VAR19[VAR15].FUN3(value);
emit Transfer(VAR15, address(0), value);
}
function FUN27(address VAR15, uint256 value) internal {
require(value <= VAR20[VAR15][msg.sender]);
VAR20[VAR15][msg.sender] = VAR20[VAR15][msg.sender].FUN3(
value);
FUN26(VAR15, value);
}
}
contract ERC20Burnable is VAR24 {
function FUN28(uint256 value) public {
FUN26(msg.sender, value);
}
function FUN29(address VAR11, uint256 value) public {
FUN27(VAR11, value);
}
}
contract Pausable is VAR12 {
event FUN30(address VAR15);
event FUN31(address VAR15);
bool private VAR25;
constructor() internal {
VAR25 = false;
}
function FUN32() public view returns(bool) {
return VAR25;
}
modifier FUN33() {
require(!VAR25);
VAR17;
}
modifier FUN34() {
require(VAR25);
VAR17;
}
function FUN35() public onlyPauser VAR26 {
VAR25 = true;
emit FUN30(msg.sender);
}
function FUN36() public onlyPauser VAR27 {
VAR25 = false;
emit FUN31(msg.sender);
}
}
contract ERC20Pausable is VAR24, VAR28 {
function transfer(
address VAR10,
uint256 value
)
public
VAR26
returns (bool)
{
return super.transfer(VAR10, value);
}
function FUN10(
address VAR11,
address VAR10,
uint256 value
)
public
VAR26
returns (bool)
{
return super.FUN10(VAR11, VAR10, value);
}
function FUN9(
address VAR9,
uint256 value
)
public
VAR26
returns (bool)
{
return super.FUN9(VAR9, value);
}
function FUN23(
address VAR9,
uint VAR22
)
public
VAR26
returns (bool VAR29)
{
return super.FUN23(VAR9, VAR22);
}
function FUN24(
address VAR9,
uint VAR23
)
public
VAR26
returns (bool VAR29)
{
return super.FUN24(VAR9, VAR23);
}
}
contract GivingToken is VAR24, VAR30, VAR31{
string public constant VAR32 = "";
string public constant VAR33 = "";
uint8 public constant VAR34 = 18;
uint256 public constant VAR35 = 75000000000 * (10 ** uint256(VAR34));
constructor() public {
FUN25(msg.sender, VAR35);
}
}
library VAR13 {
struct VAR14 {
mapping (address => bool) VAR36;
}
function FUN4(Role storage VAR37, address VAR15) internal {
require(VAR15 != address(0));
require(!FUN17(VAR37, VAR15));
VAR37.VAR36[VAR15] = true;
}
function FUN21(Role storage VAR37, address VAR15) internal {
require(VAR15 != address(0));
require(FUN17(VAR37, VAR15));
VAR37.VAR36[VAR15] = false;
}
function FUN17(Role storage VAR37, address VAR15)
internal
view
returns (bool)
{
require(VAR15 != address(0));
return VAR37.VAR36[VAR15];
}
}
0
---------------------------------
429 0x0312855bb6e548578a36fa8de63b8f0d3d7d7dc2.sol
contract VAR1 {
struct VAR2 {
address VAR3;
byte VAR4;
}
VAR2[] public VAR5;
bool public VAR6;
uint public VAR7;
uint public VAR8;
uint public VAR9;
uint public VAR10;
byte public VAR11;
uint VAR12;
address VAR13;
modifier VAR14 { if (msg.sender == VAR13) VAR15 }
function FUN1() {
VAR13 = msg.sender;
VAR7 = 1 VAR16;
VAR9 = 1;
VAR8 = 6;
VAR6 = true;
VAR10 = 0;
}
function FUN2() internal {
bytes32 VAR17 = VAR18.FUN3(VAR12);
VAR11 = FUN4(VAR17);
byte VAR4;
uint8 VAR19;
address[] memory VAR20 = new address[](VAR8);
uint8 VAR21=0;
for(VAR19=0; VAR19 < VAR5.VAR22; VAR19++) {
Player VAR23 = VAR5[VAR19];
if(VAR23.VAR4 < 0x80 && VAR11 < 0x80 || VAR23.VAR4 >= 0x80 && VAR11 >= 0x80) {
VAR20[VAR21++] = VAR23.VAR3;
}
else VAR10 += VAR7;
}
if(VAR21 > 0) {
uint VAR24 = (VAR10 / VAR21) * 99 / 100;
for(VAR19 = 0; VAR19 < VAR21; VAR19++) {
if(!VAR20[VAR19].FUN5(VAR7 + VAR24)) throw;
}
VAR10 = 0;
}
VAR9++;
delete VAR5;
}
function FUN6() internal {
msg.sender.FUN5(msg.value);
}
function FUN7() internal {
if(VAR5.VAR22 >= VAR8) {
if(VAR18.VAR25 > VAR12) FUN2();
else {FUN6(); return;}
}
if(msg.value < VAR7) {
VAR10 += msg.value;
return;
}
if(msg.VAR26.VAR22 < 1) {FUN6();return;}
for(uint8 VAR27 = 0; VAR27 < VAR5.VAR22; VAR27++)
if(msg.sender == VAR5[VAR27].VAR3) {FUN6(); return;}
if(msg.value > VAR7) {
msg.sender.FUN5(msg.value - VAR7);
}
VAR5.FUN8( FUN9(msg.sender, msg.VAR26[0]) );
VAR12 = VAR18.VAR25;
}
function () {
if(VAR6) FUN7();
else throw;
}
function FUN10() onlyowner returns (bool) {
if(VAR5.VAR22 == 0) return true;
if (VAR5[VAR5.VAR22 - 1].VAR3.FUN5(VAR7)) {
VAR5.VAR22--;
return true;
}
return false;
}
function FUN11() onlyowner returns (bool) {
while(VAR5.VAR22 > 0) {if(!FUN10()) return false;}
return true;
}
function FUN12() VAR14 {
uint VAR28 = VAR10;
uint8 VAR19;
for(VAR19=0; VAR19 < VAR5.VAR22; VAR19++) VAR28 += VAR7;
uint VAR29 = this.VAR30 - VAR28;
if(VAR29 > 0) VAR13.FUN5(VAR29);
}
function FUN13(address VAR31) VAR14 {
VAR13 = VAR31;
}
function FUN14(uint VAR32) VAR14 {
if(VAR5.VAR22 > 0) FUN2();
VAR8 = VAR32;
}
function FUN15() VAR14 {
VAR6 = false;
FUN11();
}
function FUN16() constant returns (uint VAR33) {
VAR33 = VAR5.VAR22;
}
function FUN17() VAR14 {
if(!VAR6 && FUN11())
FUN18(VAR13);
}
}
0
---------------------------------
430 0x031532240109b60b97fb732574ec9d80f1032bc5.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29030400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x6469464AF55dcA5afc35D7a0a178340691dF277A;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
431 0x0318179601a70085aeb488f178b081295b65ecc9.sol
contract VAR1 {
address VAR2;
uint public VAR3 = 0;
event FUN1(string VAR4, uint indexed VAR5);
modifier VAR6 { if (msg.sender == VAR2) VAR7 }
function FUN2() public { VAR2 = msg.sender; }
function FUN3() VAR6 { FUN4(VAR2); }
function FUN5() VAR6 {
VAR2.FUN6(this.VAR8);
}
function FUN7(string VAR4, uint VAR5) VAR6 {
VAR3++;
FUN1(VAR4, VAR5);
}
}
0
---------------------------------
432 0x031e8de47dee0fdde1969a93b64bb8f8fbcba65d.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30412800;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 =  0xae09643734a0A0054fB4C1B376Ea95cd2d552dee;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
433 0x03214697869eba6390966dead33a8c6b4bb2f2a3.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30412800;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 =  0x89f835CD00BA2523Cdc32F9588ce11b60416d05e;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
434 0x0324dd195d0cd53f9f07bee6a48ee7a20bad738f.sol
pragma VAR1 ^0.4.21;
contract VAR2{
address public VAR3;
address public VAR4;
event FUN1(address VAR4);
constructor () public{
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR5;
}
function FUN2(address VAR6) public onlyOwner {
VAR4 = VAR6;
emit FUN1(VAR6);
}
function () payable public {
address VAR7 = VAR4;
require(VAR7 != address(0));
VAR8 {
let VAR9 := FUN3(0x40)
FUN4(VAR9, 0, VAR10)
let VAR11 := FUN5(VAR12, VAR7, VAR9, VAR10, 0, 0)
let VAR13 := VAR14
FUN6(VAR9, 0, VAR13)
switch VAR11
case 0 { revert(VAR9, VAR13) }
default { return(VAR9, VAR13) }
}
}
}
0
---------------------------------
435 0x032747313c4e914b5fce356ab8dc4df551972dcd.sol
//
//
//
//
//
contract VAR1 {
struct Transaction {
uint VAR2;
uint VAR3;
address VAR4;
bool VAR5;
uint VAR6;
string VAR7;
bool VAR8;
}
struct VAR9 {
address VAR10;
uint[] VAR11;
uint[] VAR12;
uint VAR13;
uint VAR14;
uint VAR15;
}
Transaction[] public VAR16;
VAR9[] public VAR17;
mapping (address => uint) VAR18;
address public VAR19;
uint public VAR20;
uint public VAR21;
modifier VAR22 { if (msg.sender == VAR19) VAR23 }
function FUN1() {
VAR19 = msg.sender;
VAR17.VAR24 = 1;
VAR16.VAR24 = 1;
VAR20 = 1 VAR25;
VAR21 = 50 VAR26;
}
function FUN2() VAR22 {
VAR19.FUN3(this.VAR27);
}
function FUN4(uint VAR28) VAR22 {
VAR20 = VAR28;
}
function FUN5(uint VAR28) VAR22 {
VAR21 = VAR28;
}
function FUN6(address VAR29) VAR22 {
VAR19 = VAR29;
}
function() {
throw;
}
function FUN7() {
return;
}
function FUN8() {
uint VAR30 = msg.value;
if(VAR30 < VAR20) { throw; }
uint VAR2 = VAR17.VAR24;
VAR17.VAR24 += 1;
VAR17[VAR2].VAR10 = msg.sender;
VAR17[VAR2].VAR13 = 0;
VAR18[msg.sender] = VAR2;
}
function FUN9(uint VAR3) {
uint VAR2 = VAR18[msg.sender];
if(VAR2 == 0) { throw; }
uint VAR31 = VAR16.VAR24;
VAR16.VAR24 += 1;
VAR16[VAR31].VAR2 = VAR2;
VAR16[VAR31].VAR3 = VAR3;
}
function FUN10(uint VAR31) {
if(VAR31 < 1 || VAR31 >= VAR16.VAR24) { throw; }
uint VAR30 = msg.value;
uint VAR32 = VAR16[VAR31].VAR3;
uint VAR33 = VAR32 + VAR21;
if(VAR30 < VAR33) { throw; }
uint VAR34 = VAR30 - VAR33;
msg.sender.FUN3(VAR34);
VAR17[VAR16[VAR31].VAR2].VAR10.FUN3(VAR32);
VAR17[VAR16[VAR31].VAR2].VAR14 += 1;
VAR16[VAR31].VAR5 = true;
VAR16[VAR31].VAR4 = msg.sender;
}
function FUN11(uint VAR31, uint VAR6, string VAR7) {
if(VAR16[VAR31].VAR4 != msg.sender) { throw; }
if(VAR31 < 1 || VAR31 >= VAR16.VAR24) { throw; }
if(VAR16[VAR31].VAR8) { throw; }
if(!VAR16[VAR31].VAR5) { throw; }
if(VAR6 < 1 || VAR6 > 10) { throw; }
VAR16[VAR31].VAR6 = VAR6;
VAR16[VAR31].VAR7 = VAR7;
VAR16[VAR31].VAR8 = true;
uint VAR35 = VAR17[VAR16[VAR31].VAR2].VAR15;
uint VAR36 = VAR17[VAR16[VAR31].VAR2].VAR13 * VAR35;
VAR17[VAR16[VAR31].VAR2].VAR13 = (VAR36 + VAR6) / (VAR35 + 1);
VAR17[VAR16[VAR31].VAR2].VAR15 += 1;
}
}
0
---------------------------------
436 0x032ef0359eb068d3dddd6e91021c02f397afce5a.sol
pragma VAR1 ^0.4.24;
pragma experimental VAR2;
//
//
//
contract VAR3 {
function FUN1() public constant returns (uint);
function FUN2(address VAR4) public constant returns (uint VAR5);
function FUN3(address VAR4, address VAR6) public constant returns (uint VAR7);
function transfer(address VAR8, uint VAR9) public returns (bool VAR10);
function FUN4(address VAR6, uint VAR9) public returns (bool VAR10);
function FUN5(address VAR11, address VAR8, uint VAR9) public returns (bool VAR10);
event Transfer(address indexed VAR11, address indexed VAR8, uint VAR9);
event FUN6(address indexed VAR4, address indexed VAR6, uint VAR9);
}
contract VAR12 {
address public VAR13;
address public VAR14;
event FUN7(address indexed VAR15, address indexed VAR16);
modifier onlyOwner {
require(msg.sender == VAR13);
VAR17;
}
function FUN8() public {
VAR13 = msg.sender;
}
function FUN9(address VAR18) public onlyOwner {
VAR14 = VAR18;
}
function FUN10() public {
require(msg.sender == VAR14);
FUN7(VAR13, VAR14);
VAR13 = VAR14;
VAR14 = 0x0;
}
}
contract Admined is VAR12 {
mapping (address => bool) public VAR19;
event FUN11(address VAR20);
event FUN12(address VAR20);
modifier onlyAdmin() {
require(FUN13(msg.sender));
VAR17;
}
function FUN13(address VAR20) public constant returns (bool) {
return (VAR19[VAR20] || VAR13 == VAR20);
}
function FUN14(address VAR20) public onlyOwner {
require(!VAR19[VAR20] && VAR20 != VAR13);
VAR19[VAR20] = true;
FUN11(VAR20);
}
function FUN15(address VAR20) public onlyOwner {
require(VAR19[VAR20]);
delete VAR19[VAR20];
FUN12(VAR20);
}
}
contract DeveryRegistry is VAR21 {
struct VAR22 {
address VAR23;
string VAR24;
address VAR25;
uint VAR26;
bool VAR27;
}
struct VAR28 {
address VAR29;
address VAR23;
string VAR30;
bool VAR27;
}
struct VAR31 {
address VAR32;
address VAR29;
string VAR33;
string VAR34;
uint VAR35;
string VAR36;
bool VAR27;
}
ERC20Interface public VAR37;
address public VAR25;
uint public VAR26;
mapping(address => VAR22) public VAR38;
mapping(address => VAR28) public VAR39;
mapping(address => VAR31) public VAR40;
mapping(address => mapping(address => bool)) VAR41;
mapping(bytes32 => address) VAR42;
address[] public VAR43;
address[] public VAR44;
address[] public VAR45;
event FUN16(address indexed VAR46, address indexed VAR47);
event FUN17(address indexed VAR48, address indexed VAR49, uint VAR50, uint VAR51);
event FUN18(address indexed VAR23, string VAR24, address VAR25, uint VAR26, bool VAR27);
event FUN19(address indexed VAR23, string VAR24, address VAR25, uint VAR26, bool VAR27);
event FUN20(address indexed VAR29, address indexed VAR23, string VAR30, bool VAR27);
event FUN21(address indexed VAR29, address indexed VAR23, string VAR30, bool VAR27);
event FUN22(address indexed VAR32, address indexed VAR29, address indexed VAR23, string VAR33, bool VAR27);
event FUN23(address indexed VAR32, address indexed VAR29, address indexed VAR23, string VAR33, bool VAR27);
event FUN24(address indexed VAR52, address indexed VAR29, bool VAR53);
event FUN25(address indexed VAR52, address indexed VAR32, address VAR54, address VAR25, uint VAR55, uint VAR26, bytes32 VAR56);
function FUN26(address VAR57) public onlyAdmin {
FUN16(address(VAR37), VAR57);
VAR37 = FUN27(VAR57);
}
function FUN28(address VAR58, uint VAR59) public onlyAdmin {
FUN17(VAR25, VAR58, VAR26, VAR59);
VAR25 = VAR58;
VAR26 = VAR59;
}
function FUN29(string VAR24, address VAR58, uint VAR59) public {
App storage VAR60 = VAR38[msg.sender];
require(VAR60.VAR23 == address(0));
VAR38[msg.sender] = FUN30({
VAR23: msg.sender,
VAR24: VAR24,
VAR25: VAR58,
VAR26: VAR59,
VAR27: true
});
VAR43.FUN31(msg.sender);
FUN18(msg.sender, VAR24, VAR58, VAR59, true);
}
function FUN32(string VAR24, address VAR58, uint VAR59, bool VAR27) public {
App storage VAR60 = VAR38[msg.sender];
require(msg.sender == VAR60.VAR23);
VAR60.VAR24 = VAR24;
VAR60.VAR25 = VAR58;
VAR60.VAR26 = VAR59;
VAR60.VAR27 = VAR27;
FUN19(msg.sender, VAR24, VAR58, VAR59, VAR27);
}
function FUN33(address VAR23) public constant returns (App VAR61) {
VAR61 = VAR38[VAR23];
}
function FUN34(address VAR23) public constant returns (address VAR58, uint VAR59, bool VAR27) {
App storage VAR60 = VAR38[VAR23];
VAR58 = VAR60.VAR25;
VAR59 = VAR60.VAR26;
VAR27 = VAR60.VAR27;
}
function FUN35() public constant returns (uint) {
return VAR43.VAR62;
}
function FUN36(address VAR29, string VAR30) public {
App storage VAR61 = VAR38[msg.sender];
require(VAR61.VAR23 != address(0));
Brand storage VAR63 = VAR39[VAR29];
require(VAR63.VAR29 == address(0));
VAR39[VAR29] = FUN37({
VAR29: VAR29,
VAR23: msg.sender,
VAR30: VAR30,
VAR27: true
});
VAR44.FUN31(VAR29);
FUN20(VAR29, msg.sender, VAR30, true);
}
function FUN38(address VAR29, string VAR30, bool VAR27) public {
Brand storage VAR63 = VAR39[VAR29];
require(VAR63.VAR23 == msg.sender);
VAR63.VAR30 = VAR30;
VAR63.VAR27 = VAR27;
FUN21(VAR29, msg.sender, VAR30, VAR27);
}
function FUN39(address VAR29) public constant returns (Brand VAR63) {
VAR63 = VAR39[VAR29];
}
function FUN40(address VAR29) public constant returns (address VAR23, address VAR54, bool VAR27) {
Brand storage VAR63 = VAR39[VAR29];
require(VAR63.VAR23 != address(0));
App storage VAR61 = VAR38[VAR63.VAR23];
require(VAR61.VAR23 != address(0));
VAR23 = VAR61.VAR23;
VAR54 = VAR61.VAR25;
VAR27 = VAR61.VAR27 && VAR63.VAR27;
}
function FUN41() public constant returns (uint) {
return VAR44.VAR62;
}
function FUN42(address VAR32, string VAR33, string VAR34, uint VAR35, string VAR36) public {
Brand storage VAR63 = VAR39[msg.sender];
require(VAR63.VAR29 != address(0));
App storage VAR61 = VAR38[VAR63.VAR23];
require(VAR61.VAR23 != address(0));
Product storage VAR64 = VAR40[VAR32];
require(VAR64.VAR32 == address(0));
VAR40[VAR32] = FUN43({
VAR32: VAR32,
VAR29: msg.sender,
VAR33: VAR33,
VAR34: VAR34,
VAR35: VAR35,
VAR36: VAR36,
VAR27: true
});
VAR45.FUN31(VAR32);
FUN22(VAR32, msg.sender, VAR61.VAR23, VAR33, true);
}
function FUN44(address VAR32, string VAR33, string VAR34, uint VAR35, string VAR36, bool VAR27) public {
Product storage VAR64 = VAR40[VAR32];
require(VAR64.VAR29 == msg.sender);
Brand storage VAR63 = VAR39[msg.sender];
require(VAR63.VAR29 == msg.sender);
App storage VAR61 = VAR38[VAR63.VAR23];
VAR64.VAR33 = VAR33;
VAR64.VAR34 = VAR34;
VAR64.VAR35 = VAR35;
VAR64.VAR36 = VAR36;
VAR64.VAR27 = VAR27;
FUN23(VAR32, VAR64.VAR29, VAR61.VAR23, VAR33, VAR27);
}
function FUN45(address VAR32) public constant returns (Product VAR64) {
VAR64 = VAR40[VAR32];
}
function FUN46(address VAR32) public constant returns (address VAR29, address VAR23, address VAR54, bool VAR27) {
Product storage VAR64 = VAR40[VAR32];
require(VAR64.VAR29 != address(0));
Brand storage VAR63 = VAR39[VAR29];
require(VAR63.VAR23 != address(0));
App storage VAR61 = VAR38[VAR63.VAR23];
require(VAR61.VAR23 != address(0));
VAR29 = VAR64.VAR29;
VAR23 = VAR61.VAR23;
VAR54 = VAR61.VAR25;
VAR27 = VAR61.VAR27 && VAR63.VAR27 && VAR63.VAR27;
}
function FUN47() public constant returns (uint) {
return VAR45.VAR62;
}
function FUN48(address VAR52, bool VAR53) public {
Brand storage VAR63 = VAR39[msg.sender];
require(VAR63.VAR29 != address(0));
VAR41[VAR52][msg.sender] = VAR53;
FUN24(VAR52, msg.sender, VAR53);
}
function FUN49(address VAR65) public pure returns (bytes32 VAR66) {
VAR66 = FUN50(VAR65);
}
function FUN51(address VAR32, bytes32 VAR56) public {
Product storage VAR64 = VAR40[VAR32];
require(VAR64.VAR29 != address(0) && VAR64.VAR27);
Brand storage VAR63 = VAR39[VAR64.VAR29];
require(VAR63.VAR29 != address(0) && VAR63.VAR27);
App storage VAR61 = VAR38[VAR63.VAR23];
require(VAR61.VAR23 != address(0) && VAR61.VAR27);
bool VAR67 = VAR41[msg.sender][VAR63.VAR29];
require(VAR67);
VAR42[VAR56] = VAR32;
FUN25(msg.sender, VAR32, VAR61.VAR25, VAR25, VAR61.VAR26, VAR26, VAR56);
if (VAR61.VAR26 > 0) {
VAR37.FUN5(VAR63.VAR29, VAR61.VAR25, VAR61.VAR26);
}
if (VAR26 > 0) {
VAR37.FUN5(VAR63.VAR29, VAR25, VAR26);
}
}
function FUN52(address VAR65) public constant returns (address VAR32, address VAR29, address VAR23) {
bytes32 VAR66 = FUN50(VAR65);
VAR32 = VAR42[VAR66];
Product storage VAR64 = VAR40[VAR32];
Brand storage VAR63 = VAR39[VAR64.VAR29];
VAR29 = VAR64.VAR29;
VAR23 = VAR63.VAR23;
}
}
library VAR68 {
function FUN53(uint256 VAR69, uint256 VAR70) internal pure returns (uint256) {
if (VAR69 == 0) {
return 0;
}
uint256 VAR71 = VAR69 * VAR70;
require(VAR71 / VAR69 == VAR70);
return VAR71;
}
function FUN54(uint256 VAR69, uint256 VAR70) internal pure returns (uint256) {
require(VAR70 > 0);
uint256 VAR71 = VAR69 / VAR70;
return VAR71;
}
function FUN55(uint256 VAR69, uint256 VAR70) internal pure returns (uint256) {
require(VAR70 <= VAR69);
uint256 VAR71 = VAR69 - VAR70;
return VAR71;
}
function FUN56(uint256 VAR69, uint256 VAR70) internal pure returns (uint256) {
uint256 VAR71 = VAR69 + VAR70;
require(VAR71 >= VAR69);
return VAR71;
}
function FUN57(uint256 VAR69, uint256 VAR70) internal pure returns (uint256) {
require(VAR70 != 0);
return VAR69 % VAR70;
}
}
contract VAR72 {
bytes4 private constant VAR73 = 0x01ffc9a7;
mapping(bytes4 => bool) private VAR74;
constructor () internal {
FUN58(VAR73);
}
function FUN59(bytes4 VAR75) external view returns (bool) {
return VAR74[VAR75];
}
function FUN58(bytes4 VAR75) internal {
require(VAR75 != 0xffffffff);
VAR74[VAR75] = true;
}
}
contract VAR76 {
function FUN60(address VAR77, address VAR11, uint256 VAR78, bytes VAR79) public returns (bytes4);
}
library VAR80 {
function FUN61(address VAR81) internal view returns (bool) {
uint256 VAR82;
VAR83 { VAR82 := FUN62(VAR81) }
return VAR82 > 0;
}
}
contract VAR84 {
function FUN1() public view returns (uint256);
function FUN63(address VAR13, uint256 VAR85) public view returns (uint256 VAR78);
function FUN64(uint256 VAR85) public view returns (uint256);
}
library VAR86 {
using SafeMath for uint256;
struct VAR87 {
uint256 VAR88;
}
function FUN65(Counter storage VAR89) internal view returns (uint256) {
return VAR89.VAR88;
}
function FUN66(Counter storage VAR89) internal {
VAR89.VAR88 += 1;
}
function FUN67(Counter storage VAR89) internal {
VAR89.VAR88 = VAR89.VAR88.FUN55(1);
}
}
contract ERC721 is VAR72 {
event Transfer(address indexed VAR11, address indexed VAR8, uint256 indexed VAR78);
event FUN6(address indexed VAR13, address indexed VAR90, uint256 indexed VAR78);
event FUN68(address indexed VAR13, address indexed VAR77, bool VAR90);
using SafeMath for uint256;
using Address for address;
using Counters for VAR86.VAR87;
bytes4 private constant VAR91 = 0x150b7a02;
mapping (uint256 => address) private VAR92;
mapping (uint256 => address) private VAR93;
mapping (address => VAR86.VAR87) private VAR94;
mapping (address => mapping (address => bool)) private VAR95;
bytes4 private constant VAR96 = 0x80ac58cd;
constructor () public {
FUN58(VAR96);
}
function FUN2(address VAR13) public view returns (uint256) {
require(VAR13 != address(0), "");
return VAR94[VAR13].FUN65();
}
function FUN69(uint256 VAR78) public view returns (address) {
address VAR13 = VAR92[VAR78];
require(VAR13 != address(0), "");
return VAR13;
}
function FUN4(address VAR8, uint256 VAR78) public {
address VAR13 = FUN69(VAR78);
require(VAR8 != VAR13, "");
require(msg.sender == VAR13 || FUN70(VAR13, msg.sender),
""
);
VAR93[VAR78] = VAR8;
emit FUN6(VAR13, VAR8, VAR78);
}
function FUN71(uint256 VAR78) public view returns (address) {
require(FUN72(VAR78), "");
return VAR93[VAR78];
}
function FUN73(address VAR8, bool VAR90) public {
require(VAR8 != msg.sender, "");
VAR95[msg.sender][VAR8] = VAR90;
emit FUN68(msg.sender, VAR8, VAR90);
}
function FUN70(address VAR13, address VAR77) public view returns (bool) {
return VAR95[VAR13][VAR77];
}
function FUN5(address VAR11, address VAR8, uint256 VAR78) public {
require(FUN74(msg.sender, VAR78), "");
FUN75(VAR11, VAR8, VAR78);
}
function FUN76(address VAR11, address VAR8, uint256 VAR78) public {
FUN76(VAR11, VAR8, VAR78, "");
}
function FUN76(address VAR11, address VAR8, uint256 VAR78, bytes memory VAR97) public {
FUN5(VAR11, VAR8, VAR78);
require(FUN77(VAR11, VAR8, VAR78, VAR97), "");
}
function FUN72(uint256 VAR78) internal view returns (bool) {
address VAR13 = VAR92[VAR78];
return VAR13 != address(0);
}
function FUN74(address VAR6, uint256 VAR78) internal view returns (bool) {
require(FUN72(VAR78), "");
address VAR13 = FUN69(VAR78);
return (VAR6 == VAR13 || FUN71(VAR78) == VAR6 || FUN70(VAR13, VAR6));
}
function FUN78(address VAR8, uint256 VAR78) internal {
require(VAR8 != address(0), "");
require(!FUN72(VAR78), "");
VAR92[VAR78] = VAR8;
VAR94[VAR8].FUN66();
emit Transfer(address(0), VAR8, VAR78);
}
function FUN79(address VAR13, uint256 VAR78) internal {
require(FUN69(VAR78) == VAR13, "");
FUN80(VAR78);
VAR94[VAR13].FUN67();
VAR92[VAR78] = address(0);
emit Transfer(VAR13, address(0), VAR78);
}
function FUN79(uint256 VAR78) internal {
FUN79(FUN69(VAR78), VAR78);
}
function FUN75(address VAR11, address VAR8, uint256 VAR78) internal {
require(FUN69(VAR78) == VAR11, "");
require(VAR8 != address(0), "");
FUN80(VAR78);
VAR94[VAR11].FUN67();
VAR94[VAR8].FUN66();
VAR92[VAR78] = VAR8;
emit Transfer(VAR11, VAR8, VAR78);
}
function FUN77(address VAR11, address VAR8, uint256 VAR78, bytes memory VAR97)
internal returns (bool)
{
if (!VAR8.FUN61()) {
return true;
}
bytes4 VAR98 = FUN81(VAR8).FUN60(msg.sender, VAR11, VAR78, VAR97);
return (VAR98 == VAR91);
}
function FUN80(uint256 VAR78) private {
if (VAR93[VAR78] != address(0)) {
VAR93[VAR78] = address(0);
}
}
}
contract ERC721Enumerable is VAR72, VAR99, VAR84 {
mapping(address => uint256[]) private VAR100;
mapping(uint256 => uint256) private VAR101;
uint256[] private VAR102;
mapping(uint256 => uint256) private VAR103;
bytes4 private constant VAR104 = 0x780e9d63;
constructor () public {
FUN58(VAR104);
}
function FUN63(address VAR13, uint256 VAR85) public view returns (uint256) {
require(VAR85 < FUN2(VAR13), "");
return VAR100[VAR13][VAR85];
}
function FUN1() public view returns (uint256) {
return VAR102.VAR62;
}
function FUN64(uint256 VAR85) public view returns (uint256) {
require(VAR85 < FUN1(), "");
return VAR102[VAR85];
}
function FUN75(address VAR11, address VAR8, uint256 VAR78) internal {
super.FUN75(VAR11, VAR8, VAR78);
FUN82(VAR11, VAR78);
FUN83(VAR8, VAR78);
}
function FUN78(address VAR8, uint256 VAR78) internal {
super.FUN78(VAR8, VAR78);
FUN83(VAR8, VAR78);
FUN84(VAR78);
}
function FUN79(address VAR13, uint256 VAR78) internal {
super.FUN79(VAR13, VAR78);
FUN82(VAR13, VAR78);
VAR101[VAR78] = 0;
FUN85(VAR78);
}
function FUN86(address VAR13) internal view returns (uint256[] VAR105) {
return VAR100[VAR13];
}
function FUN83(address VAR8, uint256 VAR78) private {
VAR101[VAR78] = VAR100[VAR8].VAR62;
VAR100[VAR8].FUN31(VAR78);
}
function FUN84(uint256 VAR78) private {
VAR103[VAR78] = VAR102.VAR62;
VAR102.FUN31(VAR78);
}
function FUN82(address VAR11, uint256 VAR78) private {
uint256 VAR106 = VAR100[VAR11].VAR62.FUN55(1);
uint256 VAR107 = VAR101[VAR78];
if (VAR107 != VAR106) {
uint256 VAR108 = VAR100[VAR11][VAR106];
VAR100[VAR11][VAR107] = VAR108;
VAR101[VAR108] = VAR107;
}
VAR100[VAR11].VAR62--;
}
function FUN85(uint256 VAR78) private {
uint256 VAR106 = VAR102.VAR62.FUN55(1);
uint256 VAR107 = VAR103[VAR78];
uint256 VAR108 = VAR102[VAR106];
VAR102[VAR107] = VAR108;
VAR103[VAR108] = VAR107;
VAR102.VAR62--;
VAR103[VAR78] = 0;
}
}
contract DeveryERC721Token is VAR109,VAR21 {
address[] public VAR110;
mapping(address => uint) public VAR111;
mapping(address => uint) public VAR112;
DeveryRegistry VAR113;
ERC20Interface public VAR37;
event FUN16(address indexed VAR46, address indexed VAR47);
function FUN26(address VAR57) public onlyAdmin {
FUN16(address(VAR37), VAR57);
VAR37 = FUN27(VAR57);
}
modifier FUN87(address VAR114){
address VAR115;
(,VAR115,,,,,) = VAR113.FUN88(VAR114);
require(VAR115 == msg.sender);
VAR17;
}
function FUN89(address VAR116) external onlyAdmin {
VAR113 = FUN90(VAR116);
}
function FUN91(address VAR114, uint VAR117) external payable FUN87(VAR114){
require(VAR117 >= VAR112[VAR114] || VAR117 == 0);
VAR111[VAR114] = VAR117;
}
function FUN92(address VAR114,uint VAR117) external payable  FUN87(VAR114) {
require(VAR111[VAR114] == 0 || VAR111[VAR114] >= VAR112[VAR114] + VAR117);
address VAR115;
address VAR118;
address VAR54;
address VAR119;
uint VAR55;
uint VAR120;
(,VAR115,,,,,) = VAR113.FUN88(VAR114);
(,VAR118,,) = VAR113.FUN93(VAR115);
(,,VAR54,VAR55,) = VAR113.FUN94(VAR118);
VAR120 = VAR113.FUN95();
VAR119 = VAR113.FUN96();
if (VAR55 > 0) {
VAR37.FUN5(VAR115, VAR54, VAR55*VAR117);
}
if (VAR120 > 0) {
VAR37.FUN5(VAR115, VAR119, VAR120*VAR117);
}
for(uint VAR121 = 0;VAR121<VAR117;VAR121++){
uint VAR122 = VAR110.FUN31(VAR114) - 1;
FUN78(msg.sender,VAR122);
}
VAR112[VAR114]+=VAR117;
}
function FUN97(address VAR123) external view returns (address[]){
address[] memory VAR40 = new address[](FUN2(VAR123));
uint VAR89 = 0;
for(uint VAR121 = 0; VAR121 < VAR110.VAR62;VAR121++){
if(FUN69(VAR121) == VAR123){
VAR40[VAR89] = VAR110[VAR121];
VAR89++;
}
}
return VAR40;
}
}
0
---------------------------------
437 0x03452e69ffcd9c45ca34ff4d9ba2209d38a8d56a.sol
pragma solidity 0.5.1;
library VAR1 {
uint256 constant internal VAR2 = 2 ** 256 - 1;
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
if (VAR3 == 0) {
return 0;
}
require(VAR2 / VAR3 >= VAR4);
return VAR3 * VAR4;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
require(VAR4 != 0);
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
require(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
require(VAR2 - VAR3 >= VAR4);
return VAR3 + VAR4;
}
}
contract VAR5 {
address public VAR6;
event FUN5(
address indexed VAR7,
address indexed VAR8
);
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR9;
}
function FUN6(address VAR10) public onlyOwner {
FUN7(VAR10);
}
function FUN7(address VAR10) internal {
require(VAR10 != address(0));
emit FUN5(VAR6, VAR10);
VAR6 = VAR10;
}
}
contract Pausable is VAR5 {
event FUN8();
event FUN9();
bool public VAR11 = false;
modifier FUN10() {
require(!VAR11);
VAR9;
}
modifier FUN11() {
require(VAR11);
VAR9;
}
function FUN12() public onlyOwner VAR12 {
VAR11 = true;
emit FUN8();
}
function FUN13() public onlyOwner VAR13 {
VAR11 = false;
emit FUN9();
}
}
contract VAR14 {
using SafeMath for uint256;
mapping(address => uint256) internal VAR15;
mapping(address => mapping(address => uint256)) internal VAR16;
uint256 internal VAR17;
event Transfer(
address indexed VAR18,
address indexed VAR19,
uint256 value
);
event FUN14(
address indexed VAR6,
address indexed VAR20,
uint256 value
);
function FUN15() public view returns(uint256) {
return VAR17;
}
function FUN16(address VAR21) public view returns(uint256) {
return VAR15[VAR21];
}
function FUN17(
address VAR21,
address VAR22
)
public
view
returns(uint256) {
return VAR16[VAR21][VAR22];
}
function transfer(address VAR23, uint256 VAR24) public returns(bool) {
require(VAR23 != address(0));
require(VAR24 <= VAR15[msg.sender]);
VAR15[msg.sender] = VAR15[msg.sender].FUN3(VAR24);
VAR15[VAR23] = VAR15[VAR23].FUN4(VAR24);
emit Transfer(msg.sender, VAR23, VAR24);
return true;
}
function FUN18(address VAR22, uint256 VAR24) public returns(bool) {
VAR16[msg.sender][VAR22] = VAR24;
emit FUN14(msg.sender, VAR22, VAR24);
return true;
}
function FUN19(
address VAR25,
address VAR23,
uint256 VAR24
)
public
returns(bool) {
require(VAR23 != address(0));
require(VAR24 <= VAR15[VAR25]);
require(VAR24 <= VAR16[VAR25][msg.sender]);
VAR15[VAR25] = VAR15[VAR25].FUN3(VAR24);
VAR15[VAR23] = VAR15[VAR23].FUN4(VAR24);
VAR16[VAR25][msg.sender] = VAR16[VAR25][msg.sender].FUN3(VAR24);
emit Transfer(VAR25, VAR23, VAR24);
return true;
}
function FUN20(
address VAR22,
uint256 VAR26
)
public
returns(bool) {
VAR16[msg.sender][VAR22] = VAR16[msg.sender][VAR22].FUN4(VAR26);
emit FUN14(msg.sender, VAR22, VAR16[msg.sender][VAR22]);
return true;
}
function FUN21(
address VAR22,
uint256 VAR27
)
public
returns(bool) {
uint256 VAR28 = VAR16[msg.sender][VAR22];
if (VAR27 >= VAR28) {
VAR16[msg.sender][VAR22] = 0;
} else {
VAR16[msg.sender][VAR22] = VAR28.FUN3(VAR27);
}
emit FUN14(msg.sender, VAR22, VAR16[msg.sender][VAR22]);
return true;
}
}
contract BurnableToken is VAR14 {
event FUN22(address indexed VAR29, uint256 value);
function FUN23(uint256 value) public {
require(VAR15[msg.sender] >= value);
VAR17 = VAR17.FUN3(value);
VAR15[msg.sender] = VAR15[msg.sender].FUN3(value);
emit FUN22(msg.sender, value);
emit Transfer(msg.sender, address(0), value);
}
function FUN24(address VAR29, uint256 value) public {
require(VAR29 != address(0));
require(VAR15[VAR29] >= value);
require(VAR16[VAR29][msg.sender] >= value);
VAR17 = VAR17.FUN3(value);
VAR15[VAR29] = VAR15[VAR29].FUN3(value);
VAR16[VAR29][msg.sender] = VAR16[VAR29][msg.sender].FUN3(value);
emit FUN22(VAR29, value);
emit Transfer(VAR29, address(0), value);
}
}
contract PausableToken is VAR14, VAR30 {
function transfer(
address VAR23,
uint256 VAR24
)
public
VAR12
returns(bool) {
return super.transfer(VAR23, VAR24);
}
function FUN19(
address VAR25,
address VAR23,
uint256 VAR24
)
public
VAR12
returns(bool) {
return super.FUN19(VAR25, VAR23, VAR24);
}
function FUN18(
address VAR22,
uint256 VAR24
)
public
VAR12
returns(bool) {
return super.FUN18(VAR22, VAR24);
}
function FUN20(
address VAR22,
uint VAR26
)
public
VAR12
returns(bool VAR31) {
return super.FUN20(VAR22, VAR26);
}
function FUN21(
address VAR22,
uint VAR27
)
public
VAR12
returns(bool VAR31) {
return super.FUN21(VAR22, VAR27);
}
}
contract VESTELLAToken is VAR32, VAR33 {
using SafeMath for uint256;
string public constant VAR34 = "";
string public constant VAR35 = "";
uint8 public constant VAR36 = 18;
uint256 constant VAR37 = 15000000000;
mapping (address => uint256[]) internal VAR38;
mapping (address => uint256[]) internal VAR39;
event FUN25(address indexed VAR29, uint256 VAR40, uint256 VAR41);
constructor() public {
VAR17 = VAR37 * 10 ** uint256(VAR36);
VAR6 = 0x0F1b590cD3155571C8680B363867e20b8E4303bE;
VAR15[VAR6] = VAR17;
}
function FUN26(address VAR29, uint256[] memory VAR40, uint256[] memory VAR41) public onlyOwner returns(bool) {
require(VAR29 != address(0));
require(VAR40.VAR42 == VAR41.VAR42);
uint256 VAR43 = 0;
for(uint VAR44 = 0; VAR44 < VAR40.VAR42; VAR44++) {
uint256 VAR45 = VAR40[VAR44] * 10 ** uint256(VAR36);
require(VAR41[VAR44] > VAR46);
VAR38[VAR29].FUN27(VAR41[VAR44]);
VAR39[VAR29].FUN27(VAR45);
emit FUN25(VAR29, VAR45, VAR41[VAR44]);
VAR43 = VAR43.FUN4(VAR45);
}
require(VAR15[msg.sender] >= VAR43);
VAR15[VAR29] = VAR15[VAR29].FUN4(VAR43);
VAR15[msg.sender] = VAR15[msg.sender].FUN3(VAR43);
emit Transfer(msg.sender, VAR29, VAR43);
return true;
}
function FUN28(address VAR29) public view returns(uint256[] memory VAR47, uint256[] memory VAR43) {
return (VAR38[VAR29], VAR39[VAR29]);
}
function FUN29(address VAR29) public view returns(uint256 VAR48) {
uint256 VAR49 = 0;
uint256 VAR50 = 0;
for(uint VAR44 = 0; VAR44 < VAR38[VAR29].VAR42; VAR44++) {
if(VAR46 < VAR38[VAR29][VAR44]) {
VAR49 = VAR39[VAR29][VAR44];
VAR50 = VAR50.FUN4(VAR49);
}
}
return VAR50;
}
function transfer(
address VAR23,
uint256 VAR24
)
public
returns(bool) {
require(VAR15[msg.sender].FUN3(VAR24) >= FUN29(msg.sender));
return super.transfer(VAR23, VAR24);
}
function FUN19(
address VAR25,
address VAR23,
uint256 VAR24
)
public
returns(bool) {
require(VAR15[VAR25].FUN3(VAR24) >= FUN29(VAR25));
return super.FUN19(VAR25, VAR23, VAR24);
}
function FUN23(uint256 value) public {
require(VAR15[msg.sender].FUN3(value) >= FUN29(msg.sender));
super.FUN23(value);
}
function FUN24(address VAR29, uint256 value) public {
require(VAR15[VAR29].FUN3(value) >= FUN29(VAR29));
super.FUN24(VAR29, value);
}
function FUN30(address[] memory VAR23, uint256[] memory VAR45) internal VAR12 {
require(VAR23.VAR42 == VAR45.VAR42);
uint256 VAR51 = 0;
for(uint VAR44 = 0;VAR44 < VAR23.VAR42;VAR44 += 1){
require(VAR23[VAR44] != address(0));
VAR51 = VAR51.FUN4(VAR45[VAR44]);
require(VAR51 <= VAR15[msg.sender]);
VAR15[VAR23[VAR44]] = VAR15[VAR23[VAR44]].FUN4(VAR45[VAR44]);
emit Transfer(msg.sender, VAR23[VAR44], VAR45[VAR44]);
}
VAR15[msg.sender] = VAR15[msg.sender].FUN3(VAR51);
}
function FUN31(address[] memory VAR23, uint256[] memory VAR45) public onlyOwner returns(bool){
FUN30(VAR23, VAR45);
return true;
}
}
0
---------------------------------
438 0x034f8165470b0a26b8daac1c3cd1cc6156e8294d.sol
pragma VAR1 >=0.5.4 <0.6.0;
//
//
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
function FUN5() public view returns (uint);
function FUN6(address VAR7) public view returns (uint VAR8);
function FUN7(address VAR7, address VAR9) public view returns (uint VAR10);
function transfer(address VAR11, uint VAR12) public returns (bool VAR13);
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13);
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13);
function FUN10(uint256 value) public returns (bool VAR13);
function FUN11(address VAR14, uint256 value) public returns (bool VAR13);
function FUN12(address VAR15, uint256 value) public returns (bool VAR13);
event Transfer(address indexed VAR14, address indexed VAR11, uint VAR12);
event FUN13(address indexed VAR7, address indexed VAR9, uint VAR12);
event FUN14(address indexed VAR14, uint256 value);
}
//
contract VAR16 {
function FUN15(address VAR14, uint256 VAR12, address VAR17, bytes memory VAR18) public;
}
contract VAR19 {
address public VAR20;
address public VAR21;
event FUN16(address indexed VAR22, address indexed VAR23);
constructor() public {
VAR20 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR20);
VAR24;
}
function FUN17(address VAR25) public onlyOwner {
VAR21 = VAR25;
}
function FUN18() public {
require(msg.sender == VAR21);
emit FUN16(VAR20, VAR21);
VAR20 = VAR21;
VAR21 = address(0);
}
}
contract EracoinToken is VAR6, VAR19 {
using SafeMath for uint;
string public VAR26;
string public  VAR27;
uint8 public VAR28;
uint VAR29;
mapping(address => uint) VAR30;
mapping(address => mapping(address => uint)) VAR31;
event Transfer(address indexed VAR14, address indexed VAR11, uint VAR12);
event FUN13(address indexed VAR7, address indexed VAR9, uint VAR12);
event FUN14(address indexed VAR14, uint256 VAR12);
constructor() public {
VAR26 = "";
VAR27 = "";
VAR28 = 18;
VAR29 = 300000000 * 10**uint(VAR28);
VAR30[VAR20] = VAR29;
emit Transfer(address(0), VAR20, VAR29);
}
function FUN5() public view returns (uint) {
return VAR29.FUN2(VAR30[address(0)]);
}
function FUN6(address VAR7) public view returns (uint VAR8) {
return VAR30[VAR7];
}
function transfer(address VAR11, uint VAR12) public returns (bool VAR13) {
VAR30[msg.sender] = VAR30[msg.sender].FUN2(VAR12);
VAR30[VAR11] = VAR30[VAR11].FUN1(VAR12);
emit Transfer(msg.sender, VAR11, VAR12);
return true;
}
//
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13) {
VAR31[msg.sender][VAR9] = VAR12;
emit FUN13(msg.sender, VAR9, VAR12);
return true;
}
//
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13) {
VAR30[VAR14] = VAR30[VAR14].FUN2(VAR12);
VAR31[VAR14][msg.sender] = VAR31[VAR14][msg.sender].FUN2(VAR12);
VAR30[VAR11] = VAR30[VAR11].FUN1(VAR12);
emit Transfer(VAR14, VAR11, VAR12);
return true;
}
function FUN7(address VAR7, address VAR9) public view returns (uint VAR10) {
return VAR31[VAR7][VAR9];
}
function FUN19(address VAR9, uint VAR12, bytes memory VAR18) public returns (bool VAR13) {
VAR31[msg.sender][VAR9] = VAR12;
emit FUN13(msg.sender, VAR9, VAR12);
FUN20(VAR9).FUN15(msg.sender, VAR12, address(this), VAR18);
return true;
}
function FUN10(uint256 VAR32) public returns (bool VAR13) {
require(VAR30[msg.sender] >= VAR32);
VAR30[msg.sender] -= VAR32;
VAR29 -= VAR32;
emit FUN14(msg.sender, VAR32);
return true;
}
function FUN11(address VAR22, uint256 VAR32) public returns (bool VAR13) {
require(VAR30[VAR22] >= VAR32);
require(VAR32 <= VAR31[VAR22][msg.sender]);
VAR30[VAR22] -= VAR32;
VAR31[VAR22][msg.sender] -= VAR32;
VAR29 -= VAR32;
emit FUN14(VAR22, VAR32);
return true;
}
function FUN12(address VAR33, uint256 VAR32) public returns (bool VAR13) {
require(msg.sender == VAR20);
require(VAR29 + VAR32 >= VAR29);
VAR29 += VAR32;
VAR30[VAR33] += VAR32;
emit Transfer(address(0), VAR33, VAR32);
return true;
}
function () external payable {
revert();
}
function FUN21(address VAR34, uint VAR12) public onlyOwner returns (bool VAR13) {
return FUN22(VAR34).transfer(VAR20, VAR12);
}
}
0
---------------------------------
439 0x0364a98148b7031451e79b93449b20090d79702a.sol
pragma VAR1 ^0.4.17;
//
//
//
contract VAR2 {
function FUN1() public constant returns (uint);
function FUN2(address VAR3) public constant returns (uint VAR4);
function FUN3(address VAR3, address VAR5) public constant returns (uint VAR6);
function transfer(address VAR7, uint VAR8) public returns (bool VAR9);
function FUN4(address VAR5, uint VAR8) public returns (bool VAR9);
function FUN5(address VAR10, address VAR7, uint VAR8) public returns (bool VAR9);
event Transfer(address indexed VAR10, address indexed VAR7, uint VAR8);
event FUN6(address indexed VAR3, address indexed VAR5, uint VAR8);
}
contract VAR11 {
address public VAR12;
address public VAR13;
event FUN7(address indexed VAR14, address indexed VAR15);
modifier onlyOwner {
require(msg.sender == VAR12);
VAR16;
}
function FUN8() public {
VAR12 = msg.sender;
}
function FUN9(address VAR17) public onlyOwner {
VAR13 = VAR17;
}
function FUN10() public {
require(msg.sender == VAR13);
FUN7(VAR12, VAR13);
VAR12 = VAR13;
VAR13 = 0x0;
}
}
contract Admined is VAR11 {
mapping (address => bool) public VAR18;
event FUN11(address VAR19);
event FUN12(address VAR19);
modifier onlyAdmin() {
require(FUN13(msg.sender));
VAR16;
}
function FUN13(address VAR19) public constant returns (bool) {
return (VAR18[VAR19] || VAR12 == VAR19);
}
function FUN14(address VAR19) public onlyOwner {
require(!VAR18[VAR19] && VAR19 != VAR12);
VAR18[VAR19] = true;
FUN11(VAR19);
}
function FUN15(address VAR19) public onlyOwner {
require(VAR18[VAR19]);
delete VAR18[VAR19];
FUN12(VAR19);
}
}
contract DeveryRegistry is VAR20 {
struct VAR21 {
address VAR22;
string VAR23;
address VAR24;
uint VAR25;
bool VAR26;
}
struct VAR27 {
address VAR28;
address VAR22;
string VAR29;
bool VAR26;
}
struct VAR30 {
address VAR31;
address VAR28;
string VAR32;
string VAR33;
uint VAR34;
string VAR35;
bool VAR26;
}
ERC20Interface public VAR36;
address public VAR24;
uint public VAR25;
mapping(address => VAR21) public VAR37;
mapping(address => VAR27) public VAR38;
mapping(address => VAR30) public VAR39;
mapping(address => mapping(address => bool)) VAR40;
mapping(bytes32 => address) VAR41;
address[] public VAR42;
address[] public VAR43;
address[] public VAR44;
event FUN16(address indexed VAR45, address indexed VAR46);
event FUN17(address indexed VAR47, address indexed VAR48, uint VAR49, uint VAR50);
event FUN18(address indexed VAR22, string VAR23, address VAR24, uint VAR25, bool VAR26);
event FUN19(address indexed VAR22, string VAR23, address VAR24, uint VAR25, bool VAR26);
event FUN20(address indexed VAR28, address indexed VAR22, string VAR29, bool VAR26);
event FUN21(address indexed VAR28, address indexed VAR22, string VAR29, bool VAR26);
event FUN22(address indexed VAR31, address indexed VAR28, address indexed VAR22, string VAR32, bool VAR26);
event FUN23(address indexed VAR31, address indexed VAR28, address indexed VAR22, string VAR32, bool VAR26);
event FUN24(address indexed VAR51, address indexed VAR28, bool VAR52);
event FUN25(address indexed VAR51, address indexed VAR31, address VAR53, address VAR24, uint VAR54, uint VAR25, bytes32 VAR55);
function FUN26(address VAR56) public onlyAdmin {
FUN16(address(VAR36), VAR56);
VAR36 = FUN27(VAR56);
}
function FUN28(address VAR57, uint VAR58) public onlyAdmin {
FUN17(VAR24, VAR57, VAR25, VAR58);
VAR24 = VAR57;
VAR25 = VAR58;
}
function FUN29(string VAR23, address VAR57, uint VAR58) public {
App storage VAR59 = VAR37[msg.sender];
require(VAR59.VAR22 == address(0));
VAR37[msg.sender] = FUN30({
VAR22: msg.sender,
VAR23: VAR23,
VAR24: VAR57,
VAR25: VAR58,
VAR26: true
});
VAR42.FUN31(msg.sender);
FUN18(msg.sender, VAR23, VAR57, VAR58, true);
}
function FUN32(string VAR23, address VAR57, uint VAR58, bool VAR26) public {
App storage VAR59 = VAR37[msg.sender];
require(msg.sender == VAR59.VAR22);
VAR59.VAR23 = VAR23;
VAR59.VAR24 = VAR57;
VAR59.VAR25 = VAR58;
VAR59.VAR26 = VAR26;
FUN19(msg.sender, VAR23, VAR57, VAR58, VAR26);
}
function FUN33(address VAR22) public constant returns (App VAR60) {
VAR60 = VAR37[VAR22];
}
function FUN34(address VAR22) public constant returns (address VAR57, uint VAR58, bool VAR26) {
App storage VAR59 = VAR37[VAR22];
VAR57 = VAR59.VAR24;
VAR58 = VAR59.VAR25;
VAR26 = VAR59.VAR26;
}
function FUN35() public constant returns (uint) {
return VAR42.VAR61;
}
function FUN36(address VAR28, string VAR29) public {
App storage VAR60 = VAR37[msg.sender];
require(VAR60.VAR22 != address(0));
Brand storage VAR62 = VAR38[VAR28];
require(VAR62.VAR28 == address(0));
VAR38[VAR28] = FUN37({
VAR28: VAR28,
VAR22: msg.sender,
VAR29: VAR29,
VAR26: true
});
VAR43.FUN31(VAR28);
FUN20(VAR28, msg.sender, VAR29, true);
}
function FUN38(address VAR28, string VAR29, bool VAR26) public {
Brand storage VAR62 = VAR38[VAR28];
require(VAR62.VAR22 == msg.sender);
VAR62.VAR29 = VAR29;
VAR62.VAR26 = VAR26;
FUN21(VAR28, msg.sender, VAR29, VAR26);
}
function FUN39(address VAR28) public constant returns (Brand VAR62) {
VAR62 = VAR38[VAR28];
}
function FUN40(address VAR28) public constant returns (address VAR22, address VAR53, bool VAR26) {
Brand storage VAR62 = VAR38[VAR28];
require(VAR62.VAR22 != address(0));
App storage VAR60 = VAR37[VAR62.VAR22];
require(VAR60.VAR22 != address(0));
VAR22 = VAR60.VAR22;
VAR53 = VAR60.VAR24;
VAR26 = VAR60.VAR26 && VAR62.VAR26;
}
function FUN41() public constant returns (uint) {
return VAR43.VAR61;
}
function FUN42(address VAR31, string VAR32, string VAR33, uint VAR34, string VAR35) public {
Brand storage VAR62 = VAR38[msg.sender];
require(VAR62.VAR28 != address(0));
App storage VAR60 = VAR37[VAR62.VAR22];
require(VAR60.VAR22 != address(0));
Product storage VAR63 = VAR39[VAR31];
require(VAR63.VAR31 == address(0));
VAR39[VAR31] = FUN43({
VAR31: VAR31,
VAR28: msg.sender,
VAR32: VAR32,
VAR33: VAR33,
VAR34: VAR34,
VAR35: VAR35,
VAR26: true
});
VAR44.FUN31(VAR31);
FUN22(VAR31, msg.sender, VAR60.VAR22, VAR32, true);
}
function FUN44(address VAR31, string VAR32, string VAR33, uint VAR34, string VAR35, bool VAR26) public {
Product storage VAR63 = VAR39[VAR31];
require(VAR63.VAR28 == msg.sender);
Brand storage VAR62 = VAR38[msg.sender];
require(VAR62.VAR28 == msg.sender);
App storage VAR60 = VAR37[VAR62.VAR22];
VAR63.VAR32 = VAR32;
VAR63.VAR33 = VAR33;
VAR63.VAR34 = VAR34;
VAR63.VAR35 = VAR35;
VAR63.VAR26 = VAR26;
FUN23(VAR31, VAR63.VAR28, VAR60.VAR22, VAR32, VAR26);
}
function FUN45(address VAR31) public constant returns (Product VAR63) {
VAR63 = VAR39[VAR31];
}
function FUN46(address VAR31) public constant returns (address VAR28, address VAR22, address VAR53, bool VAR26) {
Product storage VAR63 = VAR39[VAR31];
require(VAR63.VAR28 != address(0));
Brand storage VAR62 = VAR38[VAR28];
require(VAR62.VAR22 != address(0));
App storage VAR60 = VAR37[VAR62.VAR22];
require(VAR60.VAR22 != address(0));
VAR28 = VAR63.VAR28;
VAR22 = VAR60.VAR22;
VAR53 = VAR60.VAR24;
VAR26 = VAR60.VAR26 && VAR62.VAR26 && VAR62.VAR26;
}
function FUN47() public constant returns (uint) {
return VAR44.VAR61;
}
function FUN48(address VAR51, bool VAR52) public {
Brand storage VAR62 = VAR38[msg.sender];
require(VAR62.VAR28 != address(0));
VAR40[VAR51][msg.sender] = VAR52;
FUN24(VAR51, msg.sender, VAR52);
}
function FUN49(address VAR64) public pure returns (bytes32 VAR65) {
VAR65 = FUN50(VAR64);
}
function FUN51(address VAR31, bytes32 VAR55) public {
Product storage VAR63 = VAR39[VAR31];
require(VAR63.VAR28 != address(0) && VAR63.VAR26);
Brand storage VAR62 = VAR38[VAR63.VAR28];
require(VAR62.VAR28 != address(0) && VAR62.VAR26);
App storage VAR60 = VAR37[VAR62.VAR22];
require(VAR60.VAR22 != address(0) && VAR60.VAR26);
bool VAR66 = VAR40[msg.sender][VAR62.VAR28];
require(VAR66);
VAR41[VAR55] = VAR31;
FUN25(msg.sender, VAR31, VAR60.VAR24, VAR24, VAR60.VAR25, VAR25, VAR55);
if (VAR60.VAR25 > 0) {
VAR36.FUN5(VAR62.VAR28, VAR60.VAR24, VAR60.VAR25);
}
if (VAR25 > 0) {
VAR36.FUN5(VAR62.VAR28, VAR24, VAR25);
}
}
function FUN52(address VAR64) public constant returns (address VAR31, address VAR28, address VAR22) {
bytes32 VAR65 = FUN50(VAR64);
VAR31 = VAR41[VAR65];
Product storage VAR63 = VAR39[VAR31];
Brand storage VAR62 = VAR38[VAR63.VAR28];
VAR28 = VAR63.VAR28;
VAR22 = VAR62.VAR22;
}
}
0
---------------------------------
440 0x036ae648ed4a16ff471849c8f2f033d87314ab46.sol
pragma solidity 0.4.19;
contract VAR1 {
address public VAR2;
function FUN1() {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN2(address VAR4) onlyOwner public {
if (VAR4 != address(0)) {
VAR2 = VAR4;
}
}
}
library VAR5 {
function FUN3(uint VAR6, uint VAR7) internal returns (uint) {
uint VAR8 = VAR6 * VAR7;
assert(VAR6 == 0 || VAR8 / VAR6 == VAR7);
return VAR8;
}
function FUN4(uint VAR6, uint VAR7) internal returns (uint) {
uint VAR8 = VAR6 / VAR7;
return VAR8;
}
function FUN5(uint VAR6, uint VAR7) internal returns (uint) {
assert(VAR7 <= VAR6);
return VAR6 - VAR7;
}
function FUN6(uint VAR6, uint VAR7) internal returns (uint) {
uint VAR8 = VAR6 + VAR7;
assert(VAR8 >= VAR6);
return VAR8;
}
function FUN7(uint64 VAR6, uint64 VAR7) internal constant returns (VAR9) {
return VAR6 >= VAR7 ? VAR6 : VAR7;
}
function FUN8(uint64 VAR6, uint64 VAR7) internal constant returns (VAR9) {
return VAR6 < VAR7 ? VAR6 : VAR7;
}
function FUN9(uint256 VAR6, uint256 VAR7) internal constant returns (uint256) {
return VAR6 >= VAR7 ? VAR6 : VAR7;
}
function FUN10(uint256 VAR6, uint256 VAR7) internal constant returns (uint256) {
return VAR6 < VAR7 ? VAR6 : VAR7;
}
}
contract HardCap is VAR1 {
using SafeMath for uint;
event FUN11(uint VAR10, bytes32 VAR11, uint VAR12);
mapping(bytes32 => uint) public VAR13;
uint VAR14 = 0;
function FUN12(string VAR15, uint VAR16) public onlyOwner {
VAR13[FUN13(VAR15)] = VAR16;
VAR14 = VAR14.FUN6(VAR16) ;
FUN11(VAR17, FUN13(VAR15), VAR16);
}
function FUN14(uint[] VAR18) public onlyOwner {
require(VAR18.VAR19 % 2 == 0);
uint VAR20 = 0;
while (VAR20 < VAR18.VAR19 / 2) {
bytes32 VAR11 = bytes32(VAR18[VAR20 * 2]);
uint VAR21 = VAR18[VAR20 * 2 + 1];
VAR13[VAR11] = VAR21;
VAR14 = VAR14.FUN6(VAR21);
FUN11(VAR17, VAR11, VAR21);
VAR20++;
}
}
function FUN15(string VAR15) public constant returns(uint) {
return VAR13[FUN13(VAR15)];
}
function FUN16() public constant returns(uint) {
return VAR14;
}
}
0
---------------------------------
441 0x0371a82e4a9d0a4312f3ee2ac9c6958512891372.sol
contract VAR1 {
uint256 public VAR2;
function FUN1(address VAR3) constant returns (uint256);
function transfer(address VAR4, uint256 value) returns (bool);
event Transfer(address indexed VAR5, address indexed VAR4, uint256 value);
}
contract ERC20 is VAR1 {
function FUN2(address VAR6, address VAR7) constant returns (uint256);
function FUN3(address VAR5, address VAR4, uint256 value) returns (bool);
function FUN4(address VAR7, uint256 value) returns (bool);
event FUN5(address indexed VAR6, address indexed VAR7, uint256 value);
}
contract VAR8 {
function FUN6(uint VAR9, uint VAR10) internal returns (uint) {
uint VAR11 = VAR9 * VAR10;
assert(VAR9 == 0 || VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN7(uint VAR9, uint VAR10) internal returns (uint) {
assert(VAR10 > 0);
uint VAR11 = VAR9 / VAR10;
assert(VAR9 == VAR10 * VAR11 + VAR9 % VAR10);
return VAR11;
}
function FUN8(uint VAR9, uint VAR10) internal returns (uint) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN9(uint VAR9, uint VAR10) internal returns (uint) {
uint VAR11 = VAR9 + VAR10;
assert(VAR11>=VAR9 && VAR11>=VAR10);
return VAR11;
}
function FUN10(uint64 VAR9, uint64 VAR10) internal constant returns (VAR12) {
return VAR9 >= VAR10 ? VAR9 : VAR10;
}
function FUN11(uint64 VAR9, uint64 VAR10) internal constant returns (VAR12) {
return VAR9 < VAR10 ? VAR9 : VAR10;
}
function FUN12(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
return VAR9 >= VAR10 ? VAR9 : VAR10;
}
function FUN13(uint256 VAR9, uint256 VAR10) internal constant returns (uint256) {
return VAR9 < VAR10 ? VAR9 : VAR10;
}
}
contract StandardToken is VAR13, VAR8 {
event FUN14(address VAR14, uint VAR15);
mapping(address => uint) VAR16;
mapping (address => mapping (address => uint)) VAR17;
function FUN15() public constant returns (bool VAR18) {
return true;
}
function transfer(address VAR19, uint VAR20) returns (bool VAR21) {
VAR16[msg.sender] = FUN8(VAR16[msg.sender], VAR20);
VAR16[VAR19] = FUN9(VAR16[VAR19], VAR20);
Transfer(msg.sender, VAR19, VAR20);
return true;
}
function FUN3(address VAR22, address VAR19, uint VAR20) returns (bool VAR21) {
uint VAR23 = VAR17[VAR22][msg.sender];
VAR16[VAR19] = FUN9(VAR16[VAR19], VAR20);
VAR16[VAR22] = FUN8(VAR16[VAR22], VAR20);
VAR17[VAR22][msg.sender] = FUN8(VAR23, VAR20);
Transfer(VAR22, VAR19, VAR20);
return true;
}
function FUN1(address VAR24) constant returns (uint VAR25) {
return VAR16[VAR24];
}
function FUN4(address VAR26, uint VAR20) returns (bool VAR21) {
if ((VAR20 != 0) && (VAR17[msg.sender][VAR26] != 0)) throw;
VAR17[msg.sender][VAR26] = VAR20;
FUN5(msg.sender, VAR26, VAR20);
return true;
}
function FUN2(address VAR24, address VAR26) constant returns (uint VAR27) {
return VAR17[VAR24][VAR26];
}
}
contract BurnableToken is VAR28 {
address public constant VAR29 = 0;
event FUN16(address VAR30, uint VAR31);
function FUN17(uint VAR32) {
address VAR30 = msg.sender;
VAR16[VAR30] = FUN8(VAR16[VAR30], VAR32);
VAR2 = FUN8(VAR2, VAR32);
FUN16(VAR30, VAR32);
}
}
contract VAR33 {
uint public VAR34;
function FUN18() public constant returns (bool) {
return true;
}
function FUN19(address VAR22, uint256 VAR20) public;
}
contract UpgradeableToken is VAR28 {
address public VAR35;
UpgradeAgent public VAR36;
uint256 public VAR37;
enum VAR38 {VAR39, VAR40, VAR41, VAR42, VAR43}
event FUN20(address indexed VAR22, address indexed VAR19, uint256 VAR20);
event FUN21(address VAR44);
function FUN22(address VAR45) {
VAR35 = VAR45;
}
function FUN23(uint256 value) public {
UpgradeState VAR46 = FUN24();
if(!(VAR46 == VAR38.VAR42 || VAR46 == VAR38.VAR43)) {
throw;
}
if (value == 0) throw;
VAR16[msg.sender] = FUN8(VAR16[msg.sender], value);
VAR2 = FUN8(VAR2, value);
VAR37 = FUN9(VAR37, value);
VAR36.FUN19(msg.sender, value);
FUN20(msg.sender, VAR36, value);
}
function FUN25(address VAR44) external {
if(!FUN26()) {
throw;
}
if (VAR44 == 0x0) throw;
if (msg.sender != VAR35) throw;
if (FUN24() == VAR38.VAR43) throw;
VAR36 = FUN27(VAR44);
if(!VAR36.FUN18()) throw;
if (VAR36.FUN28() != VAR2) throw;
FUN21(VAR36);
}
function FUN24() public constant returns(VAR38) {
if(!FUN26()) return VAR38.VAR40;
else if(address(VAR36) == 0x00) return VAR38.VAR41;
else if(VAR37 == 0) return VAR38.VAR42;
else return VAR38.VAR43;
}
function FUN29(address VAR47) public {
if (VAR47 == 0x0) throw;
if (msg.sender != VAR35) throw;
VAR35 = VAR47;
}
function FUN26() public constant returns(bool) {
return true;
}
}
contract VAR48 {
address public VAR6;
function FUN30() {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR49;
}
function FUN31(address VAR50) onlyOwner {
require(VAR50 != address(0));
VAR6 = VAR50;
}
}
contract ReleasableToken is VAR13, VAR48 {
address public VAR51;
bool public VAR52 = false;
mapping (address => bool) public VAR53;
modifier FUN32(address VAR54) {
if(!VAR52) {
if(!VAR53[VAR54]) {
throw;
}
}
VAR49;
}
function FUN33(address VAR55) onlyOwner FUN34(false) public {
VAR51 = VAR55;
}
function FUN35(address VAR55, bool VAR46) onlyOwner FUN34(false) public {
VAR53[VAR55] = VAR46;
}
function FUN36() public VAR56 {
VAR52 = true;
}
modifier FUN34(bool VAR57) {
if(VAR57 != VAR52) {
throw;
}
VAR49;
}
modifier FUN37() {
if(msg.sender != VAR51) {
throw;
}
VAR49;
}
function transfer(address VAR19, uint VAR20) FUN32(msg.sender) returns (bool VAR21) {
return super.transfer(VAR19, VAR20);
}
function FUN3(address VAR22, address VAR19, uint VAR20) FUN32(VAR22) returns (bool VAR21) {
return super.FUN3(VAR22, VAR19, VAR20);
}
}
library VAR58 {
function FUN38(uint VAR9, uint VAR10) returns (uint) {
uint VAR11 = VAR9 * VAR10;
assert(VAR9 == 0 || VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN39(uint VAR9, uint VAR10) returns (uint) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN40(uint VAR9, uint VAR10) returns (uint) {
uint VAR11 = VAR9 + VAR10;
assert(VAR11>=VAR9);
return VAR11;
}
}
contract MintableToken is VAR28, VAR48 {
using SafeMathLib for uint;
bool public VAR59 = false;
mapping (address => bool) public VAR60;
event FUN41(address VAR55, bool VAR46  );
function FUN42(address VAR14, uint VAR15) onlyMintAgent canMint public {
VAR2 = VAR2.FUN40(VAR15);
VAR16[VAR14] = VAR16[VAR14].FUN40(VAR15);
Transfer(0, VAR14, VAR15);
}
function FUN43(address VAR55, bool VAR46) onlyOwner canMint public {
VAR60[VAR55] = VAR46;
FUN41(VAR55, VAR46);
}
modifier FUN44() {
if(!VAR60[msg.sender]) {
throw;
}
VAR49;
}
modifier FUN45() {
if(VAR59) throw;
VAR49;
}
}
contract CrowdsaleToken is VAR61, VAR62, VAR63 {
event FUN46(string VAR64, string VAR65);
string public VAR66;
string public VAR67;
uint public VAR68;
function FUN47(string VAR69, string VAR70, uint VAR71, uint VAR72, bool VAR73)
FUN22(msg.sender) {
VAR6 = msg.sender;
VAR66 = VAR69;
VAR67 = VAR70;
VAR2 = VAR71;
VAR68 = VAR72;
VAR16[VAR6] = VAR2;
if(VAR2 > 0) {
FUN14(VAR6, VAR2);
}
if(!VAR73) {
VAR59 = true;
if(VAR2 == 0) {
throw;
}
}
}
function FUN36() public VAR56 {
VAR59 = true;
super.FUN36();
}
function FUN26() public constant returns(bool) {
return VAR52 && super.FUN26();
}
function FUN48(string VAR69, string VAR70) onlyOwner {
VAR66 = VAR69;
VAR67 = VAR70;
FUN46(VAR66, VAR67);
}
}
contract BurnableCrowdsaleToken is VAR74, VAR75 {
function FUN49(string VAR69, string VAR70, uint VAR71, uint VAR72, bool VAR73)
FUN47(VAR69, VAR70, VAR71, VAR72, VAR73) {
}
}
0
---------------------------------
442 0x0372ddb7c5e849383252243348bbe65da456e97d.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
function FUN5(address VAR6) constant public returns (uint256);
function transfer(address VAR7, uint256 VAR8) public returns (bool);
}
contract VAR9 {
uint256 public VAR10;
function FUN5(address VAR11) public constant returns (uint256);
function transfer(address VAR12, uint256 value) public returns (bool);
event Transfer(address indexed VAR13, address indexed VAR12, uint256 value);
}
contract ERC20 is VAR9 {
function FUN6(address VAR14, address VAR15) public constant returns (uint256);
function FUN7(address VAR13, address VAR12, uint256 value) public returns (bool);
function FUN8(address VAR15, uint256 value) public returns (bool);
event FUN9(address indexed VAR14, address indexed VAR15, uint256 value);
}
contract VAR16 {
address public VAR14;
constructor() public{
VAR14 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR14);
VAR17;
}
}
contract Pausable is VAR16 {
event FUN10();
event FUN11();
bool public VAR18 = false;
modifier FUN12() {
require(!VAR18);
VAR17;
}
modifier FUN13() {
require(VAR18);
VAR17;
}
function FUN14() onlyOwner whenNotPaused public {
VAR18 = true;
emit FUN10();
}
function FUN15() onlyOwner whenPaused public {
VAR18 = false;
emit FUN11();
}
}
contract CUC is VAR19,VAR20 {
using SafeMath for uint256;
mapping (address => uint256) VAR21;
mapping (address => mapping (address => uint256)) VAR22;
mapping (address => bool) public VAR23;
string public constant VAR24 = "";
string public constant VAR25 = "";
uint8 public constant VAR26 = 18;
uint256 public VAR27 = 1050000000e18;
uint256 public VAR28 = 450000000e18;
uint256 public VAR29 = 1200000000e18;
uint256 public VAR30;
uint256 public value = 3000e18;
address private VAR31;
address private VAR32;
uint256 private VAR33 = VAR34 + 365 VAR35;
event FUN16(address indexed VAR12, uint256 VAR36);
event FUN17();
event FUN18(address indexed VAR37, uint256 value);
bool public VAR38 = false;
modifier FUN19() {
require(!VAR38);
VAR17;
}
modifier FUN20() {
require(VAR23[msg.sender] == false);
VAR17;
}
constructor(address VAR39, address VAR40) public {
VAR14 = msg.sender;
require(VAR14 != VAR39);
require(VAR14 != VAR40);
require(VAR39 != address(0));
require(VAR40 != address(0));
VAR10 = 3000000000e18;
VAR30 = VAR10.FUN3(VAR27).FUN3(VAR28).FUN3(VAR29);
VAR21[VAR14] = VAR27;
VAR31 = VAR39;
VAR32 = VAR40;
VAR21[VAR31] = VAR28;
VAR21[VAR32] = VAR29;
}
function FUN21(address VAR41) onlyOwner public {
require(VAR41 != address(0));
VAR14 = VAR41;
}
function FUN22() onlyOwner canDistr public returns (bool) {
VAR38 = true;
emit FUN17();
return true;
}
function FUN23(address VAR7, uint256 VAR42) canDistr private returns (bool) {
VAR27 = VAR27.FUN4(VAR42);
VAR30 = VAR30.FUN3(VAR42);
VAR21[VAR7] = VAR21[VAR7].FUN4(VAR42);
emit FUN16(VAR7, VAR42);
emit Transfer(address(0), VAR7, VAR42);
if (VAR27 >= VAR10) {
VAR38 = true;
}
return true;
}
function () external payable {
FUN24();
}
function FUN24() payable canDistr onlyWhitelist public {
if (value > VAR30) {
value = VAR30;
}
require(value <= VAR30);
address VAR43 = msg.sender;
require(VAR44.VAR45 == VAR43);
uint256 VAR46 = value;
FUN23(VAR43, VAR46);
if (VAR46 > 0) {
VAR23[VAR43] = true;
}
value = value.FUN1(99999).FUN2(100000);
}
function FUN5(address VAR6) constant public returns (uint256) {
return VAR21[VAR6];
}
modifier FUN25(uint VAR47) {
require(msg.VAR48.VAR49 >= VAR47 + 4);
VAR17;
}
function FUN26(address VAR13) public view returns (bool) {
if (VAR13 == VAR31 || VAR13 == VAR32) {
if (VAR34 >= VAR33) {
return true;
} else {
return false;
}
}
return true;
}
function transfer(address VAR7, uint256 VAR42) FUN25(2 * 32) public whenNotPaused returns (bool VAR50) {
require(VAR7 != address(0));
require(VAR42 <= VAR21[msg.sender]);
require(FUN26(msg.sender));
VAR21[msg.sender] = VAR21[msg.sender].FUN3(VAR42);
VAR21[VAR7] = VAR21[VAR7].FUN4(VAR42);
emit Transfer(msg.sender, VAR7, VAR42);
return true;
}
function FUN7(address VAR51, address VAR7, uint256 VAR42) FUN25(3 * 32) public whenNotPaused returns (bool VAR50) {
require(VAR7 != address(0));
require(VAR42 <= VAR21[VAR51]);
require(VAR42 <= VAR22[VAR51][msg.sender]);
require(FUN26(VAR51));
VAR21[VAR51] = VAR21[VAR51].FUN3(VAR42);
VAR22[VAR51][msg.sender] = VAR22[VAR51][msg.sender].FUN3(VAR42);
VAR21[VAR7] = VAR21[VAR7].FUN4(VAR42);
emit Transfer(VAR51, VAR7, VAR42);
return true;
}
function FUN8(address VAR52, uint256 VAR8) public whenNotPaused returns (bool VAR50) {
if (VAR8 != 0 && VAR22[msg.sender][VAR52] != 0) { return false; }
VAR22[msg.sender][VAR52] = VAR8;
emit FUN9(msg.sender, VAR52, VAR8);
return true;
}
function FUN6(address VAR6, address VAR52) constant public returns (uint256) {
return VAR22[VAR6][VAR52];
}
function FUN27(address VAR53, address VAR11) constant public returns (uint){
ForeignToken VAR54 = FUN28(VAR53);
uint VAR55 = VAR54.FUN5(VAR11);
return VAR55;
}
function FUN29() onlyOwner public {
uint256 VAR56 = address(this).VAR57;
VAR14.transfer(VAR56);
}
function FUN30(uint256 VAR8) onlyOwner public {
require(VAR8 <= VAR21[msg.sender]);
address VAR37 = msg.sender;
VAR21[VAR37] = VAR21[VAR37].FUN3(VAR8);
VAR10 = VAR10.FUN3(VAR8);
VAR27 = VAR27.FUN3(VAR8);
emit FUN18(VAR37, VAR8);
}
function FUN31(address VAR58) onlyOwner public returns (bool) {
ForeignToken VAR59 = FUN28(VAR58);
uint256 VAR36 = VAR59.FUN5(address(this));
return VAR59.transfer(VAR14, VAR36);
}
}
0
---------------------------------
443 0x0373bd549897b97bfdc17e9be3f576eb03916857.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
uint256 constant VAR3 = 0x10000000000000000;
int constant VAR4 = 7;
int constant VAR5 = 9;
int constant VAR6 = -0x296ABF784A358468C;
string constant public VAR7 = "";
string constant public VAR8 = "";
uint8 constant public VAR9 = 18;
mapping(address => uint256) public VAR10;
mapping(address => VAR11) public VAR12;
uint256 public VAR13;
int256 VAR14;
uint256 VAR15;
uint256 public VAR16;
uint private VAR17 = 0;
mapping (address => uint) private VAR18;
mapping (address => mapping (address => uint)) private VAR19;
function FUN1() public {}
function FUN2() constant returns (uint VAR20) {
VAR20 = VAR17;
}
function FUN3(uint VAR21) internal {
VAR18[msg.sender] += VAR21;
VAR17 += VAR21;
}
function FUN4(address VAR22) constant returns (uint VAR23) {
return VAR18[VAR22];
}
function transfer(address VAR24, uint VAR21) returns (bool VAR25) {
if (VAR21 > 0 && VAR21 <= FUN4(msg.sender)) {
VAR18[msg.sender] -= VAR21;
VAR18[VAR24] += VAR21;
return true;
}
return false;
}
function FUN5(address VAR26, address VAR24, uint VAR21) returns (bool VAR25) {
if (VAR19[VAR26][msg.sender] > 0 &&
VAR21 > 0 &&
VAR19[VAR26][msg.sender] >= VAR21 &&
VAR18[VAR26] >= VAR21) {
VAR18[VAR26] -= VAR21;
VAR18[VAR24] += VAR21;
VAR19[VAR26][msg.sender] -= VAR21;
return true;
}
return false;
}
function FUN6(address VAR27, uint VAR21) returns (bool VAR25) {
VAR19[msg.sender][VAR27] = VAR21;
return true;
}
function FUN7(address VAR28, address VAR27) constant returns (uint VAR29) {
return VAR19[VAR28][VAR27];
}
function FUN8(address VAR28) public constant returns (uint256 VAR23) {
return VAR10[VAR28];
}
function FUN9() public {
var VAR23 = FUN10(msg.sender);
VAR12[msg.sender] += (VAR11) (VAR23 * VAR3);
VAR14 += (VAR11) (VAR23 * VAR3);
VAR16 = FUN11(VAR16, VAR23);
msg.sender.transfer(VAR23);
}
function FUN12() public {
var VAR23 = FUN10(msg.sender);
VAR12[msg.sender] += (VAR11) (VAR23 * VAR3);
VAR14 += (VAR11) (VAR23 * VAR3);
uint VAR30 = (uint) (VAR23);
if (VAR30 < 0.000001 VAR31 || VAR30 > 1000000 VAR31)
revert();
var sender = msg.sender;
var VAR32 = FUN13() - VAR23;
var VAR33 = FUN14(VAR30, 10);
var VAR34 = VAR30 - VAR33;
var VAR35 = FUN15(VAR34, VAR23);
FUN3(VAR35);
var VAR36 = VAR33 * VAR3;
if (VAR13 > 0) {
var VAR37 =
(VAR3 - (VAR32 + VAR34) * VAR35 * VAR3 / (VAR13 + VAR35) / VAR34)
* (uint)(VAR5) / (uint)(VAR5-VAR4);
var VAR38 = VAR33 * VAR37;
VAR36 -= VAR38;
var VAR39 = VAR38 / VAR13;
VAR15 += VAR39;
}
VAR13 = FUN16(VAR13, VAR35);
VAR10[sender] = FUN16(VAR10[sender], VAR35);
var VAR40  = (VAR11) ((VAR15 * VAR35) - VAR36);
VAR12[sender] += VAR40;
VAR14    += VAR40;
}
function FUN17() public {
var VAR23 = FUN8(msg.sender);
FUN18(VAR23);
}
function FUN19() public {
FUN17();
FUN9();
}
function FUN20() public {
FUN17();
FUN12();
}
function FUN21() payable public {
if (msg.value > 0.000001 VAR31) {
VAR16 = FUN16(VAR16, msg.value);
FUN22();
} else {
revert();
}
}
function FUN23() public constant returns (uint) {
return FUN24(1 VAR41);
}
function FUN25() public constant returns (uint) {
var VAR42 = FUN26(1 VAR41);
var VAR33 = FUN14(VAR42, 10);
return VAR42 - VAR33;
}
function FUN10(address VAR28) public constant returns (uint256 VAR43) {
return (uint256) ((VAR11)(VAR15 * VAR10[VAR28]) - VAR12[VAR28]) / VAR3;
}
function FUN27(address VAR44) public {
var VAR23 = FUN10(msg.sender);
VAR12[msg.sender] += (VAR11) (VAR23 * VAR3);
VAR14 += (VAR11) (VAR23 * VAR3);
VAR16 = FUN11(VAR16, VAR23);
VAR44.transfer(VAR23);
}
function FUN28() internal constant returns (uint256 VAR43) {
return VAR16 - msg.value;
}
function FUN22() internal {
if (msg.value < 0.000001 VAR31 || msg.value > 1000000 VAR31)
revert();
var sender = msg.sender;
var VAR33 = FUN14(msg.value, 10);
var VAR34 = msg.value - VAR33;
var VAR35 = FUN24(VAR34);
FUN3(VAR35);
var VAR36 = VAR33 * VAR3;
if (VAR13 > 0) {
var VAR37 =
(VAR3 - (FUN13() + VAR34) * VAR35 * VAR3 / (VAR13 + VAR35) / VAR34)
* (uint)(VAR5) / (uint)(VAR5-VAR4);
var VAR38 = VAR33 * VAR37;
VAR36 -= VAR38;
var VAR39 = VAR38 / VAR13;
VAR15 += VAR39;
}
VAR13 = FUN16(VAR13, VAR35);
VAR10[sender] = FUN16(VAR10[sender], VAR35);
var VAR40 = (VAR11) ((VAR15 * VAR35) - VAR36);
VAR12[sender] += VAR40;
VAR14    += VAR40;
}
function FUN18(uint256 VAR43) internal {
var VAR45 = FUN26(VAR43);
var VAR33 = FUN14(VAR45, 10);
var VAR46 = VAR45 ;
VAR13 = FUN11(VAR13, VAR43);
VAR10[msg.sender] = FUN11(VAR10[msg.sender], VAR43);
var VAR40 = (VAR11) (VAR15 * VAR43 + (VAR46 * VAR3));
VAR12[msg.sender] -= VAR40;
VAR14 -= VAR40;
if (VAR13 > 0) {
var VAR47 = VAR33 * VAR3;
var VAR39 = VAR47 / VAR13;
VAR15 = FUN16(VAR15, VAR39);
}
}
function FUN13() internal constant returns (uint256 VAR43) {
return FUN11(FUN28(),
((uint256) ((VAR11) (VAR15 * VAR13) - VAR14) / VAR3));
}
function FUN24(uint256 VAR48) public constant returns (uint256 VAR49) {
return FUN11(FUN29(FUN30(FUN13() + VAR48)*VAR4/VAR5 + VAR6), VAR13);
}
function FUN15(uint256 VAR48, uint256 VAR50) public constant returns (uint256 VAR49) {
return FUN11(FUN29(FUN30(FUN13() - VAR50 + VAR48)*VAR4/VAR5 + VAR6), VAR13);
}
function FUN26(uint256 VAR49) public constant returns (uint256 VAR48) {
var VAR51 = FUN13();
if (VAR49 == VAR13)
return VAR51;
return FUN11(VAR51, FUN29((FUN30(VAR13 - VAR49) - VAR6) * VAR5/VAR4));
}
int256  constant VAR52        = 0x10000000000000000;
uint256 constant VAR53      = 0x16a09e667f3bcc908;
uint256 constant VAR54   = 0x0b504f333f9de6484;
int256  constant VAR55        = 0x0b17217f7d1cf79ac;
int256  constant VAR56 = 0x2cb53f09f05cc627c8;
int256  constant VAR57         = 0x1ffffffffff9dac9b;
int256  constant VAR58         = 0x0aaaaaaac16877908;
int256  constant VAR59         = 0x0666664e5e9fa0c99;
int256  constant VAR60         = 0x049254026a7630acf;
int256  constant VAR61         = 0x038bd75ed37753d68;
int256  constant VAR62        = 0x03284a0c14610924f;
function FUN30(uint256 VAR63) internal pure returns (int256 VAR64) {
int32 VAR65 = 0;
while (VAR63 > VAR53) {
VAR63 /= 2;
VAR65++;
}
while (VAR63 <= VAR54) {
VAR63 *= 2;
VAR65--;
}
int256 VAR66 = (((VAR11)(VAR63) - VAR52) * VAR52) / ((VAR11)(VAR63) + VAR52);
var VAR67 = (VAR66*VAR66) / VAR52;
return VAR65 * VAR55 +
(VAR66*(VAR57 + (VAR67*(VAR58 + (VAR67*(VAR59 + (VAR67*(VAR60 + (VAR67*(VAR61 + (VAR67*VAR62/VAR52))
/VAR52))/VAR52))/VAR52))/VAR52))/VAR52);
}
int256 constant VAR68 =  0x02aaaaaaaaa015db0;
int256 constant VAR69 = -0x000b60b60808399d1;
int256 constant VAR70 =  0x0000455956bccdd06;
int256 constant VAR71 = -0x000001b893ad04b3a;
function FUN29(int256 VAR63) internal pure returns (uint256 VAR72) {
int256 VAR65 = (VAR63 + (VAR56)) / VAR55 - 64;
VAR63 -= VAR65*VAR55;
int256 VAR67 = (VAR63*VAR63) / VAR52;
int256 VAR73 = ((VAR11)(2) * VAR52) +
(VAR67*(VAR68 + (VAR67*(VAR69 + (VAR67*(VAR70 + (VAR67*VAR71/VAR52))/VAR52))/VAR52))/VAR52);
VAR72 = (uint256) (((VAR73 + VAR63) * VAR52) / (VAR73 - VAR63));
if (VAR65 >= 0)
VAR72 <<= VAR65;
else
VAR72 >>= -VAR65;
return VAR72;
}
function FUN31(uint256 VAR63, uint256 VAR74) internal pure returns (uint256) {
if (VAR63 == 0) {
return 0;
}
uint256 VAR75 = VAR63 * VAR74;
assert(VAR75 / VAR63 == VAR74);
return VAR75;
}
function FUN14(uint256 VAR63, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR75 = VAR63 / VAR74;
return VAR75;
}
function FUN11(uint256 VAR63, uint256 VAR74) internal pure returns (uint256) {
assert(VAR74 <= VAR63);
return VAR63 - VAR74;
}
function FUN16(uint256 VAR63, uint256 VAR74) internal pure returns (uint256) {
uint256 VAR75 = VAR63 + VAR74;
assert(VAR75 >= VAR63);
return VAR75;
}
function () payable public {
if (msg.value > 0) {
FUN21();
} else {
FUN27(msg.sender);
}
}
}
0
---------------------------------
444 0x0377ea0201218c87988269097fe291ba800eb182.sol
pragma solidity 0.4.18;
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);
function FUN2() {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN3(address VAR4) onlyOwner public {
require(VAR4 != address(0));
FUN1(VAR2, VAR4);
VAR2 = VAR4;
}
}
contract Pausable is VAR1 {
event FUN4();
event FUN5();
bool public VAR6 = false;
modifier FUN6() {
require(!VAR6);
VAR5;
}
modifier FUN7() {
require(VAR6);
VAR5;
}
function FUN8() onlyOwner whenNotPaused public {
VAR6 = true;
FUN4();
}
function FUN9() onlyOwner whenPaused public {
VAR6 = false;
FUN5();
}
}
library VAR7 {
function FUN10(uint256 VAR8, uint256 VAR9) internal constant returns (uint256) {
uint256 VAR10 = VAR8 * VAR9;
assert(VAR8 == 0 || VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN11(uint256 VAR8, uint256 VAR9) internal constant returns (uint256) {
uint256 VAR10 = VAR8 / VAR9;
return VAR10;
}
function FUN12(uint256 VAR8, uint256 VAR9) internal constant returns (uint256) {
assert(VAR9 <= VAR8);
return VAR8 - VAR9;
}
function FUN13(uint256 VAR8, uint256 VAR9) internal constant returns (uint256) {
uint256 VAR10 = VAR8 + VAR9;
assert(VAR10 >= VAR8);
return VAR10;
}
}
contract VAR11 {
uint256 public VAR12;
function FUN14(address VAR13) public constant returns (uint256);
function transfer(address VAR14, uint256 value) public returns (bool);
event Transfer(address indexed VAR15, address indexed VAR14, uint256 value);
}
contract BasicToken is VAR11 {
using SafeMath for uint256;
mapping(address => uint256) VAR16;
function transfer(address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN12(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN13(VAR18);
Transfer(msg.sender, VAR17, VAR18);
return true;
}
function FUN14(address VAR19) public constant returns (uint256 VAR20) {
return VAR16[VAR19];
}
}
contract ERC20 is VAR11 {
function FUN15(address VAR2, address VAR21) public constant returns (uint256);
function FUN16(address VAR15, address VAR14, uint256 value) public returns (bool);
function FUN17(address VAR21, uint256 value) public returns (bool);
event FUN18(address indexed VAR2, address indexed VAR21, uint256 value);
}
contract StandardToken is VAR22, VAR23 {
mapping (address => mapping (address => uint256)) VAR24;
function FUN16(address VAR25, address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
uint256 VAR26 = VAR24[VAR25][msg.sender];
VAR16[VAR25] = VAR16[VAR25].FUN12(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN13(VAR18);
VAR24[VAR25][msg.sender] = VAR26.FUN12(VAR18);
Transfer(VAR25, VAR17, VAR18);
return true;
}
function FUN17(address VAR27, uint256 VAR18) public returns (bool) {
VAR24[msg.sender][VAR27] = VAR18;
FUN18(msg.sender, VAR27, VAR18);
return true;
}
function FUN15(address VAR19, address VAR27) public constant returns (uint256 VAR28) {
return VAR24[VAR19][VAR27];
}
function FUN19 (address VAR27, uint VAR29)
returns (bool VAR30) {
VAR24[msg.sender][VAR27] = VAR24[msg.sender][VAR27].FUN13(VAR29);
FUN18(msg.sender, VAR27, VAR24[msg.sender][VAR27]);
return true;
}
function FUN20 (address VAR27, uint VAR31)
returns (bool VAR30) {
uint VAR32 = VAR24[msg.sender][VAR27];
if (VAR31 > VAR32) {
VAR24[msg.sender][VAR27] = 0;
} else {
VAR24[msg.sender][VAR27] = VAR32.FUN12(VAR31);
}
FUN18(msg.sender, VAR27, VAR24[msg.sender][VAR27]);
return true;
}
}
contract PausableToken is VAR33, VAR34 {
function transfer(address VAR17, uint256 VAR18) public whenNotPaused returns (bool) {
return super.transfer(VAR17, VAR18);
}
function FUN16(address VAR25, address VAR17, uint256 VAR18) public whenNotPaused returns (bool) {
return super.FUN16(VAR25, VAR17, VAR18);
}
function FUN17(address VAR27, uint256 VAR18) public whenNotPaused returns (bool) {
return super.FUN17(VAR27, VAR18);
}
function FUN19(address VAR27, uint VAR29) public whenNotPaused returns (bool VAR30) {
return super.FUN19(VAR27, VAR29);
}
function FUN20(address VAR27, uint VAR31) public whenNotPaused returns (bool VAR30) {
return super.FUN20(VAR27, VAR31);
}
}
contract SimplePOAToken is VAR35 {
string public constant VAR36 = "";
string public constant VAR37 = "";
uint256 public constant VAR38 = 1800 * (10 ** uint256(VAR39));
uint8 public constant VAR39 = 18;
event FUN21(address VAR15, uint256 VAR40);
function FUN22()
public
{
VAR12 = VAR38;
VAR16[msg.sender] = VAR38;
Transfer(address(0), msg.sender, VAR38);
}
function ()
public
payable
{
VAR2.transfer(msg.value);
FUN21(msg.sender, msg.value);
}
}
0
---------------------------------
445 0x037a54aab062628c9bbae1fdb1583c195585fe41.sol
pragma solidity 0.5.4;
interface VAR1 {
function transfer(address VAR2, uint256 value) external returns (bool);
function FUN1(address VAR3, uint256 value) external returns (bool);
function FUN2(address VAR4, address VAR2, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR5) external view returns (uint256);
function FUN5(address VAR6, address VAR3) external view returns (uint256);
event Transfer(address indexed VAR4, address indexed VAR2, uint256 value);
event FUN6(address indexed VAR6, address indexed VAR3, uint256 value);
}
library VAR7 {
using SafeMath for uint256;
function FUN7(IERC20 VAR8, address VAR2, uint256 value) internal {
require(VAR8.transfer(VAR2, value));
}
function FUN8(IERC20 VAR8, address VAR4, address VAR2, uint256 value) internal {
require(VAR8.FUN2(VAR4, VAR2, value));
}
function FUN9(IERC20 VAR8, address VAR3, uint256 value) internal {
require((value == 0) || (VAR8.FUN5(msg.sender, VAR3) == 0));
require(VAR8.FUN1(VAR3, value));
}
function FUN10(IERC20 VAR8, address VAR3, uint256 value) internal {
uint256 VAR9 = VAR8.FUN5(address(this), VAR3).FUN11(value);
require(VAR8.FUN1(VAR3, VAR9));
}
function FUN12(IERC20 VAR8, address VAR3, uint256 value) internal {
uint256 VAR9 = VAR8.FUN5(address(this), VAR3).FUN13(value);
require(VAR8.FUN1(VAR3, VAR9));
}
}
library VAR10 {
function FUN14(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
if (VAR11 == 0) {
return 0;
}
uint256 VAR13 = VAR11 * VAR12;
require(VAR13 / VAR11 == VAR12);
return VAR13;
}
function FUN15(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 > 0);
uint256 VAR13 = VAR11 / VAR12;
return VAR13;
}
function FUN13(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 <= VAR11);
uint256 VAR13 = VAR11 - VAR12;
return VAR13;
}
function FUN11(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 + VAR12;
require(VAR13 >= VAR11);
return VAR13;
}
function FUN16(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 != 0);
return VAR11 % VAR12;
}
}
contract VAR14 {
address private VAR15;
event FUN17(address indexed VAR16, address indexed VAR17);
constructor () internal {
VAR15 = msg.sender;
emit FUN17(address(0), VAR15);
}
function FUN18() public view returns (address) {
return VAR15;
}
modifier onlyOwner() {
require(FUN19());
VAR18;
}
function FUN19() public view returns (bool) {
return msg.sender == VAR15;
}
function FUN20() public onlyOwner {
emit FUN17(VAR15, address(0));
VAR15 = address(0);
}
function FUN21(address VAR17) public onlyOwner {
FUN22(VAR17);
}
function FUN22(address VAR17) internal {
require(VAR17 != address(0));
emit FUN17(VAR15, VAR17);
VAR15 = VAR17;
}
}
contract TokenVesting is VAR14{
using SafeMath for uint256;
using SafeERC20 for VAR1;
struct VAR19{
uint256 VAR20;
uint256 VAR21;
uint256 VAR22;
uint256 VAR23;
uint256 VAR24;
bool VAR25;
}
mapping (address => VAR19) public VAR26;
uint256 private VAR27 = 2592000;
uint256 private VAR28 = 93312000;
bool private VAR29 = false;
IERC20 public VAR30;
event FUN23(address indexed VAR31, uint256 VAR32);
event FUN24(address indexed VAR31);
modifier FUN25() {
require(msg.sender==FUN18() || msg.sender == address(VAR30));
VAR18;
}
function FUN26(IERC20 VAR8) public onlyOwner returns(bool){
VAR30 = VAR8;
return true;
}
function FUN27(address VAR31, uint256 VAR32) public VAR33 returns(bool){
FUN28(VAR31, VAR32);
return true;
}
function FUN28(address VAR31, uint256 VAR32)  internal {
require(VAR31!=address(0));
VestedToken storage VAR34 = VAR26[VAR31];
VAR34.VAR20 = VAR27;
VAR34.VAR21 = VAR35.VAR36;
VAR34.VAR22 = VAR28;
VAR34.VAR24 = VAR32;
VAR34.VAR23 = 0;
VAR34.VAR25 = VAR29;
}
function FUN29(address VAR31, uint256 VAR32, uint256 VAR20, uint256 VAR22, uint256 VAR37 ) public VAR33  returns(bool){
FUN30(VAR31, VAR32, VAR20, VAR22, VAR37);
return true;
}
function FUN30(address VAR31, uint256 VAR32, uint256 VAR20, uint256 VAR22, uint256 VAR37) internal {
require(VAR31!=address(0));
require(VAR20<=VAR22);
VestedToken storage VAR34 = VAR26[VAR31];
VAR34.VAR20 = VAR20;
VAR34.VAR21 = VAR37;
VAR34.VAR22 = VAR22;
VAR34.VAR24 = VAR32;
VAR34.VAR23 = 0;
VAR34.VAR25 = false;
}
function FUN31() public returns(bool) {
FUN32(msg.sender);
return true;
}
function FUN32(address VAR31) public {
require(VAR31 != address(0));
VestedToken storage VAR34 = VAR26[VAR31];
uint256 VAR38 = FUN33(VAR31);
require(VAR38>0);
VAR34.VAR23 = VAR34.VAR23.FUN11(VAR38);
VAR30.FUN7(VAR31,VAR38);
emit FUN23(VAR31, VAR38);
}
function FUN33(address VAR31) internal view returns (uint256) {
return FUN34(VAR31).FUN13(VAR26[VAR31].VAR23);
}
function FUN34(address VAR31) internal view returns (uint256) {
VestedToken storage VAR34 = VAR26[VAR31];
uint256 VAR24 = VAR34.VAR24;
if(VAR35.VAR36 <  VAR34.VAR21.FUN11(VAR34.VAR20)){
return 0;
}else if(VAR35.VAR36 >= VAR34.VAR21.FUN11(VAR34.VAR22) || VAR34.VAR25){
return VAR24;
}else{
uint256 VAR39 = (VAR35.VAR36.FUN13(VAR34.VAR21)).FUN15(VAR34.VAR20);
return VAR24.FUN14(VAR39.FUN14(VAR34.VAR20)).FUN15(VAR34.VAR22);
}
}
function FUN35(address VAR31) public onlyOwner {
VestedToken storage VAR34 = VAR26[VAR31];
require(!VAR34.VAR25);
uint256 VAR40 = VAR34.VAR24;
uint256 VAR41 = FUN33(VAR31);
uint256 VAR42 = VAR40.FUN13(VAR41);
VAR34.VAR25 = true;
VAR34.VAR24 = VAR41;
VAR30.FUN7(FUN18(), VAR42);
emit FUN24(VAR31);
}
}
contract lcxToken is VAR1, VAR14{
using SafeMath for uint256;
mapping (address => uint256) private VAR43;
mapping (address => mapping (address => uint256)) private VAR44;
uint256 private VAR45;
TokenVesting public VAR46;
string public constant VAR47 = '';
string public constant VAR48 = '';
uint256 public constant VAR49 = 18;
constructor(uint256 VAR50) public{
VAR45 = VAR50.FUN14(10**VAR49);
VAR43[msg.sender] = VAR45;
emit Transfer(address(0), msg.sender, VAR45);
}
function FUN3() public view returns (uint256) {
return VAR45;
}
function FUN4(address VAR6) public view returns (uint256) {
return VAR43[VAR6];
}
function FUN5(address VAR6, address VAR3) public view returns (uint256) {
return VAR44[VAR6][VAR3];
}
function transfer(address VAR2, uint256 value) public returns (bool) {
FUN36(msg.sender, VAR2, value);
return true;
}
function FUN1(address VAR3, uint256 value) public returns (bool) {
FUN37(msg.sender, VAR3, value);
return true;
}
function FUN2(address VAR4, address VAR2, uint256 value) public returns (bool) {
FUN36(VAR4, VAR2, value);
FUN37(VAR4, msg.sender, VAR44[VAR4][msg.sender].FUN13(value));
return true;
}
function FUN38(address VAR3, uint256 VAR51) public returns (bool) {
FUN37(msg.sender, VAR3, VAR44[msg.sender][VAR3].FUN11(VAR51));
return true;
}
function FUN39(address VAR3, uint256 VAR52) public returns (bool) {
FUN37(msg.sender, VAR3, VAR44[msg.sender][VAR3].FUN13(VAR52));
return true;
}
function FUN40(uint256 value) public {
FUN41(msg.sender, value);
}
function FUN42(address VAR4, uint256 value) public {
FUN43(VAR4, value);
}
function FUN36(address VAR4, address VAR2, uint256 value) internal {
require(VAR2 != address(0));
VAR43[VAR4] = VAR43[VAR4].FUN13(value);
VAR43[VAR2] = VAR43[VAR2].FUN11(value);
emit Transfer(VAR4, VAR2, value);
}
function FUN41(address VAR31, uint256 value) internal {
require(VAR31 != address(0));
VAR45 = VAR45.FUN13(value);
VAR43[VAR31] = VAR43[VAR31].FUN13(value);
emit Transfer(VAR31, address(0), value);
}
function FUN37(address VAR6, address VAR3, uint256 value) internal {
require(VAR3 != address(0));
require(VAR6 != address(0));
VAR44[VAR6][VAR3] = value;
emit FUN6(VAR6, VAR3, value);
}
function FUN43(address VAR31, uint256 value) internal {
FUN41(VAR31, value);
FUN37(VAR31, msg.sender, VAR44[VAR31][msg.sender].FUN13(value));
}
function FUN44(TokenVesting VAR53) public onlyOwner returns(bool){
VAR46 = VAR53;
return true;
}
function FUN45(address VAR31, uint256 VAR32) public onlyOwner returns(bool){
VAR46.FUN27(VAR31, VAR32);
FUN36(msg.sender,address(VAR46), VAR32);
return true;
}
function FUN46(address VAR31, uint256 VAR32, uint256 VAR20, uint256 VAR22, uint256 VAR37) public onlyOwner returns(bool){
VAR46.FUN29(VAR31, VAR32, VAR20, VAR22, VAR37);
FUN36(msg.sender ,address(VAR46), VAR32);
return true;
}
function FUN47(address[] memory VAR54, uint256[] memory VAR55 ) public onlyOwner returns(bool){
require(VAR54.VAR56 == VAR55.VAR56);
for(uint256 VAR57=0;VAR57< VAR54.VAR56;VAR57++){
FUN36(msg.sender, VAR54[VAR57], VAR55[VAR57]);
}
return true;
}
}
0
---------------------------------
446 0x037c51c8756a217a74e25a4f40fc7641452bc57c.sol
pragma solidity 0.4.21;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
if (VAR2 == 0)
return 0;
VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
interface VAR5 {
function transfer(address VAR6, uint256 value) external returns (bool VAR7);
function FUN4(uint256 VAR8) external;
function FUN5(address VAR9) external returns (uint256 VAR10);
}
contract VAR11 {
address public VAR9;
address public VAR12;
uint256 public VAR13;
uint256 public VAR14;
uint256 public VAR15;
uint256 public VAR16;
uint256 public VAR17;
uint256 public VAR18;
Token public VAR19;
mapping(address => VAR20) public VAR21;
struct VAR20 {
bool VAR22;
uint256 VAR23;
bool VAR15;
}
event FUN6(address VAR6, uint VAR8);
modifier FUN7() { if (VAR24 >= VAR16) VAR25; }
modifier FUN8() { if (VAR24 >= VAR17) VAR25; }
modifier onlyOwner() { require(msg.sender == VAR9); VAR25; }
function FUN9(
address VAR26,
uint256 VAR27,
uint256 VAR28,
uint256 VAR29,
address VAR30
)
public
{
VAR9 = msg.sender;
VAR12 = VAR26;
VAR16 = VAR24 + VAR27 * 1 VAR31;
VAR17 = VAR24 + VAR28 * 1 VAR31;
VAR18 = VAR29;
VAR19 = FUN10(VAR30);
}
function() payable public {
require(VAR24 < VAR16);
require(VAR21[msg.sender].VAR22);
require(msg.value >= 0.01 VAR32);
uint256 VAR33 = VAR1.FUN1(msg.value, VAR18);
require(VAR33 <= VAR1.FUN2(VAR19.FUN5(this), VAR14));
VAR21[msg.sender].VAR23 = VAR1.FUN3(VAR21[msg.sender].VAR23, VAR33);
VAR13 = VAR1.FUN3(VAR13, msg.value);
VAR14 = VAR1.FUN3(VAR14, VAR33);
}
function FUN11(address VAR34) onlyOwner public {
VAR21[VAR34].VAR22 = true;
}
function FUN12(address VAR34) onlyOwner public {
VAR21[VAR34].VAR22 = false;
}
function FUN13(address[] VAR35) onlyOwner public {
for (uint VAR36 = 0; VAR36 < VAR35.VAR37; VAR36++) {
VAR21[VAR35[VAR36]].VAR22 = true;
}
}
function FUN14(address[] VAR35) onlyOwner public {
for (uint VAR36 = 0; VAR36 < VAR35.VAR37; VAR36++) {
VAR21[VAR35[VAR36]].VAR22 = false;
}
}
function FUN15() afterIcoDeadline public {
require(VAR12 == msg.sender);
VAR12.transfer(address(this).VAR10);
emit FUN6(VAR12, address(this).VAR10);
}
function FUN16()  onlyOwner afterIcoDeadline public {
uint256 VAR38 = VAR1.FUN2(VAR14, VAR15);
uint256 VAR39 = VAR1.FUN2(VAR19.FUN5(this), VAR38);
VAR19.FUN4(VAR39);
}
function FUN17() afterTokensClaimableDeadline public {
require(VAR21[msg.sender].VAR22);
require(!VAR21[msg.sender].VAR15);
VAR21[msg.sender].VAR15 = true;
uint256 VAR23 = VAR21[msg.sender].VAR23;
VAR19.transfer(msg.sender, VAR23);
VAR15 = VAR1.FUN3(VAR15, VAR23);
}
}
0
---------------------------------
447 0x038651c3e304c7764a3cab885195e04de3ae271e.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
address public VAR6;
event FUN5(address indexed VAR7, address indexed VAR8);
function FUN6() public {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR9;
}
function FUN7(address VAR8) onlyOwner public {
require(VAR8 != address(0));
FUN5(VAR6, VAR8);
VAR6 = VAR8;
}
}
contract VAR10 {
uint256 public VAR11;
function FUN8(address VAR12) public constant returns (uint256);
function transfer(address VAR13, uint256 value) public returns (bool);
event Transfer(address indexed VAR14, address indexed VAR13, uint256 value);
function FUN9(address VAR6, address VAR15) public constant returns (uint256);
function FUN10(address VAR14, address VAR13, uint256 value) public returns (bool);
function FUN11(address VAR15, uint256 value) public returns (bool);
event FUN12(address indexed VAR6, address indexed VAR15, uint256 value);
}
contract StandardToken is VAR10 {
using SafeMath for uint256;
mapping (address => uint256) VAR16;
mapping (address => mapping (address => uint256)) VAR17;
function transfer(address VAR18, uint256 VAR19) public returns (bool) {
require(VAR18 != address(0));
require(VAR19 > 0);
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR19);
VAR16[VAR18] = VAR16[VAR18].FUN4(VAR19);
Transfer(msg.sender, VAR18, VAR19);
return true;
}
function FUN10(address VAR20, address VAR18, uint256 VAR19) public returns (bool) {
require(VAR20 != address(0));
require(VAR18 != address(0));
uint256 VAR21 = VAR17[VAR20][msg.sender];
VAR16[VAR20] = VAR16[VAR20].FUN3(VAR19);
VAR16[VAR18] = VAR16[VAR18].FUN4(VAR19);
VAR17[VAR20][msg.sender] = VAR21.FUN3(VAR19);
Transfer(VAR20, VAR18, VAR19);
return true;
}
function FUN8(address VAR22) public constant returns (uint256 VAR23) {
return VAR16[VAR22];
}
function FUN11(address VAR24, uint256 VAR19) public returns (bool) {
VAR17[msg.sender][VAR24] = VAR19;
FUN12(msg.sender, VAR24, VAR19);
return true;
}
function FUN9(address VAR22, address VAR24) public constant returns (uint256 VAR25) {
return VAR17[VAR22][VAR24];
}
}
contract CreditAsiaCoin is VAR26, VAR5 {
string public VAR27 = "";
string public VAR28 = "";
uint public VAR29 = 18;
uint public constant VAR30       = 10000000000e18;
uint public constant VAR31    =  10000000000e18;
address public constant VAR32    = 0xbb90E8310a78f99aB776985A9B7ecDf39ace98e9;
mapping(address => uint256) public VAR33;
mapping(address => uint256) public VAR34;
mapping(address => uint256) public VAR35;
mapping(address => uint256) public VAR36;
modifier FUN13(address VAR37, uint256 VAR19) {
require(VAR37 != address(0));
uint256 VAR25 = VAR16[VAR37].FUN3(VAR19);
uint256 VAR38 = 0;
if (VAR33[VAR37] > 0) {
VAR38 = VAR38.FUN4(FUN14(VAR37));
}
if (VAR34[VAR37] > 0) {
VAR38 = VAR38.FUN4(FUN15(VAR37));
}
require(VAR25 >= VAR38);
VAR9;
}
event FUN16(string VAR39, address indexed VAR13, uint256 value, uint256 VAR40);
function FUN17() public {
VAR16[msg.sender] = VAR30;
VAR11 = VAR30;
transfer(VAR32, VAR31);
}
function FUN14(address VAR41)
public
constant
returns (uint256)
{
uint256 VAR42 = VAR35[VAR41];
uint256 VAR43 = VAR33[VAR41];
if (VAR44 <= VAR42 +  (90 * 1 VAR45 )) {return VAR43;}
return 0;
}
function FUN15(address VAR46)
public
constant
returns (uint256)
{
uint256 VAR47 = VAR36[VAR46];
uint256 VAR43 = VAR34[VAR46];
if (VAR44 <= VAR47) {return VAR43;}
if (VAR44 <= VAR47 + 90 VAR45) {return VAR43;}
return 0;
}
function FUN18(address VAR41, uint256 VAR19, uint256 VAR48)
public
onlyOwner
{
require(VAR41 != address(0));
VAR33[VAR41] = VAR19;
VAR35[VAR41] = VAR48;
FUN16("", VAR41, VAR19, VAR48);
}
function FUN19(address VAR46, uint256 VAR19, uint256 VAR49)
public
onlyOwner
{
require(VAR46 != address(0));
VAR34[VAR46] = VAR19;
VAR36[VAR46] = VAR49;
FUN16("", VAR46, VAR19, VAR49);
}
function transfer(address VAR18, uint VAR19)
public
FUN13(msg.sender, VAR19)
returns (bool VAR50)
{
return super.transfer(VAR18, VAR19);
}
function FUN10(address VAR20, address VAR18, uint VAR19)
public
FUN13(VAR20, VAR19)
returns (bool VAR50)
{
return super.FUN10(VAR20, VAR18, VAR19);
}
}
0
---------------------------------
448 0x0389a06b028526b05966c287370bebefa0082176.sol
contract VAR1 {
struct VAR2{
address VAR3;
uint VAR4;
uint VAR5;
}
VAR2[] public VAR6;
uint public VAR7 = 0;
uint public VAR8 = 0;
uint public VAR9 = 0;
uint public VAR10 = 0;
uint public VAR11 = 0;
address public VAR12;
address public VAR13;
modifier VAR14 {
if (msg.sender == VAR12)
VAR15
}
function FUN1() {
VAR12 = msg.sender;
VAR13 = VAR12;
}
function() {
FUN2();
}
function FUN2() {
if (msg.sender == VAR13) {
VAR7 = msg.value;
}
else {
if (VAR7 != 0) {
uint VAR5;
uint VAR16 = VAR7;
uint VAR17;
VAR10 += VAR16;
if (VAR6.VAR18 != 0 && VAR16 != 0) {
for (uint VAR19 = 0; VAR19 < VAR6.VAR18; VAR19++) {
VAR17 = VAR6[VAR19].VAR4 + VAR6[VAR19].VAR5;
VAR5 = VAR16 * VAR17 / VAR11;
VAR6[VAR19].VAR5 += VAR5;
}
}
VAR11 += VAR16;
}
uint VAR20 = msg.value;
bool VAR21 = false;
VAR9 += VAR20;
VAR11 += VAR20;
for (uint VAR22 = 0; VAR22 < VAR6.VAR18; VAR22++) {
if (msg.sender == VAR6[VAR22].VAR3) {
VAR6[VAR22].VAR4 += VAR20;
VAR21 = true;
break;
}
}
if (VAR21 == false) {
VAR8 = VAR6.VAR18 + 1;
VAR6.VAR18 += 1;
VAR6[VAR6.VAR18 - 1].VAR3 = msg.sender;
VAR6[VAR6.VAR18 - 1].VAR4 = VAR20;
VAR6[VAR6.VAR18 - 1].VAR5 = 0;
}
}
}
function FUN3(uint VAR23) {
if (msg.sender == VAR6[VAR23].VAR3) {
uint VAR24 = VAR6[VAR23].VAR5;
if (VAR24 != 0) {
VAR6[VAR23].VAR3.FUN4(VAR24);
VAR6[VAR23].VAR5 = 0;
VAR10 -= VAR24;
VAR11 -= VAR24;
}
}
}
function FUN5() VAR14 {
VAR12.FUN4(this.VAR25);
}
function FUN6 (address VAR26) VAR14 {
VAR13 = VAR26;
}
}
0
---------------------------------
449 0x038da599a137f89f49b43cd0d561d5e159058b60.sol
pragma VAR1 ^0.4.17;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
require((VAR5 = VAR3 - VAR4) < VAR3);
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR5) {
require((VAR5 = VAR3 + VAR4) > VAR3);
}
}
contract VAR6 {
using SafeMathMod for uint256;
string constant public VAR7 = "";
string constant public VAR8 = "";
uint8 constant public VAR9 = 8;
uint256 constant public VAR10 = 21000000e8;
uint256 constant private VAR11 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
mapping (address => uint256) public VAR12;
mapping (address => mapping (address => uint256)) public VAR13;
event Transfer(address indexed VAR14, address indexed VAR15, uint256 VAR16);
event FUN3(address indexed VAR17, address indexed VAR14, address indexed VAR15, uint256 VAR16);
event FUN4(address indexed VAR18, address indexed VAR17, uint256 VAR16);
function FUN5() public {VAR12[msg.sender] = VAR10;}
function transfer(address VAR15, uint256 VAR16) public returns (bool VAR19) {
require(VAR15 != address(0));
require(FUN6(VAR15));
VAR12[msg.sender] = VAR12[msg.sender].FUN1(VAR16);
VAR12[VAR15] = VAR12[VAR15].FUN2(VAR16);
Transfer(msg.sender, VAR15, VAR16);
return true;
}
function FUN7(address VAR14, address VAR15, uint256 VAR16) public returns (bool VAR19) {
require(VAR15 != address(0));
require(VAR15 != address(this));
uint256 VAR20 = VAR13[VAR14][msg.sender];
require(VAR16 <= VAR20 || VAR14 == msg.sender);
VAR12[VAR15] = VAR12[VAR15].FUN2(VAR16);
VAR12[VAR14] = VAR12[VAR14].FUN1(VAR16);
if (VAR13[VAR14][msg.sender] != VAR11 && VAR14 != msg.sender) {
VAR13[VAR14][msg.sender] = VAR13[VAR14][msg.sender].FUN1(VAR16);
}
Transfer(VAR14, VAR15, VAR16);
return true;
}
function FUN8(address[] VAR21, uint256[] VAR22) public {
require(VAR21.VAR23 <= 255);
require(VAR21.VAR23 == VAR22.VAR23);
for (uint8 VAR24 = 0; VAR24 < VAR21.VAR23; VAR24++) {
transfer(VAR21[VAR24], VAR22[VAR24]);
}
}
function FUN9(address VAR14, address[] VAR21, uint256[] VAR22) public {
require(VAR21.VAR23 <= 255);
require(VAR21.VAR23 == VAR22.VAR23);
for (uint8 VAR24 = 0; VAR24 < VAR21.VAR23; VAR24++) {
FUN7(VAR14, VAR21[VAR24], VAR22[VAR24]);
}
}
function FUN10(address VAR17, uint256 VAR16) public returns (bool VAR19) {
require(VAR17 != address(0));
VAR13[msg.sender][VAR17] = VAR16;
FUN4(msg.sender, VAR17, VAR16);
return true;
}
function FUN11(address VAR18, address VAR17) public view returns (uint256 VAR25) {
VAR25 = VAR13[VAR18][VAR17];
}
function FUN6(address VAR26) private view returns (bool) {
uint VAR23;
VAR27 {
VAR23 := FUN12(VAR26)
}
return (VAR23 == 0);
}
function() public payable {revert();}
}
0
---------------------------------
450 0x038ed35dde8f63b457d91e874f25e7ae41e15da8.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 28857600;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xe99988705186AE5f10430ab25A8CD1C10fe959e9;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
451 0x03966330e7f60c95d2d8dd043735eea901c5e4e0.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1(bytes4 VAR3)
external
view
returns (bool);
}
contract IERC721 is VAR2 {
event Transfer(
address indexed VAR4,
address indexed VAR5,
uint256 indexed VAR6
);
event FUN2(
address indexed VAR7,
address indexed VAR8,
uint256 indexed VAR6
);
event FUN3(
address indexed VAR7,
address indexed VAR9,
bool VAR8
);
function FUN4(address VAR7) public view returns (uint256 VAR10);
function FUN5(uint256 VAR6) public view returns (address VAR7);
function FUN6(address VAR5, uint256 VAR6) public;
function FUN7(uint256 VAR6)
public view returns (address VAR9);
function FUN8(address VAR9, bool VAR11) public;
function FUN9(address VAR7, address VAR9)
public view returns (bool);
function FUN10(address VAR4, address VAR5, uint256 VAR6) public;
function FUN11(address VAR4, address VAR5, uint256 VAR6)
public;
function FUN11(
address VAR4,
address VAR5,
uint256 VAR6,
bytes VAR12
)
public;
}
contract VAR13 {
function FUN12(
address VAR9,
address VAR4,
uint256 VAR6,
bytes VAR12
)
public
returns(bytes4);
}
library VAR14 {
function FUN13(address VAR15) internal view returns (bool) {
uint256 VAR16;
VAR17 { VAR16 := FUN14(VAR15) }
return VAR16 > 0;
}
}
contract ERC165 is VAR2 {
bytes4 private constant VAR18 = 0x01ffc9a7;
mapping(bytes4 => bool) private VAR19;
constructor()
internal
{
FUN15(VAR18);
}
function FUN1(bytes4 VAR3)
external
view
returns (bool)
{
return VAR19[VAR3];
}
function FUN15(bytes4 VAR3)
internal
{
require(VAR3 != 0xffffffff);
VAR19[VAR3] = true;
}
}
contract ERC721 is VAR20, VAR21 {
using SafeMath for uint256;
using Address for address;
bytes4 private constant VAR22 = 0x150b7a02;
mapping (uint256 => address) private VAR23;
mapping (uint256 => address) private VAR24;
mapping (address => uint256) private VAR25;
mapping (address => mapping (address => bool)) private VAR26;
bytes4 private constant VAR27 = 0x80ac58cd;
constructor()
public
{
FUN15(VAR27);
}
function FUN4(address VAR7) public view returns (uint256) {
require(VAR7 != address(0));
return VAR25[VAR7];
}
function FUN5(uint256 VAR6) public view returns (address) {
address VAR7 = VAR23[VAR6];
require(VAR7 != address(0));
return VAR7;
}
function FUN6(address VAR5, uint256 VAR6) public {
address VAR7 = FUN5(VAR6);
require(VAR5 != VAR7);
require(msg.sender == VAR7 || FUN9(VAR7, msg.sender));
VAR24[VAR6] = VAR5;
emit FUN2(VAR7, VAR5, VAR6);
}
function FUN7(uint256 VAR6) public view returns (address) {
require(FUN16(VAR6));
return VAR24[VAR6];
}
function FUN8(address VAR5, bool VAR8) public {
require(VAR5 != msg.sender);
VAR26[msg.sender][VAR5] = VAR8;
emit FUN3(msg.sender, VAR5, VAR8);
}
function FUN9(
address VAR7,
address VAR9
)
public
view
returns (bool)
{
return VAR26[VAR7][VAR9];
}
function FUN10(
address VAR4,
address VAR5,
uint256 VAR6
)
public
{
require(FUN17(msg.sender, VAR6));
require(VAR5 != address(0));
FUN18(VAR4, VAR6);
FUN19(VAR4, VAR6);
FUN20(VAR5, VAR6);
emit Transfer(VAR4, VAR5, VAR6);
}
function FUN11(
address VAR4,
address VAR5,
uint256 VAR6
)
public
{
FUN11(VAR4, VAR5, VAR6, "");
}
function FUN11(
address VAR4,
address VAR5,
uint256 VAR6,
bytes VAR28
)
public
{
FUN10(VAR4, VAR5, VAR6);
require(FUN21(VAR4, VAR5, VAR6, VAR28));
}
function FUN16(uint256 VAR6) internal view returns (bool) {
address VAR7 = VAR23[VAR6];
return VAR7 != address(0);
}
function FUN17(
address VAR29,
uint256 VAR6
)
internal
view
returns (bool)
{
address VAR7 = FUN5(VAR6);
return (
VAR29 == VAR7 ||
FUN7(VAR6) == VAR29 ||
FUN9(VAR7, VAR29)
);
}
function FUN22(address VAR5, uint256 VAR6) internal {
require(VAR5 != address(0));
FUN20(VAR5, VAR6);
emit Transfer(address(0), VAR5, VAR6);
}
function FUN23(address VAR7, uint256 VAR6) internal {
FUN18(VAR7, VAR6);
FUN19(VAR7, VAR6);
emit Transfer(VAR7, address(0), VAR6);
}
function FUN20(address VAR5, uint256 VAR6) internal {
require(VAR23[VAR6] == address(0));
VAR23[VAR6] = VAR5;
VAR25[VAR5] = VAR25[VAR5].FUN24(1);
}
function FUN19(address VAR4, uint256 VAR6) internal {
require(FUN5(VAR6) == VAR4);
VAR25[VAR4] = VAR25[VAR4].FUN25(1);
VAR23[VAR6] = address(0);
}
function FUN21(
address VAR4,
address VAR5,
uint256 VAR6,
bytes VAR28
)
internal
returns (bool)
{
if (!VAR5.FUN13()) {
return true;
}
bytes4 VAR30 = FUN26(VAR5).FUN12(
msg.sender, VAR4, VAR6, VAR28);
return (VAR30 == VAR22);
}
function FUN18(address VAR7, uint256 VAR6) private {
require(FUN5(VAR6) == VAR7);
if (VAR24[VAR6] != address(0)) {
VAR24[VAR6] = address(0);
}
}
}
contract VAR31 {
address private VAR32;
event FUN27(
address indexed VAR33,
address indexed VAR34
);
constructor() internal {
VAR32 = msg.sender;
emit FUN27(address(0), VAR32);
}
function FUN28() public view returns(address) {
return VAR32;
}
modifier onlyOwner() {
require(FUN29());
VAR35;
}
function FUN29() public view returns(bool) {
return msg.sender == VAR32;
}
function FUN30() public onlyOwner {
emit FUN27(VAR32, address(0));
VAR32 = address(0);
}
function FUN31(address VAR34) public onlyOwner {
FUN32(VAR34);
}
function FUN32(address VAR34) internal {
require(VAR34 != address(0));
emit FUN27(VAR32, VAR34);
VAR32 = VAR34;
}
}
library VAR36 {
function FUN33(uint256 VAR37, uint256 VAR38) internal pure returns (uint256) {
if (VAR37 == 0) {
return 0;
}
uint256 VAR39 = VAR37 * VAR38;
require(VAR39 / VAR37 == VAR38);
return VAR39;
}
function FUN34(uint256 VAR37, uint256 VAR38) internal pure returns (uint256) {
require(VAR38 > 0);
uint256 VAR39 = VAR37 / VAR38;
return VAR39;
}
function FUN25(uint256 VAR37, uint256 VAR38) internal pure returns (uint256) {
require(VAR38 <= VAR37);
uint256 VAR39 = VAR37 - VAR38;
return VAR39;
}
function FUN24(uint256 VAR37, uint256 VAR38) internal pure returns (uint256) {
uint256 VAR39 = VAR37 + VAR38;
require(VAR39 >= VAR37);
return VAR39;
}
function FUN35(uint256 VAR37, uint256 VAR38) internal pure returns (uint256) {
require(VAR38 != 0);
return VAR37 % VAR38;
}
}
contract CryptoHeart is VAR40, VAR31 {
function FUN36(address VAR41, uint256 VAR6) public onlyOwner {
FUN22(VAR41, VAR6);
}
}
0
---------------------------------
452 0x03a71d713cbcfcb27a4172117718e63f50f571a0.sol
pragma VAR1 ^0.5.6;
library VAR2{
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint){
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint){
uint VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint){
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint){
uint VAR5 = VAR3 + VAR4; assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
constructor() public{
VAR7 = msg.sender;
}
modifier onlyOwner(){
require(msg.sender == VAR7);
VAR10;
}
function FUN6(address VAR9) onlyOwner public{
require(VAR9 != address(0));
emit FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract ITCMoney is VAR6{
using SafeMath for uint;
string public constant VAR11 = "";
string public constant VAR12 = "";
uint32 public constant VAR13 = 18;
address payable public VAR14 = address(0);
address public constant VAR15   = 0xaEA6949B27C44562Dd446c2C44f403cF6D13a2fD;
address public constant VAR16    = 0xe0b70c54a1baa2847e210d019Bb8edc291AEA5c7;
address public constant VAR17  = 0x95E1f32981F909ce39d45bF52C9108f47e0FCc50;
uint public VAR18 = 0;
uint public VAR19 = 17000000000 * 1 VAR20;
mapping(address => uint) VAR21;
mapping (address => mapping (address => uint)) internal VAR22;
bool public VAR23 = false;
mapping(address => bool) internal VAR24;
uint public VAR25 = 170 * 1 VAR26;
uint private VAR27 = 0;
uint[2][] private VAR28 = [
[1538784000, 100],
[1554422400,  19],
[1564617600,  17],
[1572566400,   0]
];
uint public VAR29 = 0;
mapping(address => uint) VAR30;
bool public VAR31 = true;
uint[2][] private VAR32 = [
[FUN7(2000),    500],
[FUN7(8000),    700],
[FUN7(17000),  1000],
[FUN7(50000),  1500],
[FUN7(100000), 1750],
[FUN7(150000), 2000],
[FUN7(500000), 2500]
];
uint[2][] private VAR33 = [
[1535673600, 2000],
[1535760000, 1800],
[1538784000, 1500],
[1541462400, 1000],
[1544054400,  800],
[1546732800,  600],
[1549411200,  300],
[1551830400,  200]
];
uint private VAR34 = 1554508800;
uint public VAR35 = 0;
event Transfer(address indexed VAR36, address indexed VAR37, uint value);
event FUN8(address indexed VAR7, address indexed VAR38, uint value);
event FUN9(address indexed VAR8, address indexed VAR9);
event FUN10();
event FUN11(address indexed VAR37);
event FUN12();
event FUN13(address indexed VAR37, uint value);
event FUN14(uint value);
event FUN15(uint VAR39, uint VAR40);
event FUN16(uint value);
event FUN17(uint VAR25);
function FUN18(address VAR41) public view returns (uint){
return VAR21[VAR41];
}
function transfer(address VAR42, uint VAR43) public returns (bool){
require(VAR42 != address(0));
require(VAR23 || VAR42 == VAR17 || VAR24[msg.sender]);
require(VAR43 > 0 && VAR43 <= VAR21[msg.sender]);
VAR21[msg.sender] = VAR21[msg.sender].FUN3(VAR43);
VAR21[VAR42] = VAR21[VAR42].FUN4(VAR43);
emit Transfer(msg.sender, VAR42, VAR43);
return true;
}
function FUN19(address VAR44, address VAR42, uint VAR43) public returns (bool){
require(VAR42 != address(0));
require(VAR23 || VAR42 == VAR17 || VAR24[VAR44]);
require(VAR43 > 0 && VAR43 <= VAR21[VAR44] && VAR43 <= VAR22[VAR44][msg.sender]);
VAR21[VAR44] = VAR21[VAR44].FUN3(VAR43);
VAR21[VAR42] = VAR21[VAR42].FUN4(VAR43);
VAR22[VAR44][msg.sender] = VAR22[VAR44][msg.sender].FUN3(VAR43);
emit Transfer(VAR44, VAR42, VAR43);
return true;
}
function FUN20(address VAR45, uint VAR43) public returns (bool){
VAR22[msg.sender][VAR45] = VAR43;
emit FUN8(msg.sender, VAR45, VAR43);
return true;
}
function FUN21(address VAR41, address VAR45) public view returns (uint){
return VAR22[VAR41][VAR45];
}
function FUN22(address VAR45, uint VAR46) public returns (bool){
VAR22[msg.sender][VAR45] = VAR22[msg.sender][VAR45].FUN4(VAR46);
emit FUN8(msg.sender, VAR45, VAR22[msg.sender][VAR45]);
return true;
}
function FUN23(address VAR45, uint VAR47) public returns (bool){
uint VAR48 = VAR22[msg.sender][VAR45];
if(VAR47 > VAR48){
VAR22[msg.sender][VAR45] = 0;
}else{
VAR22[msg.sender][VAR45] = VAR48.FUN3(VAR47);
}
emit FUN8(msg.sender, VAR45, VAR22[msg.sender][VAR45]);
return true;
}
function FUN24(address payable VAR49) onlyOwner public{
require(VAR49 != address(0));
emit FUN9(VAR14, VAR49);
VAR14 = VAR49;
}
function FUN25() onlyOwner public{
VAR23 = true;
emit FUN10();
}
function FUN26(address VAR42) onlyOwner public{
VAR24[VAR42] = true;
emit FUN11(VAR42);
}
function FUN27() onlyOwner public{
VAR31 = false;
emit FUN12();
}
function FUN28(address VAR42, uint VAR43) private returns (bool){
uint VAR50 = VAR43.FUN1(3).FUN2(87);
uint VAR51 = VAR43.FUN1(10).FUN2(87);
uint VAR52 = VAR43.FUN4(VAR50).FUN4(VAR51);
require(VAR52 <= VAR19);
VAR19 = VAR19.FUN3(VAR52);
VAR18 = VAR18.FUN4(VAR52);
VAR21[VAR42] = VAR21[VAR42].FUN4(VAR43);
VAR21[VAR15] = VAR21[VAR15].FUN4(VAR50);
VAR21[VAR16] = VAR21[VAR16].FUN4(VAR51);
emit Transfer(address(0), VAR42, VAR43);
emit Transfer(address(0), VAR15, VAR50);
emit Transfer(address(0), VAR16, VAR51);
return true;
}
function FUN29(address VAR42, uint VAR43) onlyOwner public returns (bool){
return FUN28(VAR42, VAR43);
}
function FUN29(address[] memory VAR42, uint[] memory VAR43) onlyOwner public returns (bool){
require(VAR42.VAR53 == VAR43.VAR53);
uint VAR54 = VAR42.VAR53;
for(uint VAR55 = 0; VAR55 < VAR54; VAR55++){
if(!FUN28(VAR42[VAR55], VAR43[VAR55])){
return false;
}
}
return true;
}
function FUN30(address VAR41) public view returns (uint){
return VAR30[VAR41];
}
function FUN31(address VAR42, uint VAR43) onlyOwner public{
VAR30[VAR42] = VAR30[VAR42].FUN4(VAR43);
emit FUN13(VAR42, VAR43);
}
function FUN31(address[] memory VAR42, uint[] memory VAR43) onlyOwner public{
require(VAR42.VAR53 == VAR43.VAR53);
uint VAR54 = VAR42.VAR53;
for(uint VAR55 = 0; VAR55 < VAR54; VAR55++){
VAR30[VAR42[VAR55]] = VAR30[VAR42[VAR55]].FUN4(VAR43[VAR55]);
emit FUN13(VAR42[VAR55], VAR43[VAR55]);
}
}
function FUN32(uint VAR56) onlyOwner public{
VAR29 = VAR56;
emit FUN14(VAR56);
}
function FUN33(uint VAR57, uint VAR56) onlyOwner public{
VAR28.FUN34([VAR57, VAR56]);
emit FUN15(VAR57, VAR56);
}
function FUN35(uint VAR43) onlyOwner public{
VAR35 = VAR43;
emit FUN16(VAR43);
}
function FUN36() public returns (uint){
uint VAR58 = VAR25;
uint VAR59 = 0;
uint VAR54 = VAR28.VAR53;
for(uint VAR55 = 0; VAR55 < VAR54; VAR55++){
if(VAR60 > VAR28[VAR55][0] && VAR28[VAR55][1] > 0){
uint VAR61 = VAR60;
if(VAR55 + 1 < VAR54 && VAR61 > VAR28[VAR55 + 1][0]){
VAR61 = VAR28[VAR55 + 1][0];
}
uint VAR62 = (VAR61 - VAR28[VAR55][0]) / 1 VAR63;
VAR59 = VAR59 + VAR62;
if(VAR62 > 0 && VAR59 > VAR27){
for(uint VAR64 = VAR27; VAR64 < VAR59; VAR64++){
VAR25 = VAR25 * (10000 + VAR28[VAR55][1]) / 10000;
}
VAR27 = VAR59;
}
}
}
if(VAR58 != VAR25){
emit FUN17(VAR25);
}
return VAR25;
}
function () external payable {
require(msg.VAR65.VAR53 == 0);
require(msg.value > 0);
require(VAR29 > 0);
uint VAR66 = (msg.value * VAR29 * 1 VAR26) / FUN36();
uint VAR67 = (msg.value * VAR29) / 10000 / 1 VAR20;
uint VAR68 = VAR30[msg.sender].FUN4(VAR67);
emit FUN13(msg.sender, VAR67);
uint VAR54 = 0;
uint VAR55 = 0;
uint VAR69 = 0;
uint VAR70 = 0;
if(VAR35 > 0){
VAR70 = VAR66.FUN1(VAR35).FUN2(10000);
}else if(VAR60 < VAR34){
VAR54 = VAR33.VAR53;
VAR69 = 0;
for(VAR55 = 0; VAR55 < VAR54; VAR55++){
if(VAR60 >= VAR33[VAR55][0]){
VAR69 = VAR33[VAR55][1];
}else{
break;
}
}
if(VAR69 > 0){
VAR70 = VAR66.FUN1(VAR69).FUN2(10000);
}
}
if(VAR31){
VAR54 = VAR32.VAR53;
VAR69 = 0;
for(VAR55 = 0; VAR55 < VAR54; VAR55++){
if(VAR68 >= VAR32[VAR55][0]){
VAR69 = VAR32[VAR55][1];
}else{
break;
}
}
if(VAR69 > 0){
VAR70 = VAR70.FUN4(VAR66.FUN1(VAR69).FUN2(10000));
}
}
VAR66 = VAR66.FUN4(VAR70);
uint VAR50 = VAR66.FUN1(3).FUN2(87);
uint VAR51 = VAR66.FUN1(10).FUN2(87);
uint VAR52 = VAR66.FUN4(VAR50).FUN4(VAR51);
require(VAR52 <= VAR19);
VAR19 = VAR19.FUN3(VAR52);
VAR18 = VAR18.FUN4(VAR52);
VAR21[msg.sender] = VAR21[msg.sender].FUN4(VAR66);
VAR30[msg.sender] = VAR68;
VAR21[VAR15] = VAR21[VAR15].FUN4(VAR50);
VAR21[VAR16] = VAR21[VAR16].FUN4(VAR51);
VAR14.transfer(msg.value);
emit Transfer(address(0), msg.sender, VAR66);
emit Transfer(address(0), VAR15, VAR50);
emit Transfer(address(0), VAR16, VAR51);
}
}
0
---------------------------------
453 0x03b267325193fd0c15ca0d2a693e54213c2afcb6.sol
pragma VAR1 ^0.4.26;
contract VAR2 {
mapping (address => uint256) VAR3;
address public VAR4;
string public VAR5;
string public VAR6;
uint8 public VAR7 = 18;
uint256 public VAR8;
mapping (address => mapping (address => uint256)) VAR9;
constructor() public {
uint256 VAR10 = 10000000000;
VAR8 = VAR10 * 10 ** uint256(VAR7);
VAR3[msg.sender] = VAR8;
VAR5 = "";
VAR6 = "";
}
function FUN1(address VAR11) public constant returns (uint256 VAR12) {
return VAR3[VAR11];
}
function transfer(address VAR13, uint256 VAR14) public returns (bool VAR15) {
require(VAR14 > 0 );
require(VAR3[msg.sender] >= VAR14);
require(VAR3[VAR13] + VAR14 > VAR3[VAR13]);
VAR3[msg.sender] -= VAR14;
VAR3[VAR13] += VAR14;
emit Transfer(msg.sender, VAR13, VAR14);
return true;
}
function FUN2(address VAR16, address VAR13, uint256 VAR14) public returns (bool VAR15) {
require(VAR3[VAR16] >= VAR14);
require(VAR3[VAR13] + VAR14 >= VAR3[VAR13]);
require(VAR14 <= VAR9[VAR16][msg.sender]);
VAR3[VAR16] -= VAR14;
VAR3[VAR13] += VAR14;
VAR9[VAR16][msg.sender] -= VAR14;
emit Transfer(VAR16, VAR13, VAR14);
return true;
}
function FUN3(address VAR17, uint256 VAR14) public returns (bool VAR15) {
require(VAR3[msg.sender] >= VAR14);
VAR9[msg.sender][VAR17] = VAR14;
emit FUN4(msg.sender, VAR17, VAR14);
return true;
}
function FUN5(address VAR11, address VAR17) public constant returns (uint256 VAR18) {
return VAR9[VAR11][VAR17];
}
function () private {
revert();
}
event Transfer(address indexed VAR16, address indexed VAR13, uint256 VAR14);
event FUN4(address indexed VAR11, address indexed VAR17, uint256 VAR14);
}
0
---------------------------------
454 0x03b7945808bb97307f31a311f2c9d3fce3d49a1c.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
using SafeMath for uint256;
mapping (address => uint256) public VAR3;
mapping (address => uint256) public VAR4;
mapping (address => uint256) public VAR5;
address VAR6 = 0xEDa159d4AD09bEdeB9fDE7124E0F5304c30F7790;
address VAR7 = 0x6a5D9648381b90AF0e6881c26739efA4379c19B2;
address VAR8 = 0xF57924672D6dBF0336c618fDa50E284E02715000;
function FUN1(address VAR9) public payable {
require(msg.value >= .05 VAR10);
if(FUN2(msg.sender) > 0){
uint256 VAR11 = FUN2(msg.sender);
VAR4[msg.sender] = VAR12;
msg.sender.transfer(VAR11);
}
uint256 VAR13 = msg.value;
uint256 VAR14 = VAR15.FUN3(VAR13, 40);
if(VAR9 != msg.sender && VAR9 != 0x1){
VAR5[VAR9] = VAR15.FUN4(VAR5[VAR9], VAR14);
}
VAR6.transfer(msg.value.FUN3(100).FUN5(5));
VAR7.transfer(msg.value.FUN3(100).FUN5(3));
VAR8.transfer(msg.value.FUN3(100).FUN5(1));
VAR3[msg.sender] = VAR15.FUN4(VAR3[msg.sender], VAR13);
VAR4[msg.sender] = VAR12;
}
function FUN6() public{
uint256 VAR11 = FUN2(msg.sender);
require(VAR11 > 0);
VAR4[msg.sender] = VAR12;
msg.sender.transfer(VAR11);
}
function FUN7() public view returns(uint256){
return FUN2(msg.sender);
}
function FUN2(address VAR16) public view returns(uint256){
uint256 VAR17 = VAR15.FUN8(VAR12, VAR4[VAR16]);
return VAR15.FUN3(VAR15.FUN5(VAR17, VAR3[VAR16]), 4800000);
}
function FUN9() public {
uint256 VAR11 = FUN2(msg.sender);
require(VAR11 > 0);
VAR4[msg.sender] = VAR12;
VAR3[msg.sender] = VAR15.FUN4(VAR3[msg.sender], VAR11);
}
function FUN10() public view returns(uint256){
return VAR5[msg.sender];
}
function FUN11() public {
require(VAR5[msg.sender] > 0);
uint256 VAR14 = VAR5[msg.sender];
VAR5[msg.sender] = 0;
msg.sender.transfer(VAR14);
}
function FUN12() public view returns(uint256){
return VAR3[msg.sender];
}
function FUN13() public view returns(uint256){
return address(this).VAR18;
}
function FUN14(uint256 VAR19, uint256 VAR20) private pure returns (uint256) {
return VAR19 < VAR20 ? VAR19 : VAR20;
}
function FUN15(uint256 VAR19, uint256 VAR20) private pure returns (uint256) {
return VAR19 > VAR20 ? VAR19 : VAR20;
}
}
library VAR15 {
function FUN5(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
if (VAR19 == 0) {
return 0;
}
uint256 VAR21 = VAR19 * VAR20;
assert(VAR21 / VAR19 == VAR20);
return VAR21;
}
function FUN3(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
uint256 VAR21 = VAR19 / VAR20;
return VAR21;
}
function FUN8(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
assert(VAR20 <= VAR19);
return VAR19 - VAR20;
}
function FUN4(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
uint256 VAR21 = VAR19 + VAR20;
assert(VAR21 >= VAR19);
return VAR21;
}
}
0
---------------------------------
455 0x03b7dcf4e018031c39f21a6e99632ccbf72c79a2.sol
pragma VAR1 ^0.4.26;
contract VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR3 >= VAR4);
return VAR3 - VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4)internal pure returns (uint256){
return VAR3 / VAR4;
}
function FUN5(uint256 VAR3, uint256 VAR4)internal pure returns (uint256){
return (VAR3 + VAR4 - 1) / VAR4;
}
}
contract VAR6 {
mapping (address => uint256) VAR7;
address public VAR8;
string public VAR9;
string public VAR10;
uint8 public VAR11 = 18;
uint256 public VAR12;
mapping (address => mapping (address => uint256)) VAR13;
constructor() public {
uint256 VAR14 = 10000000000;
VAR12 = VAR14 * 10 ** uint256(VAR11);
VAR7[msg.sender] = VAR12;
VAR9 = "";
VAR10 = "";
}
function FUN6(address VAR15) public constant returns (uint256 VAR16) {
return VAR7[VAR15];
}
function transfer(address VAR17, uint256 VAR18) public returns (bool VAR19) {
require(VAR18 > 0 );
require(VAR7[msg.sender] >= VAR18);
require(VAR7[VAR17] + VAR18 > VAR7[VAR17]);
VAR7[msg.sender] -= VAR18;
VAR7[VAR17] += VAR18;
emit Transfer(msg.sender, VAR17, VAR18);
return true;
}
function FUN7(address VAR20, address VAR17, uint256 VAR18) public returns (bool VAR19) {
require(VAR7[VAR20] >= VAR18);
require(VAR7[VAR17] + VAR18 >= VAR7[VAR17]);
require(VAR18 <= VAR13[VAR20][msg.sender]);
VAR7[VAR20] -= VAR18;
VAR7[VAR17] += VAR18;
VAR13[VAR20][msg.sender] -= VAR18;
emit Transfer(VAR20, VAR17, VAR18);
return true;
}
function FUN8(address VAR21, uint256 VAR18) public returns (bool VAR19) {
require(VAR7[msg.sender] >= VAR18);
VAR13[msg.sender][VAR21] = VAR18;
emit FUN9(msg.sender, VAR21, VAR18);
return true;
}
function FUN10(address VAR15, address VAR21) public constant returns (uint256 VAR22) {
return VAR13[VAR15][VAR21];
}
function () private {
revert();
}
event Transfer(address indexed VAR20, address indexed VAR17, uint256 VAR18);
event FUN9(address indexed VAR15, address indexed VAR21, uint256 VAR18);
}
contract UnlockGmi is VAR2{
mapping (address => uint256) private VAR23;
bool            private             VAR24;
uint256         private             VAR25;
ERC20Token      private             VAR26;
mapping (address => uint256)  private VAR27;
mapping (address => uint256)  private VAR28;
uint64          private             VAR29;
uint64          private             VAR30;
address         public              VAR31;
constructor() public {
VAR26 = FUN11(0x03B267325193FD0c15cA0D2A693e54213C2AfCB6);
VAR29 = 60 * 60 * 24;
VAR30 = 200;
FUN12();
VAR31 = msg.sender;
}
function FUN12() private {
VAR23[0xDfa1ebaA05b68B82475Aa737d923eCF3AA8535c5]  = 200          * 10 ** 18;
VAR23[0x876282c8809c300fB1ab10b451fb21F1600c27F0]  = 19574        * 10 ** 18;
VAR23[0xa5bC6Eca62ec7bd910753d01e2dD310D465E7a22]  = 197903       * 10 ** 18;
VAR23[0x71A07b9f65A9008b867584c267D545aFF5c8c68f]  = 1014         * 10 ** 18;
VAR23[0x0531c9018a7ff16a9c16817ea6bc544d20abf94b]  = 11838        * 10 ** 18;
VAR23[0x2Ba00DC6Ca55CF9632978D3c38495a8ae52FbeD1]  = 2146         * 10 ** 18;
VAR23[0xae0b391429b0e2169abe4f030ea3700922e2696b]  = 1816         * 10 ** 18;
VAR23[0x3d703c1ada6f12b19DF5BC3c3CDd94F6bE16fc0a]  = 4470         * 10 ** 18;
VAR23[0x819953b03815F529e879AEF3344746942BBBe0cE]  = 13087        * 10 ** 18;
VAR23[0x290BA7bA59d6915eC8E7300581B9fD35c09D9808]  = 15434        * 10 ** 18;
VAR23[0x3af35E26a83c053bC5958160788Fc8a5783FAEaf]  = 4521         * 10 ** 18;
VAR23[0x3ca492b82978A9FB293410b254B49b24F0E43124]  = 6404         * 10 ** 18;
VAR23[0x59e5def48b51b1d3619dea0908b51cafa36bc32c]  = 10344        * 10 ** 18;
VAR23[0x56453D2139F9Fdd6e1Ec40d5370BA03dD4822537]  = 4876         * 10 ** 18;
VAR23[0xEC68B77c7231f7C8A0aF27251c5a8F05819D99A3]  = 11632        * 10 ** 18;
VAR23[0x12A3f50dDA438854491ae7CEe713D21254Bf4831]  = 418          * 10 ** 18;
VAR23[0x811Ff6C39f75dD3FAAeCb35C0bEcBa09AaE5ea50]  = 24534        * 10 ** 18;
VAR23[0x1105A96F7023AA1320b381Bb96ac7528B6De08A5]  = 1059         * 10 ** 18;
VAR23[0x7Da0eCc11BF1baB6f80c91525F00E8CF12a0Ce80]  = 38089        * 10 ** 18;
VAR23[0xf0c6Be88F289Fc1fC3e4BB25BA6C32D120556612]  = 1759         * 10 ** 18;
VAR23[0xD7dD9514Ac84c537526d7fBa9DB39b301369419b]  = 5770         * 10 ** 18;
VAR23[0xe995b1c4f73212ab9122e13d40f8227824a7d134]  = 1802         * 10 ** 18;
VAR23[0xd2309C4ae9Cf8E7F8680c3B87320a2b6Be702435]  = 5428         * 10 ** 18;
VAR23[0x7f2876eaD16E6fee63CF20412e18F4F1B1bF7e7e]  = 6723         * 10 ** 18;
VAR23[0x739411622fB2d07B3d54905846E3367653F4578e]  = 709          * 10 ** 18;
VAR23[0xe50E01F2b901AD6eAA6bcF2182e47e5EF91f4f1c]  = 22722        * 10 ** 18;
VAR23[0x048CCb21e664CFD700c4D5492feaed8e86895c62]  = 753          * 10 ** 18;
VAR23[0xDbc6E2fa275bF5d7762eEa2401ddC93a324feb17]  = 16838        * 10 ** 18;
VAR23[0x83f4f537b01e368e4dce5520c5E869271e3FA90f]  = 77           * 10 ** 18;
VAR23[0x61CFB88085f848f5685c937E7cb7A18d76802709]  = 1448         * 10 ** 18;
VAR23[0x028f9c71fE9cb17fBd32D72159604Fa0b64579A0]  = 8532         * 10 ** 18;
VAR23[0xe4Dc73D6cb05370e9C539aDB7DBf4F330A3Cc663]  = 451          * 10 ** 18;
VAR23[0xF37425eD1E3Eb4a01649fE136D858456d5e37020]  = 93068        * 10 ** 18;
VAR23[0x7d465899B2909d95a1293F4301DB5fC55f5B5008]  = 784          * 10 ** 18;
VAR23[0xe1ac511d43b238EAffdEd35e1F1060a20e7dE87C]  = 22607.8125   * 10 ** 18;
VAR23[0xDdd540e1F4fDb157164597621B236D2650428d3c]  = 760          * 10 ** 18;
VAR23[0x02ff817036529c72572eCfE4e48d532daC9AF777]  = 19475.7      * 10 ** 18;
VAR23[0x9B51Ee9F220590448bB11BcdEd2091d185257e1c]  = 1289         * 10 ** 18;
VAR23[0xEbD6b840d186808AadEfa8d6B0879FFEc965CC3b]  = 6360.8       * 10 ** 18;
VAR23[0xe9687b4633660BF831A7cEdCFe6b2f8Ad695C060]  = 2750.7       * 10 ** 18;
VAR23[0x96E3544A58297bB7C0eBB484280000220d64b483]  = 2984         * 10 ** 18;
VAR23[0xA9dDedfF71811EF9C7Ff6d5C6A800C4AB0B829A6]  = 12350        * 10 ** 18;
VAR23[0x6aa92ffEAD98370d8E86FAD42A4e300F614C154c]  = 55074        * 10 ** 18;
VAR23[0x7E4F8be3EcA8c31AAe3a955bb43Afc0c8Ab5bfaC]  = 579          * 10 ** 18;
VAR23[0x0067478F0aC9DF5fd513C7c5e10C3734cc95a2Bf]  = 6161.5       * 10 ** 18;
VAR23[0x27d2B31ded839ad94a3f637bA56A70Cd9Ae2B282]  = 1085         * 10 ** 18;
VAR23[0x335E44383F620D3e7647C4B2d97c6d6589979fEe]  = 13264        * 10 ** 18;
VAR23[0xD29E97b3940Cb2b2f241FEc7192bf25db34CE4FB]  = 5891         * 10 ** 18;
VAR23[0xf7026196DEacF2584636933C4918395D6E7f072B]  = 1728         * 10 ** 18;
VAR23[0xAf02B81eAafC2103662F3Abaf63Fc1cc3a39F8F3]  = 15324        * 10 ** 18;
VAR23[0xCe5dc41E2bDB3343df281faf6043e9C83e42946F]  = 2048         * 10 ** 18;
VAR23[0x2e161fab552e23849b219c37B237cA3e46FFE190]  = 10664        * 10 ** 18;
VAR23[0x948882468fecb578955575a65331abefc2820445]  = 1356         * 10 ** 18;
VAR23[0x2eDeB8a0aa363f11dDCBCdaD7170b2dd6888b8B7]  = 1095         * 10 ** 18;
VAR23[0x8B4A431805DDE778EEC6BE62F15FCAAB49180349]  = 589          * 10 ** 18;
VAR23[0x0F507a26F1f66761630b814974cA22f0aeEB025b]  = 6623         * 10 ** 18;
VAR23[0xD8467a842D4974f8460D35c0D68d27f46212FC42]  = 11781        * 10 ** 18;
VAR23[0x2f4b7eAA5348aB80CBF0845316fD2f5EdC8CcBB7]  = 22015        * 10 ** 18;
VAR23[0x7029B37167d15051f3E82467Bf8E3Be2a9f5eB66]  = 7671         * 10 ** 18;
VAR23[0x426de357613E1A096285DC7A9b1E4D960532dc77]  = 1191         * 10 ** 18;
VAR23[0xFd39138e6b4df493c22f3D45Cf675d37a53E8e59]  = 3100         * 10 ** 18;
VAR23[0xe0b8a2499804B466b210d1350412DD65a6DA7644]  = 23195        * 10 ** 18;
VAR23[0xa5440b5b3786a6a551aa52464088380a4c94cc5c]  = 16281        * 10 ** 18;
VAR23[0x398626e5b5D43F12C2E1f752521C31cEA6F67Edd]  = 10608        * 10 ** 18;
VAR23[0x33f8255f707cbb9b81561271058e264870F2932E]  = 8650         * 10 ** 18;
VAR23[0x52f2a2CA11562bd804E21Ae8CE24FAc1592F8d5B]  = 7012         * 10 ** 18;
VAR23[0x2c87a13b8f4ac9ccfc84d0cf192b7b250449f814]  = 3728         * 10 ** 18;
VAR23[0x5df29645580d23c7ee79387e55ae14250c5a2ef2]  = 8520         * 10 ** 18;
VAR23[0xc916e3de378d12e15ca68c5740e78cad6d319620]  = 600          * 10 ** 18;
VAR23[0x9667cb2f8cd6858d97cfb78a751ae93869498b90]  = 1037         * 10 ** 18;
VAR23[0xe09eC6ed709050171a6b640decC8a02e2F6E4CA4]  = 1488         * 10 ** 18;
VAR23[0xD4F4bEfeadbE319428F95c4496668d5499f6B3A6]  = 3350         * 10 ** 18;
VAR23[0x5a55368b29c238574A41d4d9513be9b5F6cE261f]  = 12153        * 10 ** 18;
VAR23[0x7BC569164Af97a4122d6c889d944ce222ef4318D]  = 4326         * 10 ** 18;
VAR23[0x684292690C546EAA7c6A37b6923d8C3d823d7ec4]  = 494          * 10 ** 18;
VAR23[0x9523fb6dbfcb91627714cfd41ed27d0dbf9d0288]  = 8085         * 10 ** 18;
VAR23[0xA5C9387746D9dad02AA8D9d8bBC85f1Cc60251DD]  = 7499         * 10 ** 18;
VAR23[0x3425f8f253C30905A4126f76c88358e9433BD23B]  = 16984        * 10 ** 18;
VAR23[0x39eA9690d8986b99047d7980e22eE7BBd20bBb36]  = 6205         * 10 ** 18;
VAR23[0x0316DdD222513626f6F07c0Ea9Aa76d119dbA597]  = 3538         * 10 ** 18;
VAR23[0x0d7ba208cfbdb009164fb5e60a528c62d80c3d2e]  = 119905       * 10 ** 18;
VAR23[0x6b7bF976b100df64bFC5ba541d26C1fE81C6BB1a]  = 6571         * 10 ** 18;
VAR23[0xF58928F2d1c07D4f37B7f35c36A573825104117A]  = 42424        * 10 ** 18;
VAR23[0x4B4064395Fc0B6E35CD7CC79FB324CF9115Dbd7D]  = 12564        * 10 ** 18;
VAR23[0x07e91aa302cb997d1524f58c0c67818bc7e9d85a]  = 200          * 10 ** 18;
VAR23[0x30e5E26E2b562946faf38aad8510BF4065fD351f]  = 1394         * 10 ** 18;
VAR23[0xfbb010c3b9216c1f5ac95587fbcefe6ec2476d14]  = 47216        * 10 ** 18;
VAR23[0xD79067c91e542725a2CBDafe02C9200aF34A75C5]  = 2248         * 10 ** 18;
VAR23[0xc491e8aac8ad3b78bc031eb0544a3feda753ed71]  = 3195         * 10 ** 18;
VAR23[0x4bD5258e6c4f200c8739c0de25C1BaaF4f0dd0A9]  = 8238         * 10 ** 18;
VAR23[0xe0f11d27a4e0d2c176562cab178898b253c2519e]  = 1293         * 10 ** 18;
VAR23[0x1599C57a7C89fb0B57De341245CB30b5a362bcb9]  = 19581        * 10 ** 18;
VAR23[0xc561DDad555F2D4590c6C234aa8eaD077557E861]  = 11484        * 10 ** 18;
VAR23[0xFD3A02E8AE8615614d4D29bf0132f4F5Cd0C92b9]  = 20438        * 10 ** 18;
VAR23[0x633b71915eAD4Ee98cBA4E605d1B93bB48f87dE9]  = 275          * 10 ** 18;
VAR23[0x9BAf29D4D23756Dd93Cb090D656CeA490D28A410]  = 3140         * 10 ** 18;
VAR23[0xc17e4c0cABe3915E52a750acC8847F77b98C6CAF]  = 5281         * 10 ** 18;
VAR23[0xc79eae229e131ca04722e9b4e77f75190cfe6eb8]  = 3657         * 10 ** 18;
VAR23[0x9954e6f38F248d3Bd213a55cDe2f53b3459680dD]  = 406          * 10 ** 18;
VAR23[0x6390A8807fa00551cBFdBf91ce2c06af2fFC0cCA]  = 225          * 10 ** 18;
VAR23[0xf430eE763C83bbAd5b072EaE9435EE228A63A888]  = 16249        * 10 ** 18;
VAR23[0xA7135f955BE175910E3e08048527b7ea387a881E]  = 3738         * 10 ** 18;
VAR23[0x68638F00c7A24dC8c1968345de50d69BA74FFa21]  = 1803         * 10 ** 18;
VAR23[0x713D2599e96Ae8Ec037A0E903B4A801Dec416aC0]  = 9160         * 10 ** 18;
VAR23[0x2fED4396Ee204a448201fAB980f1C90018e22801]  = 302122       * 10 ** 18;
VAR23[0x3cC8291F32a07aC9D0D9887eEc7331bD273c613B]  = 1142882      * 10 ** 18;
VAR23[0xef6607FafE4406dD1698865aC89BcBc22323e853]  = 139708       * 10 ** 18;
VAR23[0x1b15FD6FeaecC11B44D689b7B1C2471207a26a23]  = 116678       * 10 ** 18;
VAR23[0xe813fe32aBd2f47c5010426d259e2372e526021C]  = 103784       * 10 ** 18;
VAR23[0x253f9FAb9dCB4a64ceF5b3320eB9F28163924DF9]  = 71770        * 10 ** 18;
VAR23[0x3aa9230bF5deD1c72aa4083B6137ADC7955B5a1a]  = 114020       * 10 ** 18;
VAR23[0xe37079253aDa30eeF49f65EFd48608A4C15F614D]  = 503303       * 10 ** 18;
VAR23[0x89Ad15DfCDe37dCF1C7C8582d8ff7F195796EB7B]  = 164803       * 10 ** 18;
VAR23[0xD063C6f99F221Df40D1F15A1d5D6a477573f8092]  = 31460        * 10 ** 18;
VAR23[0x8Ef20D2388606Fd4E6ef0f0f070a63c5c655626c]  = 681715       * 10 ** 18;
VAR23[0x632A8a687C5c99556117650641B3ACB299ba070f]  = 458888       * 10 ** 18;
VAR23[0x8901A17d3964214D501F9C8B015854d037d90fEf]  = 831815       * 10 ** 18;
VAR23[0xDF5662248182270da3b7582d303CFb2d5E62ec23]  = 1257794      * 10 ** 18;
VAR23[0x1f5a6da1dfd6645eb4f3afc0d4e457aac95c8776]  = 1014032      * 10 ** 18;
VAR23[0xb1FA3A4c4CEEc881Ec3B4f50afa4d40a20353385]  = 339020       * 10 ** 18;
VAR23[0x7F3D90153259c49887d55E906af3336c38F814A9]  = 421571       * 10 ** 18;
VAR23[0x9c6fc8Eb31B67Cc9452c96B77DdCb5EF504CDa81]  = 119204       * 10 ** 18;
VAR23[0xD9c1F9347785dc2E79477E20E7d5e5b7866deF35]  = 178954       * 10 ** 18;
VAR23[0xa4FEf4Cc6f63E5Ea0A2F3044EA84b9a1EACeAE5e]  = 139148       * 10 ** 18;
VAR23[0x3Ae9e2E7fEA9031eE85facbBc26794b079b3dCd9]  = 1940127      * 10 ** 18;
VAR23[0x901AD29A0e95647525137E2af782C517375D37C4]  = 4750115      * 10 ** 18;
VAR23[0xbff165E4549bfcea5F150FC5ee04cC8dA4dCAe5d]  = 59902        * 10 ** 18;
VAR23[0x09c09b03563B6Be9104Da38890468C0D9A98C691]  = 2729048      * 10 ** 18;
VAR23[0x400D5Fd9A30C3f524931F82C687cacB6C4054F41]  = 610952       * 10 ** 18;
VAR23[0x054C0a11804Ad1116290CF14EE23Ad59F3d0925e]  = 376660       * 10 ** 18;
VAR23[0xB80ab7AAb74731243fE13d5c6Eb87223CfaDA59b]  = 73479        * 10 ** 18;
VAR23[0xb1DbcBd1705938546e1eBa520332B4c164878965]  = 68520        * 10 ** 18;
VAR23[0x4e961A68d3dafff6D4d863d21fba6Fff82b25d5c]  = 10000        * 10 ** 18;
VAR23[0x097515d2570baBbDa32e5caF23a765e574cDc6B1]  = 50683        * 10 ** 18;
VAR23[0xb2aCA30Ae71d146aad0422a141e3eF0B9313A4bc]  = 25158        * 10 ** 18;
VAR23[0x8Ab96a4778BB5b7E6839059D2988e846A749E9ED]  = 67043        * 10 ** 18;
VAR23[0x7e5177Bd22D9e64AfEBD4F06DdD4C6F6bFccc548]  = 113495       * 10 ** 18;
VAR23[0xd3A8bBBc7eeAF8422C791A3d046Fa773E972bAe2]  = 184614       * 10 ** 18;
VAR23[0x66F9A4b3C09dA25cF14a063647882c31880bcd17]  = 37509        * 10 ** 18;
VAR23[0x3409780afa44ede06111b927e25c1fa7ef72cda5]  = 185956       * 10 ** 18;
VAR23[0x1F105e0A5126a1282929ff5E4FB1819F2D48a785]  = 221487       * 10 ** 18;
VAR23[0x5F86Ff75c7745d40d81F155c9B2D49794F8Dd85E]  = 476976       * 10 ** 18;
VAR23[0xAB107D9932f4338538c72fEc7fEd65a7F87Ed24C]  = 1863872      * 10 ** 18;
VAR23[0xB3D3403BB64258CFA18C49D28c0E9719eF0A0004]  = 192751       * 10 ** 18;
VAR23[0xb1da36EfcBf2ee81178A113c631932AEc9c9ADE9]  = 34386        * 10 ** 18;
VAR23[0x8894EdE64044F73d293bD43eaeBf1D6Dbc55B361]  = 2368356      * 10 ** 18;
VAR23[0xF7F62c2B263E6C7319322f2A4a76d989404835d6]  = 100515       * 10 ** 18;
VAR23[0x5814639DA554762e40745b9F0e2C5d0Ba593E532]  = 413704       * 10 ** 18;
VAR23[0xc02918Eb9563dBa6322673C2f18096Dceb5BE71d]  = 101500       * 10 ** 18;
VAR23[0x61dBB6fA0d7A85a73Fb3AA4896079eE4011229e5]  = 164921       * 10 ** 18;
VAR23[0x30E442ADD9826B52F344D7FAfB8960Df9dbb8f30]  = 280178       * 10 ** 18;
VAR23[0xE8B0A0BEc7b2B772858414527C022bfb259FAC71]  = 1559993      * 10 ** 18;
VAR23[0x9f8B4fd6B3BbACCa93b79C37Ce1F330a5A81cbB7]  = 766709       * 10 ** 18;
VAR23[0x5a98B695Fe35F628DFaEBbBB5493Dc8488FA3275]  = 283605       * 10 ** 18;
VAR23[0x23b6E3369bD27C3C4Be5d925c6fa1FCea52283e2]  = 143304       * 10 ** 18;
VAR23[0xE8c215194222708C831362D5e181b2Af99c6c384]  = 144635       * 10 ** 18;
VAR23[0xfC0aE173522D24326CFfA9D0D0C058565Fd39d2B]  = 84228        * 10 ** 18;
VAR23[0x5e08EA6DDD4BF0969B33CAD27D89Fb586F0fC2f1]  = 34749        * 10 ** 18;
VAR23[0xE7De0652d437b627AcC466002d1bC8D44bdb156E]  = 17809        * 10 ** 18;
VAR23[0xEa4CedE1d23c616404Ac2dcDB3A3C5EaA24Ce38d]  = 13263        * 10 ** 18;
VAR23[0x7d97568b1329013A026ED561A0FA542030f7b44B]  = 107752       * 10 ** 18;
VAR23[0x0c52d845AB2cB7e4bec52DF6F521603683FA8780]  = 36368        * 10 ** 18;
VAR23[0x58d66AC8820fa6f7c18594766519c490d33C6E96]  = 292311       * 10 ** 18;
VAR23[0x1554972baa4b0f26bafbfac8872fc461683a64aa]  = 74097        * 10 ** 18;
VAR23[0xcCD4513E24C87439173f747625FDBF906AE5428A]  = 33718        * 10 ** 18;
VAR23[0xB81f587dEB7Dc1eb1e7372B1BD0E75DeE5804313]  = 34711        * 10 ** 18;
VAR23[0xad4e8ae487bf8b6005aa7cb8f3f573752db1ced0]  = 62781        * 10 ** 18;
VAR23[0x9e25ade8a3a4f2f1a9e902a3eaa62baee0000c16]  = 1042612      * 10 ** 18;
VAR23[0xeb019f923bb1Dab5Fd309E342b52950E6A3a5bb5]  = 210671       * 10 ** 18;
VAR23[0xf145c1E0dEcE26b8DD0eDbd0D7A1f4a16dBFE238]  = 414327       * 10 ** 18;
VAR23[0xf1cfa922da06079ce6ed6c5b6922df0d4b82c76f]  = 135962       * 10 ** 18;
VAR23[0x0Fc746A1800BDb4F6308B544e07B46eF4615776E]  = 12948        * 10 ** 18;
VAR23[0x448bc2419Fef08eF72a49B125EA8f2312a0Db64C]  = 11331        * 10 ** 18;
VAR23[0x6766B4BebcEfa05db1041b80f9C67a00aAe60d2a]  = 44260        * 10 ** 18;
VAR23[0xfd1b9d97772661f56cb630262311f345e24078ee]  = 116657       * 10 ** 18;
VAR23[0x5149F1A30Bab45e436550De2Aed5C63101CC3c61]  = 161098       * 10 ** 18;
VAR23[0xAeA06A4bFc2c60b2CEb3457c56eEb602C72B6C74]  = 13499        * 10 ** 18;
VAR23[0xB24969E6CEAE48EfccAb7dB5E56169574A3a13A8]  = 62028        * 10 ** 18;
VAR23[0x6FaE413d14cD734d6816d4407b1e4aB931D3F918]  = 100378       * 10 ** 18;
VAR23[0xb6224a0f0ab25312d100a1a8c498f7fb4c86da17]  = 484510       * 10 ** 18;
VAR23[0xE3C398F56733eF23a06D96f37EaE555eE6596A85]  = 381015       * 10 ** 18;
VAR23[0x3eB5594E1CE158799849cfC7A7861164107F2006]  = 445141       * 10 ** 18;
VAR23[0x15ac93dE94657882c8EB6204213D9B521dEBaBfB]  = 213617       * 10 ** 18;
VAR23[0x1988267Ce9B413EE6706A21417481Ed11a3Ca152]  = 595134       * 10 ** 18;
VAR23[0x50e10b4444F2eC1a14Deea02138A338896c2325E]  = 321502       * 10 ** 18;
VAR23[0x5934028055dd8bff18e75283af5a8800469c7eda]  = 788752       * 10 ** 18;
VAR23[0xff54d0987cba3c07dc2e65f8ba62a963439e257f]  = 239170       * 10 ** 18;
VAR23[0x71396C01ba9AA053a51cfadC7d0D09d97aF96189]  = 2250076      * 10 ** 18;
VAR23[0x795129211Eb76D8440E01Ed2374417f054dB65f2]  = 2355693      * 10 ** 18;
VAR23[0xac0c89c654d837100db2c3dc5923e308c745ac0e]  = 34000        * 10 ** 18;
VAR23[0x941D03Ae7242cF1929888FdE6160771ff27f3D8c]  = 1308777      * 10 ** 18;
VAR23[0xd9A2649ea71A38065B2DB6e670272Bed0bb68fB7]  = 1570922      * 10 ** 18;
VAR23[0x7303bDf8d7c7642F5297A0a97320ee440E55D028]  = 1846600      * 10 ** 18;
VAR23[0x333a0401Aa60D81Ba38e9E9Bd43FD0f8253A83eB]  = 1503988      * 10 ** 18;
VAR23[0x5AC44139a4E395b8d1461b251597F86F997A407B]  = 1467330      * 10 ** 18;
VAR23[0xbB07b26d8c7d9894FAF45139B3286784780EC94F]  = 1650000      * 10 ** 18;
VAR23[0xc4Ad40d8FCCDcd555B7026CAc1CC6513993a2A03]  = 845391       * 10 ** 18;
VAR23[0x92Dab5d9af2fC53863affd8b9212Fae404A8B625]  = 48000        * 10 ** 18;
}
modifier FUN13() {
require(VAR24 == true, "");
VAR32;
}
modifier FUN14() {
require(msg.sender == VAR31, "");
VAR32;
}
function FUN15(uint64 VAR33) public FUN14() {
VAR25 = VAR33;
VAR24 = true;
}
function FUN16() public  FUN14() {
VAR24 = false;
}
function FUN17(address VAR34) public FUN14() {
require(VAR24 == false, "");
uint256 VAR35 = VAR26.FUN6(address(this));
VAR26.transfer(VAR34, VAR35);
}
modifier FUN18() {
require(VAR28[msg.sender] < VAR23[msg.sender], "");
VAR32;
}
function FUN19() public
FUN13()
FUN18()
payable {
uint256 VAR36 = 0;
uint256 VAR37 = 0;
uint256 VAR38 = 0;
uint256 VAR39 = 0;
uint256 VAR40 = 0;
(VAR36, VAR37, VAR38, VAR39, VAR40) = FUN20(msg.sender);
VAR28[msg.sender] = FUN1(VAR28[msg.sender], VAR36);
VAR27[msg.sender] = VAR41;
VAR26.transfer(msg.sender, VAR36);
}
function FUN20(address VAR34) private FUN13()
view returns(uint256, uint256, uint256, uint256, uint256)  {
uint256 VAR37 = 0;
uint256 VAR36 = 0;
uint256 VAR42 = VAR27[VAR34];
uint256 VAR39 = VAR23[VAR34];
VAR37 = FUN4(FUN2(VAR41, VAR25), VAR29);
if(VAR37 == 0) {
return (0, VAR37, VAR38, VAR39, VAR42);
}
if(VAR37 > VAR30) {
VAR37 = VAR30;
}
uint256 VAR38 =  FUN4(FUN3(VAR39, VAR37), VAR30);
VAR36 = FUN2(VAR38, VAR28[VAR34]);
if(VAR37 == VAR30) {
VAR36 = FUN2(VAR39, VAR28[VAR34]);
}
return (VAR36, VAR37, VAR38, VAR39, VAR42);
}
function FUN21(address VAR34) public
FUN13() view returns(uint256, uint256, uint256, uint256, uint256)
{
uint256 VAR36 = 0;
uint256 VAR37 = 0;
uint256 VAR38 = 0;
uint256 VAR39 = 0;
uint256 VAR40 = 0;
(VAR36, VAR37, VAR38, VAR39, VAR40) = FUN20(VAR34);
return (VAR36, VAR37, VAR38, VAR39, VAR40);
}
}
0
---------------------------------
456 0x03c9458cef76439365cb1b4c44ea307c8e990b81.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
event FUN1(address VAR3, uint value);
event FUN2(address VAR4, uint value);
address public VAR5;
constructor() public {
VAR5 = msg.sender;
}
function() public payable {
emit FUN1(msg.sender, msg.value);
}
function transfer(address VAR4, uint value) public {
require(msg.sender == VAR5);
VAR4.transfer(value);
emit FUN2(VAR4, value);
}
}
0
---------------------------------
457 0x03cc979c46b030c4abd7d4063cd075cb38cd0919.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) public returns (bool VAR5);
function FUN1(address VAR6, address VAR3, uint256 VAR4) public returns (bool VAR5);
}
library VAR7 {
function FUN2(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
if (VAR8 == 0) {
return 0;
}
uint256 VAR10 = VAR8 * VAR9;
require(VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN3(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
uint256 VAR10 = VAR8 / VAR9;
return VAR10;
}
function FUN4(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
require(VAR9 <= VAR8);
return VAR8 - VAR9;
}
function FUN5(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
uint256 VAR10 = VAR8 + VAR9;
require(VAR10 >= VAR8);
return VAR10;
}
function FUN6(uint VAR8, uint VAR9) internal pure returns (uint) {
if (VAR8 >= VAR9)
return VAR9;
return VAR8;
}
function FUN7(uint VAR8, uint VAR9) internal pure returns (uint) {
if (VAR8 >= VAR9)
return VAR8;
return VAR9;
}
}
contract VAR11 {
function FUN8(
address VAR12,
address VAR13,
bytes4 VAR14
) public view returns (bool);
}
contract VAR15 {
event FUN9 (address indexed VAR16);
event FUN10     (address indexed VAR17);
}
contract DSAuth is VAR15 {
DSAuthority  public  VAR16;
address      public  VAR17;
constructor() public {
VAR17 = msg.sender;
emit FUN10(msg.sender);
}
function FUN11(address VAR18)
public
VAR19
{
VAR17 = VAR18;
emit FUN10(VAR17);
}
function FUN12(DSAuthority VAR20)
public
VAR19
{
VAR16 = VAR20;
emit FUN9(VAR16);
}
modifier VAR19 {
require(FUN13(msg.sender, msg.VAR14));
VAR21;
}
function FUN13(address VAR12, bytes4 VAR14) internal view returns (bool) {
if (VAR12 == address(this)) {
return true;
} else if (VAR12 == VAR17) {
return true;
} else if (VAR16 == FUN14(0)) {
return false;
} else {
return VAR16.FUN8(VAR12, this, VAR14);
}
}
}
contract Exchange is VAR22 {
using SafeMath for uint;
ERC20 public VAR23;
mapping(address => uint) public VAR24;
mapping(address => uint) public VAR25;
mapping(address => uint) public VAR26;
mapping(address => uint) public VAR27;
mapping(bytes32 => mapping(address => uint)) public VAR28;
mapping(bytes32 => mapping(address => uint)) public VAR29;
mapping(bytes32 => mapping(address => uint)) public VAR30;
mapping(bytes32 => mapping(address => uint)) public VAR31;
mapping(bytes32 => uint) public VAR32;
mapping(bytes32 => uint) public VAR33;
mapping(bytes32 => uint) public VAR34;
mapping(bytes32 => uint) public VAR35;
mapping(address => mapping(bytes32 => bool)) public VAR36;
mapping(address => mapping(bytes32 => uint)) public VAR37;
mapping(address => uint) public VAR38;
mapping(bytes32 => bool) public VAR39;
uint public VAR40       = 7 VAR41;
uint public VAR42   = 1 VAR41;
uint public VAR43   = 20 VAR41;
uint public VAR44 = 20 VAR41;
uint public VAR45 = 0;
uint public VAR46 = 0;
string VAR47 = "";
constructor(address VAR48) public {
require(VAR48 != 0x0);
VAR23 = FUN15(VAR48);
}
function() public payable {
revert();
}
event FUN16(address indexed VAR49, uint VAR50);
event FUN17(address indexed VAR49, uint VAR50, address VAR51);
event FUN18(address indexed VAR49, uint VAR50);
event FUN19(address indexed VAR49, uint VAR50, address VAR51);
function FUN20() public payable {
FUN21(msg.value, msg.sender);
emit FUN16(msg.sender, msg.value);
}
function FUN22(uint VAR50) public {
require(VAR23.FUN1(msg.sender, this, VAR50));
FUN23(VAR50, msg.sender);
emit FUN18(msg.sender, VAR50);
}
function FUN24(uint VAR50, address VAR51) public {
require(VAR51 != 0x0);
FUN25(VAR50, msg.sender);
VAR51.transfer(VAR50);
emit FUN17(msg.sender, VAR50, VAR51);
}
function FUN26(uint VAR50, address VAR51) public {
require(VAR51 != 0x0);
FUN27(VAR50, msg.sender);
VAR23.transfer(VAR51, VAR50);
emit FUN19(msg.sender, VAR50, VAR51);
}
function FUN28(uint VAR50, address VAR49) public {
require(VAR49 != 0x0);
require(VAR23.FUN1(msg.sender, this, VAR50));
FUN23(VAR50, VAR49);
emit FUN18(VAR49, VAR50);
}
function FUN21(uint VAR50, address VAR49) private {
VAR25[VAR49] = VAR25[VAR49].FUN5(VAR50);
VAR26[VAR49] = VAR26[VAR49].FUN5(VAR50);
}
function FUN25(uint VAR50, address VAR49) private {
VAR25[VAR49] = VAR25[VAR49].FUN4(VAR50);
VAR26[VAR49] = VAR26[VAR49].FUN4(VAR50);
}
function FUN23(uint VAR50, address VAR49) private {
VAR24[VAR49] = VAR24[VAR49].FUN5(VAR50);
VAR27[VAR49] = VAR27[VAR49].FUN5(VAR50);
}
function FUN27(uint VAR50, address VAR49) private {
VAR24[VAR49] = VAR24[VAR49].FUN4(VAR50);
VAR27[VAR49] = VAR27[VAR49].FUN4(VAR50);
}
function FUN29(
uint VAR52,
uint VAR53,
uint VAR54,
uint VAR55
) public VAR19 {
VAR40 = VAR52;
VAR42 = VAR53;
VAR43 = VAR54;
VAR44 = VAR55;
require(VAR42 < 5 VAR41);
require(VAR40 < 6.95 VAR41);
require(VAR43 < 20 VAR41);
require(VAR44 < 20 VAR41);
}
function FUN30(address VAR51) public VAR19 {
require(VAR51 != 0x0);
uint VAR50 = VAR45.FUN4(VAR46);
VAR46 = VAR45;
require(VAR23.transfer(VAR51, VAR50));
}
modifier FUN31(uint VAR50) {
VAR21;
FUN32(msg.sender, FUN33(VAR50));
}
enum VAR56 {
VAR57,
VAR58,
VAR59,
VAR60,
VAR61,
VAR62,
VAR63,
VAR64
}
event FUN34(address indexed VAR49, bytes32 VAR65);
function FUN35(bytes32 VAR65) public {
VAR36[msg.sender][VAR65] = true;
emit FUN34(msg.sender, VAR65);
}
function FUN36(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR59, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN40(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN41(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN42(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR60, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN40(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN43(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN44(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR59, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN45(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN41(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN46(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR60, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN45(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN43(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN47(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR57, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN41(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN40(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN48(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR58, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN41(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN45(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN49(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR57, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN43(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN40(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN50(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR58, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN43(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN45(VAR50, VAR66, VAR68, VAR70, VAR75);
}
event FUN51(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
event FUN52(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
event FUN53(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
event FUN54(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
function FUN40(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR76) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
FUN27(VAR78, VAR76);
VAR28[VAR77][VAR76] = VAR28[VAR77][VAR76].FUN5(VAR50);
emit FUN51(VAR76, VAR50, VAR66, VAR68, VAR70);
}
function FUN45(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR76) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
FUN27(VAR78, VAR76);
VAR25[VAR76] = VAR25[VAR76].FUN5(VAR50);
VAR30[VAR77][VAR76] = VAR30[VAR77][VAR76].FUN4(VAR50);
emit FUN53(VAR76, VAR50, VAR66, VAR68, VAR70);
}
function FUN41(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR79) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
FUN23(VAR78, VAR79);
VAR25[VAR79] = VAR25[VAR79].FUN4(VAR50);
VAR30[VAR77][VAR79] = VAR30[VAR77][VAR79].FUN5(VAR50);
emit FUN52(VAR79, VAR50, VAR66, VAR68, VAR70);
}
function FUN43(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR79) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
FUN23(VAR78, VAR79);
VAR28[VAR77][VAR79] = VAR28[VAR77][VAR79].FUN4(VAR50);
emit FUN54(VAR79, VAR50, VAR66, VAR68, VAR70);
}
event FUN55(address indexed VAR49, uint VAR50, uint VAR66, uint VAR70);
function FUN56(
uint VAR50,
uint VAR66,
uint VAR70
) public {
require(VAR80 < VAR66, "");
require(VAR50 % 1 VAR81 == 0, VAR47);
uint VAR82 = VAR50.FUN2(VAR70).FUN3(1 VAR41);
bytes32 VAR77 = FUN37(VAR66, VAR70);
require(VAR28[VAR77][msg.sender] > 0);
VAR28[VAR77][msg.sender] = VAR28[VAR77][msg.sender].FUN4(VAR50);
VAR34[VAR77] = VAR34[VAR77].FUN5(VAR50);
FUN32(msg.sender, VAR43);
FUN27(VAR82, msg.sender);
FUN21(VAR50, msg.sender);
emit FUN55(msg.sender, VAR50, VAR66, VAR70);
}
event FUN57(address indexed VAR49, uint VAR50, uint VAR66, uint VAR70);
event FUN58(address indexed VAR49, uint VAR66, uint VAR70);
function FUN59(uint VAR66, uint VAR70, address VAR83) public {
require(msg.sender == VAR83 || FUN13(msg.sender, msg.VAR14), "");
require(VAR80 > VAR66, "");
bytes32 VAR77 = FUN37(VAR66, VAR70);
require(VAR30[VAR77][VAR83] > 0);
if (VAR32[VAR77] < VAR34[VAR77]) {
uint VAR84 = VAR30[VAR77][VAR83];
uint VAR85 = VAR34[VAR77].FUN4(VAR32[VAR77]);
uint VAR86 = VAR85.FUN6(VAR84);
VAR26[VAR83] = VAR26[VAR83].FUN4(VAR86);
VAR32[VAR77] = VAR32[VAR77].FUN5(VAR86);
VAR30[VAR77][VAR83] = VAR30[VAR77][VAR83].FUN4(VAR86);
uint value = VAR70.FUN2(VAR86).FUN3(1 VAR41);
FUN23(value, VAR83);
emit FUN57(msg.sender, VAR86, VAR66, VAR70);
}
FUN32(VAR83, VAR44);
VAR25[VAR83] = VAR25[VAR83].FUN5(VAR30[VAR77][VAR83]);
VAR30[VAR77][VAR83] = 0;
emit FUN58(VAR83, VAR66, VAR70);
}
function FUN60(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR63, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN61(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN62(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN63(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR64, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN61(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN64(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN65(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR63, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN66(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN62(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN67(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR64, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN66(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN64(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN68(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR61, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN62(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN61(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN69(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR62, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN62(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN66(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN70(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR61, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN64(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN61(VAR50, VAR66, VAR68, VAR70, VAR75);
}
function FUN71(
uint    VAR50,
uint    VAR66,
bytes32 VAR67,
uint    VAR68,
uint    VAR69,
uint    VAR70,
uint    VAR71,
bytes32 VAR72,
bytes32 VAR73,
uint8   VAR74
) public FUN31(VAR50) {
bytes32 VAR65 = FUN37(VAR56.VAR62, VAR66, VAR67, VAR68, VAR69, VAR70, VAR71, this);
address VAR75 = FUN38(VAR65, VAR74, VAR72, VAR73);
FUN39(VAR50, VAR66, VAR65, VAR75, VAR68, VAR71, VAR69, VAR70);
FUN64(VAR50, VAR66, VAR68, VAR70, msg.sender);
FUN66(VAR50, VAR66, VAR68, VAR70, VAR75);
}
event FUN72(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
event FUN73(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
event FUN74(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
event FUN75(address indexed VAR49, uint VAR50, uint VAR66, uint VAR68, uint VAR70);
function FUN61(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR76) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
FUN27(VAR78, VAR76);
VAR29[VAR77][VAR76] = VAR29[VAR77][VAR76].FUN5(VAR50);
emit FUN72(VAR76, VAR50, VAR66, VAR68, VAR70);
}
function FUN66(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR76) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
VAR24[VAR76] = VAR24[VAR76].FUN5(VAR70.FUN2(VAR50).FUN3(1 VAR41));
FUN27(VAR78, VAR76);
VAR31[VAR77][VAR76] = VAR31[VAR77][VAR76].FUN4(VAR50);
emit FUN74(VAR76, VAR50, VAR66, VAR68, VAR70);
}
function FUN62(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR79) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
uint VAR82 = VAR70.FUN2(VAR50).FUN3(1 VAR41);
FUN23(VAR78, VAR79);
VAR24[VAR79] = VAR24[VAR79].FUN4(VAR82);
VAR31[VAR77][VAR79] = VAR31[VAR77][VAR79].FUN5(VAR50);
emit FUN73(VAR79, VAR50, VAR66, VAR68, VAR70);
}
function FUN64(uint VAR50, uint VAR66, uint VAR68, uint VAR70, address VAR79) private {
bytes32 VAR77 = FUN37(VAR66, VAR70);
uint VAR78 = VAR50.FUN2(VAR68).FUN3(1 VAR41);
FUN23(VAR78, VAR79);
VAR29[VAR77][VAR79] = VAR29[VAR77][VAR79].FUN4(VAR50);
emit FUN75(VAR79, VAR50, VAR66, VAR68, VAR70);
}
event FUN76(address indexed VAR49, uint VAR50, uint VAR66, uint VAR70);
function FUN77(
uint VAR50,
uint VAR66,
uint VAR70
) public {
require(VAR80 < VAR66, "");
require(VAR50 % 1 VAR81 == 0, VAR47);
uint VAR87 = VAR50.FUN2(VAR70).FUN3(1 VAR41);
bytes32 VAR77 = FUN37(VAR66, VAR70);
require(VAR29[VAR77][msg.sender] > 0);
VAR29[VAR77][msg.sender] = VAR29[VAR77][msg.sender].FUN4(VAR50);
VAR35[VAR77] = VAR35[VAR77].FUN5(VAR50);
FUN25(VAR50, msg.sender);
FUN23(VAR87, msg.sender);
FUN32(msg.sender, VAR43);
emit FUN76(msg.sender, VAR50, VAR66, VAR70);
}
event FUN78(address indexed VAR49, uint VAR50, uint VAR66, uint VAR70);
event FUN79(address indexed VAR49, uint VAR66, uint VAR70);
function FUN80(uint VAR66, uint VAR70, address VAR83) public {
require(msg.sender == VAR83 || FUN13(msg.sender, msg.VAR14), "");
require(VAR80 > VAR66, "");
bytes32 VAR77 = FUN37(VAR66, VAR70);
require(VAR31[VAR77][VAR83] > 0);
if (VAR33[VAR77] < VAR35[VAR77]) {
uint VAR84 = VAR31[VAR77][VAR83];
uint VAR85 = VAR35[VAR77].FUN4(VAR33[VAR77]);
uint VAR86 = VAR84.FUN6(VAR85);
VAR27[VAR83] = VAR27[VAR83].FUN4(VAR86.FUN2(VAR70).FUN3(1 VAR41));
VAR31[VAR77][VAR83] = VAR31[VAR77][VAR83].FUN4(VAR86);
VAR33[VAR77] = VAR33[VAR77].FUN5(VAR86);
FUN21(VAR86, VAR83);
emit FUN78(VAR83, VAR86, VAR66, VAR70);
}
uint VAR87 = VAR31[VAR77][VAR83].FUN2(VAR70).FUN3(1 VAR41);
FUN32(VAR83, VAR44);
VAR24[VAR83] = VAR24[VAR83].FUN5(VAR87);
VAR31[VAR77][VAR83] = 0;
emit FUN79(VAR83, VAR66, VAR70);
}
function FUN33(uint VAR50) public view returns (uint) {
return VAR50.FUN2(VAR42).FUN3(1 VAR41).FUN5(VAR40);
}
function FUN81(uint VAR50, bytes32 VAR67, bytes32 VAR72, bytes32 VAR73, uint8 VAR74) public {
bytes32 VAR65 = FUN37(VAR50, VAR67, msg.sender);
VAR65 = FUN37("", VAR65);
address VAR88 = FUN82(VAR65, VAR74, VAR72, VAR73);
require(VAR50 <= 1000);
require(FUN13(VAR88, msg.VAR14));
require(VAR39[VAR67] == false);
VAR38[msg.sender] = VAR38[msg.sender].FUN5(VAR50);
VAR39[VAR67] = true;
}
event FUN83(address indexed VAR49, address VAR75, uint VAR50, bytes32 VAR65);
function FUN39(uint VAR50, uint VAR66, bytes32 VAR65, address VAR75, uint VAR68, uint VAR71, uint VAR69, uint VAR70) private {
require(VAR70 % 1 VAR41 == 0, VAR47);
require(VAR50 % 1 VAR81 == 0, VAR47);
require(VAR68 % 1 VAR81 == 0, VAR47);
require(VAR66 % 86400 == 0, "");
require(VAR36[VAR75][VAR65] == false, "");
require(VAR50 <= VAR69.FUN4(VAR37[VAR75][VAR65]), "");
require(VAR80 < VAR71, "");
require(VAR80 < VAR66, "");
VAR37[VAR75][VAR65] = VAR37[VAR75][VAR65].FUN5(VAR50);
emit FUN83(msg.sender, VAR75, VAR50, VAR65);
}
function FUN32(address VAR49, uint VAR50) private {
if (VAR38[msg.sender] > 0) {
VAR38[msg.sender] = VAR38[msg.sender].FUN4(1);
} else {
FUN27(VAR50, VAR49);
VAR45 = VAR45.FUN5(VAR50);
}
}
function FUN38(bytes32 VAR65, uint8 VAR74, bytes32 VAR72, bytes32 VAR73) public pure returns (address) {
return FUN82(FUN37("", VAR65), VAR74, VAR72, VAR73);
}
}
0
---------------------------------
458 0x03d9550c4ce1df4ad97bbcfe4df24cdec9cf3b24.sol
pragma solidity 0.4.24;
pragma VAR1 "";
library VAR2 {
function FUN1(uint64 VAR3, uint64 VAR4) internal pure returns (VAR5) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN2(uint64 VAR3, uint64 VAR4) internal pure returns (VAR5) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
library VAR6 {
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR7) {
if (VAR3 == 0) {
return 0;
}
VAR7 = VAR3 * VAR4;
assert(VAR7 / VAR3 == VAR4);
return VAR7;
}
function FUN6(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
return VAR3 / VAR4;
}
function FUN7(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN8(uint256 VAR3, uint256 VAR4) internal pure returns (uint256 VAR7) {
VAR7 = VAR3 + VAR4;
assert(VAR7 >= VAR3);
return VAR7;
}
}
contract VAR8 {
address public VAR9;
event FUN9(address indexed VAR10);
event FUN10(
address indexed VAR10,
address indexed VAR11
);
constructor() public {
VAR9 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR9);
VAR12;
}
function FUN11() public onlyOwner {
emit FUN9(VAR9);
VAR9 = address(0);
}
function FUN12(address VAR13) public onlyOwner {
FUN13(VAR13);
}
function FUN13(address VAR13) internal {
require(VAR13 != address(0));
emit FUN10(VAR9, VAR13);
VAR9 = VAR13;
}
}
contract VAR14 {
mapping (address => bool) public VAR15;
event FUN14(
address VAR16
);
event FUN15(
address VAR16
);
modifier FUN16() {
require(
VAR15[msg.sender],
""
);
VAR12;
}
}
contract StaticAccessControlled is VAR14, VAR8 {
using SafeMath for uint256;
uint256 public VAR17;
constructor(
uint256 VAR18
)
public
FUN17()
{
VAR17 = VAR19.VAR20.FUN8(VAR18);
}
function FUN18(
address VAR16
)
external
onlyOwner
{
require(
VAR19.VAR20 < VAR17,
""
);
emit FUN14(VAR16);
VAR15[VAR16] = true;
}
}
interface VAR21 {
function FUN19(
)
external
view
returns (uint256);
function FUN20(
address VAR16
)
external
view
returns (uint256);
function FUN21(
address VAR9,
address VAR22
)
external
view
returns (uint256);
function transfer(
address VAR23,
uint256 value
)
external;
function FUN22(
address VAR24,
address VAR23,
uint256 value
)
external;
function FUN23(
address VAR22,
uint256 value
)
external;
}
library VAR25 {
function FUN20(
address VAR26,
address VAR9
)
internal
view
returns (uint256)
{
return FUN24(VAR26).FUN20(VAR9);
}
function FUN21(
address VAR26,
address VAR9,
address VAR22
)
internal
view
returns (uint256)
{
return FUN24(VAR26).FUN21(VAR9, VAR22);
}
function FUN23(
address VAR26,
address VAR22,
uint256 VAR27
)
internal
{
FUN24(VAR26).FUN23(VAR22, VAR27);
require(
FUN25(),
""
);
}
function transfer(
address VAR26,
address VAR23,
uint256 VAR27
)
internal
{
address VAR24 = address(this);
if (
VAR27 == 0
|| VAR24 == VAR23
) {
return;
}
FUN24(VAR26).transfer(VAR23, VAR27);
require(
FUN25(),
""
);
}
function FUN22(
address VAR26,
address VAR24,
address VAR23,
uint256 VAR27
)
internal
{
if (
VAR27 == 0
|| VAR24 == VAR23
) {
return;
}
FUN24(VAR26).FUN22(VAR24, VAR23, VAR27);
require(
FUN25(),
""
);
}
function FUN25(
)
private
pure
returns (bool)
{
uint256 VAR28 = 0;
VAR29 {
switch VAR30
case 0x0 {
VAR28 := 1
}
case 0x20 {
FUN26(0x0, 0x0, 0x20)
VAR28 := FUN27(0x0)
}
default { }
}
return VAR28 != 0;
}
}
contract TokenProxy is VAR31 {
using SafeMath for uint256;
constructor(
uint256 VAR18
)
public
FUN28(VAR18)
{}
function FUN29(
address VAR26,
address VAR24,
address VAR23,
uint256 value
)
external
VAR32
{
VAR25.FUN22(
VAR26,
VAR24,
VAR23,
value
);
}
function FUN30(
address VAR16,
address VAR26
)
external
view
returns (uint256)
{
return VAR2.FUN4(
VAR25.FUN21(VAR26, VAR16, address(this)),
VAR25.FUN20(VAR26, VAR16)
);
}
}
contract Vault is VAR31
{
using SafeMath for uint256;
event FUN31(
address indexed VAR26,
address indexed VAR23,
address VAR33
);
address public VAR34;
mapping (bytes32 => mapping (address => uint256)) public VAR35;
mapping (address => uint256) public VAR36;
constructor(
address VAR37,
uint256 VAR18
)
public
FUN28(VAR18)
{
VAR34 = VAR37;
}
function FUN32(
address VAR26,
address VAR23
)
external
onlyOwner
returns (uint256)
{
uint256 VAR38 = VAR25.FUN20(VAR26, address(this));
uint256 VAR39 = VAR36[VAR26];
uint256 VAR40 = VAR38.FUN7(VAR39);
require(
VAR40 != 0,
""
);
VAR25.transfer(VAR26, VAR23, VAR40);
emit FUN31(VAR26, VAR23, msg.sender);
return VAR40;
}
function FUN33(
bytes32 VAR41,
address VAR26,
address VAR24,
uint256 VAR27
)
external
VAR32
{
FUN34(VAR34).FUN29(
VAR26,
VAR24,
address(this),
VAR27
);
VAR35[VAR41][VAR26] = VAR35[VAR41][VAR26].FUN8(VAR27);
VAR36[VAR26] = VAR36[VAR26].FUN8(VAR27);
assert(VAR36[VAR26] >= VAR35[VAR41][VAR26]);
FUN35(VAR26);
}
function FUN36(
bytes32 VAR41,
address VAR26,
address VAR23,
uint256 VAR27
)
external
VAR32
{
VAR35[VAR41][VAR26] = VAR35[VAR41][VAR26].FUN7(VAR27);
VAR36[VAR26] = VAR36[VAR26].FUN7(VAR27);
assert(VAR36[VAR26] >= VAR35[VAR41][VAR26]);
VAR25.transfer(VAR26, VAR23, VAR27);
FUN35(VAR26);
}
function FUN35(
address VAR26
)
private
view
{
assert(VAR25.FUN20(VAR26, address(this)) >= VAR36[VAR26]);
}
}
contract VAR42 {
uint256 private VAR43 = 1;
modifier FUN37() {
uint256 VAR44 = VAR43 + 1;
VAR43 = VAR44;
VAR12;
require(
VAR43 == VAR44,
""
);
}
}
library VAR45 {
function FUN38(address VAR46) internal view returns (bool) {
uint256 VAR47;
VAR29 { VAR47 := FUN39(VAR46) }
return VAR47 > 0;
}
}
library VAR48 {
struct VAR49 {
uint128 VAR50;
uint128 VAR51;
}
}
library VAR52 {
using SafeMath for uint256;
using SafeMath for uint128;
function FUN8(
VAR48.Fraction128 memory VAR53,
VAR48.Fraction128 memory VAR54
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
uint256 VAR56 = VAR53.VAR50.FUN5(VAR54.VAR51);
uint256 VAR57 = VAR54.VAR50.FUN5(VAR53.VAR51);
uint256 VAR58 = VAR53.VAR51.FUN5(VAR54.VAR51);
if (VAR56 + VAR57 < VAR56) {
VAR56 = VAR56.FUN6(2);
VAR57 = VAR57.FUN6(2);
VAR58 = VAR58.FUN6(2);
}
return FUN40(VAR56.FUN8(VAR57), VAR58);
}
function FUN41(
VAR48.Fraction128 memory VAR53,
uint128 VAR59
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
if (VAR53.VAR51 % VAR59 == 0) {
return FUN40(
VAR53.VAR50.FUN7(VAR53.VAR51.FUN6(VAR59)),
VAR53.VAR51
);
}
return FUN40(
VAR53.VAR50.FUN5(VAR59).FUN7(VAR53.VAR51),
VAR53.VAR51.FUN5(VAR59)
);
}
function FUN6(
VAR48.Fraction128 memory VAR53,
uint128 VAR59
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
if (VAR53.VAR50 % VAR59 == 0) {
return FUN40(
VAR53.VAR50.FUN6(VAR59),
VAR53.VAR51
);
}
return FUN40(
VAR53.VAR50,
VAR53.VAR51.FUN5(VAR59)
);
}
function FUN5(
VAR48.Fraction128 memory VAR53,
VAR48.Fraction128 memory VAR54
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
return FUN40(
VAR53.VAR50.FUN5(VAR54.VAR50),
VAR53.VAR51.FUN5(VAR54.VAR51)
);
}
function FUN40(
uint256 VAR50,
uint256 VAR51
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
uint256 VAR60 = VAR50 > VAR51 ? VAR50 : VAR51;
uint256 VAR61 = (VAR60 >> 128);
if (VAR61 != 0) {
VAR61 += 1;
VAR50 /= VAR61;
VAR51 /= VAR61;
}
assert(VAR51 != 0);
assert(VAR51 < 2**128);
assert(VAR50 < 2**128);
return VAR48.FUN42({
VAR50: uint128(VAR50),
VAR51: uint128(VAR51)
});
}
function FUN43(
VAR48.Fraction128 memory VAR53
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
FUN44(VAR53);
return VAR48.FUN42({ VAR50: VAR53.VAR50, VAR51: VAR53.VAR51 });
}
function FUN44(
VAR48.Fraction128 memory VAR53
)
private
pure
{
assert(VAR53.VAR51 != 0);
}
}
library VAR62 {
using SafeMath for uint256;
using FractionMath for VAR48.VAR49;
uint128 constant public VAR63 = 340282366920938463463374607431768211455;
uint256 constant public VAR64 = 32;
uint256 constant public VAR65 = 32;
function FUN45(
VAR48.Fraction128 memory VAR66,
uint256 VAR67,
uint256 VAR68
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
require(
VAR67 <= VAR64,
""
);
VAR48.Fraction128 memory VAR69 = VAR66.FUN43();
if (VAR69.VAR50 == 0) {
return FUN46();
}
uint256 VAR70 = uint256(VAR69.VAR50).FUN6(VAR69.VAR51);
if (VAR70 == 0) {
return FUN47(VAR69, VAR67, VAR68);
}
VAR48.Fraction128 memory VAR71 =
FUN48(VAR70 % VAR65);
while (VAR70 >= VAR65) {
VAR71 = VAR71.FUN5(FUN48(VAR65));
VAR70 -= VAR65;
}
VAR48.Fraction128 memory VAR72 = VAR48.FUN42({
VAR50: VAR69.VAR50 % VAR69.VAR51,
VAR51: VAR69.VAR51
});
return FUN47(VAR72, VAR67, VAR68).FUN5(VAR71);
}
function FUN47(
VAR48.Fraction128 memory VAR66,
uint256 VAR67,
uint256 VAR68
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
assert(VAR67 <= VAR64);
assert(VAR66.VAR50 < VAR66.VAR51);
VAR48.Fraction128 memory VAR73 = VAR66.FUN43();
if (VAR73.VAR50 == 0) {
return FUN46();
}
VAR48.Fraction128 memory VAR74 = FUN46();
uint256 VAR59 = 1;
for (uint256 VAR75 = 1; VAR75 <= VAR67; VAR75++) {
VAR59 *= 2;
if (VAR59.FUN5(VAR73.VAR50) >= VAR73.VAR51) {
VAR73 = VAR73.FUN41(uint128(VAR59));
VAR74 = VAR74.FUN5(FUN49(VAR75));
}
}
return VAR74.FUN5(FUN50(VAR73, VAR68));
}
function FUN50(
VAR48.Fraction128 memory VAR66,
uint256 VAR76
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
VAR48.Fraction128 memory VAR69 = VAR66.FUN43();
if (VAR69.VAR50 == 0) {
return FUN46();
}
VAR48.Fraction128 memory VAR74 = FUN46();
VAR48.Fraction128 memory VAR73 = FUN46();
for (uint256 VAR75 = 1; VAR75 <= VAR76; VAR75++) {
VAR73 = VAR73.FUN5(VAR69.FUN6(uint128(VAR75)));
VAR74 = VAR74.FUN8(VAR73);
}
return VAR74;
}
function FUN49(
uint256 VAR77
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
assert(VAR77 <= VAR64);
uint128 VAR58 = [
125182886983370532117250726298150828301,
206391688497133195273760705512282642279,
265012173823417992016237332255925138361,
300298134811882980317033350418940119802,
319665700530617779809390163992561606014,
329812979126047300897653247035862915816,
335006777809430963166468914297166288162,
337634268532609249517744113622081347950,
338955731696479810470146282672867036734,
339618401537809365075354109784799900812,
339950222128463181389559457827561204959,
340116253979683015278260491021941090650,
340199300311581465057079429423749235412,
340240831081268226777032180141478221816,
340261598367316729254995498374473399540,
340271982485676106947851156443492415142,
340277174663693808406010255284800906112,
340279770782412691177936847400746725466,
340281068849199706686796915841848278311,
340281717884450116236033378667952410919,
340282042402539547492367191008339680733,
340282204661700319870089970029119685699,
340282285791309720262481214385569134454,
340282326356121674011576912006427792656,
340282346638529464274601981200276914173,
340282356779733812753265346086924801364,
340282361850336100329388676752133324799,
340282364385637272451648746721404212564,
340282365653287865596328444437856608255,
340282366287113163939555716675618384724,
340282366604025813553891209601455838559,
340282366762482138471739420386372790954,
340282366841710300958333641874363209044
][VAR77];
return VAR48.FUN42({
VAR50: VAR63,
VAR51: VAR58
});
}
function FUN48(
uint256 VAR77
)
internal
pure
returns (VAR48.Fraction128 VAR55)
{
assert(VAR77 <= VAR65);
uint128 VAR58 = [
340282366920938463463374607431768211455,
125182886983370532117250726298150828301,
46052210507670172419625860892627118820,
16941661466271327126146327822211253888,
6232488952727653950957829210887653621,
2292804553036637136093891217529878878,
843475657686456657683449904934172134,
310297353591408453462393329342695980,
114152017036184782947077973323212575,
41994180235864621538772677139808695,
15448795557622704876497742989562086,
5683294276510101335127414470015662,
2090767122455392675095471286328463,
769150240628514374138961856925097,
282954560699298259527814398449860,
104093165666968799599694528310221,
38293735615330848145349245349513,
14087478058534870382224480725096,
5182493555688763339001418388912,
1906532833141383353974257736699,
701374233231058797338605168652,
258021160973090761055471434334,
94920680509187392077350434438,
34919366901332874995585576427,
12846117181722897538509298435,
4725822410035083116489797150,
1738532907279185132707372378,
639570514388029575350057932,
235284843422800231081973821,
86556456714490055457751527,
31842340925906738090071268,
11714142585413118080082437,
4309392228124372433711936
][VAR77];
return VAR48.FUN42({
VAR50: VAR63,
VAR51: VAR58
});
}
function FUN46()
private
pure
returns (VAR48.Fraction128 VAR55)
{
return VAR48.FUN42({ VAR50: 1, VAR51: 1 });
}
}
library VAR78 {
using SafeMath for uint256;
function FUN51(
uint256 VAR79,
uint256 VAR58,
uint256 VAR80
)
internal
pure
returns (uint256)
{
return VAR79.FUN5(VAR80).FUN6(VAR58);
}
function FUN52(
uint256 VAR79,
uint256 VAR58,
uint256 VAR80
)
internal
pure
returns (uint256)
{
return FUN53(VAR79.FUN5(VAR80), VAR58);
}
function FUN53(
uint256 VAR79,
uint256 VAR58
)
internal
pure
returns (uint256)
{
assert(VAR58 != 0);
if (VAR79 == 0) {
return 0;
}
return VAR79.FUN7(1).FUN6(VAR58).FUN8(1);
}
function FUN54(
)
internal
pure
returns (uint256)
{
return 2 ** 256 - 1;
}
function FUN55(
)
internal
pure
returns (VAR81)
{
return 2 ** 32 - 1;
}
function FUN56(
uint256 VAR82
)
internal
pure
returns (uint256)
{
uint256 VAR83 = 0;
uint256 VAR84 = 256;
while (VAR83 < VAR84) {
uint256 VAR85 = (VAR83 + VAR84) / 2;
if ((VAR82 >> VAR85) == 0) {
VAR84 = VAR85;
} else {
VAR83 = VAR85 + 1;
}
}
assert(VAR83 <= 256);
return VAR83;
}
}
library VAR86 {
using SafeMath for uint256;
using FractionMath for VAR48.VAR49;
uint256 constant VAR87 = 11;
uint256 constant VAR88 = 5;
uint256 constant VAR89 = 80;
uint128 constant VAR90 = 55406223843935100525711733958316613;
function FUN57(
uint256 VAR91,
uint256 VAR92,
uint256 VAR93
)
public
pure
returns (uint256)
{
uint256 VAR79 = VAR92.FUN5(VAR93);
uint128 VAR58 = (10**8) * (365 * 1 VAR94);
assert(VAR79 < 2**128);
VAR48.Fraction128 memory VAR95 = VAR48.FUN42({
VAR50: uint128(VAR79),
VAR51: VAR58
});
VAR48.Fraction128 memory VAR96;
if (VAR79.FUN6(VAR58) >= VAR89) {
VAR96 = VAR48.FUN42({
VAR50: VAR90,
VAR51: 1
});
} else {
VAR96 = VAR62.FUN45(
VAR95,
VAR87,
VAR88
);
}
assert(VAR96.VAR50 >= VAR96.VAR51);
return FUN58(VAR91, VAR96);
}
function FUN58(
uint256 VAR82,
VAR48.Fraction128 memory VAR97
)
private
pure
returns (uint256)
{
uint256 VAR98 = VAR82.FUN6(2 ** 128);
uint256 VAR99 = VAR82 % (2 ** 128);
if (VAR98 > 0) {
VAR98 = VAR98.FUN5(VAR97.VAR50);
uint256 VAR100 = VAR78.FUN56(VAR98);
VAR98 = VAR78.FUN53(
VAR98 << (uint256(256).FUN7(VAR100)),
VAR97.VAR51);
if (VAR100 > 128) {
VAR98 = VAR98 << (VAR100.FUN7(128));
} else if (VAR100 < 128) {
VAR98 = VAR98 >> (uint256(128).FUN7(VAR100));
}
}
VAR99 = VAR78.FUN52(
VAR97.VAR50,
VAR97.VAR51,
VAR99
);
return VAR98.FUN8(VAR99);
}
}
library VAR101 {
struct VAR102 {
address VAR103;
address VAR34;
mapping (bytes32 => uint256) VAR104;
mapping (bytes32 => uint256) VAR105;
mapping (bytes32 => VAR106.VAR107) VAR108;
mapping (bytes32 => bool) VAR109;
mapping (bytes32 => uint256) VAR110;
}
}
interface VAR111 {
function FUN59(
address VAR24,
bytes32 VAR112
)
external
returns (address);
}
interface VAR113 {
function FUN60(
address VAR24,
bytes32 VAR112
)
external
returns (address);
}
library VAR114 {
event FUN61(
bytes32 indexed VAR112,
address indexed VAR24,
address indexed VAR23
);
event FUN62(
bytes32 indexed VAR112,
address indexed VAR24,
address indexed VAR23
);
function FUN63(
bytes32 VAR112,
address VAR115,
address VAR11
)
internal
returns (address)
{
if (VAR115 != address(0)) {
emit FUN61(VAR112, VAR115, VAR11);
}
if (VAR45.FUN38(VAR11)) {
address VAR116 =
FUN64(VAR11).FUN59(VAR115, VAR112);
if (VAR116 != VAR11) {
return FUN63(VAR112, VAR11, VAR116);
}
}
require(
VAR11 != address(0),
""
);
return VAR11;
}
function FUN65(
bytes32 VAR112,
address VAR115,
address VAR11
)
internal
returns (address)
{
if (VAR115 != address(0)) {
emit FUN62(VAR112, VAR115, VAR11);
}
if (VAR45.FUN38(VAR11)) {
address VAR116 =
FUN66(VAR11).FUN60(VAR115, VAR112);
if (VAR116 != VAR11) {
return FUN65(VAR112, VAR11, VAR116);
}
}
require(
VAR11 != address(0),
""
);
return VAR11;
}
}
library VAR117 {
function FUN67()
internal
view
returns (VAR81)
{
assert(uint256(FUN68(VAR19.VAR20)) == VAR19.VAR20);
assert(VAR19.VAR20 > 0);
return FUN68(VAR19.VAR20);
}
}
library VAR106 {
using SafeMath for uint256;
struct VAR107 {
address VAR118;
address VAR119;
address VAR120;
address VAR9;
uint256 VAR91;
uint256 VAR121;
uint32  VAR122;
uint32  VAR123;
uint32  VAR124;
uint32  VAR125;
uint32  VAR92;
uint32  VAR126;
}
struct VAR127 {
address   VAR118;
address   VAR119;
address   VAR128;
address   VAR9;
address   VAR129;
address   VAR130;
address   VAR131;
address   VAR132;
address   VAR133;
LoanRates VAR134;
uint256   VAR135;
uint32    VAR122;
uint32    VAR125;
uint256   VAR136;
bytes32   VAR137;
bytes     VAR138;
}
struct VAR139 {
uint256 VAR140;
uint256 VAR141;
uint256 VAR142;
uint256 VAR143;
uint256 VAR144;
uint32  VAR92;
uint32  VAR126;
}
function FUN69(
VAR101.State storage VAR145,
bytes32 VAR112,
Position memory VAR146,
address VAR147
)
internal
{
assert(!FUN70(VAR145, VAR112));
assert(VAR146.VAR118 != address(0));
assert(VAR146.VAR119 != address(0));
assert(VAR146.VAR118 != VAR146.VAR119);
assert(VAR146.VAR9 != address(0));
assert(VAR146.VAR120 != address(0));
assert(VAR146.VAR125 != 0);
assert(VAR146.VAR126 <= VAR146.VAR125);
assert(VAR146.VAR124 == 0);
assert(VAR146.VAR121 == 0);
VAR145.VAR108[VAR112].VAR118 = VAR146.VAR118;
VAR145.VAR108[VAR112].VAR119 = VAR146.VAR119;
VAR145.VAR108[VAR112].VAR91 = VAR146.VAR91;
VAR145.VAR108[VAR112].VAR122 = VAR146.VAR122;
VAR145.VAR108[VAR112].VAR123 = VAR117.FUN67();
VAR145.VAR108[VAR112].VAR125 = VAR146.VAR125;
VAR145.VAR108[VAR112].VAR92 = VAR146.VAR92;
VAR145.VAR108[VAR112].VAR126 = VAR146.VAR126;
VAR145.VAR108[VAR112].VAR9 = VAR114.FUN65(
VAR112,
(VAR146.VAR9 != msg.sender) ? msg.sender : address(0),
VAR146.VAR9
);
VAR145.VAR108[VAR112].VAR120 = VAR114.FUN63(
VAR112,
(VAR146.VAR120 != VAR147) ? VAR147 : address(0),
VAR146.VAR120
);
}
function FUN71(
uint256 VAR148
)
internal
view
returns (bytes32)
{
return FUN72(VAR149.FUN73(msg.sender, VAR148));
}
function FUN74(
VAR101.State storage VAR145,
bytes32 VAR137
)
internal
view
returns (uint256)
{
return VAR145.VAR104[VAR137].FUN8(VAR145.VAR105[VAR137]);
}
function FUN75(
VAR101.State storage VAR145,
bytes32 VAR112
)
internal
{
delete VAR145.VAR108[VAR112];
VAR145.VAR109[VAR112] = true;
}
function FUN76(
Position storage VAR146,
uint256 VAR150,
uint256 VAR151
)
internal
view
returns (uint256)
{
uint256 VAR152 = FUN77(VAR146, VAR151);
return VAR86.FUN57(
VAR150,
VAR146.VAR92,
VAR152
);
}
function FUN77(
Position storage VAR146,
uint256 VAR20
)
internal
view
returns (uint256)
{
uint256 VAR153 = VAR20.FUN7(VAR146.VAR123);
uint256 VAR154 = VAR146.VAR126;
if (VAR154 > 1) {
VAR153 = VAR78.FUN53(VAR153, VAR154).FUN5(VAR154);
}
return VAR2.FUN4(
VAR153,
VAR146.VAR125
);
}
function FUN78(
Position storage VAR146,
uint256 VAR155,
uint256 VAR151
)
internal
view
returns (uint256)
{
uint256 VAR152 = FUN79(VAR146, VAR151);
return VAR86.FUN57(
VAR155,
VAR146.VAR92,
VAR152
);
}
function FUN80(
LoanOffering VAR156
)
internal
view
returns (bytes32)
{
return FUN72(
VAR149.FUN73(
address(this),
VAR156.VAR118,
VAR156.VAR119,
VAR156.VAR128,
VAR156.VAR9,
VAR156.VAR129,
VAR156.VAR130,
VAR156.VAR131,
VAR156.VAR132,
VAR156.VAR133,
FUN81(VAR156)
)
);
}
function FUN82(
VAR101.State storage VAR145,
bytes32 VAR112
)
internal
view
returns(uint256)
{
return FUN83(VAR145.VAR103).FUN84(VAR112, VAR145.VAR108[VAR112].VAR119);
}
function FUN85(
VAR101.State storage VAR145,
bytes32 VAR112
)
internal
view
returns (bool)
{
return VAR145.VAR108[VAR112].VAR123 != 0;
}
function FUN70(
VAR101.State storage VAR145,
bytes32 VAR112
)
internal
view
returns (bool)
{
return FUN85(VAR145, VAR112) || VAR145.VAR109[VAR112];
}
function FUN86(
VAR101.State storage VAR145,
bytes32 VAR112
)
internal
view
returns (Position VAR157)
{
Position storage VAR146 = VAR145.VAR108[VAR112];
require(
VAR146.VAR123 != 0,
""
);
return VAR146;
}
function FUN79(
Position storage VAR146,
uint256 VAR20
)
private
view
returns (uint256)
{
uint256 VAR153 = VAR20.FUN7(VAR146.VAR123);
uint256 VAR154 = VAR146.VAR126;
if (VAR154 > 1) {
VAR153 = VAR153.FUN6(VAR154).FUN5(VAR154);
}
return VAR2.FUN4(
VAR153,
VAR146.VAR125
);
}
function FUN81(
LoanOffering VAR156
)
private
pure
returns (bytes32)
{
return FUN72(
VAR149.FUN73(
VAR156.VAR134.VAR140,
VAR156.VAR134.VAR141,
VAR156.VAR134.VAR142,
VAR156.VAR134.VAR143,
VAR156.VAR134.VAR144,
VAR156.VAR135,
VAR156.VAR136,
VAR156.VAR122,
VAR156.VAR125,
VAR156.VAR134.VAR92,
VAR156.VAR134.VAR126
)
);
}
}
interface VAR158 {
function FUN87(
bytes32 VAR112,
uint256 VAR150,
address VAR159,
address VAR130,
address VAR119,
uint256 VAR160,
uint256 VAR161,
bool    VAR162
)
external
returns (bool);
}
interface VAR163 {
function FUN88(
address VAR159,
address VAR164,
bytes32 VAR112,
uint256 VAR165
)
external
returns (address, uint256);
}
interface VAR166 {
function FUN89(
address VAR159,
address VAR164,
bytes32 VAR112,
uint256 VAR165
)
external
returns (address, uint256);
}
library VAR167 {
using SafeMath for uint256;
struct VAR168 {
bytes32 VAR112;
uint256 VAR169;
uint256 VAR150;
uint256 VAR170;
uint256 VAR171;
uint256 VAR172;
address VAR164;
address VAR118;
address VAR119;
address VAR130;
address VAR173;
address VAR174;
bool    VAR162;
}
function FUN90(
VAR101.State storage VAR145,
CloseTx memory VAR175
)
internal
{
if (VAR175.VAR150 == VAR175.VAR169) {
VAR106.FUN75(VAR145, VAR175.VAR112);
} else {
assert(
VAR175.VAR169 == VAR145.VAR108[VAR175.VAR112].VAR91
);
VAR145.VAR108[VAR175.VAR112].VAR91 =
VAR175.VAR169.FUN7(VAR175.VAR150);
}
}
function FUN91(
VAR101.State storage VAR145,
VAR167.CloseTx memory VAR175,
uint256 VAR176,
uint256 VAR177
)
internal
returns (uint256)
{
uint256 VAR160;
if (VAR175.VAR162) {
VAR160 = VAR175.VAR172.FUN7(VAR176);
FUN83(VAR145.VAR103).FUN36(
VAR175.VAR112,
VAR175.VAR119,
VAR175.VAR164,
VAR160
);
} else {
assert(VAR175.VAR174 != address(0));
VAR160 = VAR177.FUN7(VAR175.VAR170);
FUN34(VAR145.VAR34).FUN29(
VAR175.VAR118,
VAR175.VAR174,
VAR175.VAR164,
VAR160
);
}
if (VAR45.FUN38(VAR175.VAR164)) {
require(
FUN92(VAR175.VAR164).FUN87(
VAR175.VAR112,
VAR175.VAR150,
msg.sender,
VAR175.VAR130,
VAR175.VAR119,
VAR160,
VAR175.VAR172,
VAR175.VAR162
),
""
);
}
assert(
VAR106.FUN82(VAR145, VAR175.VAR112)
== VAR175.VAR171.FUN7(VAR175.VAR172)
);
return VAR160;
}
function FUN93(
VAR101.State storage VAR145,
bytes32 VAR112,
uint256 VAR165,
address VAR164,
address VAR174,
bool VAR162,
bool VAR178
)
internal
returns (CloseTx VAR55)
{
require(
VAR164 != address(0),
""
);
require(
VAR165 > 0,
""
);
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
uint256 VAR150 = FUN94(
VAR146,
VAR112,
VAR165,
VAR164,
VAR178
);
return FUN95(
VAR145,
VAR146,
VAR112,
VAR150,
VAR164,
VAR174,
VAR162,
VAR178
);
}
function FUN94(
VAR106.Position storage VAR146,
bytes32 VAR112,
uint256 VAR165,
address VAR164,
bool VAR179
)
private
returns (uint256)
{
uint256 VAR180 = VAR2.FUN4(VAR165, VAR146.VAR91);
VAR180 = FUN96(
VAR146.VAR9,
msg.sender,
VAR164,
VAR112,
VAR180
);
if (VAR179) {
VAR180 = FUN97(
VAR146.VAR120,
msg.sender,
VAR164,
VAR112,
VAR180
);
}
assert(VAR180 > 0);
assert(VAR180 <= VAR146.VAR91);
assert(VAR180 <= VAR165);
return VAR180;
}
function FUN96(
address VAR181,
address VAR159,
address VAR164,
bytes32 VAR112,
uint256 VAR150
)
private
returns (uint256)
{
if (VAR159 == VAR181) {
return VAR150;
}
(
address VAR182,
uint256 VAR183
) = FUN98(VAR181).FUN89(
VAR159,
VAR164,
VAR112,
VAR150
);
require(
VAR183 <= VAR150,
""
);
require(
VAR183 > 0,
""
);
if (VAR182 != VAR181) {
FUN96(
VAR182,
VAR159,
VAR164,
VAR112,
VAR183
);
}
return VAR183;
}
function FUN97(
address VAR181,
address VAR159,
address VAR164,
bytes32 VAR112,
uint256 VAR150
)
private
returns (uint256)
{
if (VAR159 == VAR181) {
return VAR150;
}
(
address VAR182,
uint256 VAR183
) = FUN99(VAR181).FUN88(
VAR159,
VAR164,
VAR112,
VAR150
);
require(
VAR183 <= VAR150,
""
);
require(
VAR183 > 0,
""
);
if (VAR182 != VAR181) {
FUN97(
VAR182,
VAR159,
VAR164,
VAR112,
VAR183
);
}
return VAR183;
}
function FUN95(
VAR101.State storage VAR145,
VAR106.Position storage VAR146,
bytes32 VAR112,
uint256 VAR150,
address VAR164,
address VAR174,
bool VAR162,
bool VAR178
)
private
view
returns (CloseTx VAR55)
{
uint256 VAR171 = VAR106.FUN82(VAR145, VAR112);
uint256 VAR172 = VAR78.FUN51(
VAR150,
VAR146.VAR91,
VAR171
);
uint256 VAR170 = 0;
if (!VAR178) {
VAR170 = VAR106.FUN76(
VAR146,
VAR150,
VAR19.VAR20
);
}
return FUN100({
VAR112: VAR112,
VAR169: VAR146.VAR91,
VAR150: VAR150,
VAR170: VAR170,
VAR171: VAR171,
VAR172: VAR172,
VAR164: VAR164,
VAR118: VAR146.VAR118,
VAR119: VAR146.VAR119,
VAR130: VAR146.VAR9,
VAR173: VAR146.VAR120,
VAR174: VAR174,
VAR162: VAR162
});
}
}
interface VAR184 {
function FUN101(
address VAR185,
address VAR186,
address VAR187,
address VAR188,
uint256 VAR189,
bytes VAR190
)
external
returns (uint256);
function FUN102(
address VAR187,
address VAR188,
uint256 VAR191,
bytes VAR190
)
external
view
returns (uint256);
}
library VAR192 {
using SafeMath for uint256;
event FUN103(
bytes32 indexed VAR112,
address indexed VAR159,
address indexed VAR164,
uint256 VAR150,
uint256 VAR193,
uint256 VAR194,
uint256 VAR195,
uint256 VAR176,
bool    VAR162
);
function FUN104(
VAR101.State storage VAR145,
bytes32 VAR112,
uint256 VAR196,
address VAR164,
address VAR174,
bool VAR162,
bytes memory VAR190
)
public
returns (uint256, uint256, uint256)
{
VAR167.CloseTx memory VAR175 = VAR167.FUN93(
VAR145,
VAR112,
VAR196,
VAR164,
VAR174,
VAR162,
false
);
(
uint256 VAR176,
uint256 VAR177
) = FUN105(
VAR145,
VAR175,
VAR190
);
uint256 VAR160 = VAR167.FUN91(
VAR145,
VAR175,
VAR176,
VAR177
);
VAR167.FUN90(VAR145, VAR175);
FUN106(
VAR175,
VAR176,
VAR160
);
return (
VAR175.VAR150,
VAR160,
VAR175.VAR170
);
}
function FUN105(
VAR101.State storage VAR145,
VAR167.CloseTx memory VAR175,
bytes memory VAR190
)
private
returns (uint256, uint256)
{
uint256 VAR176 = 0;
uint256 VAR177 = 0;
uint256 VAR197 = VAR175.VAR170;
if (VAR175.VAR174 == address(0)) {
require(
VAR175.VAR162,
""
);
FUN34(VAR145.VAR34).FUN29(
VAR175.VAR118,
msg.sender,
VAR175.VAR173,
VAR197
);
} else {
(VAR176, VAR177) = FUN107(
VAR145,
VAR175,
VAR190
);
if (VAR175.VAR162) {
assert(VAR177 >= VAR197);
VAR197 = VAR177;
}
FUN34(VAR145.VAR34).FUN29(
VAR175.VAR118,
VAR175.VAR174,
VAR175.VAR173,
VAR197
);
}
VAR145.VAR110[VAR175.VAR112] =
VAR145.VAR110[VAR175.VAR112].FUN8(VAR197);
return (VAR176, VAR177);
}
function FUN107(
VAR101.State storage VAR145,
VAR167.CloseTx VAR175,
bytes memory VAR190
)
private
returns (uint256, uint256)
{
uint256 VAR176;
if (VAR175.VAR162) {
VAR176 = FUN108(VAR175.VAR174)
.FUN102(
VAR175.VAR118,
VAR175.VAR119,
VAR175.VAR170,
VAR190
);
require(
VAR176 <= VAR175.VAR172,
""
);
} else {
VAR176 = VAR175.VAR172;
}
FUN83(VAR145.VAR103).FUN36(
VAR175.VAR112,
VAR175.VAR119,
VAR175.VAR174,
VAR176
);
uint256 VAR177 = FUN108(VAR175.VAR174).FUN101(
msg.sender,
VAR145.VAR34,
VAR175.VAR118,
VAR175.VAR119,
VAR176,
VAR190
);
require(
VAR177 >= VAR175.VAR170,
""
);
return (VAR176, VAR177);
}
function FUN106(
VAR167.CloseTx VAR175,
uint256 VAR176,
uint256 VAR160
)
private
{
emit FUN103(
VAR175.VAR112,
msg.sender,
VAR175.VAR164,
VAR175.VAR150,
VAR175.VAR169.FUN7(VAR175.VAR150),
VAR175.VAR170,
VAR160,
VAR176,
VAR175.VAR162
);
}
}
library VAR198 {
using SafeMath for uint256;
event FUN103(
bytes32 indexed VAR112,
address indexed VAR159,
address indexed VAR164,
uint256 VAR150,
uint256 VAR193,
uint256 VAR194,
uint256 VAR195,
uint256 VAR176,
bool VAR162
);
function FUN109(
VAR101.State storage VAR145,
bytes32 VAR112,
uint256 VAR196,
address VAR164
)
public
returns (uint256, uint256)
{
VAR167.CloseTx memory VAR175 = VAR167.FUN93(
VAR145,
VAR112,
VAR196,
VAR164,
address(0),
true,
true
);
uint256 VAR199 = VAR167.FUN91(
VAR145,
VAR175,
0,
0
);
VAR167.FUN90(VAR145, VAR175);
FUN110(VAR175);
return (
VAR175.VAR150,
VAR199
);
}
function FUN110(
VAR167.CloseTx VAR175
)
private
{
emit FUN103(
VAR175.VAR112,
msg.sender,
VAR175.VAR164,
VAR175.VAR150,
VAR175.VAR169.FUN7(VAR175.VAR150),
0,
VAR175.VAR172,
0,
true
);
}
}
interface VAR200 {
function FUN111(
address VAR201,
bytes32 VAR112,
uint256 VAR27
)
external
returns (address);
}
library VAR202 {
using SafeMath for uint256;
event FUN112(
bytes32 indexed VAR112,
uint256 VAR27,
address VAR201
);
event FUN113(
bytes32 indexed VAR112,
address indexed VAR120,
address indexed VAR9,
uint256 VAR203
);
function FUN114(
VAR101.State storage VAR145,
bytes32 VAR112,
uint256 VAR203
)
public
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
require(
VAR203 > 0,
""
);
FUN115(
VAR146.VAR9,
msg.sender,
VAR112,
VAR203
);
FUN83(VAR145.VAR103).FUN33(
VAR112,
VAR146.VAR119,
msg.sender,
VAR203
);
bool VAR204 = false;
uint256 VAR121 = VAR146.VAR121;
if (VAR146.VAR124 > 0 && VAR121 > 0) {
if (VAR203 >= VAR121) {
VAR146.VAR121 = 0;
VAR146.VAR124 = 0;
VAR204 = true;
} else {
VAR146.VAR121 = VAR146.VAR121.FUN7(VAR203);
}
}
emit FUN112(
VAR112,
VAR203,
msg.sender
);
if (VAR204) {
emit FUN113(
VAR112,
VAR146.VAR120,
msg.sender,
VAR203
);
}
}
function FUN115(
address VAR181,
address VAR201,
bytes32 VAR112,
uint256 VAR27
)
private
{
if (VAR201 == VAR181) {
return;
}
address VAR182 =
FUN116(VAR181).FUN111(
VAR201,
VAR112,
VAR27
);
if (VAR182 != VAR181) {
FUN115(
VAR182,
VAR201,
VAR112,
VAR27
);
}
}
}
interface VAR205 {
function FUN117(
address VAR206,
bytes32 VAR112,
address VAR207
)
external
returns (address);
}
library VAR208 {
using SafeMath for uint256;
event FUN118(
bytes32 indexed VAR112,
address indexed VAR207,
uint256 VAR27
);
function FUN119(
VAR101.State storage VAR145,
bytes32 VAR112,
address VAR207
)
public
returns (uint256)
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
require(
(
VAR146.VAR124 > 0
&& VAR19.VAR20 >= uint256(VAR146.VAR124).FUN8(VAR146.VAR122)
) || (
VAR19.VAR20 >= uint256(VAR146.VAR123).FUN8(VAR146.VAR125)
),
""
);
FUN120(
VAR146.VAR120,
msg.sender,
VAR112,
VAR207
);
uint256 VAR209 = VAR106.FUN82(VAR145, VAR112);
FUN83(VAR145.VAR103).FUN36(
VAR112,
VAR146.VAR119,
VAR207,
VAR209
);
VAR106.FUN75(
VAR145,
VAR112
);
emit FUN118(
VAR112,
VAR207,
VAR209
);
return VAR209;
}
function FUN120(
address VAR181,
address VAR206,
bytes32 VAR112,
address VAR207
)
private
{
if (VAR206 == VAR181) {
return;
}
address VAR182 =
FUN121(VAR181).FUN117(
VAR206,
VAR112,
VAR207
);
if (VAR182 != VAR181) {
FUN120(
VAR182,
VAR206,
VAR112,
VAR207
);
}
}
}
library VAR210 {
uint8 private constant VAR211 = 0;
uint8 private constant VAR212 = 1;
uint8 private constant VAR213 = 2;
uint8 private constant VAR214 = 3;
bytes constant private VAR215 = "";
bytes constant private VAR216 = "";
function FUN122(
bytes32 VAR217,
bytes VAR218
)
internal
pure
returns (address)
{
require(
VAR218.VAR219 == 66,
""
);
uint8 VAR220 = uint8(VAR218[0]);
require(
VAR220 > uint8(VAR211),
""
);
require(
VAR220 < uint8(VAR214),
""
);
uint8 VAR221 = uint8(VAR218[1]);
bytes32 VAR222;
bytes32 VAR223;
VAR29 {
VAR222 := FUN27(FUN8(VAR218, 34))
VAR223 := FUN27(FUN8(VAR218, 66))
}
bytes32 VAR224;
if (VAR220 == VAR212) {
VAR224 = FUN72(VAR149.FUN73(VAR216, VAR217));
} else {
assert(VAR220 == VAR213);
VAR224 = FUN72(VAR149.FUN73(VAR215, VAR217));
}
return FUN123(
VAR224,
VAR221,
VAR222,
VAR223
);
}
}
interface VAR225 {
function FUN124(
address[9] VAR226,
uint256[7] VAR227,
VAR81[4] VAR228,
bytes32 VAR112,
bytes VAR138
)
external
returns (address);
}
library VAR229 {
using SafeMath for uint256;
struct VAR230 {
bytes32 VAR112;
address VAR9;
uint256 VAR91;
uint256 VAR231;
VAR106.LoanOffering VAR156;
address VAR174;
bool VAR232;
uint256 VAR203;
uint256 VAR233;
uint256 VAR234;
}
function FUN125(
VAR101.State storage VAR145,
Tx memory VAR175
)
internal
{
assert(VAR175.VAR231 >= VAR175.VAR91);
require(
VAR175.VAR91 > 0,
""
);
if (VAR175.VAR156.VAR129 != address(0)) {
require(
msg.sender == VAR175.VAR156.VAR129,
""
);
}
if (VAR175.VAR156.VAR130 != address(0)) {
require(
VAR175.VAR9 == VAR175.VAR156.VAR130,
""
);
}
if (VAR45.FUN38(VAR175.VAR156.VAR128)) {
FUN126(VAR175);
} else {
require(
VAR175.VAR156.VAR128 == VAR210.FUN122(
VAR175.VAR156.VAR137,
VAR175.VAR156.VAR138
),
""
);
}
uint256 VAR235 = VAR106.FUN74(
VAR145,
VAR175.VAR156.VAR137
);
require(
VAR175.VAR231.FUN8(VAR235) <= VAR175.VAR156.VAR134.VAR140,
""
);
require(
VAR175.VAR231 >= VAR175.VAR156.VAR134.VAR141,
""
);
require(
VAR175.VAR156.VAR118 != VAR175.VAR156.VAR119,
""
);
require(
VAR175.VAR9 != address(0),
""
);
require(
VAR175.VAR156.VAR9 != address(0),
""
);
require(
VAR175.VAR156.VAR135 > VAR19.VAR20,
""
);
require(
VAR175.VAR156.VAR125 > 0,
""
);
require(
VAR175.VAR156.VAR134.VAR126 <= VAR175.VAR156.VAR125,
""
);
}
function FUN127(
VAR101.State storage VAR145,
Tx memory VAR175
)
internal
{
FUN128(VAR175);
FUN129(VAR145, VAR175);
VAR145.VAR104[VAR175.VAR156.VAR137] =
VAR145.VAR104[VAR175.VAR156.VAR137].FUN8(VAR175.VAR231);
}
function FUN130(
VAR101.State storage VAR145,
Tx VAR175,
bytes VAR190,
uint256 VAR236
)
internal
returns (uint256)
{
FUN131(VAR145, VAR175);
uint256 VAR237 = VAR175.VAR232 ?
VAR175.VAR231 :
VAR175.VAR231.FUN8(VAR175.VAR203);
uint256 VAR234 = VAR2.FUN4(
VAR236,
FUN108(VAR175.VAR174).FUN101(
msg.sender,
VAR145.VAR34,
VAR175.VAR156.VAR119,
VAR175.VAR156.VAR118,
VAR237,
VAR190
)
);
FUN83(VAR145.VAR103).FUN33(
VAR175.VAR112,
VAR175.VAR156.VAR119,
VAR175.VAR174,
VAR234
);
VAR175.VAR233 = VAR175.VAR233.FUN8(VAR234);
return VAR234;
}
function FUN132(
VAR101.State storage VAR145,
Tx VAR175
)
internal
{
FUN34(VAR145.VAR34).FUN29(
VAR175.VAR156.VAR118,
msg.sender,
VAR175.VAR174,
VAR175.VAR203
);
}
function FUN133(
VAR101.State storage VAR145,
Tx VAR175
)
internal
{
FUN83(VAR145.VAR103).FUN33(
VAR175.VAR112,
VAR175.VAR156.VAR119,
msg.sender,
VAR175.VAR203
);
VAR175.VAR233 = VAR175.VAR233.FUN8(VAR175.VAR203);
}
function FUN128(
Tx VAR175
)
private
pure
{
uint256 VAR238 = VAR175.VAR232 ?
VAR175.VAR234.FUN8(VAR175.VAR203) :
VAR175.VAR234;
assert(VAR175.VAR233 == VAR238);
uint256 VAR239 = VAR78.FUN52(
VAR175.VAR231,
VAR175.VAR156.VAR134.VAR140,
VAR175.VAR156.VAR134.VAR142
);
require(
VAR175.VAR233 >= VAR239,
""
);
}
function FUN126(
Tx VAR175
)
private
{
FUN134(
VAR175.VAR156.VAR128,
FUN135(VAR175),
FUN136(VAR175),
FUN137(VAR175),
VAR175.VAR112,
VAR175.VAR156.VAR138
);
}
function FUN134(
address VAR181,
address[9] VAR226,
uint256[7] VAR227,
VAR81[4] VAR228,
bytes32 VAR112,
bytes VAR138
)
private
{
address VAR182 = FUN138(VAR181).FUN124(
VAR226,
VAR227,
VAR228,
VAR112,
VAR138
);
if (VAR182 != VAR181) {
FUN134(
VAR182,
VAR226,
VAR227,
VAR228,
VAR112,
VAR138
);
}
}
function FUN131(
VAR101.State storage VAR145,
Tx VAR175
)
private
{
FUN34(VAR145.VAR34).FUN29(
VAR175.VAR156.VAR118,
VAR175.VAR156.VAR128,
VAR175.VAR174,
VAR175.VAR231
);
}
function FUN129(
VAR101.State storage VAR145,
Tx VAR175
)
private
{
if (VAR175.VAR156.VAR131 == address(0)) {
return;
}
TokenProxy VAR37 = FUN34(VAR145.VAR34);
uint256 VAR143 = VAR78.FUN51(
VAR175.VAR231,
VAR175.VAR156.VAR134.VAR140,
VAR175.VAR156.VAR134.VAR143
);
uint256 VAR144 = VAR78.FUN51(
VAR175.VAR231,
VAR175.VAR156.VAR134.VAR140,
VAR175.VAR156.VAR134.VAR144
);
if (VAR143 > 0) {
VAR37.FUN29(
VAR175.VAR156.VAR132,
VAR175.VAR156.VAR128,
VAR175.VAR156.VAR131,
VAR143
);
}
if (VAR144 > 0) {
VAR37.FUN29(
VAR175.VAR156.VAR133,
msg.sender,
VAR175.VAR156.VAR131,
VAR144
);
}
}
function FUN135(
Tx VAR175
)
private
pure
returns (address[9])
{
return [
VAR175.VAR156.VAR118,
VAR175.VAR156.VAR119,
VAR175.VAR156.VAR128,
VAR175.VAR156.VAR9,
VAR175.VAR156.VAR129,
VAR175.VAR156.VAR130,
VAR175.VAR156.VAR131,
VAR175.VAR156.VAR132,
VAR175.VAR156.VAR133
];
}
function FUN136(
Tx VAR175
)
private
pure
returns (uint256[7])
{
return [
VAR175.VAR156.VAR134.VAR140,
VAR175.VAR156.VAR134.VAR141,
VAR175.VAR156.VAR134.VAR142,
VAR175.VAR156.VAR134.VAR143,
VAR175.VAR156.VAR134.VAR144,
VAR175.VAR156.VAR135,
VAR175.VAR156.VAR136
];
}
function FUN137(
Tx VAR175
)
private
pure
returns (VAR81[4])
{
return [
VAR175.VAR156.VAR122,
VAR175.VAR156.VAR125,
VAR175.VAR156.VAR134.VAR92,
VAR175.VAR156.VAR134.VAR126
];
}
}
interface VAR240 {
function FUN139(
address VAR128,
bytes32 VAR112,
uint256 VAR241,
uint256 VAR242
)
external
returns (address);
}
interface VAR243 {
function FUN140(
address VAR244,
bytes32 VAR112,
uint256 VAR241
)
external
returns (address);
}
library VAR245 {
using SafeMath for uint256;
event FUN141(
bytes32 indexed VAR112,
address indexed VAR244,
address indexed VAR120,
address VAR130,
address VAR246,
bytes32 VAR137,
address VAR247,
uint256 VAR248,
uint256 VAR241,
uint256 VAR234,
uint256 VAR203,
bool    VAR232
);
function FUN142(
VAR101.State storage VAR145,
bytes32 VAR112,
address[7] VAR226,
uint256[8] VAR227,
VAR81[2] VAR228,
bool VAR232,
bytes VAR138,
bytes VAR190
)
public
returns (uint256)
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
VAR229.Tx memory VAR175 = FUN143(
VAR146,
VAR112,
VAR226,
VAR227,
VAR228,
VAR232,
VAR138
);
FUN144(VAR145, VAR175, VAR146);
FUN145(VAR145, VAR175, VAR190);
FUN146(
VAR146,
VAR175.VAR112,
VAR175.VAR91,
VAR175.VAR231,
VAR175.VAR156.VAR128
);
FUN147(VAR175, VAR146);
return VAR175.VAR231;
}
function FUN148(
VAR101.State storage VAR145,
bytes32 VAR112,
uint256 VAR155
)
public
returns (uint256)
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
require(
VAR155 > 0,
""
);
require(
VAR19.VAR20 < uint256(VAR146.VAR123).FUN8(VAR146.VAR125),
""
);
uint256 VAR249 = FUN149(
VAR145,
VAR146,
VAR112,
VAR155
);
FUN83(VAR145.VAR103).FUN33(
VAR112,
VAR146.VAR119,
msg.sender,
VAR249
);
FUN146(
VAR146,
VAR112,
VAR155,
0,
msg.sender
);
emit FUN141(
VAR112,
msg.sender,
msg.sender,
VAR146.VAR9,
VAR146.VAR120,
"",
address(0),
0,
VAR155,
0,
VAR249,
true
);
return VAR249;
}
function FUN145(
VAR101.State storage VAR145,
VAR229.Tx memory VAR175,
bytes VAR190
)
private
{
uint256 VAR250 = FUN149(
VAR145,
VAR145.VAR108[VAR175.VAR112],
VAR175.VAR112,
VAR175.VAR91
);
VAR229.FUN125(VAR145, VAR175);
uint256 VAR251 = VAR78.FUN54();
if (!VAR175.VAR232) {
VAR175.VAR203 =
FUN150(VAR175, VAR250, VAR190);
VAR229.FUN132(VAR145, VAR175);
VAR251 = VAR250;
}
VAR175.VAR234 = VAR229.FUN130(
VAR145,
VAR175,
VAR190,
VAR251
);
if (VAR175.VAR232) {
require(
VAR175.VAR234 <= VAR250,
""
);
VAR175.VAR203 = VAR250.FUN7(VAR175.VAR234);
VAR229.FUN133(VAR145, VAR175);
}
assert(VAR175.VAR233 == VAR250);
VAR229.FUN127(VAR145, VAR175);
}
function FUN150(
VAR229.Tx VAR175,
uint256 VAR250,
bytes VAR190
)
private
view
returns (uint256)
{
uint256 VAR252 = FUN108(VAR175.VAR174).FUN102(
VAR175.VAR156.VAR119,
VAR175.VAR156.VAR118,
VAR250,
VAR190
);
require(
VAR175.VAR231 <= VAR252,
""
);
return VAR252.FUN7(VAR175.VAR231);
}
function FUN144(
VAR101.State storage VAR145,
VAR229.Tx VAR175,
VAR106.Position storage VAR146
)
private
view
{
assert(VAR106.FUN85(VAR145, VAR175.VAR112));
require(
VAR146.VAR122 <= VAR175.VAR156.VAR122,
""
);
uint256 VAR253 = uint256(VAR146.VAR123).FUN8(VAR146.VAR125);
uint256 VAR254 = VAR19.VAR20.FUN8(VAR175.VAR156.VAR125);
require(
VAR253 <= VAR254,
""
);
require(
VAR19.VAR20 < VAR253,
""
);
}
function FUN149(
VAR101.State storage VAR145,
VAR106.Position storage VAR146,
bytes32 VAR112,
uint256 VAR155
)
private
view
returns (uint256)
{
uint256 VAR255 = VAR106.FUN82(VAR145, VAR112);
return VAR78.FUN52(
VAR155,
VAR146.VAR91,
VAR255
);
}
function FUN146(
VAR106.Position storage VAR146,
bytes32 VAR112,
uint256 VAR241,
uint256 VAR256,
address VAR147
)
private
{
VAR146.VAR91 = VAR146.VAR91.FUN8(VAR241);
address VAR9 = VAR146.VAR9;
address VAR120 = VAR146.VAR120;
FUN151(
VAR9,
msg.sender,
VAR112,
VAR241
);
FUN152(
VAR120,
VAR147,
VAR112,
VAR241,
VAR256
);
}
function FUN151(
address VAR181,
address VAR244,
bytes32 VAR112,
uint256 VAR241
)
private
{
if (VAR244 == VAR181 && !VAR45.FUN38(VAR181)) {
return;
}
address VAR182 =
FUN153(VAR181).FUN140(
VAR244,
VAR112,
VAR241
);
if (VAR182 != VAR181) {
FUN151(
VAR182,
VAR244,
VAR112,
VAR241
);
}
}
function FUN152(
address VAR181,
address VAR128,
bytes32 VAR112,
uint256 VAR241,
uint256 VAR257
)
private
{
if (VAR128 == VAR181 && !VAR45.FUN38(VAR181)) {
return;
}
address VAR182 =
FUN154(VAR181).FUN139(
VAR128,
VAR112,
VAR241,
VAR257
);
if (VAR182 != VAR181) {
FUN152(
VAR182,
VAR128,
VAR112,
VAR241,
VAR257
);
}
}
function FUN147(
VAR229.Tx VAR175,
VAR106.Position storage VAR146
)
private
{
emit FUN141(
VAR175.VAR112,
msg.sender,
VAR175.VAR156.VAR128,
VAR146.VAR9,
VAR146.VAR120,
VAR175.VAR156.VAR137,
VAR175.VAR156.VAR131,
VAR175.VAR231,
VAR175.VAR91,
VAR175.VAR234,
VAR175.VAR203,
VAR175.VAR232
);
}
function FUN143(
VAR106.Position storage VAR146,
bytes32 VAR112,
address[7] VAR226,
uint256[8] VAR227,
VAR81[2] VAR228,
bool VAR232,
bytes VAR138
)
private
view
returns (VAR229.Tx VAR55)
{
uint256 VAR91 = VAR227[7];
uint256 VAR231 = VAR106.FUN78(
VAR146,
VAR91,
VAR19.VAR20
);
assert(VAR231 >= VAR91);
VAR229.Tx memory VAR175 = VAR229.FUN155({
VAR112: VAR112,
VAR9: VAR146.VAR9,
VAR91: VAR91,
VAR231: VAR231,
VAR156: FUN156(
VAR146,
VAR226,
VAR227,
VAR228,
VAR138
),
VAR174: VAR226[6],
VAR232: VAR232,
VAR203: 0,
VAR233: 0,
VAR234: 0
});
return VAR175;
}
function FUN156(
VAR106.Position storage VAR146,
address[7] VAR226,
uint256[8] VAR227,
VAR81[2] VAR228,
bytes VAR138
)
private
view
returns (VAR106.LoanOffering VAR55)
{
VAR106.LoanOffering memory VAR156 = VAR106.FUN157({
VAR118: VAR146.VAR118,
VAR119: VAR146.VAR119,
VAR128: VAR226[0],
VAR9: VAR146.VAR120,
VAR129: VAR226[1],
VAR130: VAR226[2],
VAR131: VAR226[3],
VAR132: VAR226[4],
VAR133: VAR226[5],
VAR134: FUN158(VAR146, VAR227),
VAR135: VAR227[5],
VAR122: VAR228[0],
VAR125: VAR228[1],
VAR136: VAR227[6],
VAR137: 0,
VAR138: VAR138
});
VAR156.VAR137 = VAR106.FUN80(VAR156);
return VAR156;
}
function FUN158(
VAR106.Position storage VAR146,
uint256[8] VAR227
)
private
view
returns (VAR106.LoanRates VAR55)
{
VAR106.LoanRates memory VAR134 = VAR106.FUN159({
VAR140: VAR227[0],
VAR141: VAR227[1],
VAR142: VAR227[2],
VAR143: VAR227[3],
VAR144: VAR227[4],
VAR92: VAR146.VAR92,
VAR126: VAR146.VAR126
});
return VAR134;
}
}
contract VAR258 {
VAR101.State VAR145;
}
contract LoanGetters is VAR258 {
function FUN160(
bytes32 VAR137
)
external
view
returns (uint256)
{
return VAR106.FUN74(VAR145, VAR137);
}
function FUN161(
bytes32 VAR137
)
external
view
returns (uint256)
{
return VAR145.VAR104[VAR137];
}
function FUN162(
bytes32 VAR137
)
external
view
returns (uint256)
{
return VAR145.VAR105[VAR137];
}
}
interface VAR259 {
function FUN163(
address VAR260,
bytes32 VAR112
)
external
returns (address);
}
interface VAR261 {
function FUN164(
address VAR33,
bytes32 VAR112,
uint256 VAR203
)
external
returns (address);
}
library VAR262 {
using SafeMath for uint256;
event FUN165(
bytes32 indexed VAR112,
address indexed VAR120,
address indexed VAR9,
uint256 VAR121
);
event FUN113(
bytes32 indexed VAR112,
address indexed VAR120,
address indexed VAR9,
uint256 VAR203
);
event FUN166(
bytes32 indexed VAR137,
address indexed VAR128,
address indexed VAR131,
uint256 VAR263
);
function FUN167(
VAR101.State storage VAR145,
bytes32 VAR112,
uint256 VAR121
)
public
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
require(
VAR146.VAR124 == 0,
""
);
FUN168(
VAR146.VAR120,
msg.sender,
VAR112,
VAR121
);
VAR146.VAR124 = VAR117.FUN67();
VAR146.VAR121 = VAR121;
emit FUN165(
VAR112,
VAR146.VAR120,
VAR146.VAR9,
VAR121
);
}
function FUN169(
VAR101.State storage VAR145,
bytes32 VAR112
)
public
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
require(
VAR146.VAR124 > 0,
""
);
FUN170(
VAR146.VAR120,
msg.sender,
VAR112
);
VAR145.VAR108[VAR112].VAR124 = 0;
VAR145.VAR108[VAR112].VAR121 = 0;
emit FUN113(
VAR112,
VAR146.VAR120,
VAR146.VAR9,
0
);
}
function FUN171(
VAR101.State storage VAR145,
address[9] VAR226,
uint256[7] VAR227,
VAR81[4]  VAR228,
uint256    VAR263
)
public
returns (uint256)
{
VAR106.LoanOffering memory VAR156 = FUN172(
VAR226,
VAR227,
VAR228
);
require(
msg.sender == VAR156.VAR128,
""
);
require(
VAR156.VAR135 > VAR19.VAR20,
""
);
uint256 VAR193 = VAR156.VAR134.VAR140.FUN7(
VAR106.FUN74(VAR145, VAR156.VAR137)
);
uint256 VAR264 = VAR2.FUN4(VAR193, VAR263);
if (VAR264 == 0) {
return 0;
}
VAR145.VAR105[VAR156.VAR137] =
VAR145.VAR105[VAR156.VAR137].FUN8(VAR264);
emit FUN166(
VAR156.VAR137,
VAR156.VAR128,
VAR156.VAR131,
VAR264
);
return VAR264;
}
function FUN168(
address VAR181,
address VAR16,
bytes32 VAR112,
uint256 VAR121
)
private
{
if (VAR16 == VAR181) {
return;
}
address VAR182 =
FUN173(VAR181).FUN164(
msg.sender,
VAR112,
VAR121
);
if (VAR182 != VAR181) {
FUN168(
VAR182,
VAR16,
VAR112,
VAR121
);
}
}
function FUN170(
address VAR181,
address VAR16,
bytes32 VAR112
)
private
{
if (VAR16 == VAR181) {
return;
}
address VAR182 =
FUN174(VAR181).FUN163(
msg.sender,
VAR112
);
if (VAR182 != VAR181) {
FUN170(
VAR182,
VAR16,
VAR112
);
}
}
function FUN172(
address[9] VAR226,
uint256[7] VAR227,
VAR81[4]  VAR228
)
private
view
returns (VAR106.LoanOffering VAR55)
{
VAR106.LoanOffering memory VAR156 = VAR106.FUN157({
VAR118: VAR226[0],
VAR119: VAR226[1],
VAR128: VAR226[2],
VAR9: VAR226[3],
VAR129: VAR226[4],
VAR130: VAR226[5],
VAR131: VAR226[6],
VAR132: VAR226[7],
VAR133: VAR226[8],
VAR134: FUN175(VAR227, VAR228),
VAR135: VAR227[5],
VAR122: VAR228[0],
VAR125: VAR228[1],
VAR136: VAR227[6],
VAR137: 0,
VAR138: VAR265 bytes(0)
});
VAR156.VAR137 = VAR106.FUN80(VAR156);
return VAR156;
}
function FUN175(
uint256[7] VAR227,
VAR81[4] VAR228
)
private
pure
returns (VAR106.LoanRates VAR55)
{
VAR106.LoanRates memory VAR134 = VAR106.FUN159({
VAR140: VAR227[0],
VAR141: VAR227[1],
VAR142: VAR227[2],
VAR92: VAR228[2],
VAR143: VAR227[3],
VAR144: VAR227[4],
VAR126: VAR228[3]
});
return VAR134;
}
}
contract MarginAdmin is VAR8 {
uint8 private constant VAR266 = 0;
uint8 private constant VAR267 = 1;
uint8 private constant VAR268 = 2;
uint8 private constant VAR269 = 3;
uint8 private constant VAR270 = 4;
event FUN176(
uint8 VAR24,
uint8 VAR23
);
uint8 public VAR271;
constructor()
public
FUN17()
{
VAR271 = VAR266;
}
modifier FUN177() {
require(
VAR271 == VAR266,
""
);
VAR12;
}
modifier FUN178() {
require(
VAR271 == VAR266
|| VAR271 == VAR267,
""
);
VAR12;
}
modifier FUN179() {
require(
VAR271 == VAR266
|| VAR271 == VAR267
|| VAR271 == VAR268,
""
);
VAR12;
}
modifier FUN180() {
VAR12;
}
function FUN181(
uint8 VAR272
)
external
onlyOwner
{
require(
VAR272 < VAR270,
""
);
if (VAR272 != VAR271) {
emit FUN176(
VAR271,
VAR272
);
VAR271 = VAR272;
}
}
}
contract VAR273 {
event FUN182(
bytes32 indexed VAR112,
address indexed VAR244,
address indexed VAR120,
bytes32 VAR137,
address VAR118,
address VAR119,
address VAR247,
uint256 VAR91,
uint256 VAR234,
uint256 VAR203,
uint256 VAR92,
uint32  VAR122,
uint32  VAR125,
bool    VAR232
);
event FUN141(
bytes32 indexed VAR112,
address indexed VAR244,
address indexed VAR120,
address VAR130,
address VAR246,
bytes32 VAR137,
address VAR247,
uint256 VAR248,
uint256 VAR241,
uint256 VAR234,
uint256 VAR203,
bool    VAR232
);
event FUN103(
bytes32 indexed VAR112,
address indexed VAR159,
address indexed VAR164,
uint256 VAR150,
uint256 VAR193,
uint256 VAR194,
uint256 VAR195,
uint256 VAR176,
bool VAR162
);
event FUN118(
bytes32 indexed VAR112,
address indexed VAR207,
uint256 VAR27
);
event FUN165(
bytes32 indexed VAR112,
address indexed VAR120,
address indexed VAR9,
uint256 VAR121
);
event FUN113(
bytes32 indexed VAR112,
address indexed VAR120,
address indexed VAR9,
uint256 VAR203
);
event FUN166(
bytes32 indexed VAR137,
address indexed VAR128,
address indexed VAR131,
uint256 VAR263
);
event FUN112(
bytes32 indexed VAR112,
uint256 VAR27,
address VAR201
);
event FUN61(
bytes32 indexed VAR112,
address indexed VAR24,
address indexed VAR23
);
event FUN62(
bytes32 indexed VAR112,
address indexed VAR24,
address indexed VAR23
);
}
library VAR274 {
using SafeMath for uint256;
event FUN182(
bytes32 indexed VAR112,
address indexed VAR244,
address indexed VAR120,
bytes32 VAR137,
address VAR118,
address VAR119,
address VAR247,
uint256 VAR91,
uint256 VAR234,
uint256 VAR203,
uint256 VAR92,
uint32  VAR122,
uint32  VAR125,
bool    VAR232
);
function FUN183(
VAR101.State storage VAR145,
address[11] VAR226,
uint256[10] VAR227,
VAR81[4] VAR228,
bool VAR232,
bytes VAR138,
bytes VAR190
)
public
returns (bytes32)
{
VAR229.Tx memory VAR175 = FUN184(
VAR226,
VAR227,
VAR228,
VAR232,
VAR138
);
require(
!VAR106.FUN70(VAR145, VAR175.VAR112),
""
);
FUN145(VAR145, VAR175, VAR190);
FUN185(
VAR175
);
FUN186(
VAR145,
VAR175
);
return VAR175.VAR112;
}
function FUN145(
VAR101.State storage VAR145,
VAR229.Tx memory VAR175,
bytes VAR190
)
private
{
VAR229.FUN125(VAR145, VAR175);
if (VAR175.VAR232) {
VAR229.FUN133(VAR145, VAR175);
} else {
VAR229.FUN132(VAR145, VAR175);
}
VAR175.VAR234 = VAR229.FUN130(
VAR145,
VAR175,
VAR190,
VAR78.FUN54()
);
VAR229.FUN127(VAR145, VAR175);
}
function FUN186(
VAR101.State storage VAR145,
VAR229.Tx memory VAR175
)
private
{
VAR106.FUN69(
VAR145,
VAR175.VAR112,
VAR106.FUN187({
VAR118: VAR175.VAR156.VAR118,
VAR119: VAR175.VAR156.VAR119,
VAR120: VAR175.VAR156.VAR9,
VAR9: VAR175.VAR9,
VAR91: VAR175.VAR91,
VAR121: 0,
VAR122: VAR175.VAR156.VAR122,
VAR123: 0,
VAR124: 0,
VAR125: VAR175.VAR156.VAR125,
VAR92: VAR175.VAR156.VAR134.VAR92,
VAR126: VAR175.VAR156.VAR134.VAR126
}),
VAR175.VAR156.VAR128
);
}
function FUN185(
VAR229.Tx VAR175
)
private
{
emit FUN182(
VAR175.VAR112,
msg.sender,
VAR175.VAR156.VAR128,
VAR175.VAR156.VAR137,
VAR175.VAR156.VAR118,
VAR175.VAR156.VAR119,
VAR175.VAR156.VAR131,
VAR175.VAR91,
VAR175.VAR234,
VAR175.VAR203,
VAR175.VAR156.VAR134.VAR92,
VAR175.VAR156.VAR122,
VAR175.VAR156.VAR125,
VAR175.VAR232
);
}
function FUN184(
address[11] VAR226,
uint256[10] VAR227,
VAR81[4] VAR228,
bool VAR232,
bytes VAR138
)
private
view
returns (VAR229.Tx VAR55)
{
VAR229.Tx memory VAR175 = VAR229.FUN155({
VAR112: VAR106.FUN71(VAR227[9]),
VAR9: VAR226[0],
VAR91: VAR227[7],
VAR231: VAR227[7],
VAR156: FUN172(
VAR226,
VAR227,
VAR228,
VAR138
),
VAR174: VAR226[10],
VAR232: VAR232,
VAR203: VAR227[8],
VAR233: 0,
VAR234: 0
});
return VAR175;
}
function FUN172(
address[11] VAR226,
uint256[10] VAR227,
VAR81[4]   VAR228,
bytes       VAR138
)
private
view
returns (VAR106.LoanOffering VAR55)
{
VAR106.LoanOffering memory VAR156 = VAR106.FUN157({
VAR118: VAR226[1],
VAR119: VAR226[2],
VAR128: VAR226[3],
VAR9: VAR226[4],
VAR129: VAR226[5],
VAR130: VAR226[6],
VAR131: VAR226[7],
VAR132: VAR226[8],
VAR133: VAR226[9],
VAR134: FUN175(VAR227, VAR228),
VAR135: VAR227[5],
VAR122: VAR228[0],
VAR125: VAR228[1],
VAR136: VAR227[6],
VAR137: 0,
VAR138: VAR138
});
VAR156.VAR137 = VAR106.FUN80(VAR156);
return VAR156;
}
function FUN175(
uint256[10] VAR227,
VAR81[4] VAR228
)
private
pure
returns (VAR106.LoanRates VAR55)
{
VAR106.LoanRates memory VAR134 = VAR106.FUN159({
VAR140: VAR227[0],
VAR141: VAR227[1],
VAR142: VAR227[2],
VAR143: VAR227[3],
VAR144: VAR227[4],
VAR92: VAR228[2],
VAR126: VAR228[3]
});
return VAR134;
}
}
library VAR275 {
struct VAR230 {
bytes32 VAR112;
address VAR130;
address VAR118;
address VAR119;
address VAR246;
uint256 VAR91;
uint256 VAR276;
uint32 VAR122;
uint32 VAR125;
uint32 VAR92;
uint32 VAR126;
}
event FUN182(
bytes32 indexed VAR112,
address indexed VAR244,
address indexed VAR120,
bytes32 VAR137,
address VAR118,
address VAR119,
address VAR247,
uint256 VAR91,
uint256 VAR234,
uint256 VAR203,
uint256 VAR92,
uint32  VAR122,
uint32  VAR125,
bool    VAR232
);
function FUN188(
VAR101.State storage VAR145,
address[4] VAR226,
uint256[3] VAR227,
VAR81[4]  VAR228
)
public
returns (bytes32)
{
Tx memory VAR277 = FUN189(
VAR226,
VAR227,
VAR228
);
FUN44(
VAR145,
VAR277
);
FUN83(VAR145.VAR103).FUN33(
VAR277.VAR112,
VAR277.VAR119,
msg.sender,
VAR277.VAR276
);
FUN185(
VAR277
);
FUN186(
VAR145,
VAR277
);
return VAR277.VAR112;
}
function FUN186(
VAR101.State storage VAR145,
Tx memory VAR277
)
private
{
VAR106.FUN69(
VAR145,
VAR277.VAR112,
VAR106.FUN187({
VAR118: VAR277.VAR118,
VAR119: VAR277.VAR119,
VAR120: VAR277.VAR246,
VAR9: VAR277.VAR130,
VAR91: VAR277.VAR91,
VAR121: 0,
VAR122: VAR277.VAR122,
VAR123: 0,
VAR124: 0,
VAR125: VAR277.VAR125,
VAR92: VAR277.VAR92,
VAR126: VAR277.VAR126
}),
msg.sender
);
}
function FUN44(
VAR101.State storage VAR145,
Tx memory VAR277
)
private
view
{
require(
!VAR106.FUN70(VAR145, VAR277.VAR112),
""
);
require(
VAR277.VAR91 > 0,
""
);
require(
VAR277.VAR118 != address(0),
""
);
require(
VAR277.VAR118 != VAR277.VAR119,
""
);
require(
VAR277.VAR130 != address(0),
""
);
require(
VAR277.VAR246 != address(0),
""
);
require(
VAR277.VAR125 > 0,
""
);
require(
VAR277.VAR126 <= VAR277.VAR125,
""
);
}
function FUN185(
Tx memory VAR277
)
private
{
emit FUN182(
VAR277.VAR112,
msg.sender,
msg.sender,
bytes32(0),
VAR277.VAR118,
VAR277.VAR119,
address(0),
VAR277.VAR91,
0,
VAR277.VAR276,
VAR277.VAR92,
VAR277.VAR122,
VAR277.VAR125,
true
);
}
function FUN189(
address[4] VAR226,
uint256[3] VAR227,
VAR81[4]  VAR228
)
private
view
returns (Tx VAR55)
{
Tx memory VAR277 = FUN155({
VAR112: VAR106.FUN71(VAR227[2]),
VAR130: VAR226[0],
VAR118: VAR226[1],
VAR119: VAR226[2],
VAR246: VAR226[3],
VAR91: VAR227[0],
VAR276: VAR227[1],
VAR122: VAR228[0],
VAR125: VAR228[1],
VAR92: VAR228[2],
VAR126: VAR228[3]
});
return VAR277;
}
}
contract PositionGetters is VAR258 {
using SafeMath for uint256;
function FUN190(
bytes32 VAR112
)
external
view
returns (bool)
{
return VAR106.FUN85(VAR145, VAR112);
}
function FUN191(
bytes32 VAR112
)
external
view
returns (bool)
{
return (VAR145.VAR108[VAR112].VAR124 > 0);
}
function FUN192(
bytes32 VAR112
)
external
view
returns (bool)
{
return VAR145.VAR109[VAR112];
}
function FUN193(
bytes32 VAR112
)
external
view
returns (uint256)
{
return VAR145.VAR110[VAR112];
}
function FUN194(
bytes32 VAR112
)
external
view
returns (uint256)
{
return VAR106.FUN82(VAR145, VAR112);
}
function FUN195(
bytes32 VAR112
)
external
view
returns (uint256)
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
uint256 VAR278 = VAR106.FUN77(
VAR146,
VAR19.VAR20
);
uint256 VAR279 = VAR19.VAR20.FUN7(VAR146.VAR123);
if (VAR279 > VAR278) {
return 0;
} else {
return VAR278.FUN8(1).FUN7(VAR279);
}
}
function FUN196(
bytes32 VAR112
)
external
view
returns (uint256)
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
return VAR106.FUN76(
VAR146,
VAR146.VAR91,
VAR19.VAR20
);
}
function FUN197(
bytes32 VAR112,
uint256 VAR280,
uint32  VAR20
)
external
view
returns (uint256)
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
require(
VAR20 >= VAR146.VAR123,
""
);
return VAR106.FUN76(
VAR146,
VAR280,
VAR20
);
}
function FUN198(
bytes32 VAR112,
uint256 VAR155,
uint32  VAR20
)
external
view
returns (uint256)
{
VAR106.Position storage VAR146 =
VAR106.FUN86(VAR145, VAR112);
require(
VAR20 >= VAR146.VAR123,
""
);
return VAR106.FUN78(
VAR146,
VAR155,
VAR20
);
}
function FUN199(
bytes32 VAR112
)
external
view
returns (
address[4],
uint256[2],
VAR81[6]
)
{
VAR106.Position storage VAR146 = VAR145.VAR108[VAR112];
return (
[
VAR146.VAR118,
VAR146.VAR119,
VAR146.VAR120,
VAR146.VAR9
],
[
VAR146.VAR91,
VAR146.VAR121
],
[
VAR146.VAR122,
VAR146.VAR123,
VAR146.VAR124,
VAR146.VAR125,
VAR146.VAR92,
VAR146.VAR126
]
);
}
function FUN200(
bytes32 VAR112
)
external
view
returns (address)
{
return VAR145.VAR108[VAR112].VAR120;
}
function FUN201(
bytes32 VAR112
)
external
view
returns (address)
{
return VAR145.VAR108[VAR112].VAR9;
}
function FUN202(
bytes32 VAR112
)
external
view
returns (address)
{
return VAR145.VAR108[VAR112].VAR119;
}
function FUN203(
bytes32 VAR112
)
external
view
returns (address)
{
return VAR145.VAR108[VAR112].VAR118;
}
function FUN204(
bytes32 VAR112
)
external
view
returns (uint256)
{
return VAR145.VAR108[VAR112].VAR91;
}
function FUN205(
bytes32 VAR112
)
external
view
returns (uint256)
{
return VAR145.VAR108[VAR112].VAR92;
}
function FUN206(
bytes32 VAR112
)
external
view
returns (uint256)
{
return VAR145.VAR108[VAR112].VAR121;
}
function FUN207(
bytes32 VAR112
)
external
view
returns (VAR81)
{
return VAR145.VAR108[VAR112].VAR123;
}
function FUN208(
bytes32 VAR112
)
external
view
returns (VAR81)
{
return VAR145.VAR108[VAR112].VAR124;
}
function FUN209(
bytes32 VAR112
)
external
view
returns (VAR81)
{
return VAR145.VAR108[VAR112].VAR122;
}
function FUN210(
bytes32 VAR112
)
external
view
returns (VAR81)
{
return VAR145.VAR108[VAR112].VAR125;
}
function FUN211(
bytes32 VAR112
)
external
view
returns (VAR81)
{
return VAR145.VAR108[VAR112].VAR126;
}
}
library VAR281 {
function FUN212(
VAR101.State storage VAR145,
bytes32 VAR112,
address VAR282
)
public
{
require(
VAR106.FUN85(VAR145, VAR112),
""
);
address VAR283 = VAR145.VAR108[VAR112].VAR120;
require(
msg.sender == VAR283,
""
);
require(
VAR282 != VAR283,
""
);
address VAR284 = VAR114.FUN63(
VAR112,
VAR283,
VAR282);
require(
VAR284 != VAR283,
""
);
VAR145.VAR108[VAR112].VAR120 = VAR284;
}
function FUN213(
VAR101.State storage VAR145,
bytes32 VAR112,
address VAR11
)
public
{
require(
VAR106.FUN85(VAR145, VAR112),
""
);
address VAR285 = VAR145.VAR108[VAR112].VAR9;
require(
msg.sender == VAR285,
""
);
require(
VAR11 != VAR285,
""
);
address VAR286 = VAR114.FUN65(
VAR112,
VAR285,
VAR11);
require(
VAR286 != VAR285,
""
);
VAR145.VAR108[VAR112].VAR9 = VAR286;
}
}
contract Margin VAR287
VAR42,
VAR258,
VAR273,
VAR288,
VAR289,
VAR290
{
using SafeMath for uint256;
constructor(
address VAR291,
address VAR37
)
public
FUN214()
{
VAR145 = VAR101.FUN215({
VAR103: VAR291,
VAR34: VAR37
});
}
function FUN216(
address[11] VAR226,
uint256[10] VAR227,
VAR81[4]   VAR228,
bool        VAR232,
bytes       VAR138,
bytes       VAR292
)
external
VAR293
VAR294
returns (bytes32)
{
return VAR274.FUN183(
VAR145,
VAR226,
VAR227,
VAR228,
VAR232,
VAR138,
VAR292
);
}
function FUN217(
address[4] VAR226,
uint256[3] VAR227,
VAR81[4]  VAR228
)
external
VAR293
VAR294
returns (bytes32)
{
return VAR275.FUN188(
VAR145,
VAR226,
VAR227,
VAR228
);
}
function FUN218(
bytes32    VAR112,
address[7] VAR226,
uint256[8] VAR227,
VAR81[2]  VAR228,
bool       VAR232,
bytes      VAR138,
bytes      VAR292
)
external
VAR293
VAR294
returns (uint256)
{
return VAR245.FUN142(
VAR145,
VAR112,
VAR226,
VAR227,
VAR228,
VAR232,
VAR138,
VAR292
);
}
function FUN219(
bytes32 VAR112,
uint256 VAR155
)
external
VAR293
VAR294
returns (uint256)
{
return VAR245.FUN148(
VAR145,
VAR112,
VAR155
);
}
function FUN220(
bytes32 VAR112,
uint256 VAR196,
address VAR164,
address VAR174,
bool    VAR162,
bytes   VAR292
)
external
VAR295
VAR294
returns (uint256, uint256, uint256)
{
return VAR192.FUN104(
VAR145,
VAR112,
VAR196,
VAR164,
VAR174,
VAR162,
VAR292
);
}
function FUN221(
bytes32 VAR112,
uint256 VAR196,
address VAR164
)
external
VAR296
VAR294
returns (uint256, uint256, uint256)
{
return VAR192.FUN104(
VAR145,
VAR112,
VAR196,
VAR164,
address(0),
true,
VAR265 bytes(0)
);
}
function FUN222(
bytes32 VAR112,
uint256 VAR196,
address VAR164
)
external
VAR295
VAR294
returns (uint256, uint256)
{
return VAR198.FUN109(
VAR145,
VAR112,
VAR196,
VAR164
);
}
function FUN223(
bytes32 VAR112,
uint256 VAR121
)
external
VAR294
{
VAR262.FUN167(
VAR145,
VAR112,
VAR121
);
}
function FUN224(
bytes32 VAR112
)
external
VAR293
VAR294
{
VAR262.FUN169(VAR145, VAR112);
}
function FUN225(
bytes32 VAR112,
address VAR207
)
external
VAR294
returns (uint256)
{
return VAR208.FUN119(
VAR145,
VAR112,
VAR207
);
}
function FUN226(
bytes32 VAR112,
uint256 VAR203
)
external
VAR293
VAR294
{
VAR202.FUN114(
VAR145,
VAR112,
VAR203
);
}
function FUN227(
address[9] VAR226,
uint256[7]  VAR227,
VAR81[4]   VAR228,
uint256     VAR263
)
external
VAR297
VAR294
returns (uint256)
{
return VAR262.FUN171(
VAR145,
VAR226,
VAR227,
VAR228,
VAR263
);
}
function FUN228(
bytes32 VAR112,
address VAR16
)
external
VAR294
{
VAR281.FUN212(
VAR145,
VAR112,
VAR16);
}
function FUN229(
bytes32 VAR112,
address VAR16
)
external
VAR294
{
VAR281.FUN213(
VAR145,
VAR112,
VAR16);
}
function FUN230()
external
view
returns (address)
{
return VAR145.VAR103;
}
function FUN231()
external
view
returns (address)
{
return VAR145.VAR34;
}
}
contract VAR298 {
address public VAR299;
constructor(
address VAR300
)
public
{
VAR299 = VAR300;
}
modifier FUN232()
{
require(
msg.sender == VAR299,
""
);
VAR12;
}
}
contract VAR301 {
function FUN172(
address[9] VAR226,
uint256[7] VAR227,
VAR81[4] VAR228,
bytes VAR138
)
internal
pure
returns (VAR106.LoanOffering VAR55)
{
VAR106.LoanOffering memory VAR156;
FUN233(VAR156, VAR226);
FUN234(VAR156, VAR227);
FUN235(VAR156, VAR228);
VAR156.VAR138 = VAR138;
return VAR156;
}
function FUN233(
VAR106.LoanOffering memory VAR156,
address[9] VAR226
)
private
pure
{
VAR156.VAR118 = VAR226[0];
VAR156.VAR119 = VAR226[1];
VAR156.VAR128 = VAR226[2];
VAR156.VAR9 = VAR226[3];
VAR156.VAR129 = VAR226[4];
VAR156.VAR130 = VAR226[5];
VAR156.VAR131 = VAR226[6];
VAR156.VAR132 = VAR226[7];
VAR156.VAR133 = VAR226[8];
}
function FUN234(
VAR106.LoanOffering memory VAR156,
uint256[7] VAR227
)
private
pure
{
VAR156.VAR134.VAR140 = VAR227[0];
VAR156.VAR134.VAR141 = VAR227[1];
VAR156.VAR134.VAR142 = VAR227[2];
VAR156.VAR134.VAR143 = VAR227[3];
VAR156.VAR134.VAR144 = VAR227[4];
VAR156.VAR135 = VAR227[5];
VAR156.VAR136 = VAR227[6];
}
function FUN235(
VAR106.LoanOffering memory VAR156,
VAR81[4] VAR228
)
private
pure
{
VAR156.VAR122 = VAR228[0];
VAR156.VAR125 = VAR228[1];
VAR156.VAR134.VAR92 = VAR228[2];
VAR156.VAR134.VAR126 = VAR228[3];
}
}
library VAR302 {
function FUN199(
address VAR299,
bytes32 VAR112
)
internal
view
returns (VAR106.Position VAR55)
{
(
address[4] memory VAR226,
uint256[2] memory VAR227,
VAR81[6]  memory VAR228
) = FUN236(VAR299).FUN199(VAR112);
return VAR106.FUN187({
VAR118: VAR226[0],
VAR119: VAR226[1],
VAR120: VAR226[2],
VAR9: VAR226[3],
VAR91: VAR227[0],
VAR121: VAR227[1],
VAR122: VAR228[0],
VAR123: VAR228[1],
VAR124: VAR228[2],
VAR125: VAR228[3],
VAR92: VAR228[4],
VAR126: VAR228[5]
});
}
}
contract BucketLender VAR287
VAR8,
VAR298,
VAR111,
VAR240,
VAR261,
VAR259,
VAR205,
VAR301,
VAR225,
VAR42
{
using SafeMath for uint256;
using TokenInteract for address;
event FUN237(
address indexed VAR303,
uint256 VAR304,
uint256 VAR27,
uint256 VAR305
);
event FUN238(
address indexed VAR306,
uint256 VAR304,
uint256 VAR305,
uint256 VAR307,
uint256 VAR308
);
event FUN239(
uint256 VAR309,
uint256 VAR310,
uint256 VAR311,
uint256 VAR27
);
event FUN240(
uint256 VAR309,
uint256 VAR310,
uint256 VAR311,
uint256 VAR27
);
event FUN241(
uint256 VAR312,
uint256 VAR310,
uint256 VAR313,
uint256 VAR27
);
event FUN242(
uint256 VAR312,
uint256 VAR310,
uint256 VAR313,
uint256 VAR27
);
mapping(uint256 => uint256) public VAR313;
uint256 public VAR312;
mapping(uint256 => uint256) public VAR311;
uint256 public VAR309;
mapping(uint256 => mapping(address => uint256)) public VAR314;
mapping(uint256 => uint256) public VAR315;
uint256 public VAR316 = 0;
uint256 public VAR317 = 0;
bool public VAR318 = false;
bytes32 public VAR319;
address public VAR320;
address public VAR321;
uint32 public VAR322;
uint32 public VAR323;
uint32 public VAR324;
uint32 public VAR325;
uint32 public VAR326;
uint32 public VAR327;
uint32 public VAR328;
mapping(address => bool) public VAR329;
mapping(address => bool) public VAR330;
constructor(
address VAR300,
bytes32 VAR112,
address VAR119,
address VAR118,
VAR81[7] VAR331,
address[] VAR332,
address[] VAR333
)
public
FUN243(VAR300)
{
VAR319 = VAR112;
VAR320 = VAR119;
VAR321 = VAR118;
require(
VAR331[0] != 0,
""
);
VAR322 = VAR331[0];
VAR323 = VAR331[1];
VAR324 = VAR331[2];
VAR325 = VAR331[3];
VAR326 = VAR331[4];
VAR327 = VAR331[5];
VAR328 = VAR331[6];
uint256 VAR75 = 0;
for (VAR75 = 0; VAR75 < VAR332.VAR219; VAR75++) {
VAR329[VAR332[VAR75]] = true;
}
for (VAR75 = 0; VAR75 < VAR333.VAR219; VAR75++) {
VAR330[VAR333[VAR75]] = true;
}
VAR321.FUN23(
FUN236(VAR300).FUN231(),
VAR78.FUN54()
);
}
modifier FUN244(bytes32 VAR112) {
require(
VAR319 == VAR112,
""
);
VAR12;
}
function FUN124(
address[9] VAR226,
uint256[7] VAR227,
VAR81[4] VAR228,
bytes32 VAR112,
bytes VAR138
)
external
VAR334
VAR294
FUN244(VAR112)
returns (address)
{
require(
FUN236(VAR299).FUN190(VAR319),
""
);
VAR106.LoanOffering memory VAR156 = FUN172(
VAR226,
VAR227,
VAR228,
VAR138
);
assert(VAR156.VAR118 == VAR321);
assert(VAR156.VAR119 == VAR320);
assert(VAR156.VAR128 == address(this));
assert(VAR156.VAR9 == address(this));
require(
VAR156.VAR129 == address(0),
""
);
require(
VAR156.VAR131 == address(0),
""
);
require(
VAR156.VAR130 == address(0),
""
);
require(
VAR156.VAR132 == address(0),
""
);
require(
VAR156.VAR133 == address(0),
""
);
require(
VAR156.VAR134.VAR140 == VAR78.FUN54(),
""
);
require(
VAR156.VAR134.VAR141 == 0,
""
);
require(
VAR156.VAR134.VAR142 == 0,
""
);
require(
VAR156.VAR134.VAR143 == 0,
""
);
require(
VAR156.VAR134.VAR144 == 0,
""
);
require(
VAR156.VAR135 == VAR78.FUN54(),
""
);
require(
VAR156.VAR136 == 0,
""
);
require(
VAR156.VAR122 == VAR78.FUN55(),
""
);
require(
VAR156.VAR125 == VAR78.FUN55(),
""
);
assert(VAR156.VAR134.VAR92 == VAR323);
assert(VAR156.VAR134.VAR126 == VAR324);
return address(this);
}
function FUN59(
address VAR24,
bytes32 VAR112
)
external
VAR334
VAR294
FUN244(VAR112)
returns (address)
{
VAR106.Position memory VAR146 = VAR302.FUN199(VAR299, VAR319);
uint256 VAR335 = VAR146.VAR91;
uint256 VAR142 = VAR78.FUN51(
uint256(VAR327),
uint256(VAR328),
VAR335
);
assert(VAR335 > 0);
assert(VAR309 == 0);
assert(VAR24 != address(this));
require(
VAR146.VAR118 == VAR321,
""
);
require(
VAR146.VAR119 == VAR320,
""
);
require(
VAR146.VAR125 == VAR325,
""
);
require(
VAR146.VAR122 == VAR326,
""
);
require(
VAR146.VAR92 == VAR323,
""
);
require(
VAR146.VAR126 == VAR324,
""
);
require(
FUN236(VAR299).FUN194(VAR319) >= VAR142,
""
);
VAR311[0] = VAR335;
VAR309 = VAR335;
VAR315[0] = VAR315[0].FUN8(VAR335);
VAR314[0][VAR24] =
VAR314[0][VAR24].FUN8(VAR335);
return address(this);
}
function FUN139(
address VAR128,
bytes32 VAR112,
uint256 VAR241,
uint256 VAR242
)
external
VAR334
VAR294
FUN244(VAR112)
returns (address)
{
Margin VAR300 = FUN236(VAR299);
require(
VAR128 == address(this),
""
);
require(
!VAR300.FUN191(VAR319),
""
);
uint256 VAR336 = VAR300.FUN204(VAR319);
uint256 VAR337 = VAR336.FUN7(VAR241);
FUN245(VAR309.FUN7(VAR337));
FUN246(VAR241, VAR242);
assert(VAR309 == VAR336);
return address(this);
}
function FUN164(
address VAR33,
bytes32 VAR112,
uint256 VAR203
)
external
VAR334
VAR294
FUN244(VAR112)
returns (address)
{
require(
VAR329[VAR33],
""
);
require(
VAR203 == 0,
""
);
return address(this);
}
function FUN163(
address VAR260,
bytes32 VAR112
)
external
VAR334
VAR294
FUN244(VAR112)
returns (address)
{
require(
VAR329[VAR260],
""
);
return address(this);
}
function FUN117(
address
,
bytes32 VAR112,
address VAR207
)
external
VAR334
VAR294
FUN244(VAR112)
returns (address)
{
return FUN247(VAR207);
}
function FUN248()
external
VAR294
{
FUN249();
}
function FUN250(
address VAR303,
uint256 VAR27
)
external
VAR294
returns (uint256)
{
Margin VAR300 = FUN236(VAR299);
bytes32 VAR112 = VAR319;
require(
VAR303 != address(0),
""
);
require(
VAR27 != 0,
""
);
require(
!VAR300.FUN192(VAR112),
""
);
require(
!VAR300.FUN191(VAR112),
""
);
FUN249();
VAR321.FUN22(
msg.sender,
address(this),
VAR27
);
uint256 VAR304 = FUN251();
uint256 VAR338 = VAR313[VAR304].FUN8(FUN252(VAR304));
uint256 VAR339 = 0;
if (VAR338 == 0) {
VAR339 = VAR27;
} else {
VAR339 = VAR78.FUN51(
VAR27,
VAR338,
VAR315[VAR304]
);
}
require(
VAR339 != 0,
""
);
FUN253(VAR304, VAR27, true);
VAR314[VAR304][VAR303] =
VAR314[VAR304][VAR303].FUN8(VAR339);
VAR315[VAR304] = VAR315[VAR304].FUN8(VAR339);
emit FUN237(
VAR303,
VAR304,
VAR27,
VAR339
);
return VAR304;
}
function FUN254(
uint256[] VAR340,
uint256[] VAR341,
address VAR342
)
external
VAR294
returns (uint256, uint256)
{
require(
VAR340.VAR219 == VAR341.VAR219,
""
);
if (VAR342 != msg.sender) {
require(
VAR330[msg.sender],
""
);
}
FUN249();
uint256 VAR343 = 0;
if (
FUN236(VAR299).FUN190(VAR319) &&
VAR316 == FUN251()
) {
VAR343 = VAR316;
}
uint256[2] memory VAR344;
uint256 VAR345 = 0;
if (VAR318) {
VAR345 = VAR320.FUN20(address(this));
}
for (uint256 VAR75 = 0; VAR75 < VAR340.VAR219; VAR75++) {
uint256 VAR304 = VAR340[VAR75];
if ((VAR304 != 0) && (VAR304 == VAR343)) {
continue;
}
(uint256 VAR346, uint256 VAR347) = FUN255(
VAR342,
VAR304,
VAR341[VAR75],
VAR345
);
VAR344[0] = VAR344[0].FUN8(VAR346);
VAR344[1] = VAR344[1].FUN8(VAR347);
}
VAR321.transfer(msg.sender, VAR344[0]);
VAR320.transfer(msg.sender, VAR344[1]);
return (VAR344[0], VAR344[1]);
}
function FUN32(
address VAR26,
address VAR23
)
external
onlyOwner
returns (uint256)
{
FUN249();
uint256 VAR27 = VAR26.FUN20(address(this));
if (VAR26 == VAR321) {
VAR27 = VAR27.FUN7(VAR312);
} else if (VAR26 == VAR320) {
require(
!VAR318,
""
);
}
VAR26.transfer(VAR23, VAR27);
return VAR27;
}
function FUN251()
public
view
returns (uint256)
{
Margin VAR300 = FUN236(VAR299);
bytes32 VAR112 = VAR319;
uint32 VAR348 = VAR322;
assert(!VAR300.FUN192(VAR112));
if (!VAR300.FUN190(VAR112)) {
return 0;
}
uint256 VAR123 = VAR300.FUN207(VAR112);
return VAR19.VAR20.FUN7(VAR123).FUN6(VAR348).FUN8(1);
}
function FUN252(
uint256 VAR304
)
public
view
returns (uint256)
{
if (FUN236(VAR299).FUN192(VAR319)) {
return 0;
}
uint256 VAR349 = VAR311[VAR304];
if (VAR349 == 0) {
return 0;
}
uint256 VAR350 = FUN236(VAR299).FUN197(
VAR319,
VAR309,
FUN68(VAR19.VAR20)
);
return VAR78.FUN51(
VAR349,
VAR309,
VAR350
);
}
function FUN247(
address VAR207
)
internal
returns (address)
{
require(
VAR207 == address(this),
""
);
FUN249();
VAR318 = true;
return address(this);
}
function FUN249()
private
{
if (VAR318) {
return;
}
uint256 VAR351 = FUN236(VAR299).FUN204(VAR319);
FUN245(VAR309.FUN7(VAR351));
assert(VAR309 == VAR351);
}
function FUN245(
uint256 VAR352
)
private
{
if (VAR352 == 0) {
return;
}
uint256 VAR353 = FUN236(VAR299).FUN193(VAR319);
assert(VAR353.FUN7(VAR317) >= VAR352);
uint256 VAR354 = VAR352;
uint256 VAR355 = VAR353.FUN7(VAR317);
uint256 VAR356 = VAR316;
for (
uint256 VAR304 = VAR356;
VAR354 > 0;
VAR304--
) {
assert(VAR304 <= VAR356);
uint256 VAR357 = VAR2.FUN4(VAR354, VAR311[VAR304]);
if (VAR357 == 0) {
continue;
}
uint256 VAR358 = VAR78.FUN51(
VAR357,
VAR354,
VAR355
);
FUN253(VAR304, VAR358, true);
FUN256(VAR304, VAR357, false);
VAR354 = VAR354.FUN7(VAR357);
VAR355 = VAR355.FUN7(VAR358);
VAR356 = VAR304;
}
assert(VAR354 == 0);
assert(VAR355 == 0);
FUN257(VAR356);
VAR317 = VAR353;
}
function FUN246(
uint256 VAR241,
uint256 VAR242
)
private
{
require(
VAR242 <= VAR312,
""
);
uint256 VAR155 = VAR241;
uint256 VAR359 = VAR242;
uint256 VAR356;
uint256 VAR360 = FUN251();
for (
uint256 VAR304 = VAR316;
VAR155 > 0;
VAR304++
) {
assert(VAR304 <= VAR360);
uint256 VAR358 = VAR2.FUN4(VAR359, VAR313[VAR304]);
if (VAR358 == 0) {
continue;
}
uint256 VAR357 = VAR78.FUN51(
VAR358,
VAR359,
VAR155
);
FUN253(VAR304, VAR358, false);
FUN256(VAR304, VAR357, true);
VAR155 = VAR155.FUN7(VAR357);
VAR359 = VAR359.FUN7(VAR358);
VAR356 = VAR304;
}
assert(VAR155 == 0);
assert(VAR359 == 0);
FUN257(VAR356);
}
function FUN255(
address VAR342,
uint256 VAR304,
uint256 VAR361,
uint256 VAR345
)
private
returns (uint256, uint256)
{
uint256 VAR362 = VAR315[VAR304];
if (VAR362 == 0) {
return (0, 0);
}
uint256 VAR363 = VAR314[VAR304][VAR342];
uint256 VAR364 = VAR2.FUN4(VAR361, VAR363);
if (VAR364 == 0) {
return (0, 0);
}
VAR315[VAR304] = VAR315[VAR304].FUN7(VAR364);
VAR314[VAR304][VAR342] = VAR363.FUN7(VAR364);
uint256 VAR365 = FUN258(
VAR304,
VAR364,
VAR362
);
uint256 VAR366 = FUN259(
VAR304,
VAR364,
VAR362,
VAR345
);
emit FUN238(
VAR342,
VAR304,
VAR364,
VAR365,
VAR366
);
return (VAR365, VAR366);
}
function FUN258(
uint256 VAR304,
uint256 VAR363,
uint256 VAR362
)
private
returns (uint256)
{
uint256 VAR365 = VAR78.FUN51(
VAR363,
VAR362,
VAR313[VAR304].FUN8(FUN252(VAR304))
);
require(
VAR365 <= VAR313[VAR304],
""
);
FUN253(VAR304, VAR365, false);
return VAR365;
}
function FUN259(
uint256 VAR304,
uint256 VAR363,
uint256 VAR362,
uint256 VAR345
)
private
returns (uint256)
{
if (VAR345 == 0) {
return 0;
}
uint256 VAR367 = VAR78.FUN51(
VAR363,
VAR362,
VAR311[VAR304]
);
uint256 VAR366 = VAR78.FUN51(
VAR367,
VAR309,
VAR345
);
FUN256(VAR304, VAR367, false);
return VAR366;
}
function FUN257(
uint256 VAR304
)
private
{
if (VAR316 == VAR304) {
return;
}
VAR316 = VAR304;
}
function FUN253(
uint256 VAR304,
uint256 VAR27,
bool VAR368
)
private
{
if (VAR27 == 0) {
return;
}
uint256 VAR369;
uint256 VAR370;
if (VAR368) {
VAR369 = VAR312.FUN8(VAR27);
VAR370 = VAR313[VAR304].FUN8(VAR27);
emit FUN241(VAR369, VAR304, VAR370, VAR27);
} else {
VAR369 = VAR312.FUN7(VAR27);
VAR370 = VAR313[VAR304].FUN7(VAR27);
emit FUN242(VAR369, VAR304, VAR370, VAR27);
}
VAR312 = VAR369;
VAR313[VAR304] = VAR370;
}
function FUN256(
uint256 VAR304,
uint256 VAR27,
bool VAR368
)
private
{
if (VAR27 == 0) {
return;
}
uint256 VAR369;
uint256 VAR370;
if (VAR368) {
VAR369 = VAR309.FUN8(VAR27);
VAR370 = VAR311[VAR304].FUN8(VAR27);
emit FUN239(VAR369, VAR304, VAR370, VAR27);
} else {
VAR369 = VAR309.FUN7(VAR27);
VAR370 = VAR311[VAR304].FUN7(VAR27);
emit FUN240(VAR369, VAR304, VAR370, VAR27);
}
VAR309 = VAR369;
VAR311[VAR304] = VAR370;
}
}
contract BucketLenderWithRecoveryDelay is VAR371
{
uint256 public VAR372;
constructor(
address VAR300,
bytes32 VAR112,
address VAR119,
address VAR118,
VAR81[7] VAR331,
address[] VAR332,
address[] VAR333,
uint256 VAR373
)
public
FUN260(
VAR300,
VAR112,
VAR119,
VAR118,
VAR331,
VAR332,
VAR333
)
{
VAR372 = VAR373;
}
function FUN117(
address
,
bytes32 VAR112,
address VAR207
)
external
VAR334
VAR294
FUN244(VAR112)
returns (address)
{
VAR106.Position memory VAR146 = VAR302.FUN199(VAR299, VAR112);
uint256 VAR374 = uint256(VAR146.VAR123).FUN8(VAR146.VAR125);
if (VAR146.VAR124 > 0) {
uint256 VAR375 = uint256(VAR146.VAR124).FUN8(VAR146.VAR122);
VAR374 = VAR2.FUN4(VAR374, VAR375);
}
require (
VAR19.VAR20 >= VAR374.FUN8(VAR372),
""
);
return FUN247(VAR207);
}
}
0
---------------------------------
459 0x03dc9b46243703fa1c1f95c2693212635f742204.sol
pragma solidity 0.4.18;
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);
function FUN2() {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN3(address VAR4) onlyOwner public {
require(VAR4 != address(0));
FUN1(VAR2, VAR4);
VAR2 = VAR4;
}
}
contract Restricted is VAR1 {
mapping (address => bool) public VAR6;
modifier FUN4() {
require(VAR6[msg.sender]);
VAR5;
}
function FUN5(address VAR7, bool VAR8) onlyOwner public {
VAR6[VAR7] = VAR8;
}
}
contract Destructible is VAR1 {
function FUN6() payable { }
function FUN7() onlyOwner public {
FUN8(VAR2);
}
function FUN9(address VAR9) onlyOwner public {
FUN8(VAR9);
}
}
contract Pausable is VAR1 {
event FUN10();
event FUN11();
bool public VAR10 = false;
modifier FUN12() {
require(!VAR10);
VAR5;
}
modifier FUN13() {
require(VAR10);
VAR5;
}
function FUN14() onlyOwner whenNotPaused public {
VAR10 = true;
FUN10();
}
function FUN15() onlyOwner whenPaused public {
VAR10 = false;
FUN11();
}
}
library VAR11 {
function FUN16(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
uint256 VAR14 = VAR12 * VAR13;
assert(VAR12 == 0 || VAR14 / VAR12 == VAR13);
return VAR14;
}
function FUN17(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
uint256 VAR14 = VAR12 / VAR13;
return VAR14;
}
function FUN18(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
assert(VAR13 <= VAR12);
return VAR12 - VAR13;
}
function FUN19(uint256 VAR12, uint256 VAR13) internal constant returns (uint256) {
uint256 VAR14 = VAR12 + VAR13;
assert(VAR14 >= VAR12);
return VAR14;
}
}
contract Contactable is VAR1{
string public VAR15;
function FUN20(string VAR16) onlyOwner public {
VAR15 = VAR16;
}
}
contract MonethaGateway is VAR17, VAR18, VAR19, VAR20 {
using SafeMath for uint256;
string constant VAR21 = "";
uint public constant VAR22 = 15;
address public VAR23;
address public VAR24;
event FUN21(address VAR25, uint VAR26, uint VAR27);
function FUN22(address VAR28, address VAR29) public {
require(VAR28 != 0x0);
VAR23 = VAR28;
FUN23(VAR29);
}
function FUN24(address VAR30) external payable onlyMonetha VAR31 {
require(VAR30 != 0x0);
uint VAR26 = msg.value.FUN18(VAR22.FUN16(msg.value).FUN17(1000));
uint VAR27 = msg.value.FUN18(VAR26);
VAR30.transfer(VAR26);
VAR23.transfer(VAR27);
FUN21(VAR30, VAR26, VAR27);
}
function FUN25(address VAR32) external onlyOwner VAR31 {
VAR23 = VAR32;
}
function FUN5(address VAR7, bool VAR8) public {
require(msg.sender == VAR24 || msg.sender == VAR2);
VAR6[VAR7] = VAR8;
}
function FUN23(address VAR29) public onlyOwner {
require(VAR29 != 0x0);
VAR24 = VAR29;
}
}
0
---------------------------------
460 0x03e0f73a93993e5101362656af1162ed80fb54f2.sol
pragma solidity 0.4.18;
library VAR1 {
function FUN1(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
VAR4 = VAR2 * VAR3;
require(VAR2 == 0 || VAR4 / VAR2 == VAR3);
}
function FUN2(uint VAR2, uint VAR3) internal pure returns (uint) {
require(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN3(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
VAR4 = VAR2 + VAR3;
require(VAR4 >= VAR2);
}
function FUN4(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
return (VAR2 >= VAR3) ? VAR2 - VAR3 : 0;
}
function FUN5(
uint[] VAR5,
uint VAR6
)
internal
pure
returns (uint)
{
uint VAR7 = VAR5.VAR8;
require(VAR7 > 1);
require(VAR6 > 0);
uint VAR9 = 0;
for (uint VAR10 = 0; VAR10 < VAR7; VAR10++) {
VAR9 += VAR5[VAR10];
}
VAR9 = VAR9 / VAR7;
if (VAR9 == 0) {
return 0;
}
uint VAR11 = 0;
uint VAR12;
uint VAR13;
for (VAR10 = 0; VAR10 < VAR7; VAR10++) {
VAR13 = VAR5[VAR10];
VAR12 = VAR13 > VAR9 ? VAR13 - VAR9 : VAR9 - VAR13;
VAR11 += FUN1(VAR12, VAR12);
}
return ((FUN1(FUN1(VAR11, VAR6), VAR6) / VAR9) / VAR9) / (VAR7 - 1);
}
}
contract VAR14 {
uint public VAR15;
event Transfer(address indexed VAR16, address indexed VAR17, uint256 value);
event FUN6(address indexed VAR18, address indexed VAR19, uint256 value);
function FUN7(address VAR20) view public returns (uint256);
function FUN8(address VAR18, address VAR19) view public returns (uint256);
function transfer(address VAR17, uint256 value) public returns (bool);
function FUN9(address VAR16, address VAR17, uint256 value) public returns (bool);
function FUN10(address VAR19, uint256 value) public returns (bool);
}
contract VAR21 {
uint8   public constant VAR22               = 0;
uint8   public constant VAR23      = 1;
uint8   public constant VAR24         = 1;
uint8   public constant VAR25 = 100;
event FUN11(
uint                VAR26,
bytes32     indexed VAR27,
address             VAR28,
address             VAR29,
bool                VAR30,
bytes32[]           VAR31,
uint[6][]           VAR32
);
event FUN12(
bytes32     indexed VAR33,
uint                VAR34
);
event FUN13(
address     indexed VAR35,
uint                VAR36
);
function FUN14(
address[2][]    VAR37,
uint[7][]       VAR38,
uint8[2][]      VAR39,
bool[]          VAR40,
uint8[]         VAR41,
bytes32[]       VAR42,
bytes32[]       VAR43,
address         VAR44,
address         VAR45
) public;
function FUN15(
address[3] VAR46,
uint[7]    VAR47,
bool       VAR48,
uint8      VAR49,
uint8      VAR50,
bytes32    VAR51,
bytes32    VAR12
) external;
function FUN16(uint VAR52) external;
}
library VAR53 {
function FUN17(
bytes32[]   VAR5,
uint        VAR7
)
internal
pure
returns (bytes32 VAR54)
{
VAR54 = VAR5[0];
for (uint VAR10 = 1; VAR10 < VAR7; VAR10++) {
VAR54 ^= VAR5[VAR10];
}
}
}
library VAR55 {
function FUN17(
uint8[] VAR5,
uint    VAR7
)
internal
pure
returns (uint8 VAR54)
{
VAR54 = VAR5[0];
for (uint VAR10 = 1; VAR10 < VAR7; VAR10++) {
VAR54 ^= VAR5[VAR10];
}
}
}
contract VAR56 {
using MathBytes32   for bytes32[];
using MathUint8     for uint8[];
uint public VAR57;
struct VAR58 {
address VAR44;
uint VAR59;
}
mapping (bytes32 => VAR58) VAR60;
event FUN18(
address indexed VAR61,
bytes32 indexed VAR27
);
function FUN19(uint VAR62)
public
{
require(VAR62 > 0);
VAR57 = VAR62;
}
function () payable public {
revert();
}
function FUN20(
address     VAR44,
bytes32     VAR63
)
public
{
require(FUN21(VAR63, VAR44));
VAR60[VAR63] = FUN22(VAR44, VAR59.VAR64);
FUN18(VAR44, VAR63);
}
function FUN23(
address[]     VAR65,
bytes32[]     VAR66
)
external
{
uint VAR67 = VAR65.VAR8;
require(VAR67 > 0);
require(VAR67 == VAR66.VAR8);
for (uint VAR10 = 0; VAR10 < VAR67; VAR10++) {
FUN20(VAR65[VAR10], VAR66[VAR10]);
}
}
function FUN24(
uint        VAR68,
uint8[]     VAR41,
bytes32[]   VAR42,
bytes32[]   VAR43
)
private
pure
returns (bytes32)
{
require(
VAR68 == VAR41.VAR8 - 1 && (
VAR68 == VAR42.VAR8 - 1 && (
VAR68 == VAR43.VAR8 - 1))
);
return FUN25(
VAR41.FUN17(VAR68),
VAR42.FUN17(VAR68),
VAR43.FUN17(VAR68)
);
}
function FUN26(
uint        VAR68,
address     VAR44,
uint8[]     VAR41,
bytes32[]   VAR42,
bytes32[]   VAR43
)
external
view
returns (bytes32 VAR63, bool[2] VAR69)
{
VAR63 = FUN24(
VAR68,
VAR41,
VAR42,
VAR43
);
VAR69[0] = FUN21(VAR63, VAR44);
VAR69[1] = FUN27(VAR63, VAR44);
}
function FUN21(
bytes32 VAR63,
address VAR44)
public
view
returns (bool)
{
require(VAR44 != 0x0);
Submission memory VAR70 = VAR60[VAR63];
address VAR71 = VAR70.VAR44;
return (
VAR71 == 0x0 || (
VAR70.VAR59 + VAR57 < VAR59.VAR64) || (
VAR71 == VAR44)
);
}
function FUN27(
bytes32 VAR63,
address VAR44)
public
view
returns (bool)
{
Submission memory VAR70 = VAR60[VAR63];
return (
VAR70.VAR59 + VAR57 >= VAR59.VAR64 && (
VAR70.VAR44 == VAR44)
);
}
}
contract VAR72 {
address public VAR18;
event FUN28(
address indexed VAR73,
address indexed VAR74
);
function FUN29() public {
VAR18 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR18);
VAR75;
}
function FUN30(address VAR74) onlyOwner public {
require(VAR74 != 0x0);
FUN28(VAR18, VAR74);
VAR18 = VAR74;
}
}
contract Claimable is VAR72 {
address public VAR76;
modifier FUN31() {
require(msg.sender == VAR76);
VAR75;
}
function FUN30(address VAR74) onlyOwner public {
require(VAR74 != 0x0 && VAR74 != VAR18);
VAR76 = VAR74;
}
function FUN32() onlyPendingOwner public {
FUN28(VAR18, VAR76);
VAR18 = VAR76;
VAR76 = 0x0;
}
}
contract TokenRegistry is VAR77 {
address[] public VAR46;
mapping (address => VAR78) VAR79;
mapping (string => address) VAR80;
uint8 public constant VAR81   = 0;
uint8 public constant VAR82  = 1;
struct VAR78 {
uint   VAR83;
uint8  VAR84;
string VAR85;
}
event FUN33(address VAR86, string VAR85);
event FUN34(address VAR86, string VAR85);
function () payable public {
revert();
}
function FUN35(
address VAR86,
string  VAR85
)
external
onlyOwner
{
FUN36(VAR86, VAR85, VAR81);
}
function FUN36(
address VAR86,
string  VAR85,
uint8   VAR84
)
public
onlyOwner
{
require(0x0 != VAR86);
require(bytes(VAR85).VAR8 > 0);
require(0x0 == VAR80[VAR85]);
require(0 == VAR79[VAR86].VAR83);
require(VAR84 <= VAR82);
VAR46.FUN37(VAR86);
VAR80[VAR85] = VAR86;
VAR79[VAR86] = FUN38(VAR46.VAR8, VAR84, VAR85);
FUN33(VAR86, VAR85);
}
function FUN39(
address VAR86,
string  VAR85
)
external
onlyOwner
{
require(VAR86 != 0x0);
require(VAR80[VAR85] == VAR86);
delete VAR80[VAR85];
uint VAR83 = VAR79[VAR86].VAR83;
require(VAR83 != 0);
delete VAR79[VAR86];
address VAR87 = VAR46[VAR46.VAR8 - 1];
if (VAR86 != VAR87) {
VAR46[VAR83 - 1] = VAR87;
VAR79[VAR87].VAR83 = VAR83;
}
VAR46.VAR8--;
FUN34(VAR86, VAR85);
}
function FUN40(string VAR85)
public
view
returns (bool)
{
return VAR80[VAR85] != 0x0;
}
function FUN41(address VAR86)
public
view
returns (bool)
{
return VAR79[VAR86].VAR83 != 0;
}
function FUN42(address[] VAR37)
external
view
returns (bool)
{
for (uint VAR10 = 0; VAR10 < VAR37.VAR8; VAR10++) {
if (VAR79[VAR37[VAR10]].VAR83 == 0) {
return false;
}
}
return true;
}
function FUN43(address VAR86)
public
view
returns (uint8)
{
TokenInfo memory VAR88 = VAR79[VAR86];
require(VAR88.VAR83 != 0);
return VAR88.VAR84;
}
function FUN44(string VAR85)
external
view
returns (address)
{
return VAR80[VAR85];
}
function FUN45(
uint VAR89,
uint VAR90
)
public
view
returns (address[] VAR37)
{
uint VAR91 = VAR46.VAR8;
if (VAR89 >= VAR91) {
return;
}
uint VAR92 = VAR89 + VAR90;
if (VAR92 > VAR91) {
VAR92 = VAR91;
}
if (VAR89 == VAR91) {
return;
}
VAR37 = new address[](VAR92 - VAR89);
for (uint VAR10 = VAR89; VAR10 < VAR92; VAR10++) {
VAR37[VAR10 - VAR89] = VAR46[VAR10];
}
}
}
contract TokenTransferDelegate is VAR77 {
using MathUint for uint;
mapping(address => VAR93) private VAR94;
address public VAR95;
struct VAR93 {
address VAR96;
uint32  VAR97;
bool    VAR98;
}
modifier FUN46() {
require(VAR94[msg.sender].VAR98);
VAR75;
}
event FUN47(address indexed VAR86, uint32 VAR64);
event FUN48(address indexed VAR86, uint32 VAR64);
function () payable public {
revert();
}
function FUN49(address VAR86)
onlyOwner
external
{
AddressInfo storage VAR99 = VAR94[VAR86];
if (VAR99.VAR97 != 0) {
if (VAR99.VAR98 == false) {
VAR99.VAR98 = true;
FUN47(VAR86, VAR99.VAR97);
}
} else {
address VAR100 = VAR95;
if (VAR100 == 0x0) {
VAR99.VAR97 = 1;
VAR99.VAR98 = true;
} else {
VAR99.VAR96 = VAR100;
VAR99.VAR97 = VAR94[VAR100].VAR97 + 1;
}
VAR99.VAR98 = true;
VAR95 = VAR86;
FUN47(VAR86, VAR99.VAR97);
}
}
function FUN50(address VAR86)
onlyOwner
external
{
uint32 VAR97 = VAR94[VAR86].VAR97;
if (VAR97 != 0) {
VAR94[VAR86].VAR98 = false;
FUN48(VAR86, VAR97);
}
}
function FUN51(address VAR86)
public
view
returns (bool)
{
return VAR94[VAR86].VAR98;
}
function FUN52(uint VAR101)
external
view
returns (address[] VAR46)
{
VAR46 = new address[](VAR101);
address VAR86 = VAR95;
AddressInfo memory VAR99;
uint VAR90 = 0;
while (VAR86 != 0x0 && VAR90 < VAR101) {
VAR99 = VAR94[VAR86];
if (VAR99.VAR97 == 0) {
break;
}
VAR46[VAR90++] = VAR86;
VAR86 = VAR99.VAR96;
}
}
function FUN53(
address VAR102,
address VAR16,
address VAR17,
uint    value)
VAR103
external
{
if (value > 0 && VAR16 != VAR17) {
require(
FUN54(VAR102).FUN9(VAR16, VAR17, value)
);
}
}
function FUN55(
address VAR104,
address VAR105,
bytes32[] VAR106)
VAR103
external
{
uint VAR7 = VAR106.VAR8;
require(VAR7 % 6 == 0);
ERC20 VAR107 = FUN54(VAR104);
for (uint VAR10 = 0; VAR10 < VAR7; VAR10 += 6) {
address VAR18 = address(VAR106[VAR10]);
address VAR108 = address(VAR106[(VAR10 + VAR7 - 6) % VAR7]);
ERC20 VAR102 = FUN54(address(VAR106[VAR10 + 1]));
if (VAR18 != VAR108) {
require(
VAR102.FUN9(VAR18, VAR108, uint(VAR106[VAR10 + 2]))
);
}
if (VAR18 != VAR105) {
bytes32 VAR13 = VAR106[VAR10 + 3];
if (VAR13 != 0) {
require(
VAR102.FUN9(VAR18, VAR105, uint(VAR13))
);
}
VAR13 = VAR106[VAR10 + 4];
if (VAR13 != 0) {
require(
VAR107.FUN9(VAR105, VAR18, uint(VAR13))
);
}
VAR13 = VAR106[VAR10 + 5];
if (VAR13 != 0) {
require(
VAR107.FUN9(VAR18, VAR105, uint(VAR13))
);
}
}
}
}
}
contract LoopringProtocolImpl is VAR21 {
using MathUint for uint;
address public  VAR104             = 0x0;
address public  VAR109        = 0x0;
address public  VAR110     = 0x0;
address public  VAR111             = 0x0;
uint    public  VAR112                 = 0;
uint64  public  VAR113                   = 0;
//
//
uint    public  VAR114       = 0;
uint    public constant VAR115    = 10000;
uint64  public constant VAR116        = 1 << 63;
mapping (bytes32 => uint) public VAR117;
mapping (address => uint) public VAR118;
struct VAR119 {
uint VAR120;
uint VAR121;
}
struct VAR122 {
address VAR18;
address VAR123;
address VAR124;
uint    VAR120;
uint    VAR121;
uint    VAR125;
bool    VAR48;
uint8   VAR49;
}
struct VAR126 {
Order   VAR127;
bytes32 VAR128;
uint8   VAR129;
Rate    VAR130;
uint    VAR131;
uint    VAR132;
uint    VAR125;
uint    VAR133;
uint    VAR134;
}
function FUN56(
address VAR135,
address VAR136,
address VAR137,
address VAR138,
uint    VAR139,
uint    VAR140
)
public
{
require(0x0 != VAR135);
require(0x0 != VAR136);
require(0x0 != VAR137);
require(0x0 != VAR138);
require(VAR139 > 1);
require(VAR140 > 0);
VAR104 = VAR135;
VAR109 = VAR136;
VAR110 = VAR137;
VAR111 = VAR138;
VAR112 = VAR139;
VAR114 = VAR140;
}
function () payable public {
revert();
}
function FUN14(
address[2][]  VAR37,
uint[7][]     VAR38,
uint8[2][]    VAR39,
bool[]        VAR40,
uint8[]       VAR41,
bytes32[]     VAR42,
bytes32[]     VAR43,
address       VAR44,
address       VAR105
)
public
{
require(VAR113 & VAR116 != VAR116);
VAR113 |= VAR116;
uint VAR68 = VAR37.VAR8;
require(VAR68 > 1 && VAR68 <= VAR112);
FUN57(
VAR68,
VAR37,
VAR38,
VAR39,
VAR40,
VAR41,
VAR42,
VAR43
);
FUN58(VAR68, VAR37);
FUN59 (VAR63, VAR141) = FUN19(
VAR110
).FUN26(
VAR68,
VAR44,
VAR41,
VAR42,
VAR43
);
require(VAR141[0]);
FUN60(
VAR44,
VAR63,
VAR41[VAR68],
VAR42[VAR68],
VAR43[VAR68]
);
VAR126[] memory VAR142 = FUN61(
VAR37,
VAR38,
VAR39,
VAR40,
VAR41,
VAR42,
VAR43
);
if (VAR105 == 0x0) {
VAR105 = VAR44;
}
FUN62(
VAR68,
VAR63,
VAR142,
VAR44,
VAR105,
VAR141[1]
);
VAR113 = (VAR113 ^ VAR116) + 1;
}
function FUN15(
address[3] VAR46,
uint[7]    VAR47,
bool       VAR48,
uint8      VAR49,
uint8      VAR50,
bytes32    VAR51,
bytes32    VAR12
)
external
{
uint VAR143 = VAR47[6];
require(VAR143 > 0);
Order memory VAR127 = FUN63(
VAR46[0],
VAR46[1],
VAR46[2],
VAR47[0],
VAR47[1],
VAR47[5],
VAR48,
VAR49
);
require(msg.sender == VAR127.VAR18);
bytes32 VAR128 = FUN64(
VAR127,
VAR47[2],
VAR47[3],
VAR47[4]
);
FUN60(
VAR127.VAR18,
VAR128,
VAR50,
VAR51,
VAR12
);
VAR117[VAR128] = VAR117[VAR128].FUN3(VAR143);
FUN12(VAR128, VAR143);
}
function FUN16(uint VAR52)
external
{
uint VAR144 = (VAR52 == 0 || VAR52 >= VAR59.VAR145) ? VAR59.VAR145 : VAR52;
require(VAR118[msg.sender] < VAR144);
VAR118[msg.sender] = VAR144;
FUN13(msg.sender, VAR144);
}
function FUN65(
uint          VAR68,
VAR126[]  VAR142
)
private
pure
{
for (uint VAR10 = 0; VAR10 < VAR68 - 1; VAR10++) {
address VAR123 = VAR142[VAR10].VAR127.VAR123;
for (uint VAR146 = VAR10 + 1; VAR146 < VAR68; VAR146++) {
require(VAR123 != VAR142[VAR146].VAR127.VAR123);
}
}
}
function FUN58(
uint          VAR68,
address[2][]  VAR37
)
private
view
{
address[] memory VAR147 = new address[](VAR68);
for (uint VAR10 = 0; VAR10 < VAR68; VAR10++) {
VAR147[VAR10] = VAR37[VAR10][1];
}
require(
FUN66(VAR109).FUN42(VAR147)
);
}
function FUN62(
uint          VAR68,
bytes32       VAR63,
VAR126[]  VAR142,
address       VAR71,
address       VAR105,
bool          VAR148
)
private
{
uint64 VAR26 = VAR113 ^ VAR116;
address VAR135 = VAR104;
TokenTransferDelegate VAR149 = FUN67(VAR111);
FUN65(VAR68, VAR142);
FUN68(VAR68, VAR142);
FUN69(VAR149, VAR68, VAR142);
FUN70(VAR68, VAR142);
FUN71(
VAR149,
VAR68,
VAR142,
VAR105,
VAR135
);
FUN59 (VAR150, VAR151) = FUN72(
VAR149,
VAR68,
VAR142,
VAR105,
VAR135
);
FUN11(
VAR26,
VAR63,
VAR71,
VAR105,
VAR148,
VAR150,
VAR151
);
}
function FUN72(
TokenTransferDelegate VAR149,
uint          VAR68,
VAR126[]  VAR142,
address       VAR105,
address       VAR135
)
private
returns(
bytes32[] memory VAR150,
uint[6][] memory VAR151)
{
bytes32[] memory VAR106 = new bytes32[](VAR68 * 6);
VAR150 = new bytes32[](VAR68);
VAR151 = new uint[6][](VAR68);
uint VAR152 = 0;
for (uint VAR10 = 0; VAR10 < VAR68; VAR10++) {
OrderState memory VAR153 = VAR142[VAR10];
Order memory VAR127 = VAR153.VAR127;
uint VAR154 = VAR142[(VAR10 + VAR68 - 1) % VAR68].VAR134;
uint VAR155 = VAR142[(VAR10 + 1) % VAR68].VAR131;
VAR106[VAR152] = bytes32(VAR127.VAR18);
VAR106[VAR152+1] = bytes32(VAR127.VAR123);
VAR106[VAR152+2] = bytes32(VAR153.VAR131 - VAR154);
VAR106[VAR152+3] = bytes32(VAR154 + VAR153.VAR133);
VAR106[VAR152+4] = bytes32(VAR153.VAR132);
VAR106[VAR152+5] = bytes32(VAR153.VAR125);
VAR152 += 6;
if (VAR127.VAR48) {
VAR117[VAR153.VAR128] += VAR155;
} else {
VAR117[VAR153.VAR128] += VAR153.VAR131;
}
VAR150[VAR10] = VAR153.VAR128;
VAR151[VAR10][0] = VAR153.VAR131 + VAR153.VAR133;
VAR151[VAR10][1] = VAR155 - VAR153.VAR134;
VAR151[VAR10][2] = VAR153.VAR132;
VAR151[VAR10][3] = VAR153.VAR125;
VAR151[VAR10][4] = VAR153.VAR133;
VAR151[VAR10][5] = VAR153.VAR134;
}
VAR149.FUN55(VAR135, VAR105, VAR106);
}
function FUN68(
uint          VAR68,
VAR126[]  VAR142
)
private
view
{
uint[] memory VAR156 = new uint[](VAR68);
uint VAR157 = VAR115;
for (uint VAR10 = 0; VAR10 < VAR68; VAR10++) {
uint VAR158 = VAR142[VAR10].VAR130.VAR120.FUN1(VAR142[VAR10].VAR127.VAR121);
uint VAR159 = VAR142[VAR10].VAR127.VAR120.FUN1(VAR142[VAR10].VAR130.VAR121);
require(VAR158 <= VAR159);
VAR156[VAR10] = VAR157.FUN1(VAR158) / VAR159;
}
uint VAR11 = VAR1.FUN5(VAR156, VAR157);
require(VAR11 <= VAR114);
}
function FUN71(
TokenTransferDelegate VAR149,
uint            VAR68,
VAR126[]    VAR142,
address         VAR105,
address         VAR135
)
private
view
{
bool VAR160 = false;
uint VAR161 = 0;
uint8 VAR162 = VAR25;
uint VAR155;
for (uint VAR10 = 0; VAR10 < VAR68; VAR10++) {
OrderState memory VAR153 = VAR142[VAR10];
uint VAR163 = 0;
if (VAR153.VAR125 == 0) {
VAR153.VAR129 = VAR23;
VAR153.VAR127.VAR49 = VAR162;
} else {
uint VAR164 = FUN73(
VAR149,
VAR135,
VAR153.VAR127.VAR18
);
if (VAR153.VAR127.VAR123 == VAR135) {
VAR164 -= VAR153.VAR131;
}
if (VAR153.VAR127.VAR124 == VAR135) {
VAR155 = VAR142[(VAR10 + 1) % VAR68].VAR131;
VAR163 = VAR155;
}
uint VAR165 = VAR164 + VAR163;
if (VAR165 < VAR153.VAR125) {
VAR153.VAR125 = VAR165;
VAR153.VAR127.VAR49 = VAR162;
}
if (VAR153.VAR125 == 0) {
VAR153.VAR129 = VAR23;
}
}
if (VAR153.VAR129 == VAR22) {
if (VAR163 > 0) {
if (VAR163 >= VAR153.VAR125) {
VAR153.VAR134 = VAR153.VAR125;
VAR153.VAR125 = 0;
} else {
VAR153.VAR134 = VAR163;
VAR153.VAR125 -= VAR163;
}
}
} else if (VAR153.VAR129 == VAR23) {
if (!VAR160 && VAR161 < VAR153.VAR125) {
VAR160 = true;
VAR161 = FUN73(VAR149, VAR135, VAR105);
}
if (VAR161 >= VAR153.VAR125) {
VAR155 = VAR142[(VAR10 + 1) % VAR68].VAR131;
uint VAR166;
if (VAR153.VAR127.VAR48) {
VAR166 = (VAR155.FUN1(
VAR153.VAR127.VAR120
) / VAR153.VAR127.VAR121).FUN2(
VAR153.VAR131
);
} else {
VAR166 = VAR155.FUN2(
VAR153.VAR131.FUN1(
VAR153.VAR127.VAR121
) / VAR153.VAR127.VAR120
);
}
if (VAR153.VAR127.VAR49 != VAR162) {
VAR166 = VAR166.FUN1(
VAR153.VAR127.VAR49
) / VAR162;
}
if (VAR153.VAR127.VAR48) {
VAR153.VAR133 = VAR166;
} else {
VAR153.VAR134 = VAR166;
}
if (VAR166 > 0) {
VAR161 -= VAR153.VAR125;
VAR153.VAR132 = VAR153.VAR125;
}
}
VAR153.VAR125 = 0;
} else {
revert();
}
}
}
function FUN70(
uint          VAR68,
VAR126[]  VAR142
)
private
pure
{
uint VAR167 = 0;
uint VAR10;
uint VAR146;
for (VAR10 = 0; VAR10 < VAR68; VAR10++) {
VAR146 = (VAR10 + 1) % VAR68;
VAR167 = FUN74(
VAR142[VAR10],
VAR142[VAR146],
VAR10,
VAR146,
VAR167
);
}
for (VAR10 = 0; VAR10 < VAR167; VAR10++) {
FUN74(
VAR142[VAR10],
VAR142[(VAR10 + 1) % VAR68],
0,
0,
0
);
}
}
function FUN74(
OrderState        VAR153,
OrderState        VAR168,
uint              VAR10,
uint              VAR146,
uint              VAR167
)
private
pure
returns (uint VAR169)
{
VAR169 = VAR167;
uint VAR170 = VAR153.VAR131.FUN1(
VAR153.VAR130.VAR121
) / VAR153.VAR130.VAR120;
if (VAR153.VAR127.VAR48) {
if (VAR170 > VAR153.VAR127.VAR121) {
VAR170 = VAR153.VAR127.VAR121;
VAR153.VAR131 = VAR170.FUN1(
VAR153.VAR130.VAR120
) / VAR153.VAR130.VAR121;
VAR169 = VAR10;
}
VAR153.VAR125 = VAR153.VAR127.VAR125.FUN1(
VAR170
) / VAR153.VAR127.VAR121;
} else {
VAR153.VAR125 = VAR153.VAR127.VAR125.FUN1(
VAR153.VAR131
) / VAR153.VAR127.VAR120;
}
if (VAR170 <= VAR168.VAR131) {
VAR168.VAR131 = VAR170;
} else {
VAR169 = VAR146;
}
}
function FUN69(
TokenTransferDelegate VAR149,
uint VAR68,
VAR126[] VAR142
)
private
view
{
for (uint VAR10 = 0; VAR10 < VAR68; VAR10++) {
OrderState memory VAR153 = VAR142[VAR10];
Order memory VAR127 = VAR153.VAR127;
uint VAR171;
if (VAR127.VAR48) {
VAR171 = VAR127.VAR121.FUN4(
VAR117[VAR153.VAR128]
);
VAR127.VAR120 = VAR171.FUN1(VAR127.VAR120) / VAR127.VAR121;
VAR127.VAR125 = VAR171.FUN1(VAR127.VAR125) / VAR127.VAR121;
VAR127.VAR121 = VAR171;
} else {
VAR171 = VAR127.VAR120.FUN4(
VAR117[VAR153.VAR128]
);
VAR127.VAR121 = VAR171.FUN1(VAR127.VAR121) / VAR127.VAR120;
VAR127.VAR125 = VAR171.FUN1(VAR127.VAR125) / VAR127.VAR120;
VAR127.VAR120 = VAR171;
}
require(VAR127.VAR120 > 0);
require(VAR127.VAR121 > 0);
uint VAR172 = FUN73(VAR149, VAR127.VAR123, VAR127.VAR18);
require(VAR172 > 0);
VAR153.VAR131 = (
VAR127.VAR120 < VAR172 ?
VAR127.VAR120 : VAR172
);
}
}
function FUN73(
TokenTransferDelegate VAR149,
address VAR173,
address VAR174
)
private
view
returns (uint)
{
ERC20 VAR102 = FUN54(VAR173);
uint VAR175 = VAR102.FUN8(
VAR174,
address(VAR149)
);
uint VAR176 = VAR102.FUN7(VAR174);
return (VAR175 < VAR176 ? VAR175 : VAR176);
}
function FUN57(
uint          VAR68,
address[2][]  VAR37,
uint[7][]     VAR38,
uint8[2][]    VAR39,
bool[]        VAR40,
uint8[]       VAR41,
bytes32[]     VAR42,
bytes32[]     VAR43
)
private
pure
{
require(VAR68 == VAR37.VAR8);
require(VAR68 == VAR38.VAR8);
require(VAR68 == VAR39.VAR8);
require(VAR68 == VAR40.VAR8);
require(VAR68 + 1 == VAR41.VAR8);
require(VAR68 + 1 == VAR42.VAR8);
require(VAR68 + 1 == VAR43.VAR8);
for (uint VAR10 = 0; VAR10 < VAR68; VAR10++) {
require(VAR38[VAR10][6] > 0);
require(VAR39[VAR10][1] <= VAR24);
}
}
function FUN61(
address[2][]    VAR37,
uint[7][]       VAR38,
uint8[2][]      VAR39,
bool[]          VAR40,
uint8[]         VAR41,
bytes32[]       VAR42,
bytes32[]       VAR43
)
private
view
returns (VAR126[] memory VAR142)
{
uint VAR68 = VAR37.VAR8;
VAR142 = new VAR126[](VAR68);
for (uint VAR10 = 0; VAR10 < VAR68; VAR10++) {
uint[7] memory VAR177 = VAR38[VAR10];
Order memory VAR127 = FUN63(
VAR37[VAR10][0],
VAR37[VAR10][1],
VAR37[(VAR10 + 1) % VAR68][1],
VAR177[0],
VAR177[1],
VAR177[5],
VAR40[VAR10],
VAR39[VAR10][0]
);
bytes32 VAR128 = FUN64(
VAR127,
VAR177[2],
VAR177[3],
VAR177[4]
);
FUN60(
VAR127.VAR18,
VAR128,
VAR41[VAR10],
VAR42[VAR10],
VAR43[VAR10]
);
FUN75(
VAR127,
VAR177[2],
VAR177[3],
VAR177[4]
);
VAR142[VAR10] = FUN76(
VAR127,
VAR128,
VAR39[VAR10][1],
FUN77(VAR177[6], VAR127.VAR121),
0,
0,
0,
0,
0
);
}
}
function FUN75(
Order        VAR127,
uint         VAR145,
uint         VAR178,
uint         VAR179
)
private
view
{
require(VAR127.VAR18 != 0x0);
require(VAR127.VAR123 != 0x0);
require(VAR127.VAR124 != 0x0);
require(VAR127.VAR120 != 0);
require(VAR127.VAR121 != 0);
require(VAR145 <= VAR59.VAR145);
require(VAR145 > VAR118[VAR127.VAR18]);
require(VAR178 != 0);
require(VAR145 + VAR178 > VAR59.VAR145);
require(VAR179 != 0);
require(VAR127.VAR49 <= VAR25);
}
function FUN64(
Order        VAR127,
uint         VAR145,
uint         VAR178,
uint         VAR179
)
private
view
returns (bytes32)
{
return FUN25(
address(this),
VAR127.VAR18,
VAR127.VAR123,
VAR127.VAR124,
VAR127.VAR120,
VAR127.VAR121,
VAR145,
VAR178,
VAR179,
VAR127.VAR125,
VAR127.VAR48,
VAR127.VAR49
);
}
function FUN60(
address VAR180,
bytes32 VAR181,
uint8   VAR50,
bytes32 VAR51,
bytes32 VAR12
)
private
pure
{
require(
VAR180 == FUN78(
FUN25("", VAR181),
VAR50,
VAR51,
VAR12
)
);
}
}
0
---------------------------------
461 0x03e3f0c25965f13dbbc58246738c183e27b26a56.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function transfer(address VAR3, uint256 value) public returns (bool);
event Transfer(address indexed VAR4, address indexed VAR3, uint256 value);
}
library VAR5 {
function FUN3(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
if (VAR6 == 0) {
return 0;
}
uint256 VAR8 = VAR6 * VAR7;
assert(VAR8 / VAR6 == VAR7);
return VAR8;
}
function FUN4(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
return VAR6 / VAR7;
}
function FUN5(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
assert(VAR7 <= VAR6);
return VAR6 - VAR7;
}
function FUN6(uint256 VAR6, uint256 VAR7) internal pure returns (uint256) {
uint256 VAR8 = VAR6 + VAR7;
assert(VAR8 >= VAR6);
return VAR8;
}
}
contract BasicToken is VAR1 {
using SafeMath for uint256;
mapping(address => uint256) VAR9;
uint256 VAR10;
function FUN1() public view returns (uint256) {
return VAR10;
}
function transfer(address VAR11, uint256 VAR12) public returns (bool) {
require(VAR11 != address(0));
require(VAR12 <= VAR9[msg.sender]);
VAR9[msg.sender] = VAR9[msg.sender].FUN5(VAR12);
VAR9[VAR11] = VAR9[VAR11].FUN6(VAR12);
emit Transfer(msg.sender, VAR11, VAR12);
return true;
}
function FUN2(address VAR13) public view returns (uint256 VAR14) {
return VAR9[VAR13];
}
}
contract ERC20 is VAR1 {
function FUN7(address VAR15, address VAR16) public view returns (uint256);
function FUN8(address VAR4, address VAR3, uint256 value) public returns (bool);
function FUN9(address VAR16, uint256 value) public returns (bool);
event FUN10(address indexed VAR15, address indexed VAR16, uint256 value);
}
contract StandardToken is VAR17, VAR18 {
mapping (address => mapping (address => uint256)) internal VAR19;
function FUN8(address VAR20, address VAR11, uint256 VAR12) public returns (bool) {
require(VAR11 != address(0));
require(VAR12 <= VAR9[VAR20]);
require(VAR12 <= VAR19[VAR20][msg.sender]);
VAR9[VAR20] = VAR9[VAR20].FUN5(VAR12);
VAR9[VAR11] = VAR9[VAR11].FUN6(VAR12);
VAR19[VAR20][msg.sender] = VAR19[VAR20][msg.sender].FUN5(VAR12);
emit Transfer(VAR20, VAR11, VAR12);
return true;
}
function FUN9(address VAR21, uint256 VAR12) public returns (bool) {
VAR19[msg.sender][VAR21] = VAR12;
emit FUN10(msg.sender, VAR21, VAR12);
return true;
}
function FUN7(address VAR13, address VAR21) public view returns (uint256) {
return VAR19[VAR13][VAR21];
}
function FUN11(address VAR21, uint VAR22) public returns (bool) {
VAR19[msg.sender][VAR21] = VAR19[msg.sender][VAR21].FUN6(VAR22);
emit FUN10(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
function FUN12(address VAR21, uint VAR23) public returns (bool) {
uint VAR24 = VAR19[msg.sender][VAR21];
if (VAR23 > VAR24) {
VAR19[msg.sender][VAR21] = 0;
} else {
VAR19[msg.sender][VAR21] = VAR24.FUN5(VAR23);
}
emit FUN10(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
}
contract VAR25 {
address public VAR15;
event FUN13(address indexed VAR26, address indexed VAR27);
constructor() public {
VAR15 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR15);
VAR28;
}
function FUN14(address VAR27) public onlyOwner {
require(VAR27 != address(0));
emit FUN13(VAR15, VAR27);
VAR15 = VAR27;
}
}
contract DisciplinaToken is VAR29, VAR25 {
string public constant VAR30 = "";
string public constant VAR31 = "";
uint32 public constant VAR32 = 18;
mapping (address => uint256) VAR33;
bool public VAR34 = false;
modifier FUN15() {
require(!VAR34);
VAR28;
}
modifier FUN16() {
require(VAR34);
VAR28;
}
event FUN17(address indexed VAR35, uint256 VAR36);
event FUN18(address indexed VAR3, uint256 VAR36);
event FUN19();
function FUN20(address VAR11, uint256 VAR37) public beforeMintingFinished returns (bool) {
require(VAR33[msg.sender] >= VAR37);
VAR10 = VAR10.FUN6(VAR37);
VAR9[VAR11] = VAR9[VAR11].FUN6(VAR37);
VAR33[msg.sender] = VAR33[msg.sender].FUN5(VAR37);
emit FUN18(VAR11, VAR37);
emit Transfer(address(0), VAR11, VAR37);
return true;
}
function FUN21(address VAR38, uint256 VAR37) public onlyOwner beforeMintingFinished returns (bool) {
VAR33[VAR38] = VAR37;
emit FUN17(VAR38, VAR33[VAR38]);
return true;
}
function FUN22() public onlyOwner beforeMintingFinished returns (bool) {
VAR34 = true;
emit FUN19();
return true;
}
function transfer(address VAR11, uint256 VAR12) public afterMintingFinished returns (bool) {
return super.transfer(VAR11, VAR12);
}
function FUN8(address VAR20, address VAR11, uint256 VAR12) public afterMintingFinished returns (bool) {
return super.FUN8(VAR20, VAR11, VAR12);
}
}
0
---------------------------------
462 0x03e53ffab44c5b60ad7f4eda5969773717007056.sol
pragma VAR1 ^0.4.18;
contract VAR2{
address private VAR3;
function FUN1()
payable
{
VAR3 = msg.sender;
}
function FUN2()
payable
onlyOwner
{
VAR3.transfer(this.VAR4-msg.value);
}
modifier
onlyOwner
{
require(msg.sender == VAR3);
VAR5;
}
}
0
---------------------------------
463 0x03e82c5c236da52a7f5f44d811f324ab437e151e.sol
pragma solidity 0.5.1;
contract VAR1 {
function FUN1(address payable VAR2) public payable {
(new VAR3).value(msg.value)(VAR2);
}
}
contract VAR3 {
constructor(address payable VAR2) public payable {
FUN2(VAR2);
}
}
0
---------------------------------
464 0x03fb52d4ee633ab0d06c833e32efdd8d388f3e6a.sol
pragma VAR1 ^0.5.9;
interface VAR2 {
function FUN1() external view returns (uint256);
function FUN2(address VAR3) external view returns (uint256);
function FUN3(address VAR4, address VAR5) external view returns (uint256);
function transfer(address VAR6, uint256 value) external returns (bool);
function FUN4(address VAR5, uint256 value) external returns (bool);
function FUN5(address VAR7, address VAR6, uint256 value) external returns (bool);
event Transfer(address indexed VAR7, address indexed VAR6, uint256 value);
event FUN6(address indexed VAR4, address indexed VAR5, uint256 value);
}
library VAR8 {
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR11 = VAR9 * VAR10;
assert(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
assert(VAR10 <= VAR9);
return VAR9 - VAR10;
}
function FUN10(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
assert(VAR11 >= VAR9);
return VAR11;
}
function FUN11(uint256 VAR9, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR11 = FUN10(VAR9,VAR12);
uint256 VAR13 = FUN9(VAR11,1);
return FUN7(FUN8(VAR13,VAR12),VAR12);
}
}
contract ERC20Detailed is VAR2 {
string private VAR14;
string private VAR15;
uint8 private VAR16;
constructor(string memory VAR17, string memory VAR18, uint8 VAR19) public {
VAR14 = VAR17;
VAR15 = VAR18;
VAR16 = VAR19;
}
function FUN12() public view returns(string VAR20) {
return VAR14;
}
function FUN13() public view returns(string VAR20) {
return VAR15;
}
function FUN14() public view returns(uint8) {
return VAR16;
}
}
contract BlackHole is VAR21 {
using SafeMath for uint256;
mapping (address => uint256) private VAR22;
mapping (address => mapping (address => uint256)) private VAR23;
string constant VAR24 = "";
string constant VAR25 = "";
uint8  constant VAR26 = 18;
uint256 VAR27 = 2500000000000000000000000;
uint256 public VAR28 = 100;
constructor() public payable FUN15(VAR24, VAR25, VAR26) {
FUN16(msg.sender, VAR27);
}
function FUN1() public view returns (uint256) {
return VAR27;
}
function FUN2(address VAR4) public view returns (uint256) {
return VAR22[VAR4];
}
function FUN3(address VAR4, address VAR5) public view returns (uint256) {
return VAR23[VAR4][VAR5];
}
function FUN17(uint256 value) public view returns (uint256)  {
uint256 VAR29 = value.FUN11(VAR28);
uint256 VAR30 = VAR29.FUN7(VAR28).FUN8(500);
return VAR30;
}
function transfer(address VAR6, uint256 value) public returns (bool) {
require(value <= VAR22[msg.sender]);
require(VAR6 != address(0));
uint256 VAR31 = FUN17(value);
uint256 VAR32 = value.FUN9(VAR31);
VAR22[msg.sender] = VAR22[msg.sender].FUN9(value);
VAR22[VAR6] = VAR22[VAR6].FUN10(VAR32);
VAR27 = VAR27.FUN9(VAR31);
emit Transfer(msg.sender, VAR6, VAR32);
emit Transfer(msg.sender, address(0), VAR31);
return true;
}
function FUN18(address[] memory VAR33, uint256[] memory VAR34) public {
for (uint256 VAR35 = 0; VAR35 < VAR33.VAR36; VAR35++) {
transfer(VAR33[VAR35], VAR34[VAR35]);
}
}
function FUN19(address[] memory VAR33, uint256 VAR37) public {
uint256 VAR38 = VAR37 * 10**18;
for (uint256 VAR35 = 0; VAR35 < VAR33.VAR36; VAR35++) {
transfer(VAR33[VAR35], VAR38);
}
}
function FUN4(address VAR5, uint256 value) public returns (bool) {
require(VAR5 != address(0));
VAR23[msg.sender][VAR5] = value;
emit FUN6(msg.sender, VAR5, value);
return true;
}
function FUN5(address VAR7, address VAR6, uint256 value) public returns (bool) {
require(value <= VAR22[VAR7]);
require(value <= VAR23[VAR7][msg.sender]);
require(VAR6 != address(0));
VAR22[VAR7] = VAR22[VAR7].FUN9(value);
uint256 VAR31 = FUN17(value);
uint256 VAR32 = value.FUN9(VAR31);
VAR22[VAR6] = VAR22[VAR6].FUN10(VAR32);
VAR27 = VAR27.FUN9(VAR31);
VAR23[VAR7][msg.sender] = VAR23[VAR7][msg.sender].FUN9(value);
emit Transfer(VAR7, VAR6, VAR32);
emit Transfer(VAR7, address(0), VAR31);
return true;
}
function FUN20(address VAR5, uint256 VAR39) public returns (bool) {
require(VAR5 != address(0));
VAR23[msg.sender][VAR5] = (VAR23[msg.sender][VAR5].FUN10(VAR39));
emit FUN6(msg.sender, VAR5, VAR23[msg.sender][VAR5]);
return true;
}
function FUN21(address VAR5, uint256 VAR40) public returns (bool) {
require(VAR5 != address(0));
VAR23[msg.sender][VAR5] = (VAR23[msg.sender][VAR5].FUN9(VAR40));
emit FUN6(msg.sender, VAR5, VAR23[msg.sender][VAR5]);
return true;
}
function FUN16(address VAR41, uint256 VAR37) internal {
require(VAR37 != 0);
VAR22[VAR41] = VAR22[VAR41].FUN10(VAR37);
emit Transfer(address(0), VAR41, VAR37);
}
function FUN22(uint256 VAR37) external {
FUN23(msg.sender, VAR37);
}
function FUN23(address VAR41, uint256 VAR37) internal {
require(VAR37 != 0);
require(VAR37 <= VAR22[VAR41]);
VAR27 = VAR27.FUN9(VAR37);
VAR22[VAR41] = VAR22[VAR41].FUN9(VAR37);
emit Transfer(VAR41, address(0), VAR37);
}
function FUN24(address VAR41, uint256 VAR37) external {
require(VAR37 <= VAR23[VAR41][msg.sender]);
VAR23[VAR41][msg.sender] = VAR23[VAR41][msg.sender].FUN9(VAR37);
FUN23(VAR41, VAR37);
}
}
0
---------------------------------
465 0x0403762a5b10218d6e6d131242387e2fec35b48f.sol
pragma VAR1 ^0.5.4;
contract VAR2 {
address private VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
constructor () internal {
VAR3 = msg.sender;
emit FUN1(address(0), VAR3);
}
function FUN2() public view returns (address) {
return VAR3;
}
modifier onlyOwner() {
require(FUN3());
VAR6;
}
function FUN3() public view returns (bool) {
return msg.sender == VAR3;
}
function FUN4() public onlyOwner {
emit FUN1(VAR3, address(0));
VAR3 = address(0);
}
function FUN5(address VAR5) public onlyOwner {
FUN6(VAR5);
}
function FUN6(address VAR5) internal {
require(VAR5 != address(0));
emit FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract VAR7 {
function FUN7(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
uint256 VAR10 = VAR8 * VAR9;
assert(VAR8 == 0 || VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN8(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
assert(VAR9 > 0);
uint256 VAR10 = VAR8 / VAR9;
assert(VAR8 == VAR9 * VAR10 + VAR8 % VAR9);
return VAR10;
}
function FUN9(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
assert(VAR9 <= VAR8);
return VAR8 - VAR9;
}
function FUN10(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
uint256 VAR10 = VAR8 + VAR9;
assert(VAR10>=VAR8 && VAR10>=VAR9);
return VAR10;
}
}
contract HolographicMediaCard is VAR2, VAR7{
string public VAR11;
string public VAR12;
uint8 public VAR13;
uint256 public VAR14;
mapping (address => uint256) public VAR15;
mapping (address => mapping (address => uint256)) public VAR16;
event Transfer(address indexed VAR17, address indexed VAR18, uint256 value);
event FUN11(address indexed VAR19, address indexed VAR20, uint256 value);
constructor()  public  {
VAR15[msg.sender] = 1500000000000000000000000000;
VAR14 = 1500000000000000000000000000;
VAR11 = "";
VAR12 = "";
VAR13 = 18;
}
function transfer(address VAR21, uint256 VAR22) public returns (bool) {
require(VAR21 != address(0));
require(VAR22 > 0);
require(VAR15[msg.sender] >= VAR22);
require(VAR15[VAR21] + VAR22 >= VAR15[VAR21]);
uint VAR23 = VAR15[msg.sender] + VAR15[VAR21];
VAR15[msg.sender] = VAR7.FUN9(VAR15[msg.sender], VAR22);
VAR15[VAR21] = VAR7.FUN10(VAR15[VAR21], VAR22);
emit Transfer(msg.sender, VAR21, VAR22);
assert(VAR15[msg.sender]+VAR15[VAR21]==VAR23);
return true;
}
function FUN12(address VAR24, uint256 VAR22) public returns (bool VAR25) {
require((VAR22 == 0) || (VAR16[msg.sender][VAR24] == 0));
VAR16[msg.sender][VAR24] = VAR22;
emit FUN11(msg.sender, VAR24, VAR22);
return true;
}
function FUN13(address VAR26, address VAR21, uint256 VAR22) public returns (bool VAR25) {
require (VAR21 != address(0));
require (VAR22 > 0);
require (VAR15[VAR26] >= VAR22) ;
require (VAR15[VAR21] + VAR22 > VAR15[VAR21]);
require (VAR22 <= VAR16[VAR26][msg.sender]);
VAR15[VAR26] = VAR7.FUN9(VAR15[VAR26], VAR22);
VAR15[VAR21] = VAR7.FUN10(VAR15[VAR21], VAR22);
VAR16[VAR26][msg.sender] = VAR7.FUN9(VAR16[VAR26][msg.sender], VAR22);
emit Transfer(VAR26, VAR21, VAR22);
return true;
}
}
0
---------------------------------
466 0x0407b4c4eaed35ce3c5b852bdfa1640b09eeedf4.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1() public view returns (uint256);
function FUN2(address VAR2) public view returns (uint256);
function transfer(address VAR3, uint256 VAR4) public returns (bool);
event Transfer(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract ERC20 is VAR1 {
function FUN3(address VAR7, address VAR8)
public view returns (uint256);
function FUN4(address VAR9, address VAR3, uint256 VAR4)
public returns (bool);
function FUN5(address VAR8, uint256 VAR4) public returns (bool);
event FUN6(
address indexed VAR10,
address indexed VAR11,
uint256 value
);
}
contract ERC865Basic is VAR12 {
function FUN7(
bytes VAR13,
address VAR9,
address VAR3,
uint256 VAR4,
uint256 VAR14,
uint256 VAR15
)
internal;
event FUN8(
address indexed VAR16,
address indexed VAR5,
address indexed VAR6,
uint256 value);
}
library VAR17 {
function FUN9(uint256 VAR18, uint256 VAR19) internal pure returns (uint256 VAR20) {
if (VAR18 == 0) {
return 0;
}
VAR20 = VAR18 * VAR19;
assert(VAR20 / VAR18 == VAR19);
return VAR20;
}
function FUN10(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
return VAR18 / VAR19;
}
function FUN11(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
assert(VAR19 <= VAR18);
return VAR18 - VAR19;
}
function FUN12(uint256 VAR18, uint256 VAR19) internal pure returns (uint256 VAR20) {
VAR20 = VAR18 + VAR19;
assert(VAR20 >= VAR18);
return VAR20;
}
}
contract BasicToken is VAR1 {
using SafeMath for uint256;
mapping(address => uint256) internal VAR21;
uint256 internal VAR22;
function FUN1() public view returns (uint256) {
return VAR22;
}
function transfer(address VAR3, uint256 VAR4) public returns (bool) {
require(VAR4 <= VAR21[msg.sender]);
require(VAR3 != address(0));
VAR21[msg.sender] = VAR21[msg.sender].FUN11(VAR4);
VAR21[VAR3] = VAR21[VAR3].FUN12(VAR4);
emit Transfer(msg.sender, VAR3, VAR4);
return true;
}
function FUN2(address VAR7) public view returns (uint256) {
return VAR21[VAR7];
}
}
contract StandardToken is VAR12, VAR23 {
mapping (address => mapping (address => uint256)) internal VAR24;
function FUN4(
address VAR9,
address VAR3,
uint256 VAR4
)
public
returns (bool)
{
require(VAR4 <= VAR21[VAR9]);
require(VAR4 <= VAR24[VAR9][msg.sender]);
require(VAR3 != address(0));
VAR21[VAR9] = VAR21[VAR9].FUN11(VAR4);
VAR21[VAR3] = VAR21[VAR3].FUN12(VAR4);
VAR24[VAR9][msg.sender] = VAR24[VAR9][msg.sender].FUN11(VAR4);
emit Transfer(VAR9, VAR3, VAR4);
return true;
}
function FUN5(address VAR8, uint256 VAR4) public returns (bool) {
VAR24[msg.sender][VAR8] = VAR4;
emit FUN6(msg.sender, VAR8, VAR4);
return true;
}
function FUN3(
address VAR7,
address VAR8
)
public
view
returns (uint256)
{
return VAR24[VAR7][VAR8];
}
function FUN13(
address VAR8,
uint256 VAR25
)
public
returns (bool)
{
VAR24[msg.sender][VAR8] = (
VAR24[msg.sender][VAR8].FUN12(VAR25));
emit FUN6(msg.sender, VAR8, VAR24[msg.sender][VAR8]);
return true;
}
function FUN14(
address VAR8,
uint256 VAR26
)
public
returns (bool)
{
uint256 VAR27 = VAR24[msg.sender][VAR8];
if (VAR26 >= VAR27) {
VAR24[msg.sender][VAR8] = 0;
} else {
VAR24[msg.sender][VAR8] = VAR27.FUN11(VAR26);
}
emit FUN6(msg.sender, VAR8, VAR24[msg.sender][VAR8]);
return true;
}
}
contract ERC865BasicToken is VAR28, VAR29 {
address internal VAR30;
mapping(bytes => bool) internal VAR31;
function FUN7(
bytes VAR13,
address VAR9,
address VAR3,
uint256 VAR4,
uint256 VAR14,
uint256 VAR15
)
internal
{
require(VAR3 != address(0));
require(VAR31[VAR13] == false);
bytes32 VAR32 = FUN15(VAR3, VAR4, VAR14, VAR15);
address VAR5 = FUN16(VAR32, VAR13);
require(VAR5 == VAR9);
uint256 VAR33 = VAR4.FUN12(VAR14);
require(VAR33 <= VAR21[VAR5]);
VAR21[VAR5] = VAR21[VAR5].FUN11(VAR4).FUN11(VAR14);
VAR21[VAR3] = VAR21[VAR3].FUN12(VAR4);
VAR21[VAR30] = VAR21[VAR30].FUN12(VAR14);
VAR31[VAR13] = true;
emit FUN8(msg.sender, VAR5, VAR3, VAR4);
emit FUN8(msg.sender, VAR5, VAR30, VAR14);
emit Transfer(VAR5, VAR3, VAR4);
emit Transfer(VAR5, VAR30, VAR14);
}
function FUN15(
address VAR3,
uint256 VAR4,
uint256 VAR14,
uint256 VAR15
)
internal pure
returns (bytes32)
{
bytes32 VAR34 = FUN17(VAR35.FUN18(VAR3, VAR4, VAR14,VAR15));
return FUN19(VAR34);
}
function FUN19(bytes32 VAR36) internal pure returns (bytes32) {
return FUN17(VAR35.FUN18("", VAR36));
}
function FUN16(bytes32 VAR36, bytes VAR37) internal pure returns (address) {
bytes32 VAR38;
bytes32 VAR39;
uint8 VAR40;
if (VAR37.VAR41 != 65) {
return (address(0));
}
VAR42 {
VAR38 := FUN20(FUN12(VAR37, 32))
VAR39 := FUN20(FUN12(VAR37, 64))
VAR40 := FUN21(0, FUN20(FUN12(VAR37, 96)))
}
if (VAR40 < 27) {
VAR40 += 27;
}
if (VAR40 != 27 && VAR40 != 28) {
return (address(0));
} else {
return FUN22(VAR36, VAR40, VAR38, VAR39);
}
}
}
contract TaxedToken is VAR43 {
uint8 public VAR44;
function transfer(
address VAR3,
uint256 VAR4
)
public
returns (bool)
{
require(VAR3 != address(0));
require(VAR4 <= VAR21[msg.sender]);
VAR21[msg.sender] = VAR21[msg.sender].FUN11(VAR4);
uint256 VAR45 = VAR4.FUN9(VAR44).FUN10(100);
uint256 VAR46 = VAR4.FUN11(VAR45);
VAR21[VAR3] = VAR21[VAR3].FUN12(VAR46);
emit Transfer(msg.sender, VAR3, VAR46);
VAR21[VAR30] = VAR21[VAR30].FUN12(VAR45);
emit Transfer(msg.sender, VAR30, VAR45);
return true;
}
function FUN4(
address VAR9,
address VAR3,
uint256 VAR4
)
public
returns (bool)
{
require(VAR3 != address(0));
require(VAR4 <= VAR21[VAR9]);
require(VAR4 <= VAR24[VAR9][msg.sender]);
VAR21[VAR9] = VAR21[VAR9].FUN11(VAR4);
uint256 VAR45 = VAR4.FUN9(VAR44).FUN10(100);
uint256 VAR46 = VAR4.FUN11(VAR45);
VAR21[VAR3] = VAR21[VAR3].FUN12(VAR46);
emit Transfer(VAR9, VAR3, VAR46);
VAR21[VAR30] = VAR21[VAR30].FUN12(VAR45);
VAR24[VAR9][msg.sender] = VAR24[VAR9][msg.sender].FUN11(VAR4);
emit Transfer(VAR9, VAR30, VAR45);
return true;
}
}
contract VAR47 {
address public VAR10;
event FUN23(address indexed VAR48);
event FUN24(
address indexed VAR48,
address indexed VAR49
);
constructor() public {
VAR10 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR50;
}
function FUN25() public onlyOwner {
emit FUN23(VAR10);
VAR10 = address(0);
}
function FUN26(address VAR51) public onlyOwner {
FUN27(VAR51);
}
function FUN27(address VAR51) internal {
require(VAR51 != address(0));
emit FUN24(VAR10, VAR51);
VAR10 = VAR51;
}
}
contract Authorizable is VAR47 {
using SafeMath for uint256;
address[] public VAR52;
mapping(address => bool) internal VAR53;
uint8 public VAR54;
constructor() public {
VAR52.VAR41 = 2;
VAR52[1] = msg.sender;
VAR53[msg.sender] = true;
VAR54 = 1;
}
modifier VAR55 {
require(FUN28(msg.sender));
VAR50;
}
function FUN29(address VAR56) public onlyOwner {
if (VAR53[VAR56] == false) {
VAR53[VAR56] = true;
VAR52.VAR41++;
VAR52[VAR52.VAR41.FUN11(1)] = VAR56;
VAR54++;
}
}
function FUN28(address VAR56) public constant returns (bool) {
if (VAR53[VAR56] == true) {
return true;
}
return false;
}
function FUN30(address VAR56) public onlyOwner {
require(FUN28(VAR56));
VAR53[VAR56] = false;
VAR54--;
}
}
contract BlockWRKToken is VAR57, VAR58 {
string public VAR59 = "";
string public VAR60 = "";
uint8 public VAR61 = 4;
uint256 public VAR62;
address public VAR63;
address public VAR64;
address public VAR65;
uint256 public VAR66;
uint256 public VAR67;
uint256 internal VAR68 = 10000;
constructor() public {
VAR30 = 0xeCced56A201d1A6D1Da31A060868F96ACdba99B3;
VAR63 = 0xAB3Edd46E9D52e1b3131757e1Ed87FA885f48019;
VAR64 = 0x97eae8151487e054112E27D8c2eE5f17B3C6A83c;
VAR65 = 0xd6E4E287a4aE2E9d8BF7f0323f440acC0d5AD301;
VAR66 = VAR68.FUN9(5600000000);
VAR67 = VAR68.FUN9(2000000000);
VAR62 = VAR66.FUN12(VAR67);
VAR21[VAR63] = VAR66;
emit Transfer(address(this), VAR63, VAR66);
VAR21[VAR65] = VAR67;
emit Transfer(address(this), VAR65, VAR67);
VAR22 = VAR62;
VAR44 = 2;
}
function FUN31(
address VAR3,
uint256 VAR4
)
public
VAR55
{
require(VAR4 <= VAR21[VAR63]);
require(VAR3 != address(0));
VAR21[VAR63] = VAR21[VAR63].FUN11(VAR4);
VAR21[VAR3] = VAR21[VAR3].FUN12(VAR4);
emit Transfer(VAR63, VAR3, VAR4);
}
function FUN32(
address VAR3,
uint256 VAR4,
uint256 VAR14
)
public
VAR55
{
require(VAR4 <= VAR21[VAR64]);
require(VAR3 != address(0));
VAR21[VAR64] = VAR21[VAR64].FUN11(VAR4);
uint256 VAR69 = VAR4.FUN11(VAR14);
VAR21[VAR3] = VAR21[VAR3].FUN12(VAR69);
emit Transfer(VAR64, VAR3, VAR69);
VAR21[VAR30] = VAR21[VAR30].FUN12(VAR14);
emit Transfer(VAR64, VAR30, VAR14);
}
function FUN33(uint8 VAR70) public onlyOwner {
VAR44 = VAR70;
}
function FUN34(address VAR71) public onlyOwner {
require(VAR71 != address(0));
VAR30 = VAR71;
}
function FUN35(address VAR71) public onlyOwner {
require(VAR71 != address(0));
VAR64 = VAR71;
}
function FUN36(
bytes VAR13,
address VAR9,
address VAR3,
uint256 VAR4,
uint256 VAR14,
uint256 VAR15
)
public
VAR55
{
FUN7(VAR13, VAR9, VAR3, VAR4, VAR14, VAR15);
}
}
contract BlockWRKICO is VAR72 {
address public VAR73;
uint256 public VAR74;
uint256 public VAR75;
uint256 public VAR76;
uint256 public VAR77;
uint256 public VAR78;
uint256 internal VAR79;
uint256 internal VAR80;
uint256 internal VAR81;
uint256 internal VAR82;
uint256 internal VAR83;
uint256 internal VAR84;
uint256 internal VAR85;
uint256 internal VAR86;
uint256 internal VAR87;
uint256 internal VAR88;
uint256 internal VAR89;
uint256 internal VAR90;
uint256 internal VAR91;
uint256 internal VAR92;
uint256 internal VAR93;
uint256 internal VAR94;
uint256 internal VAR95;
uint256 internal VAR96;
uint256 internal VAR97;
uint256 internal VAR98;
uint256 internal VAR99;
uint256 internal VAR100;
uint256 internal VAR101;
uint256 internal VAR102;
uint256 internal VAR103;
constructor() public {
VAR74 = 9999999999999999999999999999999999999999999999;
VAR73 = 0xA0E021fC3538ed52F9a3D79249ff1D3A67f91C42;
VAR77 = 1557856800;
VAR75 = 1589479200;
VAR81 = 76000000000000;
VAR82 = 43000000000000;
VAR83 = 119000000000000;
VAR80 = VAR82;
VAR84 = 100000;
VAR85 = 10000;
VAR86 = 2000;
VAR87 = 1250;
VAR88 = 625;
VAR89 = 312;
VAR90 = 156;
VAR91 = 117;
VAR92 = 104;
VAR93 = 100;
VAR94 = VAR81.FUN12(1000000000000);
VAR95 = VAR94.FUN12(2000000000000);
VAR96 = VAR95.FUN12(5000000000000);
VAR97 = VAR96.FUN12(5000000000000);
VAR98 = VAR97.FUN12(5000000000000);
VAR99 = VAR98.FUN12(5000000000000);
VAR100 = VAR99.FUN12(5000000000000);
VAR101 = VAR100.FUN12(5000000000000);
VAR102 = VAR101.FUN12(5000000000000);
VAR103 = VAR102.FUN12(5000000000000);
}
event FUN37(
address indexed VAR104,
address indexed VAR105,
uint256 value,
uint256 VAR106
);
event FUN38(address indexed VAR107, uint256 VAR106);
function () external payable {
FUN39(msg.sender);
}
function FUN39(address VAR108) public payable {
uint256 VAR109 = msg.value;
FUN40(VAR108, VAR109);
uint256 VAR110 = FUN41(VAR109);
VAR78 = VAR78.FUN12(VAR109);
FUN42(VAR108, VAR110);
FUN43();
emit FUN37(msg.sender, VAR108, VAR109, VAR110);
}
function FUN44() public view returns (bool) {
return VAR78 >= VAR74;
}
function FUN45() public view returns (bool) {
return VAR111.VAR112 > VAR75;
}
function FUN41(uint256 VAR113) internal returns (uint256) {
uint256 VAR114;
uint256 VAR115;
uint256 VAR116 = FUN46(VAR22);
uint256 VAR117 = FUN47(VAR113);
bool VAR118 = true;
while (VAR118) {
if (VAR117 > VAR116) {
VAR114 = VAR116;
uint256 VAR119 = VAR22.FUN12(VAR114);
VAR115 = VAR115.FUN12(VAR114);
uint256 VAR120 = VAR114.FUN10(VAR76);
uint256 VAR121 = VAR113.FUN11(VAR120);
VAR116 = FUN46(VAR119);
VAR117 = FUN47(VAR121);
} else {
VAR115 = VAR115.FUN12(VAR117);
VAR118 = false;
FUN48(VAR116, VAR117);
FUN49(VAR117);
}
}
return VAR115;
}
function FUN50(address VAR108, uint256 VAR122) internal {
VAR22 = VAR22.FUN12(VAR122);
VAR21[VAR108] = VAR21[VAR108].FUN12(VAR122);
}
function FUN43() internal {
VAR73.transfer(msg.value);
}
function FUN46(uint256 VAR123) internal returns (uint256) {
uint256 VAR124;
if (VAR123 < VAR98) {
if (VAR123 < VAR96) {
if (VAR123 < VAR94) {
FUN51(VAR84);
VAR124 = VAR94.FUN11(VAR123);
} else if (VAR123 < VAR95) {
FUN51(VAR85);
VAR124 = VAR95.FUN11(VAR123);
} else {
FUN51(VAR86);
VAR124 = VAR96.FUN11(VAR123);
}
} else {
if (VAR123 < VAR97) {
FUN51(VAR87);
VAR124 = VAR97.FUN11(VAR123);
} else {
FUN51(VAR88);
VAR124 = VAR98.FUN11(VAR123);
}
}
} else {
if (VAR123 < VAR101) {
if (VAR123 < VAR99) {
FUN51(VAR89);
VAR124 = VAR99.FUN11(VAR123);
} else if (VAR123 < VAR100) {
FUN51(VAR90);
VAR124 = VAR100.FUN11(VAR123);
} else {
FUN51(VAR91);
VAR124 = VAR101.FUN11(VAR123);
}
} else {
if (VAR123 < VAR102) {
FUN51(VAR92);
VAR124 = VAR102.FUN11(VAR123);
} else {
FUN51(VAR93);
VAR124 = VAR103.FUN11(VAR123);
}
}
}
return VAR124;
}
function FUN47(uint256 VAR125) internal view returns (uint256) {
return VAR125.FUN9(VAR76).FUN9(VAR68).FUN10(1 VAR126);
}
function FUN40(address VAR108, uint256 VAR125) internal view {
require(VAR108 != address(0));
require(VAR125 != 0);
require(VAR78.FUN12(VAR125) <= VAR74);
require(VAR111.VAR112 >= VAR77 && VAR111.VAR112 <= VAR75);
}
function FUN42(address VAR108, uint256 VAR122) internal {
FUN50(VAR108, VAR122);
}
function FUN48(uint256 VAR127, uint256 VAR128) internal {
VAR79 = VAR127.FUN11(VAR128);
}
function FUN49(uint256 VAR128) internal {
VAR80 = VAR82.FUN11(VAR128);
}
function FUN51(uint256 VAR129) internal {
VAR76 = VAR129;
}
function FUN52() public view returns (uint256) {
return VAR80;
}
function FUN53() public view returns (uint256) {
return VAR79;
}
function FUN54() public onlyOwner {
require(FUN45());
require(VAR80 > 0);
VAR21[VAR63] = VAR21[VAR63].FUN12(VAR80);
emit FUN38(VAR63, VAR80);
}
}
0
---------------------------------
467 0x040d5eded7a68608722aaa96a27523d8a36e8fb0.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29548800;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x85b748DD2E867e6B3e3F6FcEF41139e3515a5bE1;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
468 0x04113ddfe962271fe5d632ba3a3c3a89b2e92e7e.sol
pragma solidity 0.4.23;
contract VAR1 {
function FUN1(address VAR2) public view returns (uint256 VAR3);
function transfer(address VAR4, uint256 VAR5) public returns (bool VAR6);
}
contract VAR7 {
ERC20BasicInterface constant VAR8 = FUN2(0x8458d484572cEB89ce70EEBBe17Dc84707b241eD);
address constant VAR9 = 0x603F65F7Fc4f650c2F025800F882CFb62BF23580;
address constant VAR10 = 0x3135081dE9aEf677b3d7445e6C44Bb385cBD3E6a;
uint constant VAR11 = 1548547199;
function FUN3() public returns(bool) {
require(VAR12 > VAR11, '');
return VAR8.transfer(VAR10, VAR8.FUN1(address(this)));
}
function FUN4(ERC20BasicInterface VAR13, address VAR4, uint VAR5) public returns(bool) {
require(msg.sender == VAR9, '');
require(address(VAR13) != address(VAR8), '');
return VAR13.transfer(VAR4, VAR5);
}
}
0
---------------------------------
469 0x0411b4652f6087d02f633119043e6199841e37eb.sol
pragma solidity 0.4.18;
contract VAR1 {
uint256 public VAR2;
function FUN1(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 value) public returns (bool);
event Transfer(address indexed VAR5, address indexed VAR4, uint256 value);
}
library VAR6 {
function FUN2(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
uint256 VAR9 = VAR7 * VAR8;
assert(VAR7 == 0 || VAR9 / VAR7 == VAR8);
return VAR9;
}
function FUN3(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
uint256 VAR9 = VAR7 / VAR8;
return VAR9;
}
function FUN4(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
assert(VAR8 <= VAR7);
return VAR7 - VAR8;
}
function FUN5(uint256 VAR7, uint256 VAR8) internal pure returns (uint256) {
uint256 VAR9 = VAR7 + VAR8;
assert(VAR9 >= VAR7);
return VAR9;
}
}
contract BasicToken is VAR1 {
using SafeMath for uint256;
mapping(address => uint256) VAR10;
function transfer(address VAR11, uint256 VAR12) public returns (bool) {
require(VAR11 != address(0));
require(VAR12 <= VAR10[msg.sender]);
VAR10[msg.sender] = VAR10[msg.sender].FUN4(VAR12);
VAR10[VAR11] = VAR10[VAR11].FUN5(VAR12);
Transfer(msg.sender, VAR11, VAR12);
return true;
}
function FUN1(address VAR13) public view returns (uint256 VAR14) {
return VAR10[VAR13];
}
}
contract ERC20 is VAR1 {
function FUN6(address VAR15, address VAR16) public view returns (uint256);
function FUN7(address VAR5, address VAR4, uint256 value) public returns (bool);
function FUN8(address VAR16, uint256 value) public returns (bool);
event FUN9(address indexed VAR15, address indexed VAR16, uint256 value);
}
contract StandardToken is VAR17, VAR18 {
mapping(address => mapping (address => uint256)) internal VAR19;
function FUN7(address VAR20, address VAR11, uint256 VAR12) public returns (bool) {
require(VAR11 != address(0));
require(VAR12 <= VAR10[VAR20]);
require(VAR12 <= VAR19[VAR20][msg.sender]);
VAR10[VAR20] = VAR10[VAR20].FUN4(VAR12);
VAR10[VAR11] = VAR10[VAR11].FUN5(VAR12);
VAR19[VAR20][msg.sender] = VAR19[VAR20][msg.sender].FUN4(VAR12);
Transfer(VAR20, VAR11, VAR12);
return true;
}
function FUN8(address VAR21, uint256 VAR12) public returns (bool) {
VAR19[msg.sender][VAR21] = VAR12;
FUN9(msg.sender, VAR21, VAR12);
return true;
}
function FUN6(address VAR13, address VAR21) public view returns (uint256) {
return VAR19[VAR13][VAR21];
}
function FUN10(address VAR21, uint VAR22) public returns (bool) {
VAR19[msg.sender][VAR21] = VAR19[msg.sender][VAR21].FUN5(VAR22);
FUN9(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
function FUN11(address VAR21, uint VAR23) public returns (bool) {
uint VAR24 = VAR19[msg.sender][VAR21];
if (VAR23 > VAR24) {
VAR19[msg.sender][VAR21] = 0;
} else {
VAR19[msg.sender][VAR21] = VAR24.FUN4(VAR23);
}
FUN9(msg.sender, VAR21, VAR19[msg.sender][VAR21]);
return true;
}
}
contract KRWT is VAR25 {
string constant public VAR26 = "";
string constant public VAR27 = "";
uint8 constant public VAR28 = 18;
uint public VAR2 = 10000000000000 * 10**uint(VAR28);
function FUN12() public {
VAR10[msg.sender] = VAR2;
}
}
0
---------------------------------
470 0x04137682e59b5c44b3ec30a0d75233c64419567d.sol
pragma solidity 0.4.24;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
if (VAR2 == 0) {
return 0;
}
VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
return VAR2 / VAR3;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256 VAR4) {
VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
address public VAR6;
event FUN5(address indexed VAR7);
event FUN6(
address indexed VAR7,
address indexed VAR8
);
constructor() public {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR9;
}
function FUN7() public onlyOwner {
emit FUN5(VAR6);
VAR6 = address(0);
}
function FUN8(address VAR10) public onlyOwner {
FUN9(VAR10);
}
function FUN9(address VAR10) internal {
require(VAR10 != address(0));
emit FUN6(VAR6, VAR10);
VAR6 = VAR10;
}
}
contract VAR11 {
function FUN10() public view returns (uint256);
function FUN11(address VAR12) public view returns (uint256);
function transfer(address VAR13, uint256 value) public returns (bool);
event Transfer(address indexed VAR14, address indexed VAR13, uint256 value);
}
contract ERC20 is VAR11 {
function FUN12(address VAR6, address VAR15)
public view returns (uint256);
function FUN13(address VAR14, address VAR13, uint256 value)
public returns (bool);
function FUN14(address VAR15, uint256 value) public returns (bool);
event FUN15(
address indexed VAR6,
address indexed VAR15,
uint256 value
);
}
library VAR16 {
function FUN16(ERC20Basic VAR17, address VAR13, uint256 value) internal {
require(VAR17.transfer(VAR13, value));
}
function FUN17(
ERC20 VAR17,
address VAR14,
address VAR13,
uint256 value
)
internal
{
require(VAR17.FUN13(VAR14, VAR13, value));
}
function FUN18(ERC20 VAR17, address VAR15, uint256 value) internal {
require(VAR17.FUN14(VAR15, value));
}
}
contract VAR18 {
function FUN19(address VAR19, address VAR20)
external
view
returns (bool);
}
contract BasicToken is VAR11 {
using SafeMath for uint256;
mapping(address => uint256) VAR21;
uint256 VAR22;
function FUN10() public view returns (uint256) {
return VAR22;
}
function transfer(address VAR20, uint256 VAR23) public returns (bool) {
require(VAR20 != address(0));
require(VAR23 <= VAR21[msg.sender]);
VAR21[msg.sender] = VAR21[msg.sender].FUN3(VAR23);
VAR21[VAR20] = VAR21[VAR20].FUN4(VAR23);
emit Transfer(msg.sender, VAR20, VAR23);
return true;
}
function FUN11(address VAR24) public view returns (uint256) {
return VAR21[VAR24];
}
}
contract StandardToken is VAR25, VAR26 {
mapping (address => mapping (address => uint256)) internal VAR27;
function FUN13(
address VAR19,
address VAR20,
uint256 VAR23
)
public
returns (bool)
{
require(VAR20 != address(0));
require(VAR23 <= VAR21[VAR19]);
require(VAR23 <= VAR27[VAR19][msg.sender]);
VAR21[VAR19] = VAR21[VAR19].FUN3(VAR23);
VAR21[VAR20] = VAR21[VAR20].FUN4(VAR23);
VAR27[VAR19][msg.sender] = VAR27[VAR19][msg.sender].FUN3(VAR23);
emit Transfer(VAR19, VAR20, VAR23);
return true;
}
function FUN14(address VAR28, uint256 VAR23) public returns (bool) {
VAR27[msg.sender][VAR28] = VAR23;
emit FUN15(msg.sender, VAR28, VAR23);
return true;
}
function FUN12(
address VAR24,
address VAR28
)
public
view
returns (uint256)
{
return VAR27[VAR24][VAR28];
}
function FUN20(
address VAR28,
uint VAR29
)
public
returns (bool)
{
VAR27[msg.sender][VAR28] = (
VAR27[msg.sender][VAR28].FUN4(VAR29));
emit FUN15(msg.sender, VAR28, VAR27[msg.sender][VAR28]);
return true;
}
function FUN21(
address VAR28,
uint VAR30
)
public
returns (bool)
{
uint VAR31 = VAR27[msg.sender][VAR28];
if (VAR30 > VAR31) {
VAR27[msg.sender][VAR28] = 0;
} else {
VAR27[msg.sender][VAR28] = VAR31.FUN3(VAR30);
}
emit FUN15(msg.sender, VAR28, VAR27[msg.sender][VAR28]);
return true;
}
}
contract ControllableToken is VAR5, VAR32 {
TokenControllerI public VAR33;
modifier FUN22(address VAR19, address VAR20) {
require(VAR33.FUN19(VAR19, VAR20), "");
VAR9;
}
function FUN23(TokenControllerI VAR34) onlyOwner public {
require(VAR34 != address(0), "");
VAR33 = VAR34;
}
function transfer(address VAR20, uint256 VAR23)
FUN22(msg.sender, VAR20)
public
returns (bool)
{
return super.transfer(VAR20, VAR23);
}
function FUN13(address VAR19, address VAR20, uint256 VAR23)
FUN22(VAR19, VAR20)
public
returns (bool)
{
return super.FUN13(VAR19, VAR20, VAR23);
}
}
contract DetailedERC20 is VAR25 {
string public VAR35;
string public VAR36;
uint8 public VAR37;
constructor(string VAR38, string VAR39, uint8 VAR40) public {
VAR35 = VAR38;
VAR36 = VAR39;
VAR37 = VAR40;
}
}
contract Token is VAR41, VAR42 {
constructor(
uint256 VAR43,
string VAR38,
string VAR39,
uint8 VAR40
) FUN24(VAR38, VAR39, VAR40) public {
require(VAR43 != 0, "");
VAR22 = VAR43;
VAR21[msg.sender] = VAR43;
emit Transfer(address(0), msg.sender, VAR43);
}
}
0
---------------------------------
471 0x0417fa6f39b811cd6edbb73a58de0eba2688fd32.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 28080000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xAb74B5560498A8f749728c173050Eb95f56bAf5a;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
472 0x0419665e0a389b17ceb566e428bf0ede20d8ed40.sol
pragma solidity 0.4.24;
contract VAR1 {
function FUN1() constant returns (uint VAR2) {}
function FUN2(address VAR3) constant returns (uint VAR4) {}
function transfer(address VAR5, uint VAR6) returns (bool VAR7) {}
function FUN3(address VAR8, address VAR5, uint VAR6) returns (bool VAR7) {}
function FUN4(address VAR9, uint VAR6) returns (bool VAR7) {}
function FUN5(address VAR3, address VAR9) constant returns (uint VAR10) {}
event Transfer(address indexed VAR8, address indexed VAR5, uint VAR6);
event FUN6(address indexed VAR3, address indexed VAR9, uint VAR6);
}
contract RegularToken is VAR1 {
function transfer(address VAR5, uint VAR6) returns (bool) {
if (VAR11[msg.sender] >= VAR6 && VAR11[VAR5] + VAR6 >= VAR11[VAR5]) {
VAR11[msg.sender] -= VAR6;
VAR11[VAR5] += VAR6;
Transfer(msg.sender, VAR5, VAR6);
return true;
} else { return false; }
}
function FUN3(address VAR8, address VAR5, uint VAR6) returns (bool) {
if (VAR11[VAR8] >= VAR6 && VAR12[VAR8][msg.sender] >= VAR6 && VAR11[VAR5] + VAR6 >= VAR11[VAR5]) {
VAR11[VAR5] += VAR6;
VAR11[VAR8] -= VAR6;
VAR12[VAR8][msg.sender] -= VAR6;
Transfer(VAR8, VAR5, VAR6);
return true;
} else { return false; }
}
function FUN2(address VAR3) constant returns (uint) {
return VAR11[VAR3];
}
function FUN4(address VAR9, uint VAR6) returns (bool) {
VAR12[msg.sender][VAR9] = VAR6;
FUN6(msg.sender, VAR9, VAR6);
return true;
}
function FUN5(address VAR3, address VAR9) constant returns (uint) {
return VAR12[VAR3][VAR9];
}
mapping (address => uint) VAR11;
mapping (address => mapping (address => uint)) VAR12;
uint public VAR13;
}
contract UnboundedRegularToken is VAR14 {
uint constant VAR15 = 2**256 - 1;
function FUN3(address VAR8, address VAR5, uint VAR6)
public
returns (bool)
{
uint VAR16 = VAR12[VAR8][msg.sender];
if (VAR11[VAR8] >= VAR6
&& VAR16 >= VAR6
&& VAR11[VAR5] + VAR6 >= VAR11[VAR5]
) {
VAR11[VAR5] += VAR6;
VAR11[VAR8] -= VAR6;
if (VAR16 < VAR15) {
VAR12[VAR8][msg.sender] -= VAR6;
}
Transfer(VAR8, VAR5, VAR6);
return true;
} else {
return false;
}
}
}
contract  KingKongCoin is VAR17 {
uint public VAR13 = 1000000000000000000000000000;
uint8 constant public VAR18 = 18;
string constant public VAR19 = "";
string constant public VAR20 = "";
function FUN7() {
VAR11[msg.sender] = VAR13;
Transfer(address(0), msg.sender, VAR13);
}
}
0
---------------------------------
473 0x042266f5ae851aff4a8104f71cf8982be1fe539f.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 27129600;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xa5FCeBfb00f11DBb7A673C966158657B828b36D9;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
474 0x0427e00ed0cab57b7fbeab1d6213d3b8fe04f003.sol
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);
function FUN2() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN3(address VAR4) public onlyOwner {
require(VAR4 != address(0));
FUN1(VAR2, VAR4);
VAR2 = VAR4;
}
}
contract SAMPreSaleToken is VAR1 {
event FUN4(address indexed VAR6, uint256 value);
function () external payable {
VAR2.transfer(msg.value);
FUN4(msg.sender, msg.value);
}
}
0
---------------------------------
475 0x04299a0fc7e4f9ebe1a923948da581975198ff8d.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29462400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 =  0x5A18F9e13D398D2AAA8a7bcbd84214AFd36095c6;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
476 0x042a19059e082881a7ff28c3c9e7772b06423a62.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29894400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xAF26e7c012A4567d6dF8FBdCfaE555ABdd136A64;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
477 0x04390d3ce5c68d1dad9af7a84254225788e3d639.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1() external view returns (uint256);
function FUN2(address VAR3) external view returns (uint256);
function FUN3(address VAR4, address VAR5)
external view returns (uint256);
function transfer(address VAR6, uint256 value) external returns (bool);
function FUN4(address VAR5, uint256 value)
external returns (bool);
function FUN5(address VAR7, address VAR6, uint256 value)
external returns (bool);
event Transfer(
address indexed VAR7,
address indexed VAR6,
uint256 value
);
event FUN6(
address indexed VAR4,
address indexed VAR5,
uint256 value
);
}
library VAR8 {
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR11 = VAR9 * VAR10;
require(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 > 0);
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 <= VAR9);
uint256 VAR11 = VAR9 - VAR10;
return VAR11;
}
function FUN10(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
require(VAR11 >= VAR9);
return VAR11;
}
function FUN11(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 != 0);
return VAR9 % VAR10;
}
}
contract ERC20 is VAR2 {
using SafeMath for uint256;
mapping (address => uint256) private VAR12;
mapping (address => mapping (address => uint256)) private VAR13;
uint256 private VAR14;
function FUN1() public view returns (uint256) {
return VAR14;
}
function FUN2(address VAR4) public view returns (uint256) {
return VAR12[VAR4];
}
function FUN3(
address VAR4,
address VAR5
)
public
view
returns (uint256)
{
return VAR13[VAR4][VAR5];
}
function transfer(address VAR6, uint256 value) public returns (bool) {
require(value <= VAR12[msg.sender]);
require(VAR6 != address(0));
VAR12[msg.sender] = VAR12[msg.sender].FUN9(value);
VAR12[VAR6] = VAR12[VAR6].FUN10(value);
emit Transfer(msg.sender, VAR6, value);
return true;
}
function FUN4(address VAR5, uint256 value) public returns (bool) {
require(VAR5 != address(0));
VAR13[msg.sender][VAR5] = value;
emit FUN6(msg.sender, VAR5, value);
return true;
}
function FUN5(
address VAR7,
address VAR6,
uint256 value
)
public
returns (bool)
{
require(value <= VAR12[VAR7]);
require(value <= VAR13[VAR7][msg.sender]);
require(VAR6 != address(0));
VAR12[VAR7] = VAR12[VAR7].FUN9(value);
VAR12[VAR6] = VAR12[VAR6].FUN10(value);
VAR13[VAR7][msg.sender] = VAR13[VAR7][msg.sender].FUN9(value);
emit Transfer(VAR7, VAR6, value);
return true;
}
function FUN12(
address VAR5,
uint256 VAR15
)
public
returns (bool)
{
require(VAR5 != address(0));
VAR13[msg.sender][VAR5] = (
VAR13[msg.sender][VAR5].FUN10(VAR15));
emit FUN6(msg.sender, VAR5, VAR13[msg.sender][VAR5]);
return true;
}
function FUN13(
address VAR5,
uint256 VAR16
)
public
returns (bool)
{
require(VAR5 != address(0));
VAR13[msg.sender][VAR5] = (
VAR13[msg.sender][VAR5].FUN9(VAR16));
emit FUN6(msg.sender, VAR5, VAR13[msg.sender][VAR5]);
return true;
}
function FUN14(address VAR17, uint256 VAR18) internal {
require(VAR17 != 0);
VAR14 = VAR14.FUN10(VAR18);
VAR12[VAR17] = VAR12[VAR17].FUN10(VAR18);
emit Transfer(address(0), VAR17, VAR18);
}
function FUN15(address VAR17, uint256 VAR18) internal {
require(VAR17 != 0);
require(VAR18 <= VAR12[VAR17]);
VAR14 = VAR14.FUN9(VAR18);
VAR12[VAR17] = VAR12[VAR17].FUN9(VAR18);
emit Transfer(VAR17, address(0), VAR18);
}
function FUN16(address VAR17, uint256 VAR18) internal {
require(VAR18 <= VAR13[VAR17][msg.sender]);
VAR13[VAR17][msg.sender] = VAR13[VAR17][msg.sender].FUN9(
VAR18);
FUN15(VAR17, VAR18);
}
}
contract Girlfriend is VAR19 {
string public constant VAR20 = "";
string public constant VAR21 = "";
uint8 public constant VAR22 = 9;
uint256 public constant VAR23 = 8000000000 * (10 ** uint256(VAR22));
constructor() public {
FUN14(msg.sender, VAR23);
}
}
0
---------------------------------
478 0x04392398673e6247ba7b781029c4ab2aad9efc28.sol
pragma VAR1 ^0.4.7;
contract VAR2 {
uint public VAR3;
address VAR4;
address public VAR5;
address public VAR6;
address[] public VAR7;
address[] public VAR8;
address[] public VAR9;
address[] public VAR10;
uint public VAR11;
mapping(address=>bool) public VAR12;
mapping(address=>bool) public VAR13;
mapping(address=>uint) public VAR14;
mapping(address => bool) public VAR15;
uint public VAR16;
uint public VAR17;
uint128 public VAR18;
uint128 public VAR19;
uint16 public VAR20;
uint16 public VAR21;
uint16 public VAR22;
uint16[] public VAR23;
uint8 public VAR24;
event FUN1(uint VAR25, address[] VAR9, address[] VAR26);
function FUN2() payable{
VAR6 = 0x87b0de512502f3e86fd22654b72a640c8e0f59cc;
VAR20 = 1000;
VAR4 = msg.sender;
VAR16=1496251740;
VAR17=1499880540;
VAR18=2000000000000000;
VAR19=1000000000000000;
VAR21=200;
VAR22=0;
VAR23.FUN3(6045);
VAR24=1;
uint16 VAR27 = VAR21;
for(uint VAR28 = 0; VAR28 < VAR23.VAR29; VAR28++) {
VAR27 += VAR23[VAR28];
}
if(VAR27>10000)
throw;
else if(VAR27 < 10000 && VAR24 == 0)
throw;
}
function FUN4() payable {
if(msg.value < VAR18)
throw;
else if (VAR30 >= VAR16)
throw;
else if (VAR12[msg.sender])
throw;
else if (msg.sender!=VAR31.VAR32)
throw;
else {
VAR7.FUN3(msg.sender);
VAR12[msg.sender]=true;
if(VAR9.VAR29 < VAR23.VAR29) VAR9.FUN3(msg.sender);
}
}
function FUN5(address VAR33) payable{
if(msg.value < VAR19)
throw;
else if(VAR30 < VAR16 || VAR30 >=VAR17)
throw;
else if(VAR13[msg.sender])
throw;
else if (msg.sender!=VAR31.VAR32)
throw;
else if(!VAR12[VAR33])
throw;
else{
VAR8.FUN3(msg.sender);
VAR13[msg.sender] = true;
VAR14[VAR33]++;
for(var VAR28 = 0; VAR28 < VAR9.VAR29; VAR28++){
if(VAR9[VAR28]==VAR33) break;
if(VAR14[VAR33]>VAR14[VAR9[VAR28]]){
for(var VAR34 = FUN6(VAR33, VAR28+1); VAR34>VAR28; VAR34--){
VAR9[VAR34]=VAR9[VAR34-1];
}
VAR9[VAR28]=VAR33;
break;
}
}
}
}
function FUN6(address VAR33, uint VAR35) internal returns (uint){
for(uint VAR28 = VAR35; VAR28 < VAR9.VAR29; VAR28++){
if(VAR9[VAR28]==VAR33) return VAR28;
}
return VAR9.VAR29-1;
}
function FUN7(address VAR33){
if(msg.sender==VAR5)
VAR15[VAR33]=true;
}
function FUN8(address VAR33){
if(msg.sender==VAR5)
VAR15[VAR33]=false;
}
function FUN9(){
if(VAR30>=VAR17&&VAR11==0){
FUN10();
if(this.VAR36>10000) FUN11();
FUN1(VAR11, VAR9, VAR10);
}
}
function FUN10() constant {
if(VAR24>=VAR8.VAR29)
VAR10 = VAR8;
else{
mapping (uint => bool) VAR37;
uint VAR38=1;
uint VAR39;
for(uint VAR28 = 0; VAR28 < VAR24; VAR28++){
do{
VAR39 = FUN12(VAR38, VAR8.VAR29);
VAR38++;
}while (VAR37[VAR39]);
VAR37[VAR39] = true;
VAR10.FUN3(VAR8[VAR39]);
}
}
}
function FUN12(uint VAR38, uint VAR40) internal constant returns(uint){
return uint(VAR41.FUN13(VAR41.VAR42-VAR38))%VAR40;
}
function FUN11() internal{
if(!VAR6.FUN14(this.VAR36/10000*VAR20)) throw;
VAR11 = this.VAR36;
if(VAR21!=0 && !VAR4.FUN14(VAR11/10000*VAR21)) throw;
if(VAR22!=0 && !VAR5.FUN14(VAR11/10000*VAR22)) throw;
for (uint8 VAR28 = 0; VAR28 < VAR9.VAR29; VAR28++)
if(VAR23[VAR28]!=0 && !VAR9[VAR28].FUN14(VAR11/10000*VAR23[VAR28])) throw;
if (VAR10.VAR29>0){
if(this.VAR36>VAR10.VAR29){
uint VAR43 = this.VAR36/VAR10.VAR29;
for(uint8 VAR34 = 0; VAR34 < VAR10.VAR29; VAR34++)
if(!VAR10[VAR34].FUN14(VAR43)) throw;
}
}
else if(!VAR4.FUN14(this.VAR36)) throw;
}
function FUN15() constant returns(uint){
return VAR8.VAR29;
}
}
0
---------------------------------
479 0x043bef377cb396756d177fda57f1ff941959a0cd.sol
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 { function transfer(address VAR7, uint VAR8){  } }
contract VAR9 {
using SafeMath for uint256;
address public VAR10;
address public VAR11;
uint256 public VAR12 = 1400;
token VAR13;
uint256 public VAR14;
event FUN5(address indexed VAR15, address indexed VAR16, uint256 value, uint256 VAR8);
function FUN6() {
VAR10 = 0x6Dad2050A88fcf9f19c9EAC4F2AeC08c10192BE5;
VAR11 = 0xfDC73869bacdD683b204DAB42413C4fF77D745e9;
VAR13 = FUN7(VAR11);
}
bool public VAR17 = true;
function FUN8(){
if (msg.sender != VAR10) throw;
VAR17 = true;
}
function FUN9(){
if(msg.sender != VAR10) throw;
VAR17 = false;
}
function FUN10(uint256 VAR18){
if(msg.sender != VAR10) throw;
VAR12 = VAR18;
}
function FUN11(address VAR19){
if(msg.sender != VAR10) throw;
VAR10 = VAR19;
}
function FUN12(address VAR20){
if(msg.sender!=VAR10) throw;
VAR13 = FUN7(VAR20);
}
function () payable {
FUN13(msg.sender);
}
function FUN13(address VAR16) payable {
require(VAR16 != 0x0);
require(FUN14());
uint256 VAR21 = msg.value;
uint256 VAR22 = (VAR21) * VAR12;
VAR14 = VAR14.FUN4(VAR21);
VAR13.transfer(VAR16, VAR22);
FUN5(msg.sender, VAR16, VAR21, VAR22);
FUN15();
}
function FUN15() internal {
if (!VAR10.FUN16(msg.value)) {
throw;
}
}
function FUN14() internal constant returns (bool) {
bool VAR23 = VAR17;
bool VAR24 = msg.value != 0;
return VAR23 && VAR24;
}
function FUN17(uint256 VAR25) {
if(msg.sender!=VAR10) throw;
VAR13.transfer(VAR10,VAR25);
}
}
0
---------------------------------
480 0x044082d51bcc68378b63f8774fb6b5d936b529b7.sol
pragma solidity 0.5.4;
library VAR1 {
uint256 constant internal VAR2 = 2 ** 256 - 1;
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
if (VAR3 == 0) {
return 0;
}
require(VAR2 / VAR3 >= VAR4);
return VAR3 * VAR4;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
require(VAR4 != 0);
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
require(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
require(VAR2 - VAR3 >= VAR4);
return VAR3 + VAR4;
}
}
contract VAR5 {
address public VAR6;
event FUN5(address indexed VAR7, address indexed VAR8);
constructor () public {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR9;
}
function FUN6(address VAR8) public onlyOwner {
FUN7(VAR8);
}
function FUN7(address VAR8) internal {
require(VAR8 != address(0));
emit FUN5(VAR6, VAR8);
VAR6 = VAR8;
}
}
contract Pausable is VAR5 {
event FUN8();
event FUN9();
bool public VAR10 = false;
modifier FUN10() {
require(!VAR10);
VAR9;
}
modifier FUN11() {
require(VAR10);
VAR9;
}
function FUN12() public onlyOwner VAR11 {
VAR10 = true;
emit FUN8();
}
function FUN13() public onlyOwner VAR12 {
VAR10 = false;
emit FUN9();
}
}
contract VAR13 {
using SafeMath for uint256;
mapping(address => uint256) internal VAR14;
mapping(address => mapping(address => uint256)) internal VAR15;
uint256 public VAR16;
event Transfer(address indexed VAR17, address indexed VAR18, uint256 value);
event FUN14(address indexed VAR6, address indexed VAR19, uint256 value);
function FUN15(address VAR20) public view returns(uint256) {
return VAR14[VAR20];
}
function FUN16(address VAR20, address VAR21) public view returns(uint256) {
return VAR15[VAR20][VAR21];
}
function transfer(address VAR22, uint256 VAR23) public returns(bool) {
require(VAR22 != address(0));
require(VAR23 <= VAR14[msg.sender]);
VAR14[msg.sender] = VAR14[msg.sender].FUN3(VAR23);
VAR14[VAR22] = VAR14[VAR22].FUN4(VAR23);
emit Transfer(msg.sender, VAR22, VAR23);
return true;
}
function FUN17(address VAR21, uint256 VAR23) public returns(bool) {
VAR15[msg.sender][VAR21] = VAR23;
emit FUN14(msg.sender, VAR21, VAR23);
return true;
}
function FUN18(address VAR24, address VAR22, uint256 VAR23) public returns(bool) {
require(VAR22 != address(0));
require(VAR23 <= VAR14[VAR24]);
require(VAR23 <= VAR15[VAR24][msg.sender]);
VAR14[VAR24] = VAR14[VAR24].FUN3(VAR23);
VAR14[VAR22] = VAR14[VAR22].FUN4(VAR23);
VAR15[VAR24][msg.sender] = VAR15[VAR24][msg.sender].FUN3(VAR23);
emit Transfer(VAR24, VAR22, VAR23);
return true;
}
function FUN19(address VAR21, uint256 VAR25) public returns(bool) {
VAR15[msg.sender][VAR21] = VAR15[msg.sender][VAR21].FUN4(VAR25);
emit FUN14(msg.sender, VAR21, VAR15[msg.sender][VAR21]);
return true;
}
function FUN20(address VAR21, uint256 VAR26) public returns(bool) {
uint256 VAR27 = VAR15[msg.sender][VAR21];
if (VAR26 >= VAR27) {
VAR15[msg.sender][VAR21] = 0;
} else {
VAR15[msg.sender][VAR21] = VAR27.FUN3(VAR26);
}
emit FUN14(msg.sender, VAR21, VAR15[msg.sender][VAR21]);
return true;
}
function FUN21(address VAR28, uint256 value) internal {
require(VAR28 != address(0));
VAR16 = VAR16.FUN3(value);
VAR14[VAR28] = VAR14[VAR28].FUN3(value);
emit Transfer(VAR28, address(0), value);
}
function FUN22(address VAR28, uint256 value) internal {
VAR15[VAR28][msg.sender] = VAR15[VAR28][msg.sender].FUN3(value);
FUN21(VAR28, value);
}
}
contract BurnableToken is VAR13 {
function FUN23(uint256 value) public {
FUN21(msg.sender, value);
}
function FUN24(address VAR17, uint256 value) public {
FUN22(VAR17, value);
}
}
contract PausableToken is VAR13, VAR29 {
function transfer(address VAR18, uint256 value) public whenNotPaused returns (bool) {
return super.transfer(VAR18, value);
}
function FUN18(address VAR17, address VAR18, uint256 value) public whenNotPaused returns (bool) {
return super.FUN18(VAR17, VAR18, value);
}
function FUN17(address VAR19, uint256 value) public whenNotPaused returns (bool) {
return super.FUN17(VAR19, value);
}
function FUN19(address VAR19, uint256 VAR30) public whenNotPaused returns (bool VAR31) {
return super.FUN19(VAR19, VAR30);
}
function FUN20(address VAR19, uint256 VAR32) public whenNotPaused returns (bool VAR31) {
return super.FUN20(VAR19, VAR32);
}
}
contract Token is VAR33, VAR34 {
string public VAR35;
string public VAR36;
uint8 public VAR37;
constructor(string memory VAR38, string memory VAR39, uint8 VAR40, uint256 VAR41) public {
VAR16 = VAR41 * 10 ** uint256(VAR40);
VAR14[VAR6] = VAR16;
VAR35 = VAR38;
VAR36 = VAR39;
VAR37 = VAR40;
}
}
interface VAR42 {
function FUN25(address VAR24, uint256 VAR23, bytes calldata VAR43) external;
function transfer(address VAR22, uint256 VAR23) external returns (bool);
function FUN26() external returns (uint8);
}
contract IOAEX is VAR44 {
BDRContract public VAR45;
mapping(address => uint256) public VAR46;
mapping(address => uint256) public VAR47;
mapping(address => VAR48[]) public VAR49;
struct VAR48 {
uint256 VAR50;
uint256 VAR51;
}
event FUN27(address VAR52, uint256 VAR46);
event FUN28(address indexed VAR53, uint256 VAR51, uint256 VAR50);
event FUN29(address VAR17, uint256 value);
event FUN30(address VAR54);
modifier FUN31() {
require(msg.sender == address(VAR45));
VAR9;
}
constructor (string memory VAR38, string memory VAR39, uint8 VAR40, uint256 VAR41) FUN32 (VAR38, VAR39, VAR40, VAR41) public {
}
function FUN33(address VAR55) public onlyOwner {
require(VAR55 != address(0));
VAR45 = FUN34(VAR55);
emit FUN30(VAR55);
}
function FUN35(address VAR52, uint256[] memory VAR56, uint256[] memory VAR57) public onlyOwner returns(bool) {
require(VAR46[VAR52] == 0);
require(VAR52 != address(0));
require(VAR56.VAR58 == VAR57.VAR58);
VAR47[VAR52] = 0;
for (uint256 VAR59 = 0; VAR59 < VAR56.VAR58; VAR59++) {
VAR46[VAR52] = VAR46[VAR52].FUN4(VAR57[VAR59]);
require(VAR57[VAR59] > 0);
require(VAR56[VAR59] >= VAR60);
VAR49[VAR52].FUN36(FUN37(VAR56[VAR59], VAR57[VAR59]));
}
VAR14[VAR6] = VAR14[VAR6].FUN3(VAR46[VAR52]);
emit FUN27(VAR52, VAR46[VAR52]);
return true;
}
function FUN38() public returns (bool) {
FUN39(msg.sender);
}
function FUN39(address VAR61) internal {
require(VAR46[VAR61] > 0);
uint256 VAR62 = FUN40(VAR61);
VAR14[VAR61] = VAR14[VAR61].FUN4(VAR62);
VAR47[VAR61] = VAR47[VAR61].FUN4(VAR62);
if (VAR47[VAR61] == VAR46[VAR61]) {
delete VAR49[VAR61];
VAR46[VAR61] = 0;
}
emit FUN28(VAR61, VAR62, VAR60);
}
function FUN40(address VAR61) public view returns (uint256) {
if(VAR46[VAR61] == 0) {
return 0;
}
uint256 VAR63 = 0;
for (uint256 VAR59 = 0; VAR59 < VAR49[VAR61].VAR58; VAR59++) {
if (VAR60 >= VAR49[VAR61][VAR59].VAR50) {
VAR63 = VAR63.FUN4(VAR49[VAR61][VAR59].VAR51);
}
}
return VAR63.FUN3(VAR47[VAR61]);
}
function FUN41(address VAR61) public view returns(uint256) {
if (VAR46[VAR61] > VAR47[VAR61]) {
return VAR46[VAR61].FUN3(VAR47[VAR61]);
} else {
return 0;
}
}
function transfer(address VAR18, uint value) public returns (bool) {
if(FUN40(msg.sender) > 0) {
FUN39(msg.sender);
}
super.transfer(VAR18, value);
if(VAR18 == address(VAR45)) {
VAR45.FUN25(msg.sender, value, bytes(""));
emit FUN29(msg.sender, value);
}
return true;
}
function FUN18(address VAR17, address VAR18, uint value) public returns (bool) {
if(FUN40(VAR17) > 0) {
FUN39(VAR17);
}
super.FUN18(VAR17, VAR18, value);
if(VAR18 == address(VAR45)) {
VAR45.FUN25(VAR17, value, bytes(""));
emit FUN29(VAR17, value);
}
return true;
}
function FUN25(address VAR17, uint256 value, bytes VAR64) external VAR65 {
require(VAR17 != address(0));
require(value != uint256(0));
uint256 VAR66 = value.FUN1(10**uint256(VAR37)).FUN2(10**uint256(VAR45.FUN26()));
require(VAR66 <= VAR14[address(VAR45)]);
VAR14[address(VAR45)] = VAR14[address(VAR45)].FUN3(VAR66);
VAR14[VAR17] = VAR14[VAR17].FUN4(VAR66);
emit Transfer(VAR6, VAR17, VAR66);
}
}
0
---------------------------------
481 0x044dd17bbbcbf1cf65f543918561bf8cf8130e7b.sol
pragma solidity 0.4.18;
contract VAR1 {
address public VAR2;
function FUN1() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR3;
}
function FUN2(address VAR4) public onlyOwner {
VAR2 = VAR4;
}
}
contract VAR5 {
uint256 public VAR6;
function FUN3(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
function FUN4(address VAR12, address VAR9, uint256 VAR10) public returns (bool VAR11);
function FUN5(address VAR13, uint256 VAR10) public returns (bool VAR11);
function FUN6(address VAR7, address VAR13) public constant returns (uint256 VAR14);
event FUN7(address indexed VAR12, address indexed VAR9, uint256 VAR10);
event FUN8(address indexed VAR7, address indexed VAR13, uint256 VAR10);
}
contract EngravedToken is VAR5, VAR1 {
string public constant VAR15 = "";
string public constant VAR16 = "";
uint8 public constant VAR17 = 3;
bool public VAR18 = false;
uint256 public VAR19 = 0;
uint256 public VAR20 = 1;
uint256 public VAR21 = 4;
uint256 public VAR22 = 1 VAR23;
uint256 public VAR24 = 2;
struct VAR25 {
address VAR26;
uint8 VAR27;
}
VAR25[] public VAR28;
bool public VAR29;
mapping(address => uint256) internal VAR30;
mapping(address => mapping (address => uint256)) internal VAR31;
function FUN9() public {
VAR2 = msg.sender;
VAR30[VAR2] = 0;
VAR6 = 0;
VAR29 = true;
VAR28.FUN10(FUN11(0xCA73c8705cbc5942f42Ad39bC7EAeCA8228894BB, 5));
VAR28.FUN10(FUN11(0xd721f5c14a4AF2625AF1E1E107Cc148C8660BA72, 5));
}
function() public {
assert(false);
}
function FUN3(address VAR7) public constant returns (uint256 VAR8) {
return VAR30[VAR7];
}
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11) {
require(!VAR29);
require(VAR30[msg.sender] >= VAR10);
require(VAR10 > 0);
assert(VAR30[VAR9] + VAR10 > VAR30[VAR9]);
VAR30[msg.sender] -= VAR10;
VAR30[VAR9] += VAR10;
FUN7(msg.sender, VAR9, VAR10);
return true;
}
function FUN4 (
address VAR12,
address VAR9,
uint256 VAR10
) public returns (bool VAR11) {
require(!VAR29);
require(VAR30[VAR12] >= VAR10);
require(VAR31[VAR12][msg.sender] >= VAR10);
require(VAR10 > 0);
assert(VAR30[VAR9] + VAR10 > VAR30[VAR9]);
VAR30[VAR12] -= VAR10;
VAR31[VAR12][msg.sender] -= VAR10;
VAR30[VAR9] += VAR10;
FUN7(VAR12, VAR9, VAR10);
return true;
}
function FUN5(address VAR13, uint256 VAR10) public returns (bool VAR11) {
require(!VAR29);
VAR31[msg.sender][VAR13] = VAR10;
FUN8(msg.sender, VAR13, VAR10);
return true;
}
function FUN6(address VAR7, address VAR13) public constant returns (
uint256 VAR14
) {
return VAR31[VAR7][VAR13];
}
function FUN12() public onlyOwner returns (bool VAR11) {
if (!VAR18) {
VAR19 = VAR32;
VAR18 = true;
}
return VAR18;
}
function FUN13() public {
require(VAR18);
require(VAR20 < VAR21);
require(VAR32 > VAR19);
uint256 VAR33 = VAR6;
uint256 VAR34 = 1;
if (VAR20 > 1) {
VAR34 = VAR24**(VAR20 - 1);
}
for (uint256 VAR35 = 0; VAR35 < VAR28.VAR36; VAR35++) {
uint256 VAR37 = VAR33 * VAR28[VAR35].VAR27 / 10**2 / VAR34;
address VAR26 = VAR28[VAR35].VAR26;
VAR30[VAR26] += VAR37;
VAR6 += VAR37;
FUN7(0, this, VAR37);
FUN7(this, VAR26, VAR37);
}
VAR19 = VAR32 + VAR22;
VAR20++;
}
function FUN14() public onlyOwner returns (bool VAR11) {
VAR29 = false;
return true;
}
function FUN15(address VAR38, uint256 VAR10) public onlyOwner returns (bool VAR11) {
require(VAR10 >= 0);
VAR30[VAR38] += VAR10;
VAR6 += VAR10;
FUN7(0, VAR2, VAR10);
FUN7(VAR2, VAR38, VAR10);
return true;
}
}
0
---------------------------------
482 0x044ed85880c7df6c1491b140e46af893e0b30b77.sol
pragma solidity 0.5.4;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
require(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
require(VAR3 > 0);
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
require(VAR3 <= VAR2);
uint256 VAR4 = VAR2 - VAR3;
return VAR4;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
require(VAR4 >= VAR2);
return VAR4;
}
function FUN5(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
require(VAR3 != 0);
return VAR2 % VAR3;
}
}
interface VAR5 {
function transfer(address VAR6, uint256 value) external returns (bool);
function FUN6(address VAR7, uint256 value) external returns (bool);
function FUN7(address VAR8, address VAR6, uint256 value) external returns (bool);
function FUN8() external view returns (uint256);
function FUN9(address VAR9) external view returns (uint256);
function FUN10(address VAR10, address VAR7) external view returns (uint256);
event Transfer(address indexed VAR8, address indexed VAR6, uint256 value);
event FUN11(address indexed VAR10, address indexed VAR7, uint256 value);
}
library VAR11 {
using SafeMath for uint256;
using Address for address;
function FUN12(IERC20 VAR12, address VAR6, uint256 value) internal {
FUN13(VAR12, VAR13.FUN14(VAR12.transfer.VAR14, VAR6, value));
}
function FUN15(IERC20 VAR12, address VAR8, address VAR6, uint256 value) internal {
FUN13(VAR12, VAR13.FUN14(VAR12.VAR15.VAR14, VAR8, VAR6, value));
}
function FUN16(IERC20 VAR12, address VAR7, uint256 value) internal {
require((value == 0) || (VAR12.FUN10(address(this), VAR7) == 0));
FUN13(VAR12, VAR13.FUN14(VAR12.VAR16.VAR14, VAR7, value));
}
function FUN17(IERC20 VAR12, address VAR7, uint256 value) internal {
uint256 VAR17 = VAR12.FUN10(address(this), VAR7).FUN4(value);
FUN13(VAR12, VAR13.FUN14(VAR12.VAR16.VAR14, VAR7, VAR17));
}
function FUN18(IERC20 VAR12, address VAR7, uint256 value) internal {
uint256 VAR17 = VAR12.FUN10(address(this), VAR7).FUN3(value);
FUN13(VAR12, VAR13.FUN14(VAR12.VAR16.VAR14, VAR7, VAR17));
}
function FUN13(IERC20 VAR12, bytes memory VAR18) private {
require(address(VAR12).FUN19());
(bool VAR19, bytes memory VAR20) = address(VAR12).call(VAR18);
require(VAR19);
if (VAR20.VAR21 > 0) {
require(VAR13.FUN20(VAR20, (bool)));
}
}
}
library VAR22 {
function FUN19(address VAR23) internal view returns (bool) {
uint256 VAR24;
VAR25 { VAR24 := FUN21(VAR23) }
return VAR24 > 0;
}
}
contract VAR26 {
uint256 private VAR27;
constructor () internal {
VAR27 = 1;
}
modifier FUN22() {
VAR27 += 1;
uint256 VAR28 = VAR27;
VAR29;
require(VAR28 == VAR27);
}
}
contract VAR30 {
function FUN23(IERC20 VAR31, IERC20 VAR32, uint256 VAR33) public view returns (uint256 VAR34, uint256 VAR35);
function FUN24(IERC20 VAR31, uint256 VAR36, IERC20 VAR32, address VAR37, uint256 VAR38, uint256 VAR39, address VAR40) public payable returns(uint256);
}
contract VAR41 {
function FUN25() public view returns (address);
}
contract PaymentsLayer is VAR26 {
using SafeERC20 for VAR5;
using SafeMath for uint256;
address public constant VAR42 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
KyberNetworkProxyInterface public constant VAR43 = FUN26(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);
LandRegistryProxyInterface public constant VAR44 = FUN27(0xe72AD2A335AE18e6C7cdb6dAEB64b0330883CD56);
event FUN28(IERC20 indexed VAR31, uint256 VAR36, IERC20 indexed VAR32, address indexed VAR37, uint256 VAR45);
function FUN29(IERC20 VAR31, uint256 VAR36, IERC20 VAR32, address VAR37, uint256 VAR39, uint256 VAR46, bytes memory VAR47) public nonReentrant payable returns(uint256) {
if (address(VAR31) != VAR42) {
require(msg.value == 0);
VAR31.FUN15(msg.sender, address(this), VAR36);
VAR31.FUN16(address(VAR43), VAR36);
}
uint256 VAR45 = VAR43.VAR48.value((address(VAR31) == VAR42) ? VAR36 : 0)(VAR31, VAR36, VAR32, address(this), ~uint256(0), VAR39, VAR44.FUN25());
require(VAR45 >= VAR46);
if (address(VAR32) != VAR42)
VAR32.FUN16(VAR37, VAR45);
(bool VAR19, ) = VAR37.call.value((address(VAR32) == VAR42) ? VAR45 : 0)(VAR47);
require(VAR19, "");
uint256 VAR49 = (address(VAR32) == VAR42) ? address(this).VAR50 : VAR32.FUN10(address(this), VAR37);
(VAR49 > 0 && address(VAR32) == VAR42) ? msg.sender.transfer(VAR49) : VAR32.FUN12(msg.sender, VAR49);
emit FUN28(VAR31, VAR36, VAR32, VAR37, VAR45.FUN3(VAR49));
return VAR45.FUN3(VAR49);
}
}
0
---------------------------------
483 0x0452dd090288a5197cb4c375611b70bcfa5eb18c.sol
pragma VAR1 ^0.5.7;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns(uint256 VAR5) {
if (VAR3 == 0) {
return 0;
}
VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
return VAR3 / VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns(uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns(uint256 VAR5) {
VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address payable internal VAR7;
address payable internal VAR8;
address payable internal VAR9;
address payable internal VAR10;
modifier onlyOwner {
require(VAR7 == msg.sender);
VAR11;
}
function FUN5(address payable VAR12) onlyOwner public {
require(VAR12 != address(0));
VAR8 = VAR12;
}
function FUN6() public {
require(VAR8 == msg.sender);
VAR7 = VAR8;
delete VAR8;
}
}
contract VAR13 {
modifier FUN7(uint VAR14) {
require(msg.VAR15.VAR16 >= VAR14 + 4);
VAR11;
}
function FUN8() public view returns(uint256);
function FUN9(address VAR17) public view returns(uint256);
function transfer(address payable VAR18, uint256 value) public returns(bool);
event Transfer(address indexed VAR19, address indexed VAR18, uint256 value);
}
contract ERC20 is VAR13 {
function FUN10(address VAR7, address VAR20) public view returns(uint256);
function FUN11(address payable VAR19, address payable VAR18, uint256 value) public returns(bool);
function FUN12(address VAR20, uint256 value) public returns(bool);
event FUN13(address indexed VAR7, address indexed VAR20, uint256 value);
}
contract TokenBasic is VAR13, VAR6 {
using SafeMath for uint256;
mapping(address => uint256) internal VAR21;
uint256 internal VAR22;
uint256 internal VAR23;
mapping(uint256 => uint256) public VAR24;
mapping(address => uint256) public VAR25;
uint256 public VAR26;
function FUN8() public view returns(uint256) {
return VAR22;
}
function FUN14() public view returns(uint256) {
return VAR23;
}
function transfer(address payable VAR27, uint256 VAR28) public FUN7(2 * 32) returns(bool) {
require(VAR27 != address(0));
require(VAR28 <= VAR21[msg.sender]);
require(VAR27 != VAR9);
uint256 VAR29 = 0;
uint256 VAR30 = 0;
if (msg.sender != VAR9) {
if (VAR25[msg.sender] < VAR26) {
for (uint256 VAR31 = VAR26; VAR31 >= VAR25[msg.sender]; VAR31 = VAR31.FUN3(1)) {
VAR29 = VAR29.FUN4(VAR24[VAR31].FUN1(VAR21[msg.sender]));
}
}
}
if (VAR25[VAR27] < VAR26 && VAR21[VAR27] > 0) {
for (uint256 VAR31 = VAR26; VAR31 >= VAR25[VAR27]; VAR31 = VAR31.FUN3(1)) {
VAR30 = VAR30.FUN4(VAR24[VAR31].FUN1(VAR21[VAR27]));
}
}
VAR21[msg.sender] = VAR21[msg.sender].FUN3(VAR28);
VAR21[VAR27] = VAR21[VAR27].FUN4(VAR28);
VAR25[VAR27] = VAR26;
emit Transfer(msg.sender, VAR27, VAR28);
if (msg.sender == VAR9) {
VAR23 = VAR23.FUN4(VAR28);
} else {
VAR25[msg.sender] = VAR26;
if (VAR29 > 0) {
msg.sender.transfer(VAR29);
}
}
if (VAR30 > 0) {
VAR27.transfer(VAR30);
}
return true;
}
function FUN9(address VAR12) public view returns(uint256) {
return VAR21[VAR12];
}
}
contract TokenStandard is VAR32, VAR33 {
mapping(address => mapping(address => uint256)) internal VAR34;
function FUN11(address payable VAR35, address payable VAR27, uint256 VAR28) public FUN7(3 * 32) returns(bool) {
require(VAR27 != address(0));
require(VAR27 != VAR9);
require(VAR28 <= VAR21[VAR35]);
require(VAR28 <= VAR34[VAR35][msg.sender]);
uint256 VAR29 = 0;
uint256 VAR30 = 0;
if (VAR35 != VAR9) {
if (VAR25[VAR35] < VAR26) {
for (uint256 VAR31 = VAR26; VAR31 >= VAR25[VAR35]; VAR31 = VAR31.FUN3(1)) {
VAR29 = VAR29.FUN4(VAR24[VAR31].FUN1(VAR21[VAR35]));
}
}
}
if (VAR25[VAR27] < VAR26 && VAR21[VAR27] > 0) {
for (uint256 VAR31 = VAR26; VAR31 >= VAR25[VAR27]; VAR31 = VAR31.FUN3(1)) {
VAR30 = VAR30.FUN4(VAR24[VAR31].FUN1(VAR21[VAR27]));
}
}
VAR21[VAR35] = VAR21[VAR35].FUN3(VAR28);
VAR21[VAR27] = VAR21[VAR27].FUN4(VAR28);
VAR34[VAR35][msg.sender] = VAR34[VAR35][msg.sender].FUN3(VAR28);
VAR25[VAR27] = VAR26;
emit Transfer(VAR35, VAR27, VAR28);
if (VAR35 == VAR9) {
VAR23 = VAR23.FUN4(VAR28);
} else {
VAR25[VAR35] = VAR26;
if (VAR29 > 0) {
VAR35.transfer(VAR29);
}
}
if (VAR30 > 0) {
VAR27.transfer(VAR30);
}
return true;
}
function FUN12(address VAR36, uint256 VAR28) public returns(bool) {
VAR34[msg.sender][VAR36] = VAR28;
emit FUN13(msg.sender, VAR36, VAR28);
return true;
}
function FUN10(address VAR12, address VAR36) public view returns(uint256) {
return VAR34[VAR12][VAR36];
}
function FUN15(address VAR36, uint VAR37) public returns(bool) {
VAR34[msg.sender][VAR36] = VAR34[msg.sender][VAR36].FUN4(VAR37);
emit FUN13(msg.sender, VAR36, VAR34[msg.sender][VAR36]);
return true;
}
function FUN16(address VAR36, uint VAR38) public returns(bool) {
uint VAR39 = VAR34[msg.sender][VAR36];
if (VAR38 > VAR39) {
VAR34[msg.sender][VAR36] = 0;
} else {
VAR34[msg.sender][VAR36] = VAR39.FUN3(VAR38);
}
emit FUN13(msg.sender, VAR36, VAR34[msg.sender][VAR36]);
return true;
}
}
contract ANASH is VAR40 {
string public constant VAR41 = "";
string public constant VAR42 = "";
uint8 public constant VAR43 = 2;
uint256 internal constant VAR44 = 20000000000;
function() payable external {
if (VAR10 == msg.sender) {
require(msg.value >= 1);
VAR24[VAR26] = msg.value.FUN2(VAR23);
VAR26 = VAR26.FUN4(1);
} else {
require(VAR21[msg.sender] > 0);
uint256 VAR29 = 0;
uint256 VAR45 = 0;
if (VAR25[msg.sender] < VAR26) {
for (uint256 VAR31 = VAR26; VAR31 >= VAR25[msg.sender]; VAR31 = VAR31.FUN3(1)) {
VAR29 = VAR29.FUN4(VAR24[VAR31].FUN1(VAR21[msg.sender]));
VAR45 = VAR45.FUN4(1);
if(VAR45 > 80){break;}
}
}
VAR25[msg.sender] = VAR26;
VAR29 = VAR29.FUN4(msg.value);
if (VAR29 > 0) {
msg.sender.transfer(VAR29);
}
}
}
constructor() public {
VAR26 = 1;
VAR7 = msg.sender;
VAR9 = 0xfB538A7365d47183692E1866fC0b32308F15BAFD;
VAR10 = 0xCebaa747868135CC4a0d9A4f982849161f3a4CE7;
VAR22 = VAR44;
VAR23 = 0;
VAR21[VAR9] = VAR21[VAR9].FUN4(VAR44);
emit Transfer(address(0), VAR9, VAR44);
}
}
0
---------------------------------
484 0x045833c3adc11914cef17cba2b6f2523db4c0b23.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30240000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xDF849cC7cfD51db1d532650586676950Fba23043;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
485 0x047055f35cb837e838dde0202b7b1a5a75757835.sol
pragma solidity 0.4.11;
contract VAR1 {
function FUN1() constant returns (uint256 VAR2);
function FUN2(address VAR3) constant returns (uint256 VAR4);
function transfer(address VAR5, uint256 VAR6) returns (bool VAR7);
function FUN3(address VAR8, address VAR5, uint256 VAR6) returns (bool VAR7);
function FUN4(address VAR9, uint256 VAR6) returns (bool VAR7);
function FUN5(address VAR3, address VAR9) constant returns (uint256 VAR10);
event Transfer(address indexed VAR8, address indexed VAR5, uint256 VAR6);
event FUN6(address indexed VAR3, address indexed VAR9, uint256 VAR6);
}
contract ETHPToken is VAR1 {
string public constant VAR11 = "";
string public constant VAR12 = "";
uint8 public constant VAR13 = 18;
uint256 VAR14 = 10000000000000000000000000;
address public VAR15;
mapping(address => uint256) VAR16;
mapping(address => mapping (address => uint256)) VAR17;
modifier onlyOwner() {
if (msg.sender != VAR15) {
throw;
}
VAR18;
}
function FUN7() {
VAR15 = msg.sender;
VAR16[VAR15] = VAR14;
}
function FUN1() constant returns (uint256 VAR2) {
VAR2 = VAR14;
}
function FUN2(address VAR3) constant returns (uint256 VAR4) {
return VAR16[VAR3];
}
function transfer(address VAR5, uint256 VAR19) returns (bool VAR7) {
if (VAR16[msg.sender] >= VAR19
&& VAR19 > 0
&& VAR16[VAR5] + VAR19 > VAR16[VAR5]) {
VAR16[msg.sender] -= VAR19;
VAR16[VAR5] += VAR19;
Transfer(msg.sender, VAR5, VAR19);
return true;
} else {
return false;
}
}
function FUN3(
address VAR8,
address VAR5,
uint256 VAR19
) returns (bool VAR7) {
if (VAR16[VAR8] >= VAR19
&& VAR17[VAR8][msg.sender] >= VAR19
&& VAR19 > 0
&& VAR16[VAR5] + VAR19 > VAR16[VAR5]) {
VAR16[VAR8] -= VAR19;
VAR17[VAR8][msg.sender] -= VAR19;
VAR16[VAR5] += VAR19;
Transfer(VAR8, VAR5, VAR19);
return true;
} else {
return false;
}
}
function FUN4(address VAR9, uint256 VAR19) returns (bool VAR7) {
VAR17[msg.sender][VAR9] = VAR19;
FUN6(msg.sender, VAR9, VAR19);
return true;
}
function FUN5(address VAR3, address VAR9) constant returns (uint256 VAR10) {
return VAR17[VAR3][VAR9];
}
}
0
---------------------------------
486 0x0470a7a47823ae3390b4acc885850aaba6ac8264.sol
pragma VAR1 ^0.4.25;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
interface VAR6 {
function FUN6() external view returns (uint256);
function FUN7(address VAR7) external view returns (uint256);
function FUN8(address VAR8, address VAR9)
external view returns (uint256);
function transfer(address VAR10, uint256 value) external returns (bool);
function FUN9(address VAR9, uint256 value)
external returns (bool);
function FUN10(address VAR11, address VAR10, uint256 value)
external returns (bool);
event Transfer(
address indexed VAR11,
address indexed VAR10,
uint256 value
);
event FUN11(
address indexed VAR8,
address indexed VAR9,
uint256 value
);
}
contract ERC20 is VAR6 {
using SafeMath for uint256;
mapping (address => uint256) public VAR12;
mapping (address => mapping (address => uint256)) private VAR13;
uint256 public VAR14;
bool public VAR15 = true;
function FUN6() public view returns (uint256) {
return VAR14;
}
function FUN7(address VAR8) public view returns (uint256) {
return VAR12[VAR8];
}
function FUN8(
address VAR8,
address VAR9
)
public
view
returns (uint256)
{
return VAR13[VAR8][VAR9];
}
function transfer(address VAR10, uint256 value) public returns (bool) {
require(VAR15);
FUN12(msg.sender, VAR10, value);
return true;
}
function FUN9(address VAR9, uint256 value) public returns (bool) {
require(VAR9 != address(0));
VAR13[msg.sender][VAR9] = value;
emit FUN11(msg.sender, VAR9, value);
return true;
}
function FUN10(
address VAR11,
address VAR10,
uint256 value
)
public
returns (bool)
{
require(value <= VAR13[VAR11][msg.sender]);
require(VAR15);
VAR13[VAR11][msg.sender] = VAR13[VAR11][msg.sender].FUN3(value);
FUN12(VAR11, VAR10, value);
return true;
}
function FUN13(
address VAR9,
uint256 VAR16
)
public
returns (bool)
{
require(VAR9 != address(0));
VAR13[msg.sender][VAR9] = (
VAR13[msg.sender][VAR9].FUN4(VAR16));
emit FUN11(msg.sender, VAR9, VAR13[msg.sender][VAR9]);
return true;
}
function FUN14(
address VAR9,
uint256 VAR17
)
public
returns (bool)
{
require(VAR9 != address(0));
VAR13[msg.sender][VAR9] = (
VAR13[msg.sender][VAR9].FUN3(VAR17));
emit FUN11(msg.sender, VAR9, VAR13[msg.sender][VAR9]);
return true;
}
function FUN12(address VAR11, address VAR10, uint256 value) internal {
require(value <= VAR12[VAR11]);
require(VAR10 != address(0));
VAR12[VAR11] = VAR12[VAR11].FUN3(value);
VAR12[VAR10] = VAR12[VAR10].FUN4(value);
emit Transfer(VAR11, VAR10, value);
}
function FUN15(address VAR18, uint256 value) internal {
require(VAR18 != 0);
VAR14 = VAR14.FUN4(value);
VAR12[VAR18] = VAR12[VAR18].FUN4(value);
emit Transfer(address(0), VAR18, value);
}
function FUN16(address VAR18, uint256 value) internal {
require(VAR18 != 0);
require(value <= VAR12[VAR18]);
VAR14 = VAR14.FUN3(value);
VAR12[VAR18] = VAR12[VAR18].FUN3(value);
emit Transfer(VAR18, address(0), value);
}
function FUN17(address VAR18, uint256 value) internal {
require(value <= VAR13[VAR18][msg.sender]);
VAR13[VAR18][msg.sender] = VAR13[VAR18][msg.sender].FUN3(
value);
FUN16(VAR18, value);
}
}
contract NeoTechCoin is VAR19 {
string constant public VAR20 = "";
uint256 constant public VAR21 = 18;
string constant public VAR22 = "";
mapping (address => bool) public VAR23;
bool public VAR24 = true;
modifier onlyOwner() {
require(FUN18());
VAR25;
}
function FUN18() public view returns(bool) {
return VAR23[msg.sender];
}
constructor() public {
VAR23[0xA861C900ea07ED2f6d1a0edE8D441Dd4fCd299f0] = true;
VAR23[0xEcaa382A186453E30c7E4944180F9Fa23AC9d6e7] = true;
VAR23[0xbb85107DA47E6965a7b7eBd7538B2295539E8f63] = true;
VAR23[msg.sender] = true;
VAR14 = uint(1000000000).FUN1(uint(10) ** VAR21);
VAR12[address(this)] = VAR14;
}
function FUN19(address VAR10, uint256 value) external onlyOwner {
require(value <= VAR12[address(this)]);
require(VAR10 != address(0));
VAR12[address(this)] = VAR12[address(this)].FUN3(value);
VAR12[VAR10] = VAR12[VAR10].FUN4(value);
emit Transfer(address(this), VAR10, value);
}
function FUN20(address[] VAR10, uint256[] value) external onlyOwner {
uint VAR26 = 0;
for (uint VAR27 = 0; VAR27 < VAR10.VAR28; VAR27++) {
VAR26 = VAR26.FUN4(value[VAR27]);
require(VAR26 <= VAR12[address(this)]);
VAR12[address(this)] = VAR12[address(this)].FUN3(value[VAR27]);
VAR12[VAR10[VAR27]] = VAR12[VAR10[VAR27]].FUN4(value[VAR27]);
emit Transfer(address(this), VAR10[VAR27], value[VAR27]);
}
}
function FUN21(bool VAR29) external onlyOwner {
require(VAR24);
VAR15 = VAR29;
}
function FUN22() external onlyOwner {
VAR15 = true;
VAR24 = false;
}
function FUN23(address VAR30, bool VAR29) external onlyOwner {
VAR23[VAR30] = VAR29;
}
}
0
---------------------------------
487 0x0476f88678696f8e1dc653c1732a88b6c5ec9d8a.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29894400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x9DB6E8ae32E1f06ebEe4D7713F64D890716f4864;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
488 0x04773124b09d0e3a7a01706f26e1f45810645f6b.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29635200;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 =  0x4E3f71A03239A52Eaf0De4be934dbCFDa6Bf5593;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
489 0x047ebd5f7431c005c9d3a59ce0675ac998417e9d.sol
pragma VAR1 >=0.4.24 <0.6.0;
contract VAR2 {
address private VAR3;
event FUN1(
address indexed VAR4,
address indexed VAR5
);
constructor() internal {
VAR3 = msg.sender;
emit FUN1(address(0), VAR3);
}
function FUN2() public view returns(address) {
return VAR3;
}
modifier onlyOwner() {
require(FUN3());
VAR6;
}
function FUN3() public view returns(bool) {
return msg.sender == VAR3;
}
function FUN4() public onlyOwner {
emit FUN1(VAR3, address(0));
VAR3 = address(0);
}
function FUN5(address VAR5) public onlyOwner {
FUN6(VAR5);
}
function FUN6(address VAR5) internal {
require(VAR5 != address(0));
emit FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract VAR7 {
function () payable external {
FUN7();
}
function FUN8() internal view returns (address);
function FUN9(address VAR8) internal {
VAR9 {
FUN10(0, 0, VAR10)
let VAR11 := FUN11(VAR12, VAR8, 0, VAR10, 0, 0)
FUN12(0, 0, VAR13)
switch VAR11
case 0 { revert(0, VAR13) }
default { return(0, VAR13) }
}
}
function FUN13() internal {
}
function FUN7() internal {
FUN13();
FUN9(FUN8());
}
}
library VAR14 {
function FUN14(address VAR15) internal view returns (bool) {
uint256 VAR16;
VAR9 { VAR16 := FUN15(VAR15) }
return VAR16 > 0;
}
}
contract UpgradeabilityProxy is VAR7 {
event FUN16(address indexed VAR8);
bytes32 private constant VAR17 = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;
constructor(address VAR18, bytes memory VAR19) public payable {
assert(VAR17 == FUN17(""));
FUN18(VAR18);
if(VAR19.VAR20 > 0) {
(bool VAR21,) = VAR18.FUN11(VAR19);
require(VAR21);
}
}
function FUN8() internal view returns (address VAR22) {
bytes32 VAR23 = VAR17;
VAR9 {
VAR22 := FUN19(VAR23)
}
}
function FUN20(address VAR24) internal {
FUN18(VAR24);
emit FUN16(VAR24);
}
function FUN18(address VAR24) private {
require(VAR14.FUN14(VAR24), "");
bytes32 VAR23 = VAR17;
VAR9 {
FUN21(VAR23, VAR24)
}
}
}
contract AdminUpgradeabilityProxy is VAR25 {
event FUN22(address VAR26, address VAR27);
bytes32 private constant VAR28 = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;
modifier FUN23() {
if (msg.sender == FUN24()) {
VAR6;
} else {
FUN7();
}
}
constructor(address VAR18, address VAR29, bytes memory VAR19) FUN25(VAR18, VAR19) public payable {
require(
address(this) == address(0x9DCe896DdC20BA883600176678cbEe2B8BA188A9),
""
);
assert(VAR28 == FUN17(""));
FUN26(VAR29);
}
function FUN27() external ifAdmin returns (address) {
return FUN24();
}
function FUN28() external ifAdmin returns (address) {
return FUN8();
}
function FUN29(address VAR27) external VAR30 {
require(VAR27 != address(0), "");
emit FUN22(FUN24(), VAR27);
FUN26(VAR27);
}
function FUN30(address VAR24) external VAR30 {
FUN20(VAR24);
}
function FUN31(address VAR24, bytes calldata VAR31) payable external VAR30 {
FUN20(VAR24);
(bool VAR21,) = VAR24.FUN11(VAR31);
require(VAR21);
}
function FUN24() internal view returns (address VAR32) {
bytes32 VAR23 = VAR28;
VAR9 {
VAR32 := FUN19(VAR23)
}
}
function FUN26(address VAR27) internal {
bytes32 VAR23 = VAR28;
VAR9 {
FUN21(VAR23, VAR27)
}
}
function FUN13() internal {
require(msg.sender != FUN24(), "");
super.FUN13();
}
}
contract ProxyAdmin is VAR2 {
constructor() public FUN32() {
require(
address(this) == address(0x047EbD5F7431c005c9D3a59CE0675ac998417e9d),
""
);
}
function FUN33(AdminUpgradeabilityProxy VAR33) public returns (address) {
return VAR33.FUN28();
}
function FUN34(AdminUpgradeabilityProxy VAR33) public returns (address) {
return VAR33.FUN27();
}
function FUN35(AdminUpgradeabilityProxy VAR33, address VAR27) public onlyOwner {
VAR33.FUN29(VAR27);
}
function FUN36(AdminUpgradeabilityProxy VAR33, address VAR8) public onlyOwner {
VAR33.FUN30(VAR8);
}
function FUN37(AdminUpgradeabilityProxy VAR33, address VAR8, bytes memory VAR31) payable public onlyOwner {
VAR33.VAR34.value(msg.value)(VAR8, VAR31);
}
}
0
---------------------------------
490 0x048694443ce5587f76d7233d0e475b14000a3f5c.sol
pragma VAR1 ^0.5.7;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) public view returns (uint256);
function transfer(address VAR5, uint256 value) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7 {
mapping (address => uint256) VAR8;
ERC20Basic VAR9 = FUN2(0xBC7942054F77b82e8A71aCE170E4B00ebAe67eB6);
uint constant VAR10 = 1556668800;
address VAR11;
constructor () public {
VAR11 = msg.sender;
VAR8[0x86970B23b8008B0E35F20fACdf4962D3A899F256] = 1000000 VAR12;
VAR8[0x403E732e419eccb3626Dc2130beec825E1023990] = 1000000 VAR12;
VAR8[0xc9CC83Ec6309e93FC72E305d24BDF34c93cA0C59] = 1000000 VAR12;
VAR8[0xa96aC207db973B12f352eC3886E1b118ad81DC57] = 1000000 VAR12;
VAR8[0xcC11EA5095E93AD5600573e31cB4F72923ECdDE3] = 1000000 VAR12;
VAR8[0xe7eC8124e15306c06AA2C1Da052e8169E697aBd2] = 100000 VAR12;
VAR8[0x4a0F4c7D631D34033f289dd33463937fbc401BeE] = 200000 VAR12;
VAR8[0xe46af6b7d32dcd9D82A0Ae123e3d9b7744f6C1C4] = 50000 VAR12;
VAR8[0xf6Df849c19BAeeCd4F85Ba528ca7772Bdc202C4e] = 100000 VAR12;
VAR8[0x34ee4A2124E8eeA848FB9ece82FCf8909138AD4d] = 100000 VAR12;
VAR8[0xAc05bde6291ba1bFb2b7F4d8DbcEb553051fd360] = 20000 VAR12;
VAR8[0xff44a930f51Ce4Ff459f52DF5Edb9becAD065f7C] = 200000 VAR12;
VAR8[0x81599e1560CaaB74443e5F5fb5Bb501cd9724b49] = 200000 VAR12;
VAR8[0xbfe92111a720bD37352Db5811a4F75647291e620] = 250000 VAR12;
VAR8[0xeB0A24d8Fa86A4d04BA97cB436D1Bb527A82B51e] = 100000 VAR12;
VAR8[0x109745E787B1dE54eBD576Adf9D9d4B70f88617B] = 100000 VAR12;
VAR8[0xC09375659859d66F625a07CB27A2919Ed6C84240] = 100000 VAR12;
VAR8[0xBb41A7Eac242e1314952555DFc7d732963275248] = 100000 VAR12;
VAR8[0x8e5eC5F5632e73A9A54105f9676f14Cbfe1e5Cc7] = 100000 VAR12;
VAR8[0x28D8AE88c0376aCca9b4779c9aF77a0D60eB0b10] = 20000 VAR12;
VAR8[0x3d918626c5075E4D63952297b97157BAb60a15F9] = 100000 VAR12;
VAR8[0xE223BDa5278a0cb09Bc154F93b85EB0C2742F369] = 200000 VAR12;
VAR8[0x60EDEA24c5815BBEf72CAC728f96a21D41Ea4214] = 100000 VAR12;
VAR8[0x28FA1C07464b8DEe70fA37627a38aCEF3630e27F] = 80000 VAR12;
VAR8[0xB0e9a0F2f4Fd171ecb23e07429B41cf52F995b82] = 100000 VAR12;
VAR8[0x1651F2d6a6a62C4aA02a766491AdAC587C2A2D9A] = 300000 VAR12;
VAR8[0x927d41d0c7A0029eDd0D6D55aacfb932FDAC8FbD] = 100000 VAR12;
VAR8[0xF22B4481eB9a224fA97dfD2fEbA1e06531A61433] = 100000 VAR12;
VAR8[0xa4e2EaFad3399FF285Dd4Fd8B4139d3cc6D30438] = 100000 VAR12;
VAR8[0xfe9220DDdaDd1065CAc7249730ee613C63f2e187] = 100000 VAR12;
VAR8[0xba93A0De5Db0E98F66e9E1C8253D4dd9557b3895] = 50000 VAR12;
VAR8[0x23da4c7Ad3B04396b0e0b6F870dDFA025153E097] = 20000 VAR12;
VAR8[0xc388657E3Edcb143D8B0FA922384D1b87bDcb0DC] = 30000 VAR12;
VAR8[0x50907432E86bc2FfDBEF238e9Df7c48A01d88dd8] = 30000 VAR12;
VAR8[0x357898808506B884Ab48b3E3f6d383560e69fc8e] = 50000 VAR12;
VAR8[0x79E9947FfF564d491d980BaB866Ca9F0980178D8] = 10000 VAR12;
VAR8[0xFD1E7E1525a32F11AaBA21f6fE1F05e4DE2cEB27] = 50000 VAR12;
VAR8[0x26B77a0c4e6B0F529f4Ea31752c23f05dd388697] = 100000 VAR12;
VAR8[0x3caA984A70F128c3B2b262861B805644A2ed6Bc0] = 100000 VAR12;
VAR8[0x11C6F9ccf49EBE938Dae82AE6c50a64eB5778dCC] = 30000 VAR12;
VAR8[0xb1A46c484BD58D984270BA710BEb2feF0A965aDc] = 50000 VAR12;
}
function() payable external {
require (msg.value == 0);
uint256 VAR13 = VAR8[msg.sender];
VAR8[msg.sender] = 0;
if (!VAR9.transfer(msg.sender, VAR13)) {
revert();
}
}
function FUN3() external {
require (VAR14 >= VAR10);
require (msg.sender == VAR11);
uint256 VAR15 = VAR9.FUN1(address(this));
if (!VAR9.transfer(VAR11, VAR15)) {
revert();
}
}
}
0
---------------------------------
491 0x048fe0f263b8c3cef3f3e6b0e4f1b8cba55453cd.sol
pragma VAR1 ^0.4.19;
interface VAR2
{
function FUN1(address VAR3) public payable;
}
interface VAR4
{
function FUN2(address VAR5) public view returns (uint256);
function transfer(address VAR6, uint256 value) public returns (bool);
}
contract VAR7
{
address public VAR8 = 0xC4C6328405F00Fa4a93715D2349f76DF0c7E8b79;
function FUN3(address VAR9, uint8 VAR10) external
{
for(uint8 VAR11 = 0; VAR11 < VAR10; ++VAR11)
{
FUN4(VAR9).FUN1(this);
}
}
function FUN5(address VAR12) external
{
FUN6(VAR12).transfer(VAR8, FUN6(VAR12).FUN2(this));
}
}
0
---------------------------------
492 0x048fe49be32adfc9ed68c37d32b5ec9df17b3603.sol
pragma VAR1 ^0.5.0;
interface VAR2 {
function FUN1() external view returns (uint256);
function FUN2(address VAR3) external view returns (uint256);
function transfer(address VAR4, uint256 VAR5) external returns (bool);
function FUN3(address VAR6, address VAR7) external view returns (uint256);
function FUN4(address VAR7, uint256 VAR5) external returns (bool);
function FUN5(address sender, address VAR4, uint256 VAR5) external returns (bool);
event Transfer(address indexed VAR8, address indexed VAR9, uint256 value);
event FUN6(address indexed VAR6, address indexed VAR7, uint256 value);
}
library VAR10 {
function FUN7(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 + VAR12;
require(VAR13 >= VAR11, "");
return VAR13;
}
function FUN8(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 <= VAR11, "");
uint256 VAR13 = VAR11 - VAR12;
return VAR13;
}
function FUN9(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
if (VAR11 == 0) {
return 0;
}
uint256 VAR13 = VAR11 * VAR12;
require(VAR13 / VAR11 == VAR12, "");
return VAR13;
}
function FUN10(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 > 0, "");
uint256 VAR13 = VAR11 / VAR12;
return VAR13;
}
function FUN11(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 != 0, "");
return VAR11 % VAR12;
}
}
contract ERC20 is VAR2 {
using SafeMath for uint256;
mapping (address => uint256) private VAR14;
mapping (address => mapping (address => uint256)) private VAR15;
uint256 private VAR16;
function FUN1() public view returns (uint256) {
return VAR16;
}
function FUN2(address VAR3) public view returns (uint256) {
return VAR14[VAR3];
}
function transfer(address VAR4, uint256 VAR5) public returns (bool) {
FUN12(msg.sender, VAR4, VAR5);
return true;
}
function FUN3(address VAR6, address VAR7) public view returns (uint256) {
return VAR15[VAR6][VAR7];
}
function FUN4(address VAR7, uint256 value) public returns (bool) {
FUN13(msg.sender, VAR7, value);
return true;
}
function FUN5(address sender, address VAR4, uint256 VAR5) public returns (bool) {
FUN12(sender, VAR4, VAR5);
FUN13(sender, msg.sender, VAR15[sender][msg.sender].FUN8(VAR5));
return true;
}
function FUN14(address VAR7, uint256 VAR17) public returns (bool) {
FUN13(msg.sender, VAR7, VAR15[msg.sender][VAR7].FUN7(VAR17));
return true;
}
function FUN15(address VAR7, uint256 VAR18) public returns (bool) {
FUN13(msg.sender, VAR7, VAR15[msg.sender][VAR7].FUN8(VAR18));
return true;
}
function FUN12(address sender, address VAR4, uint256 VAR5) internal {
require(sender != address(0), "");
require(VAR4 != address(0), "");
VAR14[sender] = VAR14[sender].FUN8(VAR5);
VAR14[VAR4] = VAR14[VAR4].FUN7(VAR5);
emit Transfer(sender, VAR4, VAR5);
}
function FUN16(address VAR3, uint256 VAR5) internal {
require(VAR3 != address(0), "");
VAR16 = VAR16.FUN7(VAR5);
VAR14[VAR3] = VAR14[VAR3].FUN7(VAR5);
emit Transfer(address(0), VAR3, VAR5);
}
function FUN17(address VAR3, uint256 value) internal {
require(VAR3 != address(0), "");
VAR16 = VAR16.FUN8(value);
VAR14[VAR3] = VAR14[VAR3].FUN8(value);
emit Transfer(VAR3, address(0), value);
}
function FUN13(address VAR6, address VAR7, uint256 value) internal {
require(VAR6 != address(0), "");
require(VAR7 != address(0), "");
VAR15[VAR6][VAR7] = value;
emit FUN6(VAR6, VAR7, value);
}
function FUN18(address VAR3, uint256 VAR5) internal {
FUN17(VAR3, VAR5);
FUN13(VAR3, msg.sender, VAR15[VAR3][msg.sender].FUN8(VAR5));
}
}
contract ERC20Detailed is VAR2 {
string private VAR19;
string private VAR20;
uint8 private VAR21;
constructor (string memory VAR22, string memory VAR23, uint8 VAR24) public {
VAR19 = VAR22;
VAR20 = VAR23;
VAR21 = VAR24;
}
function FUN19() public view returns (string VAR25) {
return VAR19;
}
function FUN20() public view returns (string VAR25) {
return VAR20;
}
function FUN21() public view returns (uint8) {
return VAR21;
}
}
library VAR26 {
struct VAR27 {
mapping (address => bool) VAR28;
}
function FUN7(Role storage VAR29, address VAR3) internal {
require(!FUN22(VAR29, VAR3), "");
VAR29.VAR28[VAR3] = true;
}
function FUN23(Role storage VAR29, address VAR3) internal {
require(FUN22(VAR29, VAR3), "");
VAR29.VAR28[VAR3] = false;
}
function FUN22(Role storage VAR29, address VAR3) internal view returns (bool) {
require(VAR3 != address(0), "");
return VAR29.VAR28[VAR3];
}
}
contract VAR30 {
using Roles for VAR26.VAR27;
event FUN24(address indexed VAR3);
event FUN25(address indexed VAR3);
VAR26.Role private VAR31;
constructor () internal {
FUN26(msg.sender);
}
modifier FUN27() {
require(FUN28(msg.sender), "");
VAR32;
}
function FUN28(address VAR3) public view returns (bool) {
return VAR31.FUN22(VAR3);
}
function FUN29(address VAR3) public VAR33 {
FUN26(VAR3);
}
function FUN30() public {
FUN31(msg.sender);
}
function FUN26(address VAR3) internal {
VAR31.FUN7(VAR3);
emit FUN24(VAR3);
}
function FUN31(address VAR3) internal {
VAR31.FUN23(VAR3);
emit FUN25(VAR3);
}
}
contract Pausable is VAR30 {
event FUN32(address VAR3);
event FUN33(address VAR3);
bool private VAR34;
constructor () internal {
VAR34 = false;
}
function FUN34() public view returns (bool) {
return VAR34;
}
modifier FUN35() {
require(!VAR34, "");
VAR32;
}
modifier FUN36() {
require(VAR34, "");
VAR32;
}
function FUN37() public onlyPauser VAR35 {
VAR34 = true;
emit FUN32(msg.sender);
}
function FUN38() public onlyPauser VAR36 {
VAR34 = false;
emit FUN33(msg.sender);
}
}
contract ERC20Pausable is VAR37, VAR38 {
function transfer(address VAR9, uint256 value) public whenNotPaused returns (bool) {
return super.transfer(VAR9, value);
}
function FUN5(address VAR8, address VAR9, uint256 value) public whenNotPaused returns (bool) {
return super.FUN5(VAR8, VAR9, value);
}
function FUN4(address VAR7, uint256 value) public whenNotPaused returns (bool) {
return super.FUN4(VAR7, value);
}
function FUN14(address VAR7, uint VAR17) public whenNotPaused returns (bool) {
return super.FUN14(VAR7, VAR17);
}
function FUN15(address VAR7, uint VAR18) public whenNotPaused returns (bool) {
return super.FUN15(VAR7, VAR18);
}
}
contract VAR39 {
using Roles for VAR26.VAR27;
event FUN39(address indexed VAR3);
event FUN40(address indexed VAR3);
VAR26.Role private VAR40;
constructor () internal {
FUN41(msg.sender);
}
modifier FUN42() {
require(FUN43(msg.sender), "");
VAR32;
}
function FUN43(address VAR3) public view returns (bool) {
return VAR40.FUN22(VAR3);
}
function FUN44(address VAR3) public VAR41 {
FUN41(VAR3);
}
function FUN45() public {
FUN46(msg.sender);
}
function FUN41(address VAR3) internal {
VAR40.FUN7(VAR3);
emit FUN39(VAR3);
}
function FUN46(address VAR3) internal {
VAR40.FUN23(VAR3);
emit FUN40(VAR3);
}
}
contract ERC20Mintable is VAR37, VAR39 {
function FUN47(address VAR3, uint256 VAR5) public onlyMinter returns (bool) {
FUN16(VAR3, VAR5);
return true;
}
}
contract ERC20Capped is VAR42 {
uint256 private VAR43;
constructor (uint256 VAR44) public {
require(VAR44 > 0, "");
VAR43 = VAR44;
}
function FUN48() public view returns (uint256) {
return VAR43;
}
function FUN16(address VAR3, uint256 value) internal {
require(FUN1().FUN7(value) <= VAR43, "");
super.FUN16(VAR3, value);
}
}
contract ERC20Burnable is VAR37, VAR39 {
function FUN49(uint256 VAR5) public VAR41 {
FUN17(msg.sender, VAR5);
}
function FUN50(address VAR3, uint256 VAR5) public  VAR41 {
FUN18(VAR3, VAR5);
}
}
contract SkrumbleToken is VAR45, VAR46, VAR47, VAR48 {
string  private constant  VAR49     = "";
string  private constant VAR50   = "";
uint private constant VAR51 = 1500000000;
uint8 private constant VAR52 = 18;
uint256 public constant VAR53 = VAR51 * (10 ** uint256(VAR52));
constructor()  public
FUN51(VAR49,VAR50,VAR52)
FUN52(VAR53)
{
FUN16(msg.sender, VAR53);
}
}
0
---------------------------------
493 0x04a28b7b45db608cc9dcc2dd247ede17164849f8.sol
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 { function transfer(address VAR7, uint VAR8){  } }
contract VAR9 {
using SafeMath for uint256;
address public VAR10;
address public VAR11;
uint256 public VAR12 = 10000;
token VAR13;
uint256 public VAR14;
event FUN5(address indexed VAR15, address indexed VAR16, uint256 value, uint256 VAR8);
function FUN6() {
VAR10 = 0xCEFACEc39Ddc6A4ffAe43879764b13151Dd84D70;
VAR11 = 0xacF2e688E1Ff85479bD045E35d0A545630137c91;
VAR13 = FUN7(VAR11);
}
bool public VAR17 = true;
function FUN8(){
if (msg.sender != VAR10) throw;
VAR17 = true;
}
function FUN9(){
if(msg.sender != VAR10) throw;
VAR17 = false;
}
function FUN10(uint256 VAR18){
if(msg.sender != VAR10) throw;
VAR12 = VAR18;
}
function FUN11(address VAR19){
if(msg.sender != VAR10) throw;
VAR10 = VAR19;
}
function FUN12(address VAR20){
if(msg.sender!=VAR10) throw;
VAR13 = FUN7(VAR20);
}
function () payable {
FUN13(msg.sender);
}
function FUN13(address VAR16) payable {
require(VAR16 != 0x0);
require(FUN14());
uint256 VAR21 = msg.value;
uint256 VAR22 = (VAR21) * VAR12;
VAR14 = VAR14.FUN4(VAR21);
VAR13.transfer(VAR16, VAR22);
FUN5(msg.sender, VAR16, VAR21, VAR22);
FUN15();
}
function FUN15() internal {
if (!VAR10.FUN16(msg.value)) {
throw;
}
}
function FUN14() internal constant returns (bool) {
bool VAR23 = VAR17;
bool VAR24 = msg.value != 0;
return VAR23 && VAR24;
}
function FUN17(uint256 VAR25) {
if(msg.sender!=VAR10) throw;
VAR13.transfer(VAR10,VAR25);
}
}
0
---------------------------------
494 0x04a487afd662c4f9deacc07a7b10cfb686b682a4.sol
pragma solidity 0.4.18;
interface VAR1 {
function FUN1() public view returns (uint VAR2);
function FUN2(address VAR3) public view returns (uint VAR4);
function transfer(address VAR5, uint VAR6) public returns (bool VAR7);
function FUN3(address VAR8, address VAR5, uint VAR6) public returns (bool VAR7);
function FUN4(address VAR9, uint VAR6) public returns (bool VAR7);
function FUN5(address VAR3, address VAR9) public view returns (uint VAR10);
function FUN6() public view returns(uint VAR11);
event FUN7(address indexed VAR3, address indexed VAR9, uint VAR6);
}
contract VAR12 {
ERC20 constant internal VAR13 = FUN8(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);
uint  constant internal VAR14 = (10**18);
uint  constant internal VAR15   = (10**28);
uint  constant internal VAR16  = (VAR14 * 10**6);
uint  constant internal VAR17 = 18;
uint  constant internal VAR18 = 18;
mapping(address=>uint) internal VAR19;
function FUN9(ERC20 VAR20) internal {
if (VAR20 == VAR13) VAR19[VAR20] = VAR18;
else VAR19[VAR20] = VAR20.FUN6();
}
function FUN10(ERC20 VAR20) internal view returns(uint) {
if (VAR20 == VAR13) return VAR18;
uint VAR21 = VAR19[VAR20];
if(VAR21 == 0) return VAR20.FUN6();
return VAR21;
}
function FUN11(uint VAR22, uint VAR23, uint VAR24, uint VAR25) internal pure returns(uint) {
require(VAR22 <= VAR15);
require(VAR25 <= VAR16);
if (VAR24 >= VAR23) {
require((VAR24 - VAR23) <= VAR17);
return (VAR22 * VAR25 * (10**(VAR24 - VAR23))) / VAR14;
} else {
require((VAR23 - VAR24) <= VAR17);
return (VAR22 * VAR25) / (VAR14 * (10**(VAR23 - VAR24)));
}
}
function FUN12(uint VAR26, uint VAR23, uint VAR24, uint VAR25) internal pure returns(uint) {
require(VAR26 <= VAR15);
require(VAR25 <= VAR16);
uint VAR27;
uint VAR28;
if (VAR23 >= VAR24) {
require((VAR23 - VAR24) <= VAR17);
VAR27 = (VAR14 * VAR26 * (10**(VAR23 - VAR24)));
VAR28 = VAR25;
} else {
require((VAR24 - VAR23) <= VAR17);
VAR27 = (VAR14 * VAR26);
VAR28 = (VAR25 * (10**(VAR24 - VAR23)));
}
return (VAR27 + VAR28 - 1) / VAR28;
}
}
contract Utils2 is VAR12 {
function FUN13(ERC20 VAR20, address VAR29) public view returns(uint) {
if (VAR20 == VAR13)
return VAR29.VAR4;
else
return VAR20.FUN2(VAR29);
}
function FUN14(ERC20 VAR20) internal returns(uint) {
if (VAR19[VAR20] == 0) {
FUN9(VAR20);
}
return VAR19[VAR20];
}
function FUN15(ERC20 VAR30, ERC20 VAR31, uint VAR32, uint VAR25) internal view returns(uint) {
return FUN11(VAR32, FUN10(VAR30), FUN10(VAR31), VAR25);
}
function FUN16(ERC20 VAR30, ERC20 VAR31, uint VAR33, uint VAR25) internal view returns(uint) {
return FUN12(VAR33, FUN10(VAR30), FUN10(VAR31), VAR25);
}
function FUN17(uint VAR32, uint VAR33, uint VAR23, uint VAR24)
internal pure returns(uint)
{
require(VAR32 <= VAR15);
require(VAR33 <= VAR15);
if (VAR24 >= VAR23) {
require((VAR24 - VAR23) <= VAR17);
return (VAR33 * VAR14 / ((10 ** (VAR24 - VAR23)) * VAR32));
} else {
require((VAR23 - VAR24) <= VAR17);
return (VAR33 * VAR14 * (10 ** (VAR23 - VAR24)) / VAR32);
}
}
}
contract VAR34 {
address public VAR35;
address public VAR36;
mapping(address=>bool) internal VAR37;
mapping(address=>bool) internal VAR38;
address[] internal VAR39;
address[] internal VAR40;
uint constant internal VAR41 = 50;
function FUN18() public {
VAR35 = msg.sender;
}
modifier onlyAdmin() {
require(msg.sender == VAR35);
VAR42;
}
modifier FUN19() {
require(VAR37[msg.sender]);
VAR42;
}
modifier FUN20() {
require(VAR38[msg.sender]);
VAR42;
}
function FUN21 () external view returns(address[]) {
return VAR39;
}
function FUN22 () external view returns(address[]) {
return VAR40;
}
event FUN23(address VAR36);
function FUN24(address VAR43) public onlyAdmin {
require(VAR43 != address(0));
FUN23(VAR36);
VAR36 = VAR43;
}
function FUN25(address VAR43) public onlyAdmin {
require(VAR43 != address(0));
FUN23(VAR43);
FUN26(VAR43, VAR35);
VAR35 = VAR43;
}
event FUN26( address VAR43, address VAR44);
function FUN27() public {
require(VAR36 == msg.sender);
FUN26(VAR36, VAR35);
VAR35 = VAR36;
VAR36 = address(0);
}
event FUN28 (address VAR45, bool VAR46);
function FUN29(address VAR45) public onlyAdmin {
require(!VAR38[VAR45]);
require(VAR40.VAR47 < VAR41);
FUN28(VAR45, true);
VAR38[VAR45] = true;
VAR40.FUN30(VAR45);
}
function FUN31 (address VAR48) public onlyAdmin {
require(VAR38[VAR48]);
VAR38[VAR48] = false;
for (uint VAR49 = 0; VAR49 < VAR40.VAR47; ++VAR49) {
if (VAR40[VAR49] == VAR48) {
VAR40[VAR49] = VAR40[VAR40.VAR47 - 1];
VAR40.VAR47--;
FUN28(VAR48, false);
break;
}
}
}
event FUN32(address VAR50, bool VAR46);
function FUN33(address VAR50) public onlyAdmin {
require(!VAR37[VAR50]);
require(VAR39.VAR47 < VAR41);
FUN32(VAR50, true);
VAR37[VAR50] = true;
VAR39.FUN30(VAR50);
}
function FUN34 (address VAR51) public onlyAdmin {
require(VAR37[VAR51]);
VAR37[VAR51] = false;
for (uint VAR49 = 0; VAR49 < VAR39.VAR47; ++VAR49) {
if (VAR39[VAR49] == VAR51) {
VAR39[VAR49] = VAR39[VAR39.VAR47 - 1];
VAR39.VAR47 -= 1;
FUN32(VAR51, false);
break;
}
}
}
}
contract Withdrawable is VAR34 {
event FUN35(ERC20 VAR20, uint VAR52, address VAR53);
function FUN36(ERC20 VAR20, uint VAR52, address VAR53) external onlyAdmin {
require(VAR20.transfer(VAR53, VAR52));
FUN35(VAR20, VAR52, VAR53);
}
event FUN37(uint VAR52, address VAR53);
function FUN38(uint VAR52, address VAR53) external onlyAdmin {
VAR53.transfer(VAR52);
FUN37(VAR52, VAR53);
}
}
interface VAR54 {
function FUN39(
ERC20 VAR55,
uint VAR32,
ERC20 VAR56,
address VAR57,
uint VAR58,
bool VAR59
)
public
payable
returns(bool);
function FUN40(ERC20 VAR30, ERC20 VAR31, uint VAR22, uint VAR60) public view returns(uint);
}
contract VAR61 {
function FUN41(uint VAR62) public constant returns (uint, VAR1, uint, VAR1);
function FUN42(ERC20 VAR63, ERC20 VAR64) public constant returns(uint);
function FUN43(uint VAR62) public constant returns(uint);
function FUN44(bytes32 VAR62, uint128 VAR65) public;
}
contract WethInterface is VAR1 {
function FUN45() public payable;
function FUN46(uint) public;
}
contract KyberOasisReserve is VAR54, VAR66, VAR67 {
uint constant internal VAR68 = 18;
address public VAR69 = 0;
address public VAR70;
OtcInterface public VAR71;
WethInterface public VAR72;
mapping(address=>bool) public VAR73;
mapping(address=>uint) public VAR74;
mapping(address=>uint) public VAR75;
mapping(address=>uint) public VAR76;
mapping(address=>uint) public VAR77;
mapping(address=>uint) public VAR78;
bool public VAR79;
uint public VAR80;
function FUN47(
address VAR81,
OtcInterface VAR82,
WethInterface VAR83,
address VAR84,
uint VAR85
)
public
{
require(VAR84 != address(0));
require(VAR81 != address(0));
require(VAR82 != address(0));
require(VAR83 != address(0));
require(VAR85 < 10000);
require(FUN10(VAR83) == VAR68);
VAR70 = VAR81;
VAR71 = VAR82;
VAR72 = VAR83;
VAR35 = VAR84;
VAR80 = VAR85;
VAR79 = true;
require(VAR72.FUN4(VAR71, 2**255));
}
function() public payable {
}
function FUN48(ERC20 VAR20, uint VAR86) public onlyAdmin {
require(VAR20 != address(0));
require(!VAR73[VAR20]);
require(FUN10(VAR20) == VAR68);
require(VAR20.FUN4(VAR71, 2**255));
VAR73[VAR20] = true;
VAR74[VAR20] = VAR86;
VAR75[VAR20] = 2 ** 255;
VAR76[VAR20] = 0;
VAR77[VAR20] = 0;
VAR78[VAR20] = 0;
}
function FUN49(ERC20 VAR20) public onlyAdmin {
require(VAR73[VAR20]);
require(VAR20.FUN4(VAR71, 0));
delete VAR73[VAR20];
delete VAR74[VAR20];
delete VAR75[VAR20];
delete VAR76[VAR20];
delete VAR77[VAR20];
delete VAR78[VAR20];
}
function FUN50(ERC20 VAR20,
uint VAR87,
uint VAR88) public onlyAdmin {
require(VAR73[VAR20]);
require(VAR88 <= 500);
require(VAR87 <= 1000);
VAR77[VAR20] = VAR88;
VAR78[VAR20] = VAR87;
}
function FUN51(ERC20 VAR20,
uint  VAR89,
uint  VAR90) public VAR91 {
require(VAR73[VAR20]);
VAR75[VAR20] = VAR89;
VAR76[VAR20] = VAR90;
}
event FUN52(
address indexed sender,
address VAR30,
uint VAR32,
address VAR56,
uint VAR33,
address VAR57
);
function FUN39(
ERC20 VAR55,
uint VAR32,
ERC20 VAR56,
address VAR57,
uint VAR58,
bool VAR59
)
public
payable
returns(bool)
{
require(VAR79);
require(msg.sender == VAR70);
require(FUN53(VAR55, VAR32, VAR56, VAR57, VAR58, VAR59));
return true;
}
event FUN54(bool VAR92);
function FUN55() public onlyAdmin returns(bool) {
VAR79 = true;
FUN54(true);
return true;
}
function FUN56() public VAR93 returns(bool) {
VAR79 = false;
FUN54(false);
return true;
}
event FUN57(address VAR70);
function FUN58(address VAR81) public onlyAdmin {
require(VAR81 != address(0));
VAR70 = VAR81;
FUN57(VAR70);
}
event FUN59(uint VAR80);
function FUN60(uint VAR85) public onlyAdmin {
require(VAR85 < 10000);
VAR80 = VAR85;
FUN59(VAR80);
}
function FUN61(uint VAR94) public view returns(uint) {
require(VAR94 <= VAR15);
return ((10000 - VAR80) * VAR94) / 10000;
}
function FUN62(uint VAR94) public view returns(uint) {
require(VAR94 <= VAR15);
return VAR94 * 10000 / (10000 - VAR80);
}
function FUN63(ERC20 VAR20, uint VAR94) public view returns(uint) {
require(VAR94 <= VAR15);
uint VAR95 = VAR77[VAR20];
return VAR94 * (10000 + VAR95) / 10000;
}
function FUN64(ERC20 VAR20,
uint VAR96,
uint VAR97,
bool VAR98) public view returns(bool) {
require(VAR96 <= VAR15);
uint VAR99 = VAR20.FUN2(this);
if (VAR98) {
if (VAR99 < VAR96) return false;
if (VAR99 - VAR96 < VAR75[VAR20]) return false;
}
else {
if (this.VAR4 < VAR97) return false;
if (VAR99 + VAR96 > VAR76[VAR20]) return false;
}
uint VAR100; uint VAR101; uint VAR102; uint VAR103;
(,VAR100,VAR101) = FUN65(VAR20, VAR72, 0);
(,VAR103,VAR102) = FUN65(VAR72, VAR20, 0);
require(VAR100 <= VAR15 && VAR102 <= VAR15 && VAR101 <= VAR15 && VAR103 <= VAR15);
if (VAR100*VAR103 > VAR102*VAR101) return false;
if (10000 * (VAR102*VAR101 - VAR100*VAR103) < VAR100*VAR103*VAR78[VAR20]) return false;
return true;
}
function FUN40(ERC20 VAR30, ERC20 VAR31, uint VAR22, uint VAR60) public view returns(uint) {
uint  VAR25;
uint  VAR104;
ERC20 VAR105;
ERC20 VAR106;
uint VAR107;
uint VAR108;
VAR60;
if (!VAR79) return 0;
if (!FUN66(VAR30, VAR31)) return 0;
if (VAR30 == VAR13) {
VAR105 = VAR72;
VAR106 = VAR31;
VAR104 = VAR22;
} else if (VAR31 == VAR13) {
VAR105 = VAR30;
VAR106 = VAR72;
if (VAR22 < VAR74[VAR30]) {
VAR104 = VAR74[VAR30];
} else {
VAR104 = VAR22;
}
} else {
return 0;
}
(, VAR107, VAR108) = FUN65(VAR106, VAR105, VAR104);
if (VAR104 > VAR108) return 0;
bool VAR109 = false;
uint VAR110 = FUN63(VAR20, VAR107);
ERC20 VAR20;
if (VAR30 == VAR13) {
VAR20 = VAR31;
VAR109 = FUN64(VAR20,
VAR110,
VAR108,
true);
}
else {
VAR20 = VAR30;
VAR109 = FUN64(VAR20,
VAR108,
VAR110,
false);
}
VAR25 = FUN17(VAR108, VAR107, VAR68, VAR68);
if (VAR109) return FUN63(VAR20,VAR25);
else return FUN61(VAR25);
}
function FUN53(
ERC20 VAR55,
uint VAR32,
ERC20 VAR56,
address VAR57,
uint VAR58,
bool VAR59
)
internal
returns(bool)
{
uint VAR111;
require(FUN66(VAR55, VAR56));
if (VAR59) {
require(VAR58 > 0);
if (VAR55 == VAR13)
require(msg.value == VAR32);
else
require(msg.value == 0);
}
uint VAR112 = FUN11(VAR32, VAR68, VAR68, VAR58);
require(VAR112 > 0);
uint VAR113 = FUN62(VAR112);
if (VAR55 == VAR13) {
if(!FUN64(VAR56,
VAR112,
0,
true)) {
VAR72.VAR114.value(msg.value)();
VAR111 = FUN67(VAR72, VAR56, VAR32);
require(VAR111 >= VAR113);
}
require(VAR56.transfer(VAR57, VAR112));
} else {
require(VAR55.FUN3(msg.sender, this, VAR32));
if(!FUN64(VAR55,
0,
VAR112,
false)) {
VAR111 = FUN67(VAR55, VAR72, VAR32);
require(VAR111 >= VAR113);
VAR72.FUN46(VAR111);
}
VAR57.transfer(VAR112);
}
FUN52(msg.sender, VAR55, VAR32, VAR56, VAR112, VAR57);
return true;
}
function FUN67(
ERC20 VAR55,
ERC20 VAR56,
uint VAR32
)
internal
returns(uint VAR111)
{
uint VAR115;
uint VAR107;
uint VAR108;
(VAR115, VAR107, VAR108) = FUN65(VAR56, VAR55, VAR32);
require(VAR32 <= VAR15);
require(VAR107 <= VAR15);
VAR111 = VAR32 * VAR107 / VAR108;
require(uint128(VAR111) == VAR111);
VAR71.FUN44(bytes32(VAR115), uint128(VAR111));
return;
}
function FUN65(
ERC20 VAR116,
ERC20 VAR117,
uint VAR118
)
internal
view
returns(
uint VAR115,
uint VAR119,
uint VAR120
)
{
VAR115 = VAR71.FUN42(VAR116, VAR117);
(VAR119, , VAR120, ) = VAR71.FUN41(VAR115);
uint VAR121 = 1;
while (VAR118 > VAR120) {
VAR115 = VAR71.FUN43(VAR115);
if (VAR115 == 0 || ++VAR121 > 7) {
VAR115 = 0;
VAR119 = 0;
VAR120 = 0;
break;
}
(VAR119, , VAR120, ) = VAR71.FUN41(VAR115);
}
return;
}
function FUN66(ERC20 VAR30, ERC20 VAR31) internal view returns (bool VAR122) {
return ((VAR73[VAR30] && VAR13 == VAR31) ||
(VAR73[VAR31] && VAR13 == VAR30));
}
}
0
---------------------------------
495 0x04a6e67d14715dd0e267b35805fea24fd0b5f70b.sol
pragma solidity 0.4.19;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
if (VAR2 == 0) {
return 0;
}
uint256 VAR4 = VAR2 * VAR3;
assert(VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
function FUN5()public view returns (uint VAR6);
function FUN6(address VAR7)public view returns (uint256);
function FUN7(address VAR8, address VAR9)public view returns (uint);
function FUN8(address VAR10, address VAR11, uint value)public returns (bool VAR12);
function FUN9(address VAR9, uint value)public returns (bool VAR12);
function transfer(address VAR11, uint value)public returns (bool VAR12);
event Transfer(address indexed VAR10, address indexed VAR11, uint value);
event FUN10(address indexed VAR8, address indexed VAR9, uint value);
}
contract GoldManCoin is VAR5
{ using SafeMath for uint256;
string public constant VAR13 = "";
string public constant VAR14 = "";
uint8 public constant VAR15 = 18;
uint public VAR16 = 1295000000 * 10 ** 18;
address public VAR8;
uint256 public VAR17 = 38000;
uint256 public VAR18= 24000;
uint256 VAR19;
uint256 VAR20;
uint256 VAR21;
bool VAR22 = false;
uint256 public VAR23;
uint256 public VAR24;
uint256 VAR25;
uint256 VAR26;
uint256 VAR27;
uint256 VAR28;
uint256 VAR29;
uint256 public VAR30;
uint256 VAR31 = 777000000 * 10 **18;
mapping(address => uint) VAR32;
mapping(address => mapping(address => uint)) VAR33;
enum VAR34 {
VAR35,
VAR36,
VAR37,
VAR38,
VAR39
}
Stages public VAR40;
modifier FUN11(Stages VAR41) {
if (VAR40 != VAR41)
revert();
VAR42;
}
modifier onlyOwner() {
if (msg.sender != VAR8) {
revert();
}
VAR42;
}
function FUN12() public
{
VAR8 = msg.sender;
VAR32[VAR8] = 518000000 * 10 **18;
VAR40 = VAR34.VAR35;
Transfer(0, VAR8, VAR32[VAR8]);
}
function () public payable
{
require(VAR40 != VAR34.VAR39);
require(!VAR22 && msg.sender != VAR8);
if( VAR40 == VAR34.VAR36 && VAR43 <= VAR29 )
{
require (VAR30 <= 1500 VAR44);
VAR30 = (VAR30).FUN4(msg.value);
VAR19 =((msg.value).FUN1(VAR17));
VAR20 = ((VAR19).FUN1(58)).FUN2(100);
VAR21 = VAR19 + VAR20;
FUN13(msg.sender,VAR21);
}
else if(VAR40 == VAR34.VAR37 && VAR43 <= VAR28 ){
if( VAR43 < VAR25 )
{
VAR19 =(msg.value).FUN1(VAR18);
VAR20 = ((VAR19).FUN1(15)).FUN2(100);
VAR21 = VAR19 + VAR20;
FUN13(msg.sender,VAR21);
}
else if(VAR43 >= VAR25 && VAR43 < VAR26)
{
VAR19 =(msg.value).FUN1(VAR18);
VAR20 = ((VAR19).FUN1(10)).FUN2(100);
VAR21 = VAR19 + VAR20;
FUN13(msg.sender,VAR21);
}
else if(VAR43 >= VAR26 && VAR43 < VAR27)
{
VAR19 =(msg.value).FUN1(VAR18);
VAR20 = ((VAR19).FUN1(5)).FUN2(100);
VAR21 = VAR19 + VAR20;
FUN13(msg.sender,VAR21);
}
else if(VAR43 >= VAR27 && VAR43 < VAR28)
{
VAR19 =(msg.value).FUN1(VAR18);
VAR21 = VAR19;
FUN13(msg.sender,VAR21);
}
}
else
{
revert();
}
}
function FUN14() public onlyOwner FUN11(VAR34.VAR35)
{
VAR40 = VAR34.VAR36;
VAR22 = false;
VAR32[address(this)] =  VAR31;
VAR23 = VAR43;
VAR29 = VAR43 + 16 VAR45;
Transfer(0, address(this), VAR32[address(this)]);
}
function FUN15() public onlyOwner FUN11(VAR34.VAR36)
{
require(VAR43 > VAR29 || VAR30 >= 1500 VAR44);
VAR40 = VAR34.VAR37;
VAR22 = false;
VAR24 = VAR43;
VAR25 = VAR43 + 15 VAR45;
VAR26 = VAR25 + 15 VAR45;
VAR27 = VAR26 + 15 VAR45;
VAR28 = VAR27 + 15 VAR45;
Transfer(0, address(this), VAR32[address(this)]);
}
function FUN16() external onlyOwner
{
VAR22 = true;
}
function FUN17() external onlyOwner
{
VAR22 = false;
}
function FUN18() external onlyOwner FUN11(VAR34.VAR37)
{
require(VAR43 > VAR28);
VAR40 = VAR34.VAR39;
VAR16 = (VAR16).FUN3(VAR32[address(this)]);
VAR32[address(this)] = 0;
Transfer(address(this), 0 , VAR32[address(this)]);
}
function FUN5() public view returns (uint256 VAR6) {
VAR6 = VAR16;
}
function FUN6(address VAR46)public view returns (uint256 VAR47) {
return VAR32[VAR46];
}
function FUN8( address VAR48, address VAR49, uint256 VAR50 )public returns (bool VAR51) {
require( VAR49 != 0x0);
require(VAR32[VAR48] >= VAR50 && VAR33[VAR48][msg.sender] >= VAR50 && VAR50 >= 0);
VAR32[VAR48] = (VAR32[VAR48]).FUN3(VAR50);
VAR33[VAR48][msg.sender] = (VAR33[VAR48][msg.sender]).FUN3(VAR50);
VAR32[VAR49] = (VAR32[VAR49]).FUN4(VAR50);
Transfer(VAR48, VAR49, VAR50);
return true;
}
function FUN9(address VAR52, uint256 VAR50)public returns (bool VAR51) {
require( VAR52 != 0x0);
VAR33[msg.sender][VAR52] = VAR50;
FUN10(msg.sender, VAR52, VAR50);
return true;
}
function FUN7(address VAR46, address VAR52)public view returns (uint256 VAR53) {
require( VAR46 != 0x0 && VAR52 !=0x0);
return VAR33[VAR46][VAR52];
}
function transfer(address VAR49, uint256 VAR50)public returns (bool VAR51) {
require( VAR49 != 0x0);
require(VAR32[msg.sender] >= VAR50 && VAR50 >= 0);
VAR32[msg.sender] = (VAR32[msg.sender]).FUN3(VAR50);
VAR32[VAR49] = (VAR32[VAR49]).FUN4(VAR50);
Transfer(msg.sender, VAR49, VAR50);
return true;
}
function FUN13(address VAR49, uint256 VAR50) private returns(bool VAR51) {
require( VAR49 != 0x0);
require(VAR32[address(this)] >= VAR50 && VAR50 > 0);
VAR32[address(this)] = (VAR32[address(this)]).FUN3(VAR50);
VAR32[VAR49] = (VAR32[VAR49]).FUN4(VAR50);
Transfer(address(this), VAR49, VAR50);
return true;
}
function FUN19() external onlyOwner {
VAR8.transfer(this.VAR47);
}
}
0
---------------------------------
496 0x04a734a6c3e415fff3149f0cb5f4719554974cc2.sol
pragma VAR1 ^0.5.0;
pragma experimental VAR2;
interface VAR3 {
function transfer(address VAR4, uint256 value) external returns (bool);
function FUN1(address VAR5, uint256 value) external returns (bool);
function FUN2(address VAR6, address VAR4, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR7) external view returns (uint256);
function FUN5(address VAR8, address VAR5) external view returns (uint256);
event Transfer(address indexed VAR6, address indexed VAR4, uint256 value);
event FUN6(address indexed VAR8, address indexed VAR5, uint256 value);
}
contract VAR9 {
address private VAR10;
event FUN7(address indexed VAR11, address indexed VAR12);
constructor () internal {
VAR10 = msg.sender;
emit FUN7(address(0), VAR10);
}
function FUN8() public view returns (address) {
return VAR10;
}
modifier onlyOwner() {
require(FUN9());
VAR13;
}
function FUN9() public view returns (bool) {
return msg.sender == VAR10;
}
function FUN10() public onlyOwner {
emit FUN7(VAR10, address(0));
VAR10 = address(0);
}
function FUN11(address VAR12) public onlyOwner {
FUN12(VAR12);
}
function FUN12(address VAR12) internal {
require(VAR12 != address(0));
emit FUN7(VAR10, VAR12);
VAR10 = VAR12;
}
}
library VAR14 {
function FUN13(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
if (VAR15 == 0) {
return 0;
}
uint256 VAR17 = VAR15 * VAR16;
require(VAR17 / VAR15 == VAR16);
return VAR17;
}
function FUN14(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
require(VAR16 > 0);
uint256 VAR17 = VAR15 / VAR16;
return VAR17;
}
function FUN15(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
require(VAR16 <= VAR15);
uint256 VAR17 = VAR15 - VAR16;
return VAR17;
}
function FUN16(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
uint256 VAR17 = VAR15 + VAR16;
require(VAR17 >= VAR15);
return VAR17;
}
function FUN17(uint256 VAR15, uint256 VAR16) internal pure returns (uint256) {
require(VAR16 != 0);
return VAR15 % VAR16;
}
}
library VAR18 {
int256 constant private VAR19 = -2**255;
function FUN13(int256 VAR15, int256 VAR16) internal pure returns (VAR20) {
if (VAR15 == 0) {
return 0;
}
require(!(VAR15 == -1 && VAR16 == VAR19));
int256 VAR17 = VAR15 * VAR16;
require(VAR17 / VAR15 == VAR16);
return VAR17;
}
function FUN14(int256 VAR15, int256 VAR16) internal pure returns (VAR20) {
require(VAR16 != 0);
require(!(VAR16 == -1 && VAR15 == VAR19));
int256 VAR17 = VAR15 / VAR16;
return VAR17;
}
function FUN15(int256 VAR15, int256 VAR16) internal pure returns (VAR20) {
int256 VAR17 = VAR15 - VAR16;
require((VAR16 >= 0 && VAR17 <= VAR15) || (VAR16 < 0 && VAR17 > VAR15));
return VAR17;
}
function FUN16(int256 VAR15, int256 VAR16) internal pure returns (VAR20) {
int256 VAR17 = VAR15 + VAR16;
require((VAR16 >= 0 && VAR17 >= VAR15) || (VAR16 < 0 && VAR17 < VAR15));
return VAR17;
}
}
contract ERC20 is VAR3 {
using SafeMath for uint256;
mapping (address => uint256) private VAR21;
mapping (address => mapping (address => uint256)) private VAR22;
uint256 private VAR23;
function FUN3() public view returns (uint256) {
return VAR23;
}
function FUN4(address VAR8) public view returns (uint256) {
return VAR21[VAR8];
}
function FUN5(address VAR8, address VAR5) public view returns (uint256) {
return VAR22[VAR8][VAR5];
}
function transfer(address VAR4, uint256 value) public returns (bool) {
FUN18(msg.sender, VAR4, value);
return true;
}
function FUN1(address VAR5, uint256 value) public returns (bool) {
require(VAR5 != address(0));
VAR22[msg.sender][VAR5] = value;
emit FUN6(msg.sender, VAR5, value);
return true;
}
function FUN2(address VAR6, address VAR4, uint256 value) public returns (bool) {
VAR22[VAR6][msg.sender] = VAR22[VAR6][msg.sender].FUN15(value);
FUN18(VAR6, VAR4, value);
emit FUN6(VAR6, msg.sender, VAR22[VAR6][msg.sender]);
return true;
}
function FUN19(address VAR5, uint256 VAR24) public returns (bool) {
require(VAR5 != address(0));
VAR22[msg.sender][VAR5] = VAR22[msg.sender][VAR5].FUN16(VAR24);
emit FUN6(msg.sender, VAR5, VAR22[msg.sender][VAR5]);
return true;
}
function FUN20(address VAR5, uint256 VAR25) public returns (bool) {
require(VAR5 != address(0));
VAR22[msg.sender][VAR5] = VAR22[msg.sender][VAR5].FUN15(VAR25);
emit FUN6(msg.sender, VAR5, VAR22[msg.sender][VAR5]);
return true;
}
function FUN18(address VAR6, address VAR4, uint256 value) internal {
require(VAR4 != address(0));
VAR21[VAR6] = VAR21[VAR6].FUN15(value);
VAR21[VAR4] = VAR21[VAR4].FUN16(value);
emit Transfer(VAR6, VAR4, value);
}
function FUN21(address VAR26, uint256 value) internal {
require(VAR26 != address(0));
VAR23 = VAR23.FUN16(value);
VAR21[VAR26] = VAR21[VAR26].FUN16(value);
emit Transfer(address(0), VAR26, value);
}
function FUN22(address VAR26, uint256 value) internal {
require(VAR26 != address(0));
VAR23 = VAR23.FUN15(value);
VAR21[VAR26] = VAR21[VAR26].FUN15(value);
emit Transfer(VAR26, address(0), value);
}
function FUN23(address VAR26, uint256 value) internal {
VAR22[VAR26][msg.sender] = VAR22[VAR26][msg.sender].FUN15(value);
FUN22(VAR26, value);
emit FUN6(VAR26, msg.sender, VAR22[VAR26][msg.sender]);
}
}
interface VAR27 {
function FUN24() external;
function FUN25() external;
}
contract ExpandedIERC20 is VAR3 {
function FUN26(uint value) external;
function FUN27(address VAR4, uint value) external;
}
interface VAR28 {
function FUN28() external payable;
function FUN29(address VAR29) external;
function FUN30(uint VAR30, uint VAR31, uint VAR32) external view returns (uint VAR33);
}
interface VAR34 {
function FUN31(int VAR35, int VAR36) external view returns (int VAR37);
function FUN32() external view returns (int VAR38);
}
interface VAR39 {
function FUN33(bytes32 VAR40) external view returns (bool VAR41);
function FUN34(bytes32 VAR40) external view returns (uint VAR42, int VAR43);
event FUN35(bytes32 indexed VAR40, uint indexed VAR44, int VAR43);
}
contract AddressWhitelist is VAR9 {
enum VAR45 { VAR46, VAR47, VAR48 }
mapping(address => VAR45) private VAR49;
address[] private VAR50;
function FUN36(address VAR51) external onlyOwner {
if (VAR49[VAR51] == VAR45.VAR47) {
return;
}
if (VAR49[VAR51] == VAR45.VAR46) {
VAR50.FUN37(VAR51);
}
VAR49[VAR51] = VAR45.VAR47;
emit FUN38(VAR51);
}
function FUN39(address VAR52) external onlyOwner {
if (VAR49[VAR52] != VAR45.VAR48) {
VAR49[VAR52] = VAR45.VAR48;
emit FUN40(VAR52);
}
}
function FUN41(address VAR53) external view returns (bool) {
return VAR49[VAR53] == VAR45.VAR47;
}
function FUN42() external view returns (address[] memory VAR54) {
uint VAR55 = 0;
for (uint VAR56 = 0; VAR56 < VAR50.VAR57; VAR56++) {
if (VAR49[VAR50[VAR56]] == VAR45.VAR47) {
VAR55++;
}
}
VAR54 = new address[](VAR55);
VAR55 = 0;
for (uint VAR56 = 0; VAR56 < VAR50.VAR57; VAR56++) {
address VAR58 = VAR50[VAR56];
if (VAR49[VAR58] == VAR45.VAR47) {
VAR54[VAR55] = VAR58;
VAR55++;
}
}
}
event FUN38(address indexed VAR59);
event FUN40(address indexed VAR60);
}
contract Withdrawable is VAR9 {
function FUN43(uint VAR61) external onlyOwner {
msg.sender.transfer(VAR61);
}
function FUN44(address VAR29, uint VAR61) external onlyOwner {
IERC20 VAR62 = FUN45(VAR29);
require(VAR62.transfer(msg.sender, VAR61));
}
}
interface VAR63 {
function FUN46(bytes32 VAR40, uint VAR44) external returns (uint VAR64);
function FUN47(bytes32 VAR40, uint VAR44) external view returns (bool VAR65);
function FUN48(bytes32 VAR40, uint VAR44) external view returns (int VAR43);
function FUN33(bytes32 VAR40) external view returns (bool VAR41);
event FUN49(bytes32 indexed VAR40, uint indexed VAR44);
event FUN50(bytes32 indexed VAR40, uint indexed VAR44, int VAR43);
}
interface VAR66 {
struct VAR67 {
address VAR68;
address VAR69;
}
function FUN51(address[] calldata VAR70, address VAR68) external;
function FUN52(address VAR69) external;
function FUN53(address VAR69) external;
function FUN54(address VAR71) external view returns (bool VAR72);
function FUN55(address VAR73) external view returns (VAR67[] memory VAR74);
function FUN56() external view returns (VAR67[] memory VAR74);
function FUN57(address VAR69) external view returns (bool VAR75);
}
contract Registry is VAR66, VAR76 {
using SafeMath for uint;
VAR67[] private VAR77;
enum VAR78 {
VAR79,
VAR80,
VAR81
}
struct VAR82 {
PointerValidity VAR83;
uint128 VAR84;
}
mapping(address => VAR82) private VAR85;
struct VAR86 {
mapping(address => bool) VAR87;
}
mapping(address => VAR86) private VAR88;
mapping(address => bool) private VAR89;
modifier VAR90 {
require(VAR89[msg.sender]);
VAR13;
}
function FUN51(address[] calldata VAR87, address VAR68)
external
VAR90
{
Pointer storage VAR91 = VAR85[VAR68];
require(VAR91.VAR83 == VAR78.VAR79);
VAR91.VAR83 = VAR78.VAR80;
VAR77.FUN37(FUN58(VAR68, msg.sender));
VAR91.VAR84 = uint128(VAR77.VAR57.FUN15(1));
PartiesMap storage VAR92 = VAR88[VAR68];
for (uint VAR56 = 0; VAR56 < VAR87.VAR57; VAR56 = VAR56.FUN16(1)) {
VAR92.VAR87[VAR87[VAR56]] = true;
}
address[] memory VAR93 = VAR87;
emit FUN59(VAR68, VAR93);
}
function FUN52(address VAR69) external onlyOwner {
if (!VAR89[VAR69]) {
VAR89[VAR69] = true;
emit FUN60(VAR69);
}
}
function FUN53(address VAR69) external onlyOwner {
if (VAR89[VAR69]) {
VAR89[VAR69] = false;
emit FUN61(VAR69);
}
}
function FUN54(address VAR71) external view returns (bool VAR72) {
return VAR85[VAR71].VAR83 == VAR78.VAR80;
}
function FUN55(address VAR73) external view returns (VAR67[] memory VAR74) {
VAR67[] memory VAR94 = new VAR67[](VAR77.VAR57);
uint VAR95 = 0;
for (uint VAR56 = 0; VAR56 < VAR77.VAR57; VAR56 = VAR56.FUN16(1)) {
RegisteredDerivative storage VAR71 = VAR77[VAR56];
if (VAR88[VAR71.VAR68].VAR87[VAR73]) {
VAR94[VAR95] = VAR71;
VAR95 = VAR95.FUN16(1);
}
}
VAR74 = new VAR67[](VAR95);
for (uint VAR96 = 0; VAR96 < VAR95; VAR96 = VAR96.FUN16(1)) {
VAR74[VAR96] = VAR94[VAR96];
}
}
function FUN56() external view returns (VAR67[] memory VAR74) {
return VAR77;
}
function FUN57(address VAR69) external view returns (bool VAR75) {
return VAR89[VAR69];
}
event FUN59(address indexed VAR68, address[] VAR87);
event FUN60(address indexed VAR97);
event FUN61(address indexed VAR98);
}
contract Testable is VAR9 {
bool public VAR99;
uint private VAR100;
constructor(bool VAR101) internal {
VAR99 = VAR101;
if (VAR101) {
VAR100 = VAR102;
}
}
modifier VAR103 {
require(VAR99);
VAR13;
}
function FUN62(uint VAR104) external onlyOwner VAR103 {
VAR100 = VAR104;
}
function FUN63() public view returns (uint) {
if (VAR99) {
return VAR100;
} else {
return VAR102;
}
}
}
contract ContractCreator is VAR76 {
Registry internal VAR105;
address internal VAR106;
address internal VAR107;
address internal VAR108;
constructor(address VAR109, address VAR110, address VAR111, address VAR112)
public
{
VAR105 = FUN64(VAR109);
VAR106 = VAR110;
VAR107 = VAR111;
VAR108 = VAR112;
}
function FUN65(address[] memory VAR87, address VAR113) internal {
VAR105.FUN51(VAR87, VAR113);
}
}
library VAR114 {
enum VAR115 {
VAR116,
VAR117
}
struct VAR118 {
address VAR119;
address VAR120;
address VAR121;
address VAR122;
address VAR123;
uint VAR124;
uint VAR125;
bytes32 VAR126;
uint VAR127;
uint VAR128;
address VAR129;
uint VAR130;
uint VAR131;
address VAR132;
uint VAR133;
ReturnType VAR134;
uint VAR135;
uint VAR136;
}
}
library VAR137 {
enum VAR138 {
VAR139,
VAR140,
VAR141,
VAR142,
VAR143,
VAR144
}
struct VAR145 {
int VAR146;
int VAR147;
uint VAR44;
}
struct VAR148 {
int VAR149;
uint VAR150;
}
struct VAR151 {
uint VAR30;
uint VAR152;
}
struct VAR153 {
uint VAR124;
uint VAR125;
uint VAR128;
uint VAR154;
uint VAR133;
bytes32 VAR126;
VAR114.ReturnType VAR134;
uint VAR155;
uint VAR136;
string VAR156;
}
struct VAR157 {
address VAR119;
address VAR120;
address VAR158;
OracleInterface VAR121;
StoreInterface VAR122;
PriceFeedInterface VAR123;
ReturnCalculatorInterface VAR129;
IERC20 VAR132;
}
struct VAR159 {
FixedParameters VAR160;
ExternalAddresses VAR161;
int VAR162;
int VAR163;
State VAR164;
uint VAR31;
TokenState VAR165;
TokenState VAR166;
int VAR167;
Dispute VAR168;
int VAR169;
WithdrawThrottle VAR170;
}
}
library VAR171 {
using TokenizedDerivativeUtils for VAR137.VAR159;
using SafeMath for uint;
using SignedSafeMath for int;
uint private constant VAR172 = 86400;
uint private constant VAR173 = 31536000;
uint private constant VAR174 = 2**255 - 1;
uint private constant VAR175 = 10**18;
int private constant VAR176 = 10**18;
modifier FUN66(VAR137.Storage storage VAR177) {
require(msg.sender == VAR177.VAR161.VAR119);
VAR13;
}
modifier onlyAdmin(VAR137.Storage storage VAR177) {
require(msg.sender == VAR177.VAR161.VAR120);
VAR13;
}
modifier FUN67(VAR137.Storage storage VAR177) {
require(msg.sender == VAR177.VAR161.VAR119 || msg.sender == VAR177.VAR161.VAR120);
VAR13;
}
modifier FUN68(VAR137.Storage storage VAR177) {
require(msg.sender == VAR177.VAR161.VAR119 || msg.sender == VAR177.VAR161.VAR158);
VAR13;
}
function FUN69(
VAR137.Storage storage VAR177, VAR114.ConstructorParams memory VAR178, string memory VAR156) public {
VAR177.FUN70(VAR178, VAR156);
VAR177.FUN71(VAR178);
require(VAR178.VAR130 >= VAR175.FUN14(10**9));
require(VAR178.VAR130 <= VAR175.FUN13(10**9));
(uint VAR179, int VAR180) = VAR177.VAR161.VAR123.FUN34(VAR177.VAR160.VAR126);
if (VAR178.VAR135 != 0) {
VAR180 = FUN72(VAR178.VAR135);
}
require(VAR180 > 0);
require(VAR179 != 0);
VAR177.VAR160.VAR155 = VAR178.VAR130.FUN13(VAR175).FUN14(FUN73(VAR180));
require(VAR177.VAR160.VAR155 != 0);
if (VAR178.VAR131 == 0) {
VAR177.VAR31 = ~uint(0);
} else {
require(VAR178.VAR131 >= VAR179);
VAR177.VAR31 = VAR178.VAR131;
}
VAR177.VAR167 = VAR177.FUN74(VAR180, VAR179, VAR178.VAR130);
VAR177.VAR164 = VAR137.VAR138.VAR139;
}
function FUN75(VAR137.Storage storage VAR177, uint VAR181, uint VAR182) external FUN68(VAR177) {
VAR177.FUN76();
int VAR183 = FUN77(VAR177.VAR166.VAR147, VAR182);
if (VAR183 < 0) {
VAR183 = 0;
}
uint VAR184 = FUN73(VAR183);
uint VAR185 = VAR177.FUN78(VAR181);
uint VAR186 = VAR181.FUN15(VAR184);
VAR177.FUN79(VAR186);
VAR185 = VAR185.FUN16(VAR177.FUN80(VAR182, VAR184));
VAR177.FUN81(VAR185);
}
function FUN82(VAR137.Storage storage VAR177, uint VAR187) external {
require(VAR177.VAR164 == VAR137.VAR138.VAR139 || VAR177.VAR164 == VAR137.VAR138.VAR144);
require(VAR187 > 0);
if (VAR177.VAR164 == VAR137.VAR138.VAR139) {
require(msg.sender == VAR177.VAR161.VAR119 || msg.sender == VAR177.VAR161.VAR158);
VAR177.FUN76();
require(VAR177.VAR164 == VAR137.VAR138.VAR139);
}
ExpandedIERC20 VAR188 = FUN83(address(this));
uint VAR189 = FUN84();
require(VAR189 > 0);
FUN85(VAR188, VAR187);
VAR188.FUN26(VAR187);
emit FUN86(VAR177.VAR160.VAR156, VAR187);
uint VAR190 = VAR187.FUN13(VAR175).FUN14(VAR189);
uint VAR191 = FUN87(FUN73(VAR177.VAR163), VAR190);
VAR177.VAR163 = VAR177.VAR163.FUN15(FUN72(VAR191));
assert(VAR177.VAR163 >= 0);
VAR177.VAR167 = FUN77(VAR177.VAR166.VAR147, FUN84());
VAR177.FUN81(VAR191);
}
function FUN88(VAR137.Storage storage VAR177, uint VAR192) external FUN66(VAR177) {
require(
VAR177.VAR164 == VAR137.VAR138.VAR139,
""
);
uint VAR193 = FUN73(FUN87(VAR177.FUN89(VAR177.VAR166), VAR177.VAR160.VAR128));
uint VAR194 = VAR177.FUN78(VAR192);
require(VAR192 >= VAR193);
uint VAR195 = VAR192.FUN15(VAR193);
VAR177.VAR164 = VAR137.VAR138.VAR140;
VAR177.VAR31 = VAR177.VAR166.VAR44;
VAR177.VAR168.VAR149 = VAR177.VAR167;
VAR177.VAR168.VAR150 = VAR193;
VAR177.VAR169 = VAR177.FUN90();
emit FUN91(VAR177.VAR160.VAR156, VAR177.VAR31, VAR177.VAR167);
VAR177.FUN92(VAR177.VAR31);
VAR177.FUN81(VAR194.FUN16(VAR195));
}
function FUN93(VAR137.Storage storage VAR177, uint VAR61) external FUN66(VAR177) {
if (VAR177.VAR164 == VAR137.VAR138.VAR139) {
VAR177.FUN76();
}
require(VAR177.VAR164 == VAR137.VAR138.VAR139 || VAR177.VAR164 == VAR137.VAR138.VAR144);
int VAR196;
if (VAR177.VAR164 == VAR137.VAR138.VAR144) {
VAR196 = VAR177.VAR162;
} else {
uint VAR100 = VAR177.VAR166.VAR44;
if (VAR177.VAR170.VAR30 <= VAR100.FUN15(VAR172)) {
VAR177.VAR170.VAR30 = VAR100;
VAR177.VAR170.VAR152 = FUN87(FUN73(VAR177.VAR162), VAR177.VAR160.VAR133);
}
int VAR197 = VAR177.VAR162.FUN15(VAR177.FUN89(VAR177.VAR166));
int VAR198 = FUN72(VAR177.VAR170.VAR152);
VAR196 = VAR198 < VAR197 ? VAR198 : VAR197;
VAR177.VAR170.VAR152 = VAR177.VAR170.VAR152.FUN15(VAR61);
}
require(
VAR196 >= FUN72(VAR61),
""
);
VAR177.VAR162 = VAR177.VAR162.FUN15(FUN72(VAR61));
emit FUN94(VAR177.VAR160.VAR156, VAR61);
VAR177.FUN81(VAR61);
}
function FUN95(VAR137.Storage storage VAR177) external FUN66(VAR177) {
require(VAR177.VAR164 == VAR137.VAR138.VAR142);
VAR177.FUN96();
}
function FUN97(VAR137.Storage storage VAR177, address VAR199) external FUN66(VAR177) {
VAR177.VAR161.VAR158 = VAR199;
}
function FUN98(VAR137.Storage storage VAR177) external onlyAdmin(VAR177) {
require(VAR177.VAR164 == VAR137.VAR138.VAR139);
VAR177.VAR164 = VAR137.VAR138.VAR143;
VAR177.VAR31 = VAR177.VAR166.VAR44;
VAR177.VAR169 = VAR177.FUN90();
emit FUN99(VAR177.VAR160.VAR156, VAR177.VAR31);
VAR177.FUN92(VAR177.VAR31);
}
function FUN100(VAR137.Storage storage VAR177) external {
VAR177.FUN101();
}
function FUN102(VAR137.Storage storage VAR177, uint VAR181, uint VAR182) external FUN68(VAR177) {
uint VAR185 = VAR177.FUN78(VAR181);
VAR185 = VAR185.FUN16(VAR177.FUN80(VAR182, VAR181));
VAR177.FUN81(VAR185);
}
function FUN103(VAR137.Storage storage VAR177, uint VAR200) external FUN66(VAR177) {
uint VAR185 = VAR177.FUN78(VAR200);
VAR177.FUN79(VAR200);
VAR177.FUN81(VAR185);
}
function FUN104(VAR137.Storage storage VAR177) external view returns (int VAR201) {
(VAR137.TokenState memory VAR202, ) = VAR177.FUN105();
VAR201 = FUN77(VAR202.VAR147, FUN84());
}
function FUN106(VAR137.Storage storage VAR177) external view returns (int VAR203) {
(VAR137.TokenState memory VAR202,) = VAR177.FUN105();
VAR203 = VAR202.VAR147;
}
function FUN107(VAR137.Storage storage VAR177) external view returns (int VAR204) {
(, VAR204) = VAR177.FUN105();
}
function FUN108(VAR137.Storage storage VAR177) external view returns (int VAR205) {
(VAR137.TokenState memory VAR202, int VAR204) = VAR177.FUN105();
int VAR206 = VAR202.VAR44 >= VAR177.VAR31 ? 0 : VAR177.FUN89(VAR202);
return VAR204.FUN15(VAR206);
}
function FUN109(VAR137.Storage storage VAR177) external view returns (int VAR206) {
if (VAR177.VAR164 == VAR137.VAR138.VAR144) {
return 0;
}
return VAR177.FUN89(VAR177.VAR166);
}
function FUN110(VAR137.Storage storage VAR177) external view returns (bool VAR207) {
VAR137.State VAR208 = VAR177.VAR164;
if (VAR208 == VAR137.VAR138.VAR144) {
return false;
}
(uint VAR209, ) = VAR177.FUN111();
if (VAR208 == VAR137.VAR138.VAR139 && (VAR209 < VAR177.VAR31)) {
return false;
}
return VAR177.VAR161.VAR121.FUN47(VAR177.VAR160.VAR126, VAR177.VAR31);
}
function FUN112(VAR137.Storage storage VAR177) external view returns (int VAR146, uint VAR44) {
(VAR137.TokenState memory VAR202, ) = VAR177.FUN105();
return (VAR202.VAR146, VAR202.VAR44);
}
function FUN105(VAR137.Storage storage VAR177) internal view returns (VAR137.TokenState memory VAR202, int VAR204)
{
if (VAR177.VAR164 == VAR137.VAR138.VAR144) {
return (VAR177.VAR166, VAR177.VAR162);
}
(uint VAR209, int VAR210) = VAR177.FUN111();
bool VAR211 = VAR177.VAR164 == VAR137.VAR138.VAR139;
bool VAR212 = VAR209 >= VAR177.VAR31;
if (VAR211 && VAR209 <= VAR177.VAR166.VAR44) {
return (VAR177.VAR166, VAR177.VAR162);
}
bool VAR213 = VAR211 &&
(VAR177.VAR160.VAR134 == VAR114.VAR115.VAR116 || VAR212);
VAR137.TokenState memory VAR214 = VAR213 ? VAR177.VAR165 : VAR177.VAR166;
(uint VAR215, int VAR216) = !VAR211 || VAR212 ?
(VAR177.VAR31, VAR177.VAR161.VAR121.FUN48(VAR177.VAR160.VAR126, VAR177.VAR31)) :
(VAR209, VAR210);
VAR204 = VAR177.VAR162;
VAR204 = VAR211 ?
VAR204.FUN15(
FUN72(VAR177.FUN113(VAR177.VAR166.VAR44, VAR215))) :
VAR204;
VAR202 = VAR177.FUN114(VAR214, VAR216, VAR215);
int VAR201 = FUN77(VAR202.VAR147, FUN84());
VAR204 = VAR204.FUN15(FUN115(VAR201, VAR177.VAR163, VAR204));
if (!VAR211 || VAR212) {
bool VAR217 = !VAR177.FUN116(VAR204, VAR202);
if (VAR217) {
int VAR218 = VAR211 ? VAR177.FUN90() : VAR177.FUN117();
int VAR124 = (VAR204 < VAR218) ?
VAR204 :
VAR218;
VAR204 = VAR204.FUN15(VAR124);
}
if (VAR177.VAR164 == VAR137.VAR138.VAR140 && VAR201 != VAR177.VAR168.VAR149) {
int VAR219 = FUN72(VAR177.VAR168.VAR150);
VAR204 = VAR204.FUN16(VAR219);
}
}
}
function FUN74(VAR137.Storage storage VAR177, int VAR180, uint VAR179, uint VAR130)
internal
returns (int VAR201)
{
int VAR220 = FUN72(VAR130);
VAR177.VAR165 = VAR137.FUN118(VAR180, VAR220, VAR179);
VAR177.VAR166 = VAR137.FUN118(VAR180, VAR220, VAR179);
VAR201 = 0;
}
function FUN119(VAR137.Storage storage VAR177) external FUN67(VAR177) {
VAR177.FUN76();
}
function FUN120(VAR137.Storage storage VAR177, address VAR29, uint VAR61) external FUN66(VAR177) {
if(address(VAR177.VAR161.VAR132) == VAR29) {
uint VAR221 = VAR177.VAR161.VAR132.FUN4(address(this));
int VAR222 = VAR177.VAR162.FUN16(VAR177.VAR163);
assert(VAR222 >= 0);
uint VAR196 = VAR221.FUN15(FUN73(VAR222)).FUN15(VAR177.VAR168.VAR150);
require(VAR196 >= VAR61);
}
IERC20 VAR62 = FUN45(VAR29);
require(VAR62.transfer(msg.sender, VAR61));
}
function FUN71(VAR137.Storage storage VAR177, VAR114.ConstructorParams memory VAR178) internal {
VAR177.VAR161.VAR132 = FUN45(VAR178.VAR132);
VAR177.VAR161.VAR121 = FUN121(VAR178.VAR121);
VAR177.VAR161.VAR122 = FUN122(VAR178.VAR122);
VAR177.VAR161.VAR123 = FUN123(VAR178.VAR123);
VAR177.VAR161.VAR129 = FUN124(VAR178.VAR129);
require(VAR177.VAR161.VAR121.FUN33(VAR178.VAR126));
require(VAR177.VAR161.VAR123.FUN33(VAR178.VAR126));
VAR177.VAR161.VAR119 = VAR178.VAR119;
VAR177.VAR161.VAR120 = VAR178.VAR120;
}
function FUN70(VAR137.Storage storage VAR177, VAR114.ConstructorParams memory VAR178, string memory VAR156) internal {
require(VAR178.VAR134 == VAR114.VAR115.VAR117
|| VAR178.VAR134 == VAR114.VAR115.VAR116);
require(VAR178.VAR134 == VAR114.VAR115.VAR117 || VAR178.VAR127 == 0);
require(VAR178.VAR124 <= VAR175);
VAR177.VAR160.VAR134 = VAR178.VAR134;
VAR177.VAR160.VAR124 = VAR178.VAR124;
VAR177.VAR160.VAR126 = VAR178.VAR126;
VAR177.VAR160.VAR154 = VAR178.VAR127.FUN14(VAR173);
VAR177.VAR160.VAR128 = VAR178.VAR128;
VAR177.VAR160.VAR125 = VAR178.VAR125;
VAR177.VAR160.VAR133 = VAR178.VAR133;
VAR177.VAR160.VAR136 = VAR178.VAR136;
VAR177.VAR160.VAR156 = VAR156;
}
function FUN76(VAR137.Storage storage VAR177) internal {
require(VAR177.VAR164 == VAR137.VAR138.VAR139);
(uint VAR179, int VAR223) = VAR177.FUN111();
if (VAR179 <= VAR177.VAR166.VAR44) {
return;
}
int VAR224 = VAR177.FUN90();
if (VAR179 >= VAR177.VAR31) {
VAR177.VAR164 = VAR137.VAR138.VAR141;
emit FUN125(VAR177.VAR160.VAR156, VAR177.VAR31);
int VAR225 = VAR177.FUN126(VAR177.VAR166.VAR146, VAR177.VAR166.VAR44);
assert(VAR225 == VAR177.VAR167);
uint VAR33 = VAR177.FUN127(VAR177.VAR166.VAR44, VAR177.VAR31);
VAR177.VAR169 = VAR224;
VAR177.FUN92(VAR177.VAR31);
VAR177.FUN128(VAR33);
return;
}
uint VAR33 = VAR177.FUN127(VAR177.VAR166.VAR44, VAR179);
int VAR201 = VAR177.FUN126(VAR223, VAR179);
VAR177.FUN129(VAR201);
bool VAR217 = !VAR177.FUN116(VAR177.VAR162, VAR177.VAR166);
if (VAR217) {
VAR177.VAR164 = VAR137.VAR138.VAR142;
VAR177.VAR169 = VAR224;
VAR177.VAR31 = VAR179;
emit FUN130(VAR177.VAR160.VAR156, VAR179, VAR177.VAR167);
VAR177.FUN92(VAR179);
}
VAR177.FUN128(VAR33);
}
function FUN80(VAR137.Storage storage VAR177, uint VAR182, uint VAR226) internal returns (uint VAR185) {
VAR177.FUN76();
require(VAR177.VAR164 == VAR137.VAR138.VAR139);
int VAR227 = FUN77(VAR177.VAR166.VAR147, VAR182);
if (VAR227 < 0) {
VAR227 = 0;
}
VAR185 = VAR226.FUN15(FUN73(VAR227));
VAR177.VAR163 = VAR177.VAR163.FUN16(VAR227);
ExpandedIERC20 VAR188 = FUN83(address(this));
VAR188.FUN27(msg.sender, VAR182);
emit FUN131(VAR177.VAR160.VAR156, VAR182);
VAR177.VAR167 = FUN77(VAR177.VAR166.VAR147, FUN84());
require(VAR177.FUN116(VAR177.VAR162, VAR177.VAR166));
}
function FUN79(VAR137.Storage storage VAR177, uint value) internal {
require(VAR177.VAR164 == VAR137.VAR138.VAR139);
VAR177.VAR162 = VAR177.VAR162.FUN16(FUN72(value));
emit FUN132(VAR177.VAR160.VAR156, value);
}
function FUN101(VAR137.Storage storage VAR177) internal {
VAR137.State VAR228 = VAR177.VAR164;
require(VAR228 == VAR137.VAR138.VAR140 || VAR228 == VAR137.VAR138.VAR141
|| VAR228 == VAR137.VAR138.VAR142 || VAR228 == VAR137.VAR138.VAR143);
VAR177.FUN133();
if (VAR228 == VAR137.VAR138.VAR140) {
int VAR219 = FUN72(VAR177.VAR168.VAR150);
if (VAR177.VAR167 != VAR177.VAR168.VAR149) {
VAR177.VAR162 = VAR177.VAR162.FUN16(VAR219);
} else {
VAR177.VAR163 = VAR177.VAR163.FUN16(VAR219);
}
}
}
function FUN127(VAR137.Storage storage VAR177, uint VAR229, uint VAR100) internal returns (uint VAR33) {
VAR33 = VAR177.FUN113(VAR229, VAR100);
VAR177.VAR162 = VAR177.VAR162.FUN15(FUN72(VAR33));
}
function FUN128(VAR137.Storage storage VAR177, uint VAR33) internal {
if (VAR33 == 0) {
return;
}
if (address(VAR177.VAR161.VAR132) == address(0x0)) {
VAR177.VAR161.VAR122.VAR230.value(VAR33)();
} else {
require(VAR177.VAR161.VAR132.FUN1(address(VAR177.VAR161.VAR122), VAR33));
VAR177.VAR161.VAR122.FUN29(address(VAR177.VAR161.VAR132));
}
}
function FUN113(VAR137.Storage storage VAR177, uint VAR229, uint VAR100)
internal
view
returns (uint VAR33)
{
int VAR32 = VAR177.VAR162 < VAR177.VAR163 ? VAR177.VAR163 : VAR177.VAR162;
uint VAR231 = VAR177.VAR161.VAR122.FUN30(VAR229, VAR100, FUN73(VAR32));
uint VAR162 = FUN73(VAR177.VAR162);
return (VAR162 < VAR231) ? VAR162 : VAR231;
}
function FUN114(VAR137.Storage storage VAR177,
VAR137.TokenState memory VAR232, int VAR180, uint VAR215)
internal
view
returns (VAR137.TokenState memory VAR202)
{
int VAR233 = VAR177.VAR161.VAR129.FUN31(
VAR232.VAR146, VAR180);
int VAR234 = VAR233.FUN15(
FUN72(VAR177.VAR160.VAR154.FUN13(VAR215.FUN15(VAR232.VAR44))));
int VAR235 = VAR234.FUN16(VAR176);
if (VAR177.VAR160.VAR134 == VAR114.VAR115.VAR117 && VAR235 < 0) {
VAR235 = 0;
}
int VAR236 = FUN87(VAR232.VAR147, VAR235);
VAR202 = VAR137.FUN118(VAR180, VAR236, VAR215);
}
function FUN116(VAR137.Storage storage VAR177, int VAR237, VAR137.TokenState memory VAR238)
internal
view
returns (bool VAR239)
{
return VAR177.FUN89(VAR238) <= VAR237;
}
function FUN92(VAR137.Storage storage VAR177, uint VAR240) internal {
uint VAR64 = VAR177.VAR161.VAR121.FUN46(VAR177.VAR160.VAR126, VAR240);
if (VAR64 == 0) {
VAR177.FUN101();
}
}
function FUN111(VAR137.Storage storage VAR177) internal view returns (uint VAR179, int VAR180) {
(VAR179, VAR180) = VAR177.VAR161.VAR123.FUN34(VAR177.VAR160.VAR126);
require(VAR179 != 0);
}
function FUN126(VAR137.Storage storage VAR177, int VAR180, uint VAR179) internal returns (int VAR201) {
if (VAR177.VAR160.VAR134 == VAR114.VAR115.VAR117) {
VAR201 = VAR177.FUN134(VAR180, VAR179);
} else {
assert(VAR177.VAR160.VAR134 == VAR114.VAR115.VAR116);
VAR201 = VAR177.FUN135(VAR180, VAR179);
}
}
function FUN134(VAR137.Storage storage VAR177, int VAR180, uint VAR179) internal returns (int VAR201) {
VAR177.VAR165 = VAR177.VAR166;
VAR177.VAR166 = VAR177.FUN114(VAR177.VAR166, VAR180, VAR179);
VAR201 = FUN77(VAR177.VAR166.VAR147, FUN84());
emit FUN136(VAR177.VAR160.VAR156, VAR201, VAR177.VAR166.VAR147);
}
function FUN135(VAR137.Storage storage VAR177, int VAR180, uint VAR179) internal returns (int VAR201) {
VAR177.VAR165.VAR44 = VAR177.VAR166.VAR44;
VAR177.VAR166 = VAR177.FUN114(VAR177.VAR165, VAR180, VAR179);
VAR201 = FUN77(VAR177.VAR166.VAR147, FUN84());
emit FUN136(VAR177.VAR160.VAR156, VAR201, VAR177.VAR166.VAR147);
}
function FUN137(VAR137.Storage storage VAR177, int VAR241, uint VAR215) internal returns (int VAR201) {
assert(VAR177.VAR31 == VAR215);
VAR177.VAR166 = VAR177.FUN114(VAR177.VAR165, VAR241, VAR215);
VAR201 = FUN77(VAR177.VAR166.VAR147, FUN84());
emit FUN136(VAR177.VAR160.VAR156, VAR201, VAR177.VAR166.VAR147);
}
function FUN138(VAR137.Storage storage VAR177, int VAR43) internal {
VAR177.FUN129(VAR177.FUN137(VAR43, VAR177.VAR31));
bool VAR217 = !VAR177.FUN116(VAR177.VAR162, VAR177.VAR166);
if (VAR217) {
int VAR218 = VAR177.FUN117();
int VAR242 = (VAR177.VAR162 < VAR218) ?
VAR177.VAR162 :
VAR218;
VAR177.VAR162 = VAR177.VAR162.FUN15(VAR242);
VAR177.VAR163 = VAR177.VAR163.FUN16(VAR242);
}
VAR177.VAR164 = VAR137.VAR138.VAR144;
emit FUN139(VAR177.VAR160.VAR156, VAR177.VAR31, VAR177.VAR167);
}
function FUN129(VAR137.Storage storage VAR177, int VAR201) internal {
int VAR243 = FUN115(VAR201, VAR177.VAR163, VAR177.VAR162);
VAR177.VAR167 = VAR201;
VAR177.VAR163 = VAR177.VAR163.FUN16(VAR243);
VAR177.VAR162 = VAR177.VAR162.FUN15(VAR243);
}
function FUN117(VAR137.Storage storage VAR177) internal view returns (int VAR242) {
return VAR177.VAR169;
}
function FUN90(VAR137.Storage storage VAR177) internal view returns (int VAR242) {
return FUN87(VAR177.FUN89(VAR177.VAR166), VAR177.VAR160.VAR124);
}
function FUN89(VAR137.Storage storage VAR177, VAR137.TokenState memory VAR238)
internal
view
returns (int VAR206)
{
int VAR244 = FUN140(VAR177.VAR161.VAR129.FUN32());
int VAR245;
if (VAR177.VAR160.VAR134 == VAR114.VAR115.VAR116) {
int VAR246 = FUN72(FUN84().FUN13(VAR177.VAR160.VAR155).FUN14(VAR175)).FUN13(VAR244);
VAR245 = VAR246.FUN13(VAR238.VAR146).FUN14(VAR176);
} else {
int VAR247 = FUN77(VAR238.VAR147, FUN84());
VAR245 = VAR247.FUN13(VAR244);
}
VAR206 = FUN87(FUN140(VAR245), VAR177.VAR160.VAR125);
}
function FUN78(VAR137.Storage storage VAR177, uint VAR248) internal returns (uint VAR185) {
if (address(VAR177.VAR161.VAR132) == address(0x0)) {
return msg.value.FUN15(VAR248);
} else {
require(msg.value == 0);
FUN85(VAR177.VAR161.VAR132, VAR248);
return 0;
}
}
function FUN81(VAR137.Storage storage VAR177, uint VAR61) internal {
if (VAR61 == 0) {
return;
}
if (address(VAR177.VAR161.VAR132) == address(0x0)) {
msg.sender.transfer(VAR61);
} else {
require(VAR177.VAR161.VAR132.transfer(msg.sender, VAR61));
}
}
function FUN96(VAR137.Storage storage VAR177) internal {
int VAR249 = VAR177.VAR166.VAR146;
VAR177.FUN138(VAR249);
}
function FUN133(VAR137.Storage storage VAR177) internal {
int VAR241 = VAR177.VAR161.VAR121.FUN48(VAR177.VAR160.VAR126, VAR177.VAR31);
VAR177.FUN138(VAR241);
}
function FUN85(IERC20 VAR62, uint VAR250) private {
if (VAR250 > 0) {
require(VAR62.FUN2(msg.sender, address(this), VAR250));
}
}
function FUN115(int VAR201, int VAR163, int VAR162) private pure returns (int VAR243) {
int VAR251 = VAR201;
if (VAR251 < 0) {
VAR251 = 0;
}
VAR243 = VAR251.FUN15(VAR163);
if (VAR243 > VAR162) {
VAR243 = VAR162;
}
}
function FUN77(int VAR147, uint VAR252) private pure returns (int VAR201) {
int VAR253 = FUN72(VAR252).FUN13(VAR147);
VAR201 = VAR253.FUN14(VAR176);
if ((VAR253 % VAR176) != 0) {
VAR201 = VAR201.FUN16(1);
}
}
function FUN84() private view returns (uint VAR254) {
ExpandedIERC20 VAR188 = FUN83(address(this));
return VAR188.FUN3();
}
function FUN87(uint value, uint VAR255) private pure returns (uint VAR256) {
return value.FUN13(VAR255).FUN14(VAR175);
}
function FUN87(int value, uint VAR255) private pure returns (int VAR256) {
return value.FUN13(FUN72(VAR255)).FUN14(VAR176);
}
function FUN87(int value, int VAR255) private pure returns (int VAR256) {
return value.FUN13(VAR255).FUN14(VAR176);
}
function FUN140(int value) private pure returns (int VAR256) {
return value < 0 ? value.FUN13(-1) : value;
}
function FUN72(uint value) private pure returns (int VAR256) {
require(value <= VAR174);
return int(value);
}
function FUN73(int value) private pure returns (uint VAR256) {
require(value >= 0);
return uint(value);
}
event FUN136(string VAR156, int VAR257, int VAR236);
event FUN130(string VAR156, uint VAR258, int VAR259);
event FUN139(string VAR156, uint VAR260, int VAR261);
event FUN125(string VAR156, uint VAR262);
event FUN91(string VAR156, uint VAR263, int VAR264);
event FUN99(string VAR156, uint VAR265);
event FUN131(string VAR156, uint VAR266);
event FUN86(string VAR156, uint VAR267);
event FUN132(string VAR156, uint VAR61);
event FUN94(string VAR156, uint VAR61);
}
contract TokenizedDerivative is VAR268, VAR27, VAR269 {
using TokenizedDerivativeUtils for VAR137.VAR159;
string public VAR270;
string public VAR156;
uint8 public constant VAR271 = 18;
VAR137.Storage public VAR272;
constructor(
VAR114.ConstructorParams memory VAR178,
string memory VAR273,
string memory VAR274
) public {
VAR270 = VAR273;
VAR156 = VAR274;
VAR272.FUN69(VAR178, VAR274);
}
function FUN141(uint VAR181, uint VAR182) external payable {
VAR272.FUN102(VAR181, VAR182);
}
function FUN142(uint VAR181, uint VAR182) external payable {
VAR272.FUN75(VAR181, VAR182);
}
function FUN143(uint VAR187) external {
VAR272.FUN82(VAR187);
}
function FUN144(uint VAR192) external payable {
VAR272.FUN88(VAR192);
}
function FUN43(uint VAR61) external {
VAR272.FUN93(VAR61);
}
function FUN25() external {
VAR272.FUN119();
}
function FUN145() external {
VAR272.FUN95();
}
function FUN146(address VAR158) external {
VAR272.FUN97(VAR158);
}
function FUN24() external {
VAR272.FUN98();
}
function FUN147() external view returns (int VAR201) {
return VAR272.FUN104();
}
function FUN148() external view returns (int VAR203) {
return VAR272.FUN106();
}
function FUN149() external view returns (int VAR204) {
return VAR272.FUN107();
}
function FUN150() external view returns (int VAR275) {
return VAR272.FUN108();
}
function FUN151() external view returns (int VAR206) {
return VAR272.FUN109();
}
function FUN152() external view returns (bool VAR276) {
return VAR272.FUN110();
}
function FUN153() external view returns (int VAR146, uint VAR44) {
return VAR272.FUN112();
}
function FUN154() external {
VAR272.FUN100();
}
function FUN155(uint VAR277) external payable {
VAR272.FUN103(VAR277);
}
function FUN156(address VAR29, uint VAR61) external {
VAR272.FUN120(VAR29, VAR61);
}
modifier VAR278 {
require(msg.sender == address(this));
VAR13;
}
function FUN26(uint value) external VAR278 {
FUN22(msg.sender, value);
}
function FUN27(address VAR4, uint256 value) external VAR278 {
FUN21(VAR4, value);
}
event FUN136(string VAR156, int VAR257, int VAR236);
event FUN130(string VAR156, uint VAR258, int VAR259);
event FUN139(string VAR156, uint VAR260, int VAR261);
event FUN125(string VAR156, uint VAR262);
event FUN91(string VAR156, uint VAR263, int VAR264);
event FUN99(string VAR156, uint VAR265);
event FUN131(string VAR156, uint VAR266);
event FUN86(string VAR156, uint VAR267);
event FUN132(string VAR156, uint VAR61);
event FUN94(string VAR156, uint VAR61);
}
contract TokenizedDerivativeCreator is VAR279, VAR280 {
struct VAR281 {
uint VAR124;
uint VAR125;
bytes32 VAR126;
uint VAR127;
uint VAR128;
address VAR129;
uint VAR130;
uint VAR131;
address VAR132;
uint VAR133;
VAR114.ReturnType VAR134;
uint VAR135;
string VAR270;
string VAR156;
}
AddressWhitelist public VAR282;
AddressWhitelist public VAR283;
AddressWhitelist public VAR284;
constructor(
address VAR109,
address VAR110,
address VAR111,
address VAR112,
address VAR285,
address VAR286,
address VAR287,
bool VAR101
)
public
FUN157(VAR109, VAR110, VAR111, VAR112)
FUN158(VAR101)
{
VAR282 = FUN159(VAR285);
VAR283 = FUN159(VAR286);
VAR284 = FUN159(VAR287);
}
function FUN160(Params memory VAR178)
public
returns (address VAR68)
{
TokenizedDerivative VAR71 = VAR288 FUN161(FUN162(VAR178), VAR178.VAR270, VAR178.VAR156);
address[] memory VAR87 = new address[](1);
VAR87[0] = msg.sender;
FUN65(VAR87, address(VAR71));
return address(VAR71);
}
function FUN162(Params memory VAR178)
private
view
returns (VAR114.ConstructorParams memory VAR289)
{
require(VAR282.FUN41(msg.sender));
VAR289.VAR119 = msg.sender;
require(VAR283.FUN41(VAR178.VAR129));
VAR289.VAR129 = VAR178.VAR129;
require(VAR284.FUN41(VAR178.VAR132));
VAR289.VAR132 = VAR178.VAR132;
VAR289.VAR124 = VAR178.VAR124;
VAR289.VAR125 = VAR178.VAR125;
VAR289.VAR126 = VAR178.VAR126;
VAR289.VAR127 = VAR178.VAR127;
VAR289.VAR128 = VAR178.VAR128;
VAR289.VAR130 = VAR178.VAR130;
VAR289.VAR131 = VAR178.VAR131;
VAR289.VAR133 = VAR178.VAR133;
VAR289.VAR134 = VAR178.VAR134;
VAR289.VAR135 = VAR178.VAR135;
VAR289.VAR123 = VAR108;
VAR289.VAR121 = VAR106;
VAR289.VAR122 = VAR107;
VAR289.VAR120 = VAR106;
VAR289.VAR136 = FUN63();
}
}
0
---------------------------------
497 0x04a84b5368c9006ed05e837f8132e9f1c0287482.sol
pragma solidity 0.4.25;
contract VAR1 {
using SafeMath for uint;
mapping(address => uint) public VAR2;
mapping(address => uint) public VAR3;
mapping(address => uint) public VAR4;
uint public VAR5 = 24 VAR6;
uint public VAR7 = 0;
address public VAR8 = 0x524011386BCDFB614f7373Ee8aeb494199D812BE;
address public VAR9 = 0xc210F228dFdb2c7C3B9BC347032a507ee62dC95c;
uint VAR10 = 5;
uint VAR11 = 15;
uint public VAR12 = 1 VAR13 / 100;
event FUN1(address VAR14, uint256 VAR15);
event FUN2(address VAR14, uint256 VAR15, string VAR16);
modifier FUN3() {
require(VAR2[msg.sender] > 0, "");
VAR17;
}
modifier FUN4() {
require(VAR18 >= VAR3[msg.sender].FUN5(VAR5), "");
VAR17;
}
function FUN6() userExist checkTime internal {
if (VAR2[msg.sender].FUN7(2) <= VAR4[msg.sender]) {
VAR2[msg.sender] = 0;
VAR3[msg.sender] = 0;
VAR4[msg.sender] = 0;
} else {
uint VAR19 = FUN8();
VAR4[msg.sender] = VAR4[msg.sender].FUN5(VAR19);
msg.sender.transfer(VAR19);
VAR3[msg.sender] = VAR18;
emit FUN2(msg.sender, VAR19, '');
}
}
function FUN8() public view returns (uint256) {
uint256 VAR20 = VAR18.FUN9(VAR3[msg.sender]).FUN10(VAR5);
uint256 VAR21 = VAR2[msg.sender].FUN7(VAR11).FUN10(1000);
uint256 VAR22 = VAR21.FUN7(VAR20);
return VAR22;
}
function FUN11() private {
if (msg.value > 0) {
require(msg.value >= VAR12, "");
if (VAR2[msg.sender] == 0) {
VAR7 += 1;
address VAR23 = FUN12(msg.VAR24);
if (VAR2[VAR23] > 0 && VAR23 != msg.sender) {
uint256 VAR25 = msg.value.FUN7(VAR11).FUN10(1000);
VAR23.transfer(VAR25);
emit FUN2(VAR23, VAR25, '');
msg.sender.transfer(VAR25);
emit FUN2(msg.sender, VAR25, '');
}
}
if (VAR2[msg.sender] > 0 && VAR18 > VAR3[msg.sender].FUN5(VAR5)) {
FUN6();
}
VAR2[msg.sender] = VAR2[msg.sender].FUN5(msg.value);
VAR3[msg.sender] = VAR18;
VAR8.transfer(msg.value.FUN7(VAR10).FUN10(100));
VAR9.transfer(msg.value.FUN7(VAR10).FUN10(100));
emit FUN1(msg.sender, msg.value);
} else {
FUN6();
}
}
function() external payable {
FUN11();
}
function FUN12(bytes VAR26) private pure returns (address VAR27) {
VAR28 {
VAR27 := FUN13(FUN5(VAR26, 20))
}
}
}
library VAR29 {
function FUN7(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
if (VAR30 == 0) {
return 0;
}
uint256 VAR32 = VAR30 * VAR31;
assert(VAR32 / VAR30 == VAR31);
return VAR32;
}
function FUN10(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
require(VAR31 > 0);
uint256 VAR32 = VAR30 / VAR31;
return VAR32;
}
function FUN9(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
assert(VAR31 <= VAR30);
return VAR30 - VAR31;
}
function FUN5(uint256 VAR30, uint256 VAR31) internal pure returns (uint256) {
uint256 VAR32 = VAR30 + VAR31;
assert(VAR32 >= VAR30);
return VAR32;
}
}
0
---------------------------------
498 0x04abeda201850ac0124161f037efd70c74ddc74c.sol
pragma VAR1 ^0.5.1;
library VAR2 {
struct VAR3
{
mapping(address => VAR4) VAR5;
VAR6[] VAR7;
uint VAR8;
}
struct VAR4 { uint VAR9; uint value; }
struct VAR6 { address VAR10; bool VAR11; }
function FUN1(itmap storage VAR12, address VAR10, uint value) public returns (bool VAR13)
{
uint VAR9 = VAR12.VAR5[VAR10].VAR9;
VAR12.VAR5[VAR10].value = value;
if (VAR9 > 0)
return true;
else
{
VAR9 = VAR12.VAR7.VAR14++;
VAR12.VAR5[VAR10].VAR9 = VAR9 + 1;
VAR12.VAR7[VAR9].VAR10 = VAR10;
VAR12.VAR8++;
return false;
}
}
function FUN2(itmap storage VAR12, address VAR10) public returns (bool VAR15)
{
uint VAR9 = VAR12.VAR5[VAR10].VAR9;
if (VAR9 == 0)
return false;
delete VAR12.VAR5[VAR10];
VAR12.VAR7[VAR9 - 1].VAR11 = true;
VAR12.VAR8 --;
}
function FUN3(itmap storage VAR12, address VAR10) public view returns (bool)
{
return VAR12.VAR5[VAR10].VAR9 > 0;
}
function FUN4(itmap storage VAR12) public view returns (uint VAR9)
{
return FUN5(VAR12, uint(-1));
}
function FUN6(itmap storage VAR12, uint VAR9) public view returns (bool)
{
return VAR9 < VAR12.VAR7.VAR14;
}
function FUN5(itmap storage VAR12, uint VAR9) public view returns (uint VAR16)
{
VAR9++;
while (VAR9 < VAR12.VAR7.VAR14 && VAR12.VAR7[VAR9].VAR11)
VAR9++;
return VAR9;
}
function FUN7(itmap storage VAR12, uint VAR9) public view returns (address VAR10, uint value)
{
VAR10 = VAR12.VAR7[VAR9].VAR10;
value = VAR12.VAR5[VAR10].value;
}
function FUN8(itmap storage VAR12, address VAR10) public view returns (uint value) {
return VAR12.VAR5[VAR10].value;
}
}
library VAR17 {
function FUN9(uint256 VAR18, uint256 VAR19) internal pure returns (uint256 VAR20) {
if (VAR18 == 0) {
return 0;
}
VAR20 = VAR18 * VAR19;
assert(VAR20 / VAR18 == VAR19);
return VAR20;
}
function FUN10(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
assert(VAR19 > 0);
uint256 VAR20 = VAR18 / VAR19;
assert(VAR18 == VAR19 * VAR20 + VAR18 % VAR19);
return VAR18 / VAR19;
}
function FUN11(uint256 VAR18, uint256 VAR19) internal pure returns (uint256) {
assert(VAR19 <= VAR18);
return VAR18 - VAR19;
}
function FUN12(uint256 VAR18, uint256 VAR19) internal pure returns (uint256 VAR20) {
VAR20 = VAR18 + VAR19;
assert(VAR20 >= VAR18);
return VAR20;
}
}
contract VAR21 {
function FUN13() public view returns (uint256);
function FUN14(address VAR22) public view returns (uint256);
function transfer(address VAR23, uint256 VAR24) public returns (bool);
event Transfer(address indexed VAR25, address indexed VAR26, uint256 value);
}
contract BasicToken is VAR21 {
using SafeMath for uint256;
VAR2.itmap VAR27;
uint256 internal VAR28;
function FUN13() public view returns (uint256) {
return VAR28;
}
function transfer(address VAR23, uint256 VAR24) public returns (bool) {
require(VAR24 <= VAR2.FUN8(VAR27, msg.sender));
require(VAR23 != address(0));
VAR2.FUN1(VAR27, msg.sender, VAR2.FUN8(VAR27, msg.sender).FUN11(VAR24));
VAR2.FUN1(VAR27, VAR23, VAR2.FUN8(VAR27, VAR23).FUN12(VAR24));
emit Transfer(msg.sender, VAR23, VAR24);
return true;
}
function FUN14(address VAR29) public view returns (uint256) {
return VAR2.FUN8(VAR27, VAR29);
}
}
contract ERC20 is VAR21 {
function FUN15(address VAR29, address VAR30)
public view returns (uint256);
function FUN16(address VAR31, address VAR23, uint256 VAR24)
public returns (bool);
function FUN17(address VAR30, uint256 VAR24) public returns (bool);
event FUN18(
address indexed VAR32,
address indexed VAR33,
uint256 value
);
}
contract StandardToken is VAR34, VAR35 {
mapping (address => mapping (address => uint256)) internal VAR36;
function FUN16(
address VAR31,
address VAR23,
uint256 VAR24
)
public
returns (bool)
{
require(VAR24 <= VAR2.FUN8(VAR27, VAR31));
require(VAR24 <= VAR36[VAR31][msg.sender]);
require(VAR23 != address(0));
VAR2.FUN1(VAR27, VAR31, VAR2.FUN8(VAR27, VAR31).FUN11(VAR24));
VAR2.FUN1(VAR27, VAR23, VAR2.FUN8(VAR27, VAR23).FUN12(VAR24));
VAR36[VAR31][msg.sender] = VAR36[VAR31][msg.sender].FUN11(VAR24);
emit Transfer(VAR31, VAR23, VAR24);
return true;
}
function FUN17(address VAR30, uint256 VAR24) public returns (bool) {
VAR36[msg.sender][VAR30] = VAR24;
emit FUN18(msg.sender, VAR30, VAR24);
return true;
}
function FUN15(
address VAR29,
address VAR30
)
public
view
returns (uint256)
{
return VAR36[VAR29][VAR30];
}
function FUN19(
address VAR30,
uint256 VAR37
)
public
returns (bool)
{
VAR36[msg.sender][VAR30] = (
VAR36[msg.sender][VAR30].FUN12(VAR37));
emit FUN18(msg.sender, VAR30, VAR36[msg.sender][VAR30]);
return true;
}
function FUN20(
address VAR30,
uint256 VAR38
)
public
returns (bool)
{
uint256 VAR39 = VAR36[msg.sender][VAR30];
if (VAR38 >= VAR39) {
VAR36[msg.sender][VAR30] = 0;
} else {
VAR36[msg.sender][VAR30] = VAR39.FUN11(VAR38);
}
emit FUN18(msg.sender, VAR30, VAR36[msg.sender][VAR30]);
return true;
}
}
contract IBNEST is VAR40 {
string public VAR41 = "";
string public VAR42 = "";
uint8 public VAR43 = 18;
uint256 public VAR44 = 10000000000 VAR45;
constructor () public {
VAR28 = VAR44;
VAR2.FUN1(VAR27, VAR46.VAR47, VAR44);
}
function FUN21() public view returns(uint256) {
return VAR2.FUN4(VAR27);
}
function FUN22(uint256 VAR48) public view returns(bool){
return VAR2.FUN6(VAR27, VAR48);
}
function FUN23(uint256 VAR48) public view returns(uint256) {
return VAR2.FUN5(VAR27, VAR48);
}
function FUN24(uint256 VAR48) public view returns(address, uint256) {
address VAR10;
uint256 value;
(VAR10, value) = VAR2.FUN7(VAR27, VAR48);
return (VAR10, value);
}
}
0
---------------------------------
499 0x04ac1eb4bdcce9cf16b3e44d9cf3ece2d4911906.sol
pragma VAR1 ^0.5.4;
contract VAR2 {
function FUN1(address) external view returns(uint256) {}
}
contract VAR3 {
function FUN2(uint256) external view returns(uint256) {}
function FUN3(uint256) external view returns(uint256) {}
}
contract VAR4 {
function FUN4(address, address, uint256) external view returns(uint256) {}
function FUN5(address, address, uint256) external view returns(uint256) {}
}
contract VAR5 {
function FUN6(address, address, uint256) external view returns(uint256, uint256) {}
}
contract VAR6 {
function FUN6(address, address, uint256) external view returns(uint256) {}
}
contract VAR7 {
function FUN7(address, address, uint256, bool) external view returns(address, uint256) {}
}
contract VAR8 {
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 constant public VAR12 = 10**18;
uint256 constant public VAR13 = 5;
address constant public VAR14 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address constant public VAR15 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address constant public VAR16 = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C;
address constant public VAR17 = 0x09cabEC1eAd1c0Ba254B09efb3EE13841712bE14;
address constant public VAR18 = 0x39755357759cE0d7f32dC8dC45414CCa409AE24e;
address constant public VAR19 = 0xCBc6a023eb975a1e2630223a7959988948E664f3;
address constant public VAR20 = 0x587044b74004E3D5eF2D453b7F8d198d9e4cB558;
address constant public VAR21 = 0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315;
address constant public VAR22 = 0x9ae49C0d7F8F9EF4B864e004FE86Ac8294E20950;
address constant public VAR23 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address constant public VAR24 = 0x04A487aFd662c4F9DEAcC07A7B10cFb686B682A4;
address constant public VAR25 = 0x13032DeB2d37556cf49301f713E9d7e1d1A8b169;
ERC20 constant VAR26 = FUN8(VAR14);
Uniswap constant VAR27 = FUN9(VAR17);
Eth2Dai constant VAR28 = FUN10(VAR18);
Bancor constant VAR29 = FUN11(VAR19);
BancorDai constant VAR30 = FUN12(VAR20);
Kyber constant VAR31 = FUN13(VAR22);
constructor() public {
FUN14();
}
function FUN15(
address VAR32
)
public
view
returns(
uint256 VAR33
) {
return VAR26.FUN1(VAR32);
}
function FUN16(
address VAR32
)
public
view
returns(
uint256 VAR34
) {
return VAR32.VAR35;
}
function FUN17(
uint256 VAR34
)
public
view
returns(
uint256 VAR36
) {
uint256 VAR37 = VAR27.FUN2(VAR34);
return (VAR37 * VAR12) / VAR34;
}
function FUN18(
uint256 VAR34
)
public
view
returns(
uint256 VAR36
) {
uint256 VAR38 = VAR27.FUN3(VAR34);
return (VAR38 * VAR12) / VAR34;
}
function FUN19(
uint256 VAR34
)
public
view
returns(
uint256 VAR36
) {
uint256 VAR37 = VAR28.FUN4(VAR14, VAR15, VAR34);
return (VAR37 * VAR12) / VAR34;
}
function FUN20(
uint256 VAR34
)
public
view
returns(
uint256 VAR36
) {
uint256 VAR38 = VAR28.FUN5(VAR14, VAR15, VAR34);
return (VAR38 * VAR12) / VAR34;
}
function FUN21(
uint256 VAR34
)
public
view
returns(
uint256 VAR36
) {
uint256 VAR39;
(VAR39,) = VAR29.FUN6(VAR21, VAR16, VAR34);
uint256 VAR37 = VAR30.FUN6(VAR16, VAR14, VAR39);
return (VAR37 * VAR12) / VAR34;
}
function FUN22(
uint256 VAR34
)
public
view
returns(
uint256 VAR36
) {
uint256 VAR40 = (VAR9 * VAR34) / VAR12;
uint256 VAR39 = VAR30.FUN6(VAR14, VAR16, VAR40);
uint256 VAR38;
(VAR38,) = VAR29.FUN6(VAR16, VAR21, VAR39);
return (VAR12 * VAR40) / VAR38;
}
function FUN23(
uint256 VAR34
)
public
view
returns(
address VAR41,
uint256 VAR36
) {
return VAR31.FUN7(VAR23, VAR14, VAR34, true);
}
function FUN24(
uint256 VAR34
)
public
view
returns(
address VAR41,
uint256 VAR36
) {
uint256 VAR42;
if (VAR43.VAR44 > VAR9 + 100) {
(,VAR42) = FUN23(VAR34);
} else {
VAR42 = VAR9;
}
uint256 VAR38;
address VAR45;
(VAR45, VAR38) = VAR31.FUN7(VAR14, VAR23, VAR34, true);
uint256 VAR37 = (VAR34 * VAR12) / VAR38;
return (VAR45, (VAR37 * VAR12) / VAR34);
}
function FUN25()
view
public
returns(
uint256 VAR36,
uint256 VAR46,
uint256 VAR47
) {
return (VAR9, VAR10, VAR11);
}
function FUN26()
external
returns(
uint256 VAR36,
uint256 VAR46,
uint256 VAR47
) {
FUN14();
return (VAR9, VAR10, VAR11);
}
function FUN14()
internal
returns(
uint256 VAR36,
uint256 VAR47
) {
uint256[3] memory VAR48 = [
FUN27(FUN17(VAR12), FUN18(VAR12)),
FUN27(FUN21(VAR12), FUN21(VAR12)),
FUN27(FUN19(VAR12), FUN20(VAR12))
];
uint256 VAR49 = FUN16(VAR17);
uint256 VAR50 = FUN15(VAR20) * VAR12 / VAR48[1];
uint256 VAR51 = FUN15(VAR18) * VAR12 / VAR48[2];
uint256 VAR52 = (VAR49 * VAR13) / 50;
uint256 VAR53 = (VAR50 * VAR13) / 50;
uint256 VAR54 = VAR51 / 2;
uint256 VAR55 = FUN19(VAR54);
uint256 VAR56 = ((VAR48[2] * 10000) / VAR55) - 10000;
if (VAR56 < VAR13 * 100) {
VAR54 += VAR51 - 1;
VAR55 = FUN19(VAR54);
VAR56 = ((VAR48[2] * 10000) / VAR55) - 10000;
}
uint256 VAR57 = VAR13 * 10000 / VAR56;
uint256 VAR58 = VAR54 * VAR57 / 100;
uint256[3] memory VAR59 = [VAR52, VAR53, VAR58];
return FUN28(VAR48, VAR59);
}
function FUN28(
uint256[3] memory VAR60,
uint256[3] memory VAR61
)
internal
returns(
uint256 VAR36,
uint256 VAR47
)
{
uint256 VAR62 = VAR61[0] + VAR61[1] + VAR61[2];
uint256 VAR63 = 10000;
uint256[3] memory VAR64;
VAR64[0] = (VAR61[0] * VAR63) / VAR62;
VAR64[1] = (VAR61[1] * VAR63) / VAR62;
VAR64[2] = (VAR61[2] * VAR63) / VAR62;
uint256 VAR65 =
(
(VAR60[0] * VAR64[0]) +
(VAR60[1] * VAR64[1]) +
(VAR60[2] * VAR64[2])
)
/ VAR63;
VAR9 = VAR65;
VAR10 = VAR43.VAR44;
VAR11 = VAR62;
return (VAR65, VAR62);
}
function FUN27(
uint256 VAR66,
uint256 VAR67
)
internal
pure
returns(
uint256 VAR68
) {
return (VAR66 + VAR67) / 2;
}
function() external {}
}
0
---------------------------------
500 0x04b227b5f44409fd48d768124925deaf2f75192e.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 28944000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xD0e05482D3E24929ffFdA2cb9A7c958d380B17aF;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
501 0x04b710d1fc77c8e7002f539bb48feb560cb2892c.sol
pragma solidity 0.4.24;
contract VAR1 {
event FUN1(uint VAR2);
event FUN2(bytes4 VAR3);
event FUN3(uint VAR2, uint value);
event FUN4(uint indexed VAR2, bytes32 VAR4, address VAR5, bytes VAR6);
}
library VAR7 {
using BytesLib for bytes;
uint256 constant VAR8 = 6;
uint16 constant VAR9 = 1;
uint16 constant VAR10 = 2;
uint16 constant VAR11 = 4;
uint16 constant VAR12 = 8;
uint16 constant VAR13 = 8192;
uint16 constant VAR14 = 16384;
uint16 constant VAR15 = 32768;
uint32 constant VAR16 = 0xFFFFFFFF;
struct VAR17 {
bytes32 VAR18;
bytes32 VAR19;
bytes VAR6;
}
struct VAR20 {
address sender;
uint VAR21;
}
event FUN5(bytes32 VAR22, uint64 VAR23, uint64 VAR24, uint16 VAR25);
event FUN6(address indexed VAR5, uint VAR26);
event FUN7(bytes32 VAR27);
event FUN8();
event FUN9();
struct VAR28 {
mapping (uint256 => VAR17) VAR29;
uint256 VAR30;
mapping (address => VAR31) VAR32;
bytes32 VAR33;
uint256 VAR34;
bytes32 VAR35;
bytes16 VAR36;
VAR20[] VAR37;
IxIface VAR38;
bool VAR39;
address VAR40;
uint256 VAR41;
}
function FUN10(DB storage VAR42) internal view {
require(VAR43 > VAR44.FUN11(VAR42.VAR34), "");
}
function FUN12(DB storage VAR42) internal view {
uint64 VAR45 = FUN13(VAR43);
uint64 VAR23;
uint64 VAR24;
(, VAR23, VAR24) = VAR44.FUN14(VAR42.VAR34);
require(VAR45 >= VAR23 && VAR45 < VAR24, "");
require(VAR42.VAR39 == false, "");
}
function FUN15(DB storage VAR42) internal view {
require(msg.sender == VAR42.VAR40, "");
}
function FUN16(DB storage VAR42) internal view {
require(FUN17(VAR44.FUN18(VAR42.VAR34)), "");
}
function FUN19() external pure returns (uint) {
return VAR8;
}
function FUN20(DB storage VAR42, bytes32 VAR22, uint256 VAR46, IxIface VAR47, address VAR40, bytes16 VAR36) external {
require(VAR42.VAR35 == bytes32(0), "");
VAR42.VAR38 = VAR47;
VAR42.VAR40 = VAR40;
uint64 VAR23;
uint64 VAR24;
uint16 VAR48;
(VAR48, VAR23, VAR24) = VAR44.FUN14(VAR46);
bool VAR49 = FUN17(VAR48);
if (VAR49) {
emit FUN8();
} else {
require(VAR24 > VAR43, "");
require(VAR48 & 0x1ff2 == 0, "");
bool VAR50 = 1 == (FUN21(VAR48) ? 1 : 0) + (FUN22(VAR48) ? 1 : 0);
require(VAR50, "");
VAR23 = VAR23 > VAR43 ? VAR23 : FUN13(VAR43);
}
require(VAR22 != bytes32(0), "");
VAR42.VAR35 = VAR22;
VAR42.VAR34 = VAR44.FUN23(VAR48, VAR23, VAR24);
VAR42.VAR41 = VAR43;
if (VAR36 != FUN24(0)) {
VAR42.VAR36 = VAR36;
}
emit FUN5(VAR42.VAR35, VAR23, VAR24, VAR48);
}
function FUN25(DB storage VAR42, uint value) internal {
VAR42.VAR37.FUN26(FUN27(msg.sender, value));
}
function FUN28(DB storage VAR42, uint VAR51) internal view returns (bytes32 VAR18, address sender, bytes VAR6, uint VAR52) {
return (VAR42.VAR29[VAR51].VAR18, address(VAR42.VAR29[VAR51].VAR19), VAR42.VAR29[VAR51].VAR6, uint(VAR42.VAR29[VAR51].VAR19) >> 160);
}
function FUN29(DB storage VAR42, address VAR5) internal view returns (VAR31) {
return VAR42.VAR32[VAR5];
}
function FUN30(DB storage VAR42) internal view returns (uint VAR53) {
for (uint VAR54 = 0; VAR54 < VAR42.VAR37.VAR55; VAR54++) {
VAR53 += VAR42.VAR37[VAR54].VAR21;
}
}
function FUN31(DB storage VAR42, uint VAR54) external view returns (address sender, uint VAR21) {
sender = VAR42.VAR37[VAR54].sender;
VAR21 = VAR42.VAR37[VAR54].VAR21;
}
function FUN32(DB storage VAR42, bytes32 VAR18, bytes VAR6) external {
FUN33(VAR42, VAR18, msg.sender, VAR6);
if (VAR42.VAR32[msg.sender] != VAR16) {
VAR42.VAR32[msg.sender] = VAR16;
}
}
function FUN34(DB storage VAR42, bytes32[5] VAR56, bytes VAR6) external returns (address VAR5) {
bytes32 VAR57 = VAR56[0];
bytes32 VAR58 = VAR56[1];
uint8 VAR59 = uint8(VAR56[2][0]);
bytes31 VAR60 = FUN35(FUN36(VAR56[2]));
bytes32 VAR2 = VAR56[3];
bytes32 VAR18 = VAR56[4];
bytes memory VAR61 = VAR62.FUN37(VAR60, VAR2, VAR18, VAR6);
bytes32 VAR63 = FUN38(VAR61);
VAR5 = FUN39(VAR63, VAR59, VAR57, VAR58);
uint32 VAR64 = FUN40(VAR60);
FUN41(VAR42, VAR5, VAR64);
FUN33(VAR42, VAR18, VAR5, VAR6);
}
function FUN33(DB storage VAR42, bytes32 VAR18, address sender, bytes VAR6) internal returns (uint256 VAR51) {
FUN12(VAR42);
VAR51 = VAR42.VAR30;
VAR42.VAR29[VAR51].VAR18 = VAR18;
VAR42.VAR29[VAR51].VAR19 = bytes32(sender) ^ bytes32(VAR43 << 160);
if (VAR6.VAR55 > 0) {
VAR42.VAR29[VAR51].VAR6 = VAR6;
}
VAR42.VAR30 += 1;
emit FUN6(sender, VAR51);
}
function FUN41(DB storage VAR42, address VAR5, uint32 VAR64) internal {
require(VAR42.VAR32[VAR5] < VAR64, "");
VAR42.VAR32[VAR5] = VAR64;
}
function FUN42(DB storage VAR42, uint64 VAR65) external {
uint16 VAR48;
uint64 VAR66;
(VAR48, VAR66,) = VAR44.FUN14(VAR42.VAR34);
VAR42.VAR34 = VAR44.FUN23(VAR48, VAR66, VAR65);
}
function FUN43(DB storage VAR42, bytes32 VAR67) internal {
VAR42.VAR33 = VAR67;
emit FUN7(VAR67);
}
uint16 constant VAR68 = 0xFFFF ^ VAR15 ^ VAR14 ^ VAR13;
function FUN21(uint16 VAR25) pure internal returns (bool) {
return FUN44(VAR25, VAR9 | VAR11);
}
function FUN22(uint16 VAR25) pure internal returns (bool) {
return FUN44(VAR25, VAR9 | VAR12);
}
function FUN45(uint16 VAR25) pure internal returns (bool) {
return (VAR25 & VAR14) == VAR14;
}
function FUN46(uint16 VAR25) pure internal returns (bool) {
return (VAR25 & VAR13) == VAR13;
}
function FUN17(uint16 VAR25) pure internal returns (bool) {
return (VAR25 & VAR15) == VAR15;
}
function FUN47(uint16 VAR25) pure internal returns (bool) {
return (VAR25 & (VAR13 | VAR14 | VAR12)) == 0;
}
function FUN44(uint16 VAR25, uint16 VAR69) pure internal returns (bool) {
uint16 VAR70 = VAR25 & VAR68;
return VAR70 == VAR69;
}
}
library VAR44 {
uint256 constant VAR71        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;
uint256 constant VAR72 = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;
uint256 constant VAR73   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;
function FUN18(uint256 VAR34) internal pure returns (uint16) {
return uint16(VAR34 >> 128);
}
function FUN48(uint256 VAR34) internal pure returns (VAR74) {
return FUN13(VAR34 >> 64);
}
function FUN11(uint256 VAR34) internal pure returns (VAR74) {
return FUN13(VAR34);
}
function FUN14(uint256 VAR34) internal pure returns (uint16 VAR25, uint64 VAR75, uint64 VAR76) {
VAR25 = uint16(VAR34 >> 128);
VAR75 = FUN13(VAR34 >> 64);
VAR76 = FUN13(VAR34);
}
function FUN23(uint16 VAR48, uint64 VAR77, uint64 VAR78) internal pure returns (uint256 VAR34) {
return uint256(VAR48) << 128 | uint256(VAR77) << 64 | uint256(VAR78);
}
function FUN49(uint256 VAR34, uint16 VAR79) internal pure returns (uint256) {
return (VAR34 & VAR71) | uint256(VAR79) << 128;
}
}
interface VAR80 {
function FUN50(bytes32 VAR81) external view returns (uint);
function FUN51(bytes32 VAR81) external;
function FUN52(address VAR82) external;
}
library VAR83 {
function FUN53(IxIface VAR47) internal view returns (address) {
return VAR47.FUN54().FUN53();
}
function FUN55(IxIface VAR47, uint256 VAR2) internal view returns (VAR84) {
bytes4 VAR85 = bytes4(VAR2 >> 48);
uint8 VAR86 = VAR47.FUN56(VAR85);
return VAR47.FUN57(VAR86);
}
function FUN58(IxIface VAR47) internal view returns (uint256) {
return VAR47.FUN59().FUN58();
}
function FUN60(IxIface VAR47, uint256 VAR87) internal view returns (bytes32) {
return VAR47.FUN59().FUN60(VAR87);
}
function FUN61(IxIface VAR47, address VAR88) internal view returns (bytes32[] VAR89) {
return VAR47.FUN59().FUN61(VAR88);
}
function FUN62(IxIface VAR47, bytes32 VAR81) internal view returns (bool) {
return VAR47.FUN54().FUN62(VAR81);
}
function FUN63(IxIface VAR47, bytes32 VAR81) internal view returns (bool) {
IxPaymentsIface VAR90 = VAR47.FUN54();
return VAR90.FUN62(VAR81) && VAR90.FUN64(VAR81);
}
function FUN65(IxIface VAR47, bytes32 VAR81) internal {
VAR47.FUN54().VAR91.value(msg.value)(VAR81);
}
function FUN66(IxIface VAR47, bytes32 VAR81) internal view returns (address) {
return VAR47.FUN59().FUN66(VAR81);
}
function FUN67(IxIface VAR47, bytes32 VAR81, address VAR92) internal view returns (bool) {
return VAR47.FUN59().FUN67(VAR81, VAR92);
}
function FUN68(IxIface VAR47, bytes32 VAR81) internal view returns (uint256) {
return VAR47.FUN59().FUN68(VAR81);
}
function FUN69(IxIface VAR47, bytes32 VAR81, uint256 VAR87) internal view returns (uint256) {
return VAR47.FUN59().FUN69(VAR81, VAR87);
}
function FUN70(IxIface VAR47, bytes32 VAR81) internal view returns (address VAR88, address VAR93, uint256 VAR94) {
return VAR47.FUN59().FUN70(VAR81);
}
function FUN71(IxIface VAR47, bytes32 VAR81) internal view returns (address VAR88) {
return VAR47.FUN59().FUN71(VAR81);
}
function FUN72(IxIface VAR47, bytes13 VAR95) internal view returns (bytes32) {
return VAR47.FUN59().FUN72(VAR95);
}
function FUN73(IxIface VAR47, bytes32 VAR81) internal view returns (uint) {
return VAR47.FUN59().FUN73(VAR81);
}
function FUN74(IxIface VAR47, bytes32 VAR81, uint VAR96) internal view returns (bool, bytes32, bool, uint) {
return VAR47.FUN59().FUN74(VAR81, VAR96);
}
function FUN75(IxIface VAR47, bytes32 VAR81, bytes VAR97) external view returns (bytes) {
return VAR47.FUN59().FUN75(VAR81, VAR97);
}
}
contract VAR98 {
uint16 constant VAR9 = 1;
uint16 constant VAR10 = 2;
uint16 constant VAR11 = 4;
uint16 constant VAR12 = 8;
uint16 constant VAR13 = 8192;
uint16 constant VAR14 = 16384;
uint16 constant VAR15 = 32768;
}
contract VAR99 {
bool private VAR100;
function FUN76(address VAR101, uint VAR21) internal {
FUN77(VAR101, "", VAR21);
}
function FUN77(address VAR101, bytes VAR102, uint VAR21) internal {
require(VAR100 == false, "");
VAR100 = true;
require(VAR101.call.value(VAR21)(VAR102), "");
VAR100 = false;
}
}
contract payoutAllC is VAR99 {
address private VAR103;
event FUN78(address VAR104, uint value);
constructor(address VAR105) public {
assert(VAR105 != address(0));
VAR103 = VAR105;
}
function FUN79() internal view returns (address) {
return VAR103;
}
function FUN80(address VAR106) internal {
VAR103 = VAR106;
}
function FUN81() external {
address VAR107 = FUN79();
uint VAR108 = address(this).VAR109;
FUN76(VAR107, VAR108);
emit FUN78(VAR107, VAR108);
}
}
contract payoutAllCSettable is VAR110 {
constructor (address VAR105) FUN82(VAR105) public {
}
function FUN83(address) external;
function FUN53() external view returns (address) {
return FUN79();
}
}
contract VAR111 {
address public VAR112;
event FUN84(address VAR113);
modifier only_owner() {
require(msg.sender == VAR112, "");
VAR114;
}
modifier FUN85(address VAR115) {
require(msg.sender == VAR115 || msg.sender == VAR112, "");
VAR114;
}
constructor() public {
VAR112 = msg.sender;
}
function FUN86(address VAR113) only_owner() external {
VAR112 = VAR113;
emit FUN84(VAR113);
}
}
contract CanReclaimToken is VAR111 {
function FUN87(ERC20Interface VAR116) external only_owner {
uint256 VAR109 = VAR116.FUN88(this);
require(VAR116.FUN89(VAR112, VAR109));
}
}
contract CommunityAuctionSimple is VAR111 {
uint public VAR117 = 1666666666000000;
struct VAR118 {
bytes32 VAR81;
uint VAR119;
}
mapping (address => VAR118[]) public VAR120;
mapping (address => address) public VAR121;
function FUN50(bytes32) external view returns (uint) {
return VAR117;
}
function FUN51(bytes32 VAR122) external {
require(VAR121[msg.sender] == address(0));
VAR120[msg.sender].FUN26(FUN90(VAR122, VAR43));
}
function FUN52(address VAR82) external {
require(VAR121[msg.sender] == address(0));
VAR121[msg.sender] = VAR82;
}
function FUN91(address VAR107) external view returns (uint) {
return VAR120[VAR107].VAR55;
}
function FUN92(uint VAR123) only_owner() external {
VAR117 = VAR123;
}
}
contract VAR124 {
function FUN93() external view returns (address);
}
contract hasAdmins is VAR111 {
mapping (uint => mapping (address => bool)) VAR125;
uint public VAR126 = 0;
bool public VAR127 = false;
address[] VAR128;
event FUN94(address indexed VAR129);
event FUN95(address indexed VAR130);
event FUN96();
event FUN97();
modifier FUN98() {
require(VAR127 == false, "");
require(FUN99(msg.sender), "");
VAR114;
}
constructor() public {
FUN100(msg.sender, true);
}
function FUN99(address VAR107) view public returns (bool) {
return VAR125[VAR126][VAR107];
}
function FUN101() view external returns (uint) {
return VAR128.VAR55;
}
function FUN102(uint VAR87) view external returns (address) {
return VAR128[VAR87];
}
function FUN103(address VAR129) FUN98() external {
require(msg.sender != VAR112, "");
FUN100(msg.sender, false);
FUN100(VAR129, true);
}
function FUN104(address VAR107, bool VAR131) FUN98() external {
require(VAR107 != msg.sender && VAR107 != VAR112, "");
FUN100(VAR107, VAR131);
}
function FUN100(address VAR107, bool VAR131) internal {
VAR125[VAR126][VAR107] = VAR131;
if (VAR131) {
emit FUN94(VAR107);
VAR128.FUN26(VAR107);
} else {
emit FUN95(VAR107);
}
}
function FUN105() only_owner() external {
VAR126++;
VAR125[VAR126][msg.sender] = true;
emit FUN96();
}
function FUN106() internal {
VAR126++;
VAR127 = true;
emit FUN97();
}
}
contract EnsOwnerProxy is VAR132 {
bytes32 public VAR133;
ENSIface public VAR134;
PublicResolver public VAR135;
constructor(bytes32 VAR136, ENSIface VAR137, PublicResolver VAR138) public {
VAR133 = VAR136;
VAR134 = VAR137;
VAR135 = VAR138;
}
function FUN107(address VAR115) FUN98() external {
FUN108(VAR115);
}
function FUN108(address VAR115) internal {
VAR135.FUN107(VAR133, VAR115);
}
function FUN109() only_owner() external {
VAR134.FUN86(VAR133, VAR112);
}
function FUN110(bytes VAR102) only_owner() external {
require(address(VAR134).call(VAR102), "");
}
function FUN111(bytes VAR102) only_owner() external {
require(address(VAR135).call(VAR102), "");
}
}
contract permissioned is VAR111, VAR132 {
mapping (address => bool) VAR139;
bool public VAR140 = false;
event FUN112(address VAR141);
event FUN113(address VAR141);
event FUN114(address VAR141);
event FUN115(address VAR142, address VAR82);
event FUN116(address VAR142, address VAR82);
event FUN117();
modifier FUN118() {
require(VAR139[msg.sender], "");
VAR114;
}
modifier FUN119() {
require(VAR140 == false, "");
VAR114;
}
constructor() FUN120() FUN121() public {
}
function FUN122(address VAR143, bool VAR144) FUN119() FUN98() external {
VAR139[VAR143] = VAR144;
if (VAR144)
emit FUN113(VAR143);
else
emit FUN114(VAR143);
}
function FUN123(address VAR142, address VAR82) FUN119() FUN98() external {
VAR139[VAR142] = false;
VAR139[VAR82] = true;
emit FUN115(VAR142, VAR82);
}
function FUN52(address VAR82) FUN118() external {
VAR139[msg.sender] = false;
VAR139[VAR82] = true;
emit FUN116(msg.sender, VAR82);
}
function FUN124(address VAR107) public view returns (bool) {
return VAR139[VAR107];
}
function FUN125() external only_owner() FUN119() {
FUN106();
VAR140 = true;
emit FUN117();
}
}
contract VAR145 {
address VAR146 = address(0);
modifier FUN126() {
require(VAR146 == address(0), "");
VAR114;
}
function FUN127() view external returns (address) {
return VAR146;
}
function FUN128(address VAR147) internal {
VAR146 = VAR147;
}
}
interface VAR148 {
function FUN129() constant external returns (uint256 VAR149);
function FUN88(address VAR150) constant external returns (uint256 VAR109);
function transfer(address VAR151, uint256 VAR152) external returns (bool VAR153);
function FUN130(address VAR154, address VAR151, uint256 VAR152) external returns (bool VAR153);
function FUN89(address VAR155, uint256 VAR152) external returns (bool VAR153);
function FUN131(address VAR150, address VAR155) constant external returns (uint256 VAR156);
event Transfer(address indexed VAR154, address indexed VAR151, uint256 VAR152);
event FUN132(address indexed VAR150, address indexed VAR155, uint256 VAR152);
}
contract VAR157 {
event FUN133(uint[2] VAR158);
event FUN134(uint8 VAR86);
event FUN135(bytes32 VAR159, address VAR82);
event FUN136(uint8 VAR86);
event FUN137(bytes32 VAR81, uint256 VAR2);
event FUN138(bytes32 VAR81, uint256 VAR2, uint256 VAR34);
event FUN1(uint VAR2);
event FUN2(bytes4 VAR3);
}
contract VAR160 {
event FUN139(bytes32 VAR81);
event FUN140(bytes32 VAR81, address VAR88);
event FUN141(bytes32 indexed VAR81, uint VAR161);
event FUN142(bytes32 indexed VAR81, address VAR112);
event FUN143(bytes32 indexed VAR81, address VAR92, bool VAR162);
event FUN144(bytes32 indexed VAR81);
event FUN145(bytes32 indexed VAR81, address VAR88);
event FUN146(bytes32 indexed VAR81, bytes32 VAR163);
event FUN147(bytes32 indexed VAR81, uint VAR164);
event FUN148(bytes32 indexed VAR81, uint VAR164);
event FUN149(bytes32 indexed VAR81, bool VAR165);
event FUN150(bytes32 indexed VAR81);
event FUN151(bytes32 indexed VAR81);
event FUN152(bytes32 indexed VAR81, address VAR113);
}
library VAR166 {
function FUN153(uint VAR107, uint VAR167) internal pure returns (uint) {
if (VAR107 < VAR167) {
return 0;
}
return VAR107 - VAR167;
}
}
contract VAR168 {
event FUN154(bytes32 indexed VAR81);
event FUN155(bytes32 indexed VAR81, uint VAR169, bytes32 VAR170);
event FUN156(bytes32 indexed VAR81, uint VAR169);
event FUN157(uint VAR21);
event FUN158(uint VAR21);
event FUN159(uint8 VAR171);
event FUN160(bytes32 indexed VAR81);
event FUN161(bytes32 indexed VAR81);
event FUN162(uint VAR172);
event FUN163(bytes32 VAR81);
event FUN164(uint VAR21);
event FUN165(bytes32 VAR81, bool VAR173);
event FUN166(bytes32 VAR81, bool VAR174);
event FUN167(address VAR104);
event FUN168(address VAR175);
event FUN169(uint VAR21);
}
interface VAR176 {
function FUN19() external pure returns (uint);
}
contract BBFarmIface is VAR1, VAR177, VAR176, VAR110 {
function FUN170() external view returns (bytes4);
function FUN171() external view returns (uint256);
function FUN172() external view returns (uint256);
function FUN173( bytes32 VAR35
, uint256 VAR34
, IxIface VAR47
, address VAR178
, bytes24 VAR36
) external returns (uint VAR2);
function FUN174(uint VAR2) external payable;
function FUN32(uint VAR2, bytes32 VAR4, bytes VAR6) external;
function FUN34(bytes32[5] VAR56, bytes VAR6) external;
function FUN175(uint VAR2, address VAR5) external view returns
( bool VAR179
, uint VAR30
, bytes32 VAR180
, uint16 VAR25
, uint64 VAR75
, uint64 VAR76
, bytes32 VAR35
, bool VAR39
, address VAR40
, bytes16 VAR36);
function FUN28(uint VAR2, uint VAR26) external view returns (bytes32 VAR18, address sender, bytes VAR6);
function FUN30(uint VAR2) external view returns (uint);
function FUN176(uint VAR2) external view returns (uint);
function FUN31(uint VAR2, uint VAR181) external view returns (address sender, uint VAR21);
function FUN177(uint VAR2) external view returns (uint);
function FUN43(uint VAR2, bytes32 VAR67) external;
function FUN42(uint VAR2, uint64 VAR65) external;
function FUN178(uint VAR2) external;
function FUN179(uint VAR2, address VAR113) external;
}
contract BBFarm is VAR84 {
using BBLib for VAR7.VAR28;
using IxLib for VAR182;
bytes4 constant VAR183 = 0x00000001;
uint256 constant VAR184 = 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
uint constant VAR185 = 2;
mapping (VAR186 => VAR7.VAR28) VAR187;
uint VAR188 = 0;
modifier FUN180(uint VAR2) {
require(bytes4(VAR2 >> 224) == VAR183, "");
VAR114;
}
constructor() FUN82(msg.sender) public {
assert(VAR7.FUN19() == 6);
emit FUN2(VAR183);
}
function FUN79() internal view returns (address) {
return VAR112;
}
function FUN19() external pure returns (uint) {
return VAR185;
}
function FUN170() external view returns (bytes4) {
return VAR183;
}
function FUN171() external view returns (uint256) {
return VAR7.FUN19();
}
function FUN172() external view returns (uint256) {
return VAR188;
}
function FUN181(uint VAR2) internal view returns (VAR7.DB VAR189) {
return VAR187[FUN182(VAR2)];
}
function FUN173( bytes32 VAR35
, uint256 VAR34
, IxIface VAR47
, address VAR178
, bytes24 VAR36
) FUN118() external returns (uint VAR2) {
VAR2 = FUN182(VAR35) ^ (uint256(VAR183) << 224);
FUN181(VAR2).FUN20(VAR35, VAR34, VAR47, VAR178, FUN24(uint128(VAR36)));
VAR188 += 1;
emit FUN1(VAR2);
}
function FUN174(uint VAR2) external payable {
VAR7.DB storage VAR42 = FUN181(VAR2);
VAR42.FUN25(msg.value);
FUN76(VAR42.VAR38.FUN53(), msg.value);
emit FUN3(VAR2, msg.value);
}
function FUN32(uint VAR2, bytes32 VAR4, bytes VAR6) FUN180(VAR2) external {
FUN181(VAR2).FUN32(VAR4, VAR6);
emit FUN4(VAR2, VAR4, msg.sender, VAR6);
}
function FUN34(bytes32[5] VAR56, bytes VAR6) FUN180(uint256(VAR56[3])) external {
uint VAR2 = uint256(VAR56[3]);
address VAR5 = FUN181(VAR2).FUN34(VAR56, VAR6);
bytes32 VAR4 = VAR56[4];
emit FUN4(VAR2, VAR4, VAR5, VAR6);
}
function FUN175(uint VAR2, address VAR5) external view returns
( bool VAR179
, uint VAR30
, bytes32 VAR180
, uint16 VAR25
, uint64 VAR75
, uint64 VAR76
, bytes32 VAR35
, bool VAR39
, address VAR40
, bytes16 VAR36) {
VAR7.DB storage VAR42 = FUN181(VAR2);
uint VAR34 = VAR42.VAR34;
return (
VAR42.FUN29(VAR5) > 0,
VAR42.VAR30,
VAR42.VAR33,
VAR44.FUN18(VAR34),
VAR44.FUN48(VAR34),
VAR44.FUN11(VAR34),
VAR42.VAR35,
VAR42.VAR39,
VAR42.VAR40,
VAR42.VAR36
);
}
function FUN28(uint VAR2, uint VAR26) external view returns (bytes32 VAR18, address sender, bytes VAR6) {
(VAR18, sender, VAR6, ) = FUN181(VAR2).FUN28(VAR26);
}
function FUN29(uint VAR2, address VAR5) external view returns (uint32 VAR64) {
return FUN181(VAR2).FUN29(VAR5);
}
function FUN30(uint VAR2) external view returns (uint) {
return FUN181(VAR2).FUN30();
}
function FUN176(uint VAR2) external view returns (uint) {
return FUN181(VAR2).VAR37.VAR55;
}
function FUN31(uint VAR2, uint VAR181) external view returns (address sender, uint VAR21) {
return FUN181(VAR2).FUN31(VAR181);
}
function FUN177(uint VAR2) external view returns (uint) {
return FUN181(VAR2).VAR41;
}
function FUN43(uint VAR2, bytes32 VAR67) external {
VAR7.DB storage VAR42 = FUN181(VAR2);
VAR42.FUN15();
VAR42.FUN10();
VAR42.FUN43(VAR67);
}
function FUN42(uint VAR2, uint64 VAR65) external {
VAR7.DB storage VAR42 = FUN181(VAR2);
VAR42.FUN15();
VAR42.FUN16();
VAR42.FUN42(VAR65);
}
function FUN178(uint VAR2) external {
VAR7.DB storage VAR42 = FUN181(VAR2);
VAR42.FUN15();
VAR42.VAR39 = true;
}
function FUN179(uint VAR2, address VAR113) external {
VAR7.DB storage VAR42 = FUN181(VAR2);
VAR42.FUN15();
VAR42.VAR40 = VAR113;
}
}
contract IxIface is VAR176,
VAR168,
VAR160,
VAR157,
VAR98,
VAR111,
VAR190,
VAR145,
VAR110 {
function FUN183(BBFarmIface VAR191) external returns (uint8 VAR86);
function FUN184(bytes32 VAR192, address VAR82) external;
function FUN185(uint8 VAR86, BBFarmIface VAR193) external;
function FUN54() external view returns (VAR194);
function FUN59() external view returns (VAR195);
function FUN57(uint8 VAR86) external view returns (VAR84);
function FUN56(bytes4 VAR85) external view returns (uint8 VAR86);
function FUN186() external view returns (VAR80);
function FUN187(address VAR196, bool VAR197) external payable returns (bytes32);
function FUN188(bytes32 VAR81, address VAR92, bool VAR162) external;
function FUN189(bytes32 VAR81) external;
function FUN190(bytes32 VAR81, address VAR113) external;
function FUN191(bytes32 VAR81) external;
function FUN192(bytes32 VAR81, address VAR198) external;
function FUN193(bytes32 VAR81, bytes32 VAR199, bool VAR200, uint VAR201) external;
function FUN194(bytes32 VAR81, uint VAR96) external;
function FUN195(bytes32 VAR81) external;
function FUN196(bytes32 VAR81) external;
function FUN197(bytes32 VAR81, bytes VAR97, bytes value) external;
function FUN198(bytes32 VAR81, bool VAR165) external;
function FUN199(bytes32 VAR81) external;
function FUN200(bytes32 VAR81, uint VAR2, uint256 VAR34) external;
function FUN201(bytes32 VAR81, bytes32 VAR35, bytes32 VAR36, uint128 VAR202) external payable;
function FUN202(bytes32 VAR81, bytes32 VAR35, bytes32 VAR36, uint256 VAR34) external payable;
}
contract SVIndex is VAR182 {
uint256 constant VAR185 = 2;
bytes4 constant VAR203 = 0x8da5cb5b;
bytes4 constant VAR204 = 0xf77c4791;
IxBackendIface VAR205;
IxPaymentsIface VAR90;
EnsOwnerProxy public VAR206;
VAR84[] VAR207;
CommAuctionIface VAR208;
mapping (bytes4 => uint8) VAR209;
mapping (uint8 => bool) VAR210;
modifier FUN203(bytes32 VAR81) {
require(msg.sender == VAR205.FUN66(VAR81), "");
VAR114;
}
modifier FUN204(bytes32 VAR81) {
require(VAR205.FUN67(VAR81, msg.sender), "");
VAR114;
}
constructor( IxBackendIface VAR211
, IxPaymentsIface VAR212
, EnsOwnerProxy VAR213
, BBFarmIface VAR214
, CommAuctionIface VAR215
) FUN82(msg.sender) public {
VAR205 = VAR211;
VAR90 = VAR212;
VAR206 = VAR213;
FUN205(0x0, VAR214);
VAR208 = VAR215;
}
function FUN79() internal view returns (address) {
return VAR90.FUN53();
}
function FUN206(address VAR147) only_owner() FUN126() external {
FUN128(VAR147);
VAR205.FUN52(VAR147);
VAR90.FUN52(VAR147);
VAR206.FUN107(VAR147);
VAR206.FUN103(VAR147);
VAR208.FUN52(VAR147);
for (uint VAR54 = 0; VAR54 < VAR207.VAR55; VAR54++) {
VAR207[VAR54].FUN52(VAR147);
}
}
function FUN205(bytes4 VAR85, BBFarmIface VAR193) internal returns (uint8 VAR86) {
uint256 VAR216 = VAR207.VAR55;
require(VAR216 < 2**8, "");
VAR86 = uint8(VAR216);
VAR207.FUN26(VAR193);
VAR209[VAR85] = VAR86;
emit FUN134(VAR86);
}
function FUN183(BBFarmIface VAR191) only_owner() external returns (uint8 VAR86) {
bytes4 VAR85 = VAR191.FUN170();
require(VAR85 != bytes4(0), "");
require(VAR209[VAR85] == 0 && VAR85 != VAR207[0].FUN170(), "");
VAR86 = FUN205(VAR85, VAR191);
}
function FUN184(bytes32 VAR192, address VAR82) only_owner() external {
emit FUN135(VAR192, VAR82);
if (VAR192 == bytes32("")) {
VAR90 = FUN207(VAR82);
} else if (VAR192 == bytes32("")) {
VAR205 = FUN208(VAR82);
} else if (VAR192 == bytes32("")) {
VAR208 = FUN209(VAR82);
} else {
revert("");
}
}
function FUN185(uint8 VAR86, BBFarmIface VAR193) only_owner() external {
require(address(VAR193) != address(0));
require(VAR207[VAR86] == VAR193);
VAR210[VAR86] = true;
emit FUN136(VAR86);
}
function FUN54() external view returns (VAR194) {
return VAR90;
}
function FUN59() external view returns (VAR195) {
return VAR205;
}
function FUN57(uint8 VAR86) external view returns (VAR84) {
return VAR207[VAR86];
}
function FUN56(bytes4 VAR85) external view returns (uint8 VAR86) {
return VAR209[VAR85];
}
function FUN186() external view returns (VAR80) {
return VAR208;
}
function FUN19() external pure returns (uint256) {
return VAR185;
}
function FUN187(address VAR217, bool VAR197) FUN126() external payable returns (bytes32) {
require(msg.value >= VAR90.FUN210());
bytes32 VAR81 = VAR205.FUN187(VAR217, msg.sender, VAR197);
VAR90.VAR91.value(msg.value)(VAR81);
return VAR81;
}
function FUN188(bytes32 VAR81, address VAR92, bool VAR162) FUN203(VAR81) external {
VAR205.FUN188(VAR81, VAR92, VAR162);
}
function FUN189(bytes32 VAR81) FUN203(VAR81) external {
VAR205.FUN189(VAR81);
}
function FUN190(bytes32 VAR81, address VAR113) FUN203(VAR81) external {
VAR205.FUN190(VAR81, VAR113);
}
function FUN191(bytes32 VAR81) external {
address VAR88 = VAR205.FUN71(VAR81);
if (VAR88.call.FUN211(3000)(VAR203)) {
require(msg.sender == FUN120(VAR88).VAR112.FUN211(3000)(), "");
} else if (VAR88.call.FUN211(3000)(VAR204)) {
require(msg.sender == FUN212(VAR88).VAR218.FUN211(3000)(), "");
} else {
revert();
}
VAR205.FUN213(VAR81, msg.sender);
}
function FUN192(bytes32 VAR81, address VAR198) FUN203(VAR81) external {
VAR205.FUN192(VAR81, VAR198);
}
function FUN193(bytes32 VAR81, bytes32 VAR219, bool VAR200, uint VAR201) FUN204(VAR81) external {
VAR205.FUN193(VAR81, VAR219, VAR200, VAR201);
}
function FUN194(bytes32 VAR81, uint VAR164) FUN204(VAR81) external {
VAR205.FUN194(VAR81, VAR164);
}
function FUN195(bytes32 VAR81) FUN203(VAR81) external {
VAR90.FUN214(VAR81);
}
function FUN196(bytes32 VAR81) FUN203(VAR81) external {
VAR90.FUN215(VAR81);
}
function FUN197(bytes32 VAR81, bytes VAR97, bytes value) external {
if (msg.sender == VAR205.FUN66(VAR81)) {
VAR205.FUN197(VAR81, VAR97, value);
} else if (VAR205.FUN67(VAR81, msg.sender)) {
VAR205.FUN216(VAR81, VAR97, value);
} else {
revert();
}
}
function FUN198(bytes32 VAR81, bool VAR165) FUN203(VAR81) external {
VAR205.FUN198(VAR81, VAR165);
}
function FUN199(bytes32 VAR81) FUN203(VAR81) external {
VAR205.FUN199(VAR81);
}
function FUN200(bytes32 VAR81, uint VAR2, uint256 VAR34)
only_owner()
external {
FUN217(VAR81, VAR2, VAR34, false);
emit FUN138(VAR81, VAR2, VAR34);
}
function FUN218(bytes32 VAR81, bytes32 VAR35, bytes32 VAR36, uint VAR34, bool VAR220, bool VAR221) internal returns (uint VAR2) {
require(VAR7.FUN17(VAR44.FUN18(VAR34)) == false, "");
uint8 VAR86 = uint8(VAR36[0]);
require(VAR210[VAR86] == false, "");
BBFarmIface VAR193 = VAR207[VAR86];
bool VAR222 = VAR220;
bool VAR223;
if (VAR220) {
uint64 VAR76 = VAR44.FUN11(VAR34);
(VAR222, VAR223) = FUN219(VAR81, VAR193);
FUN220(VAR81, VAR76);
}
if (!VAR223 && msg.value > 0 && VAR221 == false) {
FUN76(msg.sender, msg.value);
}
VAR2 = VAR193.FUN173(
VAR35,
VAR34,
this,
msg.sender,
FUN221(FUN222(VAR36)));
FUN217(VAR81, VAR2, VAR34, VAR222);
}
function FUN201(bytes32 VAR81, bytes32 VAR35, bytes32 VAR36, uint128 VAR202) external payable {
uint VAR224 = VAR208.FUN50(VAR81);
require(msg.value >= VAR224, "");
FUN76(VAR90.FUN53(), VAR224);
FUN76(msg.sender, msg.value - VAR224);
bool VAR225 = VAR205.FUN223(VAR81) || !VAR90.FUN62(VAR81);
require(VAR225, "");
uint256 VAR34 = VAR44.FUN49(uint256(VAR202), (VAR9 | VAR11));
uint VAR2 = FUN218(VAR81, VAR35, VAR36, VAR34, false, true);
VAR208.FUN51(VAR81);
emit FUN137(VAR81, VAR2);
}
function FUN202(bytes32 VAR81, bytes32 VAR35, bytes32 VAR36, uint256 VAR34)
FUN204(VAR81)
external payable {
FUN218(VAR81, VAR35, VAR36, VAR34, true, false);
}
function FUN217(bytes32 VAR81, uint256 VAR2, uint256 VAR34, bool VAR222) internal {
VAR205.FUN200(VAR81, VAR2, VAR34, VAR222);
}
function FUN220(bytes32 VAR81, uint64 VAR76) internal view {
uint VAR226 = VAR90.FUN224(VAR81);
uint256 VAR227 = VAR76 - VAR43;
require(VAR226 * 2 > VAR227, "");
}
function FUN219(bytes32 VAR81, BBFarmIface VAR193) internal returns (bool VAR228, bool VAR223) {
if (VAR90.FUN64(VAR81) == false) {
uint VAR229 = VAR90.FUN225();
uint VAR230 = VAR205.FUN226(VAR81);
if (VAR229 > VAR230) {
return (true, false);
}
uint VAR231 = VAR205.FUN227(VAR81, VAR230 - VAR229);
uint VAR232 = VAR193.FUN177(VAR231);
if (VAR232 < VAR43 - 30 VAR233) {
return (true, false);
}
uint VAR234 = VAR90.FUN228();
require(msg.value >= VAR234, "");
uint VAR235 = msg.value - VAR234;
FUN76(address(VAR90), VAR234);
FUN76(msg.sender, VAR235);
emit FUN133([VAR234, VAR235]);
return (false, true);
} else {
return (false, false);
}
}
}
contract IxBackendIface is VAR176, VAR160, VAR177, VAR110 {
function FUN58() external view returns (uint);
function FUN60(uint VAR51) external view returns (bytes32);
function FUN61(address VAR88) external view returns (bytes32[] VAR89);
function FUN229(bytes32 VAR81, address VAR88, bool VAR197) external;
function FUN230(bytes32 VAR81, address VAR113) external;
function FUN187(address VAR217, address VAR236, bool VAR197) external returns (bytes32 VAR81);
function FUN190(bytes32 VAR81, address VAR113) external;
function FUN213(bytes32 VAR81, address VAR113) external;
function FUN188(bytes32 VAR81, address VAR92, bool VAR162) external;
function FUN189(bytes32 VAR81) external;
function FUN192(bytes32 VAR81, address VAR198) external;
function FUN197(bytes32 VAR81, bytes VAR97, bytes value) external;
function FUN216(bytes32 VAR81, bytes VAR97, bytes value) external;
function FUN193(bytes32 VAR81, bytes32 VAR199, bool VAR200, uint VAR201) external;
function FUN194(bytes32 VAR81, uint VAR164) external;
function FUN198(bytes32 VAR81, bool VAR165) external;
function FUN199(bytes32 VAR81) external;
function FUN200(bytes32 VAR81, uint VAR2, uint256 VAR34, bool VAR222) external;
function FUN66(bytes32 VAR81) external view returns (address);
function FUN67(bytes32 VAR81, address VAR92) external view returns (bool);
function FUN72(bytes13 VAR95) external view returns (bytes32);
function FUN70(bytes32 VAR81) external view returns (address VAR88, address VAR112, uint256 VAR188);
function FUN71(bytes32 VAR81) external view returns (address);
function FUN75(bytes32 VAR81, bytes VAR97) external view returns (bytes value);
function FUN231(bytes32 VAR81, bytes VAR97) external view returns (bytes value);
function FUN68(bytes32 VAR81) external view returns (uint256);
function FUN69(bytes32 VAR81, uint VAR87) external view returns (uint VAR2);
function FUN226(bytes32 VAR81) external view returns (uint256);
function FUN227(bytes32 VAR81, uint256 VAR87) external view returns (uint256);
function FUN73(bytes32 VAR81) external view returns (uint);
function FUN74(bytes32 VAR81, uint VAR164) external view returns (bool VAR39, bytes32 VAR237, bool VAR200, uint VAR201);
function FUN223(bytes32 VAR81) external view returns (bool);
function FUN232(bytes32 VAR81) external view returns (bool);
}
contract SVIndexBackend is VAR195 {
uint constant VAR185 = 2;
struct VAR238 {
address VAR88;
address VAR112;
bool VAR239;
bool VAR240;
uint VAR241;
mapping (uint => mapping (address => bool)) VAR242;
uint256[] VAR243;
uint256[] VAR244;
}
struct VAR245 {
bytes32 VAR81;
uint VAR2;
}
struct VAR246 {
bool VAR39;
bytes32 VAR237;
bool VAR200;
uint VAR201;
}
struct VAR247 {
uint VAR248;
mapping(uint => VAR246) VAR249;
}
mapping (bytes32 => VAR238) VAR250;
mapping (bytes32 => VAR247) VAR251;
mapping (VAR252 => bytes32) VAR253;
mapping (address => bytes32[]) VAR254;
bytes32[] VAR255;
mapping (bytes32 => mapping (bytes32 => bytes)) VAR256;
constructor() FUN82(msg.sender) public {
}
function FUN79() internal view returns (address) {
return VAR112;
}
function FUN19() external pure returns (uint) {
return VAR185;
}
function FUN58() external view returns (uint) {
return VAR255.VAR55;
}
function FUN60(uint VAR51) external view returns (bytes32) {
return VAR255[VAR51];
}
function FUN61(address VAR88) external view returns (bytes32[] VAR89) {
return VAR254[VAR88];
}
function FUN233(bytes32 VAR81, address VAR88, address VAR236, bool VAR197) internal {
VAR255.FUN26(VAR81);
Democ storage VAR122 = VAR250[VAR81];
VAR122.VAR88 = VAR88;
if (VAR197) {
VAR122.VAR240 = true;
}
assert(VAR253[FUN234(VAR81)] == bytes32(0));
VAR253[FUN234(VAR81)] = VAR81;
VAR254[VAR88].FUN26(VAR81);
FUN235(VAR81, VAR236);
emit FUN139(VAR81);
}
function FUN229(bytes32 VAR81, address VAR88, bool VAR197) only_owner() external {
FUN233(VAR81, VAR88, msg.sender, VAR197);
emit FUN140(VAR81, VAR88);
}
function FUN230(bytes32 VAR81, address VAR113) only_owner() external {
FUN235(VAR81, VAR113);
emit FUN152(VAR81, VAR113);
}
function FUN187(address VAR217, address VAR236, bool VAR197) FUN118() external returns (bytes32 VAR81) {
VAR81 = FUN38(VAR62.FUN37(VAR255.VAR55, FUN236(VAR257.VAR258-1), VAR217, VAR43));
FUN233(VAR81, VAR217, VAR236, VAR197);
}
function FUN235(bytes32 VAR81, address VAR113) internal {
Democ storage VAR122 = VAR250[VAR81];
uint VAR259 = VAR122.VAR241;
VAR122.VAR112 = VAR113;
VAR122.VAR242[VAR259][VAR122.VAR112] = false;
VAR122.VAR242[VAR259][VAR113] = true;
emit FUN142(VAR81, VAR113);
}
function FUN190(bytes32 VAR81, address VAR113) FUN118() external {
FUN235(VAR81, VAR113);
}
function FUN213(bytes32 VAR81, address VAR113) FUN118() external {
Democ storage VAR122 = VAR250[VAR81];
require(VAR122.VAR240 == false, "");
VAR122.VAR112 = VAR113;
VAR122.VAR242[VAR122.VAR241][VAR113] = true;
VAR122.VAR240 = true;
emit FUN142(VAR81, VAR113);
emit FUN151(VAR81);
}
function FUN188(bytes32 VAR81, address VAR92, bool VAR162) FUN118() external {
Democ storage VAR122 = VAR250[VAR81];
VAR122.VAR242[VAR122.VAR241][VAR92] = VAR162;
emit FUN143(VAR81, VAR92, VAR162);
}
function FUN189(bytes32 VAR81) FUN118() external {
VAR250[VAR81].VAR241 += 1;
emit FUN144(VAR81);
}
function FUN192(bytes32 VAR81, address VAR198) FUN118() external {
VAR250[VAR81].VAR88 = VAR198;
VAR254[VAR198].FUN26(VAR81);
emit FUN145(VAR81, VAR198);
}
function FUN197(bytes32 VAR81, bytes VAR97, bytes value) FUN118() external {
bytes32 VAR260 = FUN38(VAR97);
VAR256[VAR81][VAR260] = value;
emit FUN146(VAR81, VAR260);
}
function FUN216(bytes32 VAR81, bytes VAR97, bytes value) FUN118() external {
bytes32 VAR260 = FUN38(FUN237(VAR97));
VAR256[VAR81][VAR260] = value;
emit FUN146(VAR81, VAR260);
}
function FUN193(bytes32 VAR81, bytes32 VAR237, bool VAR200, uint VAR201) FUN118() external {
uint VAR164 = VAR251[VAR81].VAR248;
VAR251[VAR81].VAR249[VAR164].VAR237 = VAR237;
if (VAR200) {
VAR251[VAR81].VAR249[VAR164].VAR200 = true;
VAR251[VAR81].VAR249[VAR164].VAR201 = VAR201;
}
VAR251[VAR81].VAR248 += 1;
emit FUN147(VAR81, VAR164);
}
function FUN194(bytes32 VAR81, uint VAR164) FUN118() external {
VAR251[VAR81].VAR249[VAR164].VAR39 = true;
emit FUN148(VAR81, VAR164);
}
function FUN198(bytes32 VAR81, bool VAR165) FUN118() external {
VAR250[VAR81].VAR239 = !VAR165;
emit FUN149(VAR81, VAR165);
}
function FUN199(bytes32 VAR81) FUN118() external {
VAR250[VAR81].VAR240 = true;
emit FUN150(VAR81);
}
function FUN238(bytes32 VAR81, uint VAR2, uint256 VAR34, bool VAR222) internal {
uint16 VAR261;
VAR261 = VAR44.FUN18(VAR34);
uint VAR262 = VAR250[VAR81].VAR243.VAR55;
VAR250[VAR81].VAR243.FUN26(VAR2);
if (VAR222) {
VAR250[VAR81].VAR244.FUN26(VAR2);
}
emit FUN141(VAR81, VAR262);
}
function FUN200(bytes32 VAR81, uint VAR2, uint256 VAR34, bool VAR222) FUN118() external {
FUN238(VAR81, VAR2, VAR34, VAR222);
}
function FUN66(bytes32 VAR81) external view returns (address) {
return VAR250[VAR81].VAR112;
}
function FUN67(bytes32 VAR81, address VAR92) external view returns (bool) {
Democ storage VAR122 = VAR250[VAR81];
return VAR122.VAR242[VAR122.VAR241][VAR92] || VAR92 == VAR122.VAR112;
}
function FUN72(bytes13 VAR95) external view returns (bytes32) {
return VAR253[VAR95];
}
function FUN70(bytes32 VAR81) external view returns (address VAR88, address VAR112, uint256 VAR188) {
return (VAR250[VAR81].VAR88, VAR250[VAR81].VAR112, VAR250[VAR81].VAR243.VAR55);
}
function FUN71(bytes32 VAR81) external view returns (address) {
return VAR250[VAR81].VAR88;
}
function FUN75(bytes32 VAR81, bytes VAR97) external view returns (bytes) {
return VAR256[VAR81][FUN38(VAR97)];
}
function FUN231(bytes32 VAR81, bytes VAR97) external view returns (bytes) {
return VAR256[VAR81][FUN38(FUN237(VAR97))];
}
function FUN68(bytes32 VAR81) external view returns (uint256) {
return VAR250[VAR81].VAR243.VAR55;
}
function FUN69(bytes32 VAR81, uint256 VAR87) external view returns (uint VAR2) {
return VAR250[VAR81].VAR243[VAR87];
}
function FUN226(bytes32 VAR81) external view returns (uint256) {
return VAR250[VAR81].VAR244.VAR55;
}
function FUN227(bytes32 VAR81, uint256 VAR87) external view returns (uint256) {
return VAR250[VAR81].VAR244[VAR87];
}
function FUN73(bytes32 VAR81) external view returns (uint) {
return VAR251[VAR81].VAR248;
}
function FUN74(bytes32 VAR81, uint VAR164) external view returns (bool VAR39, bytes32 VAR237, bool VAR200, uint256 VAR201) {
VAR39 = VAR251[VAR81].VAR249[VAR164].VAR39;
VAR237 = VAR251[VAR81].VAR249[VAR164].VAR237;
VAR200 = VAR251[VAR81].VAR249[VAR164].VAR200;
VAR201 = VAR251[VAR81].VAR249[VAR164].VAR201;
}
function FUN223(bytes32 VAR81) external view returns (bool) {
return !VAR250[VAR81].VAR239;
}
function FUN232(bytes32 VAR81) external view returns (bool) {
return !VAR250[VAR81].VAR240;
}
function FUN237(bytes VAR97) internal pure returns (bytes) {
return VAR62.FUN37("", VAR97);
}
}
contract IxPaymentsIface is VAR176, VAR168, VAR177, VAR190, VAR263 {
function FUN239(address VAR113) external;
function FUN240(uint VAR21) public view returns (uint VAR264);
function FUN241(uint VAR265) public view returns (uint);
function FUN242(uint VAR266) public view returns (uint);
function FUN65(bytes32 VAR81) external payable;
function FUN243(bytes32 VAR81) external;
function FUN215(bytes32 VAR81) external;
function FUN214(bytes32 VAR81) external;
function FUN62(bytes32 VAR81) external view returns (bool);
function FUN224(bytes32 VAR81) external view returns (uint);
function FUN64(bytes32 VAR81) external view returns (bool);
function FUN244(bytes32 VAR81) external view returns (bool);
function FUN245(bytes32 VAR81) external view returns (bool VAR267, uint VAR268, uint VAR269, bool VAR270);
function FUN246(bytes32 VAR81) external view returns (bool);
function FUN247(bytes32 VAR81, uint VAR169, bytes32 VAR170) external;
function FUN83(address) external;
function FUN248(address) external;
function FUN249(uint VAR21) external;
function FUN250(uint VAR21) external;
function FUN251(uint8 VAR21) external;
function FUN252(uint) external;
function FUN253(bytes32 VAR81, bool VAR173) external;
function FUN254(bytes32 VAR81, bool VAR174) external;
function FUN255(uint VAR21) external;
function FUN256() external view returns(uint);
function FUN228() external view returns (uint);
function FUN225() external view returns (uint);
function FUN257() external view returns (uint8);
function FUN258() external view returns (uint);
function FUN259() external view returns (uint VAR172);
function FUN260() external view returns (uint VAR271);
function FUN210() external view returns (uint);
function FUN261() external view returns (uint);
function FUN262(uint VAR87) external view returns (bool VAR272, bytes32 VAR273, uint VAR274, uint VAR275);
}
contract SVPayments is VAR194 {
uint constant VAR185 = 2;
struct VAR276 {
bool VAR267;
uint VAR268;
uint VAR269;
uint VAR277;
}
struct VAR278 {
bool VAR272;
bytes32 VAR273;
uint VAR274;
uint VAR275;
}
address public VAR175;
uint VAR279 = 125000;
uint VAR280 = 10;
uint8 VAR281 = 5;
uint VAR172 = 0.000016583747 VAR282;
uint VAR283 = 1;
mapping (bytes32 => VAR276) VAR284;
VAR278[] VAR90;
mapping (bytes32 => bool) VAR285;
mapping (bytes32 => bool) VAR286;
address public VAR287;
function FUN239(address VAR113) external {
require(msg.sender == VAR287, "");
VAR112 = VAR113;
}
constructor(address VAR288) FUN263(msg.sender) public {
VAR287 = VAR288;
assert(VAR288 != address(0));
}
function FUN19() external pure returns (uint) {
return VAR185;
}
function() payable public {
FUN79().transfer(msg.value);
}
function FUN264(bytes32 VAR81, uint VAR169) internal {
uint VAR289 = VAR284[VAR81].VAR269;
if (VAR289 < VAR43) {
VAR289 = VAR43;
}
VAR284[VAR81].VAR269 = VAR289 + VAR169;
VAR284[VAR81].VAR268 = VAR43;
}
function FUN240(uint VAR21) public view returns (uint) {
uint VAR290 = FUN241(VAR21);
uint VAR291 = ((10 ** 18) * VAR290) / VAR279;
uint VAR292 = VAR291 * (30 VAR233);
uint VAR169 = VAR292 / (10 ** 18);
return VAR169;
}
function FUN241(uint VAR265) public view returns (uint) {
return VAR265 / VAR172;
}
function FUN242(uint VAR266) public view returns (uint) {
return VAR266 * VAR172;
}
function FUN65(bytes32 VAR81) external payable {
require(msg.value > 0, "");
uint VAR169 = FUN240(msg.value);
if (VAR284[VAR81].VAR267) {
VAR169 /= VAR281;
}
if (VAR169 >= 1) {
FUN264(VAR81, VAR169);
}
VAR90.FUN26(FUN265(false, VAR81, VAR169, msg.value));
emit FUN156(VAR81, VAR169);
FUN79().transfer(msg.value);
}
function FUN243(bytes32 VAR81) external {
require(VAR286[VAR81], "");
uint VAR293 = VAR43 + 60 VAR233;
VAR284[VAR81].VAR269 = VAR293;
emit FUN163(VAR81);
}
function FUN215(bytes32 VAR81) FUN118() external {
require(VAR284[VAR81].VAR267, "");
VAR284[VAR81].VAR267 = false;
uint VAR294 = VAR284[VAR81].VAR269;
uint VAR295 = VAR166.FUN153(VAR294, VAR43);
if (VAR295 > 0) {
require(VAR284[VAR81].VAR277 < (VAR43 - 24 VAR296), "");
VAR295 *= VAR281;
VAR284[VAR81].VAR269 = VAR43 + VAR295;
}
emit FUN160(VAR81);
}
function FUN214(bytes32 VAR81) FUN118() external {
require(VAR285[VAR81] == false, "");
require(!VAR284[VAR81].VAR267, "");
VAR284[VAR81].VAR267 = true;
uint VAR294 = VAR284[VAR81].VAR269;
uint VAR295 = VAR166.FUN153(VAR294, VAR43);
if (VAR295 > 0) {
VAR295 /= VAR281;
VAR284[VAR81].VAR269 = VAR43 + VAR295;
}
VAR284[VAR81].VAR277 = VAR43;
emit FUN154(VAR81);
}
function FUN62(bytes32 VAR81) external view returns (bool) {
return VAR284[VAR81].VAR269 >= VAR43;
}
function FUN224(bytes32 VAR81) external view returns (uint) {
return VAR166.FUN153(VAR284[VAR81].VAR269, VAR43);
}
function FUN64(bytes32 VAR81) external view returns (bool) {
return VAR284[VAR81].VAR267;
}
function FUN244(bytes32 VAR81) external view returns (bool) {
return VAR286[VAR81];
}
function FUN245(bytes32 VAR81) external view returns (bool VAR267, uint VAR268, uint VAR269, bool VAR270) {
VAR267 = VAR284[VAR81].VAR267;
VAR268 = VAR284[VAR81].VAR268;
VAR269 = VAR284[VAR81].VAR269;
VAR270 = VAR286[VAR81];
}
function FUN246(bytes32 VAR81) external view returns (bool) {
return VAR285[VAR81];
}
function FUN247(bytes32 VAR81, uint VAR169, bytes32 VAR170) FUN85(VAR175) external {
FUN264(VAR81, VAR169);
VAR90.FUN26(FUN265(true, VAR81, VAR169, 0));
emit FUN155(VAR81, VAR169, VAR170);
}
function FUN83(address VAR106) only_owner() external {
FUN80(VAR106);
emit FUN167(VAR106);
}
function FUN248(address VAR107) only_owner() external {
VAR175 = VAR107;
emit FUN168(VAR107);
}
function FUN249(uint VAR21) only_owner() external {
VAR279 = VAR21;
emit FUN158(VAR21);
}
function FUN250(uint VAR21) only_owner() external {
VAR280 = VAR21;
emit FUN164(VAR21);
}
function FUN251(uint8 VAR297) only_owner() external {
VAR281 = VAR297;
emit FUN159(VAR297);
}
function FUN252(uint VAR298) FUN85(VAR175) external {
VAR172 = VAR298;
emit FUN162(VAR298);
}
function FUN253(bytes32 VAR81, bool VAR173) FUN85(VAR175) external {
VAR286[VAR81] = VAR173;
emit FUN165(VAR81, VAR173);
}
function FUN254(bytes32 VAR81, bool VAR174) FUN85(VAR175) external {
VAR285[VAR81] = VAR174;
emit FUN166(VAR81, VAR174);
}
function FUN255(uint VAR21) FUN85(VAR175) external {
VAR283 = VAR21;
emit FUN169(VAR21);
}
function FUN256() external view returns (uint) {
return VAR279;
}
function FUN228() external view returns (uint) {
return FUN242(VAR279 / VAR280);
}
function FUN225() external view returns (uint) {
return VAR280;
}
function FUN257() external view returns (uint8) {
return VAR281;
}
function FUN258() external view returns (uint) {
return FUN266();
}
function FUN266() internal view returns (uint) {
return uint(VAR281) * VAR279;
}
function FUN259() external view returns (uint) {
return VAR172;
}
function FUN260() external view returns (uint) {
return 1 VAR282 / VAR172;
}
function FUN210() external view returns (uint) {
return VAR283;
}
function FUN261() external view returns (uint) {
return VAR90.VAR55;
}
function FUN262(uint VAR87) external view returns (bool VAR272, bytes32 VAR273, uint VAR274, uint VAR275) {
VAR272 = VAR90[VAR87].VAR272;
VAR273 = VAR90[VAR87].VAR273;
VAR274 = VAR90[VAR87].VAR274;
VAR275 = VAR90[VAR87].VAR275;
}
}
interface VAR299 {
event FUN267(bytes32 indexed VAR300, bytes32 indexed VAR301, address VAR112);
event Transfer(bytes32 indexed VAR300, address VAR112);
event FUN268(bytes32 indexed VAR300, address VAR135);
event FUN269(bytes32 indexed VAR300, uint64 VAR302);
function FUN270(bytes32 VAR300, bytes32 VAR301, address VAR112) external returns (bytes32);
function FUN271(bytes32 VAR300, address VAR135) external;
function FUN86(bytes32 VAR300, address VAR112) external;
function FUN272(bytes32 VAR300, uint64 VAR302) external;
function FUN273(bytes32 VAR300) external view returns (address);
function FUN274(bytes32 VAR300) external view returns (address);
function FUN275(bytes32 VAR300) external view returns (VAR74);
}
interface VAR303 {
event FUN267(bytes32 indexed VAR300, bytes32 indexed VAR301, address VAR112);
event Transfer(bytes32 indexed VAR300, address VAR112);
event FUN268(bytes32 indexed VAR300, address VAR135);
event FUN269(bytes32 indexed VAR300, uint64 VAR302);
function FUN270(bytes32 VAR300, bytes32 VAR301, address VAR112) external;
function FUN271(bytes32 VAR300, address VAR135) external;
function FUN86(bytes32 VAR300, address VAR112) external;
function FUN272(bytes32 VAR300, uint64 VAR302) external;
function FUN273(bytes32 VAR300) external view returns (address);
function FUN274(bytes32 VAR300) external view returns (address);
function FUN275(bytes32 VAR300) external view returns (VAR74);
}
contract VAR304 {
bytes4 constant VAR305 = 0x01ffc9a7;
bytes4 constant VAR306 = 0x3b3b57de;
bytes4 constant VAR307 = 0xd8389dc5;
bytes4 constant VAR308 = 0x691f3431;
bytes4 constant VAR309 = 0x2203ab56;
bytes4 constant VAR310 = 0xc8690233;
bytes4 constant VAR311 = 0x59d1d43c;
event FUN276(bytes32 indexed VAR300, address VAR107);
event FUN277(bytes32 indexed VAR300, bytes32 VAR312);
event FUN278(bytes32 indexed VAR300, string VAR237);
event FUN279(bytes32 indexed VAR300, uint256 indexed VAR313);
event FUN280(bytes32 indexed VAR300, bytes32 VAR314, bytes32 VAR315);
event FUN281(bytes32 indexed VAR300, string VAR316, string VAR97);
struct VAR317 {
bytes32 VAR314;
bytes32 VAR315;
}
struct VAR118 {
address VAR115;
bytes32 VAR318;
string VAR237;
PublicKey VAR319;
mapping(string=>string) VAR320;
mapping(uint256=>bytes) VAR321;
}
ENSIface VAR134;
mapping (bytes32 => VAR118) VAR322;
modifier only_owner(bytes32 VAR300) {
require(VAR134.FUN273(VAR300) == msg.sender);
VAR114;
}
constructor(ENSIface VAR323) public {
VAR134 = VAR323;
}
function FUN107(bytes32 VAR300, address VAR115) public only_owner(VAR300) {
VAR322[VAR300].VAR115 = VAR115;
emit FUN276(VAR300, VAR115);
}
function FUN282(bytes32 VAR300, bytes32 VAR312) public only_owner(VAR300) {
VAR322[VAR300].VAR318 = VAR312;
emit FUN277(VAR300, VAR312);
}
function FUN283(bytes32 VAR300, string VAR237) public only_owner(VAR300) {
VAR322[VAR300].VAR237 = VAR237;
emit FUN278(VAR300, VAR237);
}
function FUN284(bytes32 VAR300, uint256 VAR313, bytes VAR102) public only_owner(VAR300) {
require(((VAR313 - 1) & VAR313) == 0);
VAR322[VAR300].VAR321[VAR313] = VAR102;
emit FUN279(VAR300, VAR313);
}
function FUN285(bytes32 VAR300, bytes32 VAR314, bytes32 VAR315) public only_owner(VAR300) {
VAR322[VAR300].VAR319 = FUN286(VAR314, VAR315);
emit FUN280(VAR300, VAR314, VAR315);
}
function FUN287(bytes32 VAR300, string VAR97, string value) public only_owner(VAR300) {
VAR322[VAR300].VAR320[VAR97] = value;
emit FUN281(VAR300, VAR97, VAR97);
}
function FUN288(bytes32 VAR300, string VAR97) public view returns (string) {
return VAR322[VAR300].VAR320[VAR97];
}
function FUN289(bytes32 VAR300) public view returns (bytes32 VAR314, bytes32 VAR315) {
return (VAR322[VAR300].VAR319.VAR314, VAR322[VAR300].VAR319.VAR315);
}
function FUN290(bytes32 VAR300, uint256 VAR324) public view returns (uint256 VAR313, bytes VAR102) {
Record storage VAR325 = VAR322[VAR300];
for (VAR313 = 1; VAR313 <= VAR324; VAR313 <<= 1) {
if ((VAR313 & VAR324) != 0 && VAR325.VAR321[VAR313].VAR55 > 0) {
VAR102 = VAR325.VAR321[VAR313];
return;
}
}
VAR313 = 0;
}
function FUN291(bytes32 VAR300) public view returns (string) {
return VAR322[VAR300].VAR237;
}
function FUN292(bytes32 VAR300) public view returns (bytes32) {
return VAR322[VAR300].VAR318;
}
function FUN293(bytes32 VAR300) public view returns (address) {
return VAR322[VAR300].VAR115;
}
function FUN294(bytes4 VAR326) public pure returns (bool) {
return VAR326 == VAR306 ||
VAR326 == VAR307 ||
VAR326 == VAR308 ||
VAR326 == VAR309 ||
VAR326 == VAR310 ||
VAR326 == VAR311 ||
VAR326 == VAR305;
}
}
library VAR327 {
function FUN295(bytes memory VAR328, bytes memory VAR329) internal pure returns (bytes) {
bytes memory VAR330;
VAR331 {
VAR330 := FUN296(0x40)
let VAR55 := FUN296(VAR328)
FUN297(VAR330, VAR55)
let VAR332 := FUN298(VAR330, 0x20)
let VAR333 := FUN298(VAR332, VAR55)
for {
let VAR334 := FUN298(VAR328, 0x20)
} FUN299(VAR332, VAR333) {
VAR332 := FUN298(VAR332, 0x20)
VAR334 := FUN298(VAR334, 0x20)
} {
FUN297(VAR332, FUN296(VAR334))
}
VAR55 := FUN296(VAR329)
FUN297(VAR330, FUN298(VAR55, FUN296(VAR330)))
VAR332 := VAR333
VAR333 := FUN298(VAR332, VAR55)
for {
let VAR334 := FUN298(VAR329, 0x20)
} FUN299(VAR332, VAR333) {
VAR332 := FUN298(VAR332, 0x20)
VAR334 := FUN298(VAR334, 0x20)
} {
FUN297(VAR332, FUN296(VAR334))
}
FUN297(0x40, FUN300(
FUN298(FUN298(VAR333, FUN301(FUN298(VAR55, FUN296(VAR328)))), 31),
FUN302(31)
))
}
return VAR330;
}
function FUN303(bytes storage VAR328, bytes memory VAR329) internal {
VAR331 {
let VAR335 := FUN304(VAR336)
let VAR337 := FUN305(FUN300(VAR335, FUN306(FUN307(0x100, FUN301(FUN300(VAR335, 1))), 1)), 2)
let VAR338 := FUN296(VAR329)
let VAR339 := FUN298(VAR337, VAR338)
switch FUN298(FUN299(VAR337, 32), FUN299(VAR339, 32))
case 2 {
FUN308(
VAR336,
FUN298(
VAR335,
FUN298(
FUN307(
FUN305(
FUN296(FUN298(VAR329, 0x20)),
FUN309(0x100, FUN306(32, VAR338))
),
FUN309(0x100, FUN306(32, VAR339))
),
FUN307(VAR338, 2)
)
)
)
}
case 1 {
FUN297(0x0, VAR336)
let VAR340 := FUN298(FUN38(0x0, 0x20), FUN305(VAR337, 32))
FUN308(VAR336, FUN298(FUN307(VAR339, 2), 1))
let VAR341 := FUN306(32, VAR337)
let VAR332 := FUN298(VAR329, VAR341)
let VAR333 := FUN298(VAR329, VAR338)
let VAR342 := FUN306(FUN309(0x100, VAR341), 1)
FUN308(
VAR340,
FUN298(
FUN300(
VAR335,
0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00
),
FUN300(FUN296(VAR332), VAR342)
)
)
for {
VAR332 := FUN298(VAR332, 0x20)
VAR340 := FUN298(VAR340, 1)
} FUN299(VAR332, VAR333) {
VAR340 := FUN298(VAR340, 1)
VAR332 := FUN298(VAR332, 0x20)
} {
FUN308(VAR340, FUN296(VAR332))
}
VAR342 := FUN309(0x100, FUN306(VAR332, VAR333))
FUN308(VAR340, FUN307(FUN305(FUN296(VAR332), VAR342), VAR342))
}
default {
FUN297(0x0, VAR336)
let VAR340 := FUN298(FUN38(0x0, 0x20), FUN305(VAR337, 32))
FUN308(VAR336, FUN298(FUN307(VAR339, 2), 1))
let VAR343 := FUN310(VAR337, 32)
let VAR344 := FUN310(VAR338, 32)
let VAR341 := FUN306(32, VAR343)
let VAR332 := FUN298(VAR329, VAR341)
let VAR333 := FUN298(VAR329, VAR338)
let VAR342 := FUN306(FUN309(0x100, VAR341), 1)
FUN308(VAR340, FUN298(FUN304(VAR340), FUN300(FUN296(VAR332), VAR342)))
for {
VAR340 := FUN298(VAR340, 1)
VAR332 := FUN298(VAR332, 0x20)
} FUN299(VAR332, VAR333) {
VAR340 := FUN298(VAR340, 1)
VAR332 := FUN298(VAR332, 0x20)
} {
FUN308(VAR340, FUN296(VAR332))
}
VAR342 := FUN309(0x100, FUN306(VAR332, VAR333))
FUN308(VAR340, FUN307(FUN305(FUN296(VAR332), VAR342), VAR342))
}
}
}
function FUN311(bytes VAR345, uint VAR346, uint VAR347) internal  pure returns (bytes) {
require(VAR345.VAR55 >= (VAR346 + VAR347));
bytes memory VAR330;
VAR331 {
switch FUN301(VAR347)
case 0 {
VAR330 := FUN296(0x40)
let VAR348 := FUN300(VAR347, 31)
let VAR332 := FUN298(FUN298(VAR330, VAR348), FUN307(0x20, FUN301(VAR348)))
let VAR333 := FUN298(VAR332, VAR347)
for {
let VAR334 := FUN298(FUN298(FUN298(VAR345, VAR348), FUN307(0x20, FUN301(VAR348))), VAR346)
} FUN299(VAR332, VAR333) {
VAR332 := FUN298(VAR332, 0x20)
VAR334 := FUN298(VAR334, 0x20)
} {
FUN297(VAR332, FUN296(VAR334))
}
FUN297(VAR330, VAR347)
FUN297(0x40, FUN300(FUN298(VAR332, 31), FUN302(31)))
}
default {
VAR330 := FUN296(0x40)
FUN297(0x40, FUN298(VAR330, 0x20))
}
}
return VAR330;
}
function FUN312(bytes VAR345, uint VAR346) internal  pure returns (address) {
require(VAR345.VAR55 >= (VAR346 + 20));
address VAR349;
VAR331 {
VAR349 := FUN305(FUN296(FUN298(FUN298(VAR345, 0x20), VAR346)), 0x1000000000000000000000000)
}
return VAR349;
}
function FUN313(bytes VAR345, uint VAR346) internal  pure returns (uint256) {
require(VAR345.VAR55 >= (VAR346 + 32));
uint256 VAR350;
VAR331 {
VAR350 := FUN296(FUN298(FUN298(VAR345, 0x20), VAR346))
}
return VAR350;
}
function FUN314(bytes memory VAR328, bytes memory VAR329) internal pure returns (bool) {
bool VAR153 = true;
VAR331 {
let VAR55 := FUN296(VAR328)
switch FUN315(VAR55, FUN296(VAR329))
case 1 {
let VAR351 := 1
let VAR332 := FUN298(VAR328, 0x20)
let VAR333 := FUN298(VAR332, VAR55)
for {
let VAR334 := FUN298(VAR329, 0x20)
} FUN315(FUN298(FUN299(VAR332, VAR333), VAR351), 2) {
VAR332 := FUN298(VAR332, 0x20)
VAR334 := FUN298(VAR334, 0x20)
} {
if FUN301(FUN315(FUN296(VAR332), FUN296(VAR334))) {
VAR153 := 0
VAR351 := 0
}
}
}
default {
VAR153 := 0
}
}
return VAR153;
}
function FUN316(bytes storage VAR328, bytes memory VAR329) internal view returns (bool) {
bool VAR153 = true;
VAR331 {
let VAR335 := FUN304(VAR336)
let VAR337 := FUN305(FUN300(VAR335, FUN306(FUN307(0x100, FUN301(FUN300(VAR335, 1))), 1)), 2)
let VAR338 := FUN296(VAR329)
switch FUN315(VAR337, VAR338)
case 1 {
if FUN301(FUN301(VAR337)) {
switch FUN299(VAR337, 32)
case 1 {
VAR335 := FUN307(FUN305(VAR335, 0x100), 0x100)
if FUN301(FUN315(VAR335, FUN296(FUN298(VAR329, 0x20)))) {
VAR153 := 0
}
}
default {
let VAR351 := 1
FUN297(0x0, VAR336)
let VAR340 := FUN38(0x0, 0x20)
let VAR332 := FUN298(VAR329, 0x20)
let VAR333 := FUN298(VAR332, VAR338)
for {} FUN315(FUN298(FUN299(VAR332, VAR333), VAR351), 2) {
VAR340 := FUN298(VAR340, 1)
VAR332 := FUN298(VAR332, 0x20)
} {
if FUN301(FUN315(FUN304(VAR340), FUN296(VAR332))) {
VAR153 := 0
VAR351 := 0
}
}
}
}
}
default {
VAR153 := 0
}
}
return VAR153;
}
}
0
---------------------------------
502 0x04ba7fd29525baa8ea04ad94f01efcec7d4a24b6.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address private VAR3;
event FUN1(
address indexed VAR4,
address indexed VAR5
);
constructor() internal {
VAR3 = msg.sender;
emit FUN1(address(0), VAR3);
}
function FUN2() public view returns(address) {
return VAR3;
}
modifier onlyOwner() {
require(FUN3());
VAR6;
}
function FUN3() public view returns(bool) {
return msg.sender == VAR3;
}
function FUN4() public onlyOwner {
emit FUN1(VAR3, address(0));
VAR3 = address(0);
}
function FUN5(address VAR5) public onlyOwner {
FUN6(VAR5);
}
function FUN6(address VAR5) internal {
require(VAR5 != address(0));
emit FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
library VAR7 {
function FUN7(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
if (VAR8 == 0) {
return 0;
}
uint256 VAR10 = VAR8 * VAR9;
require(VAR10 / VAR8 == VAR9);
return VAR10;
}
function FUN8(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
require(VAR9 > 0);
uint256 VAR10 = VAR8 / VAR9;
return VAR10;
}
function FUN9(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
require(VAR9 <= VAR8);
uint256 VAR10 = VAR8 - VAR9;
return VAR10;
}
function FUN10(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
uint256 VAR10 = VAR8 + VAR9;
require(VAR10 >= VAR8);
return VAR10;
}
function FUN11(uint256 VAR8, uint256 VAR9) internal pure returns (uint256) {
require(VAR9 != 0);
return VAR8 % VAR9;
}
}
interface VAR11 {
function FUN12() external view returns (uint256);
function FUN13(address VAR12) external view returns (uint256);
function FUN14(address VAR13, address VAR14)
external view returns (uint256);
function transfer(address VAR15, uint256 value) external returns (bool);
function FUN15(address VAR14, uint256 value)
external returns (bool);
function FUN16(address VAR16, address VAR15, uint256 value)
external returns (bool);
event Transfer(
address indexed VAR16,
address indexed VAR15,
uint256 value
);
event FUN17(
address indexed VAR13,
address indexed VAR14,
uint256 value
);
}
contract ERC20 is VAR11 {
using SafeMath for uint256;
mapping (address => uint256) private VAR17;
mapping (address => mapping (address => uint256)) private VAR18;
uint256 private VAR19;
function FUN12() public view returns (uint256) {
return VAR19;
}
function FUN13(address VAR13) public view returns (uint256) {
return VAR17[VAR13];
}
function FUN14(
address VAR13,
address VAR14
)
public
view
returns (uint256)
{
return VAR18[VAR13][VAR14];
}
function transfer(address VAR15, uint256 value) public returns (bool) {
FUN18(msg.sender, VAR15, value);
return true;
}
function FUN15(address VAR14, uint256 value) public returns (bool) {
require(VAR14 != address(0));
VAR18[msg.sender][VAR14] = value;
emit FUN17(msg.sender, VAR14, value);
return true;
}
function FUN16(
address VAR16,
address VAR15,
uint256 value
)
public
returns (bool)
{
require(value <= VAR18[VAR16][msg.sender]);
VAR18[VAR16][msg.sender] = VAR18[VAR16][msg.sender].FUN9(value);
FUN18(VAR16, VAR15, value);
return true;
}
function FUN19(
address VAR14,
uint256 VAR20
)
public
returns (bool)
{
require(VAR14 != address(0));
VAR18[msg.sender][VAR14] = (
VAR18[msg.sender][VAR14].FUN10(VAR20));
emit FUN17(msg.sender, VAR14, VAR18[msg.sender][VAR14]);
return true;
}
function FUN20(
address VAR14,
uint256 VAR21
)
public
returns (bool)
{
require(VAR14 != address(0));
VAR18[msg.sender][VAR14] = (
VAR18[msg.sender][VAR14].FUN9(VAR21));
emit FUN17(msg.sender, VAR14, VAR18[msg.sender][VAR14]);
return true;
}
function FUN18(address VAR16, address VAR15, uint256 value) internal {
require(value <= VAR17[VAR16]);
require(VAR15 != address(0));
VAR17[VAR16] = VAR17[VAR16].FUN9(value);
VAR17[VAR15] = VAR17[VAR15].FUN10(value);
emit Transfer(VAR16, VAR15, value);
}
function FUN21(address VAR22, uint256 value) internal {
require(VAR22 != 0);
VAR19 = VAR19.FUN10(value);
VAR17[VAR22] = VAR17[VAR22].FUN10(value);
emit Transfer(address(0), VAR22, value);
}
function FUN22(address VAR22, uint256 value) internal {
require(VAR22 != 0);
require(value <= VAR17[VAR22]);
VAR19 = VAR19.FUN9(value);
VAR17[VAR22] = VAR17[VAR22].FUN9(value);
emit Transfer(VAR22, address(0), value);
}
function FUN23(address VAR22, uint256 value) internal {
require(value <= VAR18[VAR22][msg.sender]);
VAR18[VAR22][msg.sender] = VAR18[VAR22][msg.sender].FUN9(
value);
FUN22(VAR22, value);
}
}
contract WAKANDA is VAR23, VAR2 {
string public constant VAR24 = "";
string public constant VAR25 = "";
uint8 public constant VAR26 = 18;
uint256 public constant VAR27 = 899000000 * (10 ** uint256(VAR26));
constructor(address VAR28) public {
FUN21(VAR28, VAR27);
}
}
0
---------------------------------
503 0x04c271ef0e8dd18a24c194ae7e72d74398b3b4b0.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address public VAR3;
event FUN1(address indexed VAR4);
event FUN2(
address indexed VAR4,
address indexed VAR5
);
constructor() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR6;
}
function FUN3() public onlyOwner {
emit FUN1(VAR3);
VAR3 = address(0);
}
function FUN4(address VAR7) public onlyOwner {
FUN5(VAR7);
}
function FUN5(address VAR7) internal {
require(VAR7 != address(0));
emit FUN2(VAR3, VAR7);
VAR3 = VAR7;
}
}
library VAR8 {
struct VAR9 {
mapping (address => bool) VAR10;
}
function FUN6(Role storage VAR11, address VAR12)
internal
{
VAR11.VAR10[VAR12] = true;
}
function FUN7(Role storage VAR11, address VAR12)
internal
{
VAR11.VAR10[VAR12] = false;
}
function FUN8(Role storage VAR11, address VAR12)
internal
view
{
require(FUN9(VAR11, VAR12));
}
function FUN9(Role storage VAR11, address VAR12)
internal
view
returns (bool)
{
return VAR11.VAR10[VAR12];
}
}
contract VAR13 {
using Roles for VAR8.VAR9;
mapping (string => VAR8.VAR9) private VAR14;
event FUN10(address indexed VAR15, string VAR16);
event FUN11(address indexed VAR15, string VAR16);
function FUN12(address VAR17, string VAR11)
public
view
{
VAR14[VAR11].FUN8(VAR17);
}
function FUN13(address VAR17, string VAR11)
public
view
returns (bool)
{
return VAR14[VAR11].FUN9(VAR17);
}
function FUN14(address VAR17, string VAR11)
internal
{
VAR14[VAR11].FUN6(VAR17);
emit FUN10(VAR17, VAR11);
}
function FUN15(address VAR17, string VAR11)
internal
{
VAR14[VAR11].FUN7(VAR17);
emit FUN11(VAR17, VAR11);
}
modifier FUN16(string VAR11)
{
FUN12(msg.sender, VAR11);
VAR6;
}
}
library VAR18 {
function FUN17(uint256 VAR19, uint256 VAR20) internal pure returns (uint256 VAR21) {
if (VAR19 == 0) {
return 0;
}
VAR21 = VAR19 * VAR20;
require(VAR21 / VAR19 == VAR20, "");
return VAR21;
}
function FUN18(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
uint256 VAR21 = VAR19 / VAR20;
return VAR21;
}
function FUN19(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
require(VAR20 <= VAR19, "");
return VAR19 - VAR20;
}
function FUN6(uint256 VAR19, uint256 VAR20) internal pure returns (uint256 VAR21) {
VAR21 = VAR19 + VAR20;
require(VAR21 >= VAR19, "");
return VAR21;
}
function FUN20(uint256 VAR22) internal pure returns (uint256 VAR23) {
uint256 VAR24 = ((FUN6(VAR22,1)) / 2);
VAR23 = VAR22;
while (VAR24 < VAR23)
{
VAR23 = VAR24;
VAR24 = ((FUN6((VAR22 / VAR24),VAR24)) / 2);
}
}
function FUN21(uint256 VAR22) internal pure returns (uint256) {
return (FUN17(VAR22,VAR22));
}
function FUN22(uint256 VAR22, uint256 VAR23) internal pure returns (uint256) {
if (VAR22==0)
return (0);
else if (VAR23==0)
return (1);
else
{
uint256 VAR24 = VAR22;
for (uint256 VAR25=1; VAR25 < VAR23; VAR25++)
VAR24 = FUN17(VAR24,VAR22);
return (VAR24);
}
}
}
interface VAR26 {
function FUN23() external view returns (uint256);
function FUN24(address VAR27) external view returns (uint256);
function transfer(address VAR28, uint256 value) external returns (bool);
function FUN25(address VAR3, address VAR29) external view returns (uint256);
function FUN26(address VAR30, address VAR28, uint256 value) external returns (bool);
function FUN27(address VAR29, uint256 value) external returns (bool);
}
contract CryptoHeroRocket is VAR2, VAR13 {
using SafeMath for uint256;
event Transfer(address indexed VAR30, address indexed VAR28, uint256 VAR31);
event FUN28(address indexed VAR3, address indexed VAR29, uint256 VAR31);
event FUN29(address indexed VAR28, uint256 VAR31);
event FUN30(address indexed VAR30, uint256 VAR31);
string internal constant VAR32 = "";
string internal constant VAR33 = "";
string public VAR34 = '';
string public VAR35 = '';
uint8 public VAR36;
uint256 public VAR37;
mapping(address => uint256) internal VAR38;
mapping (address => mapping (address => uint256)) internal VAR39;
constructor() public {
FUN14(msg.sender, VAR32);
FUN14(msg.sender, VAR33);
}
function() external {}
function transfer(address VAR40, uint256 VAR41) public returns (bool) {
require(VAR40 != address(0));
VAR38[msg.sender] = VAR38[msg.sender].FUN19(VAR41);
VAR38[VAR40] = VAR38[VAR40].FUN6(VAR41);
emit Transfer(msg.sender, VAR40, VAR41);
return true;
}
function FUN24(address VAR42) public view returns (uint256) {
return VAR38[VAR42];
}
function FUN25(address VAR42, address VAR43) public view returns (uint256) {
return VAR39[VAR42][VAR43];
}
function FUN26(address VAR44, address VAR40, uint256 VAR41) public returns (bool) {
require(VAR40 != address(0));
VAR38[VAR44] = VAR38[VAR44].FUN19(VAR41);
VAR39[VAR44][msg.sender] = VAR39[VAR44][msg.sender].FUN19(VAR41);
VAR38[VAR40] = VAR38[VAR40].FUN6(VAR41);
emit Transfer(VAR44, VAR40, VAR41);
return true;
}
function FUN27(address VAR43, uint256 VAR41) public returns (bool) {
VAR39[msg.sender][VAR43] = VAR41;
emit FUN28(msg.sender, VAR43, VAR41);
return true;
}
function FUN31(address VAR43, uint256 VAR45) public returns (bool) {
VAR39[msg.sender][VAR43] = (
VAR39[msg.sender][VAR43].FUN6(VAR45));
emit FUN28(msg.sender, VAR43, VAR39[msg.sender][VAR43]);
return true;
}
function FUN32(address VAR43, uint256 VAR46) public returns (bool) {
uint256 VAR47 = VAR39[msg.sender][VAR43];
if (VAR46 >= VAR47) {
VAR39[msg.sender][VAR43] = 0;
} else {
VAR39[msg.sender][VAR43] = VAR47.FUN19(VAR46);
}
emit FUN28(msg.sender, VAR43, VAR39[msg.sender][VAR43]);
return true;
}
function FUN33(address VAR48) external onlyOwner {
FUN14(VAR48, VAR32);
}
function FUN34(address VAR49) external onlyOwner {
FUN14(VAR49, VAR33);
}
function FUN35(address VAR48) external onlyOwner {
FUN15(VAR48, VAR32);
}
function FUN36(address VAR49) external onlyOwner {
FUN15(VAR49, VAR33);
}
function FUN37(address VAR40, uint256 VAR50) external FUN16(VAR32) returns (bool) {
VAR37 = VAR37.FUN6(VAR50);
VAR38[VAR40] = VAR38[VAR40].FUN6(VAR50);
emit FUN29(VAR40, VAR50);
emit Transfer(address(0), VAR40, VAR50);
return true;
}
function FUN38(address VAR44, uint256 VAR50) external FUN16(VAR33) returns (bool) {
VAR38[VAR44] = VAR38[VAR44].FUN19(VAR50);
VAR37 = VAR37.FUN19(VAR50);
emit FUN30(VAR44, VAR50);
emit Transfer(VAR44, address(0), VAR50);
return true;
}
function FUN39(address VAR51) external onlyOwner {
if (VAR51 == 0x0) {
VAR3.transfer(address(this).VAR52);
return;
}
ERC20 VAR53 = FUN40(VAR51);
uint VAR52 = VAR53.FUN24(this);
VAR53.transfer(VAR3, VAR52);
}
}
0
---------------------------------
504 0x04c2f74f7ce126ecbf39a89d8179f228dafbc500.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29808000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xc2b09C3baC79A2aE679D9Beb872465d6F8F8fFE1;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
505 0x04c62019ab478bff5874e7b7d9bc84fcf7e30025.sol
pragma solidity 0.4.18;
contract VAR1 {
event FUN1(address indexed sender, uint indexed VAR2);
event FUN2(address indexed sender, uint indexed VAR2);
event FUN3(uint indexed VAR2);
event FUN4(uint indexed VAR2);
event FUN5(uint indexed VAR2);
event FUN6(address indexed sender, uint value);
event FUN7(address indexed VAR3);
event FUN8(address indexed VAR3);
event FUN9(uint VAR4);
uint constant public VAR5 = 50;
mapping (uint => Transaction) public VAR6;
mapping (uint => mapping (address => bool)) public VAR7;
mapping (address => bool) public VAR8;
address[] public VAR9;
uint public VAR4;
uint public VAR10;
struct Transaction {
address VAR11;
uint value;
bytes VAR12;
bool VAR13;
}
modifier FUN10() {
if (msg.sender != address(this))
throw;
VAR14;
}
modifier FUN11(address VAR3) {
if (VAR8[VAR3])
throw;
VAR14;
}
modifier ownerExists(address VAR3) {
if (!VAR8[VAR3])
throw;
VAR14;
}
modifier FUN12(uint VAR2) {
if (VAR6[VAR2].VAR11 == 0)
throw;
VAR14;
}
modifier confirmed(uint VAR2, address VAR3) {
if (!VAR7[VAR2][VAR3])
throw;
VAR14;
}
modifier notConfirmed(uint VAR2, address VAR3) {
if (VAR7[VAR2][VAR3])
throw;
VAR14;
}
modifier notExecuted(uint VAR2) {
if (VAR6[VAR2].VAR13)
throw;
VAR14;
}
modifier FUN13(address VAR15) {
if (VAR15 == 0)
throw;
VAR14;
}
modifier FUN14(uint VAR16, uint VAR17) {
if (   VAR16 > VAR5
|| VAR17 > VAR16
|| VAR17 == 0
|| VAR16 == 0)
throw;
VAR14;
}
function()
payable
{
if (msg.value > 0)
FUN6(msg.sender, msg.value);
}
function FUN15(address[] VAR18, uint VAR17)
public
FUN14(VAR18.VAR19, VAR17)
{
for (uint VAR20=0; VAR20<VAR18.VAR19; VAR20++) {
if (VAR8[VAR18[VAR20]] || VAR18[VAR20] == 0)
throw;
VAR8[VAR18[VAR20]] = true;
}
VAR9 = VAR18;
VAR4 = VAR17;
}
function FUN16(address VAR3)
public
VAR21
FUN11(VAR3)
FUN13(VAR3)
FUN14(VAR9.VAR19 + 1, VAR4)
{
VAR8[VAR3] = true;
VAR9.FUN17(VAR3);
FUN7(VAR3);
}
function FUN18(address VAR3)
public
VAR21
ownerExists(VAR3)
{
VAR8[VAR3] = false;
for (uint VAR20=0; VAR20<VAR9.VAR19 - 1; VAR20++)
if (VAR9[VAR20] == VAR3) {
VAR9[VAR20] = VAR9[VAR9.VAR19 - 1];
break;
}
VAR9.VAR19 -= 1;
if (VAR4 > VAR9.VAR19)
FUN19(VAR9.VAR19);
FUN8(VAR3);
}
function FUN20(address VAR3, address VAR22)
public
VAR21
ownerExists(VAR3)
FUN11(VAR22)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR9[VAR20] == VAR3) {
VAR9[VAR20] = VAR22;
break;
}
VAR8[VAR3] = false;
VAR8[VAR22] = true;
FUN8(VAR3);
FUN7(VAR22);
}
function FUN19(uint VAR17)
public
VAR21
FUN14(VAR9.VAR19, VAR17)
{
VAR4 = VAR17;
FUN9(VAR17);
}
function FUN21(address VAR11, uint value, bytes VAR12)
public
returns (uint VAR2)
{
VAR2 = FUN22(VAR11, value, VAR12);
FUN23(VAR2);
}
function FUN23(uint VAR2)
public
ownerExists(msg.sender)
FUN12(VAR2)
notConfirmed(VAR2, msg.sender)
{
VAR7[VAR2][msg.sender] = true;
FUN1(msg.sender, VAR2);
FUN24(VAR2);
}
function FUN25(uint VAR2)
public
ownerExists(msg.sender)
confirmed(VAR2, msg.sender)
notExecuted(VAR2)
{
VAR7[VAR2][msg.sender] = false;
FUN2(msg.sender, VAR2);
}
function FUN24(uint VAR2)
public
ownerExists(msg.sender)
confirmed(VAR2, msg.sender)
notExecuted(VAR2)
{
if (FUN26(VAR2)) {
Transaction VAR23 = VAR6[VAR2];
VAR23.VAR13 = true;
if (VAR23.VAR11.call.value(VAR23.value)(VAR23.VAR12))
FUN4(VAR2);
else {
FUN5(VAR2);
VAR23.VAR13 = false;
}
}
}
function FUN26(uint VAR2)
public
constant
returns (bool)
{
uint VAR24 = 0;
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++) {
if (VAR7[VAR2][VAR9[VAR20]])
VAR24 += 1;
if (VAR24 == VAR4)
return true;
}
}
function FUN22(address VAR11, uint value, bytes VAR12)
internal
FUN13(VAR11)
returns (uint VAR2)
{
VAR2 = VAR10;
VAR6[VAR2] = Transaction({
VAR11: VAR11,
value: value,
VAR12: VAR12,
VAR13: false
});
VAR10 += 1;
FUN3(VAR2);
}
function FUN27(uint VAR2)
public
constant
returns (uint VAR24)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR2][VAR9[VAR20]])
VAR24 += 1;
}
function FUN28(bool VAR25, bool VAR13)
public
constant
returns (uint VAR24)
{
for (uint VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR25 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
VAR24 += 1;
}
function FUN29()
public
constant
returns (address[])
{
return VAR9;
}
function FUN30(uint VAR2)
public
constant
returns (address[] VAR26)
{
address[] memory VAR27 = new address[](VAR9.VAR19);
uint VAR24 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR2][VAR9[VAR20]]) {
VAR27[VAR24] = VAR9[VAR20];
VAR24 += 1;
}
VAR26 = new address[](VAR24);
for (VAR20=0; VAR20<VAR24; VAR20++)
VAR26[VAR20] = VAR27[VAR20];
}
function FUN31(uint VAR28, uint VAR29, bool VAR25, bool VAR13)
public
constant
returns (uint[] VAR30)
{
uint[] memory VAR31 = new uint[](VAR10);
uint VAR24 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR25 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
{
VAR31[VAR24] = VAR20;
VAR24 += 1;
}
VAR30 = new uint[](VAR29 - VAR28);
for (VAR20=VAR28; VAR20<VAR29; VAR20++)
VAR30[VAR20 - VAR28] = VAR31[VAR20];
}
}
0
---------------------------------
506 0x04d660832910ff492e940daff9ec7b3497e886ac.sol
pragma solidity 0.4.25;
pragma experimental VAR1;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns(uint) {
if (VAR3 > VAR4) {
return VAR4;
}
return VAR3;
}
}
library VAR5 {
function FUN2(address VAR6) internal pure {
require(VAR6 != address(0), "");
}
function FUN2(uint VAR7) internal pure {
require(VAR7 != 0, "");
}
function FUN3(address VAR6) internal pure returns(bool) {
return !(VAR6 == address(0));
}
function FUN4(address VAR6) internal pure returns(bool) {
return VAR6 == address(0);
}
function FUN4(uint VAR3) internal pure returns(bool) {
return VAR3 == 0;
}
function FUN3(uint VAR3) internal pure returns(bool) {
return VAR3 != 0;
}
}
library VAR8 {
struct VAR9 {
uint VAR10;
uint VAR11;
}
function FUN5(percent storage VAR12, uint VAR3) internal view returns (uint) {
if (VAR3 == 0) {
return 0;
}
return VAR3*VAR12.VAR10/VAR12.VAR11;
}
function FUN6(percent storage VAR12, uint VAR3) internal view returns (uint) {
return VAR3/VAR12.VAR10*VAR12.VAR11;
}
function FUN7(percent storage VAR12, uint VAR3) internal view returns (uint) {
uint VAR4 = FUN5(VAR12, VAR3);
if (VAR4 >= VAR3) {
return 0;
}
return VAR3 - VAR4;
}
function FUN8(percent storage VAR12, uint VAR3) internal view returns (uint) {
return VAR3 + FUN5(VAR12, VAR3);
}
function FUN9(percent storage VAR12) internal view returns (VAR8.percent VAR13) {
return VAR8.FUN10(VAR12.VAR10, VAR12.VAR11);
}
function FUN11(percent memory VAR12, uint VAR3) internal pure returns (uint) {
if (VAR3 == 0) {
return 0;
}
return VAR3*VAR12.VAR10/VAR12.VAR11;
}
function FUN12(percent memory VAR12, uint VAR3) internal pure returns (uint) {
return VAR3/VAR12.VAR10*VAR12.VAR11;
}
function FUN13(percent memory VAR12, uint VAR3) internal pure returns (uint) {
uint VAR4 = FUN11(VAR12, VAR3);
if (VAR4 >= VAR3) {
return 0;
}
return VAR3 - VAR4;
}
function FUN14(percent memory VAR12, uint VAR3) internal pure returns (uint) {
return VAR3 + FUN11(VAR12, VAR3);
}
}
library VAR14 {
function FUN15(bytes VAR15) internal pure returns(address VAR6) {
VAR16 { VAR6 := FUN16(FUN8(VAR15,0x14)) }
return VAR6;
}
function FUN17(address VAR6) internal view returns(bool) {
uint VAR17;
VAR16 { VAR17 := FUN18(VAR6) }
return VAR17 == 0;
}
}
library VAR18 {
function FUN5(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
if (VAR19 == 0) {
return 0;
}
uint256 VAR21 = VAR19 * VAR20;
require(VAR21 / VAR19 == VAR20);
return VAR21;
}
function FUN6(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
require(VAR20 > 0);
uint256 VAR21 = VAR19 / VAR20;
return VAR21;
}
function FUN7(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
require(VAR20 <= VAR19);
uint256 VAR21 = VAR19 - VAR20;
return VAR21;
}
function FUN8(uint256 VAR19, uint256 VAR20) internal pure returns (uint256) {
uint256 VAR21 = VAR19 + VAR20;
require(VAR21 >= VAR19);
return VAR21;
}
function FUN19(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
contract VAR22 {
address private VAR23;
modifier onlyOwner() {
require(msg.sender == VAR23, "");
VAR24;
}
constructor() public {
VAR23 = msg.sender;
}
function FUN20() internal {
delete VAR23;
}
}
contract InvestorsStorage is VAR22 {
struct VAR25 {
uint value;
uint VAR26;
bool VAR27;
bool VAR28;
}
struct VAR29 {
uint VAR30;
uint VAR31;
VAR25[] VAR32;
VAR8.percent VAR33;
}
uint public VAR34;
mapping (address => VAR29) private VAR35;
function FUN21(address VAR6) public view returns (bool) {
return VAR35[VAR6].VAR30 > 0;
}
function FUN22(address VAR6)  returns(uint VAR30, uint VAR31, VAR25[] VAR32, VAR8.percent VAR33) {
VAR30 = VAR35[VAR6].VAR30;
VAR31 = VAR35[VAR6].VAR31;
VAR32 = VAR35[VAR6].VAR32;
VAR33 = VAR35[VAR6].VAR33;
}
function FUN23(address VAR6) private {
uint VAR36 = VAR35[VAR6].VAR30;
if (VAR36 < 1 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(3,100);
} else if (VAR36 >= 1 VAR37 && VAR36 < 10 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(4,100);
} else if (VAR36 >= 10 VAR37 && VAR36 < 50 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(5,100);
} else if (VAR36 >= 150 VAR37 && VAR36 < 250 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(7,100);
} else if (VAR36 >= 250 VAR37 && VAR36 < 500 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(10,100);
} else if (VAR36 >= 500 VAR37 && VAR36 < 1000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(11,100);
} else if (VAR36 >= 1000 VAR37 && VAR36 < 2000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(14,100);
} else if (VAR36 >= 2000 VAR37 && VAR36 < 5000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(15,100);
} else if (VAR36 >= 5000 VAR37 && VAR36 < 10000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(18,100);
} else if (VAR36 >= 10000 VAR37 && VAR36 < 30000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(20,100);
} else if (VAR36 >= 30000 VAR37 && VAR36 < 60000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(27,100);
} else if (VAR36 >= 60000 VAR37 && VAR36 < 100000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(35,100);
} else if (VAR36 >= 100000 VAR37) {
VAR35[VAR6].VAR33 = VAR8.FUN10(100,100);
}
}
function FUN24(address VAR6, uint VAR38, uint VAR31) public onlyOwner returns (bool) {
if (VAR35[VAR6].VAR30 != 0 || VAR38 == 0) {
return false;
}
VAR35[VAR6].VAR30 = VAR38;
VAR35[VAR6].VAR31 = VAR31;
VAR35[VAR6].VAR32.FUN25(FUN26(VAR38, VAR31, false, false));
VAR34++;
return true;
}
function FUN27(address VAR6, uint value) public onlyOwner returns (bool) {
if (VAR35[VAR6].VAR30 == 0) {
return false;
}
VAR35[VAR6].VAR30 += value;
VAR35[VAR6].VAR32.FUN25(FUN26(value, VAR39, false, false));
FUN23(VAR6);
return true;
}
function FUN28(address VAR6, uint VAR31) public onlyOwner returns (bool) {
if (VAR35[VAR6].VAR30 == 0) {
return false;
}
VAR35[VAR6].VAR31 = VAR31;
return true;
}
function FUN29(address VAR6, uint VAR40) public onlyOwner returns (uint) {
VAR25[] VAR32 = VAR35[VAR6].VAR32;
uint VAR41 = 0;
for (uint VAR42 = 0; VAR42 < VAR32.VAR17; VAR42++) {
if (!VAR32[VAR42].VAR27 && VAR32[VAR42].VAR26 <= VAR39 - 30 VAR43 && VAR41 + VAR32[VAR42].value/2 <= VAR40) {
VAR32[VAR42].VAR27 = true;
VAR41 += VAR32[VAR42].value/2;
VAR35[VAR6].VAR30 -= VAR32[VAR42].value/2;
}
if (!VAR32[VAR42].VAR28 && VAR32[VAR42].VAR26 <= VAR39 - 60 VAR43 && VAR41 + VAR32[VAR42].value/2 <= VAR40) {
VAR32[VAR42].VAR28 = true;
VAR41 += VAR32[VAR42].value/2;
VAR35[VAR6].VAR30 -= VAR32[VAR42].value/2;
}
return VAR41;
}
return VAR41;
}
function FUN30(address VAR6) public onlyOwner returns (bool) {
VAR35[VAR6].VAR30 = 0;
VAR35[VAR6].VAR32.VAR17 = 0;
}
}
contract Revolution2 is VAR22 {
using Percent for VAR8.VAR9;
using SafeMath for uint;
using Math for uint;
using Address for *;
using Zero for *;
mapping(address => bool) private VAR44;
InvestorsStorage private VAR45;
uint public constant VAR46 = 50 VAR47;
uint public constant VAR48 = 8888e5 VAR37;
address public VAR49;
address public VAR50;
uint public VAR51;
uint public VAR52;
VAR8.percent private VAR53 = VAR8.FUN10(5,100);
VAR8.percent private VAR54 = VAR8.FUN10(15,100);
VAR8.percent private VAR55 = VAR8.FUN10(5, 100);
VAR8.percent private VAR56 = VAR8.FUN10(5, 100);
VAR8.percent private VAR57 = VAR8.FUN10(10, 100);
VAR8.percent private VAR58 = VAR8.FUN10(10, 100);
VAR8.percent private VAR59 = VAR8.FUN10(15, 100);
VAR8.percent private VAR60 = VAR8.FUN10(20, 100);
event FUN31(uint VAR61, address VAR62, address VAR63, uint VAR64, uint VAR65);
event FUN32(address indexed VAR6, uint VAR61, uint value, uint VAR36, uint VAR66);
event FUN33(address indexed VAR6, address indexed VAR67, uint VAR61, uint VAR68);
event FUN34(uint VAR61, uint VAR69, uint VAR70, uint VAR71);
event FUN35(address indexed VAR6, uint VAR61, uint VAR36, uint indexed VAR72);
event FUN36(address indexed VAR6, uint VAR61, uint VAR36, uint value);
event FUN37(address indexed VAR6, uint VAR61, uint VAR36);
event FUN38(address indexed VAR6, uint VAR61, uint VAR73);
event FUN39(address indexed VAR6, uint VAR61);
event FUN40(uint VAR61, uint VAR74);
event FUN41(uint VAR61);
event FUN42(uint VAR61);
modifier VAR75 {
VAR24;
emit FUN40(VAR39, address(this).VAR74);
}
modifier FUN43() {
require(msg.sender.FUN17(), "");
VAR24;
}
constructor() public {
VAR50 = msg.sender;
VAR49 = msg.sender;
FUN44();
}
function() public payable {
if (msg.value.FUN4()) {
FUN45();
return;
}
FUN46(msg.VAR76.FUN15());
}
function FUN47(address VAR6) public onlyOwner {
VAR45.FUN30(VAR6);
}
function FUN48() public onlyOwner {
FUN20();
emit FUN42(VAR39);
}
function FUN49(address VAR6) public onlyOwner {
VAR6.transfer(address(this).VAR74);
}
function FUN50(address VAR6) public onlyOwner {
VAR6.FUN2();
VAR49 = VAR6;
}
function FUN51(address VAR6) public onlyOwner {
VAR6.FUN2();
VAR50 = VAR6;
}
function FUN52() public view returns(uint) {
return VAR45.FUN53();
}
function FUN54() public view returns(uint) {
return address(this).VAR74;
}
function FUN55() public view returns(uint VAR77, uint VAR78) {
(VAR77, VAR78) = (VAR56.VAR10, VAR56.VAR11);
}
function FUN56() public view returns(uint VAR77, uint VAR78) {
(VAR77, VAR78) = (VAR55.VAR10, VAR55.VAR11);
}
function FUN22(address VAR79) public view returns(uint VAR30, uint VAR31, VAR8.percent VAR33, VAR80.VAR25[] VAR32) {
(VAR30, VAR31, VAR32, VAR33) = VAR45.FUN22(VAR79);}
function FUN57(address VAR79) public view returns(uint VAR73) {
VAR73 = FUN58(VAR79);
}
function FUN45() public notFromContract VAR75 {
require(VAR39.FUN7(FUN59(msg.sender).VAR31) > 1 VAR81);
uint VAR73 = FUN58(msg.sender);
require (VAR73.FUN3(), "");
assert(VAR45.FUN28(msg.sender, VAR39));
if (address(this).VAR74 <= VAR73) {
FUN44();
VAR73 = address(this).VAR74;
}
msg.sender.transfer(VAR73);
emit FUN38(msg.sender, VAR39, VAR73);
}
function FUN46(address VAR67) public payable notFromContract VAR75 {
uint VAR36 = msg.value;
uint VAR82 = msg.value;
require(VAR36 >= VAR46, "");
require(address(this).VAR74 <= VAR48, "");
if (VAR82 > VAR36) {
uint VAR66 = VAR82 - VAR36;
msg.sender.transfer(VAR66);
VAR82 = VAR36;
emit FUN32(msg.sender, VAR39, msg.value, VAR36, VAR66);
}
VAR49.FUN60(VAR56.FUN5(VAR82));
VAR50.FUN60(VAR55.FUN5(VAR82));
bool VAR83 = VAR45.FUN21(msg.sender);
if (VAR67.FUN3() && !VAR83 && !VAR44[msg.sender] &&
VAR67 != msg.sender && VAR45.FUN21(VAR67)) {
VAR44[msg.sender] = true;
uint VAR84 = VAR54.FUN11(VAR36);
uint VAR85 = VAR53.FUN11(VAR36);
assert(VAR45.FUN27(VAR67, VAR84));
VAR36 += VAR85;
emit FUN33(msg.sender, VAR67, VAR39, VAR85);
}
uint VAR73 = FUN58(msg.sender);
if (VAR83 && VAR73.FUN3()) {
VAR36 += VAR73;
emit FUN37(msg.sender, VAR39, VAR73);
}
if (VAR51 % 20 == 0) {
VAR36 += VAR60.FUN11(VAR36);
} else if(VAR51 % 15 == 0) {
VAR36 += VAR59.FUN11(VAR36);
} else if(VAR51 % 10 == 0) {
VAR36 += VAR58.FUN11(VAR36);
}
if (VAR83) {
assert(VAR45.FUN27(msg.sender, VAR36));
assert(VAR45.FUN28(msg.sender, VAR39));
} else {
if (VAR51 <= 50) {
VAR36 += VAR57.FUN11(VAR36);
}
assert(VAR45.FUN24(msg.sender, VAR36, VAR39));
emit FUN39(msg.sender, VAR39);
}
VAR51++;
emit FUN36(msg.sender, VAR39, VAR36, VAR82);
}
function FUN59(address VAR79) internal view returns(VAR80.Investor VAR13) {
(uint VAR30, uint VAR31, VAR80.VAR25[] memory VAR32, VAR8.percent memory VAR33) = VAR45.FUN22(VAR79);
return VAR80.FUN61(VAR30, VAR31, VAR32, VAR33);
}
function FUN58(address VAR79) internal view returns(uint VAR73) {
VAR80.Investor memory VAR86 = FUN59(VAR79);
if (VAR86.VAR30.FUN4() || VAR39.FUN7(VAR86.VAR31) < 1 VAR81) {
return 0;
}
VAR8.percent memory VAR12 = VAR86.VAR33;
VAR73 = (VAR39.FUN7(VAR86.VAR31) / 1 VAR81) * VAR12.FUN11(VAR86.VAR30) / 24;
}
function FUN44() private {
VAR45 = VAR87 FUN62();
VAR51 = 0;
VAR52 = VAR39;
emit FUN41(VAR39);
}
}
0
---------------------------------
507 0x04d6edcfc557a8cff318277c34c7478403315de3.sol
pragma solidity 0.5.9;
library VAR1 {
function FUN1(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
require((VAR4 = VAR2 + VAR3) >= VAR2);
}
function FUN2(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
require((VAR4 = VAR2 - VAR3) <= VAR2);
}
function FUN3(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
require(VAR3 == 0 || (VAR4 = VAR2 * VAR3) / VAR3 == VAR2);
}
function FUN4(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
return VAR2 <= VAR3 ? VAR2 : VAR3;
}
function FUN5(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(int VAR2, int VAR3) internal pure returns (int VAR4) {
return VAR2 <= VAR3 ? VAR2 : VAR3;
}
function FUN7(int VAR2, int VAR3) internal pure returns (int VAR4) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
uint constant VAR5 = 10 ** 18;
uint constant VAR6 = 10 ** 27;
function FUN8(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
VAR4 = FUN1(FUN3(VAR2, VAR3), VAR5 / 2) / VAR5;
}
function FUN9(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
VAR4 = FUN1(FUN3(VAR2, VAR3), VAR6 / 2) / VAR6;
}
function FUN10(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
VAR4 = FUN1(FUN3(VAR2, VAR5), VAR3 / 2) / VAR3;
}
function FUN11(uint VAR2, uint VAR3) internal pure returns (uint VAR4) {
VAR4 = FUN1(FUN3(VAR2, VAR6), VAR3 / 2) / VAR3;
}
//
//
//
//
//
function FUN12(uint VAR2, uint VAR7) internal pure returns (uint VAR4) {
VAR4 = VAR7 % 2 != 0 ? VAR2 : VAR6;
for (VAR7 /= 2; VAR7 != 0; VAR7 /= 2) {
VAR2 = FUN9(VAR2, VAR2);
if (VAR7 % 2 != 0) {
VAR4 = FUN9(VAR4, VAR2);
}
}
}
}
contract VAR8 {
function FUN13() public view returns (bytes32, bool) {}
}
contract VAR9 {
function FUN14(address VAR10, address VAR11, uint VAR12) public returns (bool) {}
}
contract VAR13 {
address public VAR14;
event FUN15(address indexed VAR15);
event FUN16(
address indexed VAR15,
address indexed VAR16
);
constructor() public {
VAR14 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR14);
VAR17;
}
function FUN17() public onlyOwner {
emit FUN15(VAR14);
VAR14 = address(0);
}
function FUN18(address VAR18) public onlyOwner {
FUN19(VAR18);
}
function FUN19(address VAR18) internal {
require(VAR18 != address(0));
emit FUN16(VAR14, VAR18);
VAR14 = VAR18;
}
}
contract RektFyi is VAR13 {
using DSMath for uint;
struct VAR19 {
uint VAR20;
uint VAR21;
uint VAR22;
uint VAR23;
uint VAR24;
address payable sender;
}
struct VAR25 {
uint VAR26;
uint VAR21;
uint VAR27;
uint VAR22;
}
struct VAR28 {
uint VAR29;
uint VAR30;
}
mapping(address => VAR19) public VAR31;
mapping(address => uint) public VAR32;
mapping(address => address[]) private VAR33;
mapping(address => VAR28) public VAR34;
mapping(address => VAR25) public VAR35;
Pot public VAR36 = FUN20(0,0);
uint public VAR37 = 0;
bool public VAR38 = false;
uint public VAR39 = 0;
uint public VAR40 = 1300000000000000000;
uint public VAR41 = 10000000000000000;
uint public VAR42 = 3628800;
address public VAR43;
Medianizer VAR44;
bool public VAR45 = false;
uint public VAR46 = 0;
address public VAR47;
address public VAR48;
Dai VAR49;
Dai VAR50;
constructor(address VAR51, address VAR52) public {
VAR43 = VAR51;
VAR44 = FUN21(VAR43);
VAR47 = VAR52;
VAR49 = FUN22(VAR47);
VAR50 = VAR49;
}
string public constant VAR53 = "";
string public constant VAR54 = "";
uint8 public constant VAR55 = 0;
uint public constant VAR5 = 1000000000000000000;
uint public constant VAR56 = 100000000000000;
uint public constant VAR57 = 1000000000000000000;
uint public constant VAR58 = 10000000000000000000;
uint public constant VAR59 = 1250000000000000000;
uint public constant VAR60 = 1800000000000000000;
uint public constant VAR61 = 5000000000000000000;
uint public constant VAR62 = 1000000000000000000000000000;
uint public constant VAR63 = 100000000000000000;
uint public constant VAR64 = 23670000;
uint public constant VAR65 = 100000000000000000;
event FUN23(address indexed VAR66, string indexed VAR67, uint value);
event FUN24(address indexed VAR68, uint VAR69, uint VAR50, uint VAR49);
event Transfer(address indexed VAR70, address indexed VAR68, uint VAR71);
event FUN25(uint indexed VAR70, uint indexed VAR68, uint VAR72, address indexed VAR73);
event FUN26(
address indexed sender,
address indexed VAR31,
uint VAR74,
uint VAR40,
uint VAR75,
uint VAR24,
uint VAR21,
uint VAR22,
uint VAR76
);
event FUN27(address indexed sender, address indexed VAR31);
modifier FUN28() {
require(VAR38 == false, "");
VAR17;
}
modifier FUN29(address VAR77) {
require(address(VAR77) != address(0), "");
require(VAR77 != msg.sender, "");
require(FUN30(VAR77) == 0, "");
require(VAR77.VAR32 > 0, "");
VAR17;
}
function FUN31(address VAR77) external payable VAR78 FUN29(VAR77) {
if (msg.value > 0) {
VAR34[msg.sender].VAR29 = VAR34[msg.sender].VAR29.FUN1(msg.value);
VAR36.VAR29 = VAR36.VAR29.FUN1(msg.value);
}
VAR31[VAR77] = FUN32(VAR77.VAR32, msg.value, 0, VAR79, FUN33(), msg.sender);
FUN34(VAR77);
}
function FUN35(address VAR77, uint VAR80) external VAR78 FUN29(VAR77) {
if (VAR80 > 0) {
require(VAR46 != VAR79, "");
require(VAR49.FUN14(msg.sender, address(this), VAR80), "");
VAR34[msg.sender].VAR30 = VAR34[msg.sender].VAR30.FUN1(VAR80);
VAR36.VAR30 = VAR36.VAR30.FUN1(VAR80);
}
VAR31[VAR77] = FUN32(VAR77.VAR32, 0, VAR80, VAR79, FUN33(), msg.sender);
FUN34(VAR77);
}
function FUN36(bool VAR81) external payable VAR78 {
require(msg.value > 0, "");
uint VAR82 = VAR40;
uint VAR83 = msg.value
.FUN10(VAR41)
.FUN8(FUN37(msg.sender))
.FUN8(VAR63);
if (VAR81) {
if (VAR40.FUN1(VAR83) >= VAR58) {
VAR40 = VAR58;
} else {
VAR40 = VAR40.FUN1(FUN38(VAR83));
}
}
else {
if (VAR40 > VAR83) {
if (VAR40.FUN2(VAR83) <= VAR57) {
VAR40 = VAR57;
} else {
VAR40 = VAR40.FUN2(FUN38(VAR83));
}
}
else {
VAR40 = VAR57;
}
}
emit FUN25(VAR82, VAR40, msg.value, msg.sender);
VAR37 = VAR37.FUN1(msg.value);
}
function FUN39(address VAR84) external {
require(FUN30(VAR84) == 1, "");
address sender = VAR31[VAR84].sender;
require(
msg.sender == VAR84 ||
msg.sender == sender ||
(VAR84 == address(this) && msg.sender == VAR14),
""
);
if (!VAR38) {
if (VAR31[VAR84].VAR20.FUN8(VAR40) > VAR84.VAR32) {
uint VAR85 = VAR31[VAR84].VAR20.FUN8(VAR31[VAR84].VAR24);
uint VAR86 = VAR84.VAR32.FUN8(FUN33());
if (VAR85.FUN8(VAR40) > VAR86) {
revert("");
}
}
}
VAR32[VAR84] = 0;
VAR39 --;
emit Transfer(VAR84, address(0), 1);
uint VAR87 = FUN40(VAR84, sender);
emit FUN26(
sender,
VAR84,
VAR31[VAR84].VAR23,
VAR40,
VAR31[VAR84].VAR20,
VAR31[VAR84].VAR24,
VAR31[VAR84].VAR21,
VAR31[VAR84].VAR22,
VAR87);
}
function FUN41(address payable VAR88) external {
require(VAR88 != address(this), "");
FUN42(VAR88, VAR88);
}
function FUN43(address payable VAR89) external onlyOwner {
FUN42(VAR89, address(this));
}
function FUN44(address VAR88) external onlyOwner {
require(address(VAR88) != address(0), "");
VAR43 = VAR88;
VAR44 = FUN21(VAR43);
bytes32 VAR90;
bool VAR91;
(VAR90, VAR91) = VAR44.FUN13();
require(VAR91, "");
}
function FUN45(address VAR88) external onlyOwner {
require(!VAR45, "");
require(address(VAR88) != address(0), "");
VAR48 = VAR88;
VAR49 = FUN22(VAR48);
VAR45 = true;
VAR46 = VAR79;
}
function FUN46(uint VAR80) external onlyOwner {
require(VAR80 > 0 && VAR80 <= VAR65, "");
VAR41 = VAR80;
}
function FUN47(uint VAR92) external onlyOwner {
require(VAR92 > 0 && VAR92 <= VAR64, "");
VAR42 = VAR92;
}
function FUN48() external onlyOwner {
VAR38 = true;
}
function FUN49(uint VAR93) public view returns (uint) {
return VAR93.FUN11(FUN50(VAR36.VAR30, VAR36.VAR29));
}
function FUN51(uint VAR94) public view returns (uint) {
if (VAR79 == VAR94)
{
return 0;
}
uint VAR95 = VAR79.FUN2(VAR94);
uint VAR96 = VAR95.FUN11(VAR42);
if (VAR96 > VAR62) {
VAR96 = VAR62;
}
return VAR96;
}
function FUN30(address VAR84) public view returns (uint) {
return VAR32[VAR84];
}
function FUN50(uint VAR97, uint VAR98) public view returns (uint) {
return VAR97.FUN1(VAR98.FUN8(FUN33()));
}
function FUN37(address VAR99) public view returns (uint) {
uint VAR100 = FUN50(VAR34[VAR99].VAR30, VAR34[VAR99].VAR29);
uint VAR101 = VAR5;
if (VAR100 >= VAR61) {
VAR101 = VAR100.FUN10(FUN50(VAR36.VAR30, VAR36.VAR29)).FUN1(VAR59);
if (VAR101 > VAR60) {
VAR101 = VAR60;
}
}
return VAR101;
}
function FUN52(address VAR99) public view returns (address[] VAR102) {
return VAR33[VAR99];
}
function FUN33() public view returns (uint) {
bytes32 VAR90;
bool VAR91;
(VAR90, VAR91) = VAR44.FUN13();
require(VAR91, "");
return uint(VAR90);
}
function FUN34(address VAR77) private {
VAR32[VAR77] = 1;
VAR33[msg.sender].FUN53(VAR77);
VAR39 ++;
emit Transfer(address(0), msg.sender, 1);
emit Transfer(msg.sender, VAR77, 1);
emit FUN27(msg.sender, VAR77);
}
function FUN40(address VAR84, address VAR99) private returns (uint VAR87) {
VAR87 = 0;
uint VAR21 = VAR31[VAR84].VAR21;
uint VAR22 = VAR31[VAR84].VAR22;
uint VAR103 = FUN50(VAR22, VAR21);
if (VAR103 > 0 ) {
uint VAR104 = FUN49(VAR103);
uint VAR105 = VAR104.FUN9(VAR37);
if (VAR38) {
VAR87 = VAR105;
} else {
uint VAR96 = FUN51(VAR31[VAR84].VAR23);
VAR87 = VAR105.FUN9(VAR96);
}
if (VAR21 > 0) {
VAR34[VAR99].VAR29 = VAR34[VAR99].VAR29.FUN2(VAR21);
VAR36.VAR29 = VAR36.VAR29.FUN2(VAR21);
VAR35[VAR84].VAR21 = VAR35[VAR84].VAR21.FUN1(VAR21);
emit FUN23(VAR84, '', VAR21);
} else if (VAR22 > 0) {
VAR34[VAR99].VAR30 = VAR34[VAR99].VAR30.FUN2(VAR22);
VAR36.VAR30 = VAR36.VAR30.FUN2(VAR22);
if (VAR45 && VAR31[VAR84].VAR23 > VAR46) {
VAR35[VAR84].VAR22 = VAR35[VAR84].VAR22.FUN1(VAR22);
} else {
VAR35[VAR84].VAR27 = VAR35[VAR84].VAR27.FUN1(VAR22);
}
emit FUN23(VAR84, '', VAR22);
}
if (VAR87 > 0) {
VAR87 = VAR87 / 2;
VAR37 = VAR37.FUN2(VAR87);
VAR35[VAR84].VAR26 = VAR35[VAR84].VAR26.FUN1(VAR87);
emit FUN23(VAR84, '', VAR87);
VAR37 = VAR37.FUN2(VAR87);
VAR35[VAR99].VAR26 = VAR35[VAR99].VAR26.FUN1(VAR87);
emit FUN23(VAR99, '', VAR87);
}
}
return VAR87;
}
function FUN38(uint VAR80) private pure returns (uint VAR106) {
require(VAR80 >= VAR56, "");
return (VAR80 / VAR56).FUN3(VAR56);
}
function FUN42(address payable VAR89, address VAR107) private {
require(address(VAR89) != address(0), "");
uint VAR108 = VAR35[VAR107].VAR26.FUN1(VAR35[VAR107].VAR21);
uint VAR109 = VAR35[VAR107].VAR22;
uint VAR110 = VAR35[VAR107].VAR27;
VAR35[VAR107] = FUN54(0,0,0,0);
emit FUN24(VAR89, VAR108, VAR110, VAR109);
if (VAR109 > 0) {
require(VAR49.FUN14(address(this), VAR89, VAR109), "");
}
if (VAR110 > 0) {
require(VAR50.FUN14(address(this), VAR89, VAR110), "");
}
if (VAR108 > 0) {
VAR89.transfer(VAR108);
}
}
}
0
---------------------------------
508 0x04da930237112bbdce8eb68fa4a27def08011041.sol
pragma VAR1 ^0.5.9;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3, "");
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3, "");
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4, "");
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0, "");
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0, "");
return VAR3 % VAR4;
}
}
contract VAR6 {
using SafeMath for uint256;
string public VAR7;
string public VAR8;
uint8 public VAR9;
uint256 public VAR10;
address public VAR11;
mapping (address => uint256) public VAR12;
mapping (address => mapping (address => uint256)) public VAR13;
event Transfer(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN6(address indexed VAR16, address indexed VAR17, uint256 VAR18);
constructor(
uint256 VAR19,
string memory VAR20,
uint8 VAR21,
string memory VAR22
) public {
VAR12[msg.sender] = VAR19;
VAR10 = VAR19;
VAR7 = VAR20;
VAR8 = VAR22;
VAR9 = VAR21;
VAR11 = msg.sender;
}
function transfer(address VAR23, uint256 VAR18) public {
require(VAR23 != address(0), "");
require(VAR18 > 0, "");
require (VAR12[msg.sender] >= VAR18, "");
require (VAR12[VAR23] + VAR18 >= VAR12[VAR23], "" );
uint VAR24 = VAR12[msg.sender] + VAR12[VAR23];
VAR12[msg.sender] = VAR2.FUN2(VAR12[msg.sender], VAR18);
VAR12[VAR23] = VAR2.FUN1(VAR12[VAR23], VAR18);
emit Transfer(msg.sender, VAR23, VAR18);
assert(VAR12[msg.sender] + VAR12[VAR23] == VAR24);
}
function FUN7(address VAR17, uint256 VAR18) public returns (bool VAR25) {
require (VAR18 > 0, "");
VAR13[msg.sender][VAR17] = VAR18;
emit FUN6(msg.sender, VAR17, VAR18);
return true;
}
function FUN8(address VAR26, address VAR23, uint256 VAR18) public returns (bool VAR25) {
require(VAR23 != address(0), "");
require(VAR18 > 0, "");
require( VAR12[VAR26] >= VAR18, "" );
require( VAR12[VAR23] + VAR18 > VAR12[VAR23], "" );
require( VAR18 <= VAR13[VAR26][msg.sender], "" );
VAR12[VAR26] = VAR2.FUN2(VAR12[VAR26], VAR18);
VAR12[VAR23] = VAR2.FUN1(VAR12[VAR23], VAR18);
VAR13[VAR26][msg.sender] = VAR2.FUN2(VAR13[VAR26][msg.sender], VAR18);
emit Transfer(VAR26, VAR23, VAR18);
return true;
}
}
0
---------------------------------
509 0x04de55d78639e7a87ca77d8b7f4bfafa9de547cf.sol
pragma VAR1 >=0.4.22 <0.6.0;
interface VAR2 {
function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external;
}
contract VAR7{
string public VAR8;
string public VAR9;
uint8 public VAR10 = 18;
uint256 public VAR11;
mapping (address => uint256) public VAR12;
mapping (address => mapping (address => uint256)) public VAR13;
event Transfer(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN2(address indexed VAR16, address indexed VAR17, uint256 VAR4);
event FUN3(address indexed VAR14, uint256 value);
constructor(
uint256 VAR18,
string memory VAR19,
string memory VAR20
) public {
VAR11 = VAR18 * 10 ** uint256(VAR10);
VAR12[msg.sender] = VAR11;
VAR8 = VAR19;
VAR9 = VAR20;
}
function FUN4(address VAR3, address VAR21, uint VAR4) internal {
require(VAR21 != address(0x0));
require(VAR12[VAR3] >= VAR4);
require(VAR12[VAR21] + VAR4 >= VAR12[VAR21]);
uint VAR22 = VAR12[VAR3] + VAR12[VAR21];
VAR12[VAR3] -= VAR4;
VAR12[VAR21] += VAR4;
emit Transfer(VAR3, VAR21, VAR4);
assert(VAR12[VAR3] + VAR12[VAR21] == VAR22);
}
function transfer(address VAR21, uint256 VAR4) public returns (bool VAR23) {
FUN4(msg.sender, VAR21, VAR4);
return true;
}
function FUN5(address VAR3, address VAR21, uint256 VAR4) public returns (bool VAR23) {
require(VAR4 <= VAR13[VAR3][msg.sender]);
VAR13[VAR3][msg.sender] -= VAR4;
FUN4(VAR3, VAR21, VAR4);
return true;
}
function FUN6(address VAR17, uint256 VAR4) public
returns (bool VAR23) {
VAR13[msg.sender][VAR17] = VAR4;
emit FUN2(msg.sender, VAR17, VAR4);
return true;
}
function FUN7(address VAR17, uint256 VAR4, bytes memory VAR6)
public
returns (bool VAR23) {
tokenRecipient VAR24 = FUN8(VAR17);
if (FUN6(VAR17, VAR4)) {
VAR24.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN9(uint256 VAR4) public returns (bool VAR23) {
require(VAR12[msg.sender] >= VAR4);
VAR12[msg.sender] -= VAR4;
VAR11 -= VAR4;
emit FUN3(msg.sender, VAR4);
return true;
}
function FUN10(address VAR3, uint256 VAR4) public returns (bool VAR23) {
require(VAR12[VAR3] >= VAR4);
require(VAR4 <= VAR13[VAR3][msg.sender]);
VAR12[VAR3] -= VAR4;
VAR13[VAR3][msg.sender] -= VAR4;
VAR11 -= VAR4;
emit FUN3(VAR3, VAR4);
return true;
}
}
0
---------------------------------
510 0x04e0e2dd8fdbca1d584927cdbdeb7a1314dff1f4.sol
pragma VAR1 ^0.4.12;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
constructor () public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN6(address VAR9) onlyOwner public {
require(VAR9 != address(0));
emit FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract VAR11 {
uint256 public VAR12;
function FUN7(address VAR13) public constant returns (uint256);
function transfer(address VAR14, uint256 value) public returns (bool);
event Transfer(address indexed VAR15, address indexed VAR14, uint256 value);
}
contract BasicToken is VAR11 {
using SafeMath for uint256;
mapping(address => uint256) VAR16;
function transfer(address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
VAR16[msg.sender] = VAR16[msg.sender].FUN3(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR18);
emit Transfer(msg.sender, VAR17, VAR18);
return true;
}
function FUN7(address VAR19) public constant returns (uint256 VAR20) {
return VAR16[VAR19];
}
}
contract ERC20 is VAR11 {
function FUN8(address VAR7, address VAR21) public constant returns (uint256);
function FUN9(address VAR15, address VAR14, uint256 value) public returns (bool);
function FUN10(address VAR21, uint256 value) public returns (bool);
event FUN11(address indexed VAR7, address indexed VAR21, uint256 value);
}
contract StandardToken is VAR22, VAR23 {
mapping (address => mapping (address => uint256)) VAR24;
function FUN9(address VAR25, address VAR17, uint256 VAR18) public returns (bool) {
require(VAR17 != address(0));
uint256 VAR26 = VAR24[VAR25][msg.sender];
VAR16[VAR25] = VAR16[VAR25].FUN3(VAR18);
VAR16[VAR17] = VAR16[VAR17].FUN4(VAR18);
VAR24[VAR25][msg.sender] = VAR26.FUN3(VAR18);
emit Transfer(VAR25, VAR17, VAR18);
return true;
}
function FUN10(address VAR27, uint256 VAR18) public returns (bool) {
VAR24[msg.sender][VAR27] = VAR18;
emit FUN11(msg.sender, VAR27, VAR18);
return true;
}
function FUN8(address VAR19, address VAR27) public constant returns (uint256 VAR28) {
return VAR24[VAR19][VAR27];
}
function FUN12 (address VAR27, uint VAR29) public
returns (bool VAR30) {
VAR24[msg.sender][VAR27] = VAR24[msg.sender][VAR27].FUN4(VAR29);
emit FUN11(msg.sender, VAR27, VAR24[msg.sender][VAR27]);
return true;
}
function FUN13 (address VAR27, uint VAR31) public
returns (bool VAR30) {
uint VAR32 = VAR24[msg.sender][VAR27];
if (VAR31 > VAR32) {
VAR24[msg.sender][VAR27] = 0;
} else {
VAR24[msg.sender][VAR27] = VAR32.FUN3(VAR31);
}
emit FUN11(msg.sender, VAR27, VAR24[msg.sender][VAR27]);
return true;
}
}
contract BurnableToken is VAR33 {
event FUN14(address indexed VAR34, uint256 value);
function FUN15(uint256 VAR18) public {
require(VAR18 > 0);
require(VAR18 <= VAR16[msg.sender]);
address VAR34 = msg.sender;
VAR16[VAR34] = VAR16[VAR34].FUN3(VAR18);
VAR12 = VAR12.FUN3(VAR18);
emit FUN14(VAR34, VAR18);
emit Transfer(VAR34, address(0), VAR18);
}
}
contract Token is VAR35, VAR6 {
string public constant VAR36 = "";
string public constant VAR37 = "";
uint public constant VAR38 = 18;
uint256 public constant VAR39 = 100000000 * (10 ** uint256(VAR38));
constructor () public {
VAR12 = VAR39;
VAR16[msg.sender] = VAR39;
emit Transfer(0x0, VAR7, VAR39);
}
}
interface VAR40 { function transfer(address VAR41, uint VAR42) external; }
contract Bloktrade is VAR43 {
using SafeMath for uint256;
uint256 public VAR44 = 3000;
token VAR45;
uint256 public VAR46;
event FUN16(address indexed VAR47, address indexed VAR48, uint256 value, uint256 VAR42);
constructor () public {
VAR45 = FUN17(address(this));
}
bool public VAR49 = true;
function FUN18() onlyOwner public {
VAR49 = true;
}
function FUN19() onlyOwner public {
VAR49 = false;
}
function FUN20(uint256 VAR50) onlyOwner public {
VAR44 = VAR50;
}
function () payable public {
FUN21(msg.sender);
}
function FUN21(address VAR48) payable public {
require(VAR48 != 0x0);
require(FUN22());
uint256 VAR51 = msg.value;
uint256 VAR52 = (VAR51) * VAR44;
VAR46 = VAR46.FUN4(VAR51);
VAR45.transfer(VAR48, VAR52);
emit FUN16(msg.sender, VAR48, VAR51, VAR52);
FUN23();
}
function FUN23() internal {
VAR7.transfer(msg.value);
}
function FUN22() internal constant returns (bool) {
bool VAR53 = VAR49;
bool VAR54 = msg.value != 0;
return VAR53 && VAR54;
}
function FUN24(uint256 VAR55) onlyOwner public {
VAR45.transfer(VAR7,VAR55);
}
} 
0
---------------------------------
511 0x04e4ec207830356bea9202e27c05b14ec9d256f2.sol
pragma VAR1 ^0.4.13;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
event FUN5(address indexed VAR8, address indexed VAR9);
function FUN6() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
FUN5(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract VestingFund is VAR6 {
using SafeMath for uint256;
using SafeERC20 for VAR11;
event FUN8(uint256 VAR12);
address public VAR13;
ERC20Basic public VAR14;
uint256 public VAR15;
uint256 public VAR16;
uint256 public VAR17;
function FUN9(address VAR18, uint256 VAR19, uint256 VAR20, address VAR21) public {
require(VAR18 != address(0) && VAR21 != address(0));
require(VAR20 > 0);
VAR13 = VAR18;
VAR15 = VAR20;
VAR16 = VAR19;
VAR14 = FUN10(VAR21);
}
function FUN11() public {
uint256 VAR22 = FUN12();
require(VAR22 > 0);
VAR17 = VAR17.FUN4(VAR22);
VAR14.FUN13(VAR13, VAR22);
FUN8(VAR22);
}
function FUN12() public view returns(uint256) {
return FUN14().FUN3(VAR17);
}
function FUN14() public view returns(uint256) {
uint256 VAR23 = VAR14.FUN15(this);
uint256 VAR24 = VAR23.FUN4(VAR17);
if (VAR25 < VAR16) {
return 0;
}
uint256 VAR26 = VAR25.FUN3(VAR16);
uint256 VAR27 = VAR26.FUN2(90 VAR28);
if (VAR27 >= VAR15) {
return VAR24;
} else {
return VAR24.FUN1(VAR27).FUN2(VAR15);
}
}
}
contract VAR11 {
function FUN16() public view returns (uint256);
function FUN15(address VAR29) public view returns (uint256);
function transfer(address VAR30, uint256 value) public returns (bool);
event Transfer(address indexed VAR31, address indexed VAR30, uint256 value);
}
contract ERC20 is VAR11 {
function FUN17(address VAR7, address VAR32) public view returns (uint256);
function FUN18(address VAR31, address VAR30, uint256 value) public returns (bool);
function FUN19(address VAR32, uint256 value) public returns (bool);
event FUN20(address indexed VAR7, address indexed VAR32, uint256 value);
}
library VAR33 {
function FUN13(ERC20Basic VAR14, address VAR30, uint256 value) internal {
assert(VAR14.transfer(VAR30, value));
}
function FUN21(ERC20 VAR14, address VAR31, address VAR30, uint256 value) internal {
assert(VAR14.FUN18(VAR31, VAR30, value));
}
function FUN22(ERC20 VAR14, address VAR32, uint256 value) internal {
assert(VAR14.FUN19(VAR32, value));
}
}
0
---------------------------------
512 0x04e9b27dc521158035764e96917813093bc2f748.sol
pragma VAR1 ^0.5.7;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint) {
uint VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint) {
uint VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint) {
uint VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
address public VAR8;
constructor() public {
VAR7 = msg.sender;
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7, "");
VAR9;
}
function FUN5(address VAR10) public onlyOwner {
VAR7 = VAR10;
}
}
contract ETHStvo is VAR6 {
event FUN6(uint indexed VAR11, uint indexed VAR12, uint indexed VAR13, uint VAR14);
event FUN7(uint indexed VAR11, uint indexed VAR12, uint indexed VAR13, uint VAR14);
event FUN8(uint indexed VAR11, uint VAR15, uint VAR16, uint VAR14);
event FUN9(uint indexed VAR11, uint indexed VAR12, uint indexed VAR13, uint VAR15, uint VAR17, uint VAR18, uint VAR14);
event FUN10(uint indexed VAR12, uint indexed VAR19, uint VAR15, uint VAR17, uint VAR14);
mapping (uint => uint) public VAR20;
mapping (uint => uint) public VAR21;
uint VAR22 = 3;
struct VAR23 {
bool VAR24;
address VAR25;
uint VAR26;
uint VAR27;
address[] VAR28;
mapping (uint => bool) VAR29;
}
mapping (uint => VAR23) public VAR30;
mapping (address => uint) public VAR31;
uint public VAR32 = 0;
uint public VAR33 = 0 VAR34;
uint public VAR35 = 0 VAR34;
bool public VAR36 = false;
bool public VAR37 = true;
constructor() public {
VAR20[1] = 0.05 VAR34;
VAR20[2] = 0.15 VAR34;
VAR20[3] = 0.60 VAR34;
VAR20[4] = 2.70 VAR34;
VAR20[5] = 24.75 VAR34;
VAR20[6] = 37.50 VAR34;
VAR20[7] = 72.90 VAR34;
VAR20[8] = 218.70 VAR34;
VAR20[9] = 385.00 VAR34;
VAR20[10] = 700.00 VAR34;
VAR20[11] = 1250.00 VAR34;
VAR20[12] = 2500.00 VAR34;
VAR20[13] = 5500.00 VAR34;
VAR20[14] = 7500.00 VAR34;
VAR20[15] = 10000.00 VAR34;
VAR20[16] = 15000.00 VAR34;
VAR21[5] = 2.25 VAR34;
VAR21[9] = 35.00 VAR34;
VAR21[13] = 500.00 VAR34;
UserStruct memory VAR38;
VAR32++;
VAR38 = FUN11({
VAR24 : true,
VAR25 : VAR8,
VAR26 : 0,
VAR27 : 0,
VAR28 : new address[](0)
});
VAR30[VAR32] = VAR38;
VAR31[VAR8] = VAR32;
VAR30[VAR32].VAR29[1] = true;
VAR30[VAR32].VAR29[2] = true;
VAR30[VAR32].VAR29[3] = true;
VAR30[VAR32].VAR29[4] = true;
VAR30[VAR32].VAR29[5] = true;
VAR30[VAR32].VAR29[6] = true;
VAR30[VAR32].VAR29[7] = true;
VAR30[VAR32].VAR29[8] = true;
VAR30[VAR32].VAR29[9] = true;
VAR30[VAR32].VAR29[10] = true;
VAR30[VAR32].VAR29[11] = true;
VAR30[VAR32].VAR29[12] = true;
VAR30[VAR32].VAR29[13] = true;
VAR30[VAR32].VAR29[14] = true;
VAR30[VAR32].VAR29[15] = true;
VAR30[VAR32].VAR29[16] = true;
}
function FUN12(address VAR39) public onlyOwner {
require(VAR31[VAR39] == 0, '');
delete VAR31[VAR8];
VAR31[VAR39] = uint(1);
VAR8 = VAR39;
VAR30[1].VAR25 = VAR39;
}
function FUN13(bool VAR40) public onlyOwner {
VAR36 = VAR40;
}
function FUN14(bool VAR41) public onlyOwner {
VAR37 = VAR41;
}
function FUN15(uint VAR15, uint VAR16) public onlyOwner {
VAR20[VAR15] = VAR16;
}
function FUN16(uint VAR15, uint VAR16) public onlyOwner {
VAR21[VAR15] = VAR16;
}
function FUN17(uint VAR42) public onlyOwner {
VAR32 = VAR42;
}
function FUN18(uint VAR43, address VAR44, uint VAR45, uint VAR46, address VAR47, address VAR48, address VAR49, uint VAR50) public onlyOwner {
require(VAR43 > 0, '');
require(VAR44 != address(0), '');
require(VAR45 > 0, '');
require(VAR46 > 0, '');
if(VAR43 > VAR32){
VAR32++;
}
if(VAR30[VAR43].VAR24){
delete VAR31[VAR30[VAR43].VAR25];
delete VAR30[VAR43];
}
UserStruct memory VAR38;
VAR38 = FUN11({
VAR24 : true,
VAR25 : VAR44,
VAR26 : VAR45,
VAR27 : VAR46,
VAR28 : new address[](0)
});
VAR30[VAR43] = VAR38;
VAR31[VAR44] = VAR43;
for(uint VAR3 = 1; VAR3 <= uint(16); VAR3++){
if(VAR3 <= VAR50){
VAR30[VAR43].VAR29[VAR3] = true;
} else {
VAR30[VAR43].VAR29[VAR3] = false;
}
}
if(VAR47 != address(0)){
VAR30[VAR43].VAR28.FUN19(VAR47);
}
if(VAR48 != address(0)){
VAR30[VAR43].VAR28.FUN19(VAR48);
}
if(VAR49 != address(0)){
VAR30[VAR43].VAR28.FUN19(VAR49);
}
}
function () external payable {
require(!VAR36, '');
uint VAR50;
if(msg.value == VAR20[1]){
VAR50 = 1;
}else if(msg.value == VAR20[2]){
VAR50 = 2;
}else if(msg.value == VAR20[3]){
VAR50 = 3;
}else if(msg.value == VAR20[4]){
VAR50 = 4;
}else if(msg.value == VAR20[5]){
VAR50 = 5;
}else if(msg.value == VAR20[6]){
VAR50 = 6;
}else if(msg.value == VAR20[7]){
VAR50 = 7;
}else if(msg.value == VAR20[8]){
VAR50 = 8;
}else if(msg.value == VAR20[9]){
VAR50 = 9;
}else if(msg.value == VAR20[10]){
VAR50 = 10;
}else if(msg.value == VAR20[11]){
VAR50 = 11;
}else if(msg.value == VAR20[12]){
VAR50 = 12;
}else if(msg.value == VAR20[13]){
VAR50 = 13;
}else if(msg.value == VAR20[14]){
VAR50 = 14;
}else if(msg.value == VAR20[15]){
VAR50 = 15;
}else if(msg.value == VAR20[16]){
VAR50 = 16;
}else {
revert('');
}
if(VAR50 == 1){
uint VAR26 = 0;
address VAR51 = FUN20(msg.VAR52);
if (VAR31[VAR51] > 0 && VAR31[VAR51] <= VAR32){
VAR26 = VAR31[VAR51];
} else {
revert('');
}
if(VAR30[VAR31[msg.sender]].VAR24){
FUN21(VAR26);
} else {
FUN22(VAR26);
}
} else if(VAR30[VAR31[msg.sender]].VAR24){
FUN23(VAR50);
} else {
revert("");
}
}
function FUN21(uint VAR45) internal {
require(VAR37, '');
require(VAR30[VAR31[msg.sender]].VAR24, '');
require(VAR31[msg.sender] != VAR45, '');
require(VAR30[VAR31[msg.sender]].VAR26 != VAR45 && VAR30[VAR31[msg.sender]].VAR27 != VAR45, '');
require(VAR45 > 0 && VAR45 <= VAR32, '');
require(msg.value==VAR20[1], '');
require(VAR30[VAR31[msg.sender]].VAR29[2] == false, '');
uint VAR46 = VAR45;
uint VAR53 = VAR30[VAR31[msg.sender]].VAR26;
if(VAR30[VAR45].VAR28.VAR54 >= VAR22)
{
VAR45 = VAR31[FUN24(VAR45)];
}
VAR30[VAR31[msg.sender]].VAR26 = VAR45;
VAR30[VAR31[msg.sender]].VAR27 = VAR46;
VAR30[VAR45].VAR28.FUN19(msg.sender);
uint VAR55 = VAR2.FUN3(uint(VAR30[VAR53].VAR28.VAR54),uint(1));
address[] memory VAR56 = new address[](VAR55);
for(uint VAR3 = 0; VAR3 <= VAR55; VAR3++){
if(VAR30[VAR53].VAR28[VAR3] != msg.sender){
VAR56[VAR3] = VAR30[VAR53].VAR28[VAR3];
}
}
for(uint VAR4 = 0; VAR4 <= VAR55; VAR4++){
VAR30[VAR53].VAR28.FUN25();
}
uint VAR57 = VAR2.FUN3(uint(VAR56.VAR54),uint(1));
for(uint VAR5 = 0; VAR5 <= VAR57; VAR5++){
if(VAR56[VAR5] != address(0)){
VAR30[VAR53].VAR28.FUN19(VAR56[VAR5]);
}
}
FUN26(VAR31[msg.sender], 1);
emit FUN7(VAR31[msg.sender], VAR45, VAR46, VAR58);
}
function FUN22(uint VAR45) internal {
require(!VAR30[VAR31[msg.sender]].VAR24, '');
require(VAR45 > 0 && VAR45 <= VAR32, '');
require(msg.value==VAR20[1], '');
uint VAR46 = VAR45;
if(VAR30[VAR45].VAR28.VAR54 >= VAR22)
{
VAR45 = VAR31[FUN24(VAR45)];
}
UserStruct memory VAR38;
VAR32++;
VAR38 = FUN11({
VAR24 : true,
VAR25 : msg.sender,
VAR26 : VAR45,
VAR27 : VAR46,
VAR28 : new address[](0)
});
VAR30[VAR32] = VAR38;
VAR31[msg.sender] = VAR32;
VAR30[VAR32].VAR29[1] = true;
VAR30[VAR32].VAR29[2] = false;
VAR30[VAR32].VAR29[3] = false;
VAR30[VAR32].VAR29[4] = false;
VAR30[VAR32].VAR29[5] = false;
VAR30[VAR32].VAR29[6] = false;
VAR30[VAR32].VAR29[7] = false;
VAR30[VAR32].VAR29[8] = false;
VAR30[VAR32].VAR29[9] = false;
VAR30[VAR32].VAR29[10] = false;
VAR30[VAR32].VAR29[11] = false;
VAR30[VAR32].VAR29[12] = false;
VAR30[VAR32].VAR29[13] = false;
VAR30[VAR32].VAR29[14] = false;
VAR30[VAR32].VAR29[15] = false;
VAR30[VAR32].VAR29[16] = false;
VAR30[VAR45].VAR28.FUN19(msg.sender);
FUN26(VAR32, 1);
emit FUN6(VAR32, VAR45, VAR46, VAR58);
}
function FUN23(uint VAR15) internal {
require(VAR30[VAR31[msg.sender]].VAR24, '');
require( VAR15 >= 2 && VAR15 <= 16, '');
require(msg.value==VAR20[VAR15], '');
require(VAR30[VAR31[msg.sender]].VAR29[VAR15] == false, '');
uint VAR59 = VAR2.FUN3(VAR15,uint(1));
require(VAR30[VAR31[msg.sender]].VAR29[VAR59] == true, '');
VAR30[VAR31[msg.sender]].VAR29[VAR15] = true;
FUN26(VAR31[msg.sender], VAR15);
emit FUN8(VAR31[msg.sender], VAR15, VAR20[VAR15], VAR58);
}
function FUN26(uint VAR11, uint VAR15) internal {
address VAR51;
address VAR60;
uint VAR61;
uint VAR62;
uint VAR63;
uint VAR64;
uint VAR65;
if(VAR15 == 1 || VAR15 == 5 || VAR15 == 9 || VAR15 == 13){
VAR61 = VAR30[VAR11].VAR26;
} else if(VAR15 == 2 || VAR15 == 6 || VAR15 == 10 || VAR15 == 14){
VAR62 = VAR30[VAR11].VAR26;
VAR61 = VAR30[VAR62].VAR26;
} else if(VAR15 == 3 || VAR15 == 7 || VAR15 == 11 || VAR15 == 15){
VAR62 = VAR30[VAR11].VAR26;
VAR63 = VAR30[VAR62].VAR26;
VAR61 = VAR30[VAR63].VAR26;
} else if(VAR15 == 4 || VAR15 == 8 || VAR15 == 12 || VAR15 == 16){
VAR62 = VAR30[VAR11].VAR26;
VAR63 = VAR30[VAR62].VAR26;
VAR64 = VAR30[VAR63].VAR26;
VAR61 = VAR30[VAR64].VAR26;
}
if(!VAR30[VAR61].VAR24 || VAR30[VAR61].VAR29[VAR15] == false){
VAR51 = VAR8;
} else {
VAR51 = VAR30[VAR61].VAR25;
}
VAR65 = VAR20[VAR15];
if(VAR21[VAR15] > 0){
bool VAR66;
VAR66 = address(FUN27(VAR8)).FUN28(VAR21[VAR15]);
VAR65 = VAR2.FUN3(VAR65,VAR21[VAR15]);
VAR35 = VAR2.FUN4(VAR35,VAR65);
}
VAR33 = VAR2.FUN4(VAR33,VAR65);
if(VAR15>=3){
if(!VAR30[VAR30[VAR11].VAR27].VAR24){
VAR60 = VAR8;
} else {
VAR60 = VAR30[VAR30[VAR11].VAR27].VAR25;
}
VAR65 = VAR2.FUN2(VAR65,2);
bool VAR67;
VAR67 = address(FUN27(VAR51)).FUN28(VAR65);
bool VAR68;
VAR68 = address(FUN27(VAR60)).FUN28(VAR65);
} else {
bool VAR69;
VAR69 = address(FUN27(VAR51)).FUN28(VAR65);
}
if(VAR30[VAR61].VAR29[VAR15] == false ){
emit FUN10(VAR61, VAR31[msg.sender], VAR15, VAR65, VAR58);
}
emit FUN9(VAR31[msg.sender], VAR31[VAR51], VAR31[VAR60], VAR15, VAR65, VAR21[VAR15], VAR58);
}
function FUN24(uint VAR11) public view returns(address) {
require(VAR30[VAR11].VAR24, '');
if(VAR30[VAR11].VAR28.VAR54 < VAR22){
return VAR30[VAR11].VAR25;
}
address[] memory VAR56 = new address[](363);
VAR56[0] = VAR30[VAR11].VAR28[0];
VAR56[1] = VAR30[VAR11].VAR28[1];
VAR56[2] = VAR30[VAR11].VAR28[2];
address VAR70;
bool VAR71 = true;
for(uint VAR72 = 0; VAR72 < 363; VAR72++){
if(VAR30[VAR31[VAR56[VAR72]]].VAR28.VAR54 == VAR22){
if(VAR72 < 120){
VAR56[(VAR72+1)*3] = VAR30[VAR31[VAR56[VAR72]]].VAR28[0];
VAR56[(VAR72+1)*3+1] = VAR30[VAR31[VAR56[VAR72]]].VAR28[1];
VAR56[(VAR72+1)*3+2] = VAR30[VAR31[VAR56[VAR72]]].VAR28[2];
}
} else {
VAR71 = false;
VAR70 = VAR56[VAR72];
break;
}
}
require(!VAR71, '');
return VAR70;
}
function FUN29(uint VAR11) public view returns(address[] VAR73) {
return VAR30[VAR11].VAR28;
}
function FUN30(uint VAR11, uint VAR15) public view returns(bool) {
return VAR30[VAR11].VAR29[VAR15];
}
function FUN20(bytes memory VAR74) private pure returns (address  VAR75) {
VAR76 {
VAR75 := FUN31(FUN4(VAR74, 20))
}
}
}
0
---------------------------------
513 0x04ead19ff234b55a6e65391fe553d4baaa5b7ebb.sol
pragma VAR1 ^0.5.8;
library VAR2
{
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256)
{
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256)
{
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256)
{
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256)
{
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6
{
address public VAR7;
address public VAR8;
address public VAR9;
address public VAR10;
uint public VAR11;
mapping (address => bool) public VAR12;
event FUN5(address indexed VAR13, address indexed VAR14, uint indexed VAR15);
modifier onlyOwner
{
require(msg.sender == VAR8 ||msg.sender == VAR9);
VAR16;
}
modifier VAR17
{
require(msg.sender == VAR7);
VAR16;
}
constructor() public
{
VAR7 = msg.sender;
}
function FUN6(address VAR14) onlyMaster public
{
require(VAR14 != address(0x0));
VAR8 = VAR14;
}
function FUN7(address VAR14) onlyMaster public
{
require(VAR14 != address(0x0));
VAR9 = VAR14;
}
}
contract VAR18
{
event Transfer( address indexed VAR13, address indexed VAR14, uint VAR19);
event FUN8( address indexed VAR20, address indexed VAR21, uint VAR19);
function FUN9() view public returns (uint VAR22);
function FUN10( address VAR23 ) public view returns (uint VAR19);
function transfer( address VAR14, uint VAR19) public returns (bool VAR24);
function FUN11( address VAR21, uint VAR19 ) public returns (bool VAR24);
function FUN12( address VAR20, address VAR21 ) public view returns (uint VAR25);
function FUN13( address VAR13, address VAR14, uint VAR19) public returns (bool VAR24);
}
contract ITAMToken is VAR18, VAR6
{
using SafeMath for uint;
string public VAR26;
uint public VAR27;
string public VAR28;
uint constant private VAR29 = 1000000000000000000;
uint constant private VAR30 = 2592000;
uint constant public VAR31 =           2500000000 * VAR29;
uint constant public VAR32 =          125000000 * VAR29;
uint constant public VAR33 =            250000000 * VAR29;
uint constant public VAR34 =             375000000 * VAR29;
uint constant public VAR35 =             750000000 * VAR29;
uint constant public VAR36 =            1000000000 * VAR29;
uint constant public VAR37 =         130000000 * VAR29;
uint constant public VAR38 =     345000000 * VAR29;
uint constant public VAR39 =      525000000 * VAR29;
uint constant public VAR40 = 25000000 * VAR29;
uint constant public VAR41 = 2 * VAR30;
uint constant public VAR42 = 5;
uint constant public VAR43   = 12500000 * VAR29;
uint constant public VAR44 = 6 * VAR30;
uint constant public VAR45 = 1 * VAR30;
uint constant public VAR46 = 20;
uint constant public VAR47      = 125000000 * VAR29;
uint constant public VAR48    =  25000000 * VAR29;
uint constant public VAR49 = 1 * VAR30;
uint constant public VAR50 = 11;
uint constant public VAR51      = 250000000 * VAR29;
uint constant public VAR52    =  50000000 * VAR29;
uint constant public VAR53 = 1 * VAR30;
uint constant public VAR54 = 11;
uint constant public VAR55 = 1 * VAR30;
uint constant public VAR56 = 5;
uint constant public VAR57 = 1 * VAR30;
uint constant public VAR58 = 6;
uint public VAR59;
uint public VAR60;
uint public VAR61;
uint public VAR62;
uint public VAR63;
uint public VAR64;
uint public VAR65;
uint public VAR66;
uint public VAR67;
uint public VAR68;
mapping (address => uint) public VAR69;
mapping (address => mapping ( address => uint )) public VAR70;
mapping (address => bool) public VAR71;
mapping (uint => uint) public VAR72;
mapping (uint => uint) public VAR73;
mapping (uint => uint) public VAR74;
mapping (uint => uint) public VAR75;
mapping (uint => uint) public VAR76;
mapping (uint => uint) public VAR77;
mapping (uint => uint) public VAR78;
mapping (uint => uint) public VAR79;
mapping (uint => uint) public VAR80;
mapping (address => mapping ( uint => uint )) public VAR81;
mapping (uint => uint) public VAR82;
mapping (address => mapping ( uint => uint )) public VAR83;
bool public VAR84 = true;
bool public VAR85 = true;
uint public VAR86 = 0;
event FUN14(address indexed VAR14, uint VAR87);
event FUN15(address indexed VAR14, uint VAR87);
event FUN16(address indexed VAR14, uint VAR87);
event FUN17(address indexed VAR14, uint VAR87);
event FUN18(address indexed VAR14, uint VAR87);
event FUN19(address indexed VAR13, uint VAR19);
event FUN20(address indexed VAR14, uint VAR87);
event FUN21(uint VAR88);
constructor() public
{
VAR26        = "";
VAR27    = 18;
VAR28      = "";
VAR59    = 0;
VAR60   = 0;
VAR61     = 0;
VAR62      = 0;
VAR63      = 0;
VAR64     = 0;
VAR65       = 0;
VAR66   = 0;
VAR67    = 0;
VAR68     = 0;
require(VAR32 == VAR40 * VAR42, "");
require(VAR33 == VAR43 * VAR46, "");
require(VAR34 == VAR47 + ( VAR48 * ( VAR50 - 1 ) ) , "");
require(VAR35 == VAR51 + ( VAR52 * ( VAR54 - 1 ) ) , "");
uint VAR89 = 0;
for(uint VAR90 = 0; VAR90 < VAR56; VAR90++)
{
VAR89 = VAR89.FUN4(20);
}
require(100 == VAR89, "");
uint VAR91 = 0;
for(uint VAR90 = 0; VAR90 < VAR58; VAR90++)
{
if(VAR90 <= 3)
{
VAR91 = VAR91.FUN4(20);
}
else
{
VAR91 = VAR91.FUN4(10);
}
}
require(100 == VAR91, "");
require(VAR31 == VAR32 + VAR33 + VAR34 + VAR35 + VAR36, "");
require(VAR36 == VAR37 + VAR38 + VAR39, "");
}
function FUN9() view public returns (uint)
{
return VAR59;
}
function FUN10(address VAR23) view public returns (uint)
{
return VAR69[VAR23];
}
function FUN22(address VAR23) view public returns (uint)
{
uint VAR92 = VAR69[VAR23];
uint VAR93 = (VAR81[VAR23][0] + VAR81[VAR23][1] + VAR81[VAR23][2] + VAR81[VAR23][3] + VAR81[VAR23][4]);
uint VAR94 = (VAR83[VAR23][0] + VAR83[VAR23][1] + VAR83[VAR23][2] + VAR83[VAR23][3] + VAR83[VAR23][4] + VAR83[VAR23][5]);
VAR92 = VAR92.FUN4(VAR93);
VAR92 = VAR92.FUN4(VAR94);
return VAR92;
}
function transfer(address VAR14, uint VAR19) public returns (bool)
{
require(FUN23(msg.sender) == true);
require(FUN23(VAR14) == true);
require(VAR69[msg.sender] >= VAR19);
VAR69[msg.sender] = VAR69[msg.sender].FUN3(VAR19);
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR19);
emit Transfer(msg.sender, VAR14, VAR19);
return true;
}
function FUN11(address VAR21, uint VAR19) public returns (bool)
{
require(FUN23(msg.sender) == true);
require(VAR69[msg.sender] >= VAR19);
VAR70[msg.sender][VAR21] = VAR19;
emit FUN8(msg.sender, VAR21, VAR19);
return true;
}
function FUN12(address VAR20, address VAR21) view public returns (uint)
{
return VAR70[VAR20][VAR21];
}
function FUN13(address VAR13, address VAR14, uint VAR19) public returns (bool)
{
require(FUN23(VAR13) == true);
require(FUN23(VAR14) == true);
require(VAR69[VAR13] >= VAR19);
require(VAR70[VAR13][msg.sender] >= VAR19);
VAR70[VAR13][msg.sender] = VAR70[VAR13][msg.sender].FUN3(VAR19);
VAR69[VAR13] = VAR69[VAR13].FUN3(VAR19);
VAR69[VAR14]  = VAR69[VAR14].FUN4(VAR19);
emit Transfer(VAR13, VAR14, VAR19);
return true;
}
function FUN24(address VAR14, uint VAR95) onlyOwner public
{
require(VAR85 == false);
require( VAR95 < VAR42);
uint VAR96 = VAR97;
require( VAR96 > VAR72[VAR95] );
uint VAR98 = VAR40;
require(VAR98 <= VAR73[VAR95]);
require(VAR98 > 0);
require(VAR32 >= VAR60.FUN4(VAR98));
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR98);
VAR73[VAR95] = 0;
VAR59 = VAR59.FUN4(VAR98);
VAR60 = VAR60.FUN4(VAR98);
emit FUN14(VAR14, VAR98);
}
function FUN25(address VAR14, uint VAR95) onlyOwner public
{
require(VAR85 == false);
require( VAR95 < VAR46);
uint VAR96 = VAR97;
require( VAR96 > VAR74[VAR95] );
uint VAR98 = VAR43;
require(VAR98 <= VAR75[VAR95]);
require(VAR98 > 0);
require(VAR33 >= VAR61.FUN4(VAR98));
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR98);
VAR75[VAR95] = 0;
VAR59 = VAR59.FUN4(VAR98);
VAR61 = VAR61.FUN4(VAR98);
emit FUN15(VAR14, VAR98);
}
function FUN26(address VAR14, uint VAR95, uint VAR19) onlyOwner public
{
require(VAR85 == false);
require( VAR95 < VAR50);
uint VAR96 = VAR97;
require( VAR96 > VAR76[VAR95] );
uint VAR98 = VAR19 * VAR29;
require(VAR98 <= VAR77[VAR95]);
require(VAR98 > 0);
require(VAR34 >= VAR62.FUN4(VAR98));
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR98);
VAR77[VAR95] = VAR77[VAR95].FUN3(VAR98);
VAR59 = VAR59.FUN4(VAR98);
VAR62 = VAR62.FUN4(VAR98);
emit FUN16(VAR14, VAR98);
}
function FUN27(address VAR14, uint VAR95, uint VAR19) onlyOwner public
{
require(VAR85 == false);
require( VAR95 < VAR54);
uint VAR96 = VAR97;
require( VAR96 > VAR78[VAR95] );
uint VAR98 = VAR19 * VAR29;
require(VAR98 <= VAR79[VAR95]);
require(VAR98 > 0);
require(VAR35 >= VAR63.FUN4(VAR98));
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR98);
VAR79[VAR95] = VAR79[VAR95].FUN3(VAR98);
VAR59 = VAR59.FUN4(VAR98);
VAR63 = VAR63.FUN4(VAR98);
emit FUN17(VAR14, VAR98);
}
function FUN28(address VAR14, uint VAR19) onlyOwner public
{
uint VAR98 = VAR19 * VAR29;
require(VAR36 >= VAR64.FUN4(VAR98));
require(VAR37 >= VAR65.FUN4(VAR98));
require(VAR98 > 0);
for(uint VAR90 = 0; VAR90 < VAR56; VAR90++)
{
uint VAR99 = VAR98.FUN1(20) / 100;
VAR81[VAR14][VAR90] = VAR99;
}
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR81[VAR14][0]);
VAR81[VAR14][0] = 0;
VAR59 = VAR59.FUN4(VAR98);
VAR64 = VAR64.FUN4(VAR98);
VAR65 = VAR65.FUN4(VAR98);
emit FUN18(VAR14, VAR98);
}
function FUN29(address VAR14, uint VAR95) onlyOwner public
{
require(VAR85 == false);
require( VAR95 < VAR56);
uint VAR96 = VAR97;
require( VAR96 > VAR80[VAR95] );
uint VAR98 = VAR81[VAR14][VAR95];
require(VAR98 > 0);
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR98);
VAR81[VAR14][VAR95] = 0;
emit FUN20(VAR14, VAR98);
}
function FUN30(address VAR14, uint VAR19) onlyOwner public
{
uint VAR98 = VAR19 * VAR29;
require(VAR36 >= VAR64.FUN4(VAR98));
require(VAR38 >= VAR66.FUN4(VAR98));
require(VAR98 > 0);
for(uint VAR90 = 0; VAR90 < VAR58; VAR90++)
{
uint VAR100 = 20;
if(VAR90 >= 4)
{
VAR100 = 10;
}
uint VAR99 = VAR98.FUN1(VAR100) / 100;
VAR83[VAR14][VAR90] = VAR99;
}
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR83[VAR14][0]);
VAR83[VAR14][0] = 0;
VAR59 = VAR59.FUN4(VAR98);
VAR64 = VAR64.FUN4(VAR98);
VAR66 = VAR66.FUN4(VAR98);
emit FUN18(VAR14, VAR98);
}
function FUN31(address VAR14, uint VAR95) onlyOwner public
{
require(VAR85 == false);
require( VAR95 < VAR58);
uint VAR96 = VAR97;
require( VAR96 > VAR82[VAR95] );
uint VAR98 = VAR83[VAR14][VAR95];
require(VAR98 > 0);
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR98);
VAR83[VAR14][VAR95] = 0;
emit FUN20(VAR14, VAR98);
}
function FUN32(address VAR14, uint VAR19) onlyOwner public
{
uint VAR98 = VAR19 * VAR29;
require(VAR36 >= VAR64.FUN4(VAR98));
VAR69[VAR14] = VAR69[VAR14].FUN4(VAR98);
VAR59 = VAR59.FUN4(VAR98);
VAR64 = VAR64.FUN4(VAR98);
VAR67 = VAR67.FUN4(VAR98);
emit FUN18(VAR14, VAR98);
}
function FUN23(address VAR23) private view returns (bool)
{
if(VAR71[VAR23] == true)
{
return false;
}
if(VAR84 == false)
{
return true;
}
else if(msg.sender == VAR8 || msg.sender == VAR9)
{
return true;
}
return false;
}
function FUN33() onlyOwner public
{
require(VAR84 == true);
require(VAR85 == false);
VAR84 = false;
}
function FUN34() onlyOwner public
{
require(VAR84 == false);
VAR84 = true;
}
function () payable external
{
revert();
}
function FUN35() onlyOwner public
{
require(VAR85 == true);
require(VAR36 == VAR64);
VAR85 = false;
uint VAR96 = VAR97;
VAR86 = VAR96;
for(uint VAR90 = 0; VAR90 < VAR42; VAR90++)
{
uint VAR101 = VAR86 + (VAR41 * VAR90);
VAR72[VAR90] = VAR101;
VAR73[VAR90] = VAR73[VAR90].FUN4(VAR40);
}
for(uint VAR90 = 0; VAR90 < VAR46; VAR90++)
{
uint VAR101 = VAR86 + VAR44 + (VAR45 * VAR90);
VAR74[VAR90] = VAR101;
VAR75[VAR90] = VAR75[VAR90].FUN4(VAR43);
}
for(uint VAR90 = 0; VAR90 < VAR50; VAR90++)
{
uint VAR101 = VAR86 + (VAR49 * VAR90);
VAR76[VAR90] = VAR101;
if(VAR90 == 0)
{
VAR77[VAR90] = VAR77[VAR90].FUN4(VAR47);
}
else
{
VAR77[VAR90] = VAR77[VAR90].FUN4(VAR48);
}
}
for(uint VAR90 = 0; VAR90 < VAR54; VAR90++)
{
uint VAR101 = VAR86 + (VAR53 * VAR90);
VAR78[VAR90] = VAR101;
if(VAR90 == 0)
{
VAR79[VAR90] = VAR79[VAR90].FUN4(VAR51);
}
else
{
VAR79[VAR90] = VAR79[VAR90].FUN4(VAR52);
}
}
for(uint VAR90 = 0; VAR90 < VAR56; VAR90++)
{
uint VAR101 = VAR86 + (VAR55 * VAR90);
VAR80[VAR90] = VAR101;
}
for(uint VAR90 = 0; VAR90 < VAR58; VAR90++)
{
uint VAR101 = VAR86 + (VAR57 * VAR90);
VAR82[VAR90] = VAR101;
}
emit FUN21(VAR86);
}
function FUN36(address VAR102, uint VAR103, uint VAR19) onlyOwner public
{
if(VAR102 == address(0x0))
{
uint VAR104 = VAR19.FUN1(10 ** VAR103);
msg.sender.transfer(VAR104);
}
else
{
uint VAR98 = VAR19.FUN1(10 ** VAR103);
FUN37(VAR102).transfer(msg.sender, VAR98);
emit Transfer(address(0x0), msg.sender, VAR98);
}
}
function FUN38(uint VAR19) onlyOwner public
{
uint VAR98 = VAR19 * VAR29;
require(VAR69[msg.sender] >= VAR98);
VAR69[msg.sender] = VAR69[msg.sender].FUN3(VAR98);
VAR68 = VAR68.FUN4(VAR98);
VAR59 = VAR59.FUN3(VAR98);
emit FUN19(msg.sender, VAR98);
}
function FUN39() onlyOwner public
{
FUN40(msg.sender);
}
function FUN41(address VAR14) onlyOwner public
{
require(VAR71[VAR14] == false);
VAR71[VAR14] = true;
}
function FUN42(address VAR14) onlyOwner public
{
require(VAR71[VAR14] == true);
VAR71[VAR14] = false;
}
}
0
---------------------------------
514 0x04eb05e09ef4b9efdebbad449307c70d06f58b3e.sol
pragma solidity 0.4.21;
contract VAR1 {
function FUN1() public constant returns (uint256);
function FUN2(address VAR2) public constant returns (uint256 VAR3);
function FUN3(address VAR2, address VAR4) public constant returns (uint256 VAR5);
function transfer(address VAR6, uint256 VAR7) public returns (bool VAR8);
function FUN4(address VAR4, uint256 VAR7) public returns (bool VAR8);
function FUN5(address VAR9, address VAR6, uint256 VAR7) public returns (bool VAR8);
event Transfer(address indexed VAR9, address indexed VAR6, uint VAR7);
event FUN6(address indexed VAR2, address indexed VAR4, uint VAR7);
}
contract VAR10 {
uint private VAR11;
uint private VAR12 = 0;
address private VAR13;
function FUN7(uint VAR14) public {
VAR13 = msg.sender;
VAR11 = VAR14;
}
modifier onlyOwner {
require(msg.sender == VAR13);
VAR15;
}
modifier VAR16 {
require(msg.value > 0);
VAR15;
}
struct VAR17 {
address VAR18;
uint VAR19;
}
VAR17[] private VAR20;
function() public payable VAR16 {
VAR20.FUN8(FUN9(msg.sender, (msg.value * VAR11) / 100));
uint VAR3 = msg.value;
while (VAR3 > 0) {
uint VAR21 = VAR3 < VAR20[VAR12].VAR19 ? VAR3 : VAR20[VAR12].VAR19;
VAR20[VAR12].VAR19 -= VAR21;
VAR3 -= VAR21;
VAR20[VAR12].VAR18.transfer(VAR21);
if(VAR3 > 0){
VAR12 += 1;
}
}
}
function FUN10() view public returns(uint) {
return VAR11;
}
function FUN11() view public returns(uint VAR22) {
VAR22 = VAR20.VAR23;
}
function FUN12() view public returns(uint ) {
return VAR20.VAR23 - VAR12;
}
function FUN13(uint VAR24) view public returns(address VAR25, uint VAR26) {
if (VAR24 <= VAR20.VAR23) {
VAR25 = VAR20[VAR24].VAR18;
VAR26 = VAR20[VAR24].VAR19;
}
}
function FUN14(address VAR27, uint VAR7) public onlyOwner returns (bool VAR8) {
return FUN15(VAR27).transfer(VAR13, VAR7);
}
}
0
---------------------------------
515 0x04ec339271ed913ee4104cb3d03574d72d7e5ac9.sol
pragma VAR1 ^0.5.2;
interface VAR2 {
function transfer(address VAR3, uint256 value) external returns (bool);
function FUN1(address VAR4, uint256 value) external returns (bool);
function FUN2(address VAR5, address VAR3, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR6) external view returns (uint256);
function FUN5(address VAR7, address VAR4) external view returns (uint256);
event Transfer(address indexed VAR5, address indexed VAR3, uint256 value);
event FUN6(address indexed VAR7, address indexed VAR4, uint256 value);
}
pragma VAR1 ^0.5.2;
library VAR8 {
function FUN7(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
if (VAR9 == 0) {
return 0;
}
uint256 VAR11 = VAR9 * VAR10;
require(VAR11 / VAR9 == VAR10);
return VAR11;
}
function FUN8(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 > 0);
uint256 VAR11 = VAR9 / VAR10;
return VAR11;
}
function FUN9(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 <= VAR9);
uint256 VAR11 = VAR9 - VAR10;
return VAR11;
}
function FUN10(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
uint256 VAR11 = VAR9 + VAR10;
require(VAR11 >= VAR9);
return VAR11;
}
function FUN11(uint256 VAR9, uint256 VAR10) internal pure returns (uint256) {
require(VAR10 != 0);
return VAR9 % VAR10;
}
}
pragma VAR1 ^0.5.2;
contract ERC20 is VAR2 {
using SafeMath for uint256;
mapping (address => uint256) private VAR12;
mapping (address => mapping (address => uint256)) private VAR13;
uint256 private VAR14;
function FUN3() public view returns (uint256) {
return VAR14;
}
function FUN4(address VAR7) public view returns (uint256) {
return VAR12[VAR7];
}
function FUN5(address VAR7, address VAR4) public view returns (uint256) {
return VAR13[VAR7][VAR4];
}
function transfer(address VAR3, uint256 value) public returns (bool) {
FUN12(msg.sender, VAR3, value);
return true;
}
function FUN1(address VAR4, uint256 value) public returns (bool) {
FUN13(msg.sender, VAR4, value);
return true;
}
function FUN2(address VAR5, address VAR3, uint256 value) public returns (bool) {
FUN12(VAR5, VAR3, value);
FUN13(VAR5, msg.sender, VAR13[VAR5][msg.sender].FUN9(value));
return true;
}
function FUN14(address VAR4, uint256 VAR15) public returns (bool) {
FUN13(msg.sender, VAR4, VAR13[msg.sender][VAR4].FUN10(VAR15));
return true;
}
function FUN15(address VAR4, uint256 VAR16) public returns (bool) {
FUN13(msg.sender, VAR4, VAR13[msg.sender][VAR4].FUN9(VAR16));
return true;
}
function FUN12(address VAR5, address VAR3, uint256 value) internal {
require(VAR3 != address(0));
VAR12[VAR5] = VAR12[VAR5].FUN9(value);
VAR12[VAR3] = VAR12[VAR3].FUN10(value);
emit Transfer(VAR5, VAR3, value);
}
function FUN16(address VAR17, uint256 value) internal {
require(VAR17 != address(0));
VAR14 = VAR14.FUN10(value);
VAR12[VAR17] = VAR12[VAR17].FUN10(value);
emit Transfer(address(0), VAR17, value);
}
function FUN17(address VAR17, uint256 value) internal {
require(VAR17 != address(0));
VAR14 = VAR14.FUN9(value);
VAR12[VAR17] = VAR12[VAR17].FUN9(value);
emit Transfer(VAR17, address(0), value);
}
function FUN13(address VAR7, address VAR4, uint256 value) internal {
require(VAR4 != address(0));
require(VAR7 != address(0));
VAR13[VAR7][VAR4] = value;
emit FUN6(VAR7, VAR4, value);
}
function FUN18(address VAR17, uint256 value) internal {
FUN17(VAR17, value);
FUN13(VAR17, msg.sender, VAR13[VAR17][msg.sender].FUN9(value));
}
}
pragma VAR1 ^0.5.2;
contract ERC20Detailed is VAR2 {
string private VAR18;
string private VAR19;
uint8 private VAR20;
constructor (string memory VAR21, string memory VAR22, uint8 VAR23) public {
VAR18 = VAR21;
VAR19 = VAR22;
VAR20 = VAR23;
}
function FUN19() public view returns (string VAR24) {
return VAR18;
}
function FUN20() public view returns (string VAR24) {
return VAR19;
}
function FUN21() public view returns (uint8) {
return VAR20;
}
}
pragma VAR1 ^0.5.2;
library VAR25 {
struct VAR26 {
mapping (address => bool) VAR27;
}
function FUN10(Role storage VAR28, address VAR17) internal {
require(VAR17 != address(0));
require(!FUN22(VAR28, VAR17));
VAR28.VAR27[VAR17] = true;
}
function FUN23(Role storage VAR28, address VAR17) internal {
require(VAR17 != address(0));
require(FUN22(VAR28, VAR17));
VAR28.VAR27[VAR17] = false;
}
function FUN22(Role storage VAR28, address VAR17) internal view returns (bool) {
require(VAR17 != address(0));
return VAR28.VAR27[VAR17];
}
}
pragma VAR1 ^0.5.2;
contract VAR29 {
using Roles for VAR25.VAR26;
event FUN24(address indexed VAR17);
event FUN25(address indexed VAR17);
VAR25.Role private VAR30;
constructor () internal {
FUN26(msg.sender);
}
modifier FUN27() {
require(FUN28(msg.sender));
VAR31;
}
function FUN28(address VAR17) public view returns (bool) {
return VAR30.FUN22(VAR17);
}
function FUN29(address VAR17) public VAR32 {
FUN26(VAR17);
}
function FUN30() public {
FUN31(msg.sender);
}
function FUN26(address VAR17) internal {
VAR30.FUN10(VAR17);
emit FUN24(VAR17);
}
function FUN31(address VAR17) internal {
VAR30.FUN23(VAR17);
emit FUN25(VAR17);
}
}
pragma VAR1 ^0.5.2;
contract ERC20Mintable is VAR33, VAR29 {
function FUN32(address VAR3, uint256 value) public onlyMinter returns (bool) {
FUN16(VAR3, value);
return true;
}
}
pragma VAR1 ^0.5.2;
contract ERC20Capped is VAR34 {
uint256 private VAR35;
constructor (uint256 VAR36) public {
require(VAR36 > 0);
VAR35 = VAR36;
}
function FUN33() public view returns (uint256) {
return VAR35;
}
function FUN16(address VAR17, uint256 value) internal {
require(FUN3().FUN10(value) <= VAR35);
super.FUN16(VAR17, value);
}
}
pragma VAR1 ^0.5.2;
contract GemsToken is VAR33, VAR37, VAR38  {
constructor(
string memory VAR21,
string memory VAR22,
uint8 VAR23,
uint32 VAR36
)
FUN34()
FUN35(VAR21, VAR22, VAR23)
FUN36(VAR36 * (10 ** uint256(VAR23)))
public
{
FUN16(msg.sender, VAR36 * (10 ** uint256(VAR23)));
}
}
0
---------------------------------
516 0x04edc02e53ef13cbe2934d4d301d93c9023acb3d.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 30326400
;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0xB57f895D5A2E8b68763f395c4D94119EF161883f ;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
517 0x04ee4f8f199a767e66248207eb8687d840b9fec9.sol
pragma solidity 0.4.19;
library VAR1 {
function FUN1(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 / VAR3;
return VAR4;
}
function FUN3(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint256 VAR2, uint256 VAR3) internal pure returns (uint256) {
uint256 VAR4 = VAR2 + VAR3;
assert(VAR4 >= VAR2);
return VAR4;
}
}
contract VAR5 {
using SafeMath for uint256;
address public VAR6;
address public VAR7;
uint256 public VAR8;
bool public VAR9;
mapping (address => bool) public VAR10;
mapping (address => bool) public VAR11;
uint256 public VAR12;
mapping (address => uint256) public VAR13;
uint256 public VAR14 = 6666 VAR15;
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR16;
}
modifier FUN5() {
require(VAR10[msg.sender]);
VAR16;
}
modifier FUN6() {
require(VAR11[msg.sender]);
VAR16;
}
modifier FUN7() {
require(VAR9);
VAR16;
}
function FUN8(address VAR17) public {
require(VAR17 != address(0));
VAR6 = msg.sender;
VAR7 = VAR17;
VAR10[msg.sender] = true;
}
function () isWhitelisted acceptingPayments payable public {
require(msg.value >= 0.2 VAR15);
require(msg.value <= 500 VAR15);
require(msg.sender != address(0));
uint256 VAR18 = msg.value;
VAR13[msg.sender] += msg.value;
VAR8 = VAR8.FUN4(msg.value);
if (VAR8 > VAR14) {
uint256 VAR19 = VAR8.FUN3(VAR14);
msg.sender.transfer(VAR19);
VAR18 = VAR18.FUN3(VAR19);
VAR19 = 0;
VAR8 = VAR14;
VAR9 = false;
}
VAR7.transfer(VAR18);
}
function FUN9() onlyOwner public  {
VAR9 = true;
}
function FUN10() onlyOwner public  {
VAR9 = false;
}
function FUN11(address VAR20) onlyOwner public {
VAR10[VAR20] = true;
}
function FUN12(address VAR20) onlyOwner public {
VAR10[VAR20] = false;
}
function FUN13(address VAR21) onlyWhitelistAdmin public  {
VAR11[VAR21] = true;
}
function FUN14(address[] VAR22) onlyWhitelistAdmin public {
for (uint256 VAR23 = 0; VAR23 < VAR22.VAR24; VAR23++) {
VAR11[VAR22[VAR23]] = true;
}
}
function FUN15(address VAR21) onlyWhitelistAdmin public  {
VAR11[VAR21] = false;
}
function FUN16(address[] VAR22) onlyWhitelistAdmin public {
for (uint256 VAR23 = 0; VAR23 < VAR22.VAR24; VAR23++) {
VAR11[VAR22[VAR23]] = false;
}
}
}
0
---------------------------------
518 0x04f062809b244e37e7fdc21d9409469c989c2342.sol
pragma solidity 0.4.19;
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);
function FUN2() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR5;
}
function FUN3(address VAR4) public onlyOwner {
require(VAR4 != address(0));
FUN1(VAR2, VAR4);
VAR2 = VAR4;
}
}
contract VAR6 {
function FUN4() public view returns (uint256);
function FUN5(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool);
event Transfer(address indexed VAR9, address indexed VAR8, uint256 value);
}
contract ERC20 is VAR6 {
function FUN6(address VAR2, address VAR10) public view returns (uint256);
function FUN7(address VAR9, address VAR8, uint256 value) public returns (bool);
function FUN8(address VAR10, uint256 value) public returns (bool);
event FUN9(address indexed VAR2, address indexed VAR10, uint256 value);
}
library VAR11 {
function FUN10(uint256 VAR12, uint256 VAR13) internal pure returns (uint256) {
if (VAR12 == 0) {
return 0;
}
uint256 VAR14 = VAR12 * VAR13;
require(VAR14 / VAR12 == VAR13);
return VAR14;
}
function FUN11(uint256 VAR12, uint256 VAR13) internal pure returns (uint256) {
require(VAR13 <= VAR12);
return VAR12 - VAR13;
}
function FUN12(uint256 VAR12, uint256 VAR13) internal pure returns (uint256) {
uint256 VAR14 = VAR12 + VAR13;
require(VAR14 >= VAR12);
return VAR14;
}
}
contract VAR15 {
function FUN13(address VAR16, uint256 VAR17, address VAR18) external payable returns (bool);
}
contract VAR19 {
function FUN14(uint256 VAR20) internal pure returns (uint256) {
return VAR20 & 0x00000000000000000000000000000000000000000000000000000000ffffffff;
}
function FUN15(uint256 VAR20) internal pure returns (uint256) {
return VAR20 & 0x000000000000000000000000f000000000000000000000000000000000000000 == 0 ? 27 : 28;
}
}
contract Joyso is VAR1, VAR19 {
using SafeMath for uint256;
uint256 private constant VAR21 = 0x00000000000000000000000000000000000000000000000000000000ffffffff;
uint256 private constant VAR22 = 0x00000000000000000000000f0000000000000000000000000000000000000000;
uint256 private constant VAR23 = 0x0000000000000000000000000000000000000000000000000000ffff00000000;
uint256 private constant VAR24 = 0x000000000000000000000000f000000000000000000000000000000000000000;
uint256 private constant VAR25 = 0x000000000000000000000000000000000000000000000000ffff000000000000;
uint256 private constant VAR26 = 0x0000000000000000000000000000000000000000000000000000ffff00000000;
uint256 private constant VAR27 = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;
uint256 private constant VAR28 = 0xfffffffffffffffffffffff00000000000000000000000000000000000000000;
uint256 private constant VAR29 = 0x0000000000000000000000000fffffffffffffffffffffff0000000000000000;
uint256 private constant VAR30 = 0x0000000000000000fffffff00000000000000000000000000000000000000000;
uint256 private constant VAR31 = 0x00000000000000000000000f0000000000000000000000000000000000000000;
uint256 private constant VAR32 = 0x00000000ffff0000000000000000000000000000000000000000000000000000;
uint256 private constant VAR33 = 0x000000000000ffff000000000000000000000000000000000000000000000000;
uint256 private constant VAR34 = 0x0000000000000000000000020000000000000000000000000000000000000000;
uint256 private constant VAR35 = 0x0000000000000000000000010000000000000000000000000000000000000000;
uint256 private constant VAR36 = 0x0000000000000000000000010000000000000000000000000000000000000000;
mapping (address => mapping (address => uint256)) private VAR37;
mapping (address => uint256) public VAR38;
mapping (address => uint256) public VAR39;
mapping (bytes32 => uint256) public VAR40;
mapping (bytes32 => bool) public VAR41;
mapping (address => bool) public VAR42;
mapping (uint256 => address) public VAR43;
mapping (uint256 => address) public VAR44;
mapping (address => uint256) public VAR45;
mapping (address => uint256) public VAR46;
address public VAR47;
address public VAR48;
uint256 public VAR49 = 30 VAR50;
uint256 public VAR51;
bool public VAR52 = true;
modifier onlyAdmin {
require(msg.sender == VAR2 || VAR42[msg.sender]);
VAR5;
}
event FUN16(address VAR53, address VAR16, uint256 VAR17, uint256 VAR54);
event FUN17(address VAR53, address VAR16, uint256 VAR17, uint256 VAR54);
event FUN18(address VAR16, uint256 VAR55);
event FUN19(address VAR16, uint256 VAR56);
event FUN20(address VAR16, uint256 VAR57, uint256 VAR58, bool VAR59, uint256 VAR60);
function FUN21(address VAR61, address VAR62) public {
VAR47 = VAR61;
FUN22(VAR61);
VAR48 = VAR62;
VAR46[VAR48] = 1;
VAR46[0] = 0;
VAR43[0] = 0;
VAR43[1] = VAR48;
}
function FUN23(address VAR53, uint256 VAR17) external {
require(VAR17 > 0);
require(VAR46[VAR53] != 0);
FUN22(msg.sender);
require(FUN24(VAR53).FUN7(msg.sender, this, VAR17));
VAR37[VAR53][msg.sender] = VAR37[VAR53][msg.sender].FUN12(VAR17);
FUN16(
VAR53,
msg.sender,
VAR17,
VAR37[VAR53][msg.sender]
);
}
function FUN25() external payable {
require(msg.value > 0);
FUN22(msg.sender);
VAR37[0][msg.sender] = VAR37[0][msg.sender].FUN12(msg.value);
FUN16(
0,
msg.sender,
msg.value,
VAR37[0][msg.sender]
);
}
function FUN26(address VAR53, uint256 VAR17) external {
require(VAR17 > 0);
require(FUN27() > VAR38[msg.sender] && VAR38[msg.sender] != 0);
VAR37[VAR53][msg.sender] = VAR37[VAR53][msg.sender].FUN11(VAR17);
if (VAR53 == 0) {
msg.sender.transfer(VAR17);
} else {
require(FUN24(VAR53).transfer(msg.sender, VAR17));
}
FUN17(
VAR53,
msg.sender,
VAR17,
VAR37[VAR53][msg.sender]
);
}
function FUN28() external {
require(VAR45[msg.sender] != 0);
VAR38[msg.sender] = FUN27() + VAR49;
FUN19(msg.sender, VAR38[msg.sender]);
}
function FUN29() external {
require(VAR45[msg.sender] != 0);
VAR38[msg.sender] = 0;
FUN19(msg.sender, 0);
}
function FUN30(bool VAR63) external onlyOwner {
VAR52 = VAR63;
}
function FUN31(address VAR64, bool VAR65) external onlyOwner {
VAR42[VAR64] = VAR65;
}
function FUN32(address VAR53) external onlyOwner {
uint256 VAR17 = VAR37[VAR53][VAR47];
require(VAR17 > 0);
VAR37[VAR53][VAR47] = 0;
if (VAR53 == 0) {
msg.sender.transfer(VAR17);
} else {
require(FUN24(VAR53).transfer(msg.sender, VAR17));
}
FUN17(
VAR53,
VAR47,
VAR17,
0
);
}
function FUN33(uint256 VAR66) external onlyOwner {
require(VAR66 <= 30 && VAR66 >= 1);
VAR49 = VAR66 * 1 VAR50;
}
function FUN34(address VAR67, uint256 VAR68) external onlyAdmin {
require(VAR68 > 1);
require(VAR46[VAR67] == 0);
require(VAR43[VAR68] == 0);
VAR46[VAR67] = VAR68;
VAR43[VAR68] = VAR67;
}
function FUN35(uint256[] VAR69) external onlyAdmin {
uint256 VAR17 = VAR69[0];
uint256 VAR70 = VAR69[1];
uint256 VAR20 = VAR69[2];
uint256 VAR71 = VAR20 & VAR22;
address VAR53 = VAR43[(VAR20 & VAR23) >> 32];
address VAR16 = VAR44[VAR20 & VAR21];
bytes32 VAR72 = FUN36(
this,
VAR17,
VAR70,
VAR20 & VAR27 | uint256(VAR53)
);
require(!VAR41[VAR72]);
require(
FUN37(
VAR72,
VAR16,
uint8(VAR20 & VAR24 == 0 ? 27 : 28),
bytes32(VAR69[3]),
bytes32(VAR69[4])
)
);
address VAR73 = 0;
if (VAR71 == VAR35) {
VAR73 = VAR48;
} else if (VAR71 == VAR34) {
VAR73 = VAR53;
}
if (VAR73 == VAR53) {
VAR37[VAR53][VAR16] = VAR37[VAR53][VAR16].FUN11(VAR17.FUN12(VAR70));
} else {
VAR37[VAR53][VAR16] = VAR37[VAR53][VAR16].FUN11(VAR17);
VAR37[VAR73][VAR16] = VAR37[VAR73][VAR16].FUN11(VAR70);
}
VAR37[VAR73][VAR47] = VAR37[VAR73][VAR47].FUN12(VAR70);
VAR41[VAR72] = true;
if (VAR53 == 0) {
VAR16.transfer(VAR17);
} else {
require(FUN24(VAR53).transfer(VAR16, VAR17));
}
}
function FUN38(uint256[] VAR69) external onlyAdmin {
uint256 VAR20 = VAR69[3];
address VAR16 = VAR44[VAR20 & VAR21];
require(VAR20 >> 224 > VAR39[VAR16]);
address VAR53;
bool VAR59;
(VAR53, VAR59) = FUN39(VAR20);
bytes32 VAR74 = FUN36(
this,
VAR69[0],
VAR69[1],
VAR69[2],
VAR20 & VAR28 | (VAR59 ? VAR36 : 0) | uint256(VAR53)
);
require(
FUN37(
VAR74,
VAR16,
uint8(VAR20 & VAR24 == 0 ? 27 : 28),
bytes32(VAR69[4]),
bytes32(VAR69[5])
)
);
uint256 VAR75 = VAR59 ? VAR69[1] : VAR69[0];
VAR75 = VAR75.FUN11(VAR40[VAR74]);
require(VAR75 != 0);
uint256 VAR76 = 0;
VAR59 = !VAR59;
for (uint256 VAR77 = 6; VAR77 < VAR69.VAR78; VAR77 += 6) {
require(VAR75 > 0 && VAR69[1].FUN10(VAR69[VAR77 + 1]) <= VAR69[0].FUN10(VAR69[VAR77]));
VAR20 = VAR69[VAR77 + 3];
VAR16 = VAR44[VAR20 & VAR21];
require(VAR20 >> 224 > VAR39[VAR16]);
bytes32 VAR79 = FUN36(
this,
VAR69[VAR77],
VAR69[VAR77 + 1],
VAR69[VAR77 + 2],
VAR20 & VAR28 | (VAR59 ? VAR36 : 0) | uint256(VAR53)
);
require(
FUN37(
VAR79,
VAR16,
uint8(VAR20 & VAR24 == 0 ? 27 : 28),
bytes32(VAR69[VAR77 + 4]),
bytes32(VAR69[VAR77 + 5])
)
);
(VAR75, VAR76) = FUN40(
VAR69[VAR77],
VAR69[VAR77 + 1],
VAR69[VAR77 + 2],
VAR20,
VAR75,
VAR76,
VAR59,
VAR53,
0,
VAR79
);
}
VAR59 = !VAR59;
VAR75 = VAR59 ? VAR69[1].FUN11(VAR75) : VAR69[0].FUN11(VAR75);
VAR75 = VAR75.FUN11(VAR40[VAR74]);
FUN41(VAR69[2], VAR69[3], VAR75, VAR76, VAR59, VAR53, 0, VAR74);
}
function FUN42(uint256[] VAR69) external onlyAdmin {
address VAR16 = VAR44[FUN14(VAR69[3])];
require(VAR69[3] >> 224 > VAR39[VAR16]);
address VAR53;
address VAR80;
bool VAR59;
(VAR53, VAR80, VAR59) = FUN43(VAR69[3]);
bytes32 VAR74 = FUN44(VAR69, 0, VAR69[3], VAR53, VAR80);
require(
FUN37(
VAR74,
VAR16,
uint8(FUN15(VAR69[3])),
bytes32(VAR69[4]),
bytes32(VAR69[5])
)
);
uint256 VAR75 = VAR59 ? VAR69[1] : VAR69[0];
VAR75 = VAR75.FUN11(VAR40[VAR74]);
require(VAR75 != 0);
uint256 VAR81 = 0;
VAR59 = !VAR59;
for (uint256 VAR77 = 6; VAR77 < VAR69.VAR78; VAR77 += 6) {
require(VAR75 > 0 && VAR69[1].FUN10(VAR69[VAR77 + 1]) <= VAR69[0].FUN10(VAR69[VAR77]));
VAR16 = VAR44[FUN14(VAR69[VAR77 + 3])];
require(VAR69[VAR77 + 3] >> 224 > VAR39[VAR16]);
bytes32 VAR79 = FUN44(VAR69, VAR77, VAR69[VAR77 + 3], VAR53, VAR80);
require(
FUN37(
VAR79,
VAR16,
uint8(FUN15(VAR69[VAR77 + 3])),
bytes32(VAR69[VAR77 + 4]),
bytes32(VAR69[VAR77 + 5])
)
);
(VAR75, VAR81) = FUN40(
VAR69[VAR77],
VAR69[VAR77 + 1],
VAR69[VAR77 + 2],
VAR69[VAR77 + 3],
VAR75,
VAR81,
VAR59,
VAR53,
VAR80,
VAR79
);
}
VAR59 = !VAR59;
VAR75 = VAR59 ? VAR69[1].FUN11(VAR75) : VAR69[0].FUN11(VAR75);
VAR75 = VAR75.FUN11(VAR40[VAR74]);
FUN41(VAR69[2], VAR69[3], VAR75, VAR81, VAR59, VAR53, VAR80, VAR74);
}
function FUN45(uint256[] VAR69) external onlyAdmin {
uint256 VAR20 = VAR69[1];
uint256 VAR82 = VAR20 >> 224;
address VAR16 = VAR44[VAR20 & VAR21];
require(VAR82 > VAR39[VAR16]);
uint256 VAR70 = VAR69[0];
require(
FUN37(
FUN36(this, VAR70, VAR20 & VAR27),
VAR16,
uint8(FUN15(VAR20)),
bytes32(VAR69[2]),
bytes32(VAR69[3])
)
);
address VAR73 = 0;
if (VAR20 & VAR22 == VAR35) {
VAR73 = VAR48;
}
require(VAR37[VAR73][VAR16] >= VAR70);
VAR37[VAR73][VAR16] = VAR37[VAR73][VAR16].FUN11(VAR70);
VAR37[VAR73][VAR47] = VAR37[VAR73][VAR47].FUN12(VAR70);
VAR39[VAR16] = VAR82;
}
function FUN46(uint256[] VAR69) external onlyAdmin {
uint256 VAR20 = VAR69[2];
address VAR53 = VAR43[(VAR20 & VAR23) >> 32];
address VAR83 = address(VAR69[0]);
for (uint256 VAR77 = 1; VAR77 < VAR69.VAR78; VAR77 += 4) {
uint256 VAR70 = VAR69[VAR77];
VAR20 = VAR69[VAR77 + 1];
address VAR16 = VAR44[VAR20 & VAR21];
bytes32 VAR72 = FUN36(
this,
VAR70,
VAR20 & VAR27 | uint256(VAR53),
VAR83
);
require(
FUN37(
VAR72,
VAR16,
uint8(VAR20 & VAR24 == 0 ? 27 : 28),
bytes32(VAR69[VAR77 + 2]),
bytes32(VAR69[VAR77 + 3])
)
);
if (VAR70 > 0) {
uint256 VAR71 = VAR20 & VAR22;
if (VAR71 == VAR35) {
VAR37[VAR48][VAR16] = VAR37[VAR48][VAR16].FUN11(VAR70);
VAR37[VAR48][VAR47] = VAR37[VAR48][VAR47].FUN12(VAR70);
} else if (VAR71 == VAR34) {
VAR37[VAR53][VAR16] = VAR37[VAR53][VAR16].FUN11(VAR70);
VAR37[VAR53][VAR47] = VAR37[VAR53][VAR47].FUN12(VAR70);
} else {
VAR37[0][VAR16] = VAR37[0][VAR16].FUN11(VAR70);
VAR37[0][VAR47] = VAR37[0][VAR47].FUN12(VAR70);
}
}
uint256 VAR17 = VAR37[VAR53][VAR16];
VAR37[VAR53][VAR16] = 0;
if (VAR53 == 0) {
FUN47(VAR83).VAR84.value(VAR17)(VAR16, VAR17, VAR53);
} else {
FUN24(VAR53).FUN8(VAR83, VAR17);
FUN47(VAR83).FUN13(VAR16, VAR17, VAR53);
}
}
}
function FUN48(address VAR53, address VAR85, uint256 VAR17) onlyAdmin external {
require(VAR46[VAR53] != 0);
require(VAR45[msg.sender] != 0);
FUN22(VAR85);
VAR37[VAR53][msg.sender] = VAR37[VAR53][msg.sender].FUN11(VAR17);
VAR37[VAR53][VAR85] = VAR37[VAR53][VAR85].FUN12(VAR17);
}
function FUN49(address VAR53, address VAR85) external view returns (uint256) {
return VAR37[VAR53][VAR85];
}
function FUN39(uint256 VAR20) internal view returns (address VAR53, bool VAR59) {
uint256 VAR86 = (VAR20 & VAR25) >> 48;
if (VAR86 == 0) {
VAR53 = VAR43[(VAR20 & VAR26) >> 32];
VAR59 = true;
} else {
VAR53 = VAR43[VAR86];
}
}
function FUN43(uint256 VAR20) internal view returns (address VAR53, address VAR80, bool VAR59) {
VAR59 = VAR20 & VAR31 == VAR36;
if (VAR59) {
VAR53 = VAR43[(VAR20 & VAR26) >> 32];
VAR80 = VAR43[(VAR20 & VAR25) >> 48];
} else {
VAR53 = VAR43[(VAR20 & VAR25) >> 48];
VAR80 = VAR43[(VAR20 & VAR26) >> 32];
}
}
function FUN27() internal view returns (uint256) {
return VAR87;
}
function FUN44(uint256[] VAR69, uint256 VAR88, uint256 VAR20, address VAR53, address VAR80) internal view returns (bytes32) {
return FUN36(
this,
VAR69[VAR88],
VAR69[VAR88 + 1],
VAR69[VAR88 + 2],
VAR20 & VAR27 | uint256(VAR53),
VAR80,
(VAR20 & VAR29) >> 64
);
}
function FUN37(bytes32 VAR72, address sender, uint8 VAR89, bytes32 VAR90, bytes32 VAR91) internal pure returns (bool) {
return FUN50(FUN36("", VAR72), VAR89, VAR90, VAR91) == sender;
}
function FUN22(address VAR92) internal {
if (VAR45[VAR92] != 0) {
return;
}
VAR51 += 1;
VAR45[VAR92] = VAR51;
VAR44[VAR51] = VAR92;
FUN18(VAR92, VAR51);
}
function FUN41(
uint256 VAR70,
uint256 VAR20,
uint256 VAR75,
uint256 VAR81,
bool VAR59,
address VAR53,
address VAR80,
bytes32 VAR74
)
internal
{
uint256 VAR60 = FUN51(VAR70, VAR20, VAR81, VAR74, true, VAR80 == 0);
FUN52(VAR20, VAR59, VAR81, VAR75, VAR60, VAR53, VAR80);
VAR40[VAR74] = VAR40[VAR74].FUN12(VAR75);
if (VAR52) {
FUN20(VAR44[VAR20 & VAR21], VAR81, VAR75, VAR59, VAR60);
}
}
function FUN40(
uint256 VAR93,
uint256 VAR94,
uint256 VAR70,
uint256 VAR20,
uint256 VAR95,
uint256 VAR96,
bool VAR59,
address VAR53,
address VAR80,
bytes32 VAR74
)
internal returns (uint256 VAR97, uint256 VAR81)
{
uint256 VAR98 = FUN53(VAR93, VAR94, VAR95, VAR59, VAR74);
uint256 VAR99 = FUN54(VAR93, VAR94, VAR59, VAR98);
uint256 VAR60 = FUN51(VAR70, VAR20, VAR99, VAR74, false, VAR80 == 0);
FUN52(VAR20, VAR59, VAR99, VAR98, VAR60, VAR53, VAR80);
VAR40[VAR74] = VAR40[VAR74].FUN12(VAR98);
VAR97 = VAR95.FUN11(VAR98);
VAR81 = VAR96.FUN12(VAR99);
if (VAR52) {
FUN20(
VAR44[VAR20 & VAR21],
VAR99,
VAR98,
VAR59,
VAR60
);
}
}
function FUN52(
uint256 VAR20,
bool VAR59,
uint256 VAR99,
uint256 VAR98,
uint256 VAR60,
address VAR53,
address VAR80
)
internal
{
address VAR16 = VAR44[VAR20 & VAR21];
uint256 VAR100 = VAR60;
uint256 VAR101 = 0;
if ((VAR80 == 0 ? (VAR20 & VAR30) >> 164 : (VAR20 & VAR29) >> 64) != 0) {
VAR101 = VAR60;
VAR100 = 0;
}
if (VAR59) {
VAR37[VAR80][VAR16] = VAR37[VAR80][VAR16].FUN11(VAR99).FUN11(VAR100);
VAR37[VAR53][VAR16] = VAR37[VAR53][VAR16].FUN12(VAR98);
} else {
VAR37[VAR80][VAR16] = VAR37[VAR80][VAR16].FUN12(VAR99).FUN11(VAR100);
VAR37[VAR53][VAR16] = VAR37[VAR53][VAR16].FUN11(VAR98);
}
if (VAR101 != 0) {
VAR37[VAR48][VAR16] = VAR37[VAR48][VAR16].FUN11(VAR101);
VAR37[VAR48][VAR47] = VAR37[VAR48][VAR47].FUN12(VAR101);
} else {
VAR37[VAR80][VAR47] = VAR37[VAR80][VAR47].FUN12(VAR100);
}
}
function FUN51(
uint256 VAR70,
uint256 VAR20,
uint256 VAR99,
bytes32 VAR74,
bool VAR102,
bool VAR103
)
internal view returns (uint256)
{
uint256 VAR60 = VAR40[VAR74] == 0 ? VAR70 : 0;
uint256 VAR104 = VAR99.FUN10(VAR102 ? (VAR20 & VAR32) >> 208 : (VAR20 & VAR33) >> 192) / 10000;
uint256 VAR105 = VAR103 ? (VAR20 & VAR30) >> 164 : (VAR20 & VAR29) >> 64;
if (VAR105 != 0) {
VAR104 = VAR103 ? VAR104 / (10 ** 5) / VAR105 : VAR104 * (10 ** 12) / VAR105;
}
return VAR60.FUN12(VAR104);
}
function FUN54(
uint256 VAR93,
uint256 VAR94,
bool VAR59,
uint256 VAR98
)
internal pure returns (uint256)
{
return VAR59 ? VAR98.FUN10(VAR93) / VAR94 : VAR98.FUN10(VAR94) / VAR93;
}
function FUN53(
uint256 VAR93,
uint256 VAR94,
uint256 VAR97,
bool VAR59,
bytes32 VAR74
)
internal view returns (uint256)
{
uint256 VAR106 = VAR59 ? VAR94 : VAR93;
VAR106 = VAR106.FUN11(VAR40[VAR74]);
require(VAR106 > 0);
return VAR106 >= VAR97 ? VAR97 : VAR106;
}
}
0
---------------------------------
519 0x04ff119b7eed896ae24b21669b18e6b964af6343.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function FUN1() public {}
function FUN2() public {}
function FUN3() public {}
function FUN4() public view returns(uint256) {}
function FUN5(bool) public view returns(uint256) {}
}
contract VAR3 {
Hourglass VAR4;
address public VAR5 = 0xeB0b5FA53843aAa2e636ccB599bA4a8CE8029aA1;
function FUN6() public {
VAR4 = FUN7(VAR5);
}
function FUN8() public {
VAR4.FUN3();
}
function FUN4() public view returns(uint256) {
return VAR4.FUN4();
}
function FUN5() public view returns(uint256) {
return VAR4.FUN5(true);
}
}
0
---------------------------------
520 0x0504a7fd883178fa182cf63d2bb1d67e5a9d876d.sol
pragma VAR1 ^0.4.16;
contract VAR2 {
bytes32 public VAR3;
bytes32 public VAR4;
bytes32 public VAR5;
uint256 public VAR6;
uint8 public VAR7;
bool public VAR8;
mapping (address => uint256) public VAR9;
mapping (address => mapping (address => uint256)) public VAR10;
function transfer(address VAR11, uint256 VAR12) returns (bool VAR13);
function FUN1(address VAR14, uint256 VAR12, bytes VAR15) returns (bool VAR13);
function FUN2(address VAR14, uint256 VAR12) returns (bool VAR13);
function FUN3(address VAR16, address VAR11, uint256 VAR12) returns (bool VAR13);
}
contract VAR17{
uint256 VAR18 = 500000000000000000000000000;
address public VAR19 = 0x3f06B5D78406cD97bdf10f5C420B241D32759c80;
address public VAR20 = 0xEBf3Aacc50ae14965240a3777eCe8DA1fC490a78;
address VAR21 = 0xEd86f5216BCAFDd85E5875d35463Aca60925bF16;
function FUN4(uint256 VAR22) returns (bool VAR13){
require(VAR18 >= FUN5(FUN6(VAR22, 5), 6));
if(FUN7(VAR19).FUN3(msg.sender, VAR21, VAR22)){
FUN7(VAR20).transfer(msg.sender, FUN5(FUN6(VAR22, 5), 6));
VAR18 -= FUN5(FUN6(VAR22, 5), 6);
}
return true;
}
function FUN8(uint256 VAR22) returns (bool VAR13){
require(msg.sender == VAR21);
require(VAR18 >= VAR22);
FUN7(VAR20).transfer(msg.sender, VAR22);
VAR18 -= VAR22;
return true;
}
function FUN5(uint VAR23, uint VAR24) public pure returns (uint VAR25) {
VAR25 = VAR23 * VAR24;
require(VAR23 == 0 || VAR25 / VAR23 == VAR24);
}
function FUN6(uint VAR23, uint VAR24) public pure returns (uint VAR25) {
require(VAR24 > 0);
VAR25 = VAR23 / VAR24;
}
}
0
---------------------------------
521 0x05064de4d8fcc27c0aad610277ff3e40d422e3f2.sol
pragma solidity 0.4.19;
contract VAR1 {
address public VAR2;
function FUN1(uint VAR3, string VAR4, string VAR5) payable returns (bytes32 VAR6);
function FUN2(uint VAR3, string VAR4, string VAR5, uint VAR7) payable returns (bytes32 VAR6);
function FUN3(uint VAR3, string VAR4, string VAR8, string VAR9) payable returns (bytes32 VAR6);
function FUN4(uint VAR3, string VAR4, string VAR8, string VAR9, uint VAR7) payable returns (bytes32 VAR6);
function FUN5(uint VAR3, string VAR4, bytes VAR10) payable returns (bytes32 VAR6);
function FUN6(uint VAR3, string VAR4, bytes VAR10, uint VAR7) payable returns (bytes32 VAR6);
function FUN7(string VAR4) returns (uint VAR11);
function FUN7(string VAR4, uint VAR12) returns (uint VAR11);
function FUN8(string VAR13);
function FUN9(byte VAR14);
function FUN10(bytes32 VAR15);
function FUN11(uint VAR16);
function FUN12() returns(bytes32);
}
contract VAR17 {
function FUN13() returns (address VAR18);
}
contract VAR19 {
uint constant VAR20 = 60*60*24;
uint constant VAR21 = 60*60*24*7;
uint constant VAR22 = 60*60*24*30;
byte constant VAR23 = 0x00;
byte constant VAR24 = 0x10;
byte constant VAR25 = 0x20;
byte constant VAR26 = 0x30;
byte constant VAR27 = 0xF0;
byte constant VAR28 = 0x01;
uint8 constant VAR29 = 0;
uint8 constant VAR30 = 1;
uint8 constant VAR31 = 2;
uint8 constant VAR32 = 2;
uint8 constant VAR33 = 161;
OraclizeAddrResolverI VAR34;
OraclizeI VAR35;
modifier VAR36 {
if((address(VAR34)==0)||(FUN14(address(VAR34))==0))
FUN15(VAR29);
if(address(VAR35) != VAR34.FUN13())
VAR35 = FUN16(VAR34.FUN13());
VAR37;
}
modifier FUN17(string VAR38){
VAR35 = FUN16(VAR34.FUN13());
VAR35.FUN8(VAR38);
VAR37;
}
function FUN15(uint8 VAR39) internal returns(bool){
if (FUN14(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){
VAR34 = FUN18(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
FUN19("");
return true;
}
if (FUN14(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){
VAR34 = FUN18(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
FUN19("");
return true;
}
if (FUN14(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){
VAR34 = FUN18(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
FUN19("");
return true;
}
if (FUN14(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){
VAR34 = FUN18(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
FUN19("");
return true;
}
if (FUN14(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){
VAR34 = FUN18(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
return true;
}
if (FUN14(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){
VAR34 = FUN18(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
return true;
}
if (FUN14(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){
VAR34 = FUN18(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
return true;
}
return false;
}
function FUN20(bytes32 VAR40, string VAR41) {
FUN20(VAR40, VAR41, VAR42 bytes(0));
}
function FUN20(bytes32 VAR40, string VAR41, bytes VAR43) {
}
function FUN21(string VAR38) oraclizeAPI internal {
VAR35.FUN8(VAR38);
}
function FUN22(string VAR44) oraclizeAPI internal returns (uint){
return VAR35.FUN7(VAR44);
}
function FUN22(string VAR44, uint VAR12) oraclizeAPI internal returns (uint){
return VAR35.FUN7(VAR44, VAR12);
}
function FUN23(string VAR44, string VAR45) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
return VAR35.VAR51.value(VAR47)(0, VAR44, VAR45);
}
function FUN23(uint VAR52, string VAR44, string VAR45) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
return VAR35.VAR51.value(VAR47)(VAR52, VAR44, VAR45);
}
function FUN23(uint VAR52, string VAR44, string VAR45, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
return VAR35.VAR53.value(VAR47)(VAR52, VAR44, VAR45, VAR12);
}
function FUN23(string VAR44, string VAR45, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
return VAR35.VAR53.value(VAR47)(0, VAR44, VAR45, VAR12);
}
function FUN23(string VAR44, string VAR54, string VAR55) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
return VAR35.VAR56.value(VAR47)(0, VAR44, VAR54, VAR55);
}
function FUN23(uint VAR52, string VAR44, string VAR54, string VAR55) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
return VAR35.VAR56.value(VAR47)(VAR52, VAR44, VAR54, VAR55);
}
function FUN23(uint VAR52, string VAR44, string VAR54, string VAR55, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
return VAR35.VAR57.value(VAR47)(VAR52, VAR44, VAR54, VAR55, VAR12);
}
function FUN23(string VAR44, string VAR54, string VAR55, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
return VAR35.VAR57.value(VAR47)(0, VAR44, VAR54, VAR55, VAR12);
}
function FUN23(string VAR44, string[] VAR58) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
bytes memory VAR59 = FUN24(VAR58);
return VAR35.VAR60.value(VAR47)(0, VAR44, VAR59);
}
function FUN23(uint VAR52, string VAR44, string[] VAR58) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
bytes memory VAR59 = FUN24(VAR58);
return VAR35.VAR60.value(VAR47)(VAR52, VAR44, VAR59);
}
function FUN23(uint VAR52, string VAR44, string[] VAR58, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
bytes memory VAR59 = FUN24(VAR58);
return VAR35.VAR61.value(VAR47)(VAR52, VAR44, VAR59, VAR12);
}
function FUN23(string VAR44, string[] VAR58, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
bytes memory VAR59 = FUN24(VAR58);
return VAR35.VAR61.value(VAR47)(0, VAR44, VAR59, VAR12);
}
function FUN23(string VAR44, string[1] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[1] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[1] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[1] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[2] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[2] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[2] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[2] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[3] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[3] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[3] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[3] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[4] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[4] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[4] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[4] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[5] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[5] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, string[5] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, string[5] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
string[] memory VAR62 = new string[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[] VAR58) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
bytes memory VAR59 = FUN25(VAR58);
return VAR35.VAR60.value(VAR47)(0, VAR44, VAR59);
}
function FUN23(uint VAR52, string VAR44, bytes[] VAR58) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44);
if (VAR47 > 1 VAR48 + VAR49.VAR50*200000) return 0;
bytes memory VAR59 = FUN25(VAR58);
return VAR35.VAR60.value(VAR47)(VAR52, VAR44, VAR59);
}
function FUN23(uint VAR52, string VAR44, bytes[] VAR58, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
bytes memory VAR59 = FUN25(VAR58);
return VAR35.VAR61.value(VAR47)(VAR52, VAR44, VAR59, VAR12);
}
function FUN23(string VAR44, bytes[] VAR58, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46){
uint VAR47 = VAR35.FUN7(VAR44, VAR12);
if (VAR47 > 1 VAR48 + VAR49.VAR50*VAR12) return 0;
bytes memory VAR59 = FUN25(VAR58);
return VAR35.VAR61.value(VAR47)(0, VAR44, VAR59, VAR12);
}
function FUN23(string VAR44, bytes[1] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[1] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[1] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[1] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](1);
VAR62[0] = VAR59[0];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[2] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[2] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[2] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[2] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](2);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[3] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[3] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[3] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[3] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](3);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[4] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[4] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[4] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[4] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](4);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[5] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[5] VAR59) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR52, VAR44, VAR62);
}
function FUN23(uint VAR52, string VAR44, bytes[5] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR52, VAR44, VAR62, VAR12);
}
function FUN23(string VAR44, bytes[5] VAR59, uint VAR12) oraclizeAPI internal returns (bytes32 VAR46) {
bytes[] memory VAR62 = new bytes[](5);
VAR62[0] = VAR59[0];
VAR62[1] = VAR59[1];
VAR62[2] = VAR59[2];
VAR62[3] = VAR59[3];
VAR62[4] = VAR59[4];
return FUN23(VAR44, VAR62, VAR12);
}
function FUN26() oraclizeAPI internal returns (address){
return VAR35.FUN27();
}
function FUN28(byte VAR63) oraclizeAPI internal {
return VAR35.FUN9(VAR63);
}
function FUN29(uint VAR64) oraclizeAPI internal {
return VAR35.FUN11(VAR64);
}
function FUN30(bytes32 VAR65) oraclizeAPI internal {
return VAR35.FUN10(VAR65);
}
function FUN31() oraclizeAPI internal returns (bytes32){
return VAR35.FUN12();
}
function FUN14(address VAR18) constant internal returns(uint VAR66) {
VAR67 {
VAR66 := FUN32(VAR18)
}
}
function FUN33(string VAR68) internal returns (address){
bytes memory VAR69 = bytes(VAR68);
uint160 VAR70 = 0;
uint160 VAR71;
uint160 VAR72;
for (uint VAR73=2; VAR73<2+2*20; VAR73+=2){
VAR70 *= 256;
VAR71 = FUN34(VAR69[VAR73]);
VAR72 = FUN34(VAR69[VAR73+1]);
if ((VAR71 >= 97)&&(VAR71 <= 102)) VAR71 -= 87;
else if ((VAR71 >= 65)&&(VAR71 <= 70)) VAR71 -= 55;
else if ((VAR71 >= 48)&&(VAR71 <= 57)) VAR71 -= 48;
if ((VAR72 >= 97)&&(VAR72 <= 102)) VAR72 -= 87;
else if ((VAR72 >= 65)&&(VAR72 <= 70)) VAR72 -= 55;
else if ((VAR72 >= 48)&&(VAR72 <= 57)) VAR72 -= 48;
VAR70 += (VAR71*16+VAR72);
}
return address(VAR70);
}
function FUN35(string VAR68, string VAR74) internal returns (int) {
bytes memory VAR75 = bytes(VAR68);
bytes memory VAR76 = bytes(VAR74);
uint VAR77 = VAR75.VAR78;
if (VAR76.VAR78 < VAR77) VAR77 = VAR76.VAR78;
for (uint VAR73 = 0; VAR73 < VAR77; VAR73 ++)
if (VAR75[VAR73] < VAR76[VAR73])
return -1;
else if (VAR75[VAR73] > VAR76[VAR73])
return 1;
if (VAR75.VAR78 < VAR76.VAR78)
return -1;
else if (VAR75.VAR78 > VAR76.VAR78)
return 1;
else
return 0;
}
function FUN36(string VAR79, string VAR80) internal returns (int) {
bytes memory VAR81 = bytes(VAR79);
bytes memory VAR82 = bytes(VAR80);
if(VAR81.VAR78 < 1 || VAR82.VAR78 < 1 || (VAR82.VAR78 > VAR81.VAR78))
return -1;
else if(VAR81.VAR78 > (2**128 -1))
return -1;
else
{
uint VAR83 = 0;
for (uint VAR73 = 0; VAR73 < VAR81.VAR78; VAR73 ++)
{
if (VAR81[VAR73] == VAR82[0])
{
VAR83 = 1;
while(VAR83 < VAR82.VAR78 && (VAR73 + VAR83) < VAR81.VAR78 && VAR81[VAR73 + VAR83] == VAR82[VAR83])
{
VAR83++;
}
if(VAR83 == VAR82.VAR78)
return int(VAR73);
}
}
return -1;
}
}
function FUN37(string VAR68, string VAR74, string VAR84, string VAR85, string VAR86) internal returns (string) {
bytes memory VAR87 = bytes(VAR68);
bytes memory VAR88 = bytes(VAR74);
bytes memory VAR89 = bytes(VAR84);
bytes memory VAR90 = bytes(VAR85);
bytes memory VAR91 = bytes(VAR86);
string memory VAR92 = VAR42 string(VAR87.VAR78 + VAR88.VAR78 + VAR89.VAR78 + VAR90.VAR78 + VAR91.VAR78);
bytes memory VAR93 = bytes(VAR92);
uint VAR94 = 0;
for (uint VAR73 = 0; VAR73 < VAR87.VAR78; VAR73++) VAR93[VAR94++] = VAR87[VAR73];
for (VAR73 = 0; VAR73 < VAR88.VAR78; VAR73++) VAR93[VAR94++] = VAR88[VAR73];
for (VAR73 = 0; VAR73 < VAR89.VAR78; VAR73++) VAR93[VAR94++] = VAR89[VAR73];
for (VAR73 = 0; VAR73 < VAR90.VAR78; VAR73++) VAR93[VAR94++] = VAR90[VAR73];
for (VAR73 = 0; VAR73 < VAR91.VAR78; VAR73++) VAR93[VAR94++] = VAR91[VAR73];
return string(VAR93);
}
function FUN37(string VAR68, string VAR74, string VAR84, string VAR85) internal returns (string) {
return FUN37(VAR68, VAR74, VAR84, VAR85, "");
}
function FUN37(string VAR68, string VAR74, string VAR84) internal returns (string) {
return FUN37(VAR68, VAR74, VAR84, "", "");
}
function FUN37(string VAR68, string VAR74) internal returns (string) {
return FUN37(VAR68, VAR74, "", "", "");
}
function FUN38(string VAR68) internal returns (uint) {
return FUN38(VAR68, 0);
}
function FUN38(string VAR68, uint VAR74) internal returns (uint) {
bytes memory VAR95 = bytes(VAR68);
uint VAR96 = 0;
bool VAR97 = false;
for (uint VAR73=0; VAR73<VAR95.VAR78; VAR73++){
if ((VAR95[VAR73] >= 48)&&(VAR95[VAR73] <= 57)){
if (VAR97){
if (VAR74 == 0) break;
else VAR74--;
}
VAR96 *= 10;
VAR96 += uint(VAR95[VAR73]) - 48;
} else if (VAR95[VAR73] == 46) VAR97 = true;
}
if (VAR74 > 0) VAR96 *= 10**VAR74;
return VAR96;
}
function FUN39(uint VAR73) internal returns (string){
if (VAR73 == 0) return "";
uint VAR98 = VAR73;
uint VAR99;
while (VAR98 != 0){
VAR99++;
VAR98 /= 10;
}
bytes memory VAR100 = VAR42 bytes(VAR99);
uint VAR94 = VAR99 - 1;
while (VAR73 != 0){
VAR100[VAR94--] = FUN40(48 + VAR73 % 10);
VAR73 /= 10;
}
return string(VAR100);
}
function FUN24(string[] VAR101) internal returns (bytes) {
uint VAR102 = VAR101.VAR78;
uint VAR103 = 0;
bytes[] memory VAR104 = new bytes[](VAR102);
for (uint VAR73 = 0; VAR73 < VAR102; VAR73++) {
VAR104[VAR73] = (bytes(VAR101[VAR73]));
VAR103 += VAR104[VAR73].VAR78 + (VAR104[VAR73].VAR78 - 1)/23 + 3;
}
uint VAR105 = 0;
uint VAR106 = VAR102 + 0x80;
VAR103 += FUN40(VAR106).VAR78;
bytes memory VAR107 = VAR42 bytes(VAR103);
while (FUN40(VAR106).VAR78 > VAR105) {
VAR107[VAR105] = FUN40(VAR106)[VAR105];
VAR105++;
}
for (VAR73 = 0; VAR73 < VAR102; VAR73++) {
VAR107[VAR105] = 0x5F;
VAR105++;
for (uint VAR108 = 0; VAR108 < VAR104[VAR73].VAR78; VAR108++) {
if (VAR108 % 23 == 0) {
uint VAR109 = VAR104[VAR73].VAR78 - VAR108 >= 24 ? 23 : VAR104[VAR73].VAR78 - VAR108;
VAR109 += 0x40;
uint VAR110 = VAR105;
while (FUN40(VAR109).VAR78 > VAR105 - VAR110) {
VAR107[VAR105] = FUN40(VAR109)[VAR105 - VAR110];
VAR105++;
}
}
VAR107[VAR105] = VAR104[VAR73][VAR108];
VAR105++;
}
VAR107[VAR105] = 0xFF;
VAR105++;
}
return VAR107;
}
function FUN25(bytes[] VAR101) internal returns (bytes) {
uint VAR102 = VAR101.VAR78;
uint VAR103 = 0;
bytes[] memory VAR104 = new bytes[](VAR102);
for (uint VAR73 = 0; VAR73 < VAR102; VAR73++) {
VAR104[VAR73] = (bytes(VAR101[VAR73]));
VAR103 += VAR104[VAR73].VAR78 + (VAR104[VAR73].VAR78 - 1)/23 + 3;
}
uint VAR105 = 0;
uint VAR106 = VAR102 + 0x80;
VAR103 += FUN40(VAR106).VAR78;
bytes memory VAR107 = VAR42 bytes(VAR103);
while (FUN40(VAR106).VAR78 > VAR105) {
VAR107[VAR105] = FUN40(VAR106)[VAR105];
VAR105++;
}
for (VAR73 = 0; VAR73 < VAR102; VAR73++) {
VAR107[VAR105] = 0x5F;
VAR105++;
for (uint VAR108 = 0; VAR108 < VAR104[VAR73].VAR78; VAR108++) {
if (VAR108 % 23 == 0) {
uint VAR109 = VAR104[VAR73].VAR78 - VAR108 >= 24 ? 23 : VAR104[VAR73].VAR78 - VAR108;
VAR109 += 0x40;
uint VAR110 = VAR105;
while (FUN40(VAR109).VAR78 > VAR105 - VAR110) {
VAR107[VAR105] = FUN40(VAR109)[VAR105 - VAR110];
VAR105++;
}
}
VAR107[VAR105] = VAR104[VAR73][VAR108];
VAR105++;
}
VAR107[VAR105] = 0xFF;
VAR105++;
}
return VAR107;
}
string VAR111;
function FUN19(string VAR112) internal {
VAR111 = VAR112;
}
function FUN41() internal returns (string) {
return VAR111;
}
function FUN42(uint VAR113, uint VAR114, uint VAR115) internal returns (bytes32){
if ((VAR114 == 0)||(VAR114 > 32)) throw;
bytes memory VAR116 = VAR42 bytes(1);
VAR116[0] = FUN40(VAR114);
bytes memory VAR117 = VAR42 bytes(32);
bytes memory VAR118 = VAR42 bytes(32);
bytes32 VAR119 = FUN31();
VAR67 {
FUN43(VAR117, 0x20)
FUN43(FUN44(VAR117, 0x20), FUN45(FUN46(FUN47(VAR120, 1)), FUN45(VAR121, VAR52)))
FUN43(VAR118, 0x20)
FUN43(FUN44(VAR118, 0x20), VAR119)
}
bytes[3] memory VAR59 = [VAR117, VAR116, VAR118];
bytes32 VAR122 = FUN23(VAR113, "", VAR59, VAR115);
FUN48(VAR122, FUN49(FUN50(VAR113), VAR59[1], FUN51(VAR59[0]), VAR59[2]));
return VAR122;
}
function FUN48(bytes32 VAR122, bytes32 VAR123) internal {
VAR124[VAR122] = VAR123;
}
mapping(bytes32=>bytes32) VAR124;
mapping(bytes32=>bool) VAR125;
function FUN52(bytes32 VAR126, bytes VAR127, bytes VAR128) internal returns (bool){
bool VAR129;
address VAR130;
bytes32 VAR131;
bytes32 VAR132;
bytes memory VAR133 = VAR42 bytes(32);
uint VAR134 = 4+(uint(VAR127[3]) - 0x20);
VAR133 = FUN53(VAR127, VAR134, 32, VAR133, 0);
bytes memory VAR135 = VAR42 bytes(32);
VAR134 += 32 + 2;
VAR135 = FUN53(VAR127, VAR134+(uint(VAR127[VAR134-1]) - 0x20), 32, VAR135, 0);
VAR67 {
VAR131 := FUN54(FUN44(VAR133, 32))
VAR132 := FUN54(FUN44(VAR135, 32))
}
(VAR129, VAR130) = FUN55(VAR126, 27, VAR131, VAR132);
if (address(FUN49(VAR128)) == VAR130) return true;
else {
(VAR129, VAR130) = FUN55(VAR126, 28, VAR131, VAR132);
return (address(FUN49(VAR128)) == VAR130);
}
}
function FUN56(bytes VAR43, uint VAR136) internal returns (bool) {
bool VAR129;
bytes memory VAR137 = VAR42 bytes(uint(VAR43[VAR136+1])+2);
FUN53(VAR43, VAR136, VAR137.VAR78, VAR137, 0);
bytes memory VAR138 = VAR42 bytes(64);
FUN53(VAR43, 3+1, 64, VAR138, 0);
bytes memory VAR139 = VAR42 bytes(1+65+32);
VAR139[0] = 1;
FUN53(VAR43, VAR136-65, 65, VAR139, 1);
bytes memory VAR140 = VAR141"";
FUN53(VAR140, 0, 32, VAR139, 1+65);
VAR129 = FUN52(FUN51(VAR139), VAR137, VAR138);
if (VAR129 == false) return false;
bytes memory VAR142 = VAR141"";
bytes memory VAR143 = VAR42 bytes(1+65);
VAR143[0] = 0xFE;
FUN53(VAR43, 3, 65, VAR143, 1);
bytes memory VAR144 = VAR42 bytes(uint(VAR43[3+65+1])+2);
FUN53(VAR43, 3+65, VAR144.VAR78, VAR144, 0);
VAR129 = FUN52(FUN51(VAR143), VAR144, VAR142);
return VAR129;
}
modifier FUN57(bytes32 VAR145, string VAR146, bytes VAR147) {
if ((VAR147[0] != "")||(VAR147[1] != "")||(VAR147[2] != 1)) throw;
bool VAR148 = FUN58(VAR147, VAR145, bytes(VAR146), FUN41());
if (VAR148 == false) throw;
VAR37;
}
function FUN59(bytes32 VAR145, string VAR146, bytes VAR147) internal returns (uint8){
if ((VAR147[0] != "")||(VAR147[1] != "")||(VAR147[2] != 1)) return 1;
bool VAR148 = FUN58(VAR147, VAR145, bytes(VAR146), FUN41());
if (VAR148 == false) return 2;
return 0;
}
function FUN60(bytes32 VAR149, bytes VAR150, uint VAR151) internal returns (bool){
bool VAR152 = true;
for (uint256 VAR73=0; VAR73< VAR151; VAR73++) {
if (VAR149[VAR73] != VAR150[VAR73]) VAR152 = false;
}
return VAR152;
}
function FUN58(bytes VAR43, bytes32 VAR122, bytes VAR41, string VAR153) internal returns (bool){
uint VAR154 = 3+65+(uint(VAR43[3+65+1])+2)+32;
bytes memory VAR155 = VAR42 bytes(32);
FUN53(VAR43, VAR154, 32, VAR155, 0);
if (!(FUN49(VAR155) == FUN49(FUN51(VAR153, VAR122)))) return false;
bytes memory VAR156 = VAR42 bytes(uint(VAR43[VAR154+(32+8+1+32)+1])+2);
FUN53(VAR43, VAR154+(32+8+1+32), VAR156.VAR78, VAR156, 0);
if (!FUN60(FUN51(VAR156), VAR41, uint(VAR43[VAR154+32+8]))) return false;
bytes memory VAR157 = VAR42 bytes(8+1+32);
FUN53(VAR43, VAR154+32, 8+1+32, VAR157, 0);
bytes memory VAR158 = VAR42 bytes(64);
uint VAR136 = VAR154+32+(8+1+32)+VAR156.VAR78+65;
FUN53(VAR43, VAR136-64, 64, VAR158, 0);
bytes32 VAR159 = FUN51(VAR158);
if (VAR124[VAR122] == FUN49(VAR157, VAR159)){
delete VAR124[VAR122];
} else return false;
bytes memory VAR160 = VAR42 bytes(32+8+1+32);
FUN53(VAR43, VAR154, 32+8+1+32, VAR160, 0);
if (!FUN52(FUN51(VAR160), VAR156, VAR158)) return false;
if (VAR125[VAR159] == false){
VAR125[VAR159] = FUN56(VAR43, VAR136);
}
return VAR125[VAR159];
}
function FUN53(bytes VAR161, uint VAR162, uint VAR78, bytes VAR163, uint VAR164) internal returns (bytes) {
uint VAR77 = VAR78 + VAR164;
if (VAR163.VAR78 < VAR77) {
throw;
}
uint VAR73 = 32 + VAR162;
uint VAR98 = 32 + VAR164;
while (VAR73 < (32 + VAR162 + VAR78)) {
VAR67 {
let VAR69 := FUN54(FUN44(VAR161, VAR73))
FUN43(FUN44(VAR163, VAR98), VAR69)
}
VAR73 += 32;
VAR98 += 32;
}
return VAR163;
}
function FUN55(bytes32 VAR165, uint8 VAR166, bytes32 VAR167, bytes32 VAR168) internal returns (bool, address) {
bool VAR169;
address VAR170;
VAR67 {
let VAR171 := FUN54(0x40)
FUN43(VAR171, VAR165)
FUN43(FUN44(VAR171, 32), VAR166)
FUN43(FUN44(VAR171, 64), VAR167)
FUN43(FUN44(VAR171, 96), VAR168)
VAR169 := call(3000, 1, 0, VAR171, 128, VAR171, 32)
VAR170 := FUN54(VAR171)
}
return (VAR169, VAR170);
}
function FUN61(bytes32 VAR165, bytes VAR172) internal returns (bool, address) {
bytes32 VAR167;
bytes32 VAR168;
uint8 VAR166;
if (VAR172.VAR78 != 65)
return (false, 0);
VAR67 {
VAR167 := FUN54(FUN44(VAR172, 32))
VAR168 := FUN54(FUN44(VAR172, 64))
VAR166 := FUN40(0, FUN54(FUN44(VAR172, 96)))
}
//
if (VAR166 < 27)
VAR166 += 27;
if (VAR166 != 27 && VAR166 != 28)
return (false, 0);
return FUN55(VAR165, VAR166, VAR167, VAR168);
}
}
contract nbagame is VAR19 {
address VAR173;
address[2] public VAR174 = [0x0161C8d35f0B603c7552017fe9642523f70d7B6A, 0x8B756b564d6FDFC1d0164174c514B0431ACC2409];
uint public constant VAR175 = 2;
string[VAR175] public VAR176 = ["", ""];
enum VAR177 { VAR178, VAR179, VAR180 }
TeamType public VAR181 = VAR177.VAR180;
uint public constant VAR182 = 10;
uint public constant VAR183 = 0.01 VAR48;
uint public constant VAR184 = 1518905100;
uint public constant VAR185 = 1519522500;
uint public constant VAR186 = 43200;
uint public constant VAR187 = 1519695300;
uint public constant VAR188 = VAR185 + VAR186;
bool public VAR189;
bool public VAR190;
struct VAR191 {
uint[VAR175] VAR192;
}
mapping(address => VAR191) VAR193;
address[] VAR194;
uint[VAR175] public VAR195;
uint public VAR196;
uint public VAR197;
event FUN62();
modifier FUN63() {
if (VAR181 != VAR177.VAR180 && !VAR190 && VAR198 > VAR185) VAR37;
}
modifier FUN64() {
if (VAR198 > VAR185) VAR37;
}
modifier FUN65() {
require(
VAR174[0] == msg.sender || VAR174[1] == msg.sender
);
VAR37;
}
function FUN66() public {
VAR173 = msg.sender;
FUN67(VAR188 - VAR198);
}
function FUN67(uint VAR199) private {
FUN23(VAR199, "", "");
}
function FUN20(bytes32 VAR122, string VAR41, bytes VAR43) public {
require(VAR190 == false);
require(msg.sender == FUN26());
if (FUN68(VAR176[0]) == FUN68(VAR41)) {
VAR181 = FUN69(0);
}
else if (FUN68(VAR176[1]) == FUN68(VAR41)) {
VAR181 = FUN69(1);
}
if (VAR181 == VAR177.VAR180) {
if (VAR198 >= VAR187)
return FUN70();
return FUN67(VAR186);
}
FUN71();
}
function FUN72() public constant returns(uint[VAR175]) {
return VAR193[msg.sender].VAR192;
}
function FUN70() private {
uint VAR200 = this.VAR201;
for (uint VAR94 = 0; VAR94 < VAR194.VAR78; VAR94++) {
uint VAR202 = VAR193[VAR194[VAR94]].VAR192[0] + VAR193[VAR194[VAR94]].VAR192[1];
VAR194[VAR94].transfer(VAR202 * VAR200 / VAR197);
}
}
function FUN73() public constant returns(bool) {
return (VAR198 >= VAR184 && VAR198 < VAR185);
}
function FUN74() public VAR203 {
FUN67(0);
}
function FUN75(uint VAR204) public payable {
require(FUN73() == true);
require(FUN69(VAR204) == VAR177.VAR178 || FUN69(VAR204) == VAR177.VAR179);
require(msg.value >= VAR183);
if (VAR193[msg.sender].VAR192[0] == 0 && VAR193[msg.sender].VAR192[1] == 0)
VAR194.FUN76(msg.sender);
VAR193[msg.sender].VAR192[VAR204] += msg.value;
VAR196++;
VAR197 += msg.value;
VAR195[VAR204] += msg.value;
FUN62();
}
function FUN71() private VAR205 {
uint VAR206 = this.VAR201 - VAR195[uint(VAR181)];
uint VAR207 = VAR206 / VAR182;
VAR174[0].transfer(VAR207 / VAR174.VAR78);
VAR174[1].transfer(VAR207 / VAR174.VAR78);
for (uint VAR94 = 0; VAR94 < VAR194.VAR78; VAR94++) {
uint VAR208 = VAR193[VAR194[VAR94]].VAR192[uint(VAR181)];
uint VAR209 = VAR208 + ((VAR208 * (VAR206 - VAR207)) / VAR195[uint(VAR181)]);
if (VAR209 > 0)
VAR194[VAR94].transfer(VAR209);
}
VAR190 = true;
}
}
0
---------------------------------
522 0x050a5a2e5e08c6d2a13eac1f0de636aed6c3080d.sol
pragma VAR1 >=0.4.22 <0.6.0;
interface VAR2 {
function FUN1(address VAR3, uint256 VAR4, address VAR5, bytes calldata VAR6) external;
}
contract VAR7 {
string public VAR8;
string public VAR9;
uint8 public VAR10 = 5;
uint256 public VAR11;
mapping (address => uint256) public VAR12;
mapping (address => mapping (address => uint256)) public VAR13;
event Transfer(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN2(address indexed VAR16, address indexed VAR17, uint256 VAR4);
event FUN3(address indexed VAR14, uint256 value);
constructor(
uint256 VAR18,
string memory VAR19,
string memory VAR20
) public {
VAR11 = VAR18 * 10 ** uint256(VAR10);
VAR12[msg.sender] = VAR11;
VAR8 = VAR19;
VAR9 = VAR20;
}
function FUN4(address VAR3, address VAR21, uint VAR4) internal {
require(VAR21 != address(0x0));
require(VAR12[VAR3] >= VAR4);
require(VAR12[VAR21] + VAR4 >= VAR12[VAR21]);
uint VAR22 = VAR12[VAR3] + VAR12[VAR21];
VAR12[VAR3] -= VAR4;
VAR12[VAR21] += VAR4;
emit Transfer(VAR3, VAR21, VAR4);
assert(VAR12[VAR3] + VAR12[VAR21] == VAR22);
}
function transfer(address VAR21, uint256 VAR4) public returns (bool VAR23) {
FUN4(msg.sender, VAR21, VAR4);
return true;
}
function FUN5(address VAR3, address VAR21, uint256 VAR4) public returns (bool VAR23) {
require(VAR4 <= VAR13[VAR3][msg.sender]);
VAR13[VAR3][msg.sender] -= VAR4;
FUN4(VAR3, VAR21, VAR4);
return true;
}
function FUN6(address VAR17, uint256 VAR4) public
returns (bool VAR23) {
VAR13[msg.sender][VAR17] = VAR4;
emit FUN2(msg.sender, VAR17, VAR4);
return true;
}
function FUN7(address VAR17, uint256 VAR4, bytes memory VAR6)
public
returns (bool VAR23) {
tokenRecipient VAR24 = FUN8(VAR17);
if (FUN6(VAR17, VAR4)) {
VAR24.FUN1(msg.sender, VAR4, address(this), VAR6);
return true;
}
}
function FUN9(uint256 VAR4) public returns (bool VAR23) {
require(VAR12[msg.sender] >= VAR4);
VAR12[msg.sender] -= VAR4;
VAR11 -= VAR4;
emit FUN3(msg.sender, VAR4);
return true;
}
function FUN10(address VAR3, uint256 VAR4) public returns (bool VAR23) {
require(VAR12[VAR3] >= VAR4);
require(VAR4 <= VAR13[VAR3][msg.sender]);
VAR12[VAR3] -= VAR4;
VAR13[VAR3][msg.sender] -= VAR4;
VAR11 -= VAR4;
emit FUN3(VAR3, VAR4);
return true;
}
}
0
---------------------------------
523 0x05112a2d23b817c6471d4f7981b26f1cecec25d3.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
function FUN2() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR6;
}
function FUN3(address VAR5) public onlyOwner {
require(VAR5 != address(0));
FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract ETHERCFeeModifiers is VAR2 {
uint256 public VAR7;
uint256 public VAR8;
mapping (address => uint256) VAR9;
mapping (address => uint256) VAR10;
function FUN4() public {
VAR7 = 0;
VAR8 = 0;
}
function FUN5(address VAR11) public view returns (uint256 VAR12, uint256 VAR13) {
VAR12 = VAR9[VAR11] > VAR7 ? VAR9[VAR11] : VAR7;
VAR13 = VAR10[VAR11] > VAR8 ? VAR10[VAR11] : VAR8;
}
function FUN6(address VAR14, address VAR15) public view returns (uint256 VAR16, uint256 VAR17, uint256 VAR13) {
VAR16 = VAR9[VAR14] > VAR7 ? VAR9[VAR14] : VAR7;
VAR17 = VAR9[VAR15] > VAR7 ? VAR9[VAR15] : VAR7;
VAR13 = VAR10[VAR14] > VAR8 ? VAR10[VAR14] : VAR8;
}
function FUN7(address VAR11, uint256 VAR18, uint256 VAR19) public onlyOwner {
require(VAR18 <= 100 && VAR19 <= 100);
VAR9[VAR11] = VAR18;
VAR10[VAR11] = VAR19;
}
function FUN8(uint256 VAR20) public onlyOwner {
require(VAR20 <=100);
VAR7 = VAR20;
}
function FUN9(uint256 VAR21) public onlyOwner {
require(VAR21 <=100);
VAR8 = VAR21;
}
}
0
---------------------------------
524 0x051451fd23d345409383ba62dc807275b48b5008.sol
pragma VAR1 ^0.5.0;
interface VAR2 {
function transfer(address VAR3, uint256 value) external returns (bool);
function FUN1(address VAR4, uint256 value) external returns (bool);
function FUN2(address VAR5, address VAR3, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR6) external view returns (uint256);
function FUN5(address VAR7, address VAR4) external view returns (uint256);
event Transfer(address indexed VAR5, address indexed VAR3, uint256 value);
event FUN6(address indexed VAR7, address indexed VAR4, uint256 value);
}
contract ERC20Detailed is VAR2 {
string private VAR8;
string private VAR9;
uint8 private VAR10;
constructor (string memory VAR11, string memory VAR12, uint8 VAR13) public {
VAR8 = VAR11;
VAR9 = VAR12;
VAR10 = VAR13;
}
function FUN7() public view returns (string VAR14) {
return VAR8;
}
function FUN8() public view returns (string VAR14) {
return VAR9;
}
function FUN9() public view returns (uint8) {
return VAR10;
}
}
library VAR15 {
function FUN10(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
if (VAR16 == 0) {
return 0;
}
uint256 VAR18 = VAR16 * VAR17;
require(VAR18 / VAR16 == VAR17);
return VAR18;
}
function FUN11(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 > 0);
uint256 VAR18 = VAR16 / VAR17;
return VAR18;
}
function FUN12(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 <= VAR16);
uint256 VAR18 = VAR16 - VAR17;
return VAR18;
}
function FUN13(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
uint256 VAR18 = VAR16 + VAR17;
require(VAR18 >= VAR16);
return VAR18;
}
function FUN14(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 != 0);
return VAR16 % VAR17;
}
}
contract ERC20 is VAR2 {
using SafeMath for uint256;
mapping (address => uint256) private VAR19;
mapping (address => mapping (address => uint256)) private VAR20;
uint256 private VAR21;
function FUN3() public view returns (uint256) {
return VAR21;
}
function FUN4(address VAR7) public view returns (uint256) {
return VAR19[VAR7];
}
function FUN5(address VAR7, address VAR4) public view returns (uint256) {
return VAR20[VAR7][VAR4];
}
function transfer(address VAR3, uint256 value) public returns (bool) {
FUN15(msg.sender, VAR3, value);
return true;
}
function FUN1(address VAR4, uint256 value) public returns (bool) {
FUN16(msg.sender, VAR4, value);
return true;
}
function FUN2(address VAR5, address VAR3, uint256 value) public returns (bool) {
FUN15(VAR5, VAR3, value);
FUN16(VAR5, msg.sender, VAR20[VAR5][msg.sender].FUN12(value));
return true;
}
function FUN17(address VAR4, uint256 VAR22) public returns (bool) {
FUN16(msg.sender, VAR4, VAR20[msg.sender][VAR4].FUN13(VAR22));
return true;
}
function FUN18(address VAR4, uint256 VAR23) public returns (bool) {
FUN16(msg.sender, VAR4, VAR20[msg.sender][VAR4].FUN12(VAR23));
return true;
}
function FUN15(address VAR5, address VAR3, uint256 value) internal {
require(VAR3 != address(0));
VAR19[VAR5] = VAR19[VAR5].FUN12(value);
VAR19[VAR3] = VAR19[VAR3].FUN13(value);
emit Transfer(VAR5, VAR3, value);
}
function FUN19(address VAR24, uint256 value) internal {
require(VAR24 != address(0));
VAR21 = VAR21.FUN13(value);
VAR19[VAR24] = VAR19[VAR24].FUN13(value);
emit Transfer(address(0), VAR24, value);
}
function FUN20(address VAR24, uint256 value) internal {
require(VAR24 != address(0));
VAR21 = VAR21.FUN12(value);
VAR19[VAR24] = VAR19[VAR24].FUN12(value);
emit Transfer(VAR24, address(0), value);
}
function FUN16(address VAR7, address VAR4, uint256 value) internal {
require(VAR4 != address(0));
require(VAR7 != address(0));
VAR20[VAR7][VAR4] = value;
emit FUN6(VAR7, VAR4, value);
}
function FUN21(address VAR24, uint256 value) internal {
FUN20(VAR24, value);
FUN16(VAR24, msg.sender, VAR20[VAR24][msg.sender].FUN12(value));
}
}
library VAR25 {
struct VAR26 {
mapping (address => bool) VAR27;
}
function FUN13(Role storage VAR28, address VAR24) internal {
require(VAR24 != address(0));
require(!FUN22(VAR28, VAR24));
VAR28.VAR27[VAR24] = true;
}
function FUN23(Role storage VAR28, address VAR24) internal {
require(VAR24 != address(0));
require(FUN22(VAR28, VAR24));
VAR28.VAR27[VAR24] = false;
}
function FUN22(Role storage VAR28, address VAR24) internal view returns (bool) {
require(VAR24 != address(0));
return VAR28.VAR27[VAR24];
}
}
contract VAR29 {
using Roles for VAR25.VAR26;
event FUN24(address indexed VAR24);
event FUN25(address indexed VAR24);
VAR25.Role private VAR30;
constructor () internal {
FUN26(msg.sender);
}
modifier FUN27() {
require(FUN28(msg.sender));
VAR31;
}
function FUN28(address VAR24) public view returns (bool) {
return VAR30.FUN22(VAR24);
}
function FUN29(address VAR24) public VAR32 {
FUN26(VAR24);
}
function FUN30() public {
FUN31(msg.sender);
}
function FUN26(address VAR24) internal {
VAR30.FUN13(VAR24);
emit FUN24(VAR24);
}
function FUN31(address VAR24) internal {
VAR30.FUN23(VAR24);
emit FUN25(VAR24);
}
}
contract ERC20Mintable is VAR33, VAR29 {
function FUN32(address VAR3, uint256 value) public onlyMinter returns (bool) {
FUN19(VAR3, value);
return true;
}
}
contract xDFINITY is VAR34, VAR35 {
constructor() public FUN33("", "", 18) {
uint VAR36 = 1000000 * (10 ** uint256(18));
FUN29(0x0E7ae3482874640710474AaE058294cAeDEe4D99);
FUN29(0x01b71E1c61529f43AA7432a225306e51cF109100);
FUN32(0x0E7ae3482874640710474AaE058294cAeDEe4D99, VAR36);
FUN30();
}
}
0
---------------------------------
525 0x05159559b45296b0a96097351e17ab1619bc9431.sol
pragma VAR1 ^0.5.8;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
contract VAR6 {
address public VAR7;
event FUN6(address indexed VAR8, address indexed VAR9);
constructor() public {
VAR7 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR7);
VAR10;
}
function FUN7(address VAR9) public onlyOwner {
require(VAR9 != address(0));
emit FUN6(VAR7, VAR9);
VAR7 = VAR9;
}
}
contract VAR11 {
event Transfer(address indexed VAR12, address indexed VAR13, uint256 indexed VAR14);
event FUN8(address indexed VAR7, address indexed VAR15, uint256 indexed VAR14);
event FUN9(address indexed VAR7, address indexed VAR16, bool VAR15);
function FUN10(address VAR7) public view returns (uint256 VAR17);
function FUN11(uint256 VAR14) public view returns (address VAR7);
function FUN12(address VAR13, uint256 VAR14) public;
function FUN13(uint256 VAR14) public view returns (address VAR16);
function FUN14(address VAR16, bool VAR18) public;
function FUN15(address VAR7, address VAR16) public view returns (bool);
function FUN16(address VAR12, address VAR13, uint256 VAR14) public;
function FUN17(address VAR12, address VAR13, uint256 VAR14) public;
function FUN17(address VAR12, address VAR13, uint256 VAR14, bytes memory VAR19) public;
}
contract VAR20 {
function FUN18() public view returns (uint256);
function FUN10(address VAR21) public view returns (uint256);
function transfer(address VAR13, uint256 value) public returns (bool);
function FUN16(address VAR12, address VAR13, uint256 value) public returns (bool);
event Transfer(address indexed VAR12, address indexed VAR13, uint256 value);
uint8 public VAR22;
}
contract Bussiness is VAR6 {
using SafeMath for uint256;
address public VAR23 = address(0xFce92D4163AA532AA096DE8a3C4fEf9f875Bc55F);
ERC20BasicInterface public VAR24 = FUN19(0xEc7ba74789694d0d03D458965370Dc7cF2FE75Ba);
uint256 public VAR25 = 1000;
uint256 public VAR26 = 21;
struct VAR27 {
address payable VAR28;
uint256 VAR29;
uint256 VAR30;
uint256 VAR31;
bool VAR32;
}
struct VAR33 {
mapping(uint256 => VAR27) VAR34;
uint256[] VAR35;
uint256 VAR36;
uint256 VAR37;
uint256 VAR38;
uint256 VAR39;
}
mapping(address => VAR33) public VAR40;
address[] VAR41;
constructor() public {
VAR40[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR36 = 0;
VAR40[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR37 = 0;
VAR40[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR38 = 0;
VAR40[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B));
VAR40[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR36 = 0;
VAR40[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR37 = 0;
VAR40[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR38 = 0;
VAR40[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea));
VAR40[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR36 = 0;
VAR40[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR37 = 0;
VAR40[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR38 = 0;
VAR40[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0x273f7F8E6489682Df756151F5525576E322d51A3));
VAR40[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR36 = 0;
VAR40[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR37 = 0;
VAR40[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR38 = 0;
VAR40[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d));
VAR40[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR36 = 0;
VAR40[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR37 = 0;
VAR40[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR38 = 0;
VAR40[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392));
VAR40[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR36 = 0;
VAR40[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR37 = 0;
VAR40[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR38 = 0;
VAR40[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f));
VAR40[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR36 = 0;
VAR40[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR37 = 0;
VAR40[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR38 = 0;
VAR40[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340));
VAR40[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR36 = 0;
VAR40[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR37 = 0;
VAR40[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR38 = 0;
VAR40[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b));
VAR40[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR36 = 0;
VAR40[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR37 = 0;
VAR40[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR38 = 0;
VAR40[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0xf26A23019b4699068bb54457f32dAFCF22A9D371));
VAR40[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR36 = 0;
VAR40[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR37 = 0;
VAR40[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR38 = 0;
VAR40[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR39 = 30000000000000000;
VAR41.FUN20(address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099));
}
function FUN21(address VAR42, uint256 VAR43) public view returns (address, uint256, uint256, uint256, bool) {
return (VAR40[VAR42].VAR34[VAR43].VAR28, VAR40[VAR42].VAR34[VAR43].VAR29, VAR40[VAR42].VAR34[VAR43].VAR30, VAR40[VAR42].VAR34[VAR43].VAR31, VAR40[VAR42].VAR34[VAR43].VAR32);
}
modifier FUN22() {
require(msg.sender == VAR23);
VAR10;
}
modifier FUN23(address VAR42, uint256 VAR43) {
IERC721 VAR44 = FUN24(VAR42);
require(VAR44.FUN11(VAR43) == msg.sender);
VAR10;
}
function FUN25(address VAR42, uint8 VAR45)  internal {
if (VAR45 >= VAR40[VAR42].VAR35.VAR46) return;
for (uint VAR47 = VAR45; VAR47<VAR40[VAR42].VAR35.VAR46-1; VAR47++){
VAR40[VAR42].VAR35[VAR47] = VAR40[VAR42].VAR35[VAR47+1];
}
delete VAR40[VAR42].VAR35[VAR40[VAR42].VAR35.VAR46-1];
VAR40[VAR42].VAR35.VAR46--;
}
function FUN26(address VAR42, uint8[] memory VAR48) internal {
for(uint8 VAR47; VAR47<VAR48.VAR46; VAR47++){
FUN25(VAR42, VAR47);
}
}
function FUN11(address VAR42, uint256 VAR43) public view returns (address){
IERC721 VAR44 = FUN24(VAR42);
return VAR44.FUN11(VAR43);
}
function FUN10() public view returns (uint256){
return address(this).VAR17;
}
function FUN13(address VAR42, uint256 VAR43) public view returns (address){
IERC721 VAR44 = FUN24(VAR42);
return VAR44.FUN13(VAR43);
}
function FUN27(address VAR42, uint256 VAR43, uint256 VAR49, uint256 VAR50, uint VAR51, bool VAR52) internal {
VAR40[VAR42].VAR34[VAR43] = FUN28(msg.sender, VAR49, VAR50, VAR51, VAR52);
VAR40[VAR42].VAR35.FUN20(VAR43);
bool VAR53 = false;
for(uint VAR47 = 0; VAR47< VAR41.VAR46; VAR47++) {
if(VAR41[VAR47] == address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)) VAR53 = true;
}
if(!VAR53) VAR41.FUN20(address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099));
}
function FUN29(address VAR42, uint256 VAR43, uint256 VAR49, uint VAR52) public view returns(uint256, uint256) {
uint256 VAR54;
uint256 VAR55 = 0;
uint256 VAR56;
if (VAR52 == 1 && (VAR40[VAR42].VAR34[VAR43].VAR29 == 0 || !VAR40[VAR42].VAR34[VAR43].VAR32)) {
VAR55 = VAR40[VAR42].VAR39;
}
if (VAR40[VAR42].VAR34[VAR43].VAR29 < VAR49) {
VAR54 = VAR49.FUN3(VAR40[VAR42].VAR34[VAR43].VAR29).FUN1(VAR40[VAR42].VAR36).FUN2(VAR25);
if(VAR40[VAR42].VAR34[VAR43].VAR29 == 0) {
if (VAR54 >= VAR40[VAR42].VAR37) {
VAR56 = VAR54.FUN4(VAR55);
} else {
VAR56 = VAR40[VAR42].VAR37.FUN4(VAR55);
}
}
}
return (VAR56, VAR55);
}
function FUN30(address VAR42, uint256 VAR43, uint256 VAR49, uint VAR52) public payable FUN23(VAR42, VAR43) {
require(VAR40[VAR42].VAR34[VAR43].VAR29 != VAR49);
uint256 VAR54;
uint256 VAR55 = 0;
if (VAR52 == 1 && (VAR40[VAR42].VAR34[VAR43].VAR29 == 0 || !VAR40[VAR42].VAR34[VAR43].VAR32)) {
VAR55 = VAR40[VAR42].VAR39;
}
if (VAR40[VAR42].VAR34[VAR43].VAR29 < VAR49) {
VAR54 = VAR49.FUN3(VAR40[VAR42].VAR34[VAR43].VAR29).FUN1(VAR40[VAR42].VAR36).FUN2(VAR25);
if(VAR40[VAR42].VAR34[VAR43].VAR29 == 0) {
if (VAR54 >= VAR40[VAR42].VAR37) {
require(msg.value == VAR54.FUN4(VAR55));
} else {
require(msg.value == VAR40[VAR42].VAR37.FUN4(VAR55));
VAR54 = VAR40[VAR42].VAR37;
}
}
VAR54 = VAR54.FUN4(VAR40[VAR42].VAR34[VAR43].VAR30);
} else VAR54 = VAR49.FUN1(VAR40[VAR42].VAR36).FUN2(VAR25);
FUN27(VAR42, VAR43, VAR49, VAR54, 0, VAR52 == 1);
}
function FUN31(address VAR42, uint256 VAR43, uint256 VAR49, uint VAR52) public view returns (uint256){
uint VAR30;
uint256 VAR54;
uint VAR55 = 0;
uint VAR57;
address VAR58 = VAR42;
if (VAR52 == 1 && (VAR40[VAR42].VAR34[VAR43].VAR29 == 0 || !VAR40[VAR42].VAR34[VAR43].VAR32)) {
VAR55 = VAR40[VAR58].VAR39.FUN1(VAR26).FUN2(2).FUN2(10 ** 16);
}
if (VAR40[VAR42].VAR34[VAR43].VAR29 < VAR49) {
VAR54 = VAR49.FUN3(VAR40[VAR58].VAR34[VAR43].VAR29).FUN1(VAR40[VAR42].VAR36).FUN2(VAR25);
VAR30 = VAR54.FUN1(VAR26).FUN2(2).FUN2(10 ** 16);
if(VAR40[VAR42].VAR34[VAR43].VAR29 == 0) {
if (VAR30 >= VAR40[VAR42].VAR38) {
VAR57 = VAR30.FUN4(VAR55);
} else {
VAR57 = VAR40[VAR42].VAR38.FUN4(VAR55);
}
}
}
return VAR57;
}
function FUN32(address VAR42, uint256 VAR43, uint256 VAR49, uint VAR52) public FUN23(VAR42, VAR43) {
require(VAR40[VAR42].VAR34[VAR43].VAR29 != VAR49);
uint VAR30;
uint256 VAR54;
uint VAR55 = 0;
address VAR58 = VAR42;
uint256 VAR59 = VAR43;
if (VAR52 == 1 && (VAR40[VAR42].VAR34[VAR43].VAR29 == 0 || !VAR40[VAR42].VAR34[VAR43].VAR32)) {
VAR55 = VAR40[VAR58].VAR39.FUN1(VAR26).FUN2(2).FUN2(10 ** 16);
}
if (VAR40[VAR42].VAR34[VAR43].VAR29 < VAR49) {
VAR54 = VAR49.FUN3(VAR40[VAR58].VAR34[VAR59].VAR29).FUN1(VAR40[VAR58].VAR36).FUN2(VAR25);
VAR30 = VAR54.FUN1(VAR26).FUN2(2).FUN2(10 ** 16);
if(VAR40[VAR42].VAR34[VAR43].VAR29 == 0) {
if (VAR30 >= VAR40[VAR42].VAR38) {
require(VAR24.FUN16(msg.sender, address(this), VAR30.FUN4(VAR55)));
} else {
require(VAR24.FUN16(msg.sender, address(this), VAR40[VAR58].VAR38.FUN4(VAR55)));
VAR30 = VAR40[VAR42].VAR38;
}
}
VAR30 = VAR30.FUN4(VAR40[VAR42].VAR34[VAR43].VAR31);
} else {
VAR54 = VAR49.FUN1(VAR40[VAR58].VAR36).FUN2(VAR25);
VAR30 = VAR54.FUN1(VAR26).FUN2(2).FUN2(10 ** 16);
}
FUN27(VAR42, VAR43, VAR49, 0, VAR30, VAR52 == 1);
}
function FUN33(address VAR42, uint256 VAR43) public FUN23(VAR42, VAR43) returns (uint256){
if (VAR40[VAR42].VAR34[VAR43].VAR30 > 0) msg.sender.transfer(VAR40[VAR42].VAR34[VAR43].VAR30);
else if (VAR40[VAR42].VAR34[VAR43].VAR31 > 0) VAR24.transfer(msg.sender, VAR40[VAR42].VAR34[VAR43].VAR31);
FUN34(VAR42, VAR43);
return VAR40[VAR42].VAR34[VAR43].VAR29;
}
function FUN35(uint VAR60) public onlyOwner returns (uint){
require(VAR60 >= 1);
VAR26 = VAR60;
return (VAR26);
}
function FUN36(address VAR42, uint256 VAR61, uint256 VAR62, uint VAR63, uint256 VAR55) public onlyOwner returns (uint256, uint256, uint256, uint256){
require(VAR61 >= 0 && VAR62 >= 0 && VAR63 >= 0 && VAR55 >= 0);
VAR40[VAR42].VAR36 = VAR61;
VAR40[VAR42].VAR37 = VAR62;
VAR40[VAR42].VAR38 = VAR63;
VAR40[VAR42].VAR39 = VAR55;
return (VAR40[VAR42].VAR36, VAR40[VAR42].VAR37, VAR40[VAR42].VAR38, VAR40[VAR42].VAR39);
}
function FUN37(uint256 VAR64, uint256 VAR65) internal {
require(address(this).VAR17 >= VAR64 && VAR24.FUN10(address(this)) >= VAR65);
if(VAR64 > 0) {
msg.sender.transfer(VAR64);
}
if(VAR65 > 0) {
VAR24.transfer(msg.sender, VAR65);
}
}
function FUN38(uint256 VAR64, uint8 VAR65) public VAR66 {
FUN37(VAR64, VAR65);
}
function FUN39() public VAR66 {
for(uint VAR67 = 0; VAR67< VAR41.VAR46; VAR67++) {
address VAR42 = VAR41[VAR67];
IERC721 VAR44 = FUN24(VAR41[VAR67]);
uint256[] memory VAR48 = VAR40[VAR42].VAR35;
uint VAR46 = VAR40[VAR42].VAR35.VAR46;
for (uint VAR47 = 0; VAR47 < VAR46; VAR47++) {
if (VAR40[VAR42].VAR34[VAR48[VAR47]].VAR28 == VAR44.FUN11(VAR48[VAR47])) {
if (VAR40[VAR42].VAR34[VAR48[VAR47]].VAR30 > 0) {
uint256 VAR68 = VAR40[VAR42].VAR34[VAR48[VAR47]].VAR30;
if(VAR40[VAR42].VAR34[VAR48[VAR47]].VAR32) VAR68 = VAR68.FUN4(VAR40[VAR42].VAR39);
if(address(this).VAR17 >= VAR68) {
VAR40[VAR42].VAR34[VAR48[VAR47]].VAR28.transfer(VAR68);
}
}
else if (VAR40[VAR42].VAR34[VAR48[VAR47]].VAR31 > 0) {
uint VAR69 = VAR40[VAR42].VAR34[VAR48[VAR47]].VAR31;
if(VAR40[VAR42].VAR34[VAR48[VAR47]].VAR32) VAR69 = VAR69.FUN4(VAR40[VAR42].VAR39.FUN1(VAR26).FUN2(2).FUN2(10 ** 16));
if(VAR24.FUN10(address(this)) >= VAR69) {
VAR24.transfer(VAR40[VAR42].VAR34[VAR48[VAR47]].VAR28, VAR69);
}
}
FUN34(VAR42, VAR48[VAR47]);
}
}
}
FUN37(address(this).VAR17, VAR24.FUN10(address(this)));
}
function FUN40() public view returns (uint256, uint){
uint256 VAR54 = 0;
uint256 VAR31 = 0;
for(uint VAR67 = 0; VAR67< VAR41.VAR46; VAR67++) {
address VAR42 = VAR41[VAR67];
IERC721 VAR44 = FUN24(VAR41[VAR67]);
for (uint VAR47 = 0; VAR47 < VAR40[VAR42].VAR35.VAR46; VAR47++) {
if (VAR40[VAR42].VAR34[VAR40[VAR42].VAR35[VAR47]].VAR28 == VAR44.FUN11(VAR40[VAR42].VAR35[VAR47])) {
if (VAR40[VAR42].VAR34[VAR40[VAR42].VAR35[VAR47]].VAR30 > 0) {
VAR54 = VAR54.FUN4(VAR40[VAR42].VAR34[VAR40[VAR42].VAR35[VAR47]].VAR30);
}
else if (VAR40[VAR42].VAR34[VAR40[VAR42].VAR35[VAR47]].VAR31 > 0) {
VAR31 = VAR31.FUN4(VAR40[VAR42].VAR34[VAR40[VAR42].VAR35[VAR47]].VAR31);
}
}
}
}
uint256 VAR68 = address(this).VAR17.FUN3(VAR54);
uint256 VAR69 = VAR24.FUN10(address(this)).FUN3(VAR31);
return (VAR68, VAR69);
}
function FUN41(address VAR70) public VAR66 {
require(VAR70 != address(0));
VAR23 = VAR70;
}
function FUN42(address VAR42, uint256 VAR14) public payable {
IERC721 VAR44 = FUN24(VAR42);
require(FUN13(VAR42, VAR14) == address(this));
require(VAR40[VAR42].VAR34[VAR14].VAR29 > 0 && VAR40[VAR42].VAR34[VAR14].VAR29 == msg.value);
VAR44.FUN16(VAR40[VAR42].VAR34[VAR14].VAR28, msg.sender, VAR14);
VAR40[VAR42].VAR34[VAR14].VAR28.transfer(msg.value);
FUN34(VAR42, VAR14);
}
function FUN43(address VAR42, uint256 VAR14) public payable {
IERC721 VAR44 = FUN24(VAR42);
require(VAR40[VAR42].VAR34[VAR14].VAR29 > 0 && VAR40[VAR42].VAR34[VAR14].VAR29 == msg.value);
VAR44.FUN16(VAR40[VAR42].VAR34[VAR14].VAR28, msg.sender, VAR14);
VAR40[VAR42].VAR34[VAR14].VAR28.transfer(msg.value);
FUN34(VAR42, VAR14);
}
function FUN34(address VAR42, uint256 VAR43) private {
VAR40[VAR42].VAR34[VAR43] = FUN28(address(0), 0, 0, 0, false);
for (uint8 VAR47 = 0; VAR47 < VAR40[VAR42].VAR35.VAR46; VAR47++) {
if (VAR40[VAR42].VAR35[VAR47] == VAR43) {
FUN25(VAR42, VAR47);
}
}
}
}
0
---------------------------------
526 0x051856b350b07bbed92818357f28f78c47e31ab5.sol
pragma VAR1 ^"";
contract VAR2 {
using SafeMath for uint256;
CovaToken internal VAR3;
uint256 internal VAR4;
uint256 internal VAR5;
uint256 internal VAR6 = 7890000;
uint256 internal VAR7 = 15780000;
address internal VAR8;
struct VAR9 {
bool VAR10;
uint256 VAR11;
uint256 VAR12;
bool VAR13;
}
VAR9 [] internal VAR14;
uint256 internal VAR15;
event FUN1(
address indexed VAR16,
uint256 VAR17,
uint256 VAR18
);
function FUN2() public returns (bool){
require(msg.sender == VAR8);
for(uint256 VAR19 = 0; VAR19 < VAR14.VAR20; VAR19++){
Claim memory VAR21 = VAR14[VAR19];
if(VAR21.VAR13 == false){
if((VAR21.VAR10 == false && (VAR21.VAR12.FUN3(VAR4) < VAR22.VAR18)) || (VAR21.VAR10 == true && (VAR21.VAR12.FUN3(VAR5) < VAR22.VAR18))){
uint256 VAR17 = VAR21.VAR11.FUN4(VAR15).FUN5(10000);
require(VAR3.transfer(msg.sender, VAR17));
VAR14[VAR19].VAR13 = true;
emit FUN1(msg.sender, VAR17, VAR22.VAR18);
}
}
}
}
function FUN6() public view returns (address) {
return VAR8;
}
function FUN7() public view returns (uint256) {
return VAR15;
}
}
contract VAR23 {
function FUN8() public view returns (uint256);
function FUN9(address VAR24) public view returns (uint256);
function FUN10(address VAR25, address VAR26)
public view returns (uint256);
function transfer(address VAR27, uint256 VAR28) public returns (bool);
function FUN11(address VAR26, uint256 VAR28)
public returns (bool);
function FUN12(address VAR29, address VAR27, uint256 VAR28)
public returns (bool);
event Transfer(
address indexed VAR30,
address indexed VAR31,
uint256 value
);
event FUN13(
address indexed VAR32,
address indexed VAR33,
uint256 value
);
}
library VAR34 {
function FUN4(uint256 VAR35, uint256 VAR36) internal pure returns (uint256) {
if (VAR35 == 0) {
return 0;
}
uint256 VAR37 = VAR35 * VAR36;
require(VAR37 / VAR35 == VAR36);
return VAR37;
}
function FUN5(uint256 VAR35, uint256 VAR36) internal pure returns (uint256) {
require(VAR36 > 0);
uint256 VAR37 = VAR35 / VAR36;
return VAR37;
}
function FUN14(uint256 VAR35, uint256 VAR36) internal pure returns (uint256) {
require(VAR36 <= VAR35);
uint256 VAR37 = VAR35 - VAR36;
return VAR37;
}
function FUN3(uint256 VAR35, uint256 VAR36) internal pure returns (uint256) {
uint256 VAR37 = VAR35 + VAR36;
require(VAR37 >= VAR35);
return VAR37;
}
function FUN15(uint256 VAR38, uint256 VAR39) internal pure returns (uint256) {
require(VAR39 != 0);
return VAR38 % VAR39;
}
}
contract CovaToken is VAR23 {
using SafeMath for uint256;
mapping (address => uint256) private VAR40;
mapping (address => mapping (address => uint256)) private VAR41;
uint256 private VAR42 = 65 * (10 ** (8 + 18));
string private constant VAR43 = '';
string private constant VAR44 = '';
uint8 private constant VAR45 = 18;
constructor () public {
VAR40[msg.sender] = VAR42;
emit Transfer(address(0), msg.sender, VAR42);
}
function FUN8() public view returns (uint256) {
return VAR42;
}
function FUN16() public view returns (string) {
return VAR43;
}
function FUN17() public view returns (string) {
return VAR44;
}
function FUN18() public view returns (uint8) {
return VAR45;
}
function FUN9(address VAR25) public view returns (uint256) {
return VAR40[VAR25];
}
function FUN10(
address VAR25,
address VAR26
)
public
view
returns (uint256)
{
return VAR41[VAR25][VAR26];
}
function transfer(address VAR27, uint256 VAR28) public returns (bool) {
require(VAR28 <= VAR40[msg.sender]);
require(VAR27 != address(0));
VAR40[msg.sender] = VAR40[msg.sender].FUN14(VAR28);
VAR40[VAR27] = VAR40[VAR27].FUN3(VAR28);
emit Transfer(msg.sender, VAR27, VAR28);
return true;
}
function FUN11(address VAR26, uint256 VAR28) public returns (bool) {
VAR41[msg.sender][VAR26] = VAR28;
emit FUN13(msg.sender, VAR26, VAR28);
return true;
}
function FUN12(
address VAR29,
address VAR27,
uint256 VAR28
)
public
returns (bool)
{
require(VAR28 <= VAR40[VAR29]);
require(VAR28 <= VAR41[VAR29][msg.sender]);
require(VAR27 != address(0));
VAR40[VAR29] = VAR40[VAR29].FUN14(VAR28);
VAR40[VAR27] = VAR40[VAR27].FUN3(VAR28);
VAR41[VAR29][msg.sender] = VAR41[VAR29][msg.sender].FUN14(VAR28);
emit Transfer(VAR29, VAR27, VAR28);
return true;
}
function FUN19(
address VAR26,
uint256 VAR46
)
public
returns (bool)
{
VAR41[msg.sender][VAR26] = (
VAR41[msg.sender][VAR26].FUN3(VAR46));
emit FUN13(msg.sender, VAR26, VAR41[msg.sender][VAR26]);
return true;
}
function FUN20(
address VAR26,
uint256 VAR47
)
public
returns (bool)
{
uint256 VAR48 = VAR41[msg.sender][VAR26];
if (VAR47 >= VAR48) {
VAR41[msg.sender][VAR26] = 0;
} else {
VAR41[msg.sender][VAR26] = VAR48.FUN14(VAR47);
}
emit FUN13(msg.sender, VAR26, VAR41[msg.sender][VAR26]);
return true;
}
}
contract VestingFoundation is VAR2{
using SafeMath for uint256;
constructor(CovaToken VAR49, uint256 VAR50) public {
VAR3 = VAR49;
VAR4 = VAR50;
VAR5 = VAR22.VAR18;
VAR8 = 0xC29cf578388A738868009a03fecCe7A262cda22a;
VAR15 = 650000000 * (10 ** 18);
VAR14.FUN21(FUN22(false, 10000, 0, false));
}
}
0
---------------------------------
527 0x05240da139d30034eaae15737610bfbe68b97910.sol
//
//
//
//
//
//
//
//
//
//
//
contract VAR1
{
address VAR2;
uint8 VAR3;
uint8 VAR4;
uint256 VAR5;
uint VAR6;
uint VAR7;
uint VAR8;
uint256 VAR9;
enum VAR10{VAR11, VAR12, VAR13, VAR14, VAR15, VAR16}
struct VAR17
{
address VAR18;
bool VAR19;
bool VAR20;
BetTypes VAR21;
uint8 VAR22;
uint256 VAR23;
uint256 VAR24;
uint8 VAR25;
}
VAR17[] private VAR26;
uint VAR27;
mapping (address=>uint) VAR28;
enum VAR29 {VAR30, VAR31} mapping (address=>VAR29) VAR32;
function  FUN1() private
{
VAR2 = msg.sender;
VAR3=2;
VAR4=200;
VAR5=500 VAR33;
VAR6=5;
VAR8=20;
}
modifier FUN2()
{
if (msg.sender!=VAR2) throw;
VAR34
}
function FUN3(address VAR35)
VAR36
VAR37
{
VAR2=VAR35;
}
enum VAR38{VAR39, VAR40} States private VAR41;
function FUN4()
VAR36
VAR37
{
VAR41=VAR38.VAR40;
}
function FUN5()
VAR37
VAR36
{
VAR41=VAR38.VAR39;
}
modifier VAR42
{
if (VAR41==VAR38.VAR40) throw;
VAR34
}
function FUN6(uint VAR43, uint VAR44, uint256 VAR45, uint8 VAR46, uint256 VAR47, uint256 VAR48, uint8 VAR49, uint8 VAR50)
VAR36
VAR37
{
if (VAR43<10) throw;
VAR8=VAR43;
VAR6=VAR44;
if (VAR45<=0) throw;
else { VAR5=VAR45; }
if (VAR46<VAR51 || VAR46>149) throw;
else { VAR51=VAR46;}
VAR52=VAR47;
if (VAR53>90 VAR54) throw;
VAR53=VAR48;
if (VAR3<1) throw;
VAR3=VAR49;
FUN7();
if (VAR50<50) throw;
VAR4=VAR50;
}
function ()
{
if (VAR32[msg.sender]==VAR29.VAR30)  FUN8(true,false);
else FUN9();
}
function FUN7() private
{
if (VAR55/(VAR8*35) > VAR5)
{
VAR9=VAR5;
}
else
{
VAR9 = VAR55/(VAR8*35);
}
}
function FUN10() private returns(uint256 VAR56)
{
FUN7();
if (msg.value > VAR9)
{
if (msg.sender.FUN11(msg.value-VAR9)==false) throw;
VAR56=VAR9;
}
else
{ VAR56=msg.value; }
return;
}
modifier FUN12()
{
if (VAR26.VAR57!=0 && VAR58.VAR11==VAR26[VAR26.VAR57-1].VAR24) VAR7+=1;
else VAR7=0;
if (VAR7>=VAR6) throw;
VAR34
}
modifier VAR59{
if (VAR32[msg.sender]!=VAR29.VAR30)
{
if (VAR26[VAR28[msg.sender]].VAR24+VAR4>VAR58.VAR11) throw;
else
{
FUN13(msg.sender, 255, false, 0) ;
}
}
VAR34
}
function FUN14() private
VAR60
{
VAR32[msg.sender]=VAR29.VAR31;
VAR28[msg.sender]=VAR26.VAR57;
}
function FUN15(uint8 VAR61)
VAR59
VAR42
VAR62
{
FUN14();
if (VAR61>36) throw;
uint256 VAR63= FUN10();
VAR26.FUN16(FUN17(msg.sender, false, false, VAR10.VAR11, VAR61, VAR63, VAR58.VAR11, 37));
}
function FUN8(bool VAR64, bool VAR65)
VAR59
VAR42
VAR62
{
FUN14();
uint8 VAR66;
uint8 VAR22;
if (VAR64)
{
VAR66+=1;
VAR22=0;
}
if (VAR65)
{
VAR66+=1;
VAR22=1;
}
if (VAR66!=1) throw;
uint256 VAR63= FUN10();
VAR26.FUN16(FUN17(msg.sender, false, false, VAR10.VAR12, VAR22, VAR63, VAR58.VAR11, 37));
}
function FUN18(bool VAR67, bool VAR68)
VAR59
VAR42
VAR62
{
FUN14();
uint8 VAR66;
uint8 VAR22;
if (VAR67)
{
VAR66+=1;
VAR22=0;
}
if (VAR68)
{
VAR66+=1;
VAR22=1;
}
if (VAR66!=1) throw;
uint256 VAR63= FUN10();
VAR26.FUN16(FUN17(msg.sender, false, false, VAR10.VAR16, VAR22, VAR63, VAR58.VAR11, 37));
}
function FUN19(bool VAR69, bool VAR70)
VAR59
VAR42
VAR62
{
FUN14();
uint8 VAR66;
uint8 VAR22;
if (VAR70)
{
VAR66+=1;
VAR22=0;
}
if (VAR69)
{
VAR66+=1;
VAR22=1;
}
if (VAR66!=1) throw;
uint256 VAR63= FUN10();
VAR26.FUN16(FUN17(msg.sender, false, false, VAR10.VAR13, VAR22, VAR63, VAR58.VAR11, 37));
}
function FUN20(bool VAR71, bool VAR72, bool VAR73)
{
FUN21(VAR71,VAR72,VAR73, VAR10.VAR14);
}
function FUN22(bool VAR71, bool VAR72, bool VAR73)
{
FUN21(VAR71, VAR72, VAR73, VAR10.VAR15);
}
function FUN21(bool VAR71, bool VAR72, bool VAR73, BetTypes VAR74) private
VAR59
VAR42
VAR62
{
FUN14();
uint8 VAR66;
uint8 VAR22;
if (VAR71)
{
VAR66+=1;
VAR22=0;
}
if (VAR72)
{
VAR66+=1;
VAR22=1;
}
if (VAR73)
{
VAR66+=1;
VAR22=2;
}
if (VAR66!=1) throw;
uint256 VAR63= FUN10();
VAR26.FUN16(FUN17(msg.sender, false, false, VAR74, VAR22, VAR63, VAR58.VAR11, 37));
}
event FUN23(address VAR18, uint8 VAR75, uint VAR76);
event FUN24(address VAR18, uint8 VAR75, uint VAR77);
modifier VAR78{
if (VAR32[msg.sender]!=VAR29.VAR31) throw;
VAR34
}
modifier FUN25()
{
if (msg.value>0)
{
if (msg.sender.FUN11(msg.value)==false) throw;
}
VAR34
}
function FUN9()
VAR36
VAR78
{
uint VAR79 = VAR26[VAR28[msg.sender]].VAR24;
if (VAR58.VAR11<VAR79+VAR3 || VAR58.VAR11>VAR79+VAR4) throw;
else
{
uint8 VAR25;
VAR25 = uint8(uint256(VAR58.FUN26(VAR79+VAR3))%37);
VAR26[VAR28[msg.sender]].VAR25=VAR25;
FUN27(VAR25, VAR26[VAR28[msg.sender]].VAR21);
FUN28();
}
}
function FUN28() private
{
for (uint VAR80=VAR27; VAR80<=VAR27+50; VAR80++)
{
if (VAR80>=VAR26.VAR57 || !VAR26[VAR80].VAR19)
{
VAR27=VAR80;
break;
}
}
}
modifier VAR60{
if (  VAR26.VAR57!=0 && VAR26.VAR57-1>=VAR27
&& VAR26[VAR27].VAR24 + VAR4 <= VAR58.VAR11
&& !VAR26[VAR27].VAR19 )
{
FUN13(VAR26[VAR27].VAR18, 255, false, 0);
}
FUN28();
VAR34
}
function FUN27(uint8 VAR75, BetTypes VAR21) private
{
if (VAR21==VAR10.VAR11) FUN29(VAR75);
else if (VAR21==VAR10.VAR13) FUN30(VAR75);
else if (VAR21==VAR10.VAR12) FUN31(VAR75);
else if (VAR21==VAR10.VAR16) FUN32(VAR75);
else if (VAR21==VAR10.VAR14) FUN33(VAR75);
else if (VAR21==VAR10.VAR15) FUN34(VAR75);
FUN7();
}
function FUN13(address VAR18, uint8 VAR75, bool VAR20, uint8 VAR81) private
{
VAR32[VAR18]=VAR29.VAR30;
VAR26[VAR28[VAR18]].VAR19=true;
uint VAR82 = VAR26[VAR28[VAR18]].VAR23;
if (VAR20)
{
if (VAR18!=VAR26[VAR28[VAR18]].VAR18) throw;
VAR26[VAR28[VAR18]].VAR20=true;
uint VAR83 = VAR81*VAR82;
VAR84+=VAR83-VAR82;
FUN23(VAR18, VAR75, VAR83);
if (VAR18.FUN11(VAR83)==false) throw;
}
else
{
FUN24(VAR18, VAR75, VAR82);
VAR85+=VAR82;
}
}
function FUN29(uint8 VAR75) private
{
bool VAR20;
if (VAR75==VAR26[VAR28[msg.sender]].VAR22)
{
VAR20=true;
}
FUN13(msg.sender, VAR75,VAR20,36);
}
function FUN30(uint8 VAR75) private
{
bool VAR20;
if (VAR75%2==VAR26[VAR28[msg.sender]].VAR22 && VAR75!=0)
{
VAR20=true;
}
FUN13(msg.sender,VAR75,VAR20,2);
}
function FUN32(uint8 VAR75) private
{
bool VAR20;
if (VAR75!=0 && ( (VAR75<19 && VAR26[VAR28[msg.sender]].VAR22==0)
|| (VAR75>18 && VAR26[VAR28[msg.sender]].VAR22==1)
) )
{
VAR20=true;
}
FUN13(msg.sender,VAR75,VAR20,2);
}
uint[18] VAR86=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
function FUN31(uint8 VAR75) private
{
bool VAR87;
for (uint8 VAR80; VAR80<18; VAR80++)
{
if (VAR86[VAR80]==VAR75)
{
VAR87=true;
break;
}
}
bool VAR20;
if ( VAR75!=0
&& ( (VAR26[VAR28[msg.sender]].VAR22==0 && VAR87)
|| ( VAR26[VAR28[msg.sender]].VAR22==1 && !VAR87)  ) )
{
VAR20=true;
}
FUN13(msg.sender,VAR75,VAR20,2);
}
function FUN33(uint8 VAR75) private
{
bool VAR20;
if ( VAR75!=0 &&
( (VAR75<13 && VAR26[VAR28[msg.sender]].VAR22==0)
||
(VAR75>12 && VAR75<25 && VAR26[VAR28[msg.sender]].VAR22==1)
||
(VAR75>24 && VAR26[VAR28[msg.sender]].VAR22==2) ) )
{
VAR20=true;
}
FUN13(msg.sender,VAR75,VAR20,3);
}
function FUN34(uint8 VAR75) private
{
bool VAR20;
if ( VAR75!=0
&& ( (VAR26[VAR28[msg.sender]].VAR22==0 && VAR75%3==1)
|| ( VAR26[VAR28[msg.sender]].VAR22==1 && VAR75%3==2)
|| ( VAR26[VAR28[msg.sender]].VAR22==2 && VAR75%3==0)  ) )
{
VAR20=true;
}
FUN13(msg.sender,VAR75,VAR20,3);
}
uint256 VAR55;
uint256 VAR85;
uint256 VAR84;
uint8 VAR51 = 50;
struct VAR88
{
address VAR89;
uint256 VAR90;
}
VAR88[250] private VAR91 ;
mapping (address=>uint256) VAR92;
uint256 VAR53=30 VAR54 ;
uint256 VAR52=10 VAR93;
uint8 VAR94;
uint256 VAR95;
uint8 VAR96;
event FUN35(address VAR18, uint VAR97);
function FUN36()
{
if (msg.value<VAR52) throw;
bool VAR98;
VAR96=255;
VAR94=255;
VAR95=1000000000 VAR93;
FUN37();
for (uint8 VAR80 = 0; VAR80<VAR51; VAR80++)
{
if (VAR91[VAR80].VAR89==0) VAR96=VAR80;
else if (VAR91[VAR80].VAR89==msg.sender)
{
VAR91[VAR80].VAR90=VAR99;
VAR98=true;
}
else if (VAR91[VAR80].VAR90+VAR53<VAR99 && VAR92[VAR91[VAR80].VAR89]<VAR95 && VAR91[VAR80].VAR89!=VAR2)
{
VAR94=VAR80;
VAR95=VAR92[VAR91[VAR80].VAR89];
}
}
if (VAR98==false)
{
if (VAR96!=255) VAR91[VAR96]=FUN38(msg.sender, VAR99);
else
{
if (msg.value<=VAR95 || VAR94==255) throw;
else
{
address VAR100 = VAR91[VAR94].VAR89;
VAR92[VAR100]=0;
VAR91[VAR94]=FUN38(msg.sender, VAR99);
if (VAR100.FUN11(VAR92[VAR100])==false) throw;
}
}
}
uint256 VAR101=2*msg.value/100;
uint256 VAR102=msg.value - VAR101;
FUN35(msg.sender, VAR102);
VAR92[msg.sender]+=VAR102;
VAR55+=VAR102;
if (VAR2.FUN11(VAR101)==false) throw;
FUN7();
}
event FUN39(address VAR18, uint VAR103);
function FUN40(uint256 VAR104)
VAR36
{
FUN37();
if (VAR104>VAR92[msg.sender]) throw;
uint8 VAR105=255;
for (uint8 VAR80 = 0; VAR80<VAR51; VAR80++)
{
if (VAR91[VAR80].VAR89==msg.sender)
{
VAR105=VAR80;
break;
}
}
if (VAR105==255) throw;
if (VAR91[VAR105].VAR90+VAR53>VAR99) throw;
if (VAR92[msg.sender]-VAR104>=VAR52 && VAR104!=0)
{
VAR92[msg.sender]-=VAR104;
VAR55-=VAR104;
if (msg.sender.FUN11(VAR104)==false) throw;
FUN39(msg.sender, VAR104);
}
else
{
uint256 VAR106=VAR92[msg.sender];
VAR55-=VAR106;
VAR92[msg.sender]=0;
delete VAR91[VAR105];
if (msg.sender.FUN11(VAR106)==false) throw;
FUN39(msg.sender, VAR106);
}
FUN7();
}
function FUN41()
VAR60
VAR36
VAR37
{
FUN37();
}
function FUN37() private
{
uint256 VAR107;
uint256 VAR108;
if (VAR85==0 && VAR84==0)
{ return; }
else
{
if (VAR85>VAR84)
{
VAR107=VAR85-VAR84;
uint256 VAR109=VAR107*2/100;
VAR107-=VAR109;
if (VAR2.FUN11(VAR109)==false) throw;
}
else
{
VAR108=VAR84-VAR85;
}
uint VAR110;
for (uint8 VAR80=0; VAR80<VAR51; VAR80++)
{
address VAR111=VAR91[VAR80].VAR89;
if (VAR111==0) continue;
else
{
if (VAR107!=0)
{
uint VAR112=(VAR107*VAR92[VAR111])/VAR55;
VAR92[VAR111]+=VAR112;
VAR110+=VAR112;
}
if (VAR108!=0)
{
uint VAR113=(VAR108*VAR92[VAR111])/VAR55;
VAR92[VAR111]-=VAR113;
VAR110+=VAR113;
}
}
}
if (VAR107 !=0)
{
VAR55+=VAR107;
VAR92[VAR2]+=VAR107-VAR110;
}
if (VAR108 !=0)
{
VAR55-=VAR108;
VAR92[VAR2]-=VAR108-VAR110;
}
VAR85=0;
VAR84=0;
}
}
function FUN42() constant returns(uint VAR114, uint VAR115)
{
VAR114=VAR85;
VAR115=VAR84;
return;
}
function FUN43(address VAR89) constant returns(uint VAR116)
{
VAR116=VAR92[VAR89];
return;
}
function FUN44(uint VAR117) constant returns(address VAR89, uint VAR118)
{
VAR89=VAR91[VAR117].VAR89;
VAR118=VAR91[VAR117].VAR90+VAR53;
return;
}
function FUN45() constant returns(bool VAR119, bool VAR120, uint VAR121, uint VAR122)
{
if (VAR96!=255) VAR119=true;
if (VAR94!=255)
{
VAR120=true;
VAR121=VAR95;
}
VAR122=VAR53;
return;
}
function FUN46() constant returns(uint VAR123, uint8 VAR124)
{
VAR123=VAR9;
VAR124=VAR3;
return ;
}
function FUN47() constant returns(uint VAR125)
{
VAR125=VAR27;
return ;
}
function FUN48() constant returns(uint VAR126)
{
VAR126=VAR55;
return ;
}
function FUN49(address VAR18) constant returns(Status VAR127, BetTypes VAR128, uint8 VAR22, uint value, uint8 VAR75, bool VAR129, bool VAR20, uint VAR130)
{
VAR127=VAR32[VAR18];
VAR128=VAR26[VAR28[VAR18]].VAR21;
VAR22=VAR26[VAR28[VAR18]].VAR22;
value=VAR26[VAR28[VAR18]].VAR23;
VAR75=VAR26[VAR28[VAR18]].VAR25;
VAR129=VAR26[VAR28[VAR18]].VAR19;
VAR20=VAR26[VAR28[VAR18]].VAR20;
VAR130=VAR26[VAR28[VAR18]].VAR24;
return;
}
function FUN50(uint256 VAR117) constant returns(address VAR18, BetTypes VAR128, uint8 VAR22, uint value, uint8 VAR75, bool VAR129, bool VAR20, uint VAR130)
{
VAR18=VAR26[VAR117].VAR18;
VAR128=VAR26[VAR117].VAR21;
VAR22=VAR26[VAR117].VAR22;
value=VAR26[VAR117].VAR23;
VAR75=VAR26[VAR117].VAR25;
VAR129=VAR26[VAR117].VAR19;
VAR20=VAR26[VAR117].VAR20;
VAR130=VAR26[VAR117].VAR24;
return;
}
} //end of contract
0
---------------------------------
528 0x05316c4bbf2521bb529ca47dd66212d34ed1f6a3.sol
pragma VAR1 >=0.4.22 <0.6.0;
contract VAR2 {
address public VAR3;
constructor() public {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR3);
VAR4;
}
function FUN1(address VAR5) onlyOwner public {
VAR3 = VAR5;
}
}
interface VAR6 { function FUN2(address VAR7, uint256 VAR8, address VAR9, bytes calldata VAR10) external; }
contract VAR11 {
string public VAR12;
string public VAR13;
uint8 public VAR14 = 18;
uint256 public VAR15;
mapping (address => uint256) public VAR16;
mapping (address => mapping (address => uint256)) public VAR17;
event Transfer(address indexed VAR18, address indexed VAR19, uint256 value);
event FUN3(address indexed VAR20, address indexed VAR21, uint256 VAR8);
event FUN4(address indexed VAR18, uint256 value);
constructor(
uint256 VAR22,
string memory VAR23,
string memory VAR24
) public {
VAR15 = VAR22 * 10 ** uint256(VAR14);
VAR16[msg.sender] = VAR15;
VAR12 = VAR23;
VAR13 = VAR24;
}
function FUN5(address VAR7, address VAR25, uint VAR8) internal {
require(VAR25 != address(0x0));
require(VAR16[VAR7] >= VAR8);
require(VAR16[VAR25] + VAR8 > VAR16[VAR25]);
uint VAR26 = VAR16[VAR7] + VAR16[VAR25];
VAR16[VAR7] -= VAR8;
VAR16[VAR25] += VAR8;
emit Transfer(VAR7, VAR25, VAR8);
assert(VAR16[VAR7] + VAR16[VAR25] == VAR26);
}
function transfer(address VAR25, uint256 VAR8) public returns (bool VAR27) {
FUN5(msg.sender, VAR25, VAR8);
return true;
}
function FUN6(address VAR7, address VAR25, uint256 VAR8) public returns (bool VAR27) {
require(VAR8 <= VAR17[VAR7][msg.sender]);
VAR17[VAR7][msg.sender] -= VAR8;
FUN5(VAR7, VAR25, VAR8);
return true;
}
function FUN7(address VAR21, uint256 VAR8) public
returns (bool VAR27) {
VAR17[msg.sender][VAR21] = VAR8;
emit FUN3(msg.sender, VAR21, VAR8);
return true;
}
function FUN8(address VAR21, uint256 VAR8, bytes memory VAR10)
public
returns (bool VAR27) {
tokenRecipient VAR28 = FUN9(VAR21);
if (FUN7(VAR21, VAR8)) {
VAR28.FUN2(msg.sender, VAR8, address(this), VAR10);
return true;
}
}
function FUN10(uint256 VAR8) public returns (bool VAR27) {
require(VAR16[msg.sender] >= VAR8);
VAR16[msg.sender] -= VAR8;
VAR15 -= VAR8;
emit FUN4(msg.sender, VAR8);
return true;
}
function FUN11(address VAR7, uint256 VAR8) public returns (bool VAR27) {
require(VAR16[VAR7] >= VAR8);
require(VAR8 <= VAR17[VAR7][msg.sender]);
VAR16[VAR7] -= VAR8;
VAR17[VAR7][msg.sender] -= VAR8;
VAR15 -= VAR8;
emit FUN4(VAR7, VAR8);
return true;
}
}
contract MyAdvancedToken is VAR2, VAR11 {
uint256 public VAR29;
uint256 public VAR30;
mapping (address => bool) public VAR31;
event FUN12(address VAR32, bool VAR33);
constructor(
uint256 VAR22,
string memory VAR23,
string memory VAR24
) FUN13(VAR22, VAR23, VAR24) public {}
function FUN5(address VAR7, address VAR25, uint VAR8) internal {
require (VAR25 != address(0x0));
require (VAR16[VAR7] >= VAR8);
require (VAR16[VAR25] + VAR8 >= VAR16[VAR25]);
require(!VAR31[VAR7]);
require(!VAR31[VAR25]);
VAR16[VAR7] -= VAR8;
VAR16[VAR25] += VAR8;
emit Transfer(VAR7, VAR25, VAR8);
}
function FUN14(address VAR32, uint256 VAR34) onlyOwner public {
VAR16[VAR32] += VAR34;
VAR15 += VAR34;
emit Transfer(address(0), address(this), VAR34);
emit Transfer(address(this), VAR32, VAR34);
}
function FUN15(address VAR32, bool VAR35) onlyOwner public {
VAR31[VAR32] = VAR35;
emit FUN12(VAR32, VAR35);
}
function FUN16(uint256 VAR36, uint256 VAR37) onlyOwner public {
VAR29 = VAR36;
VAR30 = VAR37;
}
function FUN17() payable public {
uint VAR38 = msg.value / VAR30;
FUN5(address(this), msg.sender, VAR38);
}
function FUN18(uint256 VAR38) public {
address VAR39 = address(this);
require(VAR39.VAR40 >= VAR38 * VAR29);
FUN5(msg.sender, address(this), VAR38);
msg.sender.transfer(VAR38 * VAR29);
}
}
0
---------------------------------
529 0x0531c928d539cbee3aa3bb3dae37ad507c750efc.sol
pragma VAR1 ^0.4.24;
contract VAR2{
function FUN1(address VAR3) {}
function FUN2(uint VAR4) {}
function FUN3() {}
}
contract VAR5{
address VAR3;
HelloEx VAR6;
constructor() public
{
VAR3 = msg.sender;
}
function FUN4(address VAR7) public
{
require(VAR3==msg.sender);
VAR6 = FUN5(VAR7);
}
function FUN6() payable public
{
require(VAR3==msg.sender);
VAR6.FUN1(address(this));
VAR6.FUN3();
}
function FUN7(uint VAR4) public
{
require(VAR3==msg.sender);
VAR6.FUN2(VAR4);
msg.sender.transfer(VAR4 * (1 VAR8));
}
function () payable public
{}
}
0
---------------------------------
530 0x0533fa1d4b6cb6fb0be65edfeaa03b11dcd172c4.sol
pragma VAR1 ^0.4.11;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) public constant returns (uint256);
function transfer(address VAR5, uint256 value) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7 {
address public VAR8;
event FUN2(address indexed VAR9, address indexed VAR10);
function FUN3() {
VAR8 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR8);
VAR11;
}
function FUN4(address VAR10) onlyOwner public {
require(VAR10 != address(0));
FUN2(VAR8, VAR10);
VAR8 = VAR10;
}
}
contract VAR12 {
function FUN5(uint VAR13, uint VAR14) internal returns (uint) {
uint VAR15 = VAR13 * VAR14;
assert(VAR13 == 0 || VAR15 / VAR13 == VAR14);
return VAR15;
}
function FUN6(uint VAR13, uint VAR14) internal returns (uint) {
assert(VAR14 > 0);
uint VAR15 = VAR13 / VAR14;
assert(VAR13 == VAR14 * VAR15 + VAR13 % VAR14);
return VAR15;
}
function FUN7(uint VAR13, uint VAR14) internal returns (uint) {
assert(VAR14 <= VAR13);
return VAR13 - VAR14;
}
function FUN8(uint VAR13, uint VAR14) internal returns (uint) {
uint VAR15 = VAR13 + VAR14;
assert(VAR15>=VAR13 && VAR15>=VAR14);
return VAR15;
}
function FUN9(uint64 VAR13, uint64 VAR14) internal constant returns (VAR16) {
return VAR13 >= VAR14 ? VAR13 : VAR14;
}
function FUN10(uint64 VAR13, uint64 VAR14) internal constant returns (VAR16) {
return VAR13 < VAR14 ? VAR13 : VAR14;
}
function FUN11(uint256 VAR13, uint256 VAR14) internal constant returns (uint256) {
return VAR13 >= VAR14 ? VAR13 : VAR14;
}
function FUN12(uint256 VAR13, uint256 VAR14) internal constant returns (uint256) {
return VAR13 < VAR14 ? VAR13 : VAR14;
}
}
contract ERC20 is VAR2 {
function FUN13(address VAR8, address VAR17) public constant returns (uint256);
function FUN14(address VAR6, address VAR5, uint256 value) public returns (bool);
function FUN15(address VAR17, uint256 value) public returns (bool);
event FUN16(address indexed VAR8, address indexed VAR17, uint256 value);
}
contract StandardToken is VAR18, VAR12 {
event FUN17(address VAR19, uint VAR20);
mapping(address => uint) VAR21;
mapping (address => mapping (address => uint)) VAR22;
function FUN18() public constant returns (bool VAR23) {
return true;
}
function transfer(address VAR24, uint VAR25) returns (bool VAR26) {
VAR21[msg.sender] = FUN7(VAR21[msg.sender], VAR25);
VAR21[VAR24] = FUN8(VAR21[VAR24], VAR25);
Transfer(msg.sender, VAR24, VAR25);
return true;
}
function FUN14(address VAR27, address VAR24, uint VAR25) returns (bool VAR26) {
uint VAR28 = VAR22[VAR27][msg.sender];
VAR21[VAR24] = FUN8(VAR21[VAR24], VAR25);
VAR21[VAR27] = FUN7(VAR21[VAR27], VAR25);
VAR22[VAR27][msg.sender] = FUN7(VAR28, VAR25);
Transfer(VAR27, VAR24, VAR25);
return true;
}
function FUN1(address VAR29) constant returns (uint VAR30) {
return VAR21[VAR29];
}
function FUN15(address VAR31, uint VAR25) returns (bool VAR26) {
if ((VAR25 != 0) && (VAR22[msg.sender][VAR31] != 0)) throw;
VAR22[msg.sender][VAR31] = VAR25;
FUN16(msg.sender, VAR31, VAR25);
return true;
}
function FUN13(address VAR29, address VAR31) constant returns (uint VAR32) {
return VAR22[VAR29][VAR31];
}
}
contract VAR33 {
uint public VAR34;
function FUN19() public constant returns (bool) {
return true;
}
function FUN20(address VAR27, uint256 VAR25) public;
}
contract UpgradeableToken is VAR35 {
address public VAR36;
UpgradeAgent public VAR37;
uint256 public VAR38;
enum VAR39 {VAR40, VAR41, VAR42, VAR43, VAR44}
event FUN21(address indexed VAR27, address indexed VAR24, uint256 VAR25);
event FUN22(address VAR45);
function FUN23(address VAR46) {
VAR36 = VAR46;
}
function FUN24(uint256 value) public {
UpgradeState VAR47 = FUN25();
if(!(VAR47 == VAR39.VAR43 || VAR47 == VAR39.VAR44)) {
throw;
}
if (value == 0) throw;
VAR21[msg.sender] = FUN7(VAR21[msg.sender], value);
VAR3 = FUN7(VAR3, value);
VAR38 = FUN8(VAR38, value);
VAR37.FUN20(msg.sender, value);
FUN21(msg.sender, VAR37, value);
}
function FUN26(address VAR45) external {
if(!FUN27()) {
throw;
}
if (VAR45 == 0x0) throw;
if (msg.sender != VAR36) throw;
if (FUN25() == VAR39.VAR44) throw;
VAR37 = FUN28(VAR45);
if(!VAR37.FUN19()) throw;
if (VAR37.FUN29() != VAR3) throw;
FUN22(VAR37);
}
function FUN25() public constant returns(VAR39) {
if(!FUN27()) return VAR39.VAR41;
else if(address(VAR37) == 0x00) return VAR39.VAR42;
else if(VAR38 == 0) return VAR39.VAR43;
else return VAR39.VAR44;
}
function FUN30(address VAR48) public {
if (VAR48 == 0x0) throw;
if (msg.sender != VAR36) throw;
VAR36 = VAR48;
}
function FUN27() public constant returns(bool) {
return true;
}
}
contract ReleasableToken is VAR18, VAR7 {
address public VAR49;
bool public VAR50 = false;
mapping (address => bool) public VAR51;
modifier FUN31(address VAR52) {
if(!VAR50) {
if(!VAR51[VAR52]) {
throw;
}
}
VAR11;
}
function FUN32(address VAR53) onlyOwner FUN33(false) public {
VAR49 = VAR53;
}
function FUN34(address VAR53, bool VAR47) onlyOwner FUN33(false) public {
VAR51[VAR53] = VAR47;
}
function FUN35() public VAR54 {
VAR50 = true;
}
modifier FUN33(bool VAR55) {
if(VAR55 != VAR50) {
throw;
}
VAR11;
}
modifier FUN36() {
if(msg.sender != VAR49) {
throw;
}
VAR11;
}
function transfer(address VAR24, uint VAR25) FUN31(msg.sender) returns (bool VAR26) {
return super.transfer(VAR24, VAR25);
}
function FUN14(address VAR27, address VAR24, uint VAR25) FUN31(VAR27) returns (bool VAR26) {
return super.FUN14(VAR27, VAR24, VAR25);
}
}
library VAR56 {
function FUN37(uint VAR13, uint VAR14) returns (uint) {
uint VAR15 = VAR13 * VAR14;
assert(VAR13 == 0 || VAR15 / VAR13 == VAR14);
return VAR15;
}
function FUN38(uint VAR13, uint VAR14) returns (uint) {
assert(VAR14 > 0);
uint VAR15 = VAR13 / VAR14;
assert(VAR13 == VAR14 * VAR15 + VAR13 % VAR14);
return VAR15;
}
function FUN39(uint VAR13, uint VAR14) returns (uint) {
assert(VAR14 <= VAR13);
return VAR13 - VAR14;
}
function FUN40(uint VAR13, uint VAR14) returns (uint) {
uint VAR15 = VAR13 + VAR14;
assert(VAR15>=VAR13);
return VAR15;
}
}
contract MintableTokenExt is VAR35, VAR7 {
using SafeMathLibExt for uint;
bool public VAR57 = false;
mapping (address => bool) public VAR58;
event FUN41(address VAR53, bool VAR47  );
struct VAR59 {
uint VAR60;
uint VAR61;
}
mapping (address => VAR59) public VAR62;
address[] public VAR63;
uint public VAR64 = 0;
function FUN42(address VAR53, uint VAR60, uint VAR61) onlyOwner {
VAR63.FUN43(VAR53);
VAR64++;
VAR62[VAR53] = FUN44({VAR60:VAR60, VAR61:VAR61});
}
function FUN45(address VAR53) constant returns (uint VAR60) {
return VAR62[VAR53].VAR60;
}
function FUN46(address VAR53) constant returns (uint VAR61) {
return VAR62[VAR53].VAR61;
}
function FUN47(address[] VAR65, uint[] VAR60, uint[] VAR61) onlyOwner {
for (uint VAR66 = 0; VAR66 < VAR65.VAR67; VAR66++) {
FUN42(VAR65[VAR66], VAR60[VAR66], VAR61[VAR66]);
}
}
function FUN48(address VAR19, uint VAR20) onlyMintAgent canMint public {
VAR3 = VAR3.FUN40(VAR20);
VAR21[VAR19] = VAR21[VAR19].FUN40(VAR20);
Transfer(0, VAR19, VAR20);
}
function FUN49(address VAR53, bool VAR47) onlyOwner canMint public {
VAR58[VAR53] = VAR47;
FUN41(VAR53, VAR47);
}
modifier FUN50() {
if(!VAR58[msg.sender]) {
throw;
}
VAR11;
}
modifier FUN51() {
if(VAR57) throw;
VAR11;
}
}
contract CrowdsaleTokenExt is VAR68, VAR69, VAR70 {
event FUN52(string VAR71, string VAR72);
string public VAR73;
string public VAR74;
uint public VAR75;
uint public VAR76;
function FUN53(string VAR77, string VAR78, uint VAR79, uint VAR80, bool VAR81, uint VAR82)
FUN23(msg.sender) {
VAR8 = msg.sender;
VAR73 = VAR77;
VAR74 = VAR78;
VAR3 = VAR79;
VAR75 = VAR80;
VAR76 = VAR82;
VAR21[VAR8] = VAR3;
if(VAR3 > 0) {
FUN17(VAR8, VAR3);
}
if(!VAR81) {
VAR57 = true;
if(VAR3 == 0) {
throw;
}
}
}
function FUN35() public VAR54 {
VAR57 = true;
super.FUN35();
}
function FUN27() public constant returns(bool) {
return VAR50 && super.FUN27();
}
function FUN54(string VAR77, string VAR78) onlyOwner {
VAR73 = VAR77;
VAR74 = VAR78;
FUN52(VAR73, VAR74);
}
}
0
---------------------------------
531 0x053b278e22e6119f1e333b10bd6d0ad3d7a8cd20.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
address public VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
function FUN2() public {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR6;
}
function FUN3(address VAR5) public onlyOwner {
require(VAR5 != address(0));
FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
contract ReturnVestingRegistry is VAR2 {
mapping (address => address) public VAR7;
function FUN4(address VAR8, address VAR9) onlyOwner public {
require(VAR8 != 0);
VAR7[VAR8] = VAR9;
}
}
contract VAR10 {
function FUN5() public view returns (uint256);
function FUN6(address VAR11) public view returns (uint256);
function transfer(address VAR9, uint256 value) public returns (bool);
event Transfer(address indexed VAR8, address indexed VAR9, uint256 value);
}
contract ERC20 is VAR10 {
function FUN7(address VAR3, address VAR12) public view returns (uint256);
function FUN8(address VAR8, address VAR9, uint256 value) public returns (bool);
function FUN9(address VAR12, uint256 value) public returns (bool);
event FUN10(address indexed VAR3, address indexed VAR12, uint256 value);
}
contract TerraformReserve is VAR2 {
mapping (address => uint256) public VAR13;
uint public VAR14;
ERC20 public VAR15;
address public VAR16;
bool public VAR17;
event FUN11(address VAR18, uint VAR19);
event FUN12(address VAR20);
event FUN13(address VAR18, uint value, bytes VAR21);
event FUN14(bool VAR22);
function FUN15(address VAR23) {
require(VAR23 != 0);
VAR15 = FUN16(VAR23);
VAR17 = true;
}
function FUN17(address VAR24, uint256 VAR19) public {
require(VAR17);
require(VAR19 >= 1000 * 1e18);
require(VAR15.FUN8(VAR24, this, VAR19));
VAR13[VAR24] += VAR19;
VAR14 += VAR19;
FUN11(VAR24, VAR19);
}
function FUN18(bool VAR22) public onlyOwner {
VAR17 = VAR22;
FUN14(VAR17);
}
function FUN19(address VAR20) public onlyOwner {
VAR16 = VAR20;
VAR15.FUN9(VAR16, VAR14);
FUN12(VAR20);
}
function () public payable {
revert();
}
}
library VAR25 {
function FUN20(uint64 VAR26, uint64 VAR27) internal pure returns (VAR28) {
return VAR26 >= VAR27 ? VAR26 : VAR27;
}
function FUN21(uint64 VAR26, uint64 VAR27) internal pure returns (VAR28) {
return VAR26 < VAR27 ? VAR26 : VAR27;
}
function FUN22(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
return VAR26 >= VAR27 ? VAR26 : VAR27;
}
function FUN23(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
return VAR26 < VAR27 ? VAR26 : VAR27;
}
}
library VAR29 {
function FUN24(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
if (VAR26 == 0) {
return 0;
}
uint256 VAR30 = VAR26 * VAR27;
assert(VAR30 / VAR26 == VAR27);
return VAR30;
}
function FUN25(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
uint256 VAR30 = VAR26 / VAR27;
return VAR30;
}
function FUN26(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
assert(VAR27 <= VAR26);
return VAR26 - VAR27;
}
function FUN27(uint256 VAR26, uint256 VAR27) internal pure returns (uint256) {
uint256 VAR30 = VAR26 + VAR27;
assert(VAR30 >= VAR26);
return VAR30;
}
}
library VAR31 {
function FUN28(ERC20Basic VAR32, address VAR9, uint256 value) internal {
assert(VAR32.transfer(VAR9, value));
}
function FUN29(ERC20 VAR32, address VAR8, address VAR9, uint256 value) internal {
assert(VAR32.FUN8(VAR8, VAR9, value));
}
function FUN30(ERC20 VAR32, address VAR12, uint256 value) internal {
assert(VAR32.FUN9(VAR12, value));
}
}
contract TokenVesting is VAR2 {
using SafeMath for uint256;
using SafeERC20 for VAR33;
event FUN31(uint256 VAR34);
event FUN32();
address public VAR35;
uint256 public VAR36;
uint256 public VAR37;
uint256 public VAR38;
bool public VAR39;
bool public VAR40;
uint256 public VAR41;
ERC20 public VAR32;
function FUN33(
address VAR42,
uint256 VAR43,
uint256 VAR44,
uint256 VAR45,
bool    VAR46,
address VAR23
) {
require(VAR42 != 0x0);
require(VAR44 <= VAR45);
VAR35 = VAR42;
VAR37       = VAR43;
VAR36       = VAR43.FUN27(VAR44);
VAR38    = VAR45;
VAR39   = VAR46;
VAR32       = FUN16(VAR23);
}
modifier FUN34() {
require(msg.sender == VAR35);
VAR6;
}
function FUN35(address VAR20) onlyBeneficiary public {
require(VAR20 != 0);
VAR35 = VAR20;
}
function FUN36() onlyBeneficiary public {
require(VAR47 >= VAR36);
FUN37(VAR35);
}
function FUN38(address VAR20) onlyBeneficiary public {
require(VAR47 >= VAR36);
FUN37(VAR20);
}
function FUN37(address VAR20) internal {
uint256 VAR48 = FUN39();
VAR41 = VAR41.FUN27(VAR48);
VAR32.FUN28(VAR20, VAR48);
FUN31(VAR41);
}
function FUN40() onlyOwner public {
require(VAR39);
require(!VAR40);
FUN37(VAR35);
VAR32.FUN28(VAR3, VAR32.FUN6(this));
VAR40 = true;
FUN32();
}
function FUN39() public constant returns (uint256) {
return FUN41().FUN26(VAR41);
}
function FUN41() public constant returns (uint256) {
uint256 VAR49 = VAR32.FUN6(this);
uint256 VAR50 = VAR49.FUN27(VAR41);
if (VAR47 < VAR36) {
return 0;
} else if (VAR47 >= VAR37.FUN27(VAR38) || VAR40) {
return VAR50;
} else {
return VAR50.FUN24(VAR47.FUN26(VAR37)).FUN25(VAR38);
}
}
function FUN42(ERC20 VAR23, uint256 VAR34) onlyOwner {
require(VAR23 != VAR32);
VAR23.transfer(VAR3, VAR34);
}
}
contract DecentralandVesting is VAR51 {
using SafeERC20 for VAR33;
event FUN43(uint256 VAR34);
ReturnVestingRegistry public VAR52;
TerraformReserve public VAR53;
function FUN44(
address               VAR42,
uint256               VAR43,
uint256               VAR44,
uint256               VAR45,
bool                  VAR46,
ERC20                 VAR23,
ReturnVestingRegistry VAR54,
TerraformReserve      VAR55
)
FUN33(VAR42, VAR43, VAR44, VAR45, VAR46, VAR23)
{
VAR52    = FUN45(VAR54);
VAR53 = FUN15(VAR55);
}
function FUN17(uint256 VAR34) onlyBeneficiary public {
require(VAR32.FUN7(VAR35, VAR53) >= VAR34);
require(VAR34 <= VAR32.FUN6(this));
require(VAR52.FUN46(VAR35) == address(this));
VAR32.FUN28(VAR35, VAR34);
VAR53.FUN17(VAR35, VAR34);
FUN43(VAR34);
}
}
0
---------------------------------
532 0x054d421c47818b972e2c50bf3d09fb3354ab87be.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29462400;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x7748186946C6e3eF831365D9022A9247e2B98473;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
533 0x054df44d9bf67e87e09de919086bf12633f6bcf5.sol
pragma VAR1 ^0.4.18;
contract VAR2 {
function FUN1() public pure returns (bool);
function FUN2(uint VAR3) external;
function FUN3(uint VAR4) external;
function FUN4(uint VAR3) external;
function FUN5(uint VAR3) external;
function FUN6(uint VAR3) external;
function FUN7() external;
function FUN8() external;
function FUN9() external;
}
contract VAR5{
uint256 constant VAR6 = 5000000;
uint256 constant VAR7 = 45 VAR8;
uint256 constant VAR9  = 1527476400;
uint256 constant VAR10 = 1528081200;
uint256 constant VAR11  = 1528686000;
uint256 constant VAR12 = 1528945200;
DataSourceInterface public VAR13;
address public VAR14;
address public VAR15;
uint256 public VAR16 = 0;
uint256 public VAR17 = 0;
uint32 public VAR18 = 0;
uint256 public VAR19 = 0;
uint32 public VAR20 = 0;
uint32 public VAR21 = 0;
uint32 public VAR22 = 0;
uint256 public VAR23 = 500000000;
uint32 public VAR24 = 0;
uint32 public VAR25 = 0;
uint256 public VAR26 = 0;
uint256 public VAR27 = 0;
uint256 public VAR28 = 0;
enum VAR29 { VAR30, VAR31, VAR32, VAR33, VAR34 }
enum VAR35 { VAR36, VAR37, VAR38, VAR39, VAR40, VAR41, VAR42 }
struct VAR43 {
uint192 VAR44;
uint192 VAR45;
uint160 VAR46;
uint64 VAR47;
uint32  VAR48;
}
struct VAR49{
uint8 VAR50;
uint8 VAR51;
}
struct VAR52{
uint8[16] VAR53;
mapping (uint8 => bool) VAR54;
mapping (uint8 => VAR29) VAR55;
uint8[4] VAR56;
}
struct VAR57 {
uint16 VAR58;
uint16 VAR59;
}
VAR43[] VAR60;
VAR49[48] VAR61;
BracketPhase VAR62;
Extras VAR63;
uint256[] VAR64;
uint256[] VAR65;
pointsValidationState public VAR66 = VAR35.VAR36;
mapping (address => uint256[]) public VAR67;
mapping (uint256 => address) public VAR68;
mapping (uint256 => address) public VAR69;
mapping (uint256 => uint256) public VAR70;
mapping (uint256 => uint16) public VAR71;
event FUN10(address VAR72, uint256 VAR73, Token VAR74);
event FUN11(uint8[] VAR75);
event FUN12(uint8 VAR75);
event FUN13(uint8 VAR75, uint8 VAR76);
}
contract VAR77 {
event FUN14(address VAR78, address VAR79, uint256 VAR73);
event FUN15(address VAR80, address VAR81, uint256 VAR73);
function FUN16() public view returns (string);
function FUN17() public view returns (string);
function FUN18() public view returns (uint256 VAR82);
function FUN19(address VAR83) public view returns (uint256 VAR84);
function FUN20(uint256 VAR85) external view returns (address VAR80);
function FUN21(address VAR86, uint256 VAR85) external;
function transfer(address VAR86, uint256 VAR85) external;
function FUN22(address VAR87, address VAR86, uint256 VAR85) external;
function FUN23(address VAR83) external view returns (uint256[] VAR88);
}
contract AccessControlLayer is VAR5{
bool public VAR89 = false;
bool public VAR90 = false;
bool public VAR91 = true;
modifier onlyAdmin() {
require(msg.sender == VAR15);
VAR92;
}
modifier FUN24() {
require(!VAR89);
VAR92;
}
modifier FUN25() {
require(VAR89);
VAR92;
}
modifier FUN26() {
require((VAR17 != 0) && VAR93 >= (VAR17 + (15 VAR94)));
VAR92;
}
modifier FUN27() {
require(VAR90);
VAR92;
}
modifier FUN28(pointsValidationState VAR95){
require(VAR66 == VAR95);
VAR92;
}
function FUN29(address VAR96) external onlyAdmin {
require(VAR96 != address(0));
VAR15 = VAR96;
}
function FUN30(bool VAR95) external onlyAdmin {
VAR89 = VAR95;
}
function FUN31(bool VAR95) external onlyAdmin {
VAR89 = VAR95;
VAR90 = VAR95;
if(VAR90 == true)
VAR28 = VAR93;
}
}
contract CryptocupToken is VAR97, VAR77 {
function FUN32(address VAR98, uint256 VAR73) internal view returns (bool){
return VAR68[VAR73] == VAR98;
}
function FUN33(address VAR98, uint256 VAR73) internal view returns (bool) {
return VAR69[VAR73] == VAR98;
}
function FUN34(address VAR99, address VAR100, uint256 VAR73) internal {
require(VAR67[VAR100].VAR101 < 100);
require(VAR66 == VAR35.VAR36);
VAR67[VAR100].FUN35(VAR73);
VAR68[VAR73] = VAR100;
uint256[] storage VAR102 = VAR67[VAR99];
for (uint256 VAR103 = 0; VAR103 < VAR102.VAR101; VAR103++){
if(VAR102[VAR103] == VAR73){
VAR102[VAR103] = VAR102[VAR102.VAR101-1];
}
}
delete VAR102[VAR102.VAR101-1];
VAR102.VAR101--;
delete VAR69[VAR73];
}
function FUN36(uint256 VAR73, address VAR98) internal {
VAR69[VAR73] = VAR98;
}
function FUN37(address VAR104, uint256 VAR73) internal{
VAR67[VAR104].FUN35(VAR73);
VAR68[VAR73] = VAR104;
}
function FUN16() public view returns (string){
return "";
}
function FUN17() public view returns (string){
return "";
}
function FUN19(address VAR98) public view returns (uint256 VAR105) {
return VAR67[VAR98].VAR101;
}
function transfer(address VAR100,uint256 VAR73) external VAR106 {
require(VAR100 != address(0));
require(VAR100 != address(this));
require(FUN32(msg.sender, VAR73));
FUN34(msg.sender, VAR100, VAR73);
FUN14(msg.sender, VAR100, VAR73);
}
function FUN22(address VAR99, address VAR100, uint256 VAR73) external VAR106 {
require(VAR100 != address(0));
require(VAR100 != address(this));
require(FUN33(msg.sender, VAR73));
require(FUN32(VAR99, VAR73));
FUN34(VAR99, VAR100, VAR73);
FUN14(VAR99, VAR100, VAR73);
}
function FUN21( address VAR100, uint256 VAR73) external VAR106 {
require(VAR100 != address(0));
require(FUN32(msg.sender, VAR73));
FUN36(VAR73, VAR100);
FUN15(msg.sender, VAR100, VAR73);
}
function FUN18() public view returns (uint) {
return VAR60.VAR101;
}
function FUN20(uint256 VAR73) external view returns (address VAR104) {
VAR104 = VAR68[VAR73];
require(VAR104 != address(0));
}
function FUN23(address VAR104) external view returns(uint256[] VAR88) {
VAR88 = VAR67[VAR104];
}
}
library VAR107 {
function FUN38(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
if (VAR108 == 0) {
return 0;
}
uint256 VAR110 = VAR108 * VAR109;
assert(VAR110 / VAR108 == VAR109);
return VAR110;
}
function FUN39(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
uint256 VAR110 = VAR108 / VAR109;
return VAR110;
}
function FUN40(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
assert(VAR109 <= VAR108);
return VAR108 - VAR109;
}
function FUN41(uint256 VAR108, uint256 VAR109) internal pure returns (uint256) {
uint256 VAR110 = VAR108 + VAR109;
assert(VAR110 >= VAR108);
return VAR110;
}
}
contract GameLogicLayer is VAR111{
using SafeMath for *;
uint8 VAR112 = 15;
uint160 VAR113 = 31;
uint16 VAR114 = 65535;
uint16 private VAR115;
uint16 private VAR116;
uint16[] private VAR117 = [1,1,1,1,1,1,1,1,1,1,5,5,10,20,50,100,100,200,500,1500,2500];
VAR118[] private VAR119;
event FUN42(uint VAR3, uint8 VAR75, uint8 VAR76);
event FUN43(uint VAR120, uint8 VAR75);
event FUN44(uint VAR3, uint8 VAR75);
event FUN45(uint VAR120, uint8[4] VAR75);
event FUN46(uint VAR120, uint16 VAR75);
function FUN47(uint VAR3) external onlyAdmin{
VAR13.FUN2(VAR3);
}
function FUN48(uint VAR4) external onlyAdmin{
VAR13.FUN3(VAR4);
}
function FUN49(uint VAR3) external onlyAdmin{
VAR13.FUN4(VAR3);
}
function FUN50(uint VAR3) external onlyAdmin{
VAR13.FUN5(VAR3);
}
function FUN51(uint VAR3) external onlyAdmin{
VAR13.FUN6(VAR3);
}
function FUN52() external onlyAdmin{
VAR13.FUN7();
}
function FUN53() external onlyAdmin{
VAR13.FUN8();
}
function FUN54() external onlyAdmin{
VAR13.FUN9();
}
function FUN55(uint VAR3, uint8 VAR75, uint8 VAR76) public {
require (msg.sender == VAR14);
require (VAR3 >= 0 && VAR3 <= 47);
VAR61[VAR3].VAR50 = VAR75;
VAR61[VAR3].VAR51 = VAR76;
FUN42(VAR3, VAR75, VAR76);
}
function FUN56(uint VAR120, uint8 VAR75) public {
require (msg.sender == VAR14);
VAR62.VAR53[VAR120] = VAR75;
VAR62.VAR54[VAR75] = true;
FUN43(VAR120, VAR75);
}
function FUN57(uint VAR3, uint8 VAR75) public {
require (msg.sender == VAR14);
teamState VAR95 = VAR62.VAR55[VAR75];
if (VAR3 >= 48 && VAR3 <= 55){
if (VAR95 < VAR29.VAR31)
VAR62.VAR55[VAR75] = VAR29.VAR31;
} else if (VAR3 >= 56 && VAR3 <= 59){
if (VAR95 < VAR29.VAR32)
VAR62.VAR55[VAR75] = VAR29.VAR32;
} else if (VAR3 == 60 || VAR3 == 61){
if (VAR95 < VAR29.VAR33)
VAR62.VAR55[VAR75] = VAR29.VAR33;
}
FUN44(VAR3, VAR75);
}
function FUN58(uint VAR120, uint8[4] VAR75) public {
require (msg.sender == VAR14);
uint256 VAR103;
for(VAR103 = 0; VAR103 < 4; VAR103++){
VAR62.VAR56[VAR103] = VAR75[VAR103];
}
FUN45(VAR120, VAR75);
}
function FUN59(uint VAR120, uint16 VAR75) public {
require (msg.sender == VAR14);
if (VAR120 == 101){
VAR63.VAR58 = VAR75;
} else if (VAR120 == 102){
VAR63.VAR59 = VAR75;
}
FUN46(VAR120, VAR75);
}
function FUN60(uint8 VAR121, uint8 VAR122, uint8 VAR123, uint8 VAR124) internal pure returns(bool){
int8 VAR125 = FUN61(VAR121 - VAR122);
int8 VAR126 = FUN61(VAR123 - VAR124);
return (VAR125 > 0 && VAR126 > 0) || (VAR125 < 0 && VAR126 < 0) || (VAR125 == 0 && VAR126 == 0);
}
function FUN62 (uint256 VAR127, uint192 VAR128) internal view returns(uint16 VAR129) {
uint8 VAR123 = uint8(VAR128 & VAR112);
uint8 VAR124 = uint8((VAR128 >> 4) & VAR112);
uint8 VAR50 = VAR61[VAR127].VAR50;
uint8 VAR51 = VAR61[VAR127].VAR51;
if (VAR50 == VAR123 && VAR51 == VAR124){
VAR129 += 10;
} else {
if (FUN60(VAR50, VAR51, VAR123, VAR124)){
VAR129 += 3;
}
}
}
function FUN63 (uint160 VAR46) internal view returns(uint16 VAR130) {
uint8[3] memory VAR131;
for (uint VAR103 = 0; VAR103 <= 2; VAR103++){
VAR46 = VAR46 >> 5;
VAR131[2-VAR103] = uint8(VAR46 & VAR113);
}
if (VAR131[0] == VAR62.VAR56[0]){
VAR130 += 100;
}
if (VAR131[2] == VAR62.VAR56[2]){
VAR130 += 25;
}
if (VAR131[0] == VAR62.VAR56[1]){
VAR130 += 50;
}
if (VAR131[1] == VAR62.VAR56[0] || VAR131[1] == VAR62.VAR56[1]){
VAR130 += 50;
}
}
function FUN64(uint8 VAR132, teamState VAR133, uint160 VAR46) internal view returns(uint16 VAR134){
uint8 VAR135;
for (uint VAR103 = 0; VAR103 < VAR132; VAR103++){
VAR135 = uint8(VAR46 & VAR113);
if (uint(VAR62.VAR55[VAR135]) >= uint(VAR133) ) {
VAR134+=60;
}
VAR46 = VAR46 >> 5;
}
}
function FUN65(uint160 VAR46) internal view returns(uint16 VAR136){
uint8 VAR135;
for (uint256 VAR103 = 0; VAR103 <= 15; VAR103++){
VAR135 = uint8(VAR46 & VAR113);
if (VAR135 == VAR62.VAR53[15-VAR103]){
VAR136+=30;
} else if (VAR62.VAR54[VAR135]){
VAR136+=25;
}
VAR46 = VAR46 >> 5;
}
}
function FUN66(uint32 VAR137) internal view returns(uint16 VAR138){
uint16 VAR59 = uint16(VAR137 & VAR114);
VAR137 = VAR137 >> 16;
uint16 VAR58 = uint16(VAR137);
if (VAR59 == VAR63.VAR59){
VAR138+=20;
}
if (VAR58 == VAR63.VAR58){
VAR138+=20;
}
}
function FUN67 (Token memory VAR139) internal view returns(uint16 VAR140){
uint192 VAR141 = VAR139.VAR44;
for (uint256 VAR103 = 0; VAR103 <= 23; VAR103++){
VAR140+=FUN62(23-VAR103, VAR141);
VAR141 = VAR141 >> 8;
}
uint192 VAR142 = VAR139.VAR45;
for (VAR103 = 0; VAR103 <= 23; VAR103++){
VAR140+=FUN62(47-VAR103, VAR142);
VAR142 = VAR142 >> 8;
}
uint160 VAR143 = VAR139.VAR46;
VAR140+=FUN63(VAR143);
VAR143 = VAR143 >> 20;
VAR140+=FUN64(4, VAR29.VAR32, VAR143);
VAR143 = VAR143 >> 20;
VAR140+=FUN64(8, VAR29.VAR31, VAR143);
VAR143 = VAR143 >> 40;
VAR140+=FUN65(VAR143);
VAR140+=FUN66(VAR139.VAR48);
}
function FUN68(uint32 VAR144) external{
require (VAR17 == 0);
require(VAR144 + VAR20 <= VAR60.VAR101);
for (uint256 VAR103 = VAR18; VAR103 < (VAR18 + VAR144); VAR103++) {
uint16 VAR140 = FUN67(VAR60[VAR103]);
VAR71[VAR103] = VAR140;
if(VAR65.VAR101 == 0 || VAR140 <= VAR23){
if(VAR65.VAR101 != 0 && VAR140 < VAR23){
VAR65.VAR101 = 0;
}
if(VAR65.VAR101 < 100){
VAR23 = VAR140;
VAR65.FUN35(VAR103);
}
}
}
VAR18 += VAR144;
}
function FUN69 () internal {
if(VAR60.VAR101 < 101){
VAR119 = [289700, 189700, 120000, 92500, 75000, 62500, 52500, 42500, 40000, 35600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
VAR115 = 0;
VAR116 = 10;
}else if(VAR60.VAR101 < 201){
VAR119 = [265500, 165500, 105500, 75500, 63000, 48000, 35500, 20500, 20000, 19500, 18500, 17800, 0, 0, 0, 0, 0, 0, 0, 0, 0];
VAR115 = 0;
VAR116 = 20;
}else if(VAR60.VAR101 < 301){
VAR119 = [260700, 155700, 100700, 70900, 60700, 45700, 35500, 20500, 17900, 12500, 11500, 11000, 10670, 0, 0, 0, 0, 0, 0, 0, 0];
VAR115 = 0;
VAR116 = 30;
}else if(VAR60.VAR101 < 501){
VAR119 = [238600, 138600, 88800, 63800, 53800, 43800, 33800, 18800, 17500, 12500, 9500, 7500, 7100, 6700, 0, 0, 0, 0, 0, 0, 0];
VAR115 = 0;
VAR116 = 50;
}else if(VAR60.VAR101 < 1001){
VAR119 = [218300, 122300, 72300, 52400, 43900, 33900, 23900, 16000, 13000, 10000, 9000, 7000, 5000, 4000, 3600, 0, 0, 0, 0, 0, 0];
VAR115 = 4000;
VAR116 = 100;
}else if(VAR60.VAR101 < 2001){
VAR119 = [204500, 114000, 64000, 44100, 35700, 26700, 22000, 15000, 11000, 9500, 8500, 6500, 4600, 2500, 2000, 1800, 0, 0, 0, 0, 0];
VAR115 = 2500;
VAR116 = 200;
}else if(VAR60.VAR101 < 3001){
VAR119 = [189200, 104800, 53900, 34900, 29300, 19300, 15300, 14000, 10500, 8300, 8000, 6000, 3800, 2500, 2000, 1500, 1100, 0, 0, 0, 0];
VAR115 = 2500;
VAR116 = 300;
}else if(VAR60.VAR101 < 5001){
VAR119 = [178000, 100500, 47400, 30400, 24700, 15500, 15000, 12000, 10200, 7800, 7400, 5500, 3300, 2000, 1500, 1200, 900, 670, 0, 0, 0];
VAR115 = 2000;
VAR116 = 500;
}else if(VAR60.VAR101 < 10001){
VAR119 = [157600, 86500, 39000, 23100, 18900, 15000, 14000, 11000, 9300, 6100, 6000, 5000, 3800, 1500, 1100, 900, 700, 500, 360, 0, 0];
VAR115 = 1500;
VAR116 = 1000;
}else if(VAR60.VAR101 < 25001){
VAR119 = [132500, 70200, 31300, 18500, 17500, 14000, 13500, 10500, 7500, 5500, 5000, 4000, 3000, 1000, 900, 700, 600, 400, 200, 152, 0];
VAR115 = 1000;
VAR116 = 2500;
} else {
VAR119 = [120000, 63000,  27000, 18800, 17300, 13700, 13000, 10000, 6300, 5000, 4500, 3900, 2500, 900, 800, 600, 500, 350, 150, 100, 70];
VAR115 = 900;
VAR116 = 5000;
}
}
function FUN70(uint256 VAR73) external onlyAdmin{
require(VAR73 < VAR60.VAR101);
require(VAR66 == VAR35.VAR36 || VAR66 == VAR35.VAR37);
VAR19 = VAR73;
VAR66 = VAR35.VAR37;
VAR20 = 0;
VAR18 = 0;
VAR21 = 0;
FUN69();
}
function FUN71(uint32 VAR144) external onlyAdmin FUN28(VAR35.VAR37){
require(VAR144 + VAR20 <= VAR60.VAR101);
uint256 VAR140 = VAR71[VAR19];
for(uint256 VAR103 = VAR20; VAR103 < VAR20 + VAR144; VAR103++){
if(VAR71[VAR103] > VAR140 ||
(VAR71[VAR103] == VAR140 && VAR103 <= VAR19)){
VAR21++;
}
}
VAR20 += VAR144;
if(VAR20 == VAR60.VAR101){
require(VAR116 == VAR21);
VAR66 = VAR35.VAR38;
}
}
function FUN72(VAR118[] VAR145) external onlyAdmin FUN28(VAR35.VAR38){
require(VAR145.VAR101 + VAR64.VAR101 <= VAR21);
for(uint256 VAR103=0;VAR103 < VAR145.VAR101-1;VAR103++){
uint256 VAR120 = VAR145[VAR103];
uint256 VAR146 = VAR145[VAR103+1];
require(VAR71[VAR120] > VAR71[VAR146] ||
(VAR71[VAR120] == VAR71[VAR146] &&  VAR120 < VAR146));
}
if(VAR64.VAR101 != 0){
uint256 VAR147 = VAR64[VAR64.VAR101-1];
uint256 VAR148 = VAR145[0];
require(VAR71[VAR147] > VAR71[VAR148] ||
(VAR71[VAR147] == VAR71[VAR148] && VAR147 < VAR148));
}
for(uint256 VAR149=0;VAR149 < VAR145.VAR101;VAR149++){
VAR64.FUN35(VAR145[VAR149]);
}
if(VAR64.VAR101 == VAR21){
require(VAR64[VAR64.VAR101-1] == VAR19);
VAR66 = VAR35.VAR39;
}
}
function FUN73(uint256 VAR150) external onlyAdmin FUN28(VAR35.VAR38){
VAR64.VAR101 = VAR150;
}
function FUN74() external onlyAdmin FUN28(VAR35.VAR39){
uint256 VAR151 = 0;
uint[] memory VAR152 = new uint[](30);
uint16 VAR153 = 0;
uint256 VAR154;
uint256 VAR155;
uint256 VAR156;
uint32 VAR157 = 0;
uint256 VAR158 = 13;
if(VAR60.VAR101 < 201){
VAR158 = 10;
}
while(VAR24 < VAR158){
uint256 VAR159 = VAR117[VAR24];
while(VAR159 > 0){
VAR154 = VAR64[VAR157];
VAR155 = VAR71[VAR154];
VAR159--;
if(VAR159 == 0 && VAR24 == VAR158 - 1){
if(VAR155 == VAR156){
VAR151 += VAR119[VAR24];
VAR152[VAR153] = VAR154;
VAR153++;
}else{
VAR70[VAR154] = VAR119[VAR24];
}
}
if(VAR157 != 0 && (VAR155 != VAR156 || (VAR159 == 0 && VAR24 == VAR158 - 1))){
for(uint256 VAR103=0;VAR103 < VAR153;VAR103++){
VAR70[VAR152[VAR103]] = VAR151.FUN39(VAR153);
}
VAR151 = 0;
VAR152 = new uint[](30);
VAR153 = 0;
}
VAR151 += VAR119[VAR24];
VAR152[VAR153] = VAR154;
VAR153++;
VAR157++;
VAR156 = VAR155;
}
VAR24++;
}
VAR66 = VAR35.VAR40;
VAR25 = VAR157;
}
function FUN75(uint32 VAR144) external onlyAdmin FUN28(VAR35.VAR40){
require(VAR25 + VAR144 <= VAR21);
uint16 VAR160 = VAR117[VAR24];
for(uint256 VAR103 = 0; VAR103 < VAR144; VAR103++){
if (VAR160 == 0){
VAR24++;
VAR160 = VAR117[VAR24];
}
uint256 VAR73 = VAR64[VAR103 + VAR25];
VAR70[VAR73] = VAR119[VAR24];
VAR160--;
}
VAR25 += VAR144;
VAR117[VAR24] = VAR160;
if(VAR25 == VAR21){
VAR66 = VAR35.VAR41;
return;
}
}
function FUN76() external onlyAdmin FUN28(VAR35.VAR41){
for(uint256 VAR149 = 0;VAR149 < VAR65.VAR101;VAR149++){
uint256 VAR73 = VAR65[VAR149];
VAR70[VAR73] += VAR115.FUN39(VAR65.VAR101);
}
uint256 VAR84 = address(this).VAR84;
VAR27 = VAR84.FUN38(25).FUN39(100);
VAR26 = VAR84.FUN38(75).FUN39(100);
VAR66 = VAR35.VAR42;
VAR17 = VAR93;
}
}
contract CoreLayer is VAR161 {
function FUN77() public {
VAR15 = msg.sender;
VAR16 = VAR93;
}
function() external payable {
require(msg.sender == VAR15);
}
function FUN78() public pure returns (bool){
return true;
}
function FUN79(uint192 VAR44, uint192 VAR45, uint160 VAR46, uint32 VAR48) external payable VAR106 {
Token memory VAR74 = FUN80({
VAR44: VAR44,
VAR45: VAR45,
VAR46: VAR46,
VAR47: FUN81(VAR93),
VAR48: VAR48
});
require(msg.value >= FUN82());
require(msg.sender != address(0));
require(VAR60.VAR101 < VAR6);
require(VAR67[msg.sender].VAR101 < 100);
require(VAR93 < VAR12);
uint256 VAR73 = VAR60.FUN35(VAR74) - 1;
require(VAR73 == uint256(FUN83(VAR73)));
FUN37(msg.sender, VAR73);
FUN10(msg.sender, VAR73, VAR74);
}
function FUN84(uint256 VAR73) external view returns (uint192 VAR44, uint192 VAR45, uint160 VAR46, uint64 VAR47, uint32 VAR48) {
Token storage VAR74 = VAR60[VAR73];
VAR44 = VAR74.VAR44;
VAR45 = VAR74.VAR45;
VAR46 = VAR74.VAR46;
VAR47 = VAR74.VAR47;
VAR48 = VAR74.VAR48;
}
function FUN85() external onlyAdmin {
VAR15.transfer(VAR27);
VAR27 = 0;
}
function FUN86() external FUN28(VAR35.VAR42){
uint256 VAR162 = 0;
uint256[] memory VAR163 = VAR67[msg.sender];
for(uint256 VAR103 = 0;VAR103 < VAR163.VAR101; VAR103++){
VAR162 += VAR70[VAR163[VAR103]];
VAR70[VAR163[VAR103]] = 0;
}
require(VAR162 > 0);
msg.sender.transfer((VAR26.FUN38(VAR162)).FUN39(1000000));
}
function FUN82() internal view returns(uint256 VAR164){
if ( VAR93 >= VAR11){
VAR164 = (150 VAR8);
} else if (VAR93 >= VAR10) {
VAR164 = (110 VAR8);
} else if (VAR93 >= VAR9) {
VAR164 = (75 VAR8);
} else {
VAR164 = VAR7;
}
require(VAR164 >= VAR7 && VAR164 <= (200 VAR8));
}
function FUN87(address VAR165) external onlyAdmin {
DataSourceInterface VAR110 = FUN88(VAR165);
require(VAR110.FUN1());
VAR13 = VAR110;
VAR14 = VAR165;
}
function FUN89(uint VAR166) external view returns(uint8 VAR108, uint8 VAR109){
VAR108 = VAR61[VAR166].VAR50;
VAR109 = VAR61[VAR166].VAR51;
}
function FUN90() external view returns(uint8[16] VAR108){
VAR108 = VAR62.VAR53;
}
function FUN91(uint8 VAR166) external view returns(teamState VAR108){
VAR108 = VAR62.VAR55[VAR166];
}
function FUN92() external view returns(uint8[4] VAR108){
VAR108 = VAR62.VAR56;
}
function FUN93() external view returns(uint16 VAR108, uint16 VAR109){
VAR108 = VAR63.VAR58;
VAR109 = VAR63.VAR59;
}
function FUN94() external VAR167{
uint256 VAR84 = VAR7 * VAR67[msg.sender].VAR101;
delete VAR67[msg.sender];
msg.sender.transfer(VAR84);
}
function FUN95() external onlyAdmin VAR168{
uint256 VAR84 = address(this).VAR84;
VAR15.transfer(VAR84);
}
function FUN96() external hasFinalized onlyAdmin{
require(VAR28 != 0 &&  VAR93 >= VAR28 + 10 VAR94 );
msg.sender.transfer(address(this).VAR84);
}
}
0
---------------------------------
534 0x0553fe39cbccdd6110e1c77b95a99faef8050604.sol
pragma VAR1 ^0.4.18;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
function FUN5(address VAR7) public constant returns (uint256 VAR8);
function transfer(address VAR9, uint256 VAR10) public returns (bool VAR11);
}
contract VAR12 {
address public VAR13;
event FUN6(address indexed VAR14, address indexed VAR15);
constructor() public{
VAR13 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR13);
VAR16;
}
function FUN7(address VAR15) onlyOwner public {
require(VAR15 != address(0));
emit FUN6(VAR13, VAR15);
VAR13 = VAR15;
}
}
contract lockEtherPay is VAR12 {
using SafeMath for uint256;
token VAR17;
address public VAR18;
bool public VAR19 = false;
bool public VAR20 = false;
uint256 public VAR21;
uint256 public VAR22;
uint256 public VAR23 = 29808000;
event FUN8(address VAR18, uint256 VAR24);
constructor() public{
VAR17 = FUN9(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6);
VAR18 = 0x24c17C779E7d4b741C1cB4038b4D9a5027ca871f;
}
function FUN10() constant public returns (uint256){
return VAR17.FUN5(this);
}
function FUN11() public onlyOwner returns (bool){
require(!VAR19);
require(FUN10() > 0);
VAR21 = VAR25;
VAR22 = VAR21.FUN4(VAR23);
VAR19 = true;
}
function FUN12() constant public returns (bool){
uint256 VAR26 = VAR25;
return VAR26 > VAR22;
}
function FUN13() onlyOwner public{
require(VAR19);
require(!VAR20);
require(FUN12());
uint256 VAR24 = FUN10();
VAR17.transfer( VAR18, VAR24);
emit FUN8(VAR18, VAR24);
VAR20 = true;
}
}
0
---------------------------------
535 0x056465859d25fc26b44047e8377b58073e760746.sol
pragma VAR1 ^0.5.0;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
require(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 > 0);
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 <= VAR3);
uint256 VAR5 = VAR3 - VAR4;
return VAR5;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
return VAR5;
}
function FUN5(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
require(VAR4 != 0);
return VAR3 % VAR4;
}
}
pragma VAR1 ^0.5.0;
contract VAR6 {
address private VAR7;
event FUN6(address indexed VAR8, address indexed VAR9);
constructor () internal {
VAR7 = msg.sender;
emit FUN6(address(0), VAR7);
}
function FUN7() public view returns (address) {
return VAR7;
}
modifier onlyOwner() {
require(FUN8());
VAR10;
}
function FUN8() public view returns (bool) {
return msg.sender == VAR7;
}
function FUN9() public onlyOwner {
emit FUN6(VAR7, address(0));
VAR7 = address(0);
}
function FUN10(address VAR9) public onlyOwner {
FUN11(VAR9);
}
function FUN11(address VAR9) internal {
require(VAR9 != address(0));
emit FUN6(VAR7, VAR9);
VAR7 = VAR9;
}
}
pragma VAR1 ^0.5.4;
contract Reputation is VAR6 {
uint8 public VAR11 = 18;
event FUN12(address indexed VAR12, uint256 VAR13);
event FUN13(address indexed VAR14, uint256 VAR13);
struct VAR15 {
uint128 VAR16;
uint128 value;
}
mapping (address => VAR15[]) VAR17;
VAR15[] VAR18;
constructor(
) public
{
}
function FUN14() public view returns (uint256) {
return FUN15(VAR19.VAR20);
}
function FUN16(address VAR7) public view returns (uint256 VAR21) {
return FUN17(VAR7, VAR19.VAR20);
}
function FUN17(address VAR7, uint256 VAR22)
public view returns (uint256)
{
if ((VAR17[VAR7].VAR23 == 0) || (VAR17[VAR7][0].VAR16 > VAR22)) {
return 0;
} else {
return FUN18(VAR17[VAR7], VAR22);
}
}
function FUN15(uint256 VAR22) public view returns(uint256) {
if ((VAR18.VAR23 == 0) || (VAR18[0].VAR16 > VAR22)) {
return 0;
} else {
return FUN18(VAR18, VAR22);
}
}
function FUN19(address VAR24, uint256 VAR13) public onlyOwner returns (bool) {
uint256 VAR25 = FUN14();
require(VAR25 + VAR13 >= VAR25);
uint256 VAR26 = FUN16(VAR24);
require(VAR26 + VAR13 >= VAR26);
FUN20(VAR18, VAR25 + VAR13);
FUN20(VAR17[VAR24], VAR26 + VAR13);
emit FUN12(VAR24, VAR13);
return true;
}
function FUN21(address VAR24, uint256 VAR13) public onlyOwner returns (bool) {
uint256 VAR25 = FUN14();
uint256 VAR27 = VAR13;
uint256 VAR28 = FUN16(VAR24);
if (VAR28 < VAR27) {
VAR27 = VAR28;
}
FUN20(VAR18, VAR25 - VAR27);
FUN20(VAR17[VAR24], VAR28 - VAR27);
emit FUN13(VAR24, VAR27);
return true;
}
function FUN18(VAR15[] storage VAR29, uint256 VAR30) internal view returns (uint256) {
if (VAR29.VAR23 == 0) {
return 0;
}
if (VAR30 >= VAR29[VAR29.VAR23-1].VAR16) {
return VAR29[VAR29.VAR23-1].value;
}
if (VAR30 < VAR29[0].VAR16) {
return 0;
}
uint256 VAR31 = 0;
uint256 VAR32 = VAR29.VAR23-1;
while (VAR32 > VAR31) {
uint256 VAR33 = (VAR32 + VAR31 + 1) / 2;
if (VAR29[VAR33].VAR16<=VAR30) {
VAR31 = VAR33;
} else {
VAR32 = VAR33-1;
}
}
return VAR29[VAR31].value;
}
function FUN20(VAR15[] storage VAR29, uint256 VAR34) internal {
require(uint128(VAR34) == VAR34);
if ((VAR29.VAR23 == 0) || (VAR29[VAR29.VAR23 - 1].VAR16 < VAR19.VAR20)) {
Checkpoint storage VAR35 = VAR29[VAR29.VAR23++];
VAR35.VAR16 = uint128(VAR19.VAR20);
VAR35.value = uint128(VAR34);
} else {
Checkpoint storage VAR36 = VAR29[VAR29.VAR23-1];
VAR36.value = uint128(VAR34);
}
}
}
pragma VAR1 ^0.5.0;
interface VAR37 {
function transfer(address VAR38, uint256 value) external returns (bool);
function FUN22(address VAR39, uint256 value) external returns (bool);
function FUN23(address VAR40, address VAR38, uint256 value) external returns (bool);
function FUN14() external view returns (uint256);
function FUN16(address VAR41) external view returns (uint256);
function FUN24(address VAR42, address VAR39) external view returns (uint256);
event Transfer(address indexed VAR40, address indexed VAR38, uint256 value);
event FUN25(address indexed VAR42, address indexed VAR39, uint256 value);
}
pragma VAR1 ^0.5.0;
contract ERC20 is VAR37 {
using SafeMath for uint256;
mapping (address => uint256) private VAR43;
mapping (address => mapping (address => uint256)) private VAR44;
uint256 private VAR45;
function FUN14() public view returns (uint256) {
return VAR45;
}
function FUN16(address VAR42) public view returns (uint256) {
return VAR43[VAR42];
}
function FUN24(address VAR42, address VAR39) public view returns (uint256) {
return VAR44[VAR42][VAR39];
}
function transfer(address VAR38, uint256 value) public returns (bool) {
FUN26(msg.sender, VAR38, value);
return true;
}
function FUN22(address VAR39, uint256 value) public returns (bool) {
require(VAR39 != address(0));
VAR44[msg.sender][VAR39] = value;
emit FUN25(msg.sender, VAR39, value);
return true;
}
function FUN23(address VAR40, address VAR38, uint256 value) public returns (bool) {
VAR44[VAR40][msg.sender] = VAR44[VAR40][msg.sender].FUN3(value);
FUN26(VAR40, VAR38, value);
emit FUN25(VAR40, msg.sender, VAR44[VAR40][msg.sender]);
return true;
}
function FUN27(address VAR39, uint256 VAR46) public returns (bool) {
require(VAR39 != address(0));
VAR44[msg.sender][VAR39] = VAR44[msg.sender][VAR39].FUN4(VAR46);
emit FUN25(msg.sender, VAR39, VAR44[msg.sender][VAR39]);
return true;
}
function FUN28(address VAR39, uint256 VAR47) public returns (bool) {
require(VAR39 != address(0));
VAR44[msg.sender][VAR39] = VAR44[msg.sender][VAR39].FUN3(VAR47);
emit FUN25(msg.sender, VAR39, VAR44[msg.sender][VAR39]);
return true;
}
function FUN26(address VAR40, address VAR38, uint256 value) internal {
require(VAR38 != address(0));
VAR43[VAR40] = VAR43[VAR40].FUN3(value);
VAR43[VAR38] = VAR43[VAR38].FUN4(value);
emit Transfer(VAR40, VAR38, value);
}
function FUN29(address VAR48, uint256 value) internal {
require(VAR48 != address(0));
VAR45 = VAR45.FUN4(value);
VAR43[VAR48] = VAR43[VAR48].FUN4(value);
emit Transfer(address(0), VAR48, value);
}
function FUN30(address VAR48, uint256 value) internal {
require(VAR48 != address(0));
VAR45 = VAR45.FUN3(value);
VAR43[VAR48] = VAR43[VAR48].FUN3(value);
emit Transfer(VAR48, address(0), value);
}
function FUN31(address VAR48, uint256 value) internal {
VAR44[VAR48][msg.sender] = VAR44[VAR48][msg.sender].FUN3(value);
FUN30(VAR48, value);
emit FUN25(VAR48, msg.sender, VAR44[VAR48][msg.sender]);
}
}
pragma VAR1 ^0.5.0;
contract ERC20Burnable is VAR49 {
function FUN21(uint256 value) public {
FUN30(msg.sender, value);
}
function FUN32(address VAR40, uint256 value) public {
FUN31(VAR40, value);
}
}
pragma VAR1 ^0.5.4;
contract DAOToken is VAR49, VAR50, VAR6 {
string public VAR51;
string public VAR52;
uint8 public constant VAR11 = 18;
uint256 public VAR53;
constructor(string memory VAR54, string memory VAR55, uint256 VAR56)
public {
VAR51 = VAR54;
VAR52 = VAR55;
VAR53 = VAR56;
}
function FUN19(address VAR12, uint256 VAR13) public onlyOwner returns (bool) {
if (VAR53 > 0)
require(FUN14().FUN4(VAR13) <= VAR53);
FUN29(VAR12, VAR13);
return true;
}
}
pragma VAR1 ^0.5.0;
library VAR57 {
function FUN33(address VAR48) internal view returns (bool) {
uint256 VAR58;
VAR59 { VAR58 := FUN34(VAR48) }
return VAR58 > 0;
}
}
pragma VAR1 ^0.5.4;
library VAR60 {
using Address for address;
bytes4 constant private VAR61 = bytes4(FUN35(bytes("")));
bytes4 constant private VAR62 = bytes4(FUN35(bytes("")));
bytes4 constant private VAR63 = bytes4(FUN35(bytes("")));
function FUN36(address VAR64, address VAR12, uint256 VAR34) internal {
require(VAR64.FUN33());
(bool VAR65, bytes memory VAR66) =
VAR64.call(VAR67.FUN37(VAR61, VAR12, VAR34));
require(VAR65);
require(VAR66.VAR23 == 0 || (VAR66.VAR23 == 32 && (VAR66[31] != 0)));
}
function FUN38(address VAR64, address VAR14, address VAR12, uint256 VAR34) internal {
require(VAR64.FUN33());
(bool VAR65, bytes memory VAR66) =
VAR64.call(VAR67.FUN37(VAR62, VAR14, VAR12, VAR34));
require(VAR65);
require(VAR66.VAR23 == 0 || (VAR66.VAR23 == 32 && (VAR66[31] != 0)));
}
function FUN39(address VAR64, address VAR68, uint256 VAR34) internal {
require(VAR64.FUN33());
require((VAR34 == 0) || (FUN40(VAR64).FUN24(address(this), VAR68) == 0));
(bool VAR65, bytes memory VAR66) =
VAR64.call(VAR67.FUN37(VAR63, VAR68, VAR34));
require(VAR65);
require(VAR66.VAR23 == 0 || (VAR66.VAR23 == 32 && (VAR66[31] != 0)));
}
}
pragma VAR1 ^0.5.4;
contract Avatar is VAR6 {
using SafeERC20 for address;
string public VAR69;
DAOToken public VAR70;
Reputation public VAR71;
event FUN41(address indexed VAR72, bytes VAR73, uint VAR34, bool VAR74);
event FUN42(uint256 VAR75, address indexed VAR12);
event FUN43(address indexed VAR76, address indexed VAR12, uint256 VAR34);
event FUN44(address indexed VAR76, address VAR14, address VAR12, uint256 VAR34);
event FUN45(address indexed VAR76, address VAR68, uint256 VAR34);
event FUN46(address indexed VAR77, uint256 VAR34);
event FUN47(string VAR78);
constructor(string memory VAR79, DAOToken VAR80, Reputation VAR81) public {
VAR69 = VAR79;
VAR70 = VAR80;
VAR71 = VAR81;
}
function() external payable {
emit FUN46(msg.sender, msg.value);
}
function FUN48(address VAR72, bytes memory VAR73, uint256 VAR34)
public
onlyOwner
returns(bool VAR65, bytes memory VAR66) {
(VAR65, VAR66) = VAR72.call.value(VAR34)(VAR73);
emit FUN41(VAR72, VAR73, VAR34, VAR65);
}
function FUN49(uint256 VAR75, address payable VAR12) public onlyOwner returns(bool) {
VAR12.transfer(VAR75);
emit FUN42(VAR75, VAR12);
return true;
}
function FUN50(IERC20 VAR76, address VAR12, uint256 VAR34)
public onlyOwner returns(bool)
{
address(VAR76).FUN36(VAR12, VAR34);
emit FUN43(address(VAR76), VAR12, VAR34);
return true;
}
function FUN51(
IERC20 VAR76,
address VAR14,
address VAR12,
uint256 VAR34
)
public onlyOwner returns(bool)
{
address(VAR76).FUN38(VAR14, VAR12, VAR34);
emit FUN44(address(VAR76), VAR14, VAR12, VAR34);
return true;
}
function FUN52(IERC20 VAR76, address VAR68, uint256 VAR34)
public onlyOwner returns(bool)
{
address(VAR76).FUN39(VAR68, VAR34);
emit FUN45(address(VAR76), VAR68, VAR34);
return true;
}
function FUN53(string memory VAR78) public onlyOwner returns(bool) {
emit FUN47(VAR78);
return true;
}
}
pragma VAR1 ^0.5.4;
contract VAR82 {
enum VAR83 { VAR84, VAR85, VAR86 }
function FUN54( address VAR87, bytes32 VAR88, bytes32 VAR89 ) public returns(bool);
function FUN55( address VAR87, bytes32 VAR88, bytes32 VAR89 ) public returns(bool);
function FUN56() public returns(VAR83);
}
pragma VAR1 ^0.5.4;
interface VAR90 {
function FUN57(uint256 VAR13, address VAR12, address VAR91)
external
returns(bool);
function FUN58(uint256 VAR13, address VAR14, address VAR91)
external
returns(bool);
function FUN59(uint256 VAR13, address VAR92, address VAR91)
external
returns(bool);
function FUN60(address VAR87, bytes32 VAR93, bytes4 VAR94, address VAR91)
external
returns(bool);
function FUN61(address VAR87, address VAR91)
external
returns(bool);
function FUN62(address VAR91) external returns(bool);
function FUN63(address VAR95, bytes32 VAR88, address VAR91)
external returns(bool);
function FUN64 (address VAR95, address VAR91)
external  returns(bool);
function FUN65(address VAR96, Avatar VAR91)
external returns(bool);
function FUN48(address VAR72, bytes calldata VAR73, Avatar VAR91, uint256 VAR34)
external
returns(bool, bytes VAR97);
function FUN49(uint256 VAR75, address payable VAR12, Avatar VAR91)
external returns(bool);
function FUN50(IERC20 VAR76, address VAR12, uint256 VAR34, Avatar VAR91)
external
returns(bool);
function FUN51(
IERC20 VAR76,
address VAR14,
address VAR12,
uint256 VAR34,
Avatar VAR91)
external
returns(bool);
function FUN52(IERC20 VAR76, address VAR68, uint256 VAR34, Avatar VAR91)
external
returns(bool);
function FUN53(string calldata VAR78, Avatar VAR91) external returns(bool);
function FUN66(address VAR91)
external
view
returns(address);
function FUN67( address VAR87, address VAR91) external view returns(bool);
function FUN68(address VAR87, address VAR91) external view returns(bytes32);
function FUN69(address VAR95, address VAR91) external view returns(bytes32);
function FUN70(address VAR87, address VAR91) external view returns(bytes4);
function FUN71(address VAR91) external view returns(uint, uint);
function FUN72(address VAR95, address VAR91) external view returns(bool);
}
pragma VAR1 ^0.5.4;
contract Auction4Reputation is VAR6 {
using SafeMath for uint256;
using SafeERC20 for address;
event FUN73(address indexed VAR98, uint256 indexed VAR99, uint256 VAR13);
event FUN74(uint256 indexed VAR99, address indexed VAR92, uint256 VAR13);
struct VAR100 {
uint256 VAR101;
mapping(address=>uint) VAR102;
}
mapping(uint=>VAR100) public VAR103;
Avatar public VAR104;
uint256 public VAR105;
uint256 public VAR106;
uint256 public VAR107;
uint256 public VAR108;
uint256 public VAR109;
uint256 public VAR110;
uint256 public VAR111;
IERC20 public VAR112;
address public VAR113;
function FUN75(
Avatar VAR91,
uint256 VAR114,
uint256 VAR115,
uint256 VAR116,
uint256 VAR117,
uint256 VAR118,
IERC20 VAR119,
address VAR120)
external
{
require(VAR104 == FUN76(0), "");
require(VAR91 != FUN76(0), "");
require(VAR117 > 0, "");
require(VAR116 > 15, "");
VAR110 = VAR116;
VAR106 = VAR115 + VAR116.FUN1(VAR117);
require(VAR118 >= VAR106, "");
VAR112 = VAR119;
VAR104 = VAR91;
VAR107 = VAR115;
VAR108 = VAR117;
VAR113 = VAR120;
VAR109 = VAR114;
VAR105 = VAR114.FUN1(VAR117);
VAR111 = VAR118;
}
function FUN77(address VAR92, uint256 VAR99) public returns(uint256 VAR121) {
require(VAR122 > VAR111, "");
Auction storage VAR123 = VAR103[VAR99];
uint256 VAR124 = VAR123.VAR102[VAR92];
require(VAR124 > 0, "");
VAR123.VAR102[VAR92] = 0;
uint256 VAR125 = VAR124.FUN1(VAR109);
VAR121 = VAR125.FUN2(VAR123.VAR101);
VAR105 = VAR105.FUN3(VAR121);
require(
FUN78(VAR104.FUN7())
.FUN57(VAR121, VAR92, address(VAR104)), "");
emit FUN74(VAR99, VAR92, VAR121);
}
function FUN79(uint256 VAR13, uint256 VAR99) public returns(uint256 VAR126) {
require(VAR13 > 0, "");
require(VAR122 < VAR106, "");
require(VAR122 >= VAR107, "");
address(VAR112).FUN38(msg.sender, address(this), VAR13);
VAR126 = (VAR122 - VAR107) / VAR110;
require(VAR126 == VAR99, "");
Auction storage VAR123 = VAR103[VAR126];
VAR123.VAR101 = VAR123.VAR101.FUN4(VAR13);
VAR123.VAR102[msg.sender] = VAR123.VAR102[msg.sender].FUN4(VAR13);
emit FUN73(msg.sender, VAR126, VAR13);
}
function FUN80(address VAR98, uint256 VAR99) public view returns(uint256) {
return VAR103[VAR99].VAR102[VAR98];
}
function FUN81() public {
require(VAR122 > VAR106, "");
uint256 VAR127 = VAR112.FUN16(address(this));
address(VAR112).FUN36(VAR113, VAR127);
}
}
pragma VAR1 ^0.5.4;
contract DxGenAuction4Rep is VAR128 {
constructor() public {}
}
0
---------------------------------
536 0x056be48c53d91bd362e29f1190daec35222a2b6c.sol
pragma VAR1 ^0.5.7;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) public view returns (uint256 VAR5);
function transfer(address VAR6, uint256 VAR7) public returns (bool VAR8);
function FUN2(address VAR9, address VAR6, uint256 VAR7) public returns (bool VAR8);
function FUN3(address VAR10, uint256 VAR7) public returns (bool VAR8);
function FUN4(address VAR4, address VAR10) public view returns (uint256 VAR11);
event Transfer(address indexed VAR9, address indexed VAR6, uint256 VAR7);
event FUN5(address indexed VAR4, address indexed VAR10, uint256 VAR7);
}
contract ERC20Vanilla is VAR2 {
uint256 constant private VAR12 = 2**256 - 1;
mapping (address => uint256) public VAR13;
mapping (address => mapping (address => uint256)) public VAR14;
string public VAR15;
uint8 public VAR16;
string public VAR17;
constructor(address VAR18, uint256 VAR19, string memory VAR20, uint8 VAR21, string memory VAR22
) public {
VAR13[VAR18] = VAR19;
VAR3 = VAR19;
VAR15 = VAR20;
VAR16 = VAR21;
VAR17 = VAR22;
}
function transfer(address VAR6, uint256 VAR7) public returns (bool VAR8) {
require(VAR13[msg.sender] >= VAR7);
VAR13[msg.sender] -= VAR7;
VAR13[VAR6] += VAR7;
emit Transfer(msg.sender, VAR6, VAR7);
return true;
}
function FUN2(address VAR9, address VAR6, uint256 VAR7) public returns (bool VAR8) {
uint256 VAR23 = VAR14[VAR9][msg.sender];
require(VAR13[VAR9] >= VAR7 && VAR23 >= VAR7);
VAR13[VAR6] += VAR7;
VAR13[VAR9] -= VAR7;
if (VAR23 < VAR12) {
VAR14[VAR9][msg.sender] -= VAR7;
}
emit Transfer(VAR9, VAR6, VAR7);
return true;
}
function FUN1(address VAR4) public view returns (uint256 VAR5) {
return VAR13[VAR4];
}
function FUN3(address VAR10, uint256 VAR7) public returns (bool VAR8) {
VAR14[msg.sender][VAR10] = VAR7;
emit FUN5(msg.sender, VAR10, VAR7);
return true;
}
function FUN4(address VAR4, address VAR10) public view returns (uint256 VAR11) {
return VAR14[VAR4][VAR10];
}
}
0
---------------------------------
537 0x056e963f69e5fe8b28591cdc469ad671d245dc0d.sol
pragma VAR1 ^0.5.7;
contract VAR2 {
mapping(address => uint256) private VAR3;
uint8 private VAR4;
address payable private VAR5;
bool private VAR6;
uint constant public VAR7 = 0.00001 VAR8;
constructor() public {
VAR5 = msg.sender;
VAR6 = false;
}
modifier onlyOwner() {
require(msg.sender == VAR5, "");
VAR9 ;
}
modifier FUN1() {
require(msg.value >= VAR7, "");
VAR9 ;
}
function FUN2(bool VAR10) public onlyOwner {
VAR6 = VAR10;
}
function FUN3() public payable VAR11 {
require(VAR6 == true, "");
require(VAR3[msg.sender] == 0, "");
VAR3[msg.sender] = VAR12;
VAR4 = VAR4 + 1;
VAR5.transfer(msg.value);
}
function FUN4() public view returns (uint8) {
return VAR4;
}
function FUN5() public view returns(bool){
return VAR3[msg.sender] > 0;
}
}
0
---------------------------------
538 0x058306004a2acfcaf5160142adcb71e9bb6d38e9.sol
pragma VAR1 ^0.4.17;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 * VAR4;
assert(VAR3 == 0 || VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 { function transfer(address VAR7, uint VAR8){  } }
contract VAR9 {
using SafeMath for uint256;
address public VAR10;
address public VAR11;
token VAR12;
uint256 public VAR13;
uint256 public VAR14;
uint256 public VAR15;
event FUN5(address indexed VAR16, address indexed VAR17, uint256 value, uint256 VAR8);
function FUN6() {
VAR10 = 0x7F9C7AA8A7F467DD5641BA81B218aADd6883e038;
VAR11 = 0xD70c22FF998cb7c5c36ae1680d1b49A435Cd7306;
VAR12 = FUN7(VAR11);
VAR13 = VAR18 + 50410 * 1 VAR19;
VAR14 = VAR13 + 54*24*60 * 1 VAR19;
}
function () payable {
FUN8(msg.sender);
}
function FUN8(address VAR17) payable {
require(VAR17 != 0x0);
require(FUN9());
uint256 VAR20 = msg.value;
uint256 VAR21 = (VAR20) * 1000;
if(VAR18 < VAR13 + 7*24*60* 1 VAR19){
VAR21 += (VAR21 * 40) / 100;
}else if (VAR18 < VAR13 + 27*24*60*1 VAR19){
throw;
}else if(VAR18 < VAR13 + 34*24*60* 1 VAR19){
VAR21 += (VAR21 * 20) / 100;
}else if(VAR18 < VAR13 + 41*24*60* 1 VAR19){
VAR21 += (VAR21 * 15) / 100;
}else if(VAR18 < VAR13 + 47*24*60* 1 VAR19){
VAR21 += (VAR21 * 10) / 100;
}
VAR15 = VAR15.FUN4(VAR20);
VAR12.transfer(VAR17, VAR21);
FUN5(msg.sender, VAR17, VAR20, VAR21);
FUN10();
}
function FUN10() internal {
if (!VAR10.FUN11(msg.value)) {
throw;
}
}
function FUN9() internal constant returns (bool) {
bool VAR22 = VAR18 >= VAR13 && VAR18 <= VAR14;
bool VAR23 = msg.value != 0;
return VAR22 && VAR23;
}
function FUN12() public constant returns (bool) {
return VAR18 > VAR14;
}
function FUN13(uint256 VAR24) {
if(msg.sender!=VAR10) throw;
VAR12.transfer(VAR10,VAR24);
}
}
0
---------------------------------
