1 0x00888096c1cdeb35bb3772f9080227aa6c9968ad.sol
pragma VAR1 ^0.4.13;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) returns (bool VAR5);
function FUN1(address VAR6) constant returns (uint256 VAR7);
}
contract VAR8 {
address public VAR9 = 0xF23B127Ff5a6a8b60CC4cbF937e5683315894DDA;
address public VAR10;
ERC20 public VAR11;
function FUN2(address VAR12, address VAR13) {
require(msg.sender == VAR9);
VAR10 = VAR12;
VAR11 = FUN3(VAR13);
}
function FUN4(){
VAR9.transfer(this.VAR7);
require(VAR11.transfer(VAR9, VAR11.FUN1(address(this))));
}
function FUN5(){
require(VAR10 != 0x0);
require(VAR10.call.value(this.VAR7)());
}
function () payable {
}
}
1
---------------------------------
2 0x0111e8a755a4212e6e1f13e75b1eaba8f837a213.sol
pragma VAR1 ^0.4.25;
contract VAR2 {
mapping(address => uint256) public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
address public VAR7;
address public VAR8;
event FUN1(address indexed sender, uint VAR9, uint256 VAR10);
event FUN2(address indexed sender, uint VAR9, uint256 VAR10);
constructor() public {
VAR7 = 0x35027a992A3c232Dd7A350bb75004aD8567561B2;
VAR8 = 0xFfB8ccA6D55762dF595F21E78f21CD8DfeadF1C8;
}
function () external payable {
emit FUN1(msg.sender, msg.value, VAR11);
if (msg.sender != VAR7) {
VAR3[msg.sender] += msg.value;
if (msg.sender != VAR8) {
VAR5 += msg.value;
}
}
}
function FUN3() external {
uint256 VAR12=address(this).VAR13;
VAR4 += VAR12;
VAR6 = VAR4-VAR3[VAR8]-VAR5;
emit FUN2(msg.sender, VAR12, VAR11);
if(!VAR7.call.value(VAR12)()) revert();
}
}
1
---------------------------------
3 0x01653e20d03d450658740691087ea7155bcd9726.sol
pragma VAR1 ^0.4.24;
interface VAR2 {
function FUN1() external returns(uint256);
function FUN2() external returns(uint256);
function FUN3() external returns(uint256);
function FUN4() external returns(uint256);
}
interface VAR3 {
function FUN5() external payable returns(bool);
function FUN6() external view returns(address, address, bool);
function FUN7(address VAR4) external returns(bool);
function FUN8() external returns(bool);
function FUN9() external returns(bool);
function FUN10(address VAR5) external;
}
interface VAR6 {
function FUN5(address VAR7) external payable returns (bool);
function FUN11() external returns (bool);
}
interface VAR8 {
function() payable external;
function FUN12(address VAR9) payable external returns(uint256);
function FUN13(uint256 VAR10) external;
function FUN14() external;
function FUN15() external;
function FUN16() external;
function FUN17(address VAR9) external view returns(uint256);
function FUN18(address VAR9) external view returns(uint256);
function transfer(address VAR11, uint256 VAR10) external returns(bool);
function FUN19() external view returns(uint256);
}
interface VAR12 {
function FUN20() external payable;
}
interface VAR13 {
function FUN21(address VAR7) external returns (uint256);
function FUN22(uint256 VAR14) external view returns (bytes32);
function FUN23(uint256 VAR14) external view returns (uint256);
function FUN24(uint256 VAR14) external view returns (address);
function FUN25() external view returns (uint256);
function FUN26(address VAR7, bytes32 VAR15, uint256 VAR16, bool VAR17) external payable returns(bool, uint256);
function FUN27(address VAR7, bytes32 VAR15, address VAR16, bool VAR17) external payable returns(bool, uint256);
function FUN28(address VAR7, bytes32 VAR15, bytes32 VAR16, bool VAR17) external payable returns(bool, uint256);
}
interface VAR18 {
function FUN29(uint256 VAR14, address VAR7, bytes32 VAR15, uint256 VAR19) external;
function FUN30(uint256 VAR14, bytes32 VAR15) external;
}
interface VAR20 {
function FUN31() external view returns(uint256);
function FUN32() external view returns(uint256);
function FUN33() external view returns(uint256);
function FUN34() external view returns(uint256);
function FUN35(address VAR21) external view returns(bytes32);
function FUN36(address VAR21) external view returns(bool);
function FUN37(address VAR21) external view returns(bool);
}
library VAR22 {
struct VAR23 {
uint256 VAR24;
uint256 VAR25;
address VAR26;
bytes32 VAR27;
uint256 VAR28;
uint256 VAR29;
uint256 VAR30;
uint256 VAR31;
uint256 VAR32;
}
struct VAR33 {
address VAR34;
bytes32 VAR35;
uint256 VAR36;
uint256 VAR37;
uint256 VAR38;
uint256 VAR39;
uint256 VAR40;
}
struct VAR41 {
uint256 VAR42;
uint256 VAR43;
uint256 VAR44;
uint256 VAR45;
}
struct VAR46 {
uint256 VAR47;
uint256 VAR48;
uint256 VAR49;
bool VAR50;
uint256 VAR51;
uint256 VAR43;
uint256 VAR42;
uint256 VAR52;
uint256 VAR44;
uint256 VAR45;
uint256 VAR53;
uint256 VAR54;
}
struct VAR55 {
uint256 VAR37;
uint256 VAR56;
}
struct VAR57 {
uint256 VAR37;
uint256 VAR56;
}
}
library VAR58 {
function FUN38(uint256 VAR59, uint256 VAR60)
internal
pure
returns (uint256 VAR61)
{
if (VAR59 == 0) {
return 0;
}
VAR61 = VAR59 * VAR60;
require(VAR61 / VAR59 == VAR60, "");
return VAR61;
}
function FUN39(uint256 VAR59, uint256 VAR60) internal pure returns (uint256) {
uint256 VAR61 = VAR59 / VAR60;
return VAR61;
}
function FUN40(uint256 VAR59, uint256 VAR60)
internal
pure
returns (uint256)
{
require(VAR60 <= VAR59, "");
return VAR59 - VAR60;
}
function FUN41(uint256 VAR59, uint256 VAR60)
internal
pure
returns (uint256 VAR61)
{
VAR61 = VAR59 + VAR60;
require(VAR61 >= VAR59, "");
return VAR61;
}
function FUN42(uint256 VAR62)
internal
pure
returns (uint256 VAR63)
{
uint256 VAR64 = ((FUN41(VAR62,1)) / 2);
VAR63 = VAR62;
while (VAR64 < VAR63)
{
VAR63 = VAR64;
VAR64 = ((FUN41((VAR62 / VAR64),VAR64)) / 2);
}
}
function FUN43(uint256 VAR62)
internal
pure
returns (uint256)
{
return (FUN38(VAR62,VAR62));
}
function FUN44(uint256 VAR62, uint256 VAR63)
internal
pure
returns (uint256)
{
if (VAR62==0)
return (0);
else if (VAR63==0)
return (1);
else
{
uint256 VAR64 = VAR62;
for (uint256 VAR65=1; VAR65 < VAR63; VAR65++)
VAR64 = FUN38(VAR64,VAR62);
return (VAR64);
}
}
}
library VAR66 {
function FUN45(string VAR67)
internal
pure
returns(bytes32)
{
bytes memory VAR68 = bytes(VAR67);
uint256 VAR69 = VAR68.VAR70;
require (VAR69 <= 32 && VAR69 > 0, "");
require(VAR68[0] != 0x20 && VAR68[VAR69-1] != 0x20, "");
if (VAR68[0] == 0x30)
{
require(VAR68[1] != 0x78, "");
require(VAR68[1] != 0x58, "");
}
bool VAR71;
for (uint256 VAR65 = 0; VAR65 < VAR69; VAR65++)
{
if (VAR68[VAR65] > 0x40 && VAR68[VAR65] < 0x5b)
{
VAR68[VAR65] = FUN46(uint(VAR68[VAR65]) + 32);
if (VAR71 == false)
VAR71 = true;
} else {
require
(
VAR68[VAR65] == 0x20 ||
(VAR68[VAR65] > 0x60 && VAR68[VAR65] < 0x7b) ||
(VAR68[VAR65] > 0x2f && VAR68[VAR65] < 0x3a),
""
);
if (VAR68[VAR65] == 0x20)
require( VAR68[VAR65+1] != 0x20, "");
if (VAR71 == false && (VAR68[VAR65] < 0x30 || VAR68[VAR65] > 0x39))
VAR71 = true;
}
}
require(VAR71 == true, "");
bytes32 VAR72;
VAR73 {
VAR72 := FUN47(FUN41(VAR68, 32))
}
return (VAR72);
}
}
library VAR74 {
struct VAR75
{
mapping (bytes32 => VAR76) VAR77;
}
struct VAR76
{
bytes32 VAR78;
uint256 VAR79;
mapping (address => bool) VAR80;
mapping (uint256 => address) VAR81;
}
function FUN48(Data storage VAR82, uint256 VAR83, bytes32 VAR84)
internal
returns(bool)
{
bytes32 VAR85 = FUN49(VAR84);
uint256 VAR86 = VAR82.VAR77[VAR85].VAR79;
address VAR87 = msg.sender;
bytes32 VAR88 = FUN50(msg.VAR89);
if (VAR86 == 0)
{
VAR82.VAR77[VAR85].VAR78 = VAR88;
VAR82.VAR77[VAR85].VAR80[VAR87] = true;
VAR82.VAR77[VAR85].VAR81[VAR86] = VAR87;
VAR82.VAR77[VAR85].VAR79 += 1;
if (VAR82.VAR77[VAR85].VAR79 == VAR83) {
return(true);
}
} else if (VAR82.VAR77[VAR85].VAR78 == VAR88) {
if (VAR82.VAR77[VAR85].VAR80[VAR87] == false)
{
VAR82.VAR77[VAR85].VAR80[VAR87] = true;
VAR82.VAR77[VAR85].VAR81[VAR86] = VAR87;
VAR82.VAR77[VAR85].VAR79 += 1;
}
if (VAR82.VAR77[VAR85].VAR79 == VAR83) {
return(true);
}
}
}
function FUN51(Data storage VAR82, bytes32 VAR84)
internal
{
bytes32 VAR85 = FUN49(VAR84);
address VAR87;
for (uint256 VAR65=0; VAR65 < VAR82.VAR77[VAR85].VAR79; VAR65++) {
VAR87 = VAR82.VAR77[VAR85].VAR81[VAR65];
delete VAR82.VAR77[VAR85].VAR80[VAR87];
delete VAR82.VAR77[VAR85].VAR81[VAR65];
}
delete VAR82.VAR77[VAR85];
}
function FUN49(bytes32 VAR84)
private
view
returns(bytes32)
{
return(FUN50(VAR90.FUN52(VAR84,this)));
}
function FUN53 (Data storage VAR82, bytes32 VAR84)
internal
view
returns (bytes32 VAR91)
{
bytes32 VAR85 = FUN49(VAR84);
return (VAR82.VAR77[VAR85].VAR78);
}
function FUN54 (Data storage VAR82, bytes32 VAR84)
internal
view
returns (uint256 VAR92)
{
bytes32 VAR85 = FUN49(VAR84);
return (VAR82.VAR77[VAR85].VAR79);
}
function FUN55 (Data storage VAR82, bytes32 VAR84, uint256 VAR93)
internal
view
returns (address VAR94)
{
require(VAR93 > 0, "");
bytes32 VAR85 = FUN49(VAR84);
return (VAR82.VAR77[VAR85].VAR81[VAR93 - 1]);
}
}
library VAR95 {
using SafeMath for *;
function FUN56(uint256 VAR96, uint256 VAR97)
internal
pure
returns (uint256)
{
return(FUN57((VAR96).FUN41(VAR97)).FUN40(FUN57(VAR96)));
}
function FUN58(uint256 VAR98, uint256 VAR99)
internal
pure
returns (uint256)
{
return((FUN59(VAR98)).FUN40(FUN59(VAR98.FUN40(VAR99))));
}
function FUN57(uint256 VAR100)
internal
pure
returns(uint256)
{
return ((((((VAR100).FUN38(1000000000000000000)).FUN38(312500000000000000000000000)).FUN41(5624988281256103515625000000000000000000000000000000000000000000)).FUN42()).FUN40(74999921875000000000000000000000)) / (156250000);
}
function FUN59(uint256 VAR101)
internal
pure
returns(uint256)
{
return ((78125000).FUN38(VAR101.FUN43()).FUN41(((149999843750000).FUN38(VAR101.FUN38(1000000000000000000))) / (2))) / ((1000000000000000000).FUN43());
}
}
library VAR102 {
using SafeMath for *;
function FUN60(uint256 VAR103, uint256 VAR104, uint256 VAR105, uint256 VAR106)
internal
pure
returns(uint256)
{
require(VAR106 < 77 && VAR105 < 77, "");
require(VAR106 >= VAR105, "");
VAR106 = FUN61(VAR106).FUN38(10);
VAR105 = FUN61(VAR105);
require(VAR104 < (VAR106 / VAR105));
if (VAR104 > 0)
VAR104 = VAR104.FUN38(VAR105);
return((VAR103.FUN40((VAR103 / VAR105).FUN38(VAR105))).FUN41(VAR104).FUN41((VAR103 / VAR106).FUN38(VAR106)));
}
function FUN62(uint256 VAR67, uint256 VAR105, uint256 VAR106)
internal
pure
returns(uint256)
{
require(VAR106 < 77 && VAR105 < 77, "");
require(VAR106 >= VAR105, "");
VAR106 = FUN61(VAR106).FUN38(10);
VAR105 = FUN61(VAR105);
return((((VAR67 / VAR105).FUN38(VAR105)).FUN40((VAR67 / VAR106).FUN38(VAR106))) / VAR105);
}
function FUN61(uint256 VAR107)
private
pure
returns(uint256)
{
return((10).FUN44(VAR107));
}
}
contract VAR108 {
event VAR109
(
uint256 indexed VAR110,
address indexed VAR111,
bytes32 indexed VAR112,
bool VAR113,
uint256 VAR114,
address VAR115,
bytes32 VAR116,
uint256 VAR117,
uint256 VAR118
);
event VAR119
(
uint256 VAR24,
uint256 VAR25,
bytes32 VAR112,
address VAR111,
uint256 VAR120,
uint256 VAR121,
address VAR26,
bytes32 VAR27,
uint256 VAR28,
uint256 VAR29,
uint256 VAR30,
uint256 VAR31,
uint256 VAR32,
uint256 VAR122
);
event VAR123
(
uint256 indexed VAR110,
address VAR111,
bytes32 VAR112,
uint256 VAR124,
uint256 VAR118
);
event VAR125
(
address VAR111,
bytes32 VAR112,
uint256 VAR124,
uint256 VAR24,
uint256 VAR25,
address VAR26,
bytes32 VAR27,
uint256 VAR28,
uint256 VAR29,
uint256 VAR30,
uint256 VAR31
);
event VAR126
(
address VAR111,
bytes32 VAR112,
uint256 VAR120,
uint256 VAR24,
uint256 VAR25,
address VAR26,
bytes32 VAR27,
uint256 VAR28,
uint256 VAR29,
uint256 VAR30,
uint256 VAR31
);
event VAR127
(
address VAR111,
bytes32 VAR112,
uint256 VAR24,
uint256 VAR25,
address VAR26,
bytes32 VAR27,
uint256 VAR28,
uint256 VAR29,
uint256 VAR30,
uint256 VAR31
);
event VAR128
(
uint256 indexed VAR114,
address VAR115,
bytes32 VAR116,
uint256 indexed VAR129,
uint256 indexed VAR130,
uint256 VAR131,
uint256 VAR118
);
event VAR132
(
uint256 VAR129,
uint256 VAR133
);
}
contract VAR134 {
string public VAR35 = "";
FundInterfaceForForwarder private VAR135;
address private VAR136;
bool VAR137 = true;
constructor()
public
{
}
function()
public
payable
{
VAR135.VAR138.value(address(this).VAR139)(address(VAR135));
}
function FUN5()
public
payable
returns(bool)
{
require(msg.value > 0, "");
require(VAR137 == false, "");
if (VAR135.VAR138.value(msg.value)(msg.sender) == true)
return(true);
else
return(false);
}
function FUN6()
public
view
returns(address, address, bool)
{
return(address(VAR135), address(VAR136), VAR137);
}
function FUN7(address VAR4)
external
returns(bool)
{
require(msg.sender == address(VAR135), "");
if(FUN63(VAR4).FUN11() == true)
{
VAR136 = VAR4;
return (true);
} else
return (false);
}
function FUN8()
external
returns(bool)
{
require(msg.sender == address(VAR135), "");
VAR136 = address(0x0);
return (true);
}
function FUN9()
external
returns(bool)
{
require(msg.sender == VAR136, "");
VAR135 = (FUN63(VAR136));
VAR136 = address(0x0);
return (true);
}
function FUN10(address VAR5)
external
{
require(VAR137 == true, "");
VAR135 = FUN63(VAR5);
VAR137 = false;
}
}
contract ModularLong is VAR108 {}
contract VAR140 {
using NameFilter for string;
using SafeMath for uint256;
address constant private VAR141 = 0x7a9E13E044CB905957eA465488DabD5F5D34E2C4;
bytes32  constant private VAR142 = "";
FundForwarderInterface constant private VAR143 = FUN64(0x5095072aEE46a39D0b3753184514ead86405780f);
TeamInterface constant private VAR144 = FUN65(0xf72848D3426d8dB71e52FAc6Df29585649bb7CBD);
VAR74.Data private VAR145;
function FUN66(bytes32 VAR84) private returns (bool) {return(VAR74.FUN48(VAR145, VAR144.FUN32(), VAR84));}
function FUN51(bytes32 VAR84) private {VAR74.FUN51(VAR145, VAR84);}
function FUN67(bytes32 VAR84) FUN68() public {VAR74.FUN51(VAR145, VAR84);}
function FUN69(bytes32 VAR84) FUN68() public view returns(bytes32, uint256) {return(VAR74.FUN53(VAR145, VAR84), VAR74.FUN54(VAR145, VAR84));}
function FUN70(bytes32 VAR84, uint256 VAR146, uint256 VAR147, uint256 VAR148) FUN68() public view returns(address, address, address) {return(VAR74.FUN55(VAR145, VAR84, VAR146), VAR74.FUN55(VAR145, VAR84, VAR147), VAR74.FUN55(VAR145, VAR84, VAR148));}
function FUN71(bytes32 VAR84, uint256 VAR146, uint256 VAR147, uint256 VAR148) FUN68() public view returns(bytes32, bytes32, bytes32) {return(VAR144.FUN35(VAR74.FUN55(VAR145, VAR84, VAR146)), VAR144.FUN35(VAR74.FUN55(VAR145, VAR84, VAR147)), VAR144.FUN35(VAR74.FUN55(VAR145, VAR84, VAR148)));}
uint256 public VAR149 = 10 VAR150;
mapping(uint256 => VAR18) public VAR151;
mapping(address => bytes32) public VAR152;
mapping(address => uint256) public VAR153;
uint256 public VAR154;
uint256 public VAR155;
mapping (address => uint256) public VAR156;
mapping (bytes32 => uint256) public VAR157;
mapping (uint256 => VAR33) public VAR158;
mapping (uint256 => mapping (bytes32 => bool)) public VAR159;
mapping (uint256 => mapping (uint256 => bytes32)) public VAR160;
struct VAR33 {
address VAR34;
bytes32 VAR35;
uint256 VAR40;
uint256 VAR161;
}
constructor()
public
{
VAR158[1].VAR34 = VAR141;
VAR158[1].VAR35 = VAR142;
VAR158[1].VAR161 = 1;
VAR156[VAR141] = 1;
VAR157[VAR142] = 1;
VAR159[1][VAR142] = true;
VAR160[1][1] = VAR142;
VAR155 = 1;
}
modifier FUN72() {
address VAR7 = msg.sender;
uint256 VAR162;
VAR73 {VAR162 := FUN73(VAR7)}
require(VAR162 == 0, "");
VAR163;
}
modifier FUN68()
{
require(VAR144.FUN37(msg.sender) == true, "");
VAR163;
}
modifier FUN74()
{
require(VAR153[msg.sender] != 0);
VAR163;
}
event VAR109
(
uint256 indexed VAR110,
address indexed VAR111,
bytes32 indexed VAR112,
bool VAR113,
uint256 VAR114,
address VAR115,
bytes32 VAR116,
uint256 VAR117,
uint256 VAR118
);
function FUN75(string VAR164)
public
view
returns(bool)
{
bytes32 VAR15 = VAR164.FUN45();
if (VAR157[VAR15] == 0)
return (true);
else
return (false);
}
function FUN76(string VAR165, uint256 VAR16, bool VAR17)
FUN72()
public
payable
{
require (msg.value >= VAR149, "");
bytes32 VAR15 = VAR66.FUN45(VAR165);
address VAR7 = msg.sender;
bool VAR166 = FUN77(VAR7);
uint256 VAR14 = VAR156[VAR7];
if (VAR16 != 0 && VAR16 != VAR158[VAR14].VAR40 && VAR16 != VAR14)
{
VAR158[VAR14].VAR40 = VAR16;
} else if (VAR16 == VAR14) {
VAR16 = 0;
}
FUN78(VAR14, VAR7, VAR16, VAR15, VAR166, VAR17);
}
function FUN79(string VAR165, address VAR16, bool VAR17)
FUN72()
public
payable
{
require (msg.value >= VAR149, "");
bytes32 VAR15 = VAR66.FUN45(VAR165);
address VAR7 = msg.sender;
bool VAR166 = FUN77(VAR7);
uint256 VAR14 = VAR156[VAR7];
uint256 VAR167;
if (VAR16 != address(0) && VAR16 != VAR7)
{
VAR167 = VAR156[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
FUN78(VAR14, VAR7, VAR167, VAR15, VAR166, VAR17);
}
function FUN80(string VAR165, bytes32 VAR16, bool VAR17)
FUN72()
public
payable
{
require (msg.value >= VAR149, "");
bytes32 VAR15 = VAR66.FUN45(VAR165);
address VAR7 = msg.sender;
bool VAR166 = FUN77(VAR7);
uint256 VAR14 = VAR156[VAR7];
uint256 VAR167;
if (VAR16 != "" && VAR16 != VAR15)
{
VAR167 = VAR157[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
FUN78(VAR14, VAR7, VAR167, VAR15, VAR166, VAR17);
}
function FUN81(uint256 VAR168)
FUN72()
public
{
require(VAR168 <= VAR154, "");
address VAR7 = msg.sender;
uint256 VAR14 = VAR156[VAR7];
require(VAR14 != 0, "");
uint256 VAR169 = VAR158[VAR14].VAR161;
VAR151[VAR168].FUN29(VAR14, VAR7, VAR158[VAR14].VAR35, VAR158[VAR14].VAR40);
if (VAR169 > 1)
for (uint256 VAR170 = 1; VAR170 <= VAR169; VAR170++)
VAR151[VAR168].FUN30(VAR14, VAR160[VAR14][VAR170]);
}
function FUN82()
FUN72()
public
{
address VAR7 = msg.sender;
uint256 VAR14 = VAR156[VAR7];
require(VAR14 != 0, "");
uint256 VAR19 = VAR158[VAR14].VAR40;
uint256 VAR169 = VAR158[VAR14].VAR161;
bytes32 VAR15 = VAR158[VAR14].VAR35;
for (uint256 VAR65 = 1; VAR65 <= VAR154; VAR65++)
{
VAR151[VAR65].FUN29(VAR14, VAR7, VAR15, VAR19);
if (VAR169 > 1)
for (uint256 VAR170 = 1; VAR170 <= VAR169; VAR170++)
VAR151[VAR65].FUN30(VAR14, VAR160[VAR14][VAR170]);
}
}
function FUN83(string VAR165)
FUN72()
public
{
bytes32 VAR15 = VAR165.FUN45();
uint256 VAR14 = VAR156[msg.sender];
require(VAR159[VAR14][VAR15] == true, "");
VAR158[VAR14].VAR35 = VAR15;
}
function FUN78(uint256 VAR14, address VAR7, uint256 VAR167, bytes32 VAR15, bool VAR166, bool VAR17)
private
{
if (VAR157[VAR15] != 0)
require(VAR159[VAR14][VAR15] == true, "");
VAR158[VAR14].VAR35 = VAR15;
VAR157[VAR15] = VAR14;
if (VAR159[VAR14][VAR15] == false)
{
VAR159[VAR14][VAR15] = true;
VAR158[VAR14].VAR161++;
VAR160[VAR14][VAR158[VAR14].VAR161] = VAR15;
}
VAR143.VAR138.value(address(this).VAR139)();
if (VAR17 == true)
for (uint256 VAR65 = 1; VAR65 <= VAR154; VAR65++)
VAR151[VAR65].FUN29(VAR14, VAR7, VAR15, VAR167);
emit FUN84(VAR14, VAR7, VAR15, VAR166, VAR167, VAR158[VAR167].VAR34, VAR158[VAR167].VAR35, msg.value, VAR171);
}
function FUN77(address VAR7)
private
returns (bool)
{
if (VAR156[VAR7] == 0)
{
VAR155++;
VAR156[VAR7] = VAR155;
VAR158[VAR155].VAR34 = VAR7;
return (true);
} else {
return (false);
}
}
function FUN21(address VAR7)
FUN74()
external
returns (uint256)
{
FUN77(VAR7);
return (VAR156[VAR7]);
}
function FUN22(uint256 VAR14)
external
view
returns (bytes32)
{
return (VAR158[VAR14].VAR35);
}
function FUN23(uint256 VAR14)
external
view
returns (uint256)
{
return (VAR158[VAR14].VAR40);
}
function FUN24(uint256 VAR14)
external
view
returns (address)
{
return (VAR158[VAR14].VAR34);
}
function FUN25()
external
view
returns (uint256)
{
return(VAR149);
}
function FUN26(address VAR7, bytes32 VAR15, uint256 VAR16, bool VAR17)
FUN74()
external
payable
returns(bool, uint256)
{
require (msg.value >= VAR149, "");
bool VAR166 = FUN77(VAR7);
uint256 VAR14 = VAR156[VAR7];
uint256 VAR167 = VAR16;
if (VAR167 != 0 && VAR167 != VAR158[VAR14].VAR40 && VAR167 != VAR14)
{
VAR158[VAR14].VAR40 = VAR167;
} else if (VAR167 == VAR14) {
VAR167 = 0;
}
FUN78(VAR14, VAR7, VAR167, VAR15, VAR166, VAR17);
return(VAR166, VAR167);
}
function FUN27(address VAR7, bytes32 VAR15, address VAR16, bool VAR17)
FUN74()
external
payable
returns(bool, uint256)
{
require (msg.value >= VAR149, "");
bool VAR166 = FUN77(VAR7);
uint256 VAR14 = VAR156[VAR7];
uint256 VAR167;
if (VAR16 != address(0) && VAR16 != VAR7)
{
VAR167 = VAR156[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
FUN78(VAR14, VAR7, VAR167, VAR15, VAR166, VAR17);
return(VAR166, VAR167);
}
function FUN28(address VAR7, bytes32 VAR15, bytes32 VAR16, bool VAR17)
FUN74()
external
payable
returns(bool, uint256)
{
require (msg.value >= VAR149, "");
bool VAR166 = FUN77(VAR7);
uint256 VAR14 = VAR156[VAR7];
uint256 VAR167;
if (VAR16 != "" && VAR16 != VAR15)
{
VAR167 = VAR157[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
FUN78(VAR14, VAR7, VAR167, VAR15, VAR166, VAR17);
return(VAR166, VAR167);
}
function FUN85(address VAR172, string VAR173)
FUN68()
public
{
require(VAR153[VAR172] == 0, "");
if (FUN66("") == true)
{
FUN51("");
VAR154++;
bytes32 VAR15 = VAR173.FUN45();
VAR153[VAR172] = VAR154;
VAR152[VAR172] = VAR15;
VAR151[VAR154] = FUN86(VAR172);
VAR151[VAR154].FUN29(1, VAR158[1].VAR34, VAR158[1].VAR35, 0);
VAR151[VAR154].FUN29(2, VAR158[2].VAR34, VAR158[2].VAR35, 0);
VAR151[VAR154].FUN29(3, VAR158[3].VAR34, VAR158[3].VAR35, 0);
VAR151[VAR154].FUN29(4, VAR158[4].VAR34, VAR158[4].VAR35, 0);
}
}
function FUN87(uint256 VAR174)
FUN68()
public
{
if (FUN66("") == true)
{FUN51("");
VAR149 = VAR174;
}
}
}
contract VAR175 {
address constant private VAR141 = 0x7a9E13E044CB905957eA465488DabD5F5D34E2C4;
bytes32  constant private VAR142 = "";
FundForwarderInterface private VAR176 = FUN64(0x0);
VAR74.Data private VAR145;
function FUN67(bytes32 VAR84) FUN68() public {VAR74.FUN51(VAR145, VAR84);}
function FUN69(bytes32 VAR84) FUN88() public view returns(bytes32 VAR177, uint256 VAR92) {return(VAR74.FUN53(VAR145, VAR84), VAR74.FUN54(VAR145, VAR84));}
function FUN71(bytes32 VAR84, uint256 VAR146, uint256 VAR147, uint256 VAR148) FUN88() public view returns(bytes32, bytes32, bytes32) {return(this.FUN35(VAR74.FUN55(VAR145, VAR84, VAR146)), this.FUN35(VAR74.FUN55(VAR145, VAR84, VAR147)), this.FUN35(VAR74.FUN55(VAR145, VAR84, VAR148)));}
struct VAR178 {
bool VAR179;
bool VAR180;
bytes32 VAR35;
}
mapping (address => VAR178) VAR181;
uint256 VAR182;
uint256 VAR183;
uint256 VAR184;
uint256 VAR185;
constructor()
public
{
VAR181[VAR141] = FUN89(true, true, VAR142);
VAR182 = 1;
VAR183 = 1;
VAR184 = 1;
VAR185 = 1;
}
function ()
public
payable
{
VAR176.VAR138.value(address(this).VAR139)();
}
function FUN10(address VAR7)
FUN68()
public
{
require( address(VAR176) == address(0) );
VAR176 = FUN64(VAR7);
}
modifier FUN68()
{
require(VAR181[msg.sender].VAR180 == true, "");
VAR163;
}
modifier FUN88()
{
require(VAR181[msg.sender].VAR179 == true, "");
VAR163;
}
function FUN90(address VAR21, bytes32 VAR15, bool VAR186)
public
FUN68()
{
if (VAR74.FUN48(VAR145, VAR185, "") == true)
{
VAR74.FUN51(VAR145, "");
if (VAR181[VAR21].VAR179 == false)
{
VAR181[VAR21].VAR179 = true;
VAR182 += 1;
VAR184 += 1;
}
if (VAR186 == true)
{
VAR181[VAR21].VAR180 = VAR186;
VAR183 += 1;
VAR185 += 1;
}
}
VAR181[VAR21].VAR35 = VAR15;
}
function FUN91(address VAR21)
public
FUN68()
{
require(VAR182 > 1, "");
require(VAR182 >= VAR184, "");
if (VAR181[VAR21].VAR180 == true)
{
require(VAR183 > 1, "");
require(VAR183 >= VAR185, "");
}
if (VAR74.FUN48(VAR145, VAR185, "") == true)
{
VAR74.FUN51(VAR145, "");
if (VAR181[VAR21].VAR179 == true) {
VAR181[VAR21].VAR179 = false;
VAR182 -= 1;
if (VAR184 > 1)
{
VAR184 -= 1;
}
}
if (VAR181[VAR21].VAR180 == true) {
VAR181[VAR21].VAR180 = false;
VAR183 -= 1;
if (VAR185 > 1)
{
VAR185 -= 1;
}
}
}
}
function FUN92(uint256 VAR187)
public
FUN68()
{
require(VAR187 > 0 && VAR187 <= VAR182, "");
if (VAR74.FUN48(VAR145, VAR185, "") == true)
{
VAR74.FUN51(VAR145, "");
VAR184 = VAR187;
}
}
function FUN93(uint256 VAR187)
public
FUN68()
{
require(VAR187 > 0 && VAR187 <= VAR183, "");
if (VAR74.FUN48(VAR145, VAR185, "") == true)
{
VAR74.FUN51(VAR145, "");
VAR185 = VAR187;
}
}
function FUN31() external view returns(uint256) {return(VAR184);}
function FUN32() external view returns(uint256) {return(VAR185);}
function FUN33() external view returns(uint256) {return(VAR182);}
function FUN34() external view returns(uint256) {return(VAR183);}
function FUN35(address VAR21) external view returns(bytes32) {return(VAR181[VAR21].VAR35);}
function FUN36(address VAR21) external view returns(bool) {return(VAR181[VAR21].VAR179);}
function FUN37(address VAR21) external view returns(bool) {return(VAR181[VAR21].VAR180);}
}
contract FoMo3DlongUnlimited is VAR188 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
address constant private VAR141 = 0x7a9E13E044CB905957eA465488DabD5F5D34E2C4;
otherFoMo3D private VAR189;
FundForwarderInterface constant private VAR190 = FUN64(0x5095072aEE46a39D0b3753184514ead86405780f);
PlayerBookInterface constant private VAR191 = FUN94(0xf72848D3426d8dB71e52FAc6Df29585649bb7CBD);
bool public VAR192 = false;
string constant public VAR35 = "";
string constant public VAR193 = "";
uint256 private VAR194 =  10 VAR195;
uint256 private VAR196 =   10 VAR195;
uint256 constant private VAR197 = 1 VAR198;
uint256 constant private VAR199 = 0 VAR200;
uint256 constant private VAR201 = 2 VAR198;
uint256 public VAR202;
uint256 public VAR203 = 0;
uint256 public VAR204;
mapping (address => uint256) public VAR156;
mapping (bytes32 => uint256) public VAR157;
mapping (uint256 => VAR22.VAR33) public VAR158;
mapping (uint256 => mapping (uint256 => VAR22.VAR41)) public VAR205;
mapping (uint256 => mapping (bytes32 => bool)) public VAR159;
mapping (uint256 => VAR22.VAR46) public VAR206;
mapping (uint256 => mapping(uint256 => uint256)) public VAR207;
mapping (uint256 => VAR22.VAR55) public VAR208;
mapping (uint256 => VAR22.VAR57) public VAR209;
constructor()
public
{
VAR208[0] = VAR22.FUN95(36,0);
VAR208[1] = VAR22.FUN95(43,0);
VAR208[2] = VAR22.FUN95(66,0);
VAR208[3] = VAR22.FUN95(51,0);
VAR209[0] = VAR22.FUN96(25,0);
VAR209[1] = VAR22.FUN96(25,0);
VAR209[2] = VAR22.FUN96(40,0);
VAR209[3] = VAR22.FUN96(40,0);
}
modifier FUN97() {
require(VAR192 == true, "");
VAR163;
}
modifier FUN72() {
address VAR7 = msg.sender;
uint256 VAR162;
VAR73 {VAR162 := FUN73(VAR7)}
require(VAR162 == 0, "");
VAR163;
}
modifier FUN98(uint256 VAR100) {
require(VAR100 >= 1000000000, "");
require(VAR100 <= 100000000000000000000000, "");
VAR163;
}
function()
FUN97()
FUN72()
FUN98(msg.value)
public
payable
{
VAR22.EventReturns memory VAR210 = FUN77(VAR210);
uint256 VAR14 = VAR156[msg.sender];
FUN99(VAR14, VAR158[VAR14].VAR40, 2, VAR210);
}
function FUN100(uint256 VAR16, uint256 VAR211)
FUN97()
FUN72()
FUN98(msg.value)
public
payable
{
VAR22.EventReturns memory VAR210 = FUN77(VAR210);
uint256 VAR14 = VAR156[msg.sender];
if (VAR16 == 0 || VAR16 == VAR14)
{
VAR16 = VAR158[VAR14].VAR40;
} else if (VAR16 != VAR158[VAR14].VAR40) {
VAR158[VAR14].VAR40 = VAR16;
}
VAR211 = FUN101(VAR211);
FUN99(VAR14, VAR16, VAR211, VAR210);
}
function FUN102(address VAR16, uint256 VAR211)
FUN97()
FUN72()
FUN98(msg.value)
public
payable
{
VAR22.EventReturns memory VAR210 = FUN77(VAR210);
uint256 VAR14 = VAR156[msg.sender];
uint256 VAR167;
if (VAR16 == address(0) || VAR16 == msg.sender)
{
VAR167 = VAR158[VAR14].VAR40;
} else {
VAR167 = VAR156[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
VAR211 = FUN101(VAR211);
FUN99(VAR14, VAR167, VAR211, VAR210);
}
function FUN103(bytes32 VAR16, uint256 VAR211)
FUN97()
FUN72()
FUN98(msg.value)
public
payable
{
VAR22.EventReturns memory VAR210 = FUN77(VAR210);
uint256 VAR14 = VAR156[msg.sender];
uint256 VAR167;
if (VAR16 == '' || VAR16 == VAR158[VAR14].VAR35)
{
VAR167 = VAR158[VAR14].VAR40;
} else {
VAR167 = VAR157[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
VAR211 = FUN101(VAR211);
FUN99(VAR14, VAR167, VAR211, VAR210);
}
function FUN104(uint256 VAR16, uint256 VAR211, uint256 VAR100)
FUN97()
FUN72()
FUN98(VAR100)
public
{
VAR22.EventReturns memory VAR210;
uint256 VAR14 = VAR156[msg.sender];
if (VAR16 == 0 || VAR16 == VAR14)
{
VAR16 = VAR158[VAR14].VAR40;
} else if (VAR16 != VAR158[VAR14].VAR40) {
VAR158[VAR14].VAR40 = VAR16;
}
VAR211 = FUN101(VAR211);
FUN105(VAR14, VAR16, VAR211, VAR100, VAR210);
}
function FUN106(address VAR16, uint256 VAR211, uint256 VAR100)
FUN97()
FUN72()
FUN98(VAR100)
public
{
VAR22.EventReturns memory VAR210;
uint256 VAR14 = VAR156[msg.sender];
uint256 VAR167;
if (VAR16 == address(0) || VAR16 == msg.sender)
{
VAR167 = VAR158[VAR14].VAR40;
} else {
VAR167 = VAR156[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
VAR211 = FUN101(VAR211);
FUN105(VAR14, VAR167, VAR211, VAR100, VAR210);
}
function FUN107(bytes32 VAR16, uint256 VAR211, uint256 VAR100)
FUN97()
FUN72()
FUN98(VAR100)
public
{
VAR22.EventReturns memory VAR210;
uint256 VAR14 = VAR156[msg.sender];
uint256 VAR167;
if (VAR16 == '' || VAR16 == VAR158[VAR14].VAR35)
{
VAR167 = VAR158[VAR14].VAR40;
} else {
VAR167 = VAR157[VAR16];
if (VAR167 != VAR158[VAR14].VAR40)
{
VAR158[VAR14].VAR40 = VAR167;
}
}
VAR211 = FUN101(VAR211);
FUN105(VAR14, VAR167, VAR211, VAR100, VAR210);
}
function FUN15()
FUN97()
FUN72()
public
{
uint256 VAR212 = VAR204;
uint256 VAR213 = VAR171;
uint256 VAR14 = VAR156[msg.sender];
uint256 VAR100;
if (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR50 == false && VAR206[VAR212].VAR47 != 0)
{
VAR22.EventReturns memory VAR210;
VAR206[VAR212].VAR50 = true;
VAR210 = FUN108(VAR210);
VAR100 = FUN109(VAR14);
if (VAR100 > 0)
VAR158[VAR14].VAR34.transfer(VAR100);
VAR210.VAR24 = VAR210.VAR24 + (VAR213 * 1000000000000000000);
VAR210.VAR25 = VAR210.VAR25 + VAR14;
emit VAR108.VAR125
(
msg.sender,
VAR158[VAR14].VAR35,
VAR100,
VAR210.VAR24,
VAR210.VAR25,
VAR210.VAR26,
VAR210.VAR27,
VAR210.VAR28,
VAR210.VAR29,
VAR210.VAR30,
VAR210.VAR31
);
} else {
VAR100 = FUN109(VAR14);
if (VAR100 > 0)
VAR158[VAR14].VAR34.transfer(VAR100);
emit VAR108.FUN110(VAR14, msg.sender, VAR158[VAR14].VAR35, VAR100, VAR213);
}
}
function FUN76(string VAR165, uint256 VAR16, bool VAR17)
FUN72()
public
payable
{
bytes32 VAR15 = VAR165.FUN45();
address VAR7 = msg.sender;
uint256 VAR214 = msg.value;
(bool VAR166, uint256 VAR167) = VAR191.VAR215.value(VAR214)(VAR7, VAR15, VAR16, VAR17);
uint256 VAR14 = VAR156[VAR7];
emit VAR108.FUN84(VAR14, VAR7, VAR15, VAR166, VAR167, VAR158[VAR167].VAR34, VAR158[VAR167].VAR35, VAR214, VAR171);
}
function FUN79(string VAR165, address VAR16, bool VAR17)
FUN72()
public
payable
{
bytes32 VAR15 = VAR165.FUN45();
address VAR7 = msg.sender;
uint256 VAR214 = msg.value;
(bool VAR166, uint256 VAR167) = VAR191.VAR216.value(msg.value)(msg.sender, VAR15, VAR16, VAR17);
uint256 VAR14 = VAR156[VAR7];
emit VAR108.FUN84(VAR14, VAR7, VAR15, VAR166, VAR167, VAR158[VAR167].VAR34, VAR158[VAR167].VAR35, VAR214, VAR171);
}
function FUN80(string VAR165, bytes32 VAR16, bool VAR17)
FUN72()
public
payable
{
bytes32 VAR15 = VAR165.FUN45();
address VAR7 = msg.sender;
uint256 VAR214 = msg.value;
(bool VAR166, uint256 VAR167) = VAR191.VAR217.value(msg.value)(msg.sender, VAR15, VAR16, VAR17);
uint256 VAR14 = VAR156[VAR7];
emit VAR108.FUN84(VAR14, VAR7, VAR15, VAR166, VAR167, VAR158[VAR167].VAR34, VAR158[VAR167].VAR35, VAR214, VAR171);
}
function FUN111()
public
view
returns(uint256)
{
uint256 VAR212 = VAR204;
uint256 VAR213 = VAR171;
if (VAR213 > VAR206[VAR212].VAR51 + VAR196 && (VAR213 <= VAR206[VAR212].VAR49 || (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR47 == 0)))
return ( (VAR206[VAR212].VAR43.FUN41(1000000000000000000)).FUN58(1000000000000000000) );
else
return ( 75000000000000 );
}
function FUN112()
public
view
returns(uint256)
{
uint256 VAR212 = VAR204;
uint256 VAR213 = VAR171;
if (VAR213 < VAR206[VAR212].VAR49)
if (VAR213 > VAR206[VAR212].VAR51 + VAR196)
return( (VAR206[VAR212].VAR49).FUN40(VAR213) );
else
return( (VAR206[VAR212].VAR51 + VAR196).FUN40(VAR213) );
else
return(0);
}
function FUN113(uint256 VAR14)
public
view
returns(uint256 ,uint256, uint256)
{
uint256 VAR212 = VAR204;
if (VAR171 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR50 == false && VAR206[VAR212].VAR47 != 0)
{
if (VAR206[VAR212].VAR47 == VAR14)
{
return
(
(VAR158[VAR14].VAR36).FUN41( ((VAR206[VAR212].VAR52).FUN38(48)) / 100 ),
(VAR158[VAR14].VAR37).FUN41(  FUN114(VAR14, VAR212).FUN40(VAR205[VAR14][VAR212].VAR44)   ),
VAR158[VAR14].VAR38
);
} else {
return
(
VAR158[VAR14].VAR36,
(VAR158[VAR14].VAR37).FUN41(  FUN114(VAR14, VAR212).FUN40(VAR205[VAR14][VAR212].VAR44)  ),
VAR158[VAR14].VAR38
);
}
} else {
return
(
VAR158[VAR14].VAR36,
(VAR158[VAR14].VAR37).FUN41(FUN115(VAR14, VAR158[VAR14].VAR39)),
VAR158[VAR14].VAR38
);
}
}
function FUN114(uint256 VAR14, uint256 VAR212)
private
view
returns(uint256)
{
return(  ((((VAR206[VAR212].VAR44).FUN41(((((VAR206[VAR212].VAR52).FUN38(VAR209[VAR206[VAR212].VAR48].VAR37)) / 100).FUN38(1000000000000000000)) / (VAR206[VAR212].VAR43))).FUN38(VAR205[VAR14][VAR212].VAR43)) / 1000000000000000000)  );
}
function FUN116()
public
view
returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)
{
uint256 VAR212 = VAR204;
return
(
VAR206[VAR212].VAR45,
VAR212,
VAR206[VAR212].VAR43,
VAR206[VAR212].VAR49,
VAR206[VAR212].VAR51,
VAR206[VAR212].VAR52,
(VAR206[VAR212].VAR48 + (VAR206[VAR212].VAR47 * 10)),
VAR158[VAR206[VAR212].VAR47].VAR34,
VAR158[VAR206[VAR212].VAR47].VAR35,
VAR207[VAR212][0],
VAR207[VAR212][1],
VAR207[VAR212][2],
VAR207[VAR212][3],
VAR203 + (VAR202 * 1000)
);
}
function FUN117(address VAR7)
public
view
returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)
{
uint256 VAR212 = VAR204;
if (VAR7 == address(0))
{
VAR7 == msg.sender;
}
uint256 VAR14 = VAR156[VAR7];
return
(
VAR14,
VAR158[VAR14].VAR35,
VAR205[VAR14][VAR212].VAR43,
VAR158[VAR14].VAR36,
(VAR158[VAR14].VAR37).FUN41(FUN115(VAR14, VAR158[VAR14].VAR39)),
VAR158[VAR14].VAR38,
VAR205[VAR14][VAR212].VAR42
);
}
function FUN99(uint256 VAR14, uint256 VAR167, uint256 VAR211, VAR22.EventReturns memory VAR210)
private
{
uint256 VAR212 = VAR204;
uint256 VAR213 = VAR171;
if (VAR213 > VAR206[VAR212].VAR51 + VAR196 && (VAR213 <= VAR206[VAR212].VAR49 || (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR47 == 0)))
{
FUN118(VAR212, VAR14, msg.value, VAR167, VAR211, VAR210);
} else {
if (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR50 == false)
{
VAR206[VAR212].VAR50 = true;
VAR210 = FUN108(VAR210);
VAR210.VAR24 = VAR210.VAR24 + (VAR213 * 1000000000000000000);
VAR210.VAR25 = VAR210.VAR25 + VAR14;
emit VAR108.VAR126
(
msg.sender,
VAR158[VAR14].VAR35,
msg.value,
VAR210.VAR24,
VAR210.VAR25,
VAR210.VAR26,
VAR210.VAR27,
VAR210.VAR28,
VAR210.VAR29,
VAR210.VAR30,
VAR210.VAR31
);
}
VAR158[VAR14].VAR37 = VAR158[VAR14].VAR37.FUN41(msg.value);
}
}
function FUN105(uint256 VAR14, uint256 VAR167, uint256 VAR211, uint256 VAR100, VAR22.EventReturns memory VAR210)
private
{
uint256 VAR212 = VAR204;
uint256 VAR213 = VAR171;
if (VAR213 > VAR206[VAR212].VAR51 + VAR196 && (VAR213 <= VAR206[VAR212].VAR49 || (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR47 == 0)))
{
VAR158[VAR14].VAR37 = FUN109(VAR14).FUN40(VAR100);
FUN118(VAR212, VAR14, VAR100, VAR167, VAR211, VAR210);
} else if (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR50 == false) {
VAR206[VAR212].VAR50 = true;
VAR210 = FUN108(VAR210);
VAR210.VAR24 = VAR210.VAR24 + (VAR213 * 1000000000000000000);
VAR210.VAR25 = VAR210.VAR25 + VAR14;
emit VAR108.VAR127
(
msg.sender,
VAR158[VAR14].VAR35,
VAR210.VAR24,
VAR210.VAR25,
VAR210.VAR26,
VAR210.VAR27,
VAR210.VAR28,
VAR210.VAR29,
VAR210.VAR30,
VAR210.VAR31
);
}
}
function FUN118(uint256 VAR212, uint256 VAR14, uint256 VAR100, uint256 VAR167, uint256 VAR211, VAR22.EventReturns memory VAR210)
private
{
if (VAR205[VAR14][VAR212].VAR43 == 0)
VAR210 = FUN119(VAR14, VAR210);
if (VAR206[VAR212].VAR42 < 100000000000000000000 && VAR205[VAR14][VAR212].VAR42.FUN41(VAR100) > 1000000000000000000)
{
uint256 VAR218 = (1000000000000000000).FUN40(VAR205[VAR14][VAR212].VAR42);
uint256 VAR219 = VAR100.FUN40(VAR218);
VAR158[VAR14].VAR37 = VAR158[VAR14].VAR37.FUN41(VAR219);
VAR100 = VAR218;
}
if (VAR100 > 1000000000)
{
uint256 VAR101 = (VAR206[VAR212].VAR42).FUN56(VAR100);
if (VAR101 >= 1000000000000000000)
{
FUN120(VAR101, VAR212);
if (VAR206[VAR212].VAR47 != VAR14)
VAR206[VAR212].VAR47 = VAR14;
if (VAR206[VAR212].VAR48 != VAR211)
VAR206[VAR212].VAR48 = VAR211;
VAR210.VAR24 = VAR210.VAR24 + 100;
}
if (VAR100 >= 100000000000000000)
{
VAR203++;
if (FUN121() == true)
{
uint256 VAR220;
if (VAR100 >= 10000000000000000000)
{
VAR220 = ((VAR202).FUN38(75)) / 100;
VAR158[VAR14].VAR36 = (VAR158[VAR14].VAR36).FUN41(VAR220);
VAR202 = (VAR202).FUN40(VAR220);
VAR210.VAR24 += 300000000000000000000000000000000;
} else if (VAR100 >= 1000000000000000000 && VAR100 < 10000000000000000000) {
VAR220 = ((VAR202).FUN38(50)) / 100;
VAR158[VAR14].VAR36 = (VAR158[VAR14].VAR36).FUN41(VAR220);
VAR202 = (VAR202).FUN40(VAR220);
VAR210.VAR24 += 200000000000000000000000000000000;
} else if (VAR100 >= 100000000000000000 && VAR100 < 1000000000000000000) {
VAR220 = ((VAR202).FUN38(25)) / 100;
VAR158[VAR14].VAR36 = (VAR158[VAR14].VAR36).FUN41(VAR220);
VAR202 = (VAR202).FUN40(VAR220);
VAR210.VAR24 += 300000000000000000000000000000000;
}
VAR210.VAR24 += 10000000000000000000000000000000;
VAR210.VAR24 += VAR220 * 1000000000000000000000000000000000;
VAR203 = 0;
}
}
VAR210.VAR24 = VAR210.VAR24 + (VAR203 * 1000);
VAR205[VAR14][VAR212].VAR43 = VAR101.FUN41(VAR205[VAR14][VAR212].VAR43);
VAR205[VAR14][VAR212].VAR42 = VAR100.FUN41(VAR205[VAR14][VAR212].VAR42);
VAR206[VAR212].VAR43 = VAR101.FUN41(VAR206[VAR212].VAR43);
VAR206[VAR212].VAR42 = VAR100.FUN41(VAR206[VAR212].VAR42);
VAR207[VAR212][VAR211] = VAR100.FUN41(VAR207[VAR212][VAR211]);
VAR210 = FUN122(VAR212, VAR14, VAR100, VAR167, VAR211, VAR210);
VAR210 = FUN123(VAR212, VAR14, VAR100, VAR211, VAR101, VAR210);
FUN124(VAR14, VAR211, VAR100, VAR101, VAR210);
}
}
function FUN115(uint256 VAR14, uint256 VAR221)
private
view
returns(uint256)
{
return(  (((VAR206[VAR221].VAR44).FUN38(VAR205[VAR14][VAR221].VAR43)) / (1000000000000000000)).FUN40(VAR205[VAR14][VAR221].VAR44)  );
}
function FUN125(uint256 VAR212, uint256 VAR100)
public
view
returns(uint256)
{
uint256 VAR213 = VAR171;
if (VAR213 > VAR206[VAR212].VAR51 + VAR196 && (VAR213 <= VAR206[VAR212].VAR49 || (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR47 == 0)))
return ( (VAR206[VAR212].VAR42).FUN56(VAR100) );
else
return ( (VAR100).FUN57() );
}
function FUN126(uint256 VAR101)
public
view
returns(uint256)
{
uint256 VAR212 = VAR204;
uint256 VAR213 = VAR171;
if (VAR213 > VAR206[VAR212].VAR51 + VAR196 && (VAR213 <= VAR206[VAR212].VAR49 || (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR47 == 0)))
return ( (VAR206[VAR212].VAR43.FUN41(VAR101)).FUN58(VAR101) );
else
return ( (VAR101).FUN59() );
}
function FUN29(uint256 VAR14, address VAR7, bytes32 VAR15, uint256 VAR19)
external
{
require (msg.sender == address(VAR191), "");
if (VAR156[VAR7] != VAR14)
VAR156[VAR7] = VAR14;
if (VAR157[VAR15] != VAR14)
VAR157[VAR15] = VAR14;
if (VAR158[VAR14].VAR34 != VAR7)
VAR158[VAR14].VAR34 = VAR7;
if (VAR158[VAR14].VAR35 != VAR15)
VAR158[VAR14].VAR35 = VAR15;
if (VAR158[VAR14].VAR40 != VAR19)
VAR158[VAR14].VAR40 = VAR19;
if (VAR159[VAR14][VAR15] == false)
VAR159[VAR14][VAR15] = true;
}
function FUN30(uint256 VAR14, bytes32 VAR15)
external
{
require (msg.sender == address(VAR191), "");
if(VAR159[VAR14][VAR15] == false)
VAR159[VAR14][VAR15] = true;
}
function FUN77(VAR22.EventReturns memory VAR210)
private
returns (VAR22.VAR23)
{
uint256 VAR14 = VAR156[msg.sender];
if (VAR14 == 0)
{
VAR14 = VAR191.FUN21(msg.sender);
bytes32 VAR15 = VAR191.FUN22(VAR14);
uint256 VAR19 = VAR191.FUN23(VAR14);
VAR156[msg.sender] = VAR14;
VAR158[VAR14].VAR34 = msg.sender;
if (VAR15 != "")
{
VAR157[VAR15] = VAR14;
VAR158[VAR14].VAR35 = VAR15;
VAR159[VAR14][VAR15] = true;
}
if (VAR19 != 0 && VAR19 != VAR14)
VAR158[VAR14].VAR40 = VAR19;
VAR210.VAR24 = VAR210.VAR24 + 1;
}
return (VAR210);
}
function FUN101(uint256 VAR211)
private
pure
returns (uint256)
{
if (VAR211 < 0 || VAR211 > 3)
return(2);
else
return(VAR211);
}
function FUN119(uint256 VAR14, VAR22.EventReturns memory VAR210)
private
returns (VAR22.VAR23)
{
if (VAR158[VAR14].VAR39 != 0)
FUN127(VAR14, VAR158[VAR14].VAR39);
VAR158[VAR14].VAR39 = VAR204;
VAR210.VAR24 = VAR210.VAR24 + 10;
return(VAR210);
}
function FUN108(VAR22.EventReturns memory VAR210)
private
returns (VAR22.VAR23)
{
uint256 VAR212 = VAR204;
uint256 VAR222 = VAR206[VAR212].VAR47;
uint256 VAR223 = VAR206[VAR212].VAR48;
uint256 VAR224 = VAR206[VAR212].VAR52;
uint256 VAR225 = (VAR224.FUN38(48)) / 100;
uint256 VAR226 = (VAR224 / 50);
uint256 VAR227 = (VAR224.FUN38(VAR209[VAR223].VAR37)) / 100;
uint256 VAR228 = (VAR224.FUN38(VAR209[VAR223].VAR56)) / 100;
uint256 VAR229 = (((VAR224.FUN40(VAR225)).FUN40(VAR226)).FUN40(VAR227)).FUN40(VAR228);
uint256 VAR230 = (VAR227.FUN38(1000000000000000000)) / (VAR206[VAR212].VAR43);
uint256 VAR231 = VAR227.FUN40((VAR230.FUN38(VAR206[VAR212].VAR43)) / 1000000000000000000);
if (VAR231 > 0)
{
VAR227 = VAR227.FUN40(VAR231);
VAR229 = VAR229.FUN41(VAR231);
}
VAR158[VAR222].VAR36 = VAR225.FUN41(VAR158[VAR222].VAR36);
if (!address(VAR190).call.value(VAR226)(bytes4(FUN50(""))))
{
VAR228 = VAR228.FUN41(VAR226);
VAR226 = 0;
}
VAR206[VAR212].VAR44 = VAR230.FUN41(VAR206[VAR212].VAR44);
if (VAR228 > 0){
VAR190.VAR138.value(VAR228)();
}
VAR210.VAR24 = VAR210.VAR24 + (VAR206[VAR212].VAR49 * 1000000);
VAR210.VAR25 = VAR210.VAR25 + (VAR222 * 100000000000000000000000000) + (VAR223 * 100000000000000000);
VAR210.VAR26 = VAR158[VAR222].VAR34;
VAR210.VAR27 = VAR158[VAR222].VAR35;
VAR210.VAR28 = VAR225;
VAR210.VAR31 = VAR227;
VAR210.VAR30 = VAR228;
VAR210.VAR29 = VAR229;
VAR204++;
VAR212++;
VAR206[VAR212].VAR51 = VAR171;
VAR206[VAR212].VAR49 = VAR171.FUN41(VAR197).FUN41(VAR196);
VAR206[VAR212].VAR52 = VAR229;
return(VAR210);
}
function FUN127(uint256 VAR14, uint256 VAR221)
private
{
uint256 VAR232 = FUN115(VAR14, VAR221);
if (VAR232 > 0)
{
VAR158[VAR14].VAR37 = VAR232.FUN41(VAR158[VAR14].VAR37);
VAR205[VAR14][VAR221].VAR44 = VAR232.FUN41(VAR205[VAR14][VAR221].VAR44);
}
}
function FUN120(uint256 VAR101, uint256 VAR212)
private
{
uint256 VAR213 = VAR171;
uint256 VAR233;
if (VAR213 > VAR206[VAR212].VAR49 && VAR206[VAR212].VAR47 == 0)
VAR233 = (((VAR101) / (1000000000000000000)).FUN38(VAR199)).FUN41(VAR213);
else
VAR233 = (((VAR101) / (1000000000000000000)).FUN38(VAR199)).FUN41(VAR206[VAR212].VAR49);
if (VAR233 < (VAR201).FUN41(VAR213))
VAR206[VAR212].VAR49 = VAR233;
else
VAR206[VAR212].VAR49 = VAR201.FUN41(VAR213);
}
function FUN121()
private
view
returns(bool)
{
uint256 VAR234 = uint256(FUN50(VAR90.FUN52(
(VAR235.VAR236).VAR237
(VAR235.VAR238).VAR237
((uint256(FUN50(VAR90.FUN52(VAR235.VAR239)))) / (VAR171)).VAR237
(VAR235.VAR240).VAR237
((uint256(FUN50(VAR90.FUN52(msg.sender)))) / (VAR171)).VAR237
(VAR235.VAR241)
)));
if((VAR234 - ((VAR234 / 1000) * 1000)) < VAR203)
return(true);
else
return(false);
}
function FUN122(uint256 VAR212, uint256 VAR14, uint256 VAR100, uint256 VAR167, uint256 VAR211, VAR22.EventReturns memory VAR210)
private
returns(VAR22.VAR23)
{
uint256 VAR226 = VAR100 / 50;
uint256 VAR228;
if (!address(VAR190).call.value(VAR226)(bytes4(FUN50(""))))
{
VAR228 = VAR226;
VAR226 = 0;
}
uint256 VAR242 = VAR100 / 100;
VAR189.VAR243.value(VAR242)();
uint256 VAR244 = VAR100 / 10;
if (VAR167 != VAR14 && VAR158[VAR167].VAR35 != '') {
VAR158[VAR167].VAR38 = VAR244.FUN41(VAR158[VAR167].VAR38);
emit VAR108.FUN128(VAR167, VAR158[VAR167].VAR34, VAR158[VAR167].VAR35, VAR212, VAR14, VAR244, VAR171);
} else {
VAR228 = VAR244;
}
VAR228 = VAR228.FUN41((VAR100.FUN38(VAR208[VAR211].VAR56)) / (100));
if (VAR228 > 0)
{
VAR190.VAR138.value(VAR228)();
VAR210.VAR30 = VAR228.FUN41(VAR210.VAR30);
}
return(VAR210);
}
function FUN20()
external
payable
{
uint256 VAR212 = VAR204 + 1;
VAR206[VAR212].VAR52 = VAR206[VAR212].VAR52.FUN41(msg.value);
emit VAR108.FUN129(VAR212, msg.value);
}
function FUN123(uint256 VAR212, uint256 VAR14, uint256 VAR100, uint256 VAR211, uint256 VAR101, VAR22.EventReturns memory VAR210)
private
returns(VAR22.VAR23)
{
uint256 VAR227 = (VAR100.FUN38(VAR208[VAR211].VAR37)) / 100;
uint256 VAR245 = (VAR100 / 100);
VAR202 = VAR202.FUN41(VAR245);
VAR100 = VAR100.FUN40(((VAR100.FUN38(14)) / 100).FUN41((VAR100.FUN38(VAR208[VAR211].VAR56)) / 100));
uint256 VAR224 = VAR100.FUN40(VAR227);
uint256 VAR231 = FUN130(VAR212, VAR14, VAR227, VAR101);
if (VAR231 > 0)
VAR227 = VAR227.FUN40(VAR231);
VAR206[VAR212].VAR52 = VAR224.FUN41(VAR231).FUN41(VAR206[VAR212].VAR52);
VAR210.VAR31 = VAR227.FUN41(VAR210.VAR31);
VAR210.VAR32 = VAR224;
return(VAR210);
}
function FUN130(uint256 VAR212, uint256 VAR14, uint256 VAR227, uint256 VAR101)
private
returns(uint256)
{
uint256 VAR230 = (VAR227.FUN38(1000000000000000000)) / (VAR206[VAR212].VAR43);
VAR206[VAR212].VAR44 = VAR230.FUN41(VAR206[VAR212].VAR44);
uint256 VAR246 = (VAR230.FUN38(VAR101)) / (1000000000000000000);
VAR205[VAR14][VAR212].VAR44 = (((VAR206[VAR212].VAR44.FUN38(VAR101)) / (1000000000000000000)).FUN40(VAR246)).FUN41(VAR205[VAR14][VAR212].VAR44);
return(VAR227.FUN40((VAR230.FUN38(VAR206[VAR212].VAR43)) / (1000000000000000000)));
}
function FUN109(uint256 VAR14)
private
returns(uint256)
{
FUN127(VAR14, VAR158[VAR14].VAR39);
uint256 VAR232 = (VAR158[VAR14].VAR36).FUN41(VAR158[VAR14].VAR37).FUN41(VAR158[VAR14].VAR38);
if (VAR232 > 0)
{
VAR158[VAR14].VAR36 = 0;
VAR158[VAR14].VAR37 = 0;
VAR158[VAR14].VAR38 = 0;
}
return(VAR232);
}
function FUN124(uint256 VAR14, uint256 VAR211, uint256 VAR100, uint256 VAR101, VAR22.EventReturns memory VAR210)
private
{
VAR210.VAR24 = VAR210.VAR24 + (VAR171 * 1000000000000000000) + (VAR211 * 100000000000000000000000000000);
VAR210.VAR25 = VAR210.VAR25 + VAR14 + (VAR204 * 10000000000000000000000000000000000000000000000000000);
emit VAR108.VAR119
(
VAR210.VAR24,
VAR210.VAR25,
VAR158[VAR14].VAR35,
msg.sender,
VAR100,
VAR101,
VAR210.VAR26,
VAR210.VAR27,
VAR210.VAR28,
VAR210.VAR29,
VAR210.VAR30,
VAR210.VAR31,
VAR210.VAR32,
VAR202
);
}
function FUN131()
public
{
require(
msg.sender == VAR141, ""
);
require(address(VAR189) != address(0), "");
require(VAR192 == false, "");
VAR192 = true;
VAR204 = 1;
VAR206[1].VAR51 = VAR171 + VAR194 - VAR196;
VAR206[1].VAR49 = VAR171 + VAR197 + VAR194;
}
function FUN132(address VAR247)
public
{
require(
msg.sender == VAR141, ""
);
require(address(VAR189) == address(0), "");
VAR189 = FUN133(VAR247);
}
}
1
---------------------------------
4 0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol
pragma VAR1 ^0.4.19;
contract VAR2
{
mapping (address=>uint256) public VAR3;
uint public VAR4 = 1 VAR5;
LogFile VAR6 = FUN1(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);
bool VAR7;
function FUN2(uint VAR8)
public
{
if(VAR7)revert();
VAR4 = VAR8;
}
function FUN3(address VAR9)
public
{
if(VAR7)revert();
VAR6 = FUN1(VAR9);
}
function FUN4()
public
{
VAR7 = true;
}
function FUN5()
public
payable
{
VAR3[msg.sender]+= msg.value;
VAR6.FUN6(msg.sender,msg.value,"");
}
function FUN7(uint VAR10)
public
payable
{
if(VAR3[msg.sender]>=VAR4 && VAR3[msg.sender]>=VAR10)
{
if(msg.sender.call.value(VAR10)())
{
VAR3[msg.sender]-=VAR10;
VAR6.FUN6(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN5();
}
}
contract VAR11
{
struct VAR12
{
address VAR13;
string  VAR14;
uint VAR15;
uint  VAR16;
}
VAR12[] public VAR17;
Message VAR18;
function FUN6(address VAR19,uint VAR8,string VAR20)
public
{
VAR18.VAR13 = VAR19;
VAR18.VAR16 = VAR21;
VAR18.VAR15 = VAR8;
VAR18.VAR14 = VAR20;
VAR17.FUN8(VAR18);
}
}
1
---------------------------------
5 0x03358425ada4620246dd703dc1f2246b8e148d22.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function FUN1() public constant returns (uint256);
function FUN2(address VAR3) public constant returns (uint256 VAR4);
function FUN3(address VAR3, address VAR5) public constant returns (uint256 VAR6);
function transfer(address VAR7, uint256 VAR8) public returns (bool VAR9);
function FUN4(address VAR5, uint256 VAR8) public returns (bool VAR9);
function FUN5(address VAR10, address VAR7, uint256 VAR8) public returns (bool VAR9);
event Transfer(address indexed VAR10, address indexed VAR7, uint VAR8);
event FUN6(address indexed VAR3, address indexed VAR5, uint VAR8);
}
contract VAR11 {
function FUN7(address) public payable returns(uint256){}
function FUN8() public {}
}
contract VAR12 {
address public VAR13;
address public VAR14;
function FUN9() public {
VAR13 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR13);
VAR15;
}
function FUN10(address VAR16) public onlyOwner {
VAR14 = VAR16;
}
function FUN11() public {
require(msg.sender == VAR14);
VAR13 = VAR14;
}
}
contract BoomerangLiquidity is VAR12 {
modifier onlyOwner(){
require(msg.sender == VAR13);
VAR15;
}
modifier FUN12(address VAR17){
require(VAR17 != VAR18);
VAR15;
}
uint public VAR19;
uint public VAR20 = 0;
address VAR18;
POWH VAR21;
function FUN13(uint VAR22, address VAR23) public {
VAR19 = VAR22;
VAR18 = VAR23;
VAR21 = FUN14(VAR18);
}
struct VAR24 {
address VAR25;
uint VAR26;
}
VAR24[] public VAR27;
function() payable public {
}
function FUN15() payable public {
VAR27.FUN16(FUN17(msg.sender, (msg.value * VAR19) / 100));
FUN18();
}
function FUN18() public {
uint VAR4 = address(this).VAR4;
require(VAR4 > 1);
uint VAR28 = VAR4 / 2;
VAR4 -= VAR28;
VAR21.VAR29.value(VAR28).FUN19(1000000)(msg.sender);
while (VAR4 > 0) {
uint VAR30 = VAR4 < VAR27[VAR20].VAR26 ? VAR4 : VAR27[VAR20].VAR26;
if(VAR30 > 0){
VAR27[VAR20].VAR26 -= VAR30;
VAR4 -= VAR30;
if(!VAR27[VAR20].VAR25.FUN20(VAR30)){
VAR27[VAR20].VAR25.call.value(VAR30).FUN19(1000000)();
}
}
if(VAR4 > 0){
VAR20 += 1;
}
if(VAR20 >= VAR27.VAR31){
return;
}
}
}
function FUN8() public {
VAR21.VAR32.FUN19(1000000)();
}
function FUN21() payable public {
}
function FUN22(address VAR33, uint VAR8) public onlyOwner FUN12(VAR33) returns (bool VAR9) {
return FUN23(VAR33).transfer(VAR13, VAR8);
}
}
1
---------------------------------
6 0x04666cdf77621dbee1b21988739dd3c12620a719.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
uint256 public VAR3;
function FUN1(address VAR4) constant returns (uint256);
function transfer(address VAR5, uint256 value) returns (bool);
event Transfer(address indexed VAR6, address indexed VAR5, uint256 value);
}
contract VAR7 {
uint256 public VAR8;
function FUN2(bytes32 VAR9) payable returns(bool);
function FUN3(bytes32 VAR9 , address VAR10) returns(bool);
function FUN4(bytes32 VAR9 , bytes32 VAR11 , uint VAR12 , bool VAR13) returns(bool);
function FUN5(bytes32 VAR9 , bytes32 VAR11) constant returns(uint);
event FUN6(string VAR14);
event FUN7(address VAR15 , bytes32 VAR9);
event FUN8(bytes32 VAR9 , address VAR16 , address VAR17);
}
contract VAR18 {
function FUN9(bytes32 VAR19) returns(bool);
event FUN10(address VAR20,address VAR10);
}
contract VAR21 {
string public VAR22;
address public VAR23;
address public VAR24;
uint public VAR25;
bool VAR26;
address VAR27;
bytes32 public VAR28;
uint public VAR29;
GlobalStorageMultiId public VAR30;
event FUN11(address indexed VAR6);
event FUN10(address VAR20,address VAR10);
event FUN12(address indexed VAR15,uint256 VAR31);
modifier onlyAdmin() {
if ( msg.sender != VAR23 && msg.sender != VAR24 ) revert();
VAR32;
}
modifier onlyOwner() {
if ( msg.sender != VAR24 ) revert();
VAR32;
}
constructor() {
VAR25 = 0.01 VAR33;
VAR23 = msg.sender;
VAR24 = 0xc238ff50c09787e7b920f711850dd945a40d3232;
VAR22 = "";
VAR27 = 0x8f49722c61a9398a1c5f5ce6e5feeef852831a64;
VAR29 = 2;
VAR30 = FUN13(VAR27);
}
function FUN14() onlyAdmin constant returns(uint) {
return VAR30.FUN15();
}
function FUN16(bytes32 VAR19) onlyAdmin payable {
require(!VAR26);
uint VAR31 = VAR30.FUN15();
VAR28 = VAR19;
VAR30.VAR34.value(VAR31)(VAR19);
VAR26 = true;
}
function FUN17(address VAR10) onlyAdmin {
UpgDocs VAR35 = FUN18(VAR10);
require(VAR35.FUN9(VAR28));
VAR30.FUN3(VAR28,VAR10);
VAR10.FUN19(this.VAR36);
}
function FUN9(bytes32 VAR19) returns(bool) {
require(!VAR26);
VAR28 = VAR19;
VAR26 = true;
emit FUN10(msg.sender,this);
return true;
}
function FUN20(address VAR37) onlyOwner returns(bool){
VAR24 = VAR37;
return true;
}
function FUN21(address VAR38) onlyOwner returns(bool) {
VAR23 = VAR38;
return true;
}
function FUN22(address VAR39,address VAR40 , uint VAR31) onlyOwner returns(bool) {
ERC20Basic VAR41 = FUN23(VAR39);
require(VAR41.transfer(VAR40, VAR31));
return true;
}
function FUN24(uint VAR42) onlyAdmin public {
VAR29 = VAR42;
}
function FUN25(uint VAR43) onlyAdmin public {
VAR25 = VAR43;
}
function() payable public {
uint VAR44 = FUN5(msg.sender);
FUN4(msg.sender, VAR44 + msg.value);
VAR23.FUN19(msg.value * VAR29 / 100);
VAR24.FUN19(this.VAR36);
emit FUN12(msg.sender, msg.value);
}
function FUN26(address[] VAR45, uint VAR46) onlyAdmin public returns (bool VAR47) {
for (uint8 VAR48=0; VAR48<VAR45.VAR49; VAR48++){
uint VAR44 = FUN5(VAR45[VAR48]);
FUN4(VAR45[VAR48], VAR44 + VAR46);
emit FUN12(VAR45[VAR48],VAR46);
}
}
function FUN27(address VAR15) constant returns(uint) {
return FUN5(VAR15);
}
function FUN28(address VAR15, string VAR50) onlyAdmin returns (bool VAR47) {
uint VAR44 = FUN5(VAR15);
require(VAR44 >= VAR25);
FUN4(VAR15, VAR44 - VAR25);
emit FUN11(VAR15);
return true;
}
function FUN29() constant returns(uint) {
return VAR25;
}
function FUN4(address VAR15, uint VAR31) internal {
VAR30.FUN4(VAR28, bytes32(VAR15), VAR31, true);
}
function FUN5(address VAR15) internal constant returns(uint) {
return VAR30.FUN5(VAR28, bytes32(VAR15));
}
}
1
---------------------------------
7 0x0529663bd4d73d3dd06f90247d8c2e802755b7ec.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 2 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
8 0x06adba5ad6c494e536cad8afa1129ab9f7cb99bf.sol
pragma VAR1 ^0.4.21;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
uint256 public VAR7;
uint256 public VAR8;
function FUN5(address VAR9) public;
function FUN6() payable public;
function FUN7() public view returns(uint256);
}
contract VAR10 {
function FUN8(uint256 VAR11, address VAR12) public;
function FUN9() payable public;
function FUN10(uint256 VAR13) public;
function FUN11() public view returns(uint256);
}
contract VAR14 {
function FUN12() constant public returns (uint VAR15);
function FUN13(address VAR16) constant public returns (uint VAR17);
function transfer(address VAR18, uint VAR19) public returns (bool VAR20);
function FUN14(address VAR21, address VAR18, uint VAR19) public returns (bool VAR20);
function FUN15(address VAR22, uint VAR19) public returns (bool VAR20);
function FUN16(address VAR16, address VAR22) constant public returns (uint VAR23);
event Transfer(address indexed VAR21, address indexed VAR18, uint VAR19);
event FUN17(address indexed VAR16, address indexed VAR22, uint VAR19);
}
contract EOSBetBankroll is VAR14, VAR10 {
using SafeMath for *;
address public VAR24;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR7;
mapping(address => bool) public VAR27;
address public VAR28;
address public VAR29;
mapping(address => uint256) VAR30;
string public constant VAR31 = "";
string public constant VAR32 = "";
uint8 public constant VAR33 = 18;
uint256 public VAR34;
mapping(address => uint256) public VAR35;
mapping(address => mapping(address => uint256)) public VAR36;
event FUN18(address VAR37, uint256 VAR38, uint256 VAR39);
event FUN19(address VAR37, uint256 VAR40, uint256 VAR41);
event FUN20(address VAR42, uint256 VAR43);
modifier FUN21(address VAR44){
require(VAR27[VAR44]);
VAR45;
}
function FUN22(address VAR46, address VAR47) public payable {
require (msg.value > 0);
VAR24 = msg.sender;
uint256 VAR48 = msg.value * 100;
VAR35[msg.sender] = VAR48;
VAR34 = VAR48;
emit Transfer(0x0, msg.sender, VAR48);
VAR27[VAR46] = true;
VAR27[VAR47] = true;
VAR28 = VAR46;
VAR29 = VAR47;
VAR26 = 6 VAR49;
VAR25 = 500 VAR50;
}
function FUN23(address VAR51) view public returns(uint256){
return VAR30[VAR51];
}
function FUN11() view public returns(uint256){
return VAR2.FUN3(address(this).VAR17, VAR7);
}
function FUN8(uint256 VAR11, address VAR12) public FUN21(msg.sender){
if (! VAR12.FUN24(VAR11)){
emit FUN20(VAR12, VAR11);
if (! VAR24.FUN24(VAR11)){
emit FUN20(VAR24, VAR11);
}
}
}
function FUN9() payable public FUN21(msg.sender){
}
function FUN10(uint256 VAR13) public FUN21(msg.sender){
FUN25(msg.sender).VAR52.value(VAR13)();
}
function () public payable {
uint256 VAR53 = VAR2.FUN3(FUN11(), msg.value);
uint256 VAR54 = VAR25;
require(VAR53 < VAR54 && msg.value != 0);
uint256 VAR55 = VAR34;
uint256 VAR56;
bool VAR57;
uint256 VAR58;
uint256 VAR59;
if (VAR2.FUN4(VAR53, msg.value) > VAR54){
VAR57 = true;
VAR56 = VAR2.FUN3(VAR54, VAR53);
VAR58 = VAR2.FUN3(msg.value, VAR56);
}
else {
VAR56 = msg.value;
}
if (VAR55 != 0){
VAR59 = VAR2.FUN1(VAR56, VAR55) / VAR53;
}
else {
VAR59 = VAR2.FUN1(VAR56, 100);
}
VAR34 = VAR2.FUN4(VAR55, VAR59);
VAR35[msg.sender] = VAR2.FUN4(VAR35[msg.sender], VAR59);
VAR30[msg.sender] = VAR60.VAR61;
if (VAR57){
msg.sender.transfer(VAR58);
}
emit FUN18(msg.sender, VAR56, VAR59);
emit Transfer(0x0, msg.sender, VAR59);
}
function FUN26(uint256 VAR62) public {
uint256 VAR63 = VAR35[msg.sender];
require(VAR62 <= VAR63
&& VAR30[msg.sender] + VAR26 <= VAR60.VAR61
&& VAR62 > 0);
uint256 VAR53 = FUN11();
uint256 VAR55 = VAR34;
uint256 VAR64 = VAR2.FUN1(VAR62, VAR53) / VAR55;
uint256 VAR65 = VAR64 / 100;
uint256 VAR66 = VAR2.FUN3(VAR64, VAR65);
VAR34 = VAR2.FUN3(VAR55, VAR62);
VAR35[msg.sender] = VAR2.FUN3(VAR63, VAR62);
VAR7 = VAR2.FUN4(VAR7, VAR65);
msg.sender.transfer(VAR66);
emit FUN19(msg.sender, VAR66, VAR62);
emit Transfer(msg.sender, 0x0, VAR62);
}
function FUN27() public {
FUN26(VAR35[msg.sender]);
}
function FUN28(address VAR67) public {
require(msg.sender == VAR24);
VAR24 = VAR67;
}
function FUN29(uint256 VAR68) public {
require (msg.sender == VAR24 && VAR68 <= 6048000);
VAR26 = VAR68;
}
function FUN30(uint256 VAR69) public {
require(msg.sender == VAR24);
VAR25 = VAR69;
}
function FUN31(address VAR70) public {
require(msg.sender == VAR24);
FUN25(VAR28).FUN5(VAR70);
FUN25(VAR29).FUN5(VAR70);
uint256 VAR71 = VAR7;
VAR7 = 0;
VAR70.transfer(VAR71);
}
function FUN32(address VAR72, uint256 VAR73) public {
require (msg.sender == VAR24);
FUN33(VAR72).transfer(msg.sender, VAR73);
}
function FUN12() constant public returns(uint){
return VAR34;
}
function FUN13(address VAR16) constant public returns(uint){
return VAR35[VAR16];
}
function transfer(address VAR18, uint256 VAR19) public returns (bool VAR20){
require(VAR35[msg.sender] >= VAR19
&& VAR30[msg.sender] + VAR26 <= VAR60.VAR61
&& VAR18 != address(this)
&& VAR18 != address(0));
VAR35[msg.sender] = VAR2.FUN3(VAR35[msg.sender], VAR19);
VAR35[VAR18] = VAR2.FUN4(VAR35[VAR18], VAR19);
emit Transfer(msg.sender, VAR18, VAR19);
return true;
}
function FUN14(address VAR21, address VAR18, uint VAR19) public returns(bool){
require(VAR36[VAR21][msg.sender] >= VAR19
&& VAR35[VAR21] >= VAR19
&& VAR30[VAR21] + VAR26 <= VAR60.VAR61
&& VAR18 != address(this)
&& VAR18 != address(0));
VAR35[VAR18] = VAR2.FUN4(VAR35[VAR18], VAR19);
VAR35[VAR21] = VAR2.FUN3(VAR35[VAR21], VAR19);
VAR36[VAR21][msg.sender] = VAR2.FUN3(VAR36[VAR21][msg.sender], VAR19);
emit Transfer(VAR21, VAR18, VAR19);
return true;
}
function FUN15(address VAR22, uint VAR19) public returns(bool){
VAR36[msg.sender][VAR22] = VAR19;
emit FUN17(msg.sender, VAR22, VAR19);
return true;
}
function FUN16(address VAR16, address VAR22) constant public returns(uint){
return VAR36[VAR16][VAR22];
}
}
1
---------------------------------
9 0x08f7e145df8b9a10a40674d7ed8396a3a9eae650.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address[] public VAR3;
address[] public VAR4;
address[] public VAR5;
address public VAR6;
mapping(address => uint) private VAR7;
uint public VAR8 = 0;
uint public VAR9 = 0;
modifier FUN1() {
require(msg.sender == VAR6);
VAR10;
}
constructor () public {
VAR6 = msg.sender;
}
function FUN2 (uint VAR11, uint VAR12, string VAR13, address VAR14) public adminOnly payable {
VAR8 ++;
address VAR15 = VAR16 FUN3(VAR8, VAR11, VAR12, VAR13, VAR14);
VAR3.FUN4(VAR15);
VAR7[VAR15] = VAR3.VAR17;
FUN5(VAR15, msg.value);
}
function FUN6() public view returns (address[]) {
return VAR3;
}
function FUN7() public view returns (address[]) {
return VAR4;
}
function FUN5(address VAR18, uint VAR19) adminOnly public {
if (VAR19 > 0) {
MajorityGame VAR20 = FUN3(VAR18);
VAR20.VAR21.value(VAR19)();
}
}
function FUN8(address VAR18) public {
uint VAR22 = VAR7[address(VAR18)];
VAR9++;
VAR4.FUN4(VAR18);
VAR3[VAR22-1] = VAR3[VAR3.VAR17-1];
VAR7[VAR3[VAR3.VAR17-1]] = VAR22;
delete VAR3[VAR3.VAR17-1];
VAR3.VAR17--;
MajorityGame VAR20 = FUN3(address(VAR18));
VAR20.FUN8();
}
function FUN9(address VAR18) public VAR23 {
uint VAR22 = VAR7[address(VAR18)];
VAR9++;
VAR4.FUN4(VAR18);
VAR3[VAR22-1] = VAR3[VAR3.VAR17-1];
VAR7[VAR3[VAR3.VAR17-1]] = VAR22;
delete VAR3[VAR3.VAR17-1];
VAR3.VAR17--;
MajorityGame VAR20 = FUN3(address(VAR18));
VAR20.FUN9();
}
}
contract VAR24 {
uint constant private VAR25 = 50000000000000000;
uint constant private VAR26 = 50000000000000000;
uint public VAR27;
uint private VAR28;
uint private VAR29;
address public VAR6;
address public VAR30;
uint private VAR31;
string private VAR32;
mapping(address => bool) private VAR33;
uint public VAR34;
mapping(address => bool) private VAR35;
mapping(address => bool) private VAR36;
address[] private VAR37;
address[] private VAR38;
address[] private VAR39;
uint private VAR40;
uint private VAR41;
uint private VAR42;
modifier FUN1() {
require(msg.sender == VAR6);
VAR10;
}
modifier FUN10() {
require(VAR43 <= VAR31);
VAR10;
}
modifier FUN11() {
require(VAR43 > VAR31);
VAR10;
}
modifier FUN12() {
require(VAR40 == 0);
VAR10;
}
modifier FUN13() {
require(VAR40 > 0);
VAR10;
}
constructor(uint VAR44, uint VAR11, uint VAR12, string VAR13, address VAR14) public {
VAR27 = VAR44;
VAR6 = msg.sender;
VAR29 = VAR11;
VAR31 = VAR12;
VAR32 = VAR13;
VAR34 = 0;
VAR40 = 0;
VAR42 = 0;
VAR30 = VAR14;
}
function FUN5() public payable adminOnly returns (bool) {
if (msg.value > 0) {
VAR28 += msg.value;
return true;
}
return false;
}
function FUN14() public view returns (uint, uint, uint, uint, uint, uint, uint) {
return (
VAR31,
VAR31,
VAR34,
address(this).VAR45,
VAR28,
VAR40,
VAR29
);
}
function FUN15() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) {
return (
VAR27,
VAR31,
VAR31,
VAR34,
address(this).VAR45,
VAR32,
VAR28,
VAR40,
VAR29
);
}
function FUN16(uint VAR46) public payable notEnded VAR47 {
require(!VAR33[msg.sender]);
require(msg.value == VAR29);
VAR33[msg.sender] = true;
VAR34++;
if (VAR46 == 1) {
VAR35[msg.sender] = true;
VAR37.FUN4(msg.sender);
} else if (VAR46 == 2) {
VAR36[msg.sender] = true;
VAR38.FUN4(msg.sender);
}
}
function FUN8() public VAR48 {
require(VAR40 == 0);
VAR41 = address(this).VAR45;
uint VAR49 = uint(VAR41 * 9 / 10);
uint VAR50 = VAR37.VAR17;
uint VAR51 = VAR38.VAR17;
if (VAR50 > VAR51 || (VAR50 == VAR51 && VAR27 % 2 == 1)) {
VAR42 = VAR50 == 0 ? 0 : uint(VAR49 / VAR50);
VAR40 = 1;
VAR39 = VAR37;
} else if (VAR51 > VAR50 || (VAR50 == VAR51 && VAR27 % 2 == 0)) {
VAR42 = VAR51 == 0 ? 0 : uint(VAR49 / VAR51);
VAR40 = 2;
VAR39 = VAR38;
}
}
function FUN9() public VAR23 {
require(VAR40 == 0);
VAR41 = address(this).VAR45;
uint VAR49 = uint(VAR41 * 9 / 10);
uint VAR50 = VAR37.VAR17;
uint VAR51 = VAR38.VAR17;
if (VAR50 > VAR51 || (VAR50 == VAR51 && VAR27 % 2 == 1)) {
VAR42 = VAR50 == 0 ? 0 : uint(VAR49 / VAR50);
VAR40 = 1;
VAR39 = VAR37;
} else if (VAR51 > VAR50 || (VAR50 == VAR51 && VAR27 % 2 == 0)) {
VAR42 = VAR51 == 0 ? 0 : uint(VAR49 / VAR51);
VAR40 = 2;
VAR39 = VAR38;
}
}
function FUN17() public VAR52 {
require(VAR39.VAR17 > 0);
uint VAR53 = VAR39.VAR17;
if (VAR53 > 250) {
for (uint VAR54 = 0; VAR54 < 250; VAR54++) {
this.FUN18();
}
} else {
for (uint VAR55 = 0; VAR55 < VAR53; VAR55++) {
this.FUN18();
}
}
}
function FUN18() public VAR52 {
address(VAR39[VAR39.VAR17 - 1]).transfer(VAR42);
delete VAR39[VAR39.VAR17 - 1];
VAR39.VAR17--;
if(VAR39.VAR17 == 0){
address VAR56=address(VAR30);
address(VAR56).transfer(address(this).VAR45);
}
}
function FUN19() public isEnded view returns (uint, uint, uint, uint, uint) {
return (
VAR40,
VAR37.VAR17,
VAR38.VAR17,
VAR41,
VAR42
);
}
function FUN20() public view returns (uint) {
if (VAR35[msg.sender]) {
return 1;
} else if (VAR36[msg.sender]) {
return 2;
} else {
return 0;
}
}
function FUN21() public isEnded view returns (address[]) {
if (VAR40 == 1) {
return VAR37;
}else {
return VAR38;
}
}
function FUN22() public isEnded view returns (address[]) {
if (VAR40 == 1) {
return VAR38;
}else {
return VAR37;
}
}
function FUN23() public isEnded view returns (address[]) {
return VAR39;
}
function FUN24() public isEnded view returns (uint) {
return VAR39.VAR17;
}
}
1
---------------------------------
10 0x09a80172ed7335660327cd664876b5df6fe06108.sol
pragma VAR1 ^0.4.13;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
library VAR6 {
function FUN5(ERC20Basic VAR7, address VAR8, uint256 value) internal {
assert(VAR7.transfer(VAR8, value));
}
function FUN6(ERC20 VAR7, address VAR9, address VAR8, uint256 value) internal {
assert(VAR7.FUN7(VAR9, VAR8, value));
}
function FUN8(ERC20 VAR7, address VAR10, uint256 value) internal {
assert(VAR7.FUN9(VAR10, value));
}
}
contract VAR11 {
address public VAR12;
event FUN10(address indexed VAR13, address indexed VAR14);
function FUN11() public {
VAR12 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR15;
}
function FUN12(address VAR14) public onlyOwner {
require(VAR14 != address(0));
emit FUN10(VAR12, VAR14);
VAR12 = VAR14;
}
}
contract Discountable is VAR11 {
struct VAR16 {
uint256 VAR17;
uint256 VAR18;
}
uint256 VAR19 = 1e2;
uint256 VAR20 = 200;
VAR16[] public VAR21;
function FUN13(uint256 VAR22, uint256 VAR23) onlyOwner public{
VAR21.FUN14(FUN15(VAR22, VAR23));
}
function FUN16(uint256 VAR24, uint256 VAR22, uint256 VAR23) onlyOwner public{
VAR21[VAR24] = FUN15(VAR22, VAR23);
}
function FUN17() public view returns(uint256 VAR25){
return VAR21.VAR26;
}
function FUN18(uint256 VAR17) internal view returns(uint256 VAR27){
uint256 VAR28 = VAR21.VAR26;
if (VAR17 < VAR21[0].VAR17){
return VAR20;
}
for (uint8 VAR29=0; VAR29<VAR28; VAR29++) {
if(VAR29 == VAR28 - 1){
return VAR21[VAR28 - 1].VAR18;
}
if (VAR17 < VAR21[VAR29+1].VAR17){
return VAR21[VAR29].VAR18;
}
}
return VAR20;
}
}
contract VAR30 {
using SafeMath for uint256;
uint256 private VAR31 = 0;
uint256 private VAR32 = 0;
uint256 private VAR33 = 0;
uint256 private VAR34 = 0;
uint256 private VAR35 = 0;
uint256 private VAR36 = 0;
uint256 private VAR37 = 0;
uint256 private VAR38 = 0;
uint256 private VAR39 = 0;
uint256 private VAR40 = 0;
function FUN19(uint256 VAR41, uint256 VAR42) internal {
VAR33 = VAR33.FUN4(VAR41);
VAR34 = VAR34.FUN4(1);
VAR35 = VAR35.FUN4(VAR42);
}
function FUN20(uint256 VAR41, uint256 VAR42) internal {
VAR31 = VAR31.FUN4(VAR41);
VAR32 = VAR32.FUN4(1);
VAR36 = VAR36.FUN4(VAR42);
}
function FUN21(uint256 VAR41) internal{
VAR37 = VAR37.FUN4(VAR41);
VAR38 = VAR38.FUN4(1);
}
function FUN22(uint256 VAR43) internal {
VAR39 = VAR39.FUN4(VAR43);
}
function FUN23(uint256 VAR44) internal {
VAR40 = VAR40.FUN4(VAR44);
}
function FUN24() internal view returns(
uint256 VAR45, uint256 VAR46,
uint256 VAR47, uint256 VAR48,
uint256 VAR49, uint256 VAR50,
uint256 VAR51, uint256 VAR52,
uint256 VAR53, uint256 VAR54) {
return (VAR31, VAR32,
VAR33, VAR34,
VAR35, VAR36,
VAR37, VAR38,
VAR39, VAR40);
}
}
contract Haltable is VAR11 {
bool public VAR55;
modifier VAR56 {
require(!VAR55);
VAR15;
}
modifier VAR57 {
require(VAR55);
VAR15;
}
function FUN25() external onlyOwner {
VAR55 = true;
}
function FUN26() external onlyOwner VAR57 {
VAR55 = false;
}
}
contract VAR58 {
function FUN27() public view returns (uint256);
function FUN28(address VAR59) public view returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool);
event Transfer(address indexed VAR9, address indexed VAR8, uint256 value);
}
contract BasicToken is VAR58 {
using SafeMath for uint256;
mapping(address => uint256) VAR60;
uint256 VAR61;
function FUN27() public view returns (uint256) {
return VAR61;
}
function transfer(address VAR62, uint256 VAR63) public returns (bool) {
require(VAR62 != address(0));
require(VAR63 <= VAR60[msg.sender]);
VAR60[msg.sender] = VAR60[msg.sender].FUN3(VAR63);
VAR60[VAR62] = VAR60[VAR62].FUN4(VAR63);
emit Transfer(msg.sender, VAR62, VAR63);
return true;
}
function FUN28(address VAR64) public view returns (uint256 VAR65) {
return VAR60[VAR64];
}
}
contract BurnableToken is VAR66, VAR11 {
event FUN29(address indexed VAR67, uint256 value);
function FUN30(uint256 VAR63) public onlyOwner{
require(VAR63 <= VAR60[msg.sender]);
address VAR67 = msg.sender;
VAR60[VAR67] = VAR60[VAR67].FUN3(VAR63);
VAR61 = VAR61.FUN3(VAR63);
emit FUN29(VAR67, VAR63);
}
}
contract ERC20 is VAR58 {
function FUN31(address VAR12, address VAR10) public view returns (uint256);
function FUN7(address VAR9, address VAR8, uint256 value) public returns (bool);
function FUN9(address VAR10, uint256 value) public returns (bool);
event FUN32(address indexed VAR12, address indexed VAR10, uint256 value);
}
contract OMPxContract is VAR66, VAR68, VAR69, VAR30 {
using SafeMath for uint256;
using SafeERC20 for VAR58;
using SafeERC20 for VAR70;
OMPxToken public VAR7;
Distribution public VAR71;
uint256 private VAR72 = 0;
event FUN33(address indexed VAR8, uint256 value);
event FUN34(address indexed VAR73, uint256 value);
event FUN35(address indexed VAR10, uint256 VAR74, bytes32 indexed VAR75);
event FUN36(address indexed VAR76, uint256 VAR74, uint256 value);
event FUN37(address indexed VAR76, uint256 VAR74, uint256 value);
event FUN38(address VAR77);
function FUN39() public payable{
FUN13(1000 * 1e18,198);
FUN13(5000 * 1e18,190);
FUN13(20000 * 1e18,180);
FUN13(100000 * 1e18,150);
VAR7 = VAR78 FUN40();
VAR7.FUN41(VAR12, VAR7.FUN42());
}
function() public payable {
emit FUN34(msg.sender, msg.value);
}
function FUN43(address VAR77) public onlyOwner {
require(VAR77 != address(0));
VAR71 = FUN44(VAR77);
emit FUN38(VAR77);
}
function FUN45() public {
if(VAR72 > 1e15){
VAR71.VAR79.value(VAR72).FUN46(150000)();
FUN23(VAR72);
VAR72 = 0;
}
}
function FUN47() public view returns(uint256 VAR61) {
return VAR7.FUN27();
}
function FUN28(address VAR64) public view returns (uint256 VAR80) {
return VAR7.FUN28(VAR64);
}
function FUN48(uint256 VAR81) public view returns(uint256 VAR82) {
if (address(this).VAR65==0) {
return 0;
}
uint256 VAR83;
uint256 VAR41 = VAR7.FUN27();
if (VAR81 > 0) {
VAR83 = address(this).VAR65.FUN3(VAR81);
} else {
VAR83 = address(this).VAR65;
}
return (VAR83.FUN3(VAR72)).FUN1(1e18).FUN2(VAR41);
}
function FUN49(uint256 VAR84, uint256 VAR17) public view returns(uint256 VAR82) {
require(VAR84 >= 0);
require(VAR17 >= 0);
uint256 VAR85 = FUN18(VAR17);
uint256 VAR86 = FUN48(VAR84).FUN1(VAR85).FUN2(VAR19);
if (VAR86 <= 0) {VAR86 = 1e11;}
return VAR86;
}
function FUN50(uint256 VAR87, uint256 VAR88) public payable returns(uint256 VAR89) {
require(VAR87 > 0);
require(msg.value > 0);
return FUN51(VAR87, VAR88);
}
function FUN51(uint256 VAR87, uint256 VAR88) internal returns(uint256 VAR89){
require(VAR88 >= 0);
uint256 VAR90 = FUN49(msg.value, VAR87);
require(VAR90 <= VAR88);
uint256 VAR91 = msg.value.FUN1(1e18).FUN2(VAR90);
if(VAR91 > VAR87) {
VAR91 = VAR87;
}
uint256 VAR92 = VAR90.FUN1(VAR91).FUN2(1e18);
require(msg.value >= VAR87.FUN1(VAR88).FUN2(1e18));
require(msg.value >= VAR92);
VAR72 = VAR72 + VAR92.FUN2(9);
uint256 VAR93 = VAR7.FUN28(this);
if (VAR93 < VAR91) {
uint256 VAR94 = VAR91.FUN3(VAR93);
VAR7.FUN41(this, VAR94);
}
VAR7.FUN5(msg.sender, VAR91);
if (VAR92 < msg.value) {
uint256 VAR95 = msg.value.FUN3(VAR92);
if (VAR95 > 0) {
require(VAR95 < msg.value);
emit FUN33(msg.sender, VAR95);
msg.sender.transfer(VAR95);
FUN22(VAR95);
}
}
emit FUN36(msg.sender, VAR87, VAR92);
FUN19(VAR91, VAR92);
return VAR91;
}
function FUN52(uint256 VAR96, uint256 VAR97) public {
uint VAR90 = FUN48(0);
require(VAR90 >= VAR97);
uint256 VAR98 = VAR96.FUN1(VAR90).FUN2(1e18);
require(VAR96 > 0);
require(VAR96 <= VAR7.FUN28(msg.sender));
VAR7.FUN6(msg.sender, this, VAR96);
emit FUN37(msg.sender, VAR96, VAR98);
FUN20(VAR96, VAR98);
msg.sender.transfer(VAR98);
}
function FUN53(uint256 VAR99, bytes32 VAR75) public {
VAR7.FUN6(msg.sender, this, VAR99);
VAR7.FUN30(VAR99);
FUN21(VAR99);
emit FUN35(msg.sender, VAR99, VAR75);
}
function FUN54(uint256 VAR99, uint256 VAR88, bytes32 VAR75) public payable returns(uint256 VAR100){
uint256 VAR101 = VAR99.FUN3(VAR7.FUN28(msg.sender));
uint256 VAR90 = FUN49(msg.value, VAR101);
uint256 VAR102 = msg.value.FUN1(1e18).FUN2(VAR90);
require(VAR101 <= VAR102);
if (VAR101>0) {
FUN50(VAR101, VAR88);
}
FUN53(VAR99, VAR75);
return VAR99;
}
function FUN55() onlyOwner public view returns(
uint256 VAR45, uint256 VAR46,
uint256 VAR47, uint256 VAR48,
uint256 VAR49, uint256 VAR50,
uint256 VAR51, uint256 VAR52,
uint256 VAR53, uint256 VAR54) {
return FUN24();
}
}
contract Distribution is VAR11 {
using SafeMath for uint256;
struct VAR103 {
address VAR104;
uint256 VAR105;
uint256 VAR65;
uint256 VAR76;
}
uint256 VAR106;
uint8 constant VAR107 = 12;
mapping(address => VAR103) public VAR108;
address[VAR107] public VAR109;
event FUN56(address indexed VAR8, uint256 value);
event FUN57(address VAR8, uint256 value);
event FUN58(address VAR8, uint256 value);
event FUN59(address VAR8);
event FUN60(address VAR110);
event FUN61(uint256 value);
function FUN44() public {
VAR106 = 0;
}
function FUN62() public payable {
emit FUN61(msg.value);
for (uint8 VAR29 = 0; VAR29 < VAR107; VAR29++) {
Recipient storage VAR111 = VAR108[VAR109[VAR29]];
uint VAR112 = (VAR111.VAR105.FUN1(msg.value)).FUN2(VAR106);
VAR111.VAR65 = VAR111.VAR65 + VAR112;
}
}
modifier onlyMembers(){
require(VAR108[msg.sender].VAR104 != address(0));
VAR15;
}
function FUN63() public {
Recipient storage VAR111 = VAR108[msg.sender];
require(VAR111.VAR65 >= 1e12);
VAR111.VAR104.transfer(VAR111.VAR65);
emit FUN56(VAR111.VAR104, VAR111.VAR65);
VAR111.VAR76 = (VAR111.VAR76).FUN4(VAR111.VAR65);
VAR111.VAR65 = 0;
}
function FUN64(address VAR113, uint256 VAR105) public onlyOwner {
require(VAR113 != address(0));
require(VAR105 > 0);
require(VAR108[VAR113].VAR104 == address(0));
VAR108[VAR113].VAR104 = VAR113;
VAR108[VAR113].VAR105 = VAR105;
VAR108[VAR113].VAR76 = 0;
for(uint8 VAR29 = 0; VAR29 < VAR107; VAR29++ ) {
if (VAR109[VAR29] == address(0)) {
VAR109[VAR29] = VAR113;
break;
}
}
VAR106 = VAR106.FUN4(VAR105);
emit FUN57(VAR113, VAR105);
}
function FUN65(address VAR113, uint VAR105) public onlyOwner {
require(VAR113 != address(0));
require(VAR105 > 0);
require(VAR108[VAR113].VAR104 != address(0));
Recipient storage VAR111 = VAR108[VAR113];
VAR106 = VAR106.FUN3(VAR111.VAR105).FUN4(VAR105);
VAR111.VAR105 = VAR105;
emit FUN58(VAR113, VAR105);
}
function FUN66(address VAR113) public onlyOwner {
require(VAR113 != address(0));
require(VAR108[VAR113].VAR104 != address(0));
VAR106 = VAR106.FUN3(VAR108[VAR113].VAR105);
for(uint8 VAR29 = 0; VAR29 < VAR107; VAR29++ ) {
if (VAR109[VAR29] == VAR108[VAR113].VAR104) {
VAR109[VAR29] = address(0);
break;
}
}
delete VAR108[VAR113];
emit FUN59(msg.sender);
}
function FUN67(address VAR114) public {
require(msg.sender != address(0));
require(VAR114 != address(0));
require(VAR108[msg.sender].VAR104 != address(0));
require(VAR108[VAR114].VAR104 == address(0));
require(VAR108[msg.sender].VAR104 != VAR114);
Recipient storage VAR111 = VAR108[msg.sender];
uint256 VAR115 = VAR111.VAR65;
FUN64(VAR114, VAR111.VAR105);
emit FUN60(VAR114);
FUN66(msg.sender);
VAR108[VAR114].VAR65 = VAR115;
emit FUN59(msg.sender);
}
function FUN68() public view returns(uint256) {
return VAR108[msg.sender].VAR65;
}
}
contract StandardToken is VAR116, VAR66 {
mapping (address => mapping (address => uint256)) internal VAR117;
address internal VAR12;
function FUN69() public {
VAR12 = msg.sender;
}
function FUN7(address VAR118, address VAR62, uint256 VAR63) public returns (bool) {
require(VAR62 != address(0));
require(VAR63 <= VAR60[VAR118]);
require(VAR63 <= VAR117[VAR118][msg.sender] || msg.sender == VAR12);
VAR60[VAR118] = VAR60[VAR118].FUN3(VAR63);
VAR60[VAR62] = VAR60[VAR62].FUN4(VAR63);
if (msg.sender != VAR12) {
VAR117[VAR118][msg.sender] = VAR117[VAR118][msg.sender].FUN3(VAR63);
}
emit Transfer(VAR118, VAR62, VAR63);
return true;
}
function FUN9(address VAR119, uint256 VAR63) public returns (bool) {
VAR117[msg.sender][VAR119] = VAR63;
emit FUN32(msg.sender, VAR119, VAR63);
return true;
}
function FUN31(address VAR64, address VAR119) public view returns (uint256) {
return VAR117[VAR64][VAR119];
}
function FUN70(address VAR119, uint VAR120) public returns (bool) {
VAR117[msg.sender][VAR119] = VAR117[msg.sender][VAR119].FUN4(VAR120);
emit FUN32(msg.sender, VAR119, VAR117[msg.sender][VAR119]);
return true;
}
function FUN71(address VAR119, uint VAR121) public returns (bool) {
uint VAR122 = VAR117[msg.sender][VAR119];
if (VAR121 > VAR122) {
VAR117[msg.sender][VAR119] = 0;
} else {
VAR117[msg.sender][VAR119] = VAR122.FUN3(VAR121);
}
emit FUN32(msg.sender, VAR119, VAR117[msg.sender][VAR119]);
return true;
}
}
contract MintableToken is VAR123, VAR11 {
event FUN72(address indexed VAR8, uint256 VAR17);
event FUN73();
bool public VAR124 = false;
modifier FUN74() {
require(!VAR124);
VAR15;
}
function FUN41(address VAR62, uint256 VAR22) onlyOwner canMint public returns (bool) {
VAR61 = VAR61.FUN4(VAR22);
VAR60[VAR62] = VAR60[VAR62].FUN4(VAR22);
emit FUN72(VAR62, VAR22);
emit Transfer(address(0), VAR62, VAR22);
return true;
}
function FUN75() onlyOwner canMint public returns (bool) {
VAR124 = true;
emit FUN73();
return true;
}
}
contract OMPxToken is VAR125, VAR126{
using SafeMath for uint256;
uint32 public constant VAR127 = 18;
uint256 public constant VAR128 = 1e24;
string public constant VAR129 = "";
string public constant VAR130 = "";
}
1
---------------------------------
11 0x0a783b98fdac271efd3804b129a5af15e88093d5.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
address public VAR4;
constructor() public {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(VAR3 == msg.sender);
VAR5;
}
function FUN1(address VAR6) onlyOwner public {
VAR4 = VAR6;
}
function FUN2() public {
require(VAR4 == msg.sender);
VAR3 = VAR4;
delete VAR4;
}
}
contract VAR7 {
function FUN3(address VAR8) public constant returns (uint);
function transfer(address VAR9, uint value) public;
}
contract Token is VAR2 {
string  public VAR10 = '';
string  public VAR11     = '';
string  public VAR12   = '';
uint8   public VAR13 = 8;
uint                      public VAR14;
mapping (address => uint) public VAR15;
uint                      public VAR16;
mapping (address => bool) public VAR17;
mapping (address => uint) public VAR18;
mapping (address => uint) public VAR19;
event Transfer(address indexed VAR20, address indexed VAR9, uint value);
enum VAR21 {
VAR22,
VAR23,
VAR24
}
address public VAR25;
address public VAR26 = 0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1;
uint    public VAR27;
State   public VAR28;
event FUN4(address indexed VAR29, uint VAR30, bytes32 VAR31);
constructor() public FUN5() {}
function FUN6() public onlyOwner {
require(VAR28==VAR21.VAR22);
VAR28=VAR21.VAR23;
}
function FUN7() public onlyOwner {
require(VAR28==VAR21.VAR23);
VAR28=VAR21.VAR24;
}
function FUN8(address VAR32) public onlyOwner {
VAR25 = VAR32;
}
function FUN9(uint VAR33) public {
require(msg.sender == VAR3 || msg.sender == VAR25);
VAR27 = VAR33;
}
function () payable public {
require(VAR28==VAR21.VAR23);
uint VAR30 = msg.value / VAR27 * 100000000;
require(VAR15[msg.sender] + VAR30 > VAR15[msg.sender]);
require(VAR30 > 0);
VAR19[msg.sender]+=msg.value;
VAR15[msg.sender] += VAR30;
if (!VAR17[msg.sender]) {
VAR17[msg.sender] = true;
++VAR16;
}
emit Transfer(this, msg.sender, VAR30);
VAR14 += VAR30;
}
function FUN10(address VAR34, uint VAR35, bytes32 VAR36) public {
require(msg.sender == VAR25 || msg.sender == VAR3);
require(VAR28==VAR21.VAR23);
uint VAR30 = (VAR35 * 10000) / 238894;
VAR18[VAR34]+=VAR35;
require(VAR15[VAR34] + VAR30 > VAR15[VAR34]);
require(VAR30 > 0);
VAR15[VAR34] += VAR30;
VAR14 += VAR30;
if (!VAR17[VAR34]) {
VAR17[VAR34] = true;
++VAR16;
}
emit Transfer(this, VAR34, VAR30);
emit FUN4(VAR34, VAR30, VAR36);
}
function FUN11() public onlyOwner {
require(msg.sender.call.FUN12(3000000).value(address(this).VAR37)());
uint VAR37 = FUN13(VAR26).FUN3(this);
FUN13(VAR26).transfer(msg.sender, VAR37);
}
function FUN14(address VAR38, address VAR39, uint VAR40) public onlyOwner {
FUN13(VAR38).transfer(VAR39, VAR40);
}
}
1
---------------------------------
12 0x0af02d90d359a4628ace226df184c3e8b4b816ff.sol
pragma VAR1 ^0.4.21;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
uint256 public VAR7;
uint256 public VAR8;
function FUN5(address VAR9) public;
function FUN6() payable public;
function FUN7() public view returns(uint256);
}
contract VAR10 {
function FUN8(uint256 VAR11, address VAR12) public;
function FUN9() payable public;
function FUN10(uint256 VAR13) public;
function FUN11() public view returns(uint256);
}
contract VAR14 {
function FUN12() constant public returns (uint VAR15);
function FUN13(address VAR16) constant public returns (uint VAR17);
function transfer(address VAR18, uint VAR19) public returns (bool VAR20);
function FUN14(address VAR21, address VAR18, uint VAR19) public returns (bool VAR20);
function FUN15(address VAR22, uint VAR19) public returns (bool VAR20);
function FUN16(address VAR16, address VAR22) constant public returns (uint VAR23);
event Transfer(address indexed VAR21, address indexed VAR18, uint VAR19);
event FUN17(address indexed VAR16, address indexed VAR22, uint VAR19);
}
contract EOSBetBankroll is VAR14, VAR10 {
using SafeMath for *;
address public VAR24;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR7;
mapping(address => bool) public VAR27;
address public VAR28;
address public VAR29;
mapping(address => uint256) VAR30;
string public constant VAR31 = "";
string public constant VAR32 = "";
uint8 public constant VAR33 = 18;
uint256 public VAR34;
mapping(address => uint256) public VAR35;
mapping(address => mapping(address => uint256)) public VAR36;
event FUN18(address VAR37, uint256 VAR38, uint256 VAR39);
event FUN19(address VAR37, uint256 VAR40, uint256 VAR41);
event FUN20(address VAR42, uint256 VAR43);
modifier FUN21(address VAR44){
require(VAR27[VAR44]);
VAR45;
}
function FUN22(address VAR46, address VAR47) public payable {
require (msg.value > 0);
VAR24 = msg.sender;
uint256 VAR48 = msg.value * 100;
VAR35[msg.sender] = VAR48;
VAR34 = VAR48;
emit Transfer(0x0, msg.sender, VAR48);
VAR27[VAR46] = true;
VAR27[VAR47] = true;
VAR28 = VAR46;
VAR29 = VAR47;
VAR26 = 0 VAR49;
VAR25 = 500 VAR50;
}
function FUN23(address VAR51) view public returns(uint256){
return VAR30[VAR51];
}
function FUN11() view public returns(uint256){
return VAR2.FUN3(address(this).VAR17, VAR7);
}
function FUN8(uint256 VAR11, address VAR12) public FUN21(msg.sender){
if (! VAR12.FUN24(VAR11)){
emit FUN20(VAR12, VAR11);
if (! VAR24.FUN24(VAR11)){
emit FUN20(VAR24, VAR11);
}
}
}
function FUN9() payable public FUN21(msg.sender){
}
function FUN10(uint256 VAR13) public FUN21(msg.sender){
FUN25(msg.sender).VAR52.value(VAR13)();
}
function () public payable {
uint256 VAR53 = VAR2.FUN3(FUN11(), msg.value);
uint256 VAR54 = VAR25;
require(VAR53 < VAR54 && msg.value != 0);
uint256 VAR55 = VAR34;
uint256 VAR56;
bool VAR57;
uint256 VAR58;
uint256 VAR59;
if (VAR2.FUN4(VAR53, msg.value) > VAR54){
VAR57 = true;
VAR56 = VAR2.FUN3(VAR54, VAR53);
VAR58 = VAR2.FUN3(msg.value, VAR56);
}
else {
VAR56 = msg.value;
}
if (VAR55 != 0){
VAR59 = VAR2.FUN1(VAR56, VAR55) / VAR53;
}
else {
VAR59 = VAR2.FUN1(VAR56, 100);
}
VAR34 = VAR2.FUN4(VAR55, VAR59);
VAR35[msg.sender] = VAR2.FUN4(VAR35[msg.sender], VAR59);
VAR30[msg.sender] = VAR60.VAR61;
if (VAR57){
msg.sender.transfer(VAR58);
}
emit FUN18(msg.sender, VAR56, VAR59);
emit Transfer(0x0, msg.sender, VAR59);
}
function FUN26(uint256 VAR62) public {
uint256 VAR63 = VAR35[msg.sender];
require(VAR62 <= VAR63
&& VAR30[msg.sender] + VAR26 <= VAR60.VAR61
&& VAR62 > 0);
uint256 VAR53 = FUN11();
uint256 VAR55 = VAR34;
uint256 VAR64 = VAR2.FUN1(VAR62, VAR53) / VAR55;
uint256 VAR65 = VAR64 / 100;
uint256 VAR66 = VAR2.FUN3(VAR64, VAR65);
VAR34 = VAR2.FUN3(VAR55, VAR62);
VAR35[msg.sender] = VAR2.FUN3(VAR63, VAR62);
VAR7 = VAR2.FUN4(VAR7, VAR65);
msg.sender.transfer(VAR66);
emit FUN19(msg.sender, VAR66, VAR62);
emit Transfer(msg.sender, 0x0, VAR62);
}
function FUN27() public {
FUN26(VAR35[msg.sender]);
}
function FUN28(address VAR67) public {
require(msg.sender == VAR24);
VAR24 = VAR67;
}
function FUN29(uint256 VAR68) public {
require (msg.sender == VAR24 && VAR68 <= 6048000);
VAR26 = VAR68;
}
function FUN30(uint256 VAR69) public {
require(msg.sender == VAR24);
VAR25 = VAR69;
}
function FUN31(address VAR70) public {
require(msg.sender == VAR24);
FUN25(VAR28).FUN5(VAR70);
FUN25(VAR29).FUN5(VAR70);
uint256 VAR71 = VAR7;
VAR7 = 0;
VAR70.transfer(VAR71);
}
function FUN32() public {
require(msg.sender == VAR24);
FUN33(msg.sender);
}
function FUN12() constant public returns(uint){
return VAR34;
}
function FUN13(address VAR16) constant public returns(uint){
return VAR35[VAR16];
}
function transfer(address VAR18, uint256 VAR19) public returns (bool VAR20){
if (VAR35[msg.sender] >= VAR19
&& VAR19 > 0
&& VAR30[msg.sender] + VAR26 <= VAR60.VAR61
&& VAR18 != address(this)){
VAR35[msg.sender] = VAR2.FUN3(VAR35[msg.sender], VAR19);
VAR35[VAR18] = VAR2.FUN4(VAR35[VAR18], VAR19);
emit Transfer(msg.sender, VAR18, VAR19);
return true;
}
else {
return false;
}
}
function FUN14(address VAR21, address VAR18, uint VAR19) public returns(bool){
if (VAR36[VAR21][msg.sender] >= VAR19
&& VAR35[VAR21] >= VAR19
&& VAR19 > 0
&& VAR30[VAR21] + VAR26 <= VAR60.VAR61
&& VAR18 != address(this)){
VAR35[VAR18] = VAR2.FUN4(VAR35[VAR18], VAR19);
VAR35[VAR21] = VAR2.FUN3(VAR35[VAR21], VAR19);
VAR36[VAR21][msg.sender] = VAR2.FUN3(VAR36[VAR21][msg.sender], VAR19);
emit Transfer(VAR21, VAR18, VAR19);
return true;
}
else {
return false;
}
}
function FUN15(address VAR22, uint VAR19) public returns(bool){
if(VAR19 > 0){
VAR36[msg.sender][VAR22] = VAR19;
emit FUN17(msg.sender, VAR22, VAR19);
return true;
}
else {
return false;
}
}
function FUN16(address VAR16, address VAR22) constant public returns(uint){
return VAR36[VAR16][VAR22];
}
}
1
---------------------------------
13 0x0d5d4c289133ebf3eb685c183a930c1ee2ea4a4f.sol
pragma VAR1 ^0.4.25;
contract VAR2
{
function FUN1(uint VAR3)
public
payable
{
var VAR4 = VAR5[msg.sender];
VAR4.VAR6 += msg.value;
VAR4.VAR7 = VAR3>VAR8?VAR3:VAR8;
VAR9.FUN2(msg.sender,msg.value,"");
}
function FUN3(uint VAR10)
public
payable
{
var VAR4 = VAR5[msg.sender];
if( VAR4.VAR6>=VAR11 && VAR4.VAR6>=VAR10 && VAR8>VAR4.VAR7)
{
if(msg.sender.call.value(VAR10)())
{
VAR4.VAR6-=VAR10;
VAR9.FUN2(msg.sender,VAR10,"");
}
}
}
function()
public
payable
{
FUN1(0);
}
struct VAR12
{
uint VAR7;
uint VAR6;
}
mapping (address => VAR12) public VAR5;
Log VAR9;
uint public VAR11 = 2 VAR13;
function FUN4(address VAR14) public{
VAR9 = FUN5(VAR14);
}
}
contract VAR15
{
struct VAR16
{
address VAR17;
string  VAR18;
uint VAR19;
uint  VAR20;
}
VAR16[] public VAR21;
Message VAR22;
function FUN2(address VAR23,uint VAR24,string VAR25)
public
{
VAR22.VAR17 = VAR23;
VAR22.VAR20 = VAR8;
VAR22.VAR19 = VAR24;
VAR22.VAR18 = VAR25;
VAR21.FUN6(VAR22);
}
}
1
---------------------------------
14 0x0e412af67f6c41e9209da8b8638d65bb883ddf5a.sol
contract VAR1 {
function FUN1(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN2(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 > 0);
uint VAR4 = VAR2 / VAR3;
assert(VAR2 == VAR3 * VAR4 + VAR2 % VAR3);
return VAR4;
}
function FUN3(uint VAR2, uint VAR3) internal returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN4(uint VAR2, uint VAR3) internal returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2 && VAR4>=VAR3);
return VAR4;
}
function FUN5(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN6(uint64 VAR2, uint64 VAR3) internal constant returns (VAR5) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function FUN7(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 >= VAR3 ? VAR2 : VAR3;
}
function FUN8(uint256 VAR2, uint256 VAR3) internal constant returns (uint256) {
return VAR2 < VAR3 ? VAR2 : VAR3;
}
function assert(bool VAR6) internal {
if (!VAR6) {
throw;
}
}
}
library VAR7 {
function FUN9(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 * VAR3;
assert(VAR2 == 0 || VAR4 / VAR2 == VAR3);
return VAR4;
}
function FUN10(uint VAR2, uint VAR3) returns (uint) {
assert(VAR3 <= VAR2);
return VAR2 - VAR3;
}
function FUN11(uint VAR2, uint VAR3) returns (uint) {
uint VAR4 = VAR2 + VAR3;
assert(VAR4>=VAR2);
return VAR4;
}
function assert(bool VAR6) private {
if (!VAR6) throw;
}
}
contract VAR8 {
address public VAR9;
function FUN12() {
VAR9 = msg.sender;
}
modifier onlyOwner() {
if (msg.sender != VAR9) {
throw;
}
VAR10;
}
function FUN13(address VAR11) onlyOwner {
if (VAR11 != address(0)) {
VAR9 = VAR11;
}
}
}
contract Haltable is VAR8 {
bool public VAR12;
modifier VAR13 {
if (VAR12) throw;
VAR10;
}
modifier VAR14 {
if (!VAR12) throw;
VAR10;
}
function FUN14() external onlyOwner {
VAR12 = true;
}
function FUN15() external onlyOwner VAR14 {
VAR12 = false;
}
}
contract VAR15 {
function FUN16() public constant returns (bool) {
return true;
}
function FUN17(address VAR16) public constant returns (bool) {
return true;
}
function FUN18(uint value, uint VAR17, uint VAR18, address VAR19, uint VAR20) public constant returns (uint VAR21);
}
contract VAR22 {
function FUN19() public constant returns(bool) {
return true;
}
function FUN17() public constant returns (bool);
function FUN20();
}
contract VAR23 {
uint public VAR24;
function FUN21(address VAR25) constant returns (uint);
function FUN22(address VAR9, address VAR26) constant returns (uint);
function transfer(address VAR27, uint value) returns (bool VAR28);
function FUN23(address VAR29, address VAR27, uint value) returns (bool VAR28);
function FUN24(address VAR26, uint value) returns (bool VAR28);
event Transfer(address indexed VAR29, address indexed VAR27, uint value);
event FUN25(address indexed VAR9, address indexed VAR26, uint value);
}
contract FractionalERC20 is VAR23 {
uint public VAR20;
}
contract Crowdsale is VAR30 {
uint public VAR31 = 5;
using SafeMathLib for uint;
FractionalERC20 public VAR32;
PricingStrategy public VAR33;
FinalizeAgent public VAR34;
address public VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR18 = 0;
uint public VAR17 = 0;
uint public VAR39 = 0;
uint public VAR40 = 0;
uint public VAR41 = 0;
bool public VAR42;
bool public VAR43;
bool public VAR44;
address public VAR45;
mapping (address => uint256) public VAR46;
mapping (address => uint256) public VAR47;
mapping (address => bool) public VAR48;
uint public VAR49;
enum VAR50{VAR51, VAR52, VAR53, VAR54, VAR55, VAR56, VAR57, VAR58}
event FUN26(address VAR59, uint VAR60, uint VAR21, uint128 VAR61);
event FUN27(address VAR59, uint VAR60);
event FUN28(bool VAR43, bool VAR44, address VAR45);
event FUN29(address VAR62, bool VAR63);
event FUN30(uint VAR38);
function FUN31(address VAR64, PricingStrategy VAR65, address VAR66, uint VAR67, uint VAR68, uint VAR69) {
VAR9 = msg.sender;
VAR32 = FUN32(VAR64);
FUN33(VAR65);
VAR35 = VAR66;
if(VAR35 == 0) {
throw;
}
if(VAR67 == 0) {
throw;
}
VAR37 = VAR67;
if(VAR68 == 0) {
throw;
}
VAR38 = VAR68;
if(VAR37 >= VAR38) {
throw;
}
VAR36 = VAR69;
}
function() payable {
throw;
}
function FUN34(address VAR70, uint128 VAR61) stopInEmergency private {
if(FUN35() == VAR50.VAR53) {
if(!VAR48[VAR70]) {
throw;
}
} else if(FUN35() == VAR50.VAR54) {
} else {
throw;
}
uint VAR60 = msg.value;
uint VAR21 = VAR33.FUN18(VAR60, VAR17, VAR18, msg.sender, VAR32.FUN36());
if(VAR21 == 0) {
throw;
}
if(VAR46[VAR70] == 0) {
VAR39++;
}
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
if(FUN37(VAR60, VAR21, VAR17, VAR18)) {
throw;
}
FUN38(VAR70, VAR21);
if(!VAR35.FUN39(VAR60)) throw;
FUN26(VAR70, VAR60, VAR21, VAR61);
}
function FUN40(address VAR70, uint VAR71, uint VAR72) public onlyOwner {
uint VAR21 = VAR71 * 10**VAR32.FUN36();
uint VAR60 = VAR72 * VAR71;
VAR17 = VAR17.FUN11(VAR60);
VAR18 = VAR18.FUN11(VAR21);
VAR46[VAR70] = VAR46[VAR70].FUN11(VAR60);
VAR47[VAR70] = VAR47[VAR70].FUN11(VAR21);
FUN38(VAR70, VAR21);
FUN26(VAR70, VAR60, VAR21, 0);
}
function FUN41(address VAR62, uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
bytes32 VAR76 = FUN42(VAR62);
if (FUN43(VAR76, VAR73, VAR74, VAR75) != VAR45) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN44(address VAR62, uint128 VAR61) public payable {
if(VAR44) throw;
if(VAR61 == 0) throw;
FUN34(VAR62, VAR61);
}
function FUN45(address VAR62) public payable {
if(VAR43) throw;
if(VAR44) throw;
FUN34(VAR62, 0);
}
function FUN46(uint128 VAR61, uint8 VAR73, bytes32 VAR74, bytes32 VAR75) public payable {
FUN41(msg.sender, VAR61, VAR73, VAR74, VAR75);
}
function FUN47(uint128 VAR61) public payable {
FUN44(msg.sender, VAR61);
}
function FUN48() public payable {
FUN45(msg.sender);
}
function FUN49() public FUN50(VAR50.VAR55) onlyOwner VAR13 {
if(VAR42) {
throw;
}
if(address(VAR34) != 0) {
VAR34.FUN20();
}
VAR42 = true;
}
function FUN51(FinalizeAgent VAR62) onlyOwner {
VAR34 = VAR62;
if(!VAR34.FUN19()) {
throw;
}
}
function FUN52(bool value) onlyOwner {
VAR43 = value;
FUN28(VAR43, VAR44, VAR45);
}
function FUN53(bool value, address VAR77) onlyOwner {
VAR44 = value;
VAR45 = VAR77;
FUN28(VAR43, VAR44, VAR45);
}
function FUN54(address VAR62, bool VAR63) onlyOwner {
VAR48[VAR62] = VAR63;
FUN29(VAR62, VAR63);
}
function FUN55(uint VAR78) onlyOwner {
if(VAR79 > VAR78) {
throw;
}
VAR38 = VAR78;
FUN30(VAR38);
}
function FUN33(PricingStrategy VAR65) onlyOwner {
VAR33 = VAR65;
if(!VAR33.FUN16()) {
throw;
}
}
function FUN56(address VAR62) public onlyOwner {
if(VAR39 > VAR31) {
throw;
}
VAR35 = VAR62;
}
function FUN57() public payable FUN50(VAR50.VAR56) {
if(msg.value == 0) throw;
VAR40 = VAR40.FUN11(msg.value);
}
function FUN58() public FUN50(VAR50.VAR58) {
uint256 VAR80 = VAR46[msg.sender];
if (VAR80 == 0) throw;
VAR46[msg.sender] = 0;
VAR41 = VAR41.FUN11(VAR80);
FUN27(msg.sender, VAR80);
if (!msg.sender.FUN39(VAR80)) throw;
}
function FUN59() public constant returns (bool VAR81) {
return VAR17 >= VAR36;
}
function FUN60() public constant returns (bool VAR82) {
return VAR34.FUN17();
}
function FUN61() public constant returns (bool VAR82) {
return VAR33.FUN17(address(this));
}
function FUN35() public constant returns (VAR50) {
if(VAR42) return VAR50.VAR57;
else if (address(VAR34) == 0) return VAR50.VAR52;
else if (!VAR34.FUN17()) return VAR50.VAR52;
else if (!VAR33.FUN17(address(this))) return VAR50.VAR52;
else if (VAR83.VAR84 < VAR37) return VAR50.VAR53;
else if (VAR83.VAR84 <= VAR38 && !FUN62()) return VAR50.VAR54;
else if (FUN59()) return VAR50.VAR55;
else if (!FUN59() && VAR17 > 0 && VAR40 >= VAR17) return VAR50.VAR58;
else return VAR50.VAR56;
}
function FUN63(uint VAR85) onlyOwner {
VAR49 = VAR85;
}
function FUN64() public constant returns (bool) {
return true;
}
//
//
modifier FUN50(State VAR86) {
if(FUN35() != VAR86) throw;
VAR10;
}
//
//
function FUN37(uint VAR60, uint VAR21, uint VAR87, uint VAR88) constant returns (bool VAR89);
function FUN62() public constant returns (bool);
function FUN38(address VAR70, uint VAR21) private;
}
contract StandardToken is VAR23, VAR1 {
event FUN65(address VAR70, uint VAR90);
mapping(address => uint) VAR91;
mapping (address => mapping (address => uint)) VAR92;
function FUN66() public constant returns (bool VAR93) {
return true;
}
modifier FUN67(uint VAR94) {
if(msg.VAR95.VAR96 < VAR94 + 4) {
throw;
}
VAR10;
}
function transfer(address VAR97, uint VAR98) FUN67(2 * 32) returns (bool VAR99) {
VAR91[msg.sender] = FUN3(VAR91[msg.sender], VAR98);
VAR91[VAR97] = FUN4(VAR91[VAR97], VAR98);
Transfer(msg.sender, VAR97, VAR98);
return true;
}
function FUN23(address VAR100, address VAR97, uint VAR98) returns (bool VAR99) {
uint VAR101 = VAR92[VAR100][msg.sender];
VAR91[VAR97] = FUN4(VAR91[VAR97], VAR98);
VAR91[VAR100] = FUN3(VAR91[VAR100], VAR98);
VAR92[VAR100][msg.sender] = FUN3(VAR101, VAR98);
Transfer(VAR100, VAR97, VAR98);
return true;
}
function FUN21(address VAR102) constant returns (uint VAR103) {
return VAR91[VAR102];
}
function FUN24(address VAR104, uint VAR98) returns (bool VAR99) {
if ((VAR98 != 0) && (VAR92[msg.sender][VAR104] != 0)) throw;
VAR92[msg.sender][VAR104] = VAR98;
FUN25(msg.sender, VAR104, VAR98);
return true;
}
function FUN22(address VAR102, address VAR104) constant returns (uint VAR105) {
return VAR92[VAR102][VAR104];
}
}
contract PreICOProxyBuyer is VAR8, VAR30, VAR1 {
uint public VAR39;
uint public VAR87;
address[] public VAR106;
mapping(address => uint) public VAR91;
mapping(address => uint) public VAR107;
uint public VAR108;
uint public VAR109;
uint public VAR110;
uint public VAR111;
uint public VAR112;
uint public VAR113;
Crowdsale public VAR16;
enum VAR50{VAR51, VAR54, VAR114, VAR58}
event FUN26(address VAR59, uint value);
event FUN68(address VAR59, uint value);
event FUN69(uint VAR115);
event FUN70(address VAR106, uint VAR115);
function FUN71(address VAR102, uint VAR116, uint VAR117, uint VAR118) {
VAR9 = VAR102;
if(VAR116 == 0) {
throw;
}
if(VAR117 == 0) {
throw;
}
VAR109 = VAR117;
VAR110 = VAR118;
VAR108 = VAR116;
}
function FUN72() public constant returns(VAR119) {
if(address(VAR16) == 0)  {
throw;
}
return VAR16.FUN73();
}
function FUN45() public stopInEmergency payable {
if(FUN35() != VAR50.VAR54) throw;
if(msg.value == 0) throw;
address VAR59 = msg.sender;
bool VAR120 = VAR91[VAR59] > 0;
VAR91[VAR59] = FUN4(VAR91[VAR59], msg.value);
if(VAR91[VAR59] < VAR109) {
throw;
}
if(!VAR120) {
VAR106.FUN74(VAR59);
VAR39++;
}
VAR87 = FUN4(VAR87, msg.value);
if(VAR87 > VAR110) {
throw;
}
FUN26(VAR59, msg.value);
}
function FUN75() stopInEmergency public {
if(FUN35() != VAR50.VAR54) {
throw;
}
if(address(VAR16) == 0) throw;
VAR16.VAR121.value(VAR87)(address(this));
VAR111 = FUN72().FUN21(address(this));
if(VAR111 == 0) {
throw;
}
FUN69(VAR111);
}
function FUN76(address VAR59) public constant returns (uint) {
if(FUN35() != VAR50.VAR114) {
throw;
}
return FUN1(VAR91[VAR59], VAR111) / VAR87;
}
function FUN77(address VAR59) public constant returns (uint) {
return FUN3(FUN76(VAR59), VAR107[VAR59]);
}
function FUN78() {
FUN79(FUN77(msg.sender));
}
function FUN79(uint VAR90) VAR13 {
address VAR59 = msg.sender;
if(VAR90 == 0) {
throw;
}
if(FUN77(VAR59) < VAR90) {
throw;
}
if(VAR107[VAR59] == 0) {
VAR112++;
}
VAR107[VAR59] = FUN4(VAR107[VAR59], VAR90);
VAR113 = FUN4(VAR113, VAR90);
FUN72().transfer(VAR59, VAR90);
FUN70(VAR59, VAR90);
}
function FUN58() VAR13 {
if(FUN35() != VAR50.VAR58) throw;
address VAR59 = msg.sender;
if(VAR91[VAR59] == 0) throw;
uint VAR90 = VAR91[VAR59];
delete VAR91[VAR59];
if(!(VAR59.call.value(VAR90)())) throw;
FUN68(VAR59, VAR90);
}
function FUN80(Crowdsale VAR122) public onlyOwner {
VAR16 = VAR122;
if(!VAR16.FUN64()) true;
}
function FUN35() public returns(VAR50) {
if(VAR111 == 0) {
if(VAR79 >= VAR108) {
return VAR50.VAR58;
} else {
return VAR50.VAR54;
}
} else {
return VAR50.VAR114;
}
}
function() payable {
throw;
}
}
1
---------------------------------
15 0x11f4306f9812b80e75c1411c1cf296b04917b2f0.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
address VAR3 = address(0);
bool VAR4 = false;
function FUN1() payable
{
if ((FUN2()%2==1) && (msg.value == 1 VAR5) && (!VAR4))
{
if (!msg.sender.call.value(2 VAR5)())
throw;
}
}
function FUN3()
{
if (VAR3==msg.sender)
{
VAR4 = true;
}
}
function FUN4()
{
if (VAR3==msg.sender)
{
VAR4 = false;
}
}
function FUN5(address VAR6)
{
if ((VAR3 == address(0)) || (VAR3 == msg.sender))
{
VAR3 = VAR6;
}
}
function FUN6(uint VAR7)
{
if (VAR3==msg.sender)
{
msg.sender.transfer( VAR7 * (1 VAR5));
}
}
function FUN2() view returns (uint8) {
return uint8(uint256(FUN7(VAR8.VAR9, VAR8.VAR10))%256);
}
function () public  payable
{
FUN1();
}
}
1
---------------------------------
16 0x134decfcc18a98f721496d83a4622e57e54f0c6b.sol
pragma VAR1 ^0.4.21;
contract VAR2 {
function transfer(address VAR3, uint256 VAR4) public returns (bool VAR5);
}
contract VAR6 {
function FUN1(address) public payable returns(uint256);
function FUN2() public;
function FUN3() public view returns(uint256);
function FUN4(bool) public view returns(uint256);
}
contract VAR7 {
address public VAR8;
address public VAR9;
function FUN5() public {
VAR8 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR8);
VAR10;
}
function FUN6(address VAR11) public onlyOwner {
VAR9 = VAR11;
}
function FUN7() public {
require(msg.sender == VAR9);
VAR8 = VAR9;
}
}
contract IronHands is VAR7 {
modifier onlyOwner(){
require(msg.sender == VAR8);
VAR10;
}
modifier FUN8(address VAR12){
require(VAR12 != address(VAR13));
VAR10;
}
event FUN9(uint256 VAR14, address VAR15);
event FUN10(uint256 VAR16, uint256 VAR17);
event FUN11(uint256 VAR14, address VAR18);
event FUN12(uint256 VAR14);
event FUN13(uint256 VAR14, address VAR19);
event FUN14(uint256 VAR20, address VAR21, uint256 VAR14);
event FUN15(uint256 VAR22, uint256 VAR23, address VAR24);
struct VAR25 {
address VAR26;
uint256 VAR27;
}
uint256 VAR28;
uint256 VAR29;
uint256 public VAR30;
uint256 public VAR31 = 0;
uint256 public VAR32 = 0;
VAR25[] public VAR33;
mapping(address => uint256[]) public VAR34;
mapping(address => uint256) public VAR35;
mapping(address => uint256) public VAR36;
POWH VAR13;
function FUN16(uint VAR37, address VAR38) public {
VAR30 = VAR37;
VAR13 = FUN17(VAR38);
}
function() payable public {
}
function FUN18() payable public {
require(msg.value > 10);
uint256 VAR39 = (msg.value * VAR30) / 100;
VAR33.FUN19(FUN20(msg.sender, VAR39));
VAR32 += VAR39;
VAR36[msg.sender] += VAR39;
emit FUN9(msg.value, msg.sender);
if(FUN4() > 0){
FUN2();
}
FUN21();
}
function FUN21() public {
uint VAR40 = address(this).VAR40;
require(VAR40 > 1);
VAR28 += VAR40;
uint VAR41 = VAR40 / 2;
VAR40 -= VAR41;
uint256 VAR4 = VAR13.VAR42.value(VAR41).FUN22(1000000)(msg.sender);
emit FUN10(VAR41, VAR4);
while (VAR40 > 0) {
uint VAR43 = VAR40 < VAR33[VAR31].VAR27 ? VAR40 : VAR33[VAR31].VAR27;
if(VAR43 > 0){
VAR33[VAR31].VAR27 -= VAR43;
VAR40 -= VAR43;
VAR32 -= VAR43;
VAR36[VAR33[VAR31].VAR26] -= VAR43;
VAR33[VAR31].VAR26.call.value(VAR43).FUN22(1000000)();
emit FUN11(VAR43, VAR33[VAR31].VAR26);
}
if(VAR40 > 0){
VAR31 += 1;
}
if(VAR31 >= VAR33.VAR44){
return;
}
}
}
function FUN3() public view returns(uint256){
return VAR13.FUN3();
}
function FUN4() public view returns(uint256){
return VAR13.FUN4(true);
}
function FUN23() public view returns(uint256){
return VAR29;
}
function FUN2() public {
uint256 VAR40 = address(this).VAR40;
VAR13.VAR45.FUN22(1000000)();
uint256 VAR46 = address(this).VAR40 - VAR40;
VAR29 += VAR46;
emit FUN12(VAR46);
}
function FUN24() payable public {
emit FUN13(msg.value, msg.sender);
}
function FUN25() public view returns (uint256){
return VAR33.VAR44 - VAR31;
}
function FUN26() public view returns (uint256){
return VAR32;
}
function FUN27() public view returns (uint256){
return VAR33.VAR44;
}
function FUN28() public view returns (uint256){
return VAR28;
}
function FUN29(address VAR47) public view returns (uint256) {
return VAR36[VAR47];
}
function FUN30() public view returns (uint256){
return FUN29(msg.sender);
}
function FUN31(address VAR48, address VAR49, uint VAR4) public onlyOwner FUN8(VAR48) returns (bool VAR5) {
return FUN32(VAR48).transfer(VAR49, VAR4);
}
function FUN33() public onlyOwner {
Participant memory VAR21 = VAR33[VAR31];
emit FUN14(VAR31, VAR21.VAR26, VAR21.VAR27);
if(VAR34[VAR21.VAR26].VAR44 == VAR35[VAR21.VAR26]){
VAR34[VAR21.VAR26].FUN19(VAR31);
}else{
VAR34[VAR21.VAR26][VAR35[VAR21.VAR26]] = VAR31;
}
VAR35[VAR21.VAR26] += 1;
VAR31 += 1;
}
function FUN34() public {
require(VAR35[msg.sender] > 0);
VAR35[msg.sender] -= 1;
uint VAR50 = VAR34[msg.sender][VAR35[msg.sender]];
require(VAR31 > VAR50);
emit FUN15(VAR31, VAR50, msg.sender);
VAR31 = VAR50;
}
}
1
---------------------------------
17 0x14b16fdf2b13589e9ddb834451bd4d673838e88c.sol
pragma VAR1 ^0.4.2;
contract VAR2{
function FUN1() public view returns (uint);
function FUN2() payable public;
function FUN3(uint VAR3, uint VAR4) public;
}
contract VAR5 {
address VAR6;
uint VAR7 = 0;
address VAR8;
MyInterface VAR9;
uint constant VAR10 = 195;
uint constant VAR11 = .0001 VAR12;
mapping(uint => address[]) VAR13;
mapping(uint => uint[]) VAR14;
mapping(uint => uint[]) VAR15;
mapping(uint => uint) VAR16;
mapping(uint => uint) VAR17;
modifier onlyOwner() {
require(VAR6 == msg.sender);
VAR18;
}
modifier FUN4() {
require(VAR8 == msg.sender);
VAR18;
}
function FUN5 () public {
VAR6 = msg.sender;
}
function FUN2() payable public {
}
function() payable public {
require(msg.value >= .001 VAR12 && VAR19.VAR20 < VAR17[VAR7]);
VAR13[VAR7].FUN6(msg.sender);
VAR14[VAR7].FUN6(msg.value);
VAR16[VAR7] +=msg.value;
VAR15[VAR7].FUN6(VAR16[VAR7]);
}
function FUN3(uint VAR3, uint VAR4) FUN4() public {
VAR7 = VAR3;
VAR17[VAR7] = VAR4;
}
function FUN7(uint VAR3, uint VAR4) onlyOwner() public {
VAR7 = VAR3;
VAR17[VAR7] = VAR4;
VAR9.FUN3(VAR7, VAR4);
}
function FUN8(uint VAR4) onlyOwner() public {
VAR7++;
VAR17[VAR7] = VAR4;
VAR9.FUN3(VAR7, VAR4);
}
function FUN9() onlyOwner() public view returns (uint) {
return VAR7;
}
function FUN10 (address VAR21) onlyOwner() public {
VAR6 = VAR21;
}
function FUN11 (address VAR22) onlyOwner() public {
VAR8 = VAR22;
VAR9 = FUN12(VAR8);
}
function FUN13() onlyOwner() public view returns (address) {
return VAR6;
}
function FUN14() onlyOwner() public view returns (address) {
return VAR8;
}
function FUN15(uint VAR23) onlyOwner() public view returns (uint, uint, address[],uint[], uint[]) {
return (VAR16[VAR23], VAR17[VAR23], VAR13[VAR23], VAR14[VAR23],VAR15[VAR23]);
}
function FUN1() FUN4() public view returns (uint) {
return (VAR16[VAR7]);
}
function FUN16() onlyOwner() public {
for (uint VAR24 = 0; VAR24 < VAR13[VAR7].VAR25; VAR24++) {
VAR13[VAR7][VAR24].transfer(VAR14[VAR7][VAR24] - VAR11);
}
}
function FUN17() public view onlyOwner() returns (uint, uint) {
uint VAR26 = VAR9.FUN1();
return (VAR16[VAR7], VAR26);
}
function FUN18(uint VAR27) onlyOwner() public {
VAR9.VAR28.value(VAR27)();
}
function FUN19(uint VAR27) onlyOwner() public {
VAR6.transfer(VAR27);
}
function FUN20() onlyOwner() public {
if (VAR16[VAR7] != 0) {
uint VAR26 = VAR9.FUN1();
if (VAR16[VAR7] <= VAR26) {
VAR9.VAR28.value(VAR16[VAR7])();
} else {
if (VAR26 != 0) {
VAR9.VAR28.value(VAR26)();
}
for (uint VAR24 = 0; VAR24 < VAR13[VAR7].VAR25; VAR24++) {
if (VAR15[VAR7][VAR24] > VAR26) {
if (VAR15[VAR7][VAR24] - VAR26 < VAR14[VAR7][VAR24]) {
VAR13[VAR7][VAR24].transfer( (VAR15[VAR7][VAR24] - VAR26) - VAR11);
} else {
VAR13[VAR7][VAR24].transfer(VAR14[VAR7][VAR24] - VAR11);
}
}
}
}
}
}
function FUN21() onlyOwner() public {
if (VAR16[VAR7] != 0) {
uint VAR29 = 0;
uint VAR26 = VAR9.FUN1();
for (uint VAR24 = 0; VAR24 < VAR13[VAR7].VAR25; VAR24++) {
if (VAR15[VAR7][VAR24] <= VAR26) {
VAR13[VAR7][VAR24].transfer((VAR14[VAR7][VAR24] * VAR10 / 100) - VAR11);
} else {
if (VAR29 < VAR26) {
VAR13[VAR7][VAR24].transfer(((VAR26 - VAR29) * VAR10 / 100) + (VAR14[VAR7][VAR24] - (VAR26 - VAR29)) - VAR11);
} else {
VAR13[VAR7][VAR24].transfer(VAR14[VAR7][VAR24] - VAR11);
}
}
VAR29 = VAR15[VAR7][VAR24];
}
}
}
function FUN22() onlyOwner() public {
FUN23(VAR6);
}
}
1
---------------------------------
18 0x14cf6193935b17fc72649ba420fdd5bfdf1f0001.sol
pragma VAR1 ^0.4.10;
contract VAR2 {
address public VAR3;
address public VAR4;
function FUN1() payable {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(VAR3 == msg.sender);
VAR5;
}
function FUN2(address VAR6) onlyOwner public {
require(VAR6 != 0);
VAR4 = VAR6;
}
function FUN3() public {
require(VAR4 == msg.sender);
VAR3 = VAR4;
delete VAR4;
}
}
contract VAR7 {
uint public VAR8;
function FUN4(address VAR9) constant returns (uint);
function transfer(address VAR10, uint value);
function FUN5(address VAR3, address VAR11) constant returns (uint);
function FUN6(address VAR12, address VAR10, uint value);
function FUN7(address VAR11, uint value);
event FUN8(address indexed VAR3, address indexed VAR11, uint value);
event Transfer(address indexed VAR12, address indexed VAR10, uint value);
}
contract KYC is VAR2 {
mapping (address => bool) public VAR13;
address                   public VAR14;
function FUN9(address VAR15) public onlyOwner {
VAR14 = VAR15;
}
function FUN10(address VAR16) public {
require(msg.sender == VAR14 || msg.sender == VAR3);
VAR13[VAR16] = true;
}
}
contract Presale is VAR17, VAR7 {
uint    public VAR18;
address public VAR19;
uint    public VAR20;
uint    public VAR21;
enum VAR22 { VAR23, VAR24, VAR25 }
event FUN11(State VAR26);
State   public VAR26;
uint    public VAR27;
uint    public VAR28;
uint    public VAR29;
struct VAR30 {
uint256 VAR31;
uint    VAR32;
}
mapping (address => VAR30) public VAR33;
mapping (uint => address)     public VAR34;
uint                          public VAR35;
function () payable public {
require(VAR26 == VAR22.VAR24);
require(VAR36 < VAR29);
require(VAR36 > VAR28 || VAR13[msg.sender]);
uint VAR37 = msg.value;
uint VAR38 = VAR37 * VAR18 / 1000000000000000000;
if (VAR21 + VAR38 > VAR20) {
VAR38 = VAR20 - VAR21;
VAR37 = VAR38 * 1000000000000000000 / VAR18;
require(msg.sender.call.FUN12(3000000).value(msg.value - VAR37)());
VAR21 = VAR20;
} else {
VAR21 += VAR38;
}
uint256 VAR39 = 100;
if (VAR36 <= VAR28) {
if (VAR38 >= 100000) {
VAR39 = 200;
} else {
VAR39 = 175;
}
} else {
if (VAR38 >= 100000) {
VAR39 = 150;
} else {
VAR39 = 130;
}
}
uint256 VAR40 = VAR39 * VAR38 / 10;
require(VAR40 > 0);
Investor storage VAR41 = VAR33[msg.sender];
if (VAR41.VAR32 == 0) {
VAR34[VAR35++] = msg.sender;
}
require(VAR41.VAR31 + VAR40 > VAR41.VAR31);
VAR41.VAR31 += VAR40;
VAR41.VAR32 += VAR37;
VAR8 += VAR40;
Transfer(this, msg.sender, VAR40);
}
function FUN13(address VAR42, uint VAR43) public onlyOwner {
require(VAR26 == VAR22.VAR23);
VAR27 = VAR36;
VAR19 = VAR42;
VAR18 = VAR43;
VAR28 = VAR36 + 3 VAR44;
VAR29 = VAR28 + 60 VAR44;
VAR26 = VAR22.VAR24;
VAR20 = 500000;
FUN11(VAR26);
}
function FUN14() public constant returns(uint VAR45) {
require(VAR26 == VAR22.VAR24);
if (VAR36 > VAR29) {
VAR45 = 0;
} else {
VAR45 = VAR29 - VAR36;
}
}
function FUN15() public onlyOwner {
require(VAR26 == VAR22.VAR24);
require(VAR36 >= VAR29 || VAR21 == VAR20);
require(VAR19.call.FUN12(3000000).value(this.VAR46)());
VAR26 = VAR22.VAR25;
FUN11(VAR26);
}
function FUN16() public onlyOwner {
require(VAR19.call.FUN12(3000000).value(this.VAR46)());
}
}
contract PresaleToken is VAR24 {
string  public VAR47    = '';
string  public VAR48        = '';
string  public VAR49      = "";
uint8   public VAR50    = 0;
function FUN17() payable public FUN18() {}
function FUN4(address VAR16) constant public returns (uint) {
return VAR33[VAR16].VAR31;
}
function transfer(address, uint256) public {revert();}
function FUN6(address, address, uint256) public {revert();}
function FUN7(address, uint256) public {revert();}
function FUN5(address, address) public constant returns (uint256) {revert();}
}
contract OpenLongevityPresale is VAR51 {
function FUN19() payable public FUN17() {}
function FUN20() public onlyOwner {
FUN21(VAR3);
}
}
1
---------------------------------
19 0x1611ead58474528582420b089e9b3b55bc9af3c1.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 VAR5) public returns (bool);
event Transfer(address indexed VAR6, address indexed VAR7, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR8, address VAR9)
public view returns (uint256);
function FUN4(address VAR10, address VAR4, uint256 VAR5)
public returns (bool);
function FUN5(address VAR9, uint256 VAR5) public returns (bool);
event FUN6(
address indexed VAR11,
address indexed VAR12,
uint256 value
);
}
contract IBasicMultiToken is VAR13 {
event FUN7(address indexed VAR14, address indexed VAR15, uint256 value);
event FUN8(address indexed VAR14, address indexed VAR15, uint256 value);
function FUN9() public view returns(uint256);
function FUN10(uint VAR16) public view returns(VAR13);
function FUN11() public view returns(bool);
function FUN12(address VAR17, uint256 VAR18, uint256[] VAR19) public;
function FUN13(address VAR17, uint256 VAR18) public;
function FUN14(address VAR17, uint256 VAR5) public;
function FUN15(address VAR17, uint256 VAR5, VAR13[] VAR20) public;
function FUN16() public;
function FUN17() public;
bytes4 public constant VAR21 = 0xd5c368b6;
}
contract IMultiToken is VAR22 {
event FUN18();
event FUN19(address indexed VAR23, address indexed VAR24, address indexed VAR25, uint256 VAR18, uint256 VAR26);
function FUN20(address VAR27) public view returns(uint256);
function FUN21() public view returns(bool);
function FUN22(address VAR23, address VAR24, uint256 VAR18) public view returns (uint256 VAR28);
function FUN23(address VAR23, address VAR24, uint256 VAR18, uint256 VAR29) public returns (uint256 VAR28);
function FUN24() public;
bytes4 public constant VAR30 = 0x81624e24;
}
library VAR31 {
function FUN25(uint256 VAR32, uint256 VAR33) internal pure returns (uint256 VAR34) {
if (VAR32 == 0) {
return 0;
}
VAR34 = VAR32 * VAR33;
assert(VAR34 / VAR32 == VAR33);
return VAR34;
}
function FUN26(uint256 VAR32, uint256 VAR33) internal pure returns (uint256) {
return VAR32 / VAR33;
}
function FUN27(uint256 VAR32, uint256 VAR33) internal pure returns (uint256) {
assert(VAR33 <= VAR32);
return VAR32 - VAR33;
}
function FUN28(uint256 VAR32, uint256 VAR33) internal pure returns (uint256 VAR34) {
VAR34 = VAR32 + VAR33;
assert(VAR34 >= VAR32);
return VAR34;
}
}
library VAR35 {
using SafeMath for uint;
function FUN29(address VAR36) internal view returns(bool VAR37) {
VAR38 {
VAR37 := FUN30(FUN31(VAR36), 0)
}
}
function FUN32() internal pure returns(bool VAR37) {
VAR38 {
switch FUN33()
case 0 {
VAR37 := 1
}
case 32 {
FUN34(0, 0, 32)
VAR37 := FUN35(0)
}
default {
revert(0, 0)
}
}
}
function FUN36() internal pure returns(bytes32 VAR37) {
VAR38 {
switch FUN37(FUN33(), 32)
case 1 {
FUN34(0, 0, 32)
VAR37 := FUN35(0)
}
switch FUN30(FUN33(), 32)
case 1 {
FUN34(0, 64, 32)
VAR37 := FUN35(0)
}
switch FUN38(FUN33(), 32)
case 1 {
revert(0, 0)
}
}
}
function FUN39(address VAR39, address VAR7, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR7, value));
return FUN32();
}
function FUN41(address VAR39, address VAR6, address VAR7, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR6, VAR7, value));
return FUN32();
}
function FUN42(address VAR39, address VAR12, uint256 value) internal returns(bool) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40("")), VAR12, value));
return FUN32();
}
//
function FUN43(ERC20 VAR39, address VAR7, uint256 value) internal {
if (value > 0) {
uint256 VAR40 = VAR39.FUN2(this);
FUN39(VAR39, VAR7, value);
require(VAR39.FUN2(this) == VAR40.FUN27(value), "");
}
}
function FUN44(ERC20 VAR39, address VAR6, address VAR7, uint256 value) internal {
if (value > 0) {
uint256 VAR41 = VAR39.FUN2(VAR7);
FUN41(VAR39, VAR6, VAR7, value);
require(VAR39.FUN2(VAR7) == VAR41.FUN28(value), "");
}
}
//
function FUN45(address VAR39) internal view returns(bytes32) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40(""))));
return FUN36();
}
function FUN46(address VAR39) internal view returns(bytes32) {
require(FUN29(VAR39));
require(VAR39.call(bytes4(FUN40(""))));
return FUN36();
}
}
library VAR42 {
function FUN47(address VAR43, uint value, bytes VAR44, uint VAR45, uint VAR46) internal returns(bool VAR37) {
VAR38 {
let VAR47 := FUN35(0x40)
let VAR48 := FUN28(VAR44, 32)
VAR37 := call(
FUN27(VAR49, 34710),
VAR43,
value,
FUN28(VAR48, VAR45),
VAR46,
VAR47,
0
)
}
}
}
contract IEtherToken is VAR13 {
function FUN48() public payable;
function FUN49(uint256 VAR50) public;
}
contract VAR51 {
using SafeMath for uint256;
using CheckedERC20 for VAR13;
using ExternalCall for address;
function() public payable {
require(VAR52.VAR53 != msg.sender);
}
function FUN23(bytes VAR54, uint[] VAR55) public payable {
for (uint VAR16 = 0; VAR16 < VAR55.VAR56 - 1; VAR16++) {
require(address(this).FUN47(0, VAR54, VAR55[VAR16], VAR55[VAR16 + 1] - VAR55[VAR16]));
}
}
function FUN50(address VAR57, uint256 value) external {
require(VAR57.call.value(value)());
}
function FUN51(address VAR57, uint256 VAR58, uint256 VAR59) external {
uint256 value = address(this).VAR40.FUN25(VAR58).FUN26(VAR59);
require(VAR57.call.value(value)());
}
function FUN52(IEtherToken VAR60, uint256 VAR50) external {
VAR60.VAR61.value(VAR50)();
}
function FUN53(IEtherToken VAR60, uint256 VAR58, uint256 VAR59) external {
uint256 VAR50 = address(this).VAR40.FUN25(VAR58).FUN26(VAR59);
VAR60.VAR61.value(VAR50)();
}
function FUN54(IEtherToken VAR60, uint256 VAR50) external {
VAR60.FUN49(VAR50);
}
function FUN55(IEtherToken VAR60, uint256 VAR58, uint256 VAR59) external {
uint256 VAR50 = VAR60.FUN2(this).FUN25(VAR58).FUN26(VAR59);
VAR60.FUN49(VAR50);
}
function FUN56(address VAR57, ERC20 VAR62, uint256 VAR50) external {
require(VAR62.FUN39(VAR57, VAR50));
}
function FUN57(address VAR57, ERC20 VAR62, uint256 VAR58, uint256 VAR59) external {
uint256 VAR50 = VAR62.FUN2(this).FUN25(VAR58).FUN26(VAR59);
require(VAR62.FUN39(VAR57, VAR50));
}
function FUN58(ERC20 VAR62, uint256 VAR50) external {
require(VAR62.FUN41(VAR52.VAR53, this, VAR50));
}
function FUN59(ERC20 VAR62, uint256 VAR58, uint256 VAR59) external {
uint256 VAR50 = VAR62.FUN2(this).FUN25(VAR58).FUN26(VAR59);
require(VAR62.FUN41(VAR52.VAR53, this, VAR50));
}
function FUN60(IMultiToken VAR63, ERC20 VAR62, ERC20 VAR64, uint256 VAR65, uint256 VAR50) external {
if (VAR62.FUN3(this, VAR63) == 0) {
VAR62.FUN42(VAR63, uint256(-1));
}
VAR63.FUN23(VAR62, VAR64, VAR50, VAR65);
}
function FUN61(IMultiToken VAR63, ERC20 VAR62, ERC20 VAR64, uint256 VAR65, uint256 VAR58, uint256 VAR59) external {
uint256 VAR50 = VAR62.FUN2(this).FUN25(VAR58).FUN26(VAR59);
this.FUN60(VAR63, VAR62, VAR64, VAR65, VAR50);
}
}
1
---------------------------------
20 0x1641dba4593e32528bd8937fc751901dc66aa60e.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
address public VAR4;
function FUN1() public payable {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(VAR3 == msg.sender);
VAR5;
}
function FUN2(address VAR6) onlyOwner public {
require(VAR6 != 0);
VAR4 = VAR6;
}
function FUN3() public {
require(VAR4 == msg.sender);
VAR3 = VAR4;
delete VAR4;
}
}
contract VAR7 {
uint public VAR8;
function FUN4(address VAR9) public constant returns (uint);
function transfer(address VAR10, uint value) public;
function FUN5(address VAR3, address VAR11) public constant returns (uint);
function FUN6(address VAR12, address VAR10, uint value) public;
function FUN7(address VAR11, uint value) public;
event FUN8(address indexed VAR3, address indexed VAR11, uint value);
event Transfer(address indexed VAR12, address indexed VAR10, uint value);
}
contract Token is VAR2, VAR7 {
string  public VAR13    = '';
string  public VAR14        = '';
string  public VAR15      = "";
uint8   public VAR16    = 8;
uint    public VAR17;
struct VAR18 {
uint VAR19;
uint VAR20;
uint VAR21;
}
mapping (address => VAR18) public VAR22;
mapping (address => uint) public VAR23;
mapping (address => mapping (address => uint256)) public VAR24;
address public VAR25;
function FUN9(address VAR26) public onlyOwner {
VAR25 = VAR26;
}
function FUN10(address VAR27) internal {
if (VAR22[VAR27].VAR21 <= VAR17) {
VAR22[VAR27].VAR21 = VAR28;
VAR22[VAR27].VAR20 = VAR22[VAR27].VAR19;
}
}
event FUN11(address indexed VAR3, uint256 value);
function FUN12() public FUN1() {}
function FUN4(address VAR27) constant public returns (uint) {
return VAR22[VAR27].VAR19;
}
function transfer(address VAR29, uint256 VAR30) public {
require(VAR28 > VAR23[msg.sender] || msg.sender == VAR25);
require(VAR22[VAR29].VAR19 + VAR30 >= VAR22[VAR29].VAR19);
FUN10(msg.sender);
FUN10(VAR29);
VAR22[msg.sender].VAR19 -= VAR30;
VAR22[VAR29].VAR19 += VAR30;
if (VAR23[VAR29] < VAR23[msg.sender]) {
VAR23[VAR29] = VAR23[msg.sender];
}
emit Transfer(msg.sender, VAR29, VAR30);
}
function FUN6(address VAR31, address VAR29, uint256 VAR30) public {
require(VAR28 > VAR23[VAR31]);
require(VAR22[VAR29].VAR19 + VAR30 >= VAR22[VAR29].VAR19);
require(VAR24[VAR31][msg.sender] >= VAR30);
FUN10(VAR31);
FUN10(VAR29);
VAR22[VAR31].VAR19 -= VAR30;
VAR22[VAR29].VAR19 += VAR30;
VAR24[VAR31][msg.sender] -= VAR30;
emit Transfer(VAR31, VAR29, VAR30);
}
function FUN7(address VAR32, uint256 VAR30) public {
VAR24[msg.sender][VAR32] = VAR30;
emit FUN8(msg.sender, VAR32, VAR30);
}
function FUN5(address VAR6, address VAR32) public constant
returns (uint256 VAR33) {
return VAR24[VAR6][VAR32];
}
function FUN13(uint256 VAR30) public {
require(VAR22[msg.sender].VAR19 >= VAR30);
FUN10(msg.sender);
VAR22[msg.sender].VAR19 -= VAR30;
VAR8 -= VAR30;
emit FUN11(msg.sender, VAR30);
}
}
contract Crowdsale is VAR34 {
address public VAR35;
uint public VAR36;
bool public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR40;
uint public VAR41;
uint public VAR42;
uint public VAR43;
bool public VAR44;
modifier VAR45 {
require(VAR44 == false);
VAR5;
}
event FUN14(address indexed VAR27, uint VAR46, uint VAR47, bytes32 VAR48);
event FUN15(uint VAR49, bool VAR50);
function FUN16() public FUN12() {
VAR8 = 100000000*100000000;
VAR22[this].VAR19 = VAR8;
}
function FUN17(uint VAR51, uint VAR52, uint VAR53) public onlyOwner VAR45 {
require(!VAR37);
require(VAR51 >= VAR41);
VAR38 = VAR51;
VAR39 = VAR52 * 100000000;
if(VAR39 > VAR22[this].VAR19) {
VAR39 = VAR22[this].VAR19;
}
VAR42 = VAR53;
VAR40 = VAR28;
VAR37 = true;
VAR43 = 0;
emit FUN15(VAR36, VAR37);
}
function FUN18() public constant returns(uint) {
uint VAR54;
if(!VAR44 && VAR37) {
uint VAR55 = (VAR28 - VAR40) / 1 VAR56;
VAR54 = VAR38;
VAR54 += VAR38 * VAR55 * VAR42 / 100;
}
return VAR54;
}
function FUN19() public onlyOwner VAR45 {
require(VAR37);
VAR37 = false;
VAR41 = FUN18();
emit FUN15(VAR36, VAR37);
++VAR36;
}
function () payable public VAR45 {
require(VAR37);
uint VAR54 = FUN18();
if(VAR43 < 100) {
VAR54 = VAR54 * 90 / 100;
}
++VAR43;
uint VAR57 = 100000000 * msg.value / VAR54;
if(VAR57 > VAR39) {
VAR57 = VAR39;
uint VAR58 = VAR57 * VAR41 / 100000000;
require(msg.sender.call.FUN20(3000000).value(msg.value - VAR58)());
}
require(VAR57 > 0);
require(VAR22[msg.sender].VAR19 + VAR57 > VAR22[msg.sender].VAR19);
VAR39 -= VAR57;
FUN10(msg.sender);
FUN10(this);
VAR22[msg.sender].VAR19 += VAR57;
VAR22[this].VAR19 -= VAR57;
emit Transfer(this, msg.sender, VAR57);
}
function FUN21(address VAR27, uint VAR46, uint VAR47, bytes32 VAR48) public VAR45 {
require(msg.sender == VAR3 || msg.sender == VAR35);
require(VAR37);
VAR46 *= 100000000;
if(VAR46 > VAR39) {
VAR46 = VAR39;
}
require(VAR46 > 0);
require(VAR22[VAR27].VAR19 + VAR46 > VAR22[VAR27].VAR19);
VAR39 -= VAR46;
FUN10(VAR27);
FUN10(this);
VAR22[VAR27].VAR19 += VAR46;
VAR22[this].VAR19 -= VAR46;
emit FUN14(VAR27, VAR46, VAR47, VAR48);
emit Transfer(this, VAR27, VAR46);
}
function FUN22(address VAR27, uint VAR46, uint VAR59) public VAR45 {
require(msg.sender == VAR3 || msg.sender == VAR35);
require(!VAR37);
require(VAR46 > 0);
VAR46 *= 100000000;
require(VAR46 <= VAR22[this].VAR19);
require(VAR22[VAR27].VAR19 + VAR46 > VAR22[VAR27].VAR19);
if(VAR59 != 0) {
VAR23[VAR27] = VAR59;
}
FUN10(VAR27);
FUN10(this);
VAR22[VAR27].VAR19 += VAR46;
VAR22[this].VAR19 -= VAR46;
emit FUN14(VAR27, VAR46, 0, 0);
emit Transfer(this, VAR27, VAR46);
}
function FUN23() public onlyOwner {
VAR44 = true;
}
}
contract Ehfirst is VAR60 {
function FUN24() payable public FUN16() {}
function FUN25(address VAR61) public onlyOwner {
VAR35 = VAR61;
}
function FUN26() public onlyOwner {
require(VAR3.call.FUN20(3000000).value(address(this).VAR19)());
}
function FUN27() public onlyOwner {
VAR17 = VAR28;
}
function FUN28(address VAR27) constant public returns(uint) {
if (VAR22[VAR27].VAR21 <= VAR17) {
return VAR22[VAR27].VAR19;
} else {
return VAR22[VAR27].VAR20;
}
}
}
1
---------------------------------
21 0x17114e96d507e478f738a5ad864f8c996c529fc7.sol
pragma VAR1 ^0.4.24;
contract VAR2 {
function FUN1() public view returns (uint256);
function FUN2(address VAR3) public view returns (uint256);
function transfer(address VAR4, uint256 value) public returns (bool);
event Transfer(address indexed VAR5, address indexed VAR4, uint256 value);
}
contract ERC20 is VAR2 {
function FUN3(address VAR6, address VAR7)
public view returns (uint256);
function FUN4(address VAR5, address VAR4, uint256 value)
public returns (bool);
function FUN5(address VAR7, uint256 value) public returns (bool);
event FUN6(
address indexed VAR6,
address indexed VAR7,
uint256 value
);
}
contract IBasicMultiToken is VAR8 {
event FUN7(address indexed VAR3, address indexed VAR9, uint256 value);
event FUN8(address indexed VAR3, address indexed VAR9, uint256 value);
function FUN9() public view returns(uint256);
function FUN10(uint256 VAR10) public view returns(VAR8);
function FUN11() public view returns(VAR8[]);
function FUN12() public view returns(uint8[]);
function FUN13() public view returns(uint256[]);
function FUN14() public view returns(VAR8[], uint8[], uint256[]);
function FUN15(address VAR11, uint256 VAR12, uint256[] VAR13) public;
function FUN16(address VAR11, uint256 VAR12) public;
function FUN17(address VAR11, uint256 VAR14) public;
function FUN18(address VAR11, uint256 VAR14, VAR8[] VAR15) public;
function FUN19() public;
function FUN20() public;
}
contract IMultiToken is VAR16 {
event FUN21();
event FUN22(address indexed VAR17, address indexed VAR18, address indexed VAR19, uint256 VAR12, uint256 VAR20);
function FUN23(address VAR17, address VAR18, uint256 VAR12) public view returns (uint256 VAR21);
function FUN24(address VAR17, address VAR18, uint256 VAR12, uint256 VAR22) public returns (uint256 VAR21);
function FUN25() public view returns(uint256[] VAR23);
function FUN26() public view returns(VAR8[] VAR15, uint8[] VAR24, uint256[] VAR25, uint256[] VAR23);
function FUN27() public;
}
library VAR26 {
function FUN28(uint256 VAR27, uint256 VAR28) internal pure returns (uint256 VAR29) {
if (VAR27 == 0) {
return 0;
}
VAR29 = VAR27 * VAR28;
assert(VAR29 / VAR27 == VAR28);
return VAR29;
}
function FUN29(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
return VAR27 / VAR28;
}
function FUN30(uint256 VAR27, uint256 VAR28) internal pure returns (uint256) {
assert(VAR28 <= VAR27);
return VAR27 - VAR28;
}
function FUN31(uint256 VAR27, uint256 VAR28) internal pure returns (uint256 VAR29) {
VAR29 = VAR27 + VAR28;
assert(VAR29 >= VAR27);
return VAR29;
}
}
library VAR30 {
function FUN32(ERC20Basic VAR31, address VAR4, uint256 value) internal {
require(VAR31.transfer(VAR4, value));
}
function FUN33(
ERC20 VAR31,
address VAR5,
address VAR4,
uint256 value
)
internal
{
require(VAR31.FUN4(VAR5, VAR4, value));
}
function FUN34(ERC20 VAR31, address VAR7, uint256 value) internal {
require(VAR31.FUN5(VAR7, value));
}
}
contract VAR32 {
address public VAR6;
event FUN35(address indexed VAR33);
event FUN36(
address indexed VAR33,
address indexed VAR34
);
constructor() public {
VAR6 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR6);
VAR35;
}
function FUN37() public onlyOwner {
emit FUN35(VAR6);
VAR6 = address(0);
}
function FUN38(address VAR36) public onlyOwner {
FUN39(VAR36);
}
function FUN39(address VAR36) internal {
require(VAR36 != address(0));
emit FUN36(VAR6, VAR36);
VAR6 = VAR36;
}
}
contract CanReclaimToken is VAR32 {
using SafeERC20 for VAR2;
function FUN40(ERC20Basic VAR31) external onlyOwner {
uint256 VAR37 = VAR31.FUN2(this);
VAR31.FUN32(VAR6, VAR37);
}
}
contract VAR38 {
function FUN41(
address[] VAR39,
uint256 VAR12,
uint256 VAR22
)
public
payable
returns(uint256);
function FUN42(
address[] VAR39,
uint256 VAR12,
uint256 VAR22
)
public
payable
returns(uint256);
}
contract VAR40 {
function FUN43(
address VAR41,
uint VAR42,
address VAR43,
address VAR44,
uint VAR45,
uint VAR46,
address VAR47
)
public
payable
returns(uint);
}
contract MultiChanger is VAR48 {
using SafeMath for uint256;
function FUN44(uint VAR43, uint VAR41, uint VAR49) private pure {
for(; VAR49 >= 32; VAR49 -= 32) {
VAR50 {
FUN45(VAR43, FUN46(VAR41))
}
VAR43 += 32;
VAR41 += 32;
}
uint VAR51 = 256 ** (32 - VAR49) - 1;
VAR50 {
let VAR52 := FUN47(FUN46(VAR41), FUN48(VAR51))
let VAR53 := FUN47(FUN46(VAR43), VAR51)
FUN45(VAR43, or(VAR53, VAR52))
}
}
function FUN49(bytes VAR54, uint VAR55, uint VAR56) private pure returns(bytes) {
bytes memory VAR57 = VAR58 bytes(VAR56);
uint VAR5;
uint VAR4;
VAR50 {
VAR5 := FUN31(VAR54, VAR55)
VAR4 := VAR57
}
FUN44(VAR4, VAR5, VAR56);
}
function FUN24(
bytes VAR59,
uint[] VAR60
)
internal
{
for (uint VAR61 = 0; VAR61 < VAR60.VAR62 - 1; VAR61++) {
bytes memory VAR63 = FUN49(
VAR59,
VAR60[VAR61],
VAR60[VAR61 + 1] - VAR60[VAR61]
);
require(address(this).call(VAR63));
}
}
function FUN50(address VAR64, bytes VAR54, uint256 VAR14) external {
require(VAR64.call.value(VAR14)(VAR54));
}
function FUN51(address VAR64, bytes VAR54, uint256 VAR65, uint256 VAR66) external {
uint256 value = address(this).VAR37.FUN28(VAR65).FUN29(VAR66);
require(VAR64.call.value(value)(VAR54));
}
function FUN52(address VAR64, bytes VAR54, ERC20 VAR17, uint256 VAR12) external {
if (VAR17.FUN3(this, VAR64) != 0) {
VAR17.FUN5(VAR64, 0);
}
VAR17.FUN5(VAR64, VAR12);
require(VAR64.call(VAR54));
}
function FUN53(address VAR64, bytes VAR54, ERC20 VAR17, uint256 VAR65, uint256 VAR66) external {
uint256 VAR67 = VAR17.FUN2(this).FUN28(VAR65).FUN29(VAR66);
if (VAR17.FUN3(this, VAR64) != 0) {
VAR17.FUN5(VAR64, 0);
}
VAR17.FUN5(VAR64, VAR67);
require(VAR64.call(VAR54));
}
function FUN54(address VAR64, bytes VAR54, ERC20 VAR17, uint256 VAR12) external {
VAR17.transfer(VAR64, VAR12);
require(VAR64.call(VAR54));
}
function FUN55(address VAR64, bytes VAR54, ERC20 VAR17, uint256 VAR65, uint256 VAR66) external {
uint256 VAR67 = VAR17.FUN2(this).FUN28(VAR65).FUN29(VAR66);
VAR17.transfer(VAR64, VAR67);
require(VAR64.call(VAR54));
}
function FUN56(IBancorNetwork VAR68, address[] VAR39, uint256 VAR14) external {
VAR68.VAR69.value(VAR14)(VAR39, VAR14, 1);
}
function FUN57(IBancorNetwork VAR68, address[] VAR39, uint256 VAR65, uint256 VAR66) external {
uint256 value = address(this).VAR37.FUN28(VAR65).FUN29(VAR66);
VAR68.VAR69.value(value)(VAR39, value, 1);
}
function FUN58(IBancorNetwork VAR68, address[] VAR39, uint256 VAR12) external {
if (FUN59(VAR39[0]).FUN3(this, VAR68) == 0) {
FUN59(VAR39[0]).FUN5(VAR68, uint256(-1));
}
VAR68.FUN42(VAR39, VAR12, 1);
}
function FUN60(IBancorNetwork VAR68, address[] VAR39, uint256 VAR65, uint256 VAR66) external {
uint256 VAR67 = FUN59(VAR39[0]).FUN2(this).FUN28(VAR65).FUN29(VAR66);
if (FUN59(VAR39[0]).FUN3(this, VAR68) == 0) {
FUN59(VAR39[0]).FUN5(VAR68, uint256(-1));
}
VAR68.FUN42(VAR39, VAR67, 1);
}
function FUN61(IBancorNetwork VAR68, address[] VAR39, uint256 VAR12) external {
FUN59(VAR39[0]).transfer(VAR68, VAR12);
VAR68.FUN41(VAR39, VAR12, 1);
}
function FUN62(IBancorNetwork VAR68, address[] VAR39, uint256 VAR65, uint256 VAR66) external {
uint256 VAR67 = FUN59(VAR39[0]).FUN2(this).FUN28(VAR65).FUN29(VAR66);
FUN59(VAR39[0]).transfer(VAR68, VAR67);
VAR68.FUN41(VAR39, VAR67, 1);
}
function FUN63(IBancorNetwork VAR68, address[] VAR39, uint256 VAR12) external {
VAR68.FUN41(VAR39, VAR12, 1);
}
function FUN64(IBancorNetwork VAR68, address[] VAR39, uint256 VAR65, uint256 VAR66) external {
uint256 VAR67 = FUN59(VAR39[0]).FUN2(VAR68).FUN28(VAR65).FUN29(VAR66);
VAR68.FUN41(VAR39, VAR67, 1);
}
function FUN65(IKyberNetworkProxy VAR70, ERC20 VAR17, address VAR18, uint256 VAR65, uint256 VAR66) external {
uint256 value = address(this).VAR37.FUN28(VAR65).FUN29(VAR66);
VAR70.VAR71.value(value)(
VAR17,
value,
VAR18,
this,
1 << 255,
0,
0
);
}
function FUN66(IKyberNetworkProxy VAR70, ERC20 VAR17, address VAR18, uint256 VAR12) external {
if (VAR17.FUN3(this, VAR70) == 0) {
VAR17.FUN5(VAR70, uint256(-1));
}
VAR70.FUN43(
VAR17,
VAR12,
VAR18,
this,
1 << 255,
0,
0
);
}
function FUN67(IKyberNetworkProxy VAR70, ERC20 VAR17, address VAR18, uint256 VAR65, uint256 VAR66) external {
uint256 VAR67 = VAR17.FUN2(this).FUN28(VAR65).FUN29(VAR66);
this.FUN66(VAR70, VAR17, VAR18, VAR67);
}
}
contract MultiBuyer is VAR72 {
function FUN68(
IMultiToken VAR73,
uint256 VAR74,
bytes VAR59,
uint[] VAR60
)
public
payable
{
FUN24(VAR59, VAR60);
uint VAR75 = VAR73.FUN1();
uint256 VAR76 = uint256(-1);
for (uint VAR61 = VAR73.FUN9(); VAR61 > 0; VAR61--) {
ERC20 VAR31 = VAR73.FUN10(VAR61 - 1);
if (VAR31.FUN3(this, VAR73) == 0) {
VAR31.FUN5(VAR73, uint256(-1));
}
uint256 VAR67 = VAR75.FUN28(VAR31.FUN2(this)).FUN29(VAR31.FUN2(VAR73));
if (VAR67 < VAR76) {
VAR76 = VAR67;
}
}
require(VAR76 >= VAR74, "");
VAR73.FUN16(msg.sender, VAR76);
}
function FUN69(
IMultiToken VAR73,
bytes VAR59,
uint[] VAR60
)
public
payable
{
FUN24(VAR59, VAR60);
uint VAR77 = VAR73.FUN9();
uint256[] memory VAR78 = new uint256[](VAR77);
for (uint VAR61 = 0; VAR61 < VAR77; VAR61++) {
ERC20 VAR31 = VAR73.FUN10(VAR61);
VAR78[VAR61] = VAR31.FUN2(this);
if (VAR31.FUN3(this, VAR73) == 0) {
VAR31.FUN5(VAR73, uint256(-1));
}
}
VAR73.FUN15(msg.sender, msg.value.FUN28(1000), VAR78);
}
}
1
---------------------------------
22 0x179a303c1fdff0ffbda6a68b384787621b78ee84.sol
pragma VAR1 ^0.4.10;
contract VAR2 {
address public VAR3;
address public VAR4;
function FUN1() public payable {
VAR3 = msg.sender;
}
modifier onlyOwner {
require(VAR3 == msg.sender);
VAR5;
}
function FUN2(address VAR6) onlyOwner public {
require(VAR6 != 0);
VAR4 = VAR6;
}
function FUN3() public {
require(VAR4 == msg.sender);
VAR3 = VAR4;
delete VAR4;
}
}
contract VAR7 {
uint public VAR8;
function FUN4(address VAR9) public constant returns (uint);
function transfer(address VAR10, uint value) public ;
function FUN5(address VAR3, address VAR11) public constant returns (uint);
function FUN6(address VAR12, address VAR10, uint value) public;
function FUN7(address VAR11, uint value) public;
event FUN8(address indexed VAR3, address indexed VAR11, uint value);
event Transfer(address indexed VAR12, address indexed VAR10, uint value);
}
contract PresaleOriginal is VAR2, VAR7 {
uint    public VAR13;
uint    public VAR14;
uint    public VAR15;
struct VAR16 {
uint256 VAR17;
uint    VAR18;
}
mapping (address => VAR16) public VAR19;
mapping (uint => address)     public VAR20;
uint                          public VAR21;
}
contract Presale is VAR22 {
uint    public VAR23;
address public VAR24;
enum VAR25 { VAR26, VAR27, VAR28 }
event FUN9(State VAR29);
State   public VAR29;
uint    public VAR30;
uint    public VAR31;
function FUN10(address VAR32, uint VAR33) public onlyOwner {
require(VAR29 == VAR25.VAR26);
VAR21 = FUN11(VAR32).FUN12();
uint VAR34 = VAR31 + VAR33;
if(VAR34 > VAR21) {
VAR34 = VAR21;
}
for(; VAR31 < VAR34; ++VAR31) {
address VAR35 = FUN11(VAR32).FUN13(VAR31);
VAR20[VAR31] = VAR35;
uint256 VAR17;
uint VAR18;
(VAR17, VAR18) = FUN11(VAR32).FUN14(VAR35);
VAR17 *= 2;
VAR19[VAR35].VAR17 = VAR17;
VAR19[VAR35].VAR18 = VAR18;
VAR8 += VAR17;
Transfer(VAR32, VAR35, VAR17);
}
if(VAR34 < VAR21) {
return;
}
VAR15 = FUN11(VAR32).FUN15();
VAR14 = FUN11(VAR32).FUN16();
VAR13 = FUN11(VAR32).FUN17();
address VAR36 = 0x59B95A5e0268Cc843e6308FEf723544BaA6676c6;
if(VAR19[VAR36].VAR18 == 0 && VAR19[VAR36].VAR17 == 0) {
VAR20[VAR21++] = VAR36;
}
uint VAR37 = 5 * FUN11(VAR32).FUN18() / 100;
VAR19[VAR36].VAR17 += VAR37;
VAR8 += VAR37;
}
function () payable public {
require(VAR29 == VAR25.VAR27);
require(VAR38 < VAR30);
uint VAR39 = msg.value;
uint VAR40 = VAR39 * VAR23 / 1000000000000000000;
if (VAR14 + VAR40 > VAR13) {
VAR40 = VAR13 - VAR14;
VAR39 = VAR40 * 1000000000000000000 / VAR23;
require(msg.sender.call.FUN19(3000000).value(msg.value - VAR39)());
VAR14 = VAR13;
} else {
VAR14 += VAR40;
}
uint256 VAR41 = 130;
if (VAR40 >= 100000) {
VAR41 = 150;
}
uint256 VAR42 = VAR41 * VAR40 / 10;
require(VAR42 > 0);
Investor storage VAR43 = VAR19[msg.sender];
if (VAR43.VAR18 == 0) {
VAR20[VAR21++] = msg.sender;
}
require(VAR43.VAR17 + VAR42 > VAR43.VAR17);
VAR43.VAR17 += VAR42;
VAR43.VAR18 += VAR39;
VAR8 += VAR42;
Transfer(this, msg.sender, VAR42);
}
function FUN20(address VAR44, uint VAR45) public onlyOwner {
require(VAR29 == VAR25.VAR26);
VAR24 = VAR44;
VAR23 = VAR45;
VAR30 = 1526342400;
VAR29 = VAR25.VAR27;
VAR13 = 500000;
FUN9(VAR29);
}
function FUN21(uint VAR45) public onlyOwner {
require(VAR29 == VAR25.VAR27);
VAR23 = VAR45;
}
function FUN22() public constant returns(uint VAR46) {
require(VAR29 == VAR25.VAR27);
if (VAR38 > VAR30) {
VAR46 = 0;
} else {
VAR46 = VAR30 - VAR38;
}
}
function FUN23() public onlyOwner {
require(VAR29 == VAR25.VAR27);
require(VAR38 >= VAR30 || VAR14 == VAR13);
require(VAR24.call.FUN19(3000000).value(this.VAR47)());
VAR29 = VAR25.VAR28;
FUN9(VAR29);
}
function FUN24() public onlyOwner {
require(VAR24.call.FUN19(3000000).value(this.VAR47)());
}
}
contract PresaleToken is VAR27 {
string  public VAR48    = '';
string  public VAR49        = '';
string  public VAR50      = "";
uint8   public VAR51    = 0;
mapping (address => mapping (address => uint)) public VAR52;
modifier FUN25(uint VAR53) {
require(msg.VAR54.VAR55 >= VAR53 + 4);
VAR5;
}
function FUN26() payable public FUN27() {}
function FUN4(address VAR56) constant public returns (uint) {
return VAR19[VAR56].VAR17;
}
function transfer(address VAR57, uint256 VAR58) public FUN25(2 * 32) {
require(VAR19[msg.sender].VAR17 >= VAR58);
require(VAR19[VAR57].VAR17 + VAR58 >= VAR19[VAR57].VAR17);
VAR19[msg.sender].VAR17 -= VAR58;
if(VAR19[VAR57].VAR17 == 0 && VAR19[VAR57].VAR18 == 0) {
VAR20[VAR21++] = VAR57;
}
VAR19[VAR57].VAR17 += VAR58;
Transfer(msg.sender, VAR57, VAR58);
}
function FUN6(address VAR59, address VAR57, uint VAR58) public FUN25(3 * 32) {
require(VAR19[VAR59].VAR17 >= VAR58);
require(VAR19[VAR57].VAR17 + VAR58 >= VAR19[VAR57].VAR17);
require(VAR52[VAR59][msg.sender] >= VAR58);
VAR19[VAR59].VAR17 -= VAR58;
if(VAR19[VAR57].VAR17 == 0 && VAR19[VAR57].VAR18 == 0) {
VAR20[VAR21++] = VAR57;
}
VAR19[VAR57].VAR17 += VAR58;
VAR52[VAR59][msg.sender] -= VAR58;
Transfer(VAR59, VAR57, VAR58);
}
function FUN7(address VAR60, uint VAR58) public {
VAR52[msg.sender][VAR60] = VAR58;
FUN8(msg.sender, VAR60, VAR58);
}
function FUN5(address VAR6, address VAR60) public constant
returns (uint VAR61) {
return VAR52[VAR6][VAR60];
}
}
contract OpenLongevityPresale is VAR62 {
function FUN28() payable public FUN26() {}
function FUN29() public onlyOwner {
FUN30(VAR3);
}
}
1
---------------------------------
23 0x17e5629660c3ee2ac68498e24e8607a712ba64ff.sol
pragma VAR1 ^0.4.19;
contract VAR2 {
address public VAR3;
function FUN1() internal {
VAR3 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR3);
VAR4;
}
function FUN2(address VAR5) onlyOwner public {
require(VAR5 != address(0));
VAR3 = VAR5;
}
}
interface VAR6 {
function FUN3() public view returns (uint256);
function FUN4(address VAR7) public view returns (uint256);
function transfer(address VAR8, uint256 value) public returns (bool VAR9);
function FUN5(address VAR10, address VAR8, uint256 value) public returns (bool VAR9);
function FUN6(address VAR11, uint256 value) public returns (bool VAR9);
function FUN7(address VAR3, address VAR11) public view returns (uint256 VAR12);
event Transfer(address indexed VAR10, address indexed VAR8, uint256 value);
event FUN8(address indexed VAR3, address indexed VAR11, uint256 value);
}
contract PinProtocolInvestment is VAR2 {
address public VAR13 = 0x77D0f9017304e53181d9519792887E78161ABD25;
address public VAR14 = 0x8f0592bDCeE38774d93bC1fd2c97ee6540385356;
address public VAR15 = 0xC787C3f6F75D7195361b64318CE019f90507f806;
uint public VAR16 = 1000;
function() payable public {
FUN9(msg.value);
}
function FUN9(uint VAR17) internal {
uint VAR18 = VAR17 * 6 / (10 * 11);
uint VAR19 = VAR17 * 4 / (10 * 11);
require(VAR14.call.FUN10(VAR16).value(VAR18)());
require(VAR15.call.FUN10(VAR16).value(VAR19)());
require(VAR13.call.FUN10(VAR16).value(VAR17 - VAR18 - VAR19)());
}
function FUN11(uint VAR20) public onlyOwner {
VAR16 = VAR20;
}
function FUN12(EIP20Token VAR21, address VAR22, uint value) public onlyOwner {
VAR21.FUN6(VAR22, value);
}
function FUN13() public onlyOwner {
require(msg.sender.call.FUN10(VAR16).value(this.VAR23)());
}
}
1
---------------------------------
24 0x18d70bd7bdfa7e424271fe25b527ee0250db5c90.sol
pragma VAR1 ^0.4.11;
pragma VAR1 ^0.4.11;
library VAR2 {
function FUN1(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN2(uint64 VAR3, uint64 VAR4) internal constant returns (VAR5) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 >= VAR4 ? VAR3 : VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal constant returns (uint256) {
return VAR3 < VAR4 ? VAR3 : VAR4;
}
}
contract VAR6 {
uint256 public VAR7;
function FUN5(address VAR8) constant returns (uint256);
function transfer(address VAR9, uint256 value) returns (bool);
event Transfer(address indexed VAR10, address indexed VAR9, uint256 value);
}
contract VAR11 {
address public VAR12;
function FUN6() {
VAR12 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
function FUN7(address VAR14) onlyOwner {
if (VAR14 != address(0)) {
VAR12 = VAR14;
}
}
}
contract ICOBuyer is VAR11 {
event FUN8(address indexed VAR15, uint256 VAR16);
event FUN9(uint256 VAR16);
event FUN10(uint256 VAR17);
event FUN11(uint256 VAR16);
event FUN12(uint256 VAR18);
event FUN13(uint256 VAR19);
event FUN14(address VAR20);
event FUN15(address VAR21);
event FUN16(address VAR22);
event FUN17(uint256 VAR23);
event FUN18(uint256 VAR24);
uint256 public VAR25;
uint256 public VAR26;
address public VAR27;
address public VAR28;
uint256 public VAR29;
uint256 public VAR30 = 0.1 VAR31;
modifier FUN19() {
require((msg.sender == VAR28) || (msg.sender == VAR12));
VAR13;
}
function FUN20(address VAR20, address VAR21, uint256 VAR18, uint256 VAR19, uint256 VAR23) {
VAR28 = VAR20;
VAR27 = VAR21;
VAR25 = VAR18;
VAR26 = VAR19;
VAR29 = VAR23;
}
function FUN21(address VAR21) onlyOwner {
VAR27 = VAR21;
FUN15(VAR27);
}
function FUN22(uint256 VAR18) VAR32 {
VAR25 = VAR18;
FUN12(VAR25);
}
function FUN23(uint256 VAR24) VAR32 {
VAR30 = VAR24;
FUN18(VAR30);
}
function FUN24(uint256 VAR19) VAR32 {
VAR26 = VAR19;
FUN13(VAR26);
}
function FUN25(uint256 VAR23) onlyOwner {
VAR29 = VAR23;
FUN17(VAR29);
}
function FUN26(address VAR20) onlyOwner {
VAR28 = VAR20;
FUN14(VAR20);
}
function FUN27() onlyOwner {
require(this.VAR33 != 0);
VAR12.transfer(this.VAR33);
FUN9(this.VAR33);
}
function FUN28(address VAR22) onlyOwner {
ERC20Basic VAR34 = FUN29(VAR22);
uint256 VAR35 = VAR34.FUN5(address(this));
require(VAR35 != 0);
assert(VAR34.transfer(VAR12, VAR35));
FUN10(VAR35);
}
function FUN30() {
if ((VAR25 != 0) && (FUN31() < VAR25)) return;
if ((VAR26 != 0) && (FUN32() < VAR26)) return;
if (this.VAR33 < VAR30) return;
uint256 VAR36 = VAR2.FUN4(this.VAR33, VAR29);
assert(VAR27.call.value(VAR36)());
FUN11(VAR36);
}
function () payable {
FUN8(msg.sender, msg.value);
}
function FUN31() internal constant returns (uint256) {
return VAR37.VAR38;
}
function FUN32() internal constant returns (uint256) {
return VAR39;
}
}
1
---------------------------------
25 0x1b85e0f97c5b3f5f815475f67d9df162cf35d3dc.sol
pragma VAR1 ^0.4.13;
library VAR2 {
function FUN1(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
if (VAR3 == 0) {
return 0;
}
uint256 VAR5 = VAR3 * VAR4;
assert(VAR5 / VAR3 == VAR4);
return VAR5;
}
function FUN2(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 / VAR4;
return VAR5;
}
function FUN3(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
assert(VAR4 <= VAR3);
return VAR3 - VAR4;
}
function FUN4(uint256 VAR3, uint256 VAR4) internal pure returns (uint256) {
uint256 VAR5 = VAR3 + VAR4;
assert(VAR5 >= VAR3);
return VAR5;
}
}
contract VAR6 {
address public VAR7;
modifier onlyManager {
require(msg.sender == VAR7);
VAR8;
}
function FUN5(address VAR9) public onlyManager() {
require(VAR9 != address(0));
VAR7 = VAR9;
}
}
contract VAR10 {
function FUN6() public view returns (uint256);
function FUN7(address VAR11) public view returns (uint256);
function transfer(address VAR12, uint256 value) public returns (bool);
event Transfer(address indexed VAR13, address indexed VAR12, uint256 value);
}
contract VAR14 {
uint256 public VAR15;
uint256 public VAR16;
}
contract VAR17 {
address public VAR18;
event FUN8(address indexed VAR19, address indexed VAR20);
function FUN9() public {
VAR18 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR18);
VAR8;
}
function FUN10(address VAR20) public onlyOwner {
require(VAR20 != address(0));
FUN8(VAR18, VAR20);
VAR18 = VAR20;
}
}
contract ICrowdsaleProcessor is VAR17, VAR6 {
modifier FUN11() {
require(FUN12());
VAR8;
}
modifier FUN13() {
require(FUN14());
VAR8;
}
modifier FUN15() {
require(FUN16());
VAR8;
}
modifier FUN17() {
require(!VAR21);
VAR8;
}
modifier FUN18() {
require(VAR21);
VAR8;
}
modifier FUN19() {
require(!VAR22);
VAR8;
}
modifier FUN20() {
require(VAR22);
VAR8;
}
uint256 constant public VAR23 = 1 VAR24;
uint256 constant public VAR25 = 3 VAR26;
uint256 constant public VAR27 = 50 VAR26;
bool public VAR22;
bool public VAR21;
uint256 public VAR28;
uint256 public VAR29;
uint256 public VAR30;
uint256 public VAR31;
uint256 public VAR32;
uint256 public VAR33;
uint256 public VAR34;
function FUN21() public payable {}
function FUN22() public returns(address);
function FUN23(address VAR35, uint256 VAR36) public onlyManager();
function FUN24(address VAR35, uint256 VAR36) public onlyManager();
function FUN25() public onlyManager() FUN17() FUN15();
function FUN26() public onlyManager() FUN17();
function FUN27(uint256 VAR37, uint256 VAR38, address VAR39)
public onlyManager() FUN19() FUN17();
function FUN14() public constant returns (bool);
function FUN12() public constant returns (bool);
function FUN16() public constant returns (bool);
}
contract BasicToken is VAR10 {
using SafeMath for uint256;
mapping(address => uint256) VAR40;
uint256 VAR41;
function FUN6() public view returns (uint256) {
return VAR41;
}
function transfer(address VAR42, uint256 VAR43) public returns (bool) {
require(VAR42 != address(0));
require(VAR43 <= VAR40[msg.sender]);
VAR40[msg.sender] = VAR40[msg.sender].FUN3(VAR43);
VAR40[VAR42] = VAR40[VAR42].FUN4(VAR43);
Transfer(msg.sender, VAR42, VAR43);
return true;
}
function FUN7(address VAR44) public view returns (uint256 VAR45) {
return VAR40[VAR44];
}
}
contract DefaultToken is VAR46 {
string public VAR47;
string public VAR48;
uint8 public VAR49;
constructor(string VAR50, string VAR51, uint8 VAR52) {
VAR47 = VAR50;
VAR48 = VAR51;
VAR49 = VAR52;
}
}
contract BasicCrowdsale is VAR53 {
event FUN28(uint256 VAR33, uint256 VAR34, address VAR54);
address public VAR54;
function FUN29(
address VAR44,
address VAR55
)
public
{
VAR18 = VAR44;
VAR7 = VAR55;
}
function FUN23(
address VAR35,
uint256 VAR36
)
public
onlyManager()
{
require(VAR35.call.value(VAR36)());
}
function FUN26() public onlyManager() FUN17()  {
if (VAR22) {
require(!FUN14());
require(!FUN16());
}
VAR21 = true;
}
function FUN27(
uint256 VAR37,
uint256 VAR38,
address VAR39
)
public
onlyManager()
FUN19()
FUN17()
{
require(VAR39 != address(0));
require(VAR37 >= VAR56.VAR57);
require(VAR38 > VAR37);
VAR32 = VAR38 - VAR37;
require(VAR32 >= VAR25 && VAR32 <= VAR27);
VAR33 = VAR37;
VAR34 = VAR38;
VAR54 = VAR39;
VAR22 = true;
FUN28(VAR37, VAR38, VAR39);
}
function FUN14()
public
constant
returns(bool)
{
return (
VAR22 &&
VAR56.VAR57 >= VAR34 &&
VAR28 < VAR30
);
}
function FUN12()
public
constant
returns(bool)
{
return (
VAR22 &&
VAR28 < VAR31 &&
VAR56.VAR57 >= VAR33 &&
VAR56.VAR57 < VAR34
);
}
function FUN16()
public
constant
returns(bool)
{
return (
VAR28 >= VAR31 ||
(VAR56.VAR57 >= VAR34 && VAR28 >= VAR30)
);
}
}
contract Bridge is VAR58 {
using SafeMath for uint256;
event FUN30(address VAR59, uint8 VAR49);
event FUN31();
DefaultToken VAR59;
bool VAR60;
constructor(
uint256 VAR61,
uint256 VAR62,
address VAR63
)
FUN29(msg.sender, msg.sender)
{
VAR30 = VAR61;
VAR31 = VAR62;
VAR59 = FUN32(VAR63);
}
function FUN22()
public
returns (address)
{
return address(VAR59);
}
function FUN24(
address VAR35,
uint256 VAR36
)
public
onlyManager()
{
VAR59.transfer(VAR35, VAR36);
}
function FUN25() public onlyManager() FUN17() FUN15() {
}
function() public payable {
}
function FUN33(uint256 VAR64, uint256 VAR65)
public
FUN20()
FUN17()
FUN11()
onlyOwner()
{
VAR28 = VAR28.FUN4(VAR64);
VAR29 = VAR29.FUN4(VAR65);
}
function FUN27(
uint256 VAR37,
uint256 VAR38,
address VAR39
)
public
FUN19()
FUN17()
onlyManager()
{
VAR22 = true;
emit FUN28(VAR37, VAR38, VAR39);
}
function FUN34()
public
FUN17()
FUN20()
FUN11()
onlyOwner()
{
VAR60 = true;
emit FUN31();
}
function FUN14()
public
view
returns (bool)
{
return (false);
}
function FUN12()
public
view
returns (bool)
{
return (VAR22 && !VAR60);
}
function FUN16()
public
view
returns (bool)
{
return (VAR60);
}
function FUN35() public view returns (uint256, uint256) {
uint256 VAR16 = FUN36(VAR7).FUN37();
uint256 VAR15 = FUN36(VAR7).FUN38();
uint256 VAR66 = VAR29.FUN1(VAR16) / 1000000;
uint256 VAR67 = (VAR15 == 0) ? 0 : (VAR28.FUN1(VAR15) / 1000000);
return (VAR67, VAR66);
}
function FUN39(address VAR68) public onlyOwner() {
VAR59 = FUN32(VAR68);
emit FUN30(address(VAR59), uint8(VAR59.FUN40()));
}
}
1
---------------------------------
26 0x0000000000085d4780b73119b644ae5ecd22b376.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1() public view returns (address);
function() external payable {
address VAR3 = FUN1();
require(VAR3 != address(0), "");
VAR4 {
let VAR5 := FUN2(0x40)
FUN3(VAR5, 0, VAR6)
let VAR7 := FUN4(VAR8, VAR3, VAR5, VAR6, 0, 0)
let VAR9 := VAR10
FUN5(VAR5, 0, VAR9)
switch VAR7
case 0 { revert(VAR5, VAR9) }
default { return(VAR5, VAR9) }
}
}
}
contract UpgradeabilityProxy is VAR2 {
event FUN6(address indexed VAR11);
bytes32 private constant VAR12 = FUN7("");
function FUN1() public view returns (address VAR13) {
bytes32 VAR14 = VAR12;
VAR4 {
VAR13 := FUN8(VAR14)
}
}
function FUN9(address VAR15) internal {
bytes32 VAR14 = VAR12;
VAR4 {
FUN10(VAR14, VAR15)
}
}
function FUN11(address VAR15) internal {
address VAR16 = FUN1();
require(VAR16 != VAR15);
FUN9(VAR15);
emit FUN6(VAR15);
}
}
contract OwnedUpgradeabilityProxy is VAR17 {
event FUN12(address indexed VAR18, address indexed VAR19);
event FUN13(address VAR20, address VAR21);
bytes32 private constant VAR22 = FUN7("");
bytes32 private constant VAR23 = FUN7("");
constructor() public {
FUN14(msg.sender);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN15(), "");
VAR24;
}
modifier FUN16() {
require(msg.sender == FUN17(), "");
VAR24;
}
function FUN15() public view returns (address VAR25) {
bytes32 VAR14 = VAR22;
VAR4 {
VAR25 := FUN8(VAR14)
}
}
function FUN17() public view returns (address VAR21) {
bytes32 VAR14 = VAR23;
VAR4 {
VAR21 := FUN8(VAR14)
}
}
function FUN14(address VAR26) internal {
bytes32 VAR14 = VAR22;
VAR4 {
FUN10(VAR14, VAR26)
}
}
function FUN18(address VAR27) internal {
bytes32 VAR14 = VAR23;
VAR4 {
FUN10(VAR14, VAR27)
}
}
function FUN19(address VAR19) external onlyProxyOwner {
require(VAR19 != address(0));
FUN18(VAR19);
emit FUN13(FUN15(), VAR19);
}
function FUN20() external VAR28 {
emit FUN12(FUN15(), FUN17());
FUN14(FUN17());
FUN18(address(0));
}
function FUN21(address VAR11) external onlyProxyOwner {
FUN11(VAR11);
}
}
0
---------------------------------
27 0x00000000000da14c27c155bb7c1ac9bd7519eb3b.sol
pragma VAR1 ^0.4.23;
interface VAR2 {
function FUN1(address VAR3, bytes32 VAR4, uint VAR5) external;
function FUN2(address VAR6, bytes32 VAR7) external view returns(bool);
}
contract VAR8 {
Registry public VAR9;
bytes32 public constant VAR10 = "";
event FUN3(address VAR11);
constructor(address VAR12) public {
VAR9 = FUN4(VAR12);
}
function FUN5() public {
address VAR13 = address(uint(msg.sender) >> 20);
require(!VAR9.FUN2(VAR13, VAR10), "");
VAR9.FUN1(VAR13, VAR10, uint(msg.sender));
emit FUN3(msg.sender);
}
function() external payable {
FUN5();
msg.sender.transfer(msg.value);
}
}
0
---------------------------------
28 0x00000000000fe8503db73c68f1a1874eb9d86883.sol
pragma solidity 0.5.0;
contract VAR1 {
address private VAR2;
address private VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
constructor() public {
FUN2(msg.sender);
}
modifier FUN3() {
require(msg.sender == VAR3, "");
VAR6;
}
modifier onlyOwner() {
require(msg.sender == VAR2, "");
VAR6;
}
function FUN4() public view returns (address) {
return VAR3;
}
function FUN5() public view returns (address ) {
return VAR2;
}
function FUN2(address VAR7) internal {
VAR2 = VAR7;
}
function FUN6(address VAR7) public onlyOwner {
VAR3 = VAR7;
}
function FUN7() public VAR8 {
emit FUN1(VAR2, VAR3);
VAR2 = VAR3;
VAR3 = address(0);
}
}
pragma solidity 0.5.0;
contract Operable is VAR1 {
address private VAR9;
event FUN8(address indexed VAR10, address indexed VAR11);
function FUN9() external view returns (address) {
return VAR9;
}
modifier FUN10() {
require(msg.sender == VAR9, "");
VAR6;
}
function FUN11(address VAR12) public onlyOwner {
require(VAR12 != address(0), "");
emit FUN8(VAR9, VAR12);
VAR9 = VAR12;
}
}
pragma solidity 0.5.0;
library VAR13 {
function FUN12(uint256 VAR14, uint256 VAR15) internal pure returns (uint256) {
if (VAR14 == 0) {
return 0;
}
uint256 VAR16 = VAR14 * VAR15;
require(VAR16 / VAR14 == VAR15);
return VAR16;
}
function FUN13(uint256 VAR14, uint256 VAR15) internal pure returns (uint256) {
require(VAR15 > 0);
uint256 VAR16 = VAR14 / VAR15;
return VAR16;
}
function FUN14(uint256 VAR14, uint256 VAR15) internal pure returns (uint256) {
require(VAR15 <= VAR14);
uint256 VAR16 = VAR14 - VAR15;
return VAR16;
}
function FUN15(uint256 VAR14, uint256 VAR15) internal pure returns (uint256) {
uint256 VAR16 = VAR14 + VAR15;
require(VAR16 >= VAR14);
return VAR16;
}
function FUN16(uint256 VAR14, uint256 VAR15) internal pure returns (uint256) {
require(VAR15 != 0);
return VAR14 % VAR15;
}
}
pragma solidity 0.5.0;
contract TokenStore is VAR17 {
using SafeMath for uint256;
uint256 public VAR18;
string  public VAR19 = "";
string  public VAR20 = "";
uint8 public VAR21 = 18;
mapping (address => uint256) public VAR22;
mapping (address => mapping (address => uint256)) public VAR23;
function FUN17(string memory VAR24, string memory VAR25) public VAR26 {
VAR19 = VAR24;
VAR20 = VAR25;
}
function FUN18(address VAR27, uint256 VAR28) public VAR26 {
VAR22[VAR27] = VAR22[VAR27].FUN15(VAR28);
}
function FUN19(address VAR27, uint256 VAR28) public VAR26 {
VAR22[VAR27] = VAR22[VAR27].FUN14(VAR28);
}
function FUN20(address VAR27, uint256 VAR28) public VAR26 {
VAR22[VAR27] = VAR28;
}
function FUN21(address VAR27, address VAR29, uint256 VAR28) public VAR26 {
VAR23[VAR27][VAR29] = VAR23[VAR27][VAR29].FUN15(VAR28);
}
function FUN22(address VAR27, address VAR29, uint256 VAR28) public VAR26 {
VAR23[VAR27][VAR29] = VAR23[VAR27][VAR29].FUN14(VAR28);
}
function FUN23(address VAR27, address VAR29, uint256 VAR28) public VAR26 {
VAR23[VAR27][VAR29] = VAR28;
}
function FUN24(uint256 VAR28) public VAR26 {
VAR18 = VAR18.FUN15(VAR28);
}
function FUN25(uint256 VAR28) public VAR26 {
VAR18 = VAR18.FUN14(VAR28);
}
function FUN26(uint256 VAR28) public VAR26 {
VAR18 = VAR28;
}
}
pragma solidity 0.5.0;
interface VAR30 {
function FUN27() external view returns (uint256);
function FUN28(address VAR31) external view returns (uint256);
function FUN29(address VAR31, address VAR32) external view returns (uint256);
function transfer(address VAR33, uint256 value) external returns (bool);
function FUN30(address VAR32, uint256 value) external returns (bool);
function FUN31(address VAR34, address VAR33, uint256 value) external returns (bool);
event Transfer(address indexed VAR34, address indexed VAR33, uint256 value);
event FUN32(address indexed VAR31, address indexed VAR32, uint256 value);
}
pragma solidity 0.5.0;
contract ERC20StandardToken is VAR30, VAR1 {
TokenStore public VAR35;
event FUN33(address indexed VAR36, address indexed VAR37);
event FUN34(string VAR38, string VAR39);
function FUN35(address VAR40) public onlyOwner returns (bool) {
emit FUN33(address(VAR35), VAR40);
VAR35 = FUN36(VAR40);
return true;
}
function FUN17(string memory VAR24, string memory VAR25) public onlyOwner {
VAR35.FUN17(VAR24, VAR25);
emit FUN34(VAR24, VAR25);
}
function FUN27() public view returns (uint256) {
return VAR35.FUN27();
}
function FUN28(address VAR27) public view returns (uint256) {
return VAR35.FUN37(VAR27);
}
function FUN29(address VAR27, address VAR29) public view returns (uint256) {
return VAR35.FUN38(VAR27, VAR29);
}
function FUN39() public view returns (string VAR41) {
return VAR35.FUN39();
}
function FUN40() public view returns (string VAR41) {
return VAR35.FUN40();
}
function FUN41() public view returns (uint8) {
return VAR35.FUN41();
}
function FUN30(
address VAR29,
uint256 VAR28
) public returns (bool VAR42) {
require (VAR29 != address(0), "");
VAR35.FUN23(msg.sender, VAR29, VAR28);
emit FUN32(msg.sender, VAR29, VAR28);
return true;
}
function FUN42(
address VAR29,
uint256 VAR43
) public returns (bool VAR42) {
require (VAR29 != address(0), "");
VAR35.FUN21(msg.sender, VAR29, VAR43);
emit FUN32(msg.sender, VAR29, VAR35.FUN38(msg.sender, VAR29));
return true;
}
function FUN43(
address VAR29,
uint256 VAR44
) public returns (bool VAR42) {
require (VAR29 != address(0), "");
VAR35.FUN22(msg.sender, VAR29, VAR44);
emit FUN32(msg.sender, VAR29, VAR35.FUN38(msg.sender, VAR29));
return true;
}
function FUN31(
address VAR45,
address VAR46,
uint256 VAR28
) public returns (bool VAR42) {
require(VAR46 != address(0), "");
VAR35.FUN22(VAR45, msg.sender, VAR28);
VAR35.FUN19(VAR45, VAR28);
VAR35.FUN18(VAR46, VAR28);
emit Transfer(VAR45, VAR46, VAR28);
return true;
}
function transfer(
address VAR46,
uint256 VAR28
) public returns (bool VAR42) {
require (VAR46 != address(0), "");
VAR35.FUN19(msg.sender, VAR28);
VAR35.FUN18(VAR46, VAR28);
emit Transfer(msg.sender, VAR46, VAR28);
return true;
}
}
pragma solidity 0.5.0;
contract PausableToken is VAR47 {
address private VAR48;
bool public VAR49 = false;
event FUN44();
event FUN45();
event FUN46(address indexed VAR50, address indexed VAR51);
function FUN47() public view returns (address) {
return VAR48;
}
modifier FUN48() {
require(!VAR49, "");
VAR6;
}
modifier FUN49() {
require(msg.sender == VAR48, "");
VAR6;
}
function FUN50() public VAR52 {
VAR49 = true;
emit FUN44();
}
function FUN51() public VAR52 {
VAR49 = false;
emit FUN45();
}
function FUN52(address VAR53) public onlyOwner {
require(VAR53 != address(0), "");
emit FUN46(VAR48, VAR53);
VAR48 = VAR53;
}
function FUN30(
address VAR29,
uint256 VAR28
) public whenNotPaused returns (bool VAR42) {
return super.FUN30(VAR29, VAR28);
}
function FUN42(
address VAR29,
uint256 VAR43
) public whenNotPaused returns (bool VAR42) {
return super.FUN42(VAR29, VAR43);
}
function FUN43(
address VAR29,
uint256 VAR44
) public whenNotPaused returns (bool VAR42) {
return super.FUN43(VAR29, VAR44);
}
function FUN31(
address VAR45,
address VAR46,
uint256 VAR28
) public whenNotPaused returns (bool VAR42) {
return super.FUN31(VAR45, VAR46, VAR28);
}
function transfer(
address VAR46,
uint256 VAR28
) public whenNotPaused returns (bool VAR42) {
return super.transfer(VAR46, VAR28);
}
}
pragma solidity 0.5.0;
contract BlacklistStore is VAR17 {
mapping (address => uint256) public VAR54;
function FUN53(address VAR55, uint256 VAR56) public VAR26 {
VAR54[VAR55] = VAR56;
}
}
pragma solidity 0.5.0;
contract BlacklistableToken is VAR57 {
BlacklistStore public VAR58;
address private VAR59;
event FUN54(address indexed VAR60, address indexed VAR61);
event FUN55(address indexed VAR62, address indexed VAR63);
event FUN56(address indexed VAR64, uint256 VAR56);
modifier FUN57(address VAR55) {
require(VAR58.FUN58(VAR55) == 0, "");
VAR6;
}
modifier FUN59() {
require(msg.sender == VAR59, "");
VAR6;
}
function FUN60() public view returns (address) {
return VAR59;
}
function FUN61(address VAR65) public onlyOwner returns (bool) {
emit FUN55(address(VAR58), VAR65);
VAR58 = FUN62(VAR65);
return true;
}
function FUN63(address VAR66) public onlyOwner {
require(VAR66 != address(0), "");
emit FUN54(VAR59, VAR66);
VAR59 = VAR66;
}
function FUN64(address VAR55) public view returns (uint256) {
return VAR58.FUN58(VAR55);
}
function FUN65(address VAR55, uint256 VAR56) public VAR67 {
VAR58.FUN53(VAR55, VAR56);
emit FUN56(VAR55, VAR56);
}
function FUN30(
address VAR29,
uint256 VAR28
) public FUN57(msg.sender) FUN57(VAR29) returns (bool VAR42) {
return super.FUN30(VAR29, VAR28);
}
function FUN42(
address VAR29,
uint256 VAR43
) public FUN57(msg.sender) FUN57(VAR29) returns (bool VAR42) {
return super.FUN42(VAR29, VAR43);
}
function FUN43(
address VAR29,
uint256 VAR44
) public FUN57(msg.sender) FUN57(VAR29) returns (bool VAR42) {
return super.FUN43(VAR29, VAR44);
}
function FUN31(
address VAR45,
address VAR46,
uint256 VAR28
) public FUN57(VAR45) FUN57(VAR46) FUN57(msg.sender) returns (bool VAR42) {
return super.FUN31(VAR45, VAR46, VAR28);
}
function transfer(
address VAR46,
uint256 VAR28
) public FUN57(msg.sender) FUN57(VAR46) returns (bool VAR42) {
return super.transfer(VAR46, VAR28);
}
}
pragma solidity 0.5.0;
contract BurnableToken is VAR68 {
event FUN66(address indexed VAR69, uint256 value);
function FUN67(
uint256 VAR28
) public VAR70 FUN57(msg.sender) returns (bool VAR42) {
VAR35.FUN19(msg.sender, VAR28);
VAR35.FUN25(VAR28);
emit FUN66(msg.sender, VAR28);
emit Transfer(msg.sender, address(0), VAR28);
return true;
}
}
pragma solidity 0.5.0;
contract MintableToken is VAR68 {
event FUN68(address indexed VAR71, address indexed VAR72);
event FUN69(address indexed VAR73, address indexed VAR33, uint256 value);
address private VAR74;
modifier FUN70() {
require(msg.sender == VAR74, "");
VAR6;
}
function FUN71() public view returns (address) {
return VAR74;
}
function FUN72(address VAR75) public onlyOwner {
require(VAR75 != address(0), "");
emit FUN68(VAR74, VAR75);
VAR74 = VAR75;
}
function FUN73(
address VAR46,
uint256 VAR28
) public onlyMinter VAR70 FUN57(msg.sender) FUN57(VAR46) returns (bool) {
require(VAR46 != address(0), "");
VAR35.FUN24(VAR28);
VAR35.FUN18(VAR46, VAR28);
emit FUN69(msg.sender, VAR46, VAR28);
emit Transfer(address(0), VAR46, VAR28);
return true;
}
}
pragma solidity 0.5.0;
contract PingAnToken is VAR76, VAR77 {
bool private VAR78 = true;
function FUN74(address VAR2) public {
require(!VAR78, "");
require(VAR2 != address(0), "");
FUN2(VAR2);
VAR78 = true;
}
}
0
---------------------------------
29 0x00000000002b13cccec913420a21e4d11b2dcd3c.sol
pragma solidity 0.5.6;
contract VAR1 {
event FUN1(address VAR2, bytes32 VAR3);
event FUN2(address VAR2, bytes32 VAR3);
bytes private constant VAR4 = (
VAR5""
);
bytes32 private constant VAR6 = bytes32(
0xb7d11e258d6663925ce8e43f07ba3b7792a573ecc2fd7682d01f8a70b2223294
);
bytes32 private constant VAR7 = bytes32(
0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
);
bytes private VAR8;
constructor() public {
require(
address(this) == address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C),
""
);
require(
FUN3(
VAR9.FUN4(VAR4)
) == VAR6,
""
);
require(
FUN3(VAR9.FUN4(VAR5"")) == VAR7,
""
);
}
function FUN5(
uint96 VAR10,
bytes calldata VAR11
) external payable returns (address VAR2) {
bytes32 VAR3 = FUN6(VAR10);
VAR8 = VAR11;
address VAR12 = FUN7(VAR3);
address VAR13;
bytes memory VAR14 = VAR4;
VAR15 {
let VAR16 := FUN8(0x20, VAR14)
let VAR17 := FUN9(VAR14)
VAR13 := FUN10(
VAR18,
VAR16,
VAR17,
VAR3
)
}
require(VAR13 != address(0), "");
VAR2 = FUN11(VAR13);
FUN12(VAR2, FUN13(VAR12));
delete VAR8;
emit FUN1(VAR2, VAR3);
}
function FUN14(uint96 VAR10) external {
bytes32 VAR3 = FUN6(VAR10);
address VAR2 = FUN11(
FUN15(VAR3)
);
VAR2.call("");
emit FUN2(VAR2, VAR3);
}
function FUN16(uint96 VAR10) external {
bytes32 VAR3 = FUN6(VAR10);
FUN7(VAR3);
VAR8 = VAR9.FUN4(
FUN17(0x5873),
msg.sender,
FUN18(0x905959593031856108fcf150ff)
);
address VAR13;
bytes memory VAR14 = VAR4;
VAR15 {
let VAR16 := FUN8(0x20, VAR14)
let VAR17 := FUN9(VAR14)
VAR13 := FUN10(
VAR18,
VAR16,
VAR17,
VAR3
)
}
require(
VAR13 != address(0),
""
);
delete VAR8;
}
function FUN19() external view returns (
bytes memory VAR11
) {
VAR11 = VAR8;
}
function FUN20(
bytes32 VAR3
) external pure returns (address VAR13) {
VAR13 = FUN15(VAR3);
}
function FUN21(
bytes32 VAR3
) external pure returns (address VAR2) {
VAR2 = FUN11(
FUN15(VAR3)
);
}
function FUN22(
bytes32 VAR3
) external pure returns (address VAR12) {
VAR12 = FUN23(
FUN24(
FUN15(VAR3)
)
);
}
function FUN25(bytes32 VAR3) external pure returns (
bytes memory VAR19
) {
VAR19 = FUN13(
FUN23(
FUN24(
FUN15(VAR3)
)
)
);
}
function FUN26() external pure returns (
bytes memory VAR20
) {
VAR20 = (
VAR4
);
}
function FUN27() external pure returns (
bytes32 VAR21
) {
VAR21 = (
VAR6
);
}
function FUN28(uint96 VAR10) external view returns (bytes32 VAR3) {
VAR3 = FUN6(VAR10);
}
function FUN6(uint96 VAR10) internal view returns (bytes32 VAR3) {
VAR15 {
VAR3 := or(FUN29(96, VAR22), VAR10)
}
}
function FUN13(
address VAR12
) internal pure returns (bytes memory VAR19) {
VAR19 = VAR9.FUN4(
FUN30(0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773),
VAR12,
FUN17(0xff5b)
);
}
function FUN12(
address VAR2,
bytes memory VAR19
) internal view {
bytes memory VAR23;
VAR15 {
VAR23 := FUN9(0x40)
FUN31(0x40, FUN8(VAR23, 0x60))
FUN31(VAR23, 44)
FUN32(VAR2, FUN8(VAR23, 0x20), 0, 44)
}
require(
FUN3(
VAR9.FUN4(VAR19)
) == FUN3(
VAR9.FUN4(VAR23)
),
""
);
}
function FUN7(
bytes32 VAR3
) internal returns (address VAR12) {
address VAR13 = FUN15(VAR3);
bytes memory VAR24 = FUN24(
VAR13
);
VAR12 = FUN23(VAR24);
if (VAR12.VAR25 > 0) {
bytes32 VAR26;
VAR15 {
VAR26 := FUN33(VAR12)
}
if (VAR26 == VAR7) {
VAR15 {
let VAR16 := FUN8(0x20, VAR24)
let VAR17 := FUN9(VAR24)
let VAR27 := FUN10(
0,
VAR16,
VAR17,
0
)
}
} else {
VAR12.call("");
}
}
}
function FUN15(
bytes32 VAR3
) internal pure returns (address VAR13) {
VAR13 = address(
FUN34(
uint256(
FUN3(
VAR9.FUN4(
VAR5"",
address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C),
VAR3,
VAR6
)
)
)
)
);
}
function FUN11(
address VAR13
) internal pure returns (address VAR2) {
VAR2 = address(
FUN34(
uint256(
FUN3(
VAR9.FUN4(
FUN17(0xd694),
VAR13,
FUN35(0x01)
)
)
)
)
);
}
function FUN24(
address VAR13
) internal pure returns (bytes memory VAR28) {
VAR28 = VAR9.FUN4(
FUN36(0x586e2b13cccec913420a21e4d11b2dcd3c33185857595959303173),
VAR13,
FUN37(0x5af160315981595939f3)
);
}
function FUN23(
bytes memory VAR28
) internal pure returns (address VAR12) {
VAR12 = address(
FUN34(
uint256(
FUN3(
VAR9.FUN4(
FUN35(0xff),
address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C),
bytes32(0),
FUN3(
VAR28
)
)
)
)
)
);
}
}
0
---------------------------------
30 0x0000000000377d181a0ebd08590c6b399b272000.sol
pragma solidity 0.4.26;
contract VAR1 {
event FUN1(address indexed sender, uint indexed VAR2);
event FUN2(address indexed sender, uint indexed VAR2);
event FUN3(uint indexed VAR2);
event FUN4(uint indexed VAR2);
event FUN5(uint indexed VAR2);
event FUN6(address indexed sender, uint value);
event FUN7(address indexed VAR3);
event FUN8(address indexed VAR3);
event FUN9(uint VAR4);
uint constant public VAR5 = 50;
mapping (uint => Transaction) public VAR6;
mapping (uint => mapping (address => bool)) public VAR7;
mapping (address => bool) public VAR8;
address[] public VAR9;
uint public VAR4;
uint public VAR10;
struct Transaction {
address VAR11;
uint value;
bytes VAR12;
bool VAR13;
}
modifier FUN10() {
require(msg.sender == address(this));
VAR14;
}
modifier FUN11(address VAR3) {
require(!VAR8[VAR3]);
VAR14;
}
modifier ownerExists(address VAR3) {
require(VAR8[VAR3]);
VAR14;
}
modifier FUN12(uint VAR2) {
require(VAR6[VAR2].VAR11 != 0);
VAR14;
}
modifier confirmed(uint VAR2, address VAR3) {
require(VAR7[VAR2][VAR3]);
VAR14;
}
modifier notConfirmed(uint VAR2, address VAR3) {
require(!VAR7[VAR2][VAR3]);
VAR14;
}
modifier notExecuted(uint VAR2) {
require(!VAR6[VAR2].VAR13);
VAR14;
}
modifier FUN13(address VAR15) {
require(VAR15 != 0);
VAR14;
}
modifier FUN14(uint VAR16, uint VAR17) {
require(VAR16 <= VAR5
&& VAR17 <= VAR16
&& VAR17 != 0
&& VAR16 != 0);
VAR14;
}
function()
payable
{
if (msg.value > 0)
FUN6(msg.sender, msg.value);
}
function FUN15(address[] VAR18, uint VAR17)
public
FUN14(VAR18.VAR19, VAR17)
{
for (uint VAR20=0; VAR20<VAR18.VAR19; VAR20++) {
require(!VAR8[VAR18[VAR20]] && VAR18[VAR20] != 0);
VAR8[VAR18[VAR20]] = true;
}
VAR9 = VAR18;
VAR4 = VAR17;
}
function FUN16(address VAR3)
public
VAR21
FUN11(VAR3)
FUN13(VAR3)
FUN14(VAR9.VAR19 + 1, VAR4)
{
VAR8[VAR3] = true;
VAR9.FUN17(VAR3);
FUN7(VAR3);
}
function FUN18(address VAR3)
public
VAR21
ownerExists(VAR3)
{
VAR8[VAR3] = false;
for (uint VAR20=0; VAR20<VAR9.VAR19 - 1; VAR20++)
if (VAR9[VAR20] == VAR3) {
VAR9[VAR20] = VAR9[VAR9.VAR19 - 1];
break;
}
VAR9.VAR19 -= 1;
if (VAR4 > VAR9.VAR19)
FUN19(VAR9.VAR19);
FUN8(VAR3);
}
function FUN20(address VAR3, address VAR22)
public
VAR21
ownerExists(VAR3)
FUN11(VAR22)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR9[VAR20] == VAR3) {
VAR9[VAR20] = VAR22;
break;
}
VAR8[VAR3] = false;
VAR8[VAR22] = true;
FUN8(VAR3);
FUN7(VAR22);
}
function FUN19(uint VAR17)
public
VAR21
FUN14(VAR9.VAR19, VAR17)
{
VAR4 = VAR17;
FUN9(VAR17);
}
function FUN21(address VAR11, uint value, bytes VAR12)
public
returns (uint VAR2)
{
VAR2 = FUN22(VAR11, value, VAR12);
FUN23(VAR2);
}
function FUN23(uint VAR2)
public
ownerExists(msg.sender)
FUN12(VAR2)
notConfirmed(VAR2, msg.sender)
{
VAR7[VAR2][msg.sender] = true;
FUN1(msg.sender, VAR2);
FUN24(VAR2);
}
function FUN25(uint VAR2)
public
ownerExists(msg.sender)
confirmed(VAR2, msg.sender)
notExecuted(VAR2)
{
VAR7[VAR2][msg.sender] = false;
FUN2(msg.sender, VAR2);
}
function FUN24(uint VAR2)
public
ownerExists(msg.sender)
confirmed(VAR2, msg.sender)
notExecuted(VAR2)
{
if (FUN26(VAR2)) {
Transaction storage VAR23 = VAR6[VAR2];
VAR23.VAR13 = true;
if (FUN27(VAR23.VAR11, VAR23.value, VAR23.VAR12.VAR19, VAR23.VAR12))
FUN4(VAR2);
else {
FUN5(VAR2);
VAR23.VAR13 = false;
}
}
}
function FUN27(address VAR11, uint value, uint VAR24, bytes VAR12) internal returns (bool) {
bool VAR25;
VAR26 {
let VAR27 := FUN28(0x40)
let VAR28 := FUN29(VAR12, 32)
VAR25 := call(
FUN30(VAR29, 34710),
VAR11,
value,
VAR28,
VAR24,
VAR27,
0
)
}
return VAR25;
}
function FUN26(uint VAR2)
public
constant
returns (bool)
{
uint VAR30 = 0;
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++) {
if (VAR7[VAR2][VAR9[VAR20]])
VAR30 += 1;
if (VAR30 == VAR4)
return true;
}
}
function FUN22(address VAR11, uint value, bytes VAR12)
internal
FUN13(VAR11)
returns (uint VAR2)
{
VAR2 = VAR10;
VAR6[VAR2] = Transaction({
VAR11: VAR11,
value: value,
VAR12: VAR12,
VAR13: false
});
VAR10 += 1;
FUN3(VAR2);
}
function FUN31(uint VAR2)
public
constant
returns (uint VAR30)
{
for (uint VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR2][VAR9[VAR20]])
VAR30 += 1;
}
function FUN32(bool VAR31, bool VAR13)
public
constant
returns (uint VAR30)
{
for (uint VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR31 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
VAR30 += 1;
}
function FUN33()
public
constant
returns (address[])
{
return VAR9;
}
function FUN34(uint VAR2)
public
constant
returns (address[] VAR32)
{
address[] memory VAR33 = new address[](VAR9.VAR19);
uint VAR30 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR9.VAR19; VAR20++)
if (VAR7[VAR2][VAR9[VAR20]]) {
VAR33[VAR30] = VAR9[VAR20];
VAR30 += 1;
}
VAR32 = new address[](VAR30);
for (VAR20=0; VAR20<VAR30; VAR20++)
VAR32[VAR20] = VAR33[VAR20];
}
function FUN35(uint VAR34, uint VAR35, bool VAR31, bool VAR13)
public
constant
returns (uint[] VAR36)
{
uint[] memory VAR37 = new uint[](VAR10);
uint VAR30 = 0;
uint VAR20;
for (VAR20=0; VAR20<VAR10; VAR20++)
if (   VAR31 && !VAR6[VAR20].VAR13
|| VAR13 && VAR6[VAR20].VAR13)
{
VAR37[VAR30] = VAR20;
VAR30 += 1;
}
VAR36 = new uint[](VAR35 - VAR34);
for (VAR20=VAR34; VAR20<VAR35; VAR20++)
VAR36[VAR20 - VAR34] = VAR37[VAR20];
}
}
0
---------------------------------
31 0x000000000063b99b8036c31e91c64fc89bff9ca7.sol
pragma solidity 0.5.8;
contract VAR1 {
mapping(address => bool) private VAR2;
function FUN1(
bytes32 VAR3,
bytes calldata VAR4
) external payable FUN2(VAR3) returns (address VAR5) {
bytes memory VAR6 = VAR4;
address VAR7 = address(
FUN3(
uint256(
FUN4(
VAR8.FUN5(
VAR9"",
address(this),
VAR3,
FUN4(
VAR8.FUN5(
VAR6
)
)
)
)
)
)
);
require(
!VAR2[VAR7],
""
);
VAR10 {
let VAR11 := FUN6(0x20, VAR6)
let VAR12 := FUN7(VAR6)
VAR5 := FUN8(
VAR13,
VAR11,
VAR12,
VAR3
)
}
require(
VAR5 == VAR7,
""
);
VAR2[VAR5] = true;
}
function FUN9(
bytes32 VAR3,
bytes calldata VAR6
) external view returns (address VAR5) {
VAR5 = address(
FUN3(
uint256(
FUN4(
VAR8.FUN5(
VAR9"",
address(this),
VAR3,
FUN4(
VAR8.FUN5(
VAR6
)
)
)
)
)
)
);
if (VAR2[VAR5]) {
return address(0);
}
}
function FUN10(
bytes32 VAR3,
bytes32 VAR14
) external view returns (address VAR5) {
VAR5 = address(
FUN3(
uint256(
FUN4(
VAR8.FUN5(
VAR9"",
address(this),
VAR3,
VAR14
)
)
)
)
);
if (VAR2[VAR5]) {
return address(0);
}
}
function FUN11(
address VAR5
) external view returns (bool) {
return VAR2[VAR5];
}
modifier FUN2(bytes32 VAR3) {
require(
(address(FUN12(VAR3)) == msg.sender) ||
(FUN12(VAR3) == FUN12(0)),
""
);
VAR15;
}
}
0
---------------------------------
32 0x0000000000c5fd1aef1a9421626cf804086185e9.sol
pragma solidity 0.4.26;
library VAR1 {
function FUN1(bytes32 VAR2, bytes VAR3)
internal
pure
returns (address)
{
bytes32 VAR4;
bytes32 VAR5;
uint8 VAR6;
if (VAR3.VAR7 != 65) {
return (address(0));
}
VAR8 {
VAR4 := FUN2(FUN3(VAR3, 0x20))
VAR5 := FUN2(FUN3(VAR3, 0x40))
VAR6 := FUN4(0, FUN2(FUN3(VAR3, 0x60)))
}
if (VAR6 < 27) {
VAR6 += 27;
}
if (VAR6 != 27 && VAR6 != 28) {
return (address(0));
} else {
return FUN5(VAR2, VAR6, VAR4, VAR5);
}
}
function FUN6(bytes32 VAR2)
internal
pure
returns (bytes32)
{
return FUN7(
VAR9.FUN8("", VAR2)
);
}
}
library VAR10 {
function FUN9(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
if (VAR11 == 0) {
return 0;
}
uint256 VAR13 = VAR11 * VAR12;
require(VAR13 / VAR11 == VAR12);
return VAR13;
}
function FUN10(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 > 0);
uint256 VAR13 = VAR11 / VAR12;
return VAR13;
}
function FUN11(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 <= VAR11);
uint256 VAR13 = VAR11 - VAR12;
return VAR13;
}
function FUN3(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 + VAR12;
require(VAR13 >= VAR11);
return VAR13;
}
function FUN12(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 != 0);
return VAR11 % VAR12;
}
}
library VAR14 {
struct VAR15 {
mapping (address => bool) VAR16;
}
function FUN3(Role storage VAR17, address VAR18) internal {
require(VAR18 != address(0));
require(!FUN13(VAR17, VAR18));
VAR17.VAR16[VAR18] = true;
}
function FUN14(Role storage VAR17, address VAR18) internal {
require(VAR18 != address(0));
require(FUN13(VAR17, VAR18));
VAR17.VAR16[VAR18] = false;
}
function FUN13(Role storage VAR17, address VAR18)
internal
view
returns (bool)
{
require(VAR18 != address(0));
return VAR17.VAR16[VAR18];
}
}
contract VAR19 {
using Roles for VAR14.VAR15;
event FUN15(address indexed VAR18);
event FUN16(address indexed VAR18);
VAR14.Role private VAR20;
constructor() internal {
FUN17(msg.sender);
}
modifier FUN18() {
require(FUN19(msg.sender));
VAR21;
}
function FUN19(address VAR18) public view returns (bool) {
return VAR20.FUN13(VAR18);
}
function FUN20(address VAR18) public VAR22 {
FUN17(VAR18);
}
function FUN21() public {
FUN22(msg.sender);
}
function FUN17(address VAR18) internal {
VAR20.FUN3(VAR18);
emit FUN15(VAR18);
}
function FUN22(address VAR18) internal {
VAR20.FUN14(VAR18);
emit FUN16(VAR18);
}
}
contract Pausable is VAR19 {
event FUN23(address VAR18);
event FUN24(address VAR18);
bool private VAR23;
constructor() internal {
VAR23 = false;
}
function FUN25() public view returns(bool) {
return VAR23;
}
modifier FUN26() {
require(!VAR23);
VAR21;
}
modifier FUN27() {
require(VAR23);
VAR21;
}
function FUN28() public onlyPauser VAR24 {
VAR23 = true;
emit FUN23(msg.sender);
}
function FUN29() public onlyPauser VAR25 {
VAR23 = false;
emit FUN24(msg.sender);
}
}
contract VAR26 {
address private VAR27;
event FUN30(
address indexed VAR28,
address indexed VAR29
);
constructor(address VAR30) internal {
VAR27 = VAR30;
emit FUN30(address(0), VAR27);
}
function FUN31() public view returns(address) {
return VAR27;
}
modifier onlyOwner() {
require(FUN32());
VAR21;
}
function FUN32() public view returns(bool) {
return msg.sender == VAR27;
}
function FUN33() public onlyOwner {
emit FUN30(VAR27, address(0));
VAR27 = address(0);
}
function FUN34(address VAR29) public onlyOwner {
FUN35(VAR29);
}
function FUN35(address VAR29) internal {
require(VAR29 != address(0));
emit FUN30(VAR27, VAR29);
VAR27 = VAR29;
}
}
interface VAR31 {
function FUN36(
address VAR18,
uint256 VAR32
) external view returns (bool);
function FUN37(
address VAR18,
uint256 VAR32
) external view returns (uint256);
function FUN38() external view returns (uint256);
function FUN39(uint256 VAR33) external view returns (uint256);
}
interface VAR34 {
event FUN40(uint256 indexed VAR32, string VAR35);
event FUN41(uint256 indexed VAR32);
event FUN42(address indexed VAR36, string VAR35);
event FUN43(address indexed VAR36);
event FUN44(
address VAR36,
uint256 indexed VAR32
);
event FUN45(
address VAR36,
uint256 indexed VAR32
);
event FUN46(
address VAR36,
address indexed VAR37,
uint256 VAR32,
uint256 VAR38
);
event FUN47(
address VAR36,
address indexed VAR37,
uint256 VAR32
);
function FUN48(uint256 VAR39, string VAR35) external;
function FUN49(uint256 VAR39) external;
function FUN50(address VAR36, string VAR35) external;
function FUN51(address VAR36) external;
function FUN52(
address VAR36,
uint256 VAR32
) external;
function FUN53(
address VAR36,
uint256 VAR32
) external;
function FUN54(
address VAR18,
uint256 VAR32,
uint256 value
) external payable;
function FUN55(
address VAR18,
uint256 VAR32
) external;
function FUN56(
address VAR36,
uint256 VAR32
) external view returns (bool);
function FUN57(
uint256 VAR32
) external view returns (string VAR35);
function FUN58(
address VAR36
) external view returns (string VAR35);
function FUN59(
address VAR18,
uint256 VAR32
) external view returns (address VAR36, bool VAR40);
function FUN38() external view returns (uint256);
function FUN39(uint256 VAR33) external view returns (uint256);
function FUN60() external view returns (uint256[]);
function FUN61() external view returns (uint256);
function FUN62(uint256 VAR33) external view returns (address);
function FUN63() external view returns (address[]);
}
interface VAR41 {
event FUN64(
address indexed VAR36,
address VAR42
);
event FUN65(
address indexed VAR43,
uint256 indexed VAR44,
uint256 VAR45
);
event FUN66(
address indexed VAR43,
uint256 indexed VAR44,
uint256 VAR45
);
event FUN67(
address indexed VAR46,
address indexed VAR47,
uint256 indexed VAR44,
uint256 VAR45
);
event FUN68(
address indexed VAR48,
address indexed VAR47,
uint256 indexed VAR44,
uint256 VAR45
);
function FUN69(uint256 VAR39, string VAR35) external;
function FUN70(uint256 VAR39, bool VAR49) external;
function FUN71(
uint256 VAR39,
address VAR50,
uint256 VAR51
) external;
function FUN72(
uint256 VAR39,
uint256 VAR52
) external;
function FUN73(uint256 VAR39, uint256 VAR53) external;
function FUN74(address VAR42) external;
function FUN75(
uint256 VAR32,
uint256 value,
uint256 VAR54,
bytes VAR3
) external payable;
function FUN76(uint256 VAR32) external;
function FUN77(
address VAR18,
uint256 VAR32,
uint256 value,
uint256 VAR54,
bytes VAR3
) external payable;
function FUN78(address VAR18, uint256 VAR32) external;
function FUN79(
bytes32 VAR2,
bytes VAR3
) external;
function FUN80(
address VAR18,
address VAR55,
uint256 VAR32,
uint256 value,
uint256 VAR56,
uint256 VAR54
) external view returns (bytes32 VAR2);
function FUN81(
uint256 VAR32,
uint256 value,
uint256 VAR56,
uint256 VAR54,
bytes VAR3
) external view returns (bool);
function FUN82(
address VAR18,
uint256 VAR32,
uint256 value,
uint256 VAR56,
uint256 VAR54,
bytes VAR3
) external view returns (bool);
function FUN83(
uint256 VAR32
) external view returns (
string VAR35,
bool VAR57,
bool VAR58,
address VAR59,
uint256 VAR60,
uint256 VAR52,
uint256 VAR61
);
function FUN84(
address VAR36
) external view returns (
address VAR62
);
}
interface VAR63 {
function FUN85(address) external view returns (uint256);
function transfer(address, uint256) external returns (bool);
}
contract ExtendedJurisdiction is VAR26, VAR64, VAR31, VAR34, VAR41 {
using ECDSA for bytes32;
using SafeMath for uint256;
struct VAR65 {
bool VAR66;
uint256 VAR33;
address VAR62;
string VAR35;
}
struct VAR67 {
bool VAR66;
bool VAR68;
address VAR55;
address VAR36;
uint256 value;
uint256 VAR69;
}
struct VAR70 {
bool VAR66;
bool VAR71;
bool VAR49;
uint256 VAR33;
address VAR59;
uint256 VAR72;
uint256 VAR73;
uint256 VAR61;
string VAR35;
mapping(address => bool) VAR74;
}
mapping(uint256 => VAR70) private VAR75;
mapping(address => mapping(uint256 => VAR67)) private VAR76;
mapping(address => VAR65) private VAR77;
mapping(address => address) private VAR78;
mapping(uint256 => bytes32) private VAR79;
mapping(bytes32 => bool) private VAR80;
mapping(address => uint256[]) private VAR81;
mapping(address => mapping(uint256 => uint256)) private VAR82;
uint256[] private VAR83;
address[] private VAR84;
uint256 private VAR85;
constructor(address VAR30) public FUN86(VAR30) {}
function FUN48(
uint256 VAR39,
string VAR35
) external onlyOwner VAR24 {
require(
!FUN87(VAR39),
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
VAR39, false, VAR35
)
);
if (VAR79[VAR39] == bytes32(0)) {
VAR79[VAR39] = VAR2;
}
require(
VAR2 == VAR79[VAR39],
""
);
VAR75[VAR39] = FUN88({
VAR66: true,
VAR71: false,
VAR49: false,
VAR33: VAR83.VAR7,
VAR59: address(0),
VAR72: uint256(0),
VAR73: uint256(0),
VAR61: uint256(0),
VAR35: VAR35
});
VAR83.FUN89(VAR39);
emit FUN40(VAR39, VAR35);
}
function FUN69(
uint256 VAR39,
string VAR35
) external onlyOwner VAR24 {
require(
!FUN87(VAR39),
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
VAR39, true, VAR35
)
);
if (VAR79[VAR39] == bytes32(0)) {
VAR79[VAR39] = VAR2;
}
require(
VAR2 == VAR79[VAR39],
""
);
VAR75[VAR39] = FUN88({
VAR66: true,
VAR71: true,
VAR49: false,
VAR33: VAR83.VAR7,
VAR59: address(0),
VAR72: uint256(0),
VAR73: uint256(0),
VAR61: uint256(0),
VAR35: VAR35
});
VAR83.FUN89(VAR39);
emit FUN40(VAR39, VAR35);
}
function FUN70(uint256 VAR39, bool VAR49) external {
require(
FUN87(VAR39),
""
);
VAR75[VAR39].VAR49 = VAR49;
}
function FUN71(
uint256 VAR39,
address VAR50,
uint256 VAR51
) external {
require(
FUN87(VAR39),
""
);
VAR75[VAR39].VAR59 = VAR50;
VAR75[VAR39].VAR72 = VAR51;
}
function FUN72(
uint256 VAR39,
uint256 VAR52
) external {
require(
FUN87(VAR39),
""
);
VAR75[VAR39].VAR73 = VAR52;
}
function FUN73(uint256 VAR39, uint256 VAR53) external {
require(
FUN87(VAR39),
""
);
VAR75[VAR39].VAR61 = VAR53;
}
function FUN49(uint256 VAR39) external onlyOwner VAR24 {
require(
FUN87(VAR39),
""
);
uint256 VAR86 = VAR83[VAR83.VAR7.FUN11(1)];
VAR83[VAR75[VAR39].VAR33] = VAR86;
VAR75[VAR86].VAR33 = VAR75[VAR39].VAR33;
VAR83.VAR7--;
delete VAR75[VAR39];
emit FUN41(VAR39);
}
function FUN50(
address VAR36,
string VAR35
) external onlyOwner VAR24 {
require(VAR36 != address(0), "");
require(
!FUN90(VAR36),
""
);
require(
VAR78[VAR36] == address(0),
""
);
VAR77[VAR36] = FUN91({
VAR66: true,
VAR33: VAR84.VAR7,
VAR62: VAR36,
VAR35: VAR35
});
VAR78[VAR36] = VAR36;
VAR84.FUN89(VAR36);
emit FUN42(VAR36, VAR35);
}
function FUN51(address VAR36) external onlyOwner VAR24 {
require(
FUN90(VAR36),
""
);
while (VAR81[VAR36].VAR7 > 0 && FUN92() > 25000) {
uint256 VAR87 = VAR81[VAR36].VAR7.FUN11(1);
uint256 VAR88 = VAR81[VAR36][VAR87];
delete VAR75[VAR88].VAR74[VAR36];
delete VAR82[VAR36][VAR88];
VAR81[VAR36].VAR7--;
}
require(
VAR81[VAR36].VAR7 == 0,
""
);
address VAR89 = VAR84[VAR84.VAR7.FUN11(1)];
VAR84[VAR77[VAR36].VAR33] = VAR89;
VAR77[VAR89].VAR33 = VAR77[VAR36].VAR33;
VAR84.VAR7--;
delete VAR78[VAR77[VAR36].VAR62];
delete VAR77[VAR36];
emit FUN43(VAR36);
}
function FUN52(
address VAR36,
uint256 VAR32
) external onlyOwner VAR24 {
require(
FUN90(VAR36) && FUN87(VAR32),
""
);
require(
!VAR75[VAR32].VAR74[VAR36],
""
);
VAR75[VAR32].VAR74[VAR36] = true;
uint256 VAR33 = VAR81[VAR36].VAR7;
VAR82[VAR36][VAR32] = VAR33;
VAR81[VAR36].FUN89(VAR32);
emit FUN44(VAR36, VAR32);
}
function FUN53(
address VAR36,
uint256 VAR32
) external onlyOwner VAR24 {
require(
FUN93(VAR36, VAR32),
""
);
delete VAR75[VAR32].VAR74[VAR36];
uint256 VAR87 = VAR81[VAR36].VAR7.FUN11(1);
uint256 VAR86 = VAR81[VAR36][VAR87];
uint256 VAR33 = VAR82[VAR36][VAR32];
VAR81[VAR36][VAR33] = VAR86;
VAR81[VAR36].VAR7--;
VAR82[VAR36][VAR86] = VAR33;
delete VAR82[VAR36][VAR32];
emit FUN45(VAR36, VAR32);
}
function FUN74(address VAR42) external {
require(
FUN90(msg.sender),
"");
require(
VAR78[VAR42] == address(0),
""
);
delete VAR78[VAR77[msg.sender].VAR62];
VAR77[msg.sender].VAR62 = VAR42;
VAR78[VAR42] = msg.sender;
emit FUN64(msg.sender, VAR42);
}
function FUN54(
address VAR18,
uint256 VAR32,
uint256 value
) external payable VAR24 {
require(
FUN93(msg.sender, VAR32),
""
);
require(
!VAR76[VAR18][VAR32].VAR66,
""
);
uint256 VAR73 = VAR75[VAR32].VAR73;
uint256 VAR61 = VAR75[VAR32].VAR61;
uint256 VAR69 = msg.value.FUN11(VAR61);
require(
VAR69 >= VAR73,
""
);
VAR76[VAR18][VAR32] = FUN94({
VAR66: true,
VAR68: false,
VAR55: address(0),
VAR36: msg.sender,
value: value,
VAR69: VAR69
});
emit FUN46(msg.sender, VAR18, VAR32, value);
if (VAR69 > 0) {
emit FUN65(msg.sender, VAR32, VAR69);
}
if (VAR61 > 0) {
if (FUN31().FUN95(VAR61)) {
emit FUN67(FUN31(), msg.sender, VAR32, VAR61);
} else {
VAR85 = VAR85.FUN3(VAR61);
}
}
}
function FUN55(
address VAR18,
uint256 VAR32
) external VAR24 {
require(
VAR76[VAR18][VAR32].VAR66,
""
);
address VAR36 = VAR76[VAR18][VAR32].VAR36;
require(
msg.sender == VAR36 || msg.sender == FUN31(),
""
);
uint256 VAR69 = VAR76[VAR18][VAR32].VAR69;
address VAR90;
if (VAR76[VAR18][VAR32].VAR68) {
VAR90 = VAR18;
} else {
address VAR55 = VAR76[VAR18][VAR32].VAR55;
if (VAR55 == address(0)) {
VAR90 = VAR36;
} else {
VAR90 = VAR55;
}
}
delete VAR76[VAR18][VAR32];
emit FUN47(VAR36, VAR18, VAR32);
if (VAR69 > 0 && address(this).VAR91 >= VAR69) {
uint256 VAR92 = 37700;
uint256 VAR93 = VAR92.FUN9(VAR94.VAR95);
if (VAR69 > VAR93) {
if (VAR90.FUN95(VAR69.FUN11(VAR93))) {
emit FUN66(
VAR90,
VAR32,
VAR69.FUN11(VAR93)
);
} else {
VAR85 = VAR85.FUN3(VAR69.FUN11(VAR93));
}
emit FUN68(
VAR94.VAR96,
VAR90,
VAR32,
VAR93
);
VAR94.VAR96.transfer(VAR93);
} else {
emit FUN68(
VAR94.VAR96,
VAR90,
VAR32,
VAR69
);
VAR94.VAR96.transfer(VAR69);
}
}
}
function FUN75(
uint256 VAR32,
uint256 value,
uint256 VAR54,
bytes VAR3
) external payable {
require(
!VAR76[msg.sender][VAR32].VAR66,
""
);
uint256 VAR73 = VAR75[VAR32].VAR73;
uint256 VAR61 = VAR75[VAR32].VAR61;
uint256 VAR69 = msg.value.FUN11(VAR54).FUN11(VAR61);
require(
VAR69 >= VAR73,
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
address(this),
msg.sender,
address(0),
msg.value,
VAR54,
VAR32,
value
)
);
require(
!VAR80[VAR2],
""
);
address VAR62 = VAR2.FUN6().FUN1(VAR3);
address VAR36 = VAR78[VAR62];
require(
FUN93(VAR36, VAR32),
""
);
VAR76[msg.sender][VAR32] = FUN94({
VAR66: true,
VAR68: true,
VAR55: address(0),
VAR36: VAR36,
value: value,
VAR69: VAR69
});
VAR80[VAR2] = true;
emit FUN46(VAR36, msg.sender, VAR32, value);
if (VAR69 > 0) {
emit FUN65(msg.sender, VAR32, VAR69);
}
if (VAR61 > 0) {
if (FUN31().FUN95(VAR61)) {
emit FUN67(FUN31(), msg.sender, VAR32, VAR61);
} else {
VAR85 = VAR85.FUN3(VAR61);
}
}
if (VAR54 > 0) {
if (VAR36.FUN95(VAR54)) {
emit FUN67(VAR36, msg.sender, VAR32, VAR54);
} else {
VAR85 = VAR85.FUN3(VAR54);
}
}
}
function FUN76(uint256 VAR32) external {
require(
!VAR75[VAR32].VAR71,
""
);
require(
VAR76[msg.sender][VAR32].VAR66,
""
);
address VAR36 = VAR76[msg.sender][VAR32].VAR36;
uint256 VAR69 = VAR76[msg.sender][VAR32].VAR69;
address VAR90;
if (VAR76[msg.sender][VAR32].VAR68) {
VAR90 = msg.sender;
} else {
address VAR55 = VAR76[msg.sender][VAR32].VAR55;
if (VAR55 == address(0)) {
VAR90 = VAR36;
} else {
VAR90 = VAR55;
}
}
delete VAR76[msg.sender][VAR32];
emit FUN47(VAR36, msg.sender, VAR32);
if (VAR69 > 0 && address(this).VAR91 >= VAR69) {
if (VAR90.FUN95(VAR69)) {
emit FUN66(VAR90, VAR32, VAR69);
} else {
VAR85 = VAR85.FUN3(VAR69);
}
}
}
function FUN77(
address VAR18,
uint256 VAR32,
uint256 value,
uint256 VAR54,
bytes VAR3
) external payable {
require(
!VAR75[VAR32].VAR49,
""
);
require(
!VAR76[VAR18][VAR32].VAR66,
""
);
uint256 VAR73 = VAR75[VAR32].VAR73;
uint256 VAR61 = VAR75[VAR32].VAR61;
uint256 VAR69 = msg.value.FUN11(VAR54).FUN11(VAR61);
require(
VAR69 >= VAR73,
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
address(this),
VAR18,
msg.sender,
msg.value,
VAR54,
VAR32,
value
)
);
require(
!VAR80[VAR2],
""
);
address VAR62 = VAR2.FUN6().FUN1(VAR3);
address VAR36 = VAR78[VAR62];
require(
FUN93(VAR36, VAR32),
""
);
VAR76[VAR18][VAR32] = FUN94({
VAR66: true,
VAR68: false,
VAR55: msg.sender,
VAR36: VAR36,
value: value,
VAR69: VAR69
});
VAR80[VAR2] = true;
emit FUN46(VAR36, VAR18, VAR32, value);
if (VAR69 > 0) {
emit FUN65(msg.sender, VAR32, VAR69);
}
if (VAR61 > 0) {
if (FUN31().FUN95(VAR61)) {
emit FUN67(FUN31(), msg.sender, VAR32, VAR61);
} else {
VAR85 = VAR85.FUN3(VAR61);
}
}
if (VAR54 > 0) {
if (VAR36.FUN95(VAR54)) {
emit FUN67(VAR36, msg.sender, VAR32, VAR54);
} else {
VAR85 = VAR85.FUN3(VAR54);
}
}
}
function FUN78(address VAR18, uint256 VAR32) external {
require(
!VAR75[VAR32].VAR71,
""
);
require(
VAR76[VAR18][VAR32].VAR66,
""
);
require(
VAR76[VAR18][VAR32].VAR55 == msg.sender,
""
);
address VAR36 = VAR76[VAR18][VAR32].VAR36;
uint256 VAR69 = VAR76[VAR18][VAR32].VAR69;
delete VAR76[VAR18][VAR32];
emit FUN47(VAR36, VAR18, VAR32);
if (VAR69 > 0 && address(this).VAR91 >= VAR69) {
if (msg.sender.FUN95(VAR69)) {
emit FUN66(msg.sender, VAR32, VAR69);
} else {
VAR85 = VAR85.FUN3(VAR69);
}
}
}
function FUN79(
bytes32 VAR2,
bytes VAR3
) external {
address VAR36 = VAR78[
VAR2.FUN6().FUN1(VAR3)
];
require(
msg.sender == VAR36 || msg.sender == FUN31(),
""
);
VAR80[VAR2] = true;
}
function FUN36(
address VAR18,
uint256 VAR32
) external view returns (bool) {
address VAR36 = VAR76[VAR18][VAR32].VAR36;
return (
(
VAR77[VAR36].VAR66 &&
VAR75[VAR32].VAR74[VAR36] &&
VAR75[VAR32].VAR66
) || (
VAR75[VAR32].VAR59 != address(0) &&
FUN96(
VAR75[VAR32].VAR59,
VAR18,
VAR75[VAR32].VAR72
)
)
);
}
function FUN37(
address VAR18,
uint256 VAR32
) external view returns (uint256 value) {
address VAR36 = VAR76[VAR18][VAR32].VAR36;
if (
VAR77[VAR36].VAR66 &&
VAR75[VAR32].VAR74[VAR36] &&
VAR75[VAR32].VAR66
) {
return VAR76[VAR18][VAR32].value;
} else if (
VAR75[VAR32].VAR59 != address(0)
) {
if (VAR75[VAR32].VAR72 == 2423228754106148037712574142965102) {
require(
FUN97(
VAR75[VAR32].VAR59
).FUN85(VAR18) >= 1,
""
);
return 1;
}
require(
FUN98(
VAR75[VAR32].VAR59
).FUN36(
VAR18, VAR75[VAR32].VAR72
),
""
);
return (
FUN98(
VAR75[VAR32].VAR59
).FUN37(
VAR18, VAR75[VAR32].VAR72
)
);
}
revert("");
}
function FUN56(
address VAR36,
uint256 VAR32
) external view returns (bool) {
return FUN93(VAR36, VAR32);
}
function FUN57(
uint256 VAR32
) external view returns (
string VAR35
) {
return VAR75[VAR32].VAR35;
}
function FUN83(
uint256 VAR32
) external view returns (
string VAR35,
bool VAR57,
bool VAR58,
address VAR59,
uint256 VAR72,
uint256 VAR52,
uint256 VAR61
) {
return (
VAR75[VAR32].VAR35,
VAR75[VAR32].VAR71,
VAR75[VAR32].VAR49,
VAR75[VAR32].VAR59,
VAR75[VAR32].VAR72,
VAR75[VAR32].VAR73,
VAR75[VAR32].VAR61
);
}
function FUN58(
address VAR36
) external view returns (
string VAR35
) {
return VAR77[VAR36].VAR35;
}
function FUN84(
address VAR36
) external view returns (
address VAR62
) {
return VAR77[VAR36].VAR62;
}
function FUN59(
address VAR18,
uint256 VAR32
) external view returns (
address VAR36,
bool VAR40
) {
address VAR97 = VAR76[VAR18][VAR32].VAR36;
return (VAR97, FUN93(VAR97, VAR32));
}
function FUN38() external view returns (uint256) {
return VAR83.VAR7;
}
function FUN39(uint256 VAR33) external view returns (uint256) {
require(
VAR33 < VAR83.VAR7,
""
);
return VAR83[VAR33];
}
function FUN60() external view returns (uint256[]) {
return VAR83;
}
function FUN61() external view returns (uint256) {
return VAR84.VAR7;
}
function FUN62(
uint256 VAR33
) external view returns (address) {
return VAR84[VAR33];
}
function FUN63() external view returns (address[]) {
return VAR84;
}
function FUN99(bytes4 VAR98) external view returns (bool) {
return (
VAR98 == this.VAR99.VAR100 ||
VAR98 == (
this.VAR101.VAR100
^ this.VAR102.VAR100
^ this.VAR103.VAR100
^ this.VAR104.VAR100
)
);
}
function FUN80(
address VAR18,
address VAR55,
uint256 VAR32,
uint256 value,
uint256 VAR56,
uint256 VAR54
) external view returns (
bytes32 VAR2
) {
return FUN100(
VAR18,
VAR55,
VAR32,
value,
VAR56,
VAR54
);
}
function FUN81(
uint256 VAR32,
uint256 value,
uint256 VAR56,
uint256 VAR54,
bytes VAR3
) external view returns (bool) {
bytes32 VAR2 = FUN100(
msg.sender,
address(0),
VAR32,
value,
VAR56,
VAR54
);
address VAR62 = VAR2.FUN6().FUN1(VAR3);
address VAR36 = VAR78[VAR62];
uint256 VAR73 = VAR75[VAR32].VAR73;
uint256 VAR61 = VAR75[VAR32].VAR61;
return (
VAR56 >= VAR73.FUN3(VAR61).FUN3(VAR54) &&
!VAR80[VAR2] &&
FUN93(VAR36, VAR32) &&
!VAR76[msg.sender][VAR32].VAR66
);
}
function FUN82(
address VAR18,
uint256 VAR32,
uint256 value,
uint256 VAR56,
uint256 VAR54,
bytes VAR3
) external view returns (bool) {
bytes32 VAR2 = FUN100(
VAR18,
msg.sender,
VAR32,
value,
VAR56,
VAR54
);
address VAR62 = VAR2.FUN6().FUN1(VAR3);
address VAR36 = VAR78[VAR62];
uint256 VAR73 = VAR75[VAR32].VAR73;
uint256 VAR61 = VAR75[VAR32].VAR61;
return (
VAR56 >= VAR73.FUN3(VAR61).FUN3(VAR54) &&
!VAR80[VAR2] &&
FUN93(VAR36, VAR32) &&
!VAR76[VAR18][VAR32].VAR66
);
}
function FUN87(uint256 VAR32) public view returns (bool) {
return VAR75[VAR32].VAR66;
}
function FUN90(address VAR18) public view returns (bool) {
return VAR77[VAR18].VAR66;
}
function FUN101() public view returns (uint256) {
return VAR85;
}
function FUN102(address VAR105) public view returns (uint256) {
return FUN97(VAR105).FUN85(address(this));
}
function FUN103(address VAR18, uint256 value) public onlyOwner {
VAR85 = VAR85.FUN11(value);
VAR18.transfer(value);
}
function FUN104(
address VAR105,
address VAR18,
uint256 value
) public onlyOwner {
require(FUN97(VAR105).transfer(VAR18, value));
}
function FUN93(
address VAR36,
uint256 VAR32
) internal view returns (bool) {
return (
VAR77[VAR36].VAR66 &&
VAR75[VAR32].VAR74[VAR36] &&
VAR75[VAR32].VAR66
);
}
function FUN100(
address VAR18,
address VAR55,
uint256 VAR32,
uint256 value,
uint256 VAR56,
uint256 VAR54
) internal view returns (bytes32 VAR2) {
return FUN7(
VAR9.FUN8(
address(this),
VAR18,
VAR55,
VAR56,
VAR54,
VAR32,
value
)
);
}
function FUN96(
address VAR106,
address VAR18,
uint256 VAR32
) internal view returns (bool VAR107) {
if (VAR32 == 2423228754106148037712574142965102) {
return (FUN97(VAR106).FUN85(VAR18) >= 1);
}
uint256 VAR108 = FUN92() > 20000 ? 20000 : FUN92();
bytes memory VAR109 = VAR9.FUN105(
this.VAR101.VAR100,
VAR18,
VAR32
);
VAR8 {
let VAR110 := FUN3(0x20, VAR109)
let VAR111 := FUN2(VAR109)
let VAR112 := FUN2(0x40)
FUN106(VAR112, 0x0)
let VAR113 := FUN107(
VAR108,
VAR106,
VAR110,
VAR111,
VAR112,
0x20
)
switch VAR113
case 1 {
VAR107 := FUN2(VAR112)
}
}
}
}
0
---------------------------------
33 0x00000000037790973600b70888431f463bce360d.sol
pragma solidity 0.4.26;
library VAR1 {
function FUN1(bytes32 VAR2, bytes VAR3)
internal
pure
returns (address)
{
bytes32 VAR4;
bytes32 VAR5;
uint8 VAR6;
if (VAR3.VAR7 != 65) {
return (address(0));
}
VAR8 {
VAR4 := FUN2(FUN3(VAR3, 0x20))
VAR5 := FUN2(FUN3(VAR3, 0x40))
VAR6 := FUN4(0, FUN2(FUN3(VAR3, 0x60)))
}
if (VAR6 < 27) {
VAR6 += 27;
}
if (VAR6 != 27 && VAR6 != 28) {
return (address(0));
} else {
return FUN5(VAR2, VAR6, VAR4, VAR5);
}
}
function FUN6(bytes32 VAR2)
internal
pure
returns (bytes32)
{
return FUN7(
VAR9.FUN8("", VAR2)
);
}
}
library VAR10 {
function FUN9(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
if (VAR11 == 0) {
return 0;
}
uint256 VAR13 = VAR11 * VAR12;
require(VAR13 / VAR11 == VAR12);
return VAR13;
}
function FUN10(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 > 0);
uint256 VAR13 = VAR11 / VAR12;
return VAR13;
}
function FUN11(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 <= VAR11);
uint256 VAR13 = VAR11 - VAR12;
return VAR13;
}
function FUN3(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
uint256 VAR13 = VAR11 + VAR12;
require(VAR13 >= VAR11);
return VAR13;
}
function FUN12(uint256 VAR11, uint256 VAR12) internal pure returns (uint256) {
require(VAR12 != 0);
return VAR11 % VAR12;
}
}
library VAR14 {
struct VAR15 {
mapping (address => bool) VAR16;
}
function FUN3(Role storage VAR17, address VAR18) internal {
require(VAR18 != address(0));
require(!FUN13(VAR17, VAR18));
VAR17.VAR16[VAR18] = true;
}
function FUN14(Role storage VAR17, address VAR18) internal {
require(VAR18 != address(0));
require(FUN13(VAR17, VAR18));
VAR17.VAR16[VAR18] = false;
}
function FUN13(Role storage VAR17, address VAR18)
internal
view
returns (bool)
{
require(VAR18 != address(0));
return VAR17.VAR16[VAR18];
}
}
contract VAR19 {
using Roles for VAR14.VAR15;
event FUN15(address indexed VAR18);
event FUN16(address indexed VAR18);
VAR14.Role private VAR20;
constructor() internal {
FUN17(msg.sender);
}
modifier FUN18() {
require(FUN19(msg.sender));
VAR21;
}
function FUN19(address VAR18) public view returns (bool) {
return VAR20.FUN13(VAR18);
}
function FUN20(address VAR18) public VAR22 {
FUN17(VAR18);
}
function FUN21() public {
FUN22(msg.sender);
}
function FUN17(address VAR18) internal {
VAR20.FUN3(VAR18);
emit FUN15(VAR18);
}
function FUN22(address VAR18) internal {
VAR20.FUN14(VAR18);
emit FUN16(VAR18);
}
}
contract Pausable is VAR19 {
event FUN23(address VAR18);
event FUN24(address VAR18);
bool private VAR23;
constructor() internal {
VAR23 = false;
}
function FUN25() public view returns(bool) {
return VAR23;
}
modifier FUN26() {
require(!VAR23);
VAR21;
}
modifier FUN27() {
require(VAR23);
VAR21;
}
function FUN28() public onlyPauser VAR24 {
VAR23 = true;
emit FUN23(msg.sender);
}
function FUN29() public onlyPauser VAR25 {
VAR23 = false;
emit FUN24(msg.sender);
}
}
contract VAR26 {
address private VAR27;
event FUN30(
address indexed VAR28,
address indexed VAR29
);
constructor() internal {
VAR27 = msg.sender;
emit FUN30(address(0), VAR27);
}
function FUN31() public view returns(address) {
return VAR27;
}
modifier onlyOwner() {
require(FUN32());
VAR21;
}
function FUN32() public view returns(bool) {
return msg.sender == VAR27;
}
function FUN33() public onlyOwner {
emit FUN30(VAR27, address(0));
VAR27 = address(0);
}
function FUN34(address VAR29) public onlyOwner {
FUN35(VAR29);
}
function FUN35(address VAR29) internal {
require(VAR29 != address(0));
emit FUN30(VAR27, VAR29);
VAR27 = VAR29;
}
}
interface VAR30 {
function FUN36(
address VAR18,
uint256 VAR31
) external view returns (bool);
function FUN37(
address VAR18,
uint256 VAR31
) external view returns (uint256);
function FUN38() external view returns (uint256);
function FUN39(uint256 VAR32) external view returns (uint256);
}
interface VAR33 {
event FUN40(uint256 indexed VAR31, string VAR34);
event FUN41(uint256 indexed VAR31);
event FUN42(address indexed VAR35, string VAR34);
event FUN43(address indexed VAR35);
event FUN44(
address VAR35,
uint256 indexed VAR31
);
event FUN45(
address VAR35,
uint256 indexed VAR31
);
event FUN46(
address VAR35,
address indexed VAR36,
uint256 VAR31,
uint256 VAR37
);
event FUN47(
address VAR35,
address indexed VAR36,
uint256 VAR31
);
function FUN48(uint256 VAR38, string VAR34) external;
function FUN49(uint256 VAR38) external;
function FUN50(address VAR35, string VAR34) external;
function FUN51(address VAR35) external;
function FUN52(
address VAR35,
uint256 VAR31
) external;
function FUN53(
address VAR35,
uint256 VAR31
) external;
function FUN54(
address VAR18,
uint256 VAR31,
uint256 value
) external payable;
function FUN55(
address VAR18,
uint256 VAR31
) external;
function FUN56(
address VAR35,
uint256 VAR31
) external view returns (bool);
function FUN57(
uint256 VAR31
) external view returns (string VAR34);
function FUN58(
address VAR35
) external view returns (string VAR34);
function FUN59(
address VAR18,
uint256 VAR31
) external view returns (address VAR35, bool VAR39);
function FUN38() external view returns (uint256);
function FUN39(uint256 VAR32) external view returns (uint256);
function FUN60() external view returns (uint256[]);
function FUN61() external view returns (uint256);
function FUN62(uint256 VAR32) external view returns (address);
function FUN63() external view returns (address[]);
}
interface VAR40 {
event FUN64(
address indexed VAR35,
address VAR41
);
event FUN65(
address indexed VAR42,
uint256 indexed VAR43,
uint256 VAR44
);
event FUN66(
address indexed VAR42,
uint256 indexed VAR43,
uint256 VAR44
);
event FUN67(
address indexed VAR45,
address indexed VAR46,
uint256 indexed VAR43,
uint256 VAR44
);
event FUN68(
address indexed VAR47,
address indexed VAR46,
uint256 indexed VAR43,
uint256 VAR44
);
function FUN69(uint256 VAR38, string VAR34) external;
function FUN70(uint256 VAR38, bool VAR48) external;
function FUN71(
uint256 VAR38,
address VAR49,
uint256 VAR50
) external;
function FUN72(
uint256 VAR38,
uint256 VAR51
) external;
function FUN73(uint256 VAR38, uint256 VAR52) external;
function FUN74(address VAR41) external;
function FUN75(
uint256 VAR31,
uint256 value,
uint256 VAR53,
bytes VAR3
) external payable;
function FUN76(uint256 VAR31) external;
function FUN77(
address VAR18,
uint256 VAR31,
uint256 value,
uint256 VAR53,
bytes VAR3
) external payable;
function FUN78(address VAR18, uint256 VAR31) external;
function FUN79(
bytes32 VAR2,
bytes VAR3
) external;
function FUN80(
address VAR18,
address VAR54,
uint256 VAR31,
uint256 value,
uint256 VAR55,
uint256 VAR53
) external view returns (bytes32 VAR2);
function FUN81(
uint256 VAR31,
uint256 value,
uint256 VAR55,
uint256 VAR53,
bytes VAR3
) external view returns (bool);
function FUN82(
address VAR18,
uint256 VAR31,
uint256 value,
uint256 VAR55,
uint256 VAR53,
bytes VAR3
) external view returns (bool);
function FUN83(
uint256 VAR31
) external view returns (
string VAR34,
bool VAR56,
bool VAR57,
address VAR58,
uint256 VAR59,
uint256 VAR51,
uint256 VAR60
);
function FUN84(
address VAR35
) external view returns (
address VAR61
);
}
interface VAR62 {
function FUN85(address) external view returns (uint256);
function transfer(address, uint256) external returns (bool);
}
contract ExtendedJurisdiction is VAR26, VAR63, VAR30, VAR33, VAR40 {
using ECDSA for bytes32;
using SafeMath for uint256;
struct VAR64 {
bool VAR65;
uint256 VAR32;
address VAR61;
string VAR34;
}
struct VAR66 {
bool VAR65;
bool VAR67;
address VAR54;
address VAR35;
uint256 value;
uint256 VAR68;
}
struct VAR69 {
bool VAR65;
bool VAR70;
bool VAR48;
uint256 VAR32;
address VAR58;
uint256 VAR71;
uint256 VAR72;
uint256 VAR60;
string VAR34;
mapping(address => bool) VAR73;
}
mapping(uint256 => VAR69) private VAR74;
mapping(address => mapping(uint256 => VAR66)) private VAR75;
mapping(address => VAR64) private VAR76;
mapping(address => address) private VAR77;
mapping(uint256 => bytes32) private VAR78;
mapping(bytes32 => bool) private VAR79;
mapping(address => uint256[]) private VAR80;
mapping(address => mapping(uint256 => uint256)) private VAR81;
uint256[] private VAR82;
address[] private VAR83;
uint256 private VAR84;
function FUN48(
uint256 VAR38,
string VAR34
) external onlyOwner VAR24 {
require(
!FUN86(VAR38),
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
VAR38, false, VAR34
)
);
if (VAR78[VAR38] == bytes32(0)) {
VAR78[VAR38] = VAR2;
}
require(
VAR2 == VAR78[VAR38],
""
);
VAR74[VAR38] = FUN87({
VAR65: true,
VAR70: false,
VAR48: false,
VAR32: VAR82.VAR7,
VAR58: address(0),
VAR71: uint256(0),
VAR72: uint256(0),
VAR60: uint256(0),
VAR34: VAR34
});
VAR82.FUN88(VAR38);
emit FUN40(VAR38, VAR34);
}
function FUN69(
uint256 VAR38,
string VAR34
) external onlyOwner VAR24 {
require(
!FUN86(VAR38),
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
VAR38, true, VAR34
)
);
if (VAR78[VAR38] == bytes32(0)) {
VAR78[VAR38] = VAR2;
}
require(
VAR2 == VAR78[VAR38],
""
);
VAR74[VAR38] = FUN87({
VAR65: true,
VAR70: true,
VAR48: false,
VAR32: VAR82.VAR7,
VAR58: address(0),
VAR71: uint256(0),
VAR72: uint256(0),
VAR60: uint256(0),
VAR34: VAR34
});
VAR82.FUN88(VAR38);
emit FUN40(VAR38, VAR34);
}
function FUN70(uint256 VAR38, bool VAR48) external {
require(
FUN86(VAR38),
""
);
VAR74[VAR38].VAR48 = VAR48;
}
function FUN71(
uint256 VAR38,
address VAR49,
uint256 VAR50
) external {
require(
FUN86(VAR38),
""
);
VAR74[VAR38].VAR58 = VAR49;
VAR74[VAR38].VAR71 = VAR50;
}
function FUN72(
uint256 VAR38,
uint256 VAR51
) external {
require(
FUN86(VAR38),
""
);
VAR74[VAR38].VAR72 = VAR51;
}
function FUN73(uint256 VAR38, uint256 VAR52) external {
require(
FUN86(VAR38),
""
);
VAR74[VAR38].VAR60 = VAR52;
}
function FUN49(uint256 VAR38) external onlyOwner VAR24 {
require(
FUN86(VAR38),
""
);
uint256 VAR85 = VAR82[VAR82.VAR7.FUN11(1)];
VAR82[VAR74[VAR38].VAR32] = VAR85;
VAR74[VAR85].VAR32 = VAR74[VAR38].VAR32;
VAR82.VAR7--;
delete VAR74[VAR38];
emit FUN41(VAR38);
}
function FUN50(
address VAR35,
string VAR34
) external onlyOwner VAR24 {
require(VAR35 != address(0), "");
require(
!FUN89(VAR35),
""
);
require(
VAR77[VAR35] == address(0),
""
);
VAR76[VAR35] = FUN90({
VAR65: true,
VAR32: VAR83.VAR7,
VAR61: VAR35,
VAR34: VAR34
});
VAR77[VAR35] = VAR35;
VAR83.FUN88(VAR35);
emit FUN42(VAR35, VAR34);
}
function FUN51(address VAR35) external onlyOwner VAR24 {
require(
FUN89(VAR35),
""
);
while (VAR80[VAR35].VAR7 > 0 && FUN91() > 25000) {
uint256 VAR86 = VAR80[VAR35].VAR7.FUN11(1);
uint256 VAR87 = VAR80[VAR35][VAR86];
delete VAR74[VAR87].VAR73[VAR35];
delete VAR81[VAR35][VAR87];
VAR80[VAR35].VAR7--;
}
require(
VAR80[VAR35].VAR7 == 0,
""
);
address VAR88 = VAR83[VAR83.VAR7.FUN11(1)];
VAR83[VAR76[VAR35].VAR32] = VAR88;
VAR76[VAR88].VAR32 = VAR76[VAR35].VAR32;
VAR83.VAR7--;
delete VAR77[VAR76[VAR35].VAR61];
delete VAR76[VAR35];
emit FUN43(VAR35);
}
function FUN52(
address VAR35,
uint256 VAR31
) external onlyOwner VAR24 {
require(
FUN89(VAR35) && FUN86(VAR31),
""
);
require(
!VAR74[VAR31].VAR73[VAR35],
""
);
VAR74[VAR31].VAR73[VAR35] = true;
uint256 VAR32 = VAR80[VAR35].VAR7;
VAR81[VAR35][VAR31] = VAR32;
VAR80[VAR35].FUN88(VAR31);
emit FUN44(VAR35, VAR31);
}
function FUN53(
address VAR35,
uint256 VAR31
) external onlyOwner VAR24 {
require(
FUN92(VAR35, VAR31),
""
);
delete VAR74[VAR31].VAR73[VAR35];
uint256 VAR86 = VAR80[VAR35].VAR7.FUN11(1);
uint256 VAR85 = VAR80[VAR35][VAR86];
uint256 VAR32 = VAR81[VAR35][VAR31];
VAR80[VAR35][VAR32] = VAR85;
VAR80[VAR35].VAR7--;
VAR81[VAR35][VAR85] = VAR32;
delete VAR81[VAR35][VAR31];
emit FUN45(VAR35, VAR31);
}
function FUN74(address VAR41) external {
require(
FUN89(msg.sender),
"");
require(
VAR77[VAR41] == address(0),
""
);
delete VAR77[VAR76[msg.sender].VAR61];
VAR76[msg.sender].VAR61 = VAR41;
VAR77[VAR41] = msg.sender;
emit FUN64(msg.sender, VAR41);
}
function FUN54(
address VAR18,
uint256 VAR31,
uint256 value
) external payable VAR24 {
require(
FUN92(msg.sender, VAR31),
""
);
require(
!VAR75[VAR18][VAR31].VAR65,
""
);
uint256 VAR72 = VAR74[VAR31].VAR72;
uint256 VAR60 = VAR74[VAR31].VAR60;
uint256 VAR68 = msg.value.FUN11(VAR60);
require(
VAR68 >= VAR72,
""
);
VAR75[VAR18][VAR31] = FUN93({
VAR65: true,
VAR67: false,
VAR54: address(0),
VAR35: msg.sender,
value: value,
VAR68: VAR68
});
emit FUN46(msg.sender, VAR18, VAR31, value);
if (VAR68 > 0) {
emit FUN65(msg.sender, VAR31, VAR68);
}
if (VAR60 > 0) {
if (FUN31().FUN94(VAR60)) {
emit FUN67(FUN31(), msg.sender, VAR31, VAR60);
} else {
VAR84 = VAR84.FUN3(VAR60);
}
}
}
function FUN55(
address VAR18,
uint256 VAR31
) external VAR24 {
require(
VAR75[VAR18][VAR31].VAR65,
""
);
address VAR35 = VAR75[VAR18][VAR31].VAR35;
require(
msg.sender == VAR35 || msg.sender == FUN31(),
""
);
uint256 VAR68 = VAR75[VAR18][VAR31].VAR68;
address VAR89;
if (VAR75[VAR18][VAR31].VAR67) {
VAR89 = VAR18;
} else {
address VAR54 = VAR75[VAR18][VAR31].VAR54;
if (VAR54 == address(0)) {
VAR89 = VAR35;
} else {
VAR89 = VAR54;
}
}
delete VAR75[VAR18][VAR31];
emit FUN47(VAR35, VAR18, VAR31);
if (VAR68 > 0 && address(this).VAR90 >= VAR68) {
uint256 VAR91 = 37700;
uint256 VAR92 = VAR91.FUN9(VAR93.VAR94);
if (VAR68 > VAR92) {
if (VAR89.FUN94(VAR68.FUN11(VAR92))) {
emit FUN66(
VAR89,
VAR31,
VAR68.FUN11(VAR92)
);
} else {
VAR84 = VAR84.FUN3(VAR68.FUN11(VAR92));
}
emit FUN68(
VAR93.VAR95,
VAR89,
VAR31,
VAR92
);
VAR93.VAR95.transfer(VAR92);
} else {
emit FUN68(
VAR93.VAR95,
VAR89,
VAR31,
VAR68
);
VAR93.VAR95.transfer(VAR68);
}
}
}
function FUN75(
uint256 VAR31,
uint256 value,
uint256 VAR53,
bytes VAR3
) external payable {
require(
!VAR75[msg.sender][VAR31].VAR65,
""
);
uint256 VAR72 = VAR74[VAR31].VAR72;
uint256 VAR60 = VAR74[VAR31].VAR60;
uint256 VAR68 = msg.value.FUN11(VAR53).FUN11(VAR60);
require(
VAR68 >= VAR72,
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
address(this),
msg.sender,
address(0),
msg.value,
VAR53,
VAR31,
value
)
);
require(
!VAR79[VAR2],
""
);
address VAR61 = VAR2.FUN6().FUN1(VAR3);
address VAR35 = VAR77[VAR61];
require(
FUN92(VAR35, VAR31),
""
);
VAR75[msg.sender][VAR31] = FUN93({
VAR65: true,
VAR67: true,
VAR54: address(0),
VAR35: VAR35,
value: value,
VAR68: VAR68
});
VAR79[VAR2] = true;
emit FUN46(VAR35, msg.sender, VAR31, value);
if (VAR68 > 0) {
emit FUN65(msg.sender, VAR31, VAR68);
}
if (VAR60 > 0) {
if (FUN31().FUN94(VAR60)) {
emit FUN67(FUN31(), msg.sender, VAR31, VAR60);
} else {
VAR84 = VAR84.FUN3(VAR60);
}
}
if (VAR53 > 0) {
if (VAR35.FUN94(VAR53)) {
emit FUN67(VAR35, msg.sender, VAR31, VAR53);
} else {
VAR84 = VAR84.FUN3(VAR53);
}
}
}
function FUN76(uint256 VAR31) external {
require(
!VAR74[VAR31].VAR70,
""
);
require(
VAR75[msg.sender][VAR31].VAR65,
""
);
address VAR35 = VAR75[msg.sender][VAR31].VAR35;
uint256 VAR68 = VAR75[msg.sender][VAR31].VAR68;
address VAR89;
if (VAR75[msg.sender][VAR31].VAR67) {
VAR89 = msg.sender;
} else {
address VAR54 = VAR75[msg.sender][VAR31].VAR54;
if (VAR54 == address(0)) {
VAR89 = VAR35;
} else {
VAR89 = VAR54;
}
}
delete VAR75[msg.sender][VAR31];
emit FUN47(VAR35, msg.sender, VAR31);
if (VAR68 > 0 && address(this).VAR90 >= VAR68) {
if (VAR89.FUN94(VAR68)) {
emit FUN66(VAR89, VAR31, VAR68);
} else {
VAR84 = VAR84.FUN3(VAR68);
}
}
}
function FUN77(
address VAR18,
uint256 VAR31,
uint256 value,
uint256 VAR53,
bytes VAR3
) external payable {
require(
!VAR74[VAR31].VAR48,
""
);
require(
!VAR75[VAR18][VAR31].VAR65,
""
);
uint256 VAR72 = VAR74[VAR31].VAR72;
uint256 VAR60 = VAR74[VAR31].VAR60;
uint256 VAR68 = msg.value.FUN11(VAR53).FUN11(VAR60);
require(
VAR68 >= VAR72,
""
);
bytes32 VAR2 = FUN7(
VAR9.FUN8(
address(this),
VAR18,
msg.sender,
msg.value,
VAR53,
VAR31,
value
)
);
require(
!VAR79[VAR2],
""
);
address VAR61 = VAR2.FUN6().FUN1(VAR3);
address VAR35 = VAR77[VAR61];
require(
FUN92(VAR35, VAR31),
""
);
VAR75[VAR18][VAR31] = FUN93({
VAR65: true,
VAR67: false,
VAR54: msg.sender,
VAR35: VAR35,
value: value,
VAR68: VAR68
});
VAR79[VAR2] = true;
emit FUN46(VAR35, VAR18, VAR31, value);
if (VAR68 > 0) {
emit FUN65(msg.sender, VAR31, VAR68);
}
if (VAR60 > 0) {
if (FUN31().FUN94(VAR60)) {
emit FUN67(FUN31(), msg.sender, VAR31, VAR60);
} else {
VAR84 = VAR84.FUN3(VAR60);
}
}
if (VAR53 > 0) {
if (VAR35.FUN94(VAR53)) {
emit FUN67(VAR35, msg.sender, VAR31, VAR53);
} else {
VAR84 = VAR84.FUN3(VAR53);
}
}
}
function FUN78(address VAR18, uint256 VAR31) external {
require(
!VAR74[VAR31].VAR70,
""
);
require(
VAR75[VAR18][VAR31].VAR65,
""
);
require(
VAR75[VAR18][VAR31].VAR54 == msg.sender,
""
);
address VAR35 = VAR75[VAR18][VAR31].VAR35;
uint256 VAR68 = VAR75[VAR18][VAR31].VAR68;
delete VAR75[VAR18][VAR31];
emit FUN47(VAR35, VAR18, VAR31);
if (VAR68 > 0 && address(this).VAR90 >= VAR68) {
if (msg.sender.FUN94(VAR68)) {
emit FUN66(msg.sender, VAR31, VAR68);
} else {
VAR84 = VAR84.FUN3(VAR68);
}
}
}
function FUN79(
bytes32 VAR2,
bytes VAR3
) external {
address VAR35 = VAR77[
VAR2.FUN6().FUN1(VAR3)
];
require(
msg.sender == VAR35 || msg.sender == FUN31(),
""
);
VAR79[VAR2] = true;
}
function FUN36(
address VAR18,
uint256 VAR31
) external view returns (bool) {
address VAR35 = VAR75[VAR18][VAR31].VAR35;
return (
(
VAR76[VAR35].VAR65 &&
VAR74[VAR31].VAR73[VAR35] &&
VAR74[VAR31].VAR65
) || (
VAR74[VAR31].VAR58 != address(0) &&
FUN95(
VAR74[VAR31].VAR58,
VAR18,
VAR74[VAR31].VAR71
)
)
);
}
function FUN37(
address VAR18,
uint256 VAR31
) external view returns (uint256 value) {
address VAR35 = VAR75[VAR18][VAR31].VAR35;
if (
VAR76[VAR35].VAR65 &&
VAR74[VAR31].VAR73[VAR35] &&
VAR74[VAR31].VAR65
) {
return VAR75[VAR18][VAR31].value;
} else if (
VAR74[VAR31].VAR58 != address(0)
) {
if (VAR74[VAR31].VAR71 == 2423228754106148037712574142965102) {
require(
FUN96(
VAR74[VAR31].VAR58
).FUN85(VAR18) >= 1,
""
);
return 1;
}
require(
FUN97(
VAR74[VAR31].VAR58
).FUN36(
VAR18, VAR74[VAR31].VAR71
),
""
);
return (
FUN97(
VAR74[VAR31].VAR58
).FUN37(
VAR18, VAR74[VAR31].VAR71
)
);
}
revert("");
}
function FUN56(
address VAR35,
uint256 VAR31
) external view returns (bool) {
return FUN92(VAR35, VAR31);
}
function FUN57(
uint256 VAR31
) external view returns (
string VAR34
) {
return VAR74[VAR31].VAR34;
}
function FUN83(
uint256 VAR31
) external view returns (
string VAR34,
bool VAR56,
bool VAR57,
address VAR58,
uint256 VAR71,
uint256 VAR51,
uint256 VAR60
) {
return (
VAR74[VAR31].VAR34,
VAR74[VAR31].VAR70,
VAR74[VAR31].VAR48,
VAR74[VAR31].VAR58,
VAR74[VAR31].VAR71,
VAR74[VAR31].VAR72,
VAR74[VAR31].VAR60
);
}
function FUN58(
address VAR35
) external view returns (
string VAR34
) {
return VAR76[VAR35].VAR34;
}
function FUN84(
address VAR35
) external view returns (
address VAR61
) {
return VAR76[VAR35].VAR61;
}
function FUN59(
address VAR18,
uint256 VAR31
) external view returns (
address VAR35,
bool VAR39
) {
address VAR96 = VAR75[VAR18][VAR31].VAR35;
return (VAR96, FUN92(VAR96, VAR31));
}
function FUN38() external view returns (uint256) {
return VAR82.VAR7;
}
function FUN39(uint256 VAR32) external view returns (uint256) {
require(
VAR32 < VAR82.VAR7,
""
);
return VAR82[VAR32];
}
function FUN60() external view returns (uint256[]) {
return VAR82;
}
function FUN61() external view returns (uint256) {
return VAR83.VAR7;
}
function FUN62(
uint256 VAR32
) external view returns (address) {
return VAR83[VAR32];
}
function FUN63() external view returns (address[]) {
return VAR83;
}
function FUN98(bytes4 VAR97) external view returns (bool) {
return (
VAR97 == this.VAR98.VAR99 ||
VAR97 == (
this.VAR100.VAR99
^ this.VAR101.VAR99
^ this.VAR102.VAR99
^ this.VAR103.VAR99
)
);
}
function FUN80(
address VAR18,
address VAR54,
uint256 VAR31,
uint256 value,
uint256 VAR55,
uint256 VAR53
) external view returns (
bytes32 VAR2
) {
return FUN99(
VAR18,
VAR54,
VAR31,
value,
VAR55,
VAR53
);
}
function FUN81(
uint256 VAR31,
uint256 value,
uint256 VAR55,
uint256 VAR53,
bytes VAR3
) external view returns (bool) {
bytes32 VAR2 = FUN99(
msg.sender,
address(0),
VAR31,
value,
VAR55,
VAR53
);
address VAR61 = VAR2.FUN6().FUN1(VAR3);
address VAR35 = VAR77[VAR61];
uint256 VAR72 = VAR74[VAR31].VAR72;
uint256 VAR60 = VAR74[VAR31].VAR60;
return (
VAR55 >= VAR72.FUN3(VAR60).FUN3(VAR53) &&
!VAR79[VAR2] &&
FUN92(VAR35, VAR31) &&
!VAR75[msg.sender][VAR31].VAR65
);
}
function FUN82(
address VAR18,
uint256 VAR31,
uint256 value,
uint256 VAR55,
uint256 VAR53,
bytes VAR3
) external view returns (bool) {
bytes32 VAR2 = FUN99(
VAR18,
msg.sender,
VAR31,
value,
VAR55,
VAR53
);
address VAR61 = VAR2.FUN6().FUN1(VAR3);
address VAR35 = VAR77[VAR61];
uint256 VAR72 = VAR74[VAR31].VAR72;
uint256 VAR60 = VAR74[VAR31].VAR60;
return (
VAR55 >= VAR72.FUN3(VAR60).FUN3(VAR53) &&
!VAR79[VAR2] &&
FUN92(VAR35, VAR31) &&
!VAR75[VAR18][VAR31].VAR65
);
}
function FUN86(uint256 VAR31) public view returns (bool) {
return VAR74[VAR31].VAR65;
}
function FUN89(address VAR18) public view returns (bool) {
return VAR76[VAR18].VAR65;
}
function FUN100() public view returns (uint256) {
return VAR84;
}
function FUN101(address VAR104) public view returns (uint256) {
return FUN96(VAR104).FUN85(address(this));
}
function FUN102(address VAR18, uint256 value) public onlyOwner {
VAR84 = VAR84.FUN11(value);
VAR18.transfer(value);
}
function FUN103(
address VAR104,
address VAR18,
uint256 value
) public onlyOwner {
require(FUN96(VAR104).transfer(VAR18, value));
}
function FUN92(
address VAR35,
uint256 VAR31
) internal view returns (bool) {
return (
VAR76[VAR35].VAR65 &&
VAR74[VAR31].VAR73[VAR35] &&
VAR74[VAR31].VAR65
);
}
function FUN99(
address VAR18,
address VAR54,
uint256 VAR31,
uint256 value,
uint256 VAR55,
uint256 VAR53
) internal view returns (bytes32 VAR2) {
return FUN7(
VAR9.FUN8(
address(this),
VAR18,
VAR54,
VAR55,
VAR53,
VAR31,
value
)
);
}
function FUN95(
address VAR105,
address VAR18,
uint256 VAR31
) internal view returns (bool VAR106) {
if (VAR31 == 2423228754106148037712574142965102) {
return (FUN96(VAR105).FUN85(VAR18) >= 1);
}
uint256 VAR107 = FUN91() > 20000 ? 20000 : FUN91();
bytes memory VAR108 = VAR9.FUN104(
this.VAR100.VAR99,
VAR18,
VAR31
);
VAR8 {
let VAR109 := FUN3(0x20, VAR108)
let VAR110 := FUN2(VAR108)
let VAR111 := FUN2(0x40)
FUN105(VAR111, 0x0)
let VAR112 := FUN106(
VAR107,
VAR105,
VAR109,
VAR110,
VAR111,
0x20
)
switch VAR112
case 1 {
VAR106 := FUN2(VAR111)
}
}
}
}
0
---------------------------------
34 0x0000000006adbd7c01bc0738cdbfc3932600ad63.sol
pragma VAR1 ^0.5.0;
interface VAR2 {
function FUN1(uint256 value) external returns (uint256 VAR3);
function FUN2(address VAR4, uint256 value) external returns (uint256 VAR3);
function FUN3(address VAR5) external view returns (uint256);
}
library VAR6 {
function FUN4(address VAR7, uint value, bytes memory VAR8, uint VAR9, uint VAR10) internal returns(bool VAR11) {
VAR12 {
let VAR13 := FUN5(0x40)
let VAR14 := FUN6(VAR8, 32)
VAR11 := call(
FUN7(VAR15, 34710),
VAR7,
value,
FUN6(VAR14, VAR9),
VAR10,
VAR13,
0
)
}
}
}
interface VAR16 {
function transfer(address VAR17, uint256 value) external returns (bool);
function FUN8(address VAR18, uint256 value) external returns (bool);
function FUN9(address VAR4, address VAR17, uint256 value) external returns (bool);
function FUN10() external view returns (uint256);
function FUN3(address VAR5) external view returns (uint256);
function FUN11(address VAR19, address VAR18) external view returns (uint256);
event Transfer(address indexed VAR4, address indexed VAR17, uint256 value);
event FUN12(address indexed VAR19, address indexed VAR18, uint256 value);
}
library VAR20 {
function FUN13(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
if (VAR21 == 0) {
return 0;
}
uint256 VAR23 = VAR21 * VAR22;
require(VAR23 / VAR21 == VAR22);
return VAR23;
}
function FUN14(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
require(VAR22 > 0);
uint256 VAR23 = VAR21 / VAR22;
return VAR23;
}
function FUN7(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
require(VAR22 <= VAR21);
uint256 VAR23 = VAR21 - VAR22;
return VAR23;
}
function FUN6(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
uint256 VAR23 = VAR21 + VAR22;
require(VAR23 >= VAR21);
return VAR23;
}
function FUN15(uint256 VAR21, uint256 VAR22) internal pure returns (uint256) {
require(VAR22 != 0);
return VAR21 % VAR22;
}
}
library VAR24 {
function FUN16(address VAR25) internal view returns (bool) {
uint256 VAR26;
VAR12 { VAR26 := FUN17(VAR25) }
return VAR26 > 0;
}
}
contract VAR27 {
address private VAR28;
event FUN18(address indexed VAR29, address indexed VAR30);
constructor () internal {
VAR28 = msg.sender;
emit FUN18(address(0), VAR28);
}
function FUN19() public view returns (address) {
return VAR28;
}
modifier onlyOwner() {
require(FUN20());
VAR31;
}
function FUN20() public view returns (bool) {
return msg.sender == VAR28;
}
function FUN21() public onlyOwner {
emit FUN18(VAR28, address(0));
VAR28 = address(0);
}
function FUN22(address VAR30) public onlyOwner {
FUN23(VAR30);
}
function FUN23(address VAR30) internal {
require(VAR30 != address(0));
emit FUN18(VAR28, VAR30);
VAR28 = VAR30;
}
}
library VAR32 {
using SafeMath for uint256;
using Address for address;
function FUN24(IERC20 VAR33, address VAR17, uint256 value) internal {
FUN25(VAR33, VAR34.FUN26(VAR33.transfer.VAR35, VAR17, value));
}
function FUN27(IERC20 VAR33, address VAR4, address VAR17, uint256 value) internal {
FUN25(VAR33, VAR34.FUN26(VAR33.VAR36.VAR35, VAR4, VAR17, value));
}
function FUN28(IERC20 VAR33, address VAR18, uint256 value) internal {
require((value == 0) || (VAR33.FUN11(address(this), VAR18) == 0));
FUN25(VAR33, VAR34.FUN26(VAR33.VAR37.VAR35, VAR18, value));
}
function FUN29(IERC20 VAR33, address VAR18, uint256 value) internal {
uint256 VAR38 = VAR33.FUN11(address(this), VAR18).FUN6(value);
FUN25(VAR33, VAR34.FUN26(VAR33.VAR37.VAR35, VAR18, VAR38));
}
function FUN30(IERC20 VAR33, address VAR18, uint256 value) internal {
uint256 VAR38 = VAR33.FUN11(address(this), VAR18).FUN7(value);
FUN25(VAR33, VAR34.FUN26(VAR33.VAR37.VAR35, VAR18, VAR38));
}
function FUN25(IERC20 VAR33, bytes memory VAR8) private {
require(address(VAR33).FUN16());
(bool VAR39, bytes memory VAR40) = address(VAR33).call(VAR8);
require(VAR39);
if (VAR40.VAR41 > 0) {
require(VAR34.FUN31(VAR40, (bool)));
}
}
}
contract IWETH is VAR16 {
function FUN32() external payable;
function FUN33(uint256 VAR42) external;
}
contract TokenSpender is VAR27 {
using SafeERC20 for VAR16;
function FUN34(IERC20 VAR33, address VAR5, address VAR43, uint256 VAR42) external onlyOwner {
VAR33.FUN27(VAR5, VAR43, VAR42);
}
}
contract VAR44 {
using SafeERC20 for VAR16;
using SafeMath for uint;
using ExternalCall for address;
address constant VAR45 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
TokenSpender public VAR18;
IGST2 VAR46;
address payable VAR19;
uint VAR47;
event FUN35(
IERC20 indexed VAR48,
address indexed VAR49,
uint256 VAR47
);
modifier onlyOwner {
require(
msg.sender == VAR19,
""
);
VAR31;
}
constructor(
address payable VAR28,
IGST2 VAR50,
uint VAR51
)
public
{
VAR18 = VAR52 FUN36();
VAR19 = VAR28;
VAR46 = VAR50;
VAR47 = VAR51;
}
function FUN37(uint VAR51) public onlyOwner {
VAR47 = VAR51;
}
function FUN38(
IERC20 VAR53,
IERC20 VAR48,
uint VAR54,
address[] memory VAR55,
bytes memory VAR56,
uint[] memory VAR57,
uint[] memory VAR58,
uint VAR59,
uint VAR60,
address payable VAR49
)
public
payable
returns (uint VAR61)
{
VAR61 = FUN39();
uint VAR62 = VAR46.FUN3(address(this));
require(VAR55.VAR41 + 1 == VAR57.VAR41);
if (address(VAR53) != VAR45) {
VAR18.FUN34(VAR53, msg.sender, address(this), VAR54);
}
for (uint VAR63 = 0; VAR63 < VAR57.VAR41 - 1; VAR63++) {
if (VAR57[VAR63 + 1] - VAR57[VAR63] > 0) {
require(
VAR56[VAR57[VAR63] + 0] != VAR18.VAR64.VAR35[0] ||
VAR56[VAR57[VAR63] + 1] != VAR18.VAR64.VAR35[1] ||
VAR56[VAR57[VAR63] + 2] != VAR18.VAR64.VAR35[2] ||
VAR56[VAR57[VAR63] + 3] != VAR18.VAR64.VAR35[3]
);
require(VAR55[VAR63].FUN4(VAR58[VAR63], VAR56, VAR57[VAR63], VAR57[VAR63 + 1] - VAR57[VAR63]));
}
}
if (address(VAR48) == VAR45) {
require(address(this).VAR65 >= VAR60);
} else {
require(VAR48.FUN3(address(this)) >= VAR60);
}
//
require(VAR62 == VAR46.FUN3(address(this)));
if (VAR59 > 0) {
FUN40(VAR61, VAR59);
}
//
VAR61 = FUN41(VAR48, address(this)) * VAR47 / 10000;
if (VAR49 != address(0)) {
VAR61 /= 2;
if (!FUN42(VAR48, VAR49, VAR61, true)) {
VAR61 *= 2;
emit FUN35(VAR48, address(0), VAR61);
} else {
emit FUN35(VAR48, VAR49, VAR61 / 2);
}
}
FUN42(VAR48, VAR19, VAR61, false);
VAR61 = FUN41(VAR48, address(this));
FUN42(VAR48, msg.sender, VAR61, false);
}
function FUN43(IERC20 VAR33, address VAR17) external {
if (
address(VAR33) != VAR45 &&
VAR33.FUN11(address(this), VAR17) == 0
) {
VAR33.FUN28(VAR17, uint256(-1));
}
}
function FUN44(IWETH VAR33) external {
uint256 VAR42 = VAR33.FUN3(address(this));
VAR33.FUN33(VAR42);
}
function FUN41(IERC20 VAR33, address VAR5) internal view returns(uint256) {
if (address(VAR33) == VAR45 || VAR33 == FUN45(0)) {
return VAR5.VAR65;
} else {
return VAR33.FUN3(VAR5);
}
}
function FUN42(IERC20 VAR33, address payable VAR17, uint256 VAR42, bool VAR66) internal returns(bool) {
if (address(VAR33) == VAR45 || VAR33 == FUN45(0)) {
if (VAR66) {
return VAR17.FUN46(VAR42);
} else {
VAR17.transfer(VAR42);
return true;
}
} else {
VAR33.FUN24(VAR17, VAR42);
return true;
}
}
function FUN40(
uint VAR67,
uint VAR59
)
private
returns (uint VAR3)
{
uint VAR68 = 32254;
uint VAR69 = 36543;
uint VAR70 = 14154;
uint VAR71 = 6870;
uint VAR72 = 24000;
uint VAR54 = ((VAR67 - FUN39()) + VAR70) / (2 * VAR72 - VAR71);
uint VAR73 = VAR54 * VAR72;
uint VAR74 = VAR68 + (VAR54 * VAR69);
uint VAR75 = VAR70 + (VAR54 * VAR71);
uint VAR76 = (VAR73 * 100 * VAR77.VAR78) / (VAR74 * VAR59 + VAR75 * VAR77.VAR78);
if (VAR76 > 100) {
return FUN47(
VAR54
);
} else {
return 0;
}
}
function FUN47(
uint VAR54
)
private
returns (uint VAR3)
{
if (VAR54 > 0) {
uint VAR79 = 0;
uint VAR15 = FUN39();
if (VAR15 >= 27710) {
VAR79 = (VAR15 - 27710) / (1148 + 5722 + 150);
}
if (VAR54 > VAR79) {
VAR54 = VAR79;
}
uint VAR62 = FUN45(address(VAR46)).FUN3(address(this));
if (VAR54 > 0 && VAR62 >= VAR54) {
return VAR46.FUN1(VAR54);
} else {
return 0;
}
} else {
return 0;
}
}
function() external payable {
if (msg.value == 0 && msg.sender == VAR19) {
IERC20 VAR50 = FUN45(address(VAR46));
VAR19.transfer(address(this).VAR65);
VAR50.FUN24(VAR19, VAR50.FUN3(address(this)));
}
}
}
0
---------------------------------
35 0x00000000441378008ea67f4284a57932b1c000a5.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1() public view returns (address);
function() external payable {
address VAR3 = FUN1();
VAR4 {
let VAR5 := FUN2(0x40)
FUN3(VAR5, 0, VAR6)
let VAR7 := FUN4(VAR8, VAR3, VAR5, VAR6, 0, 0)
let VAR9 := VAR10
FUN5(VAR5, 0, VAR9)
switch VAR7
case 0 { revert(VAR5, VAR9) }
default { return(VAR5, VAR9) }
}
}
}
contract UpgradeabilityProxy is VAR2 {
event FUN6(address indexed VAR11);
bytes32 private constant VAR12 = FUN7("");
function FUN1() public view returns (address VAR13) {
bytes32 VAR14 = VAR12;
VAR4 {
VAR13 := FUN8(VAR14)
}
}
function FUN9(address VAR15) internal {
bytes32 VAR14 = VAR12;
VAR4 {
FUN10(VAR14, VAR15)
}
}
function FUN11(address VAR15) internal {
address VAR16 = FUN1();
require(VAR16 != VAR15);
FUN9(VAR15);
emit FUN6(VAR15);
}
}
contract TrueGBP is VAR17 {
event FUN12(address indexed VAR18, address indexed VAR19);
event FUN13(address VAR20, address VAR21);
bytes32 private constant VAR22 = FUN7("");
bytes32 private constant VAR23 = FUN7("");
constructor() public {
FUN14(msg.sender);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN15(), "");
VAR24;
}
modifier FUN16() {
require(msg.sender == FUN17(), "");
VAR24;
}
function FUN15() public view returns (address VAR25) {
bytes32 VAR14 = VAR22;
VAR4 {
VAR25 := FUN8(VAR14)
}
}
function FUN17() public view returns (address VAR21) {
bytes32 VAR14 = VAR23;
VAR4 {
VAR21 := FUN8(VAR14)
}
}
function FUN14(address VAR26) internal {
bytes32 VAR14 = VAR22;
VAR4 {
FUN10(VAR14, VAR26)
}
}
function FUN18(address VAR27) internal {
bytes32 VAR14 = VAR23;
VAR4 {
FUN10(VAR14, VAR27)
}
}
function FUN19(address VAR19) external onlyProxyOwner {
require(VAR19 != address(0));
FUN18(VAR19);
emit FUN13(FUN15(), VAR19);
}
function FUN20() external VAR28 {
emit FUN12(FUN15(), FUN17());
FUN14(FUN17());
FUN18(address(0));
}
function FUN21(address VAR11) external onlyProxyOwner {
FUN11(VAR11);
}
}
0
---------------------------------
36 0x0000000053d411becdb4a82d8603edc6d8b8b3bc.sol
pragma VAR1 ^0.5.0;
pragma experimental VAR2;
interface VAR3 {
function FUN1(uint256 value) external returns (uint256 VAR4);
function FUN2(address VAR5, uint256 value) external returns (uint256 VAR4);
function FUN3(address VAR6) external view returns (uint256);
}
contract VAR7 {
bytes constant public VAR8 = "";
}
contract VAR9
{
struct VAR10 {
uint256 VAR11;
uint256 VAR12;
uint256 VAR13;
uint256 VAR14;
}
struct VAR15 {
FillResults VAR16;
FillResults VAR17;
uint256 VAR18;
}
}
contract VAR19
{
bytes32 constant internal VAR20 = FUN4(VAR21.FUN5(
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
""
));
enum VAR22 {
VAR23,
VAR24,
VAR25,
VAR26,
VAR27,
VAR28,
VAR29
}
struct VAR30 {
address VAR31;
address VAR32;
address VAR33;
address VAR34;
uint256 VAR35;
uint256 VAR36;
uint256 VAR37;
uint256 VAR38;
uint256 VAR39;
uint256 VAR40;
bytes VAR41;
bytes VAR42;
}
struct VAR43 {
uint8 VAR44;
bytes32 VAR45;
uint256 VAR46;
}
}
contract VAR47 {
function FUN6(uint256 VAR48)
external;
function FUN7(
VAR19.Order memory VAR49,
uint256 VAR50,
bytes memory VAR51
)
public
returns (VAR9.FillResults memory VAR52);
function FUN8(VAR19.Order memory VAR49)
public;
function FUN9(VAR19.Order memory VAR49)
public
view
returns (VAR19.OrderInfo memory VAR53);
}
contract VAR54 {
function FUN10(address VAR55)
external;
function FUN11(bytes4 VAR56)
external
view
returns (address);
}
contract VAR57 {
function FUN12(
VAR19.Order memory VAR58,
VAR19.Order memory VAR59,
bytes memory VAR60,
bytes memory VAR61
)
public
returns (VAR9.MatchedFillResults memory VAR62);
}
contract VAR63 {
function FUN13(
VAR19.Order memory VAR49,
uint256 VAR50,
bytes memory VAR51
)
public
returns (VAR9.FillResults memory VAR52);
function FUN14(
VAR19.Order memory VAR49,
uint256 VAR50,
bytes memory VAR51
)
public
returns (VAR9.FillResults memory VAR52);
function FUN15(
VAR19.VAR30[] memory VAR64,
uint256[] memory VAR65,
bytes[] memory VAR66
)
public
returns (VAR9.FillResults memory VAR67);
function FUN16(
VAR19.VAR30[] memory VAR64,
uint256[] memory VAR65,
bytes[] memory VAR66
)
public
returns (VAR9.FillResults memory VAR67);
function FUN17(
VAR19.VAR30[] memory VAR64,
uint256[] memory VAR65,
bytes[] memory VAR66
)
public
returns (VAR9.FillResults memory VAR67);
function FUN18(
VAR19.VAR30[] memory VAR64,
uint256 VAR50,
bytes[] memory VAR66
)
public
returns (VAR9.FillResults memory VAR67);
function FUN19(
VAR19.VAR30[] memory VAR64,
uint256 VAR50,
bytes[] memory VAR66
)
public
returns (VAR9.FillResults memory VAR67);
function FUN20(
VAR19.VAR30[] memory VAR64,
uint256 VAR68,
bytes[] memory VAR66
)
public
returns (VAR9.FillResults memory VAR67);
function FUN21(
VAR19.VAR30[] memory VAR64,
uint256 VAR68,
bytes[] memory VAR66
)
public
returns (VAR9.FillResults memory VAR67);
function FUN22(VAR19.VAR30[] memory VAR64)
public;
function FUN23(VAR19.VAR30[] memory VAR64)
public
view
returns (VAR19.VAR43[] VAR69);
}
contract IZrxExchange VAR70
VAR47,
VAR57,
VAR54,
VAR63
{}
library VAR71 {
function FUN24(address VAR72, uint value, bytes memory VAR73, uint VAR74, uint VAR75) internal returns(bool VAR76) {
VAR77 {
let VAR78 := FUN25(0x40)
let VAR79 := FUN26(VAR73, 32)
VAR76 := call(
FUN27(VAR80, 34710),
VAR72,
value,
FUN26(VAR79, VAR74),
VAR75,
VAR78,
0
)
}
}
}
interface VAR81 {
function FUN28() external view returns (uint256);
function FUN3(address VAR82) external view returns (uint256);
function transfer(address VAR83, uint256 VAR84) external returns (bool);
function FUN29(address VAR85, address VAR86) external view returns (uint256);
function FUN30(address VAR86, uint256 VAR84) external returns (bool);
function FUN31(address sender, address VAR83, uint256 VAR84) external returns (bool);
event Transfer(address indexed VAR5, address indexed VAR87, uint256 value);
event FUN32(address indexed VAR85, address indexed VAR86, uint256 value);
}
library VAR88 {
function FUN26(uint256 VAR89, uint256 VAR90) internal pure returns (uint256) {
uint256 VAR91 = VAR89 + VAR90;
require(VAR91 >= VAR89, "");
return VAR91;
}
function FUN27(uint256 VAR89, uint256 VAR90) internal pure returns (uint256) {
require(VAR90 <= VAR89, "");
uint256 VAR91 = VAR89 - VAR90;
return VAR91;
}
function FUN33(uint256 VAR89, uint256 VAR90) internal pure returns (uint256) {
if (VAR89 == 0) {
return 0;
}
uint256 VAR91 = VAR89 * VAR90;
require(VAR91 / VAR89 == VAR90, "");
return VAR91;
}
function FUN34(uint256 VAR89, uint256 VAR90) internal pure returns (uint256) {
require(VAR90 > 0, "");
uint256 VAR91 = VAR89 / VAR90;
return VAR91;
}
function FUN35(uint256 VAR89, uint256 VAR90) internal pure returns (uint256) {
require(VAR90 != 0, "");
return VAR89 % VAR90;
}
}
library VAR92 {
function FUN36(address VAR82) internal view returns (bool) {
uint256 VAR93;
VAR77 { VAR93 := FUN37(VAR82) }
return VAR93 > 0;
}
}
contract VAR94 {
address private VAR95;
event FUN38(address indexed VAR96, address indexed VAR97);
constructor () internal {
VAR95 = msg.sender;
emit FUN38(address(0), VAR95);
}
function FUN39() public view returns (address) {
return VAR95;
}
modifier onlyOwner() {
require(FUN40(), "");
VAR98;
}
function FUN40() public view returns (bool) {
return msg.sender == VAR95;
}
function FUN41() public onlyOwner {
emit FUN38(VAR95, address(0));
VAR95 = address(0);
}
function FUN42(address VAR97) public onlyOwner {
FUN43(VAR97);
}
function FUN43(address VAR97) internal {
require(VAR97 != address(0), "");
emit FUN38(VAR95, VAR97);
VAR95 = VAR97;
}
}
library VAR99 {
using SafeMath for uint256;
using Address for address;
function FUN44(IERC20 VAR100, address VAR87, uint256 value) internal {
FUN45(VAR100, VAR21.FUN46(VAR100.transfer.VAR101, VAR87, value));
}
function FUN47(IERC20 VAR100, address VAR5, address VAR87, uint256 value) internal {
FUN45(VAR100, VAR21.FUN46(VAR100.VAR102.VAR101, VAR5, VAR87, value));
}
function FUN48(IERC20 VAR100, address VAR86, uint256 value) internal {
require((value == 0) || (VAR100.FUN29(address(this), VAR86) == 0),
""
);
FUN45(VAR100, VAR21.FUN46(VAR100.VAR103.VAR101, VAR86, value));
}
function FUN49(IERC20 VAR100, address VAR86, uint256 value) internal {
uint256 VAR104 = VAR100.FUN29(address(this), VAR86).FUN26(value);
FUN45(VAR100, VAR21.FUN46(VAR100.VAR103.VAR101, VAR86, VAR104));
}
function FUN50(IERC20 VAR100, address VAR86, uint256 value) internal {
uint256 VAR104 = VAR100.FUN29(address(this), VAR86).FUN27(value);
FUN45(VAR100, VAR21.FUN46(VAR100.VAR103.VAR101, VAR86, VAR104));
}
function FUN45(IERC20 VAR100, bytes memory VAR73) private {
require(address(VAR100).FUN36(), "");
(bool VAR105, bytes memory VAR106) = address(VAR100).call(VAR73);
require(VAR105, "");
if (VAR106.VAR107 > 0) {
require(VAR21.FUN51(VAR106, (bool)), "");
}
}
}
contract IWETH is VAR81 {
function FUN52() external payable;
function FUN53(uint256 VAR84) external;
}
contract TokenSpender is VAR94 {
using SafeERC20 for VAR81;
function FUN54(IERC20 VAR100, address VAR6, address VAR108, uint256 VAR84) external onlyOwner {
VAR100.FUN47(VAR6, VAR108, VAR84);
}
}
contract VAR109 {
using SafeERC20 for VAR81;
using SafeMath for uint;
using ExternalCall for address;
address constant VAR110 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
TokenSpender public VAR86;
IGST2 VAR111;
address payable VAR85;
uint VAR112;
event FUN55(
IERC20 indexed VAR113,
address indexed VAR114,
uint256 VAR112
);
modifier onlyOwner {
require(
msg.sender == VAR85,
""
);
VAR98;
}
constructor(
address payable VAR95,
IGST2 VAR115,
uint VAR116
)
public
{
VAR86 = VAR117 FUN56();
VAR85 = VAR95;
VAR111 = VAR115;
VAR112 = VAR116;
}
function FUN57(uint VAR116) public onlyOwner {
require(VAR116 <= 20, "");
VAR112 = VAR116;
}
function FUN58(
IERC20 VAR118,
IERC20 VAR113,
uint VAR119,
address[] memory VAR120,
bytes memory VAR121,
uint[] memory VAR122,
uint[] memory VAR123,
uint VAR124,
uint VAR125,
address payable VAR114
)
public
payable
returns (uint VAR126)
{
VAR126 = FUN59();
uint VAR127 = VAR111.FUN3(address(this));
require(VAR120.VAR107 + 1 == VAR122.VAR107);
if (address(VAR118) != VAR110) {
VAR86.FUN54(VAR118, msg.sender, address(this), VAR119);
}
for (uint VAR128 = 0; VAR128 < VAR122.VAR107 - 1; VAR128++) {
if (VAR122[VAR128 + 1] - VAR122[VAR128] > 0) {
require(
VAR121[VAR122[VAR128] + 0] != VAR86.VAR129.VAR101[0] ||
VAR121[VAR122[VAR128] + 1] != VAR86.VAR129.VAR101[1] ||
VAR121[VAR122[VAR128] + 2] != VAR86.VAR129.VAR101[2] ||
VAR121[VAR122[VAR128] + 3] != VAR86.VAR129.VAR101[3]
);
require(VAR120[VAR128].FUN24(VAR123[VAR128], VAR121, VAR122[VAR128], VAR122[VAR128 + 1] - VAR122[VAR128]));
}
}
require(FUN60(VAR113, address(this)) >= VAR125);
//
require(VAR127 == VAR111.FUN3(address(this)));
if (VAR124 > 0) {
FUN61(VAR126, VAR124);
}
//
VAR126 = FUN60(VAR113, address(this)) * VAR112 / 10000;
if (VAR114 != address(0)) {
VAR126 /= 2;
if (!FUN62(VAR113, VAR114, VAR126, true)) {
VAR126 *= 2;
emit FUN55(VAR113, address(0), VAR126);
} else {
emit FUN55(VAR113, VAR114, VAR126 / 2);
}
}
FUN62(VAR113, VAR85, VAR126, false);
VAR126 = FUN60(VAR113, address(this));
FUN62(VAR113, msg.sender, VAR126, false);
}
function FUN63(IERC20 VAR100, address VAR87) external {
if (
address(VAR100) != VAR110 &&
VAR100.FUN29(address(this), VAR87) == 0
) {
VAR100.FUN48(VAR87, uint256(-1));
}
}
function FUN64(IWETH VAR100) external {
uint256 VAR84 = VAR100.FUN3(address(this));
VAR100.FUN53(VAR84);
}
function FUN18(
IERC20 VAR100,
IZrxExchange VAR130,
VAR19.VAR30[] calldata VAR64,
bytes[] calldata VAR66,
uint256 VAR131,
uint256 VAR132
)
external
{
uint256 VAR84 = VAR100.FUN3(address(this)).FUN33(VAR131).FUN34(VAR132);
VAR130.FUN18(VAR64, VAR84, VAR66);
}
function FUN60(IERC20 VAR100, address VAR6) internal view returns(uint256) {
if (address(VAR100) == VAR110 || VAR100 == FUN65(0)) {
return VAR6.VAR133;
} else {
return VAR100.FUN3(VAR6);
}
}
function FUN62(IERC20 VAR100, address payable VAR87, uint256 VAR84, bool VAR134) internal returns(bool) {
if (address(VAR100) == VAR110 || VAR100 == FUN65(0)) {
if (VAR134) {
return VAR87.FUN66(VAR84);
} else {
VAR87.transfer(VAR84);
return true;
}
} else {
VAR100.FUN44(VAR87, VAR84);
return true;
}
}
function FUN61(
uint VAR135,
uint VAR124
)
private
returns (uint VAR4)
{
uint VAR136 = 32254;
uint VAR137 = 36543;
uint VAR138 = 14154;
uint VAR139 = 6870;
uint VAR140 = 24000;
uint VAR119 = ((VAR135 - FUN59()) + VAR138) / (2 * VAR140 - VAR139);
uint VAR141 = VAR119 * VAR140;
uint VAR142 = VAR136 + (VAR119 * VAR137);
uint VAR143 = VAR138 + (VAR119 * VAR139);
uint VAR144 = (VAR141 * 100 * VAR145.VAR146) / (VAR142 * VAR124 + VAR143 * VAR145.VAR146);
if (VAR144 > 100) {
return FUN67(
VAR119
);
} else {
return 0;
}
}
function FUN67(
uint VAR119
)
private
returns (uint VAR4)
{
if (VAR119 > 0) {
uint VAR147 = 0;
uint VAR80 = FUN59();
if (VAR80 >= 27710) {
VAR147 = (VAR80 - 27710) / (1148 + 5722 + 150);
}
if (VAR119 > VAR147) {
VAR119 = VAR147;
}
uint VAR127 = FUN65(address(VAR111)).FUN3(address(this));
if (VAR119 > 0 && VAR127 >= VAR119) {
return VAR111.FUN1(VAR119);
} else {
return 0;
}
} else {
return 0;
}
}
function() external payable {
if (msg.value == 0 && msg.sender == VAR85) {
IERC20 VAR115 = FUN65(address(VAR111));
VAR85.transfer(address(this).VAR133);
VAR115.FUN44(VAR85, VAR115.FUN3(address(this)));
}
}
}
0
---------------------------------
37 0x00000000bbcf7700a1b403c9eb666f350707b900.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1() public view returns (address);
function() external payable {
address VAR3 = FUN1();
VAR4 {
let VAR5 := FUN2(0x40)
FUN3(VAR5, 0, VAR6)
let VAR7 := FUN4(VAR8, VAR3, VAR5, VAR6, 0, 0)
let VAR9 := VAR10
FUN5(VAR5, 0, VAR9)
switch VAR7
case 0 { revert(VAR5, VAR9) }
default { return(VAR5, VAR9) }
}
}
}
contract UpgradeabilityProxy is VAR2 {
event FUN6(address indexed VAR11);
bytes32 private constant VAR12 = 0xdc8e328a3c0acffa7969856957539d0f8c2deaa0d39abaf20397a9fa3b45bf17;
function FUN1() public view returns (address VAR13) {
bytes32 VAR14 = VAR12;
VAR4 {
VAR13 := FUN7(VAR14)
}
}
function FUN8(address VAR15) internal {
bytes32 VAR14 = VAR12;
VAR4 {
FUN9(VAR14, VAR15)
}
}
function FUN10(address VAR15) internal {
address VAR16 = FUN1();
require(VAR16 != VAR15);
FUN8(VAR15);
emit FUN6(VAR15);
}
}
contract TGBPController is VAR17 {
event FUN11(address indexed VAR18, address indexed VAR19);
event FUN12(address VAR20, address VAR21);
bytes32 private constant VAR22 = 0x58709042d6c9a2b64c8e7802bfedabdcd2eaecc68e15ef2e896a5970c608cd16;
bytes32 private constant VAR23 = 0xa6933dbb41d1bc3d681619c11234027db3b75954220aa88dfdc74750053ed30c;
constructor() public {
FUN13(msg.sender);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN14(), "");
VAR24;
}
modifier FUN15() {
require(msg.sender == FUN16(), "");
VAR24;
}
function FUN14() public view returns (address VAR25) {
bytes32 VAR14 = VAR22;
VAR4 {
VAR25 := FUN7(VAR14)
}
}
function FUN16() public view returns (address VAR21) {
bytes32 VAR14 = VAR23;
VAR4 {
VAR21 := FUN7(VAR14)
}
}
function FUN13(address VAR26) internal {
bytes32 VAR14 = VAR22;
VAR4 {
FUN9(VAR14, VAR26)
}
}
function FUN17(address VAR27) internal {
bytes32 VAR14 = VAR23;
VAR4 {
FUN9(VAR14, VAR27)
}
}
function FUN18(address VAR19) external onlyProxyOwner {
require(VAR19 != address(0));
FUN17(VAR19);
emit FUN12(FUN14(), VAR19);
}
function FUN19() external VAR28 {
emit FUN11(FUN14(), FUN16());
FUN13(FUN16());
FUN17(address(0));
}
function FUN20(address VAR11) external onlyProxyOwner {
FUN10(VAR11);
}
}
0
---------------------------------
38 0x00000000e82eb0431756271f0d00cfb143685e7b.sol
pragma solidity 0.5.6;
contract VAR1 {
event FUN1(address VAR2, address VAR3);
event FUN2(
address VAR2,
address VAR4
);
bytes private VAR5;
bytes32 private VAR6;
bytes private VAR7;
bytes32 private VAR8;
mapping(address => address) private VAR9;
mapping(address => bytes) private VAR10;
constructor(bytes memory VAR11) public {
VAR5 = (
VAR12""
);
VAR6 = FUN3(
VAR13.FUN4(
VAR5
)
);
VAR7 = VAR11;
VAR8 = FUN3(
VAR13.FUN4(
VAR7
)
);
}
function FUN5(
bytes32 VAR14,
bytes calldata VAR15,
bytes calldata VAR16
) external payable FUN6(VAR14) returns (
address VAR17
) {
bytes memory VAR18 = VAR15;
bytes memory VAR19 = VAR16;
bytes memory VAR20 = VAR5;
address VAR21;
VAR17 = FUN7(VAR14);
address VAR22;
VAR23 {
let VAR24 := FUN8(0x20, VAR18)
let VAR25 := FUN9(VAR18)
VAR22 := FUN10(
0,
VAR24,
VAR25
)
}
require(
VAR22 != address(0),
""
);
VAR9[VAR17] = VAR22;
VAR23 {
let VAR24 := FUN8(0x20, VAR20)
let VAR25 := FUN9(VAR20)
VAR21 := FUN11(
0,
VAR24,
VAR25,
VAR14
)
}
require(
VAR21 == VAR17,
""
);
if (VAR19.VAR26 > 0 || msg.value > 0) {
(bool VAR27,) = VAR21.call.value(msg.value)(VAR19);
require(VAR27, "");
}
emit FUN1(VAR21, VAR22);
}
function FUN12(
bytes32 VAR14,
address VAR22,
bytes calldata VAR16
) external payable FUN6(VAR14) returns (
address VAR17
) {
bytes memory VAR19 = VAR16;
bytes memory VAR20 = VAR5;
address VAR21;
VAR17 = FUN7(VAR14);
VAR9[VAR17] = VAR22;
VAR23 {
let VAR24 := FUN8(0x20, VAR20)
let VAR25 := FUN9(VAR20)
VAR21 := FUN11(
0,
VAR24,
VAR25,
VAR14
)
}
require(
VAR21 == VAR17,
""
);
if (VAR19.VAR26 > 0 || msg.value > 0) {
(bool VAR27,) = VAR17.call.value(msg.value)(VAR19);
require(VAR27, "");
}
emit FUN1(VAR21, VAR22);
}
function FUN13(
bytes32 VAR14,
bytes calldata VAR28
) external payable FUN6(VAR14) returns (
address VAR17
) {
bytes memory VAR20 = VAR7;
address VAR29;
address VAR30 = FUN14(VAR14);
VAR10[VAR30] = VAR28;
VAR23 {
let VAR24 := FUN8(0x20, VAR20)
let VAR25 := FUN9(VAR20)
VAR29 := FUN11(
VAR31,
VAR24,
VAR25,
VAR14
)
}
require(
VAR29 == VAR30,
""
);
VAR17 = FUN15(
VAR30
);
emit FUN2(
VAR17,
VAR30
);
}
function FUN16() external view returns (address VAR32) {
return VAR9[msg.sender];
}
function FUN17() external view returns (
bytes memory VAR28
) {
return VAR10[msg.sender];
}
function FUN18(
address VAR17
) external view returns (address VAR33) {
return VAR9[VAR17];
}
function FUN19(
address VAR30
) external view returns (bytes memory VAR28) {
return VAR10[VAR30];
}
function FUN20(
bytes32 VAR14
) external view returns (address VAR17) {
VAR17 = FUN7(VAR14);
}
function FUN21(
bytes32 VAR14
) external view returns (address VAR30) {
VAR30 = FUN14(VAR14);
}
function FUN22(
bytes32 VAR14
) external view returns (address VAR17) {
VAR17 = FUN15(
FUN14(VAR14)
);
}
function FUN23() external view returns (
bytes memory VAR34
) {
return VAR5;
}
function FUN24() external view returns (
bytes32 VAR35
) {
return VAR6;
}
function FUN25() external view returns (
bytes memory VAR11
) {
return VAR7;
}
function FUN26() external view returns (
bytes32 VAR36
) {
return VAR8;
}
function FUN7(
bytes32 VAR14
) internal view returns (address) {
return address(
FUN27(
uint256(
FUN3(
VAR13.FUN4(
VAR12"",
address(this),
VAR14,
VAR6
)
)
)
)
);
}
function FUN14(
bytes32 VAR14
) internal view returns (address) {
return address(
FUN27(
uint256(
FUN3(
VAR13.FUN4(
VAR12"",
address(this),
VAR14,
VAR8
)
)
)
)
);
}
function FUN15(
address VAR30
) internal pure returns (address) {
return address(
FUN27(
uint256(
FUN3(
VAR13.FUN4(
FUN28(0xd6),
FUN28(0x94),
VAR30,
FUN28(0x01)
)
)
)
)
);
}
modifier FUN6(bytes32 VAR14) {
require(
address(FUN29(VAR14)) == msg.sender,
""
);
VAR37;
}
}
0
---------------------------------
39 0x000000085824f23a070c2474442ed014c0e46b58.sol
pragma solidity 0.5.8;
//
//
library VAR1 {
function FUN1(uint VAR2, uint VAR3) internal pure returns (uint VAR4) { VAR4 = VAR2 + VAR3; require(VAR4 >= VAR2); }
function FUN2(uint VAR2, uint VAR3) internal pure returns (uint VAR4) { require(VAR3 <= VAR2); VAR4 = VAR2 - VAR3; }
function FUN3(uint VAR2, uint VAR3) internal pure returns (uint VAR4) { VAR4 = VAR2 * VAR3; require(VAR2 == 0 || VAR4 / VAR2 == VAR3); }
function FUN4(uint VAR2, uint VAR3) internal pure returns (uint VAR4) { require(VAR3 > 0); VAR4 = VAR2 / VAR3; }
}
contract VAR5 {
function FUN5() public view returns (uint);
function FUN6(address VAR6) public view returns (uint VAR7);
function FUN7(address VAR6, address VAR8) public view returns (uint VAR9);
function transfer(address VAR10, uint VAR11) public returns (bool VAR12);
function FUN8(address VAR8, uint VAR11) public returns (bool VAR12);
function FUN9(address VAR13, address VAR10, uint VAR11) public returns (bool VAR12);
event Transfer(address indexed VAR13, address indexed VAR10, uint VAR11);
event FUN10(address indexed VAR6, address indexed VAR8, uint VAR11);
}
contract VAR14 {
function FUN11(address VAR13, uint VAR11, address VAR15, bytes memory VAR16) public;
}
contract VAR17 {
address public VAR18;
address public VAR19;
event FUN12(address indexed VAR13, address indexed VAR10);
constructor() public {
VAR18 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR18);
VAR20;
}
function FUN13(address VAR21) public onlyOwner {
require(VAR21 != VAR19);
VAR19 = VAR21;
}
function FUN14() public {
require(msg.sender == VAR19);
emit FUN12(VAR18, VAR19);
VAR18 = VAR19;
VAR19 = address(0);
}
}
contract NRM is VAR5, VAR17 {
using SafeMath for uint;
bool public VAR22 = true;
string public VAR23;
string public VAR24;
uint8 public VAR25;
uint VAR26;
mapping(address => uint) VAR27;
mapping(address => mapping(address => uint)) VAR28;
address VAR29 = address(7);
uint VAR30;
uint VAR31 = 1580169600;
constructor() public {
VAR23 = "";
VAR24 = "";
VAR25 = 18;
VAR26 = 4958333333 * 10**uint(VAR25);
VAR27[VAR18] = VAR26;
emit Transfer(address(0), VAR18, VAR26);
VAR30 = VAR26.FUN3(30).FUN4(100);
VAR27[VAR18] = VAR27[VAR18].FUN2(VAR30);
VAR27[VAR29] = VAR27[VAR29].FUN1(VAR30);
emit Transfer(VAR18, VAR29, VAR30);
}
function FUN15(address VAR32) public onlyOwner returns (bool VAR12) {
require(VAR33 >= VAR31);
VAR27[VAR29] = VAR27[VAR29].FUN2(VAR30);
VAR27[VAR32] = VAR27[VAR32].FUN1(VAR30);
emit Transfer(VAR29, VAR32, VAR30);
return true;
}
modifier VAR34 {
require(VAR22);
VAR20;
}
function FUN16 () public onlyOwner returns (bool VAR12) {
if (VAR22) { VAR22 = false; } else { VAR22 = true; }
return true;
}
function FUN5() public view returns (uint) {
return VAR26;
}
function FUN6(address VAR6) public view returns (uint VAR7) {
return VAR27[VAR6];
}
function transfer(address VAR10, uint VAR11) public isRunning returns (bool VAR12) {
require(VAR11 <= VAR27[msg.sender]);
require(VAR10 != address(0));
VAR27[msg.sender] = VAR27[msg.sender].FUN2(VAR11);
VAR27[VAR10] = VAR27[VAR10].FUN1(VAR11);
emit Transfer(msg.sender, VAR10, VAR11);
return true;
}
//
function FUN8(address VAR8, uint VAR11) public isRunning returns (bool VAR12) {
FUN17(msg.sender, VAR8, VAR11);
return true;
}
function FUN18(address VAR8, uint VAR35) public isRunning returns (bool VAR12) {
FUN17(msg.sender, VAR8, VAR28[msg.sender][VAR8].FUN1(VAR35));
return true;
}
function FUN19(address VAR8, uint VAR36) public isRunning returns (bool VAR12) {
FUN17(msg.sender, VAR8, VAR28[msg.sender][VAR8].FUN2(VAR36));
return true;
}
function FUN20(address VAR8, uint VAR11, bytes memory VAR16) public isRunning returns (bool VAR12) {
FUN17(msg.sender, VAR8, VAR11);
FUN21(VAR8).FUN11(msg.sender, VAR11, address(this), VAR16);
return true;
}
function FUN17(address VAR18, address VAR8, uint256 value) internal {
require(VAR18 != address(0));
require(VAR8 != address(0));
VAR28[VAR18][VAR8] = value;
emit FUN10(VAR18, VAR8, value);
}
function FUN9(address VAR13, address VAR10, uint VAR11) public isRunning returns (bool VAR12) {
require(VAR10 != address(0));
VAR27[VAR13] = VAR27[VAR13].FUN2(VAR11);
FUN17(VAR13, msg.sender, VAR28[VAR13][msg.sender].FUN2(VAR11));
VAR27[VAR10] = VAR27[VAR10].FUN1(VAR11);
emit Transfer(VAR13, VAR10, VAR11);
return true;
}
function FUN7(address VAR6, address VAR8) public view returns (uint VAR9) {
return VAR28[VAR6][VAR8];
}
function FUN22(address VAR37, uint VAR11) public onlyOwner returns (bool VAR12) {
return FUN23(VAR37).transfer(VAR18, VAR11);
}
function FUN24(uint VAR11) public returns (bool VAR12) {
require(VAR11 <= VAR27[msg.sender]);
VAR27[msg.sender] = VAR27[msg.sender].FUN2(VAR11);
VAR26 = VAR26.FUN2(VAR11);
emit Transfer(msg.sender, address(0), VAR11);
return true;
}
function FUN25(address[] memory VAR10, uint[] memory VAR38) public onlyOwner returns (uint) {
require(VAR10.VAR39 == VAR38.VAR39);
require(VAR10.VAR39 < 100);
uint VAR40;
for (uint VAR41; VAR41 < VAR38.VAR39; VAR41++) {
VAR40 += VAR38[VAR41];
}
VAR27[VAR18] = VAR27[VAR18].FUN2(VAR40);
for (uint VAR42; VAR42 < VAR10.VAR39; VAR42++) {
VAR27[VAR10[VAR42]] = VAR27[VAR10[VAR42]].FUN1(VAR38[VAR42]);
emit Transfer(VAR18, VAR10[VAR42], VAR38[VAR42]);
}
return(VAR10.VAR39);
}
}
0
---------------------------------
40 0x0000000fdf9eb269b38e39e058f45d7d0ddb60f9.sol
pragma VAR1 ^0.5.6;
contract VAR2 {
address private VAR3;
event FUN1(address indexed VAR4, address indexed VAR5);
constructor () internal {
VAR3 = msg.sender;
emit FUN1(address(0), VAR3);
}
function FUN2() public view returns (address) {
return VAR3;
}
modifier onlyOwner() {
require(FUN3());
VAR6;
}
function FUN3() public view returns (bool) {
return msg.sender == VAR3;
}
function FUN4() public onlyOwner {
emit FUN1(VAR3, address(0));
VAR3 = address(0);
}
function FUN5(address VAR5) public onlyOwner {
FUN6(VAR5);
}
function FUN6(address VAR5) internal {
require(VAR5 != address(0));
emit FUN1(VAR3, VAR5);
VAR3 = VAR5;
}
}
pragma VAR1 ^0.5.6;
library VAR7 {
struct VAR8 {
mapping (address => bool) VAR9;
}
function FUN7(Role storage VAR10, address VAR11) internal {
require(VAR11 != address(0));
require(!FUN8(VAR10, VAR11));
VAR10.VAR9[VAR11] = true;
}
function FUN9(Role storage VAR10, address VAR11) internal {
require(VAR11 != address(0));
require(FUN8(VAR10, VAR11));
VAR10.VAR9[VAR11] = false;
}
function FUN8(Role storage VAR10, address VAR11) internal view returns (bool) {
require(VAR11 != address(0));
return VAR10.VAR9[VAR11];
}
}
pragma VAR1 ^0.5.6;
contract VAR12 {
using Roles for VAR7.VAR8;
event FUN10(address indexed VAR11);
event FUN11(address indexed VAR11);
VAR7.Role private VAR13;
constructor () internal {
FUN12(msg.sender);
}
modifier FUN13() {
require(FUN14(msg.sender));
VAR6;
}
function FUN14(address VAR11) public view returns (bool) {
return VAR13.FUN8(VAR11);
}
function FUN15(address VAR11) public VAR14 {
FUN12(VAR11);
}
function FUN16() public {
FUN17(msg.sender);
}
function FUN12(address VAR11) internal {
VAR13.FUN7(VAR11);
emit FUN10(VAR11);
}
function FUN17(address VAR11) internal {
VAR13.FUN9(VAR11);
emit FUN11(VAR11);
}
}
pragma VAR1 ^0.5.6;
contract WhitelistedRole is VAR12 {
using Roles for VAR7.VAR8;
event FUN18(address indexed VAR11);
event FUN19(address indexed VAR11);
VAR7.Role private VAR15;
modifier FUN20() {
require(FUN21(msg.sender));
VAR6;
}
function FUN21(address VAR11) public view returns (bool) {
return VAR15.FUN8(VAR11);
}
function FUN22(address VAR11) public VAR14 {
FUN23(VAR11);
}
function FUN24(address VAR11) public VAR14 {
FUN25(VAR11);
}
function FUN26() public {
FUN25(msg.sender);
}
function FUN23(address VAR11) internal {
VAR15.FUN7(VAR11);
emit FUN18(VAR11);
}
function FUN25(address VAR11) internal {
VAR15.FUN9(VAR11);
emit FUN19(VAR11);
}
}
pragma VAR1 ^0.5.6;
contract InvictusWhitelist is VAR2, VAR16 {
constructor ()
FUN27() public {
}
function FUN28(address VAR17) public VAR14 {
if (!FUN21(VAR17)) {
FUN22(VAR17);
}
}
function FUN29(address VAR11) public onlyOwner {
require(VAR11 != msg.sender, "");
FUN17(VAR11);
}
}
0
---------------------------------
41 0x000000eade0fe9269d0412a6055b6f3c5d968488.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
function FUN1(address VAR3) public;
function FUN2() public;
function FUN3() public returns(address);
function FUN4() public returns(address);
function FUN5() public returns(uint);
function FUN6(address VAR4) external;
}
contract VAR5 {
function FUN7(uint VAR6) public;
function FUN6(address VAR4) public;
function FUN2() public;
}
contract VAR7 {
function FUN2() external;
function FUN8(address VAR8, address VAR4) external;
function FUN9(address VAR8) external;
function FUN10(address VAR8) external;
function FUN11(address VAR9) external;
function FUN12(address VAR10) external;
function FUN13(address VAR11,
address VAR12,
address VAR13) external;
function FUN14(address VAR14) external;
function FUN6(address VAR4) external;
function FUN15() external returns(address);
}
contract VAR15 {
OldTrueUSDInterface public constant VAR16 = FUN16(0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E);
NewTrueUSDInterface public constant VAR17 = FUN17(0x0000000000085d4780B73119b644AE5ecd22b376);
TokenControllerInterface public constant VAR18 = FUN18(0x0000000000075EfBeE23fe2de1bd0b7690883cc9);
address public constant VAR19 = address(0x0000000000013949F288172bD7E36837bDdC7211);
address public constant VAR20 = address(0x0000000000027f6D87be8Ade118d9ee56767d993);
function FUN19() public {
address VAR21 = VAR18.FUN15();
VAR18.FUN2();
VAR17.FUN2();
VAR17.FUN7(VAR16.FUN5());
address VAR22 = VAR16.FUN3();
address VAR23 = VAR16.FUN4();
VAR18.FUN9(VAR22);
VAR18.FUN9(VAR23);
VAR18.FUN10(VAR22);
VAR18.FUN10(VAR23);
VAR18.FUN8(VAR22, VAR17);
VAR18.FUN8(VAR23, VAR17);
VAR17.FUN6(VAR18);
VAR18.FUN10(VAR17);
VAR18.FUN11(VAR17);
VAR18.FUN13(VAR17, VAR22, VAR23);
VAR18.FUN12(VAR19);
VAR18.FUN14(VAR20);
VAR18.FUN8(VAR16, address(this));
VAR16.FUN2();
VAR16.FUN1(VAR17);
VAR16.FUN6(VAR18);
VAR18.FUN10(VAR16);
VAR18.FUN6(VAR21);
}
}
0
---------------------------------
42 0x00000100f2a2bd000715001920eb70d229700085.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
event FUN1(address indexed VAR3, address indexed VAR4);
event FUN2(address VAR5, address VAR6);
bytes32 private constant VAR7 = 0x136d55780fb1583e87bb6fa1fda0bbe2746553b012c9291a830fad1e95c269cc;
bytes32 private constant VAR8 = 0xca6c24188764c50fa5c7b728d85fdd98bea1991968b9f4bd4000ae3ace49faac;
constructor() public {
FUN3(msg.sender);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN4(), "");
VAR9;
}
modifier FUN5() {
require(msg.sender == FUN6(), "");
VAR9;
}
function FUN4() public view returns (address VAR10) {
bytes32 VAR11 = VAR7;
VAR12 {
VAR10 := FUN7(VAR11)
}
}
function FUN6() public view returns (address VAR6) {
bytes32 VAR11 = VAR8;
VAR12 {
VAR6 := FUN7(VAR11)
}
}
function FUN3(address VAR13) internal {
bytes32 VAR11 = VAR7;
VAR12 {
FUN8(VAR11, VAR13)
}
}
function FUN9(address VAR14) internal {
bytes32 VAR11 = VAR8;
VAR12 {
FUN8(VAR11, VAR14)
}
}
function FUN10(address VAR4) external onlyProxyOwner {
require(VAR4 != address(0));
FUN9(VAR4);
emit FUN2(FUN4(), VAR4);
}
function FUN11() external VAR15 {
emit FUN1(FUN4(), FUN6());
FUN3(FUN6());
FUN9(address(0));
}
function FUN12(address VAR16) external onlyProxyOwner {
address VAR17;
bytes32 VAR11 = VAR18;
VAR12 {
VAR17 := FUN7(VAR11)
}
require(VAR17 != VAR16);
VAR12 {
FUN8(VAR11, VAR16)
}
emit FUN13(VAR16);
}
event FUN13(address indexed VAR16);
bytes32 private constant VAR18 = 0xecfd2ee7a4295d533a08882dec6729582fc6bda7812f32b75ae1ea4807d08982;
function FUN14() public view returns (address VAR19) {
bytes32 VAR11 = VAR18;
VAR12 {
VAR19 := FUN7(VAR11)
}
}
function() external payable {
VAR12 {
let VAR20 := FUN15(0x40)
FUN16(VAR20, VAR21, VAR22)
let VAR23 := FUN17(VAR24, FUN7(0xecfd2ee7a4295d533a08882dec6729582fc6bda7812f32b75ae1ea4807d08982), VAR20, VAR22, VAR21, VAR21)
FUN18(VAR20, 0, VAR21)
switch VAR23
case 0 { revert(VAR20, VAR21) }
default { return(VAR20, VAR21) }
}
}
}
0
---------------------------------
43 0x000003ed2eb44cded8ade31c01dda60da466b2d1.sol
pragma VAR1 "";
contract VAR2 {
string public VAR3;
string public VAR4;
uint8 public VAR5;
function FUN1(address, uint256) public returns (bool VAR6);
function FUN2(address, address) constant public returns (uint256 VAR7);
function FUN3(address) constant public returns (uint256 VAR8);
function FUN4() constant public returns (uint256 VAR9);
function transfer(address, uint256) public returns (bool VAR6);
function FUN5(address, address, uint256) public returns (bool VAR6);
}
contract Erc20Test is VAR2 {
string public VAR3;
string public VAR4;
uint8 public VAR5;
function FUN6(string VAR10, string VAR11, uint8 VAR12) public {
VAR3 = VAR10;
VAR4 = VAR11;
VAR5 = VAR12;
}
function FUN1(address, uint256) public returns (bool) {return true;}
function FUN2(address, address) constant public returns (uint256) {return 42;}
function FUN3(address) constant public returns (uint256) {return 42;}
function FUN4() constant public returns (uint256) {return 42;}
function transfer(address, uint256) public returns (bool) {return true;}
function FUN5(address, address, uint256) public returns (bool) {return true;}
}
contract VAR13 {
bool                                private VAR14 = false;
bool                                private VAR15 = false;
address                             public VAR16;
mapping(address => bool)            public VAR17;
function FUN7() public {
VAR16 = msg.sender;
}
modifier FUN8() {
require(VAR16 == msg.sender);
VAR18;
}
modifier FUN9() {
require(VAR17[msg.sender] || VAR15);
require(!VAR14);
VAR18;
}
function FUN10(address VAR19) ownership public {
if (VAR19 != address(0)) {
VAR17[VAR19] = true;
}
}
function FUN11(address VAR19) ownership public {
if (VAR19 != address(0)) {
VAR17[VAR19] = false;
}
}
function FUN12(address VAR19) ownership public {
if (VAR19 != address(0)) {
VAR16 = VAR19;
}
}
function FUN13() ownership public {
VAR14 = !VAR14;
}
function FUN14() ownership public {
VAR15 = !VAR15;
}
}
contract Erc20SummaryStorage is VAR13 {
address[]                           public VAR20;
mapping(address => bool)            public VAR21;
mapping(bytes32 => uint256)         public VAR22;
mapping(bytes32 => string)          public VAR23;
mapping(bytes32 => address)         public VAR24;
mapping(bytes32 => bytes)           public VAR25;
mapping(bytes32 => bool)            public VAR26;
mapping(bytes32 => VAR27)          public VAR28;
function FUN15(uint VAR29) external view returns (address) {
return VAR20[VAR29];
}
function FUN16() external view returns (uint) {
return VAR20.VAR30;
}
function FUN17(address VAR31) accessible external {
require(VAR31 != address(0));
require(!VAR21[VAR31]);
VAR21[VAR31] = true;
VAR20.FUN18(VAR31);
}
function FUN19(address VAR31) accessible external {
uint256 VAR32 = VAR20.VAR30;
uint256 VAR33 = 0;
while(VAR32 > VAR33) {
if(VAR20[VAR33] == VAR31) {
while(VAR20[VAR32 - 1] == VAR31) {
VAR32 = VAR32 - 1;
if(VAR32 == 0) break;
}
if(VAR32 > VAR33) {
VAR20[VAR33] = VAR20[VAR32 - 1];
VAR32 = VAR32 - 1;
}
}
VAR33 = VAR33 + 1;
}
VAR20.VAR30 = VAR32;
VAR21[VAR31] = false;
}
function FUN20(bytes32 VAR34) external view returns (address) {
return VAR24[VAR34];
}
function FUN21(bytes32 VAR34) external view returns (uint) {
return VAR22[VAR34];
}
function FUN22(bytes32 VAR34) external view returns (string) {
return VAR23[VAR34];
}
function FUN23(bytes32 VAR34) external view returns (bytes) {
return VAR25[VAR34];
}
function FUN24(bytes32 VAR34) external view returns (bool) {
return VAR26[VAR34];
}
function FUN25(bytes32 VAR34) external view returns (int) {
return VAR28[VAR34];
}
function FUN26(bytes32 VAR34, address VAR35) accessible external {
VAR24[VAR34] = VAR35;
}
function FUN27(bytes32 VAR34, uint VAR35) accessible external {
VAR22[VAR34] = VAR35;
}
function FUN28(bytes32 VAR34, string VAR35) accessible external {
VAR23[VAR34] = VAR35;
}
function FUN29(bytes32 VAR34, bytes VAR35) accessible external {
VAR25[VAR34] = VAR35;
}
function FUN30(bytes32 VAR34, bool VAR35) accessible external {
VAR26[VAR34] = VAR35;
}
function FUN31(bytes32 VAR34, int VAR35) accessible external {
VAR28[VAR34] = VAR35;
}
function FUN32(bytes32 VAR34) accessible external {
delete VAR24[VAR34];
}
function FUN33(bytes32 VAR34) accessible external {
delete VAR22[VAR34];
}
function FUN34(bytes32 VAR34) accessible external {
delete VAR23[VAR34];
}
function FUN35(bytes32 VAR34) accessible external {
delete VAR25[VAR34];
}
function FUN36(bytes32 VAR34) accessible external {
delete VAR26[VAR34];
}
function FUN37(bytes32 VAR34) accessible external {
delete VAR28[VAR34];
}
}
contract Erc20SummaryLogic is VAR13 {
Erc20SummaryStorage VAR36;
function FUN38(address VAR37) public {
VAR36 = FUN39(VAR37);
}
function FUN40(address VAR31) accessible public {
Erc20 VAR38 = FUN41(VAR31);
VAR38.FUN42();
VAR38.FUN43();
VAR38.FUN44();
VAR38.FUN4();
VAR38.FUN3(0x281055Afc982d96fAB65b3a49cAc8b878184Cb16);
VAR36.FUN17(VAR31);
}
function FUN45(address[] VAR39) accessible external {
for(uint VAR40 = 0; VAR40 < VAR39.VAR30; VAR40++) {
FUN40(VAR39[VAR40]);
}
}
function FUN46(address VAR31) accessible external {
VAR36.FUN19(VAR31);
}
function FUN47(address VAR41) external view returns (address[], uint[], uint8[]) {
uint VAR42 = VAR36.FUN16();
address[] memory VAR43 = new address[](VAR42);
uint[] memory VAR44 = new uint[](VAR42);
uint8[] memory VAR5 = new uint8[](VAR42);
address VAR45;
Erc20 VAR46;
for (uint VAR40 = 0; VAR40 < VAR42; VAR40++) {
VAR45 = VAR36.FUN15(VAR40);
VAR46 = FUN41(VAR45);
VAR43[VAR40] = VAR45;
VAR44[VAR40] = VAR46.FUN3(VAR41);
VAR5[VAR40] = VAR46.FUN44();
}
return (VAR43, VAR44, VAR5);
}
}
0
---------------------------------
44 0x0000610024bae4de00eb00ee7ee8321e4cc900b9.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
event FUN1(address indexed VAR3, address indexed VAR4);
event FUN2(address VAR5, address VAR6);
bytes32 private constant VAR7 = 0x9afdba48695f976525206667656e0eb4a6d66671c0d3ec078f1f48d2307ed49c;
bytes32 private constant VAR8 = 0x7b9044cf1491ee5d1e688907e48d0439248c6543a740f2f5f828fecf8367c4d1;
constructor() public {
FUN3(msg.sender);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN4(), "");
VAR9;
}
modifier FUN5() {
require(msg.sender == FUN6(), "");
VAR9;
}
function FUN4() public view returns (address VAR10) {
bytes32 VAR11 = VAR7;
VAR12 {
VAR10 := FUN7(VAR11)
}
}
function FUN6() public view returns (address VAR6) {
bytes32 VAR11 = VAR8;
VAR12 {
VAR6 := FUN7(VAR11)
}
}
function FUN3(address VAR13) internal {
bytes32 VAR11 = VAR7;
VAR12 {
FUN8(VAR11, VAR13)
}
}
function FUN9(address VAR14) internal {
bytes32 VAR11 = VAR8;
VAR12 {
FUN8(VAR11, VAR14)
}
}
function FUN10(address VAR4) external onlyProxyOwner {
require(VAR4 != address(0));
FUN9(VAR4);
emit FUN2(FUN4(), VAR4);
}
function FUN11() external VAR15 {
emit FUN1(FUN4(), FUN6());
FUN3(FUN6());
FUN9(address(0));
}
function FUN12(address VAR16) external onlyProxyOwner {
address VAR17;
bytes32 VAR11 = VAR18;
VAR12 {
VAR17 := FUN7(VAR11)
}
require(VAR17 != VAR16);
VAR12 {
FUN8(VAR11, VAR16)
}
emit FUN13(VAR16);
}
event FUN13(address indexed VAR16);
bytes32 private constant VAR18 = 0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb;
function FUN14() public returns (address VAR19) {
bytes32 VAR11 = VAR18;
VAR12 {
VAR19 := FUN7(VAR11)
}
}
function() external payable {
VAR12 {
let VAR20 := FUN15(0x40)
FUN16(VAR20, VAR21, VAR22)
let VAR23 := FUN17(VAR24, FUN7(0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb), VAR20, VAR22, VAR21, VAR21)
FUN18(VAR20, 0, VAR21)
switch VAR23
case 0 { revert(VAR20, VAR21) }
default { return(VAR20, VAR21) }
}
}
}
0
---------------------------------
45 0x00006100f7090010005f1bd7ae6122c3c2cf0090.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
event FUN1(address indexed VAR3, address indexed VAR4);
event FUN2(address VAR5, address VAR6);
bytes32 private constant VAR7 = 0x9afdba48695f976525206667656e0eb4a6d66671c0d3ec078f1f48d2307ed49c;
bytes32 private constant VAR8 = 0x7b9044cf1491ee5d1e688907e48d0439248c6543a740f2f5f828fecf8367c4d1;
constructor() public {
FUN3(msg.sender);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN4(), "");
VAR9;
}
modifier FUN5() {
require(msg.sender == FUN6(), "");
VAR9;
}
function FUN4() public view returns (address VAR10) {
bytes32 VAR11 = VAR7;
VAR12 {
VAR10 := FUN7(VAR11)
}
}
function FUN6() public view returns (address VAR6) {
bytes32 VAR11 = VAR8;
VAR12 {
VAR6 := FUN7(VAR11)
}
}
function FUN3(address VAR13) internal {
bytes32 VAR11 = VAR7;
VAR12 {
FUN8(VAR11, VAR13)
}
}
function FUN9(address VAR14) internal {
bytes32 VAR11 = VAR8;
VAR12 {
FUN8(VAR11, VAR14)
}
}
function FUN10(address VAR4) external onlyProxyOwner {
require(VAR4 != address(0));
FUN9(VAR4);
emit FUN2(FUN4(), VAR4);
}
function FUN11() external VAR15 {
emit FUN1(FUN4(), FUN6());
FUN3(FUN6());
FUN9(address(0));
}
function FUN12(address VAR16) external onlyProxyOwner {
address VAR17;
bytes32 VAR11 = VAR18;
VAR12 {
VAR17 := FUN7(VAR11)
}
require(VAR17 != VAR16);
VAR12 {
FUN8(VAR11, VAR16)
}
emit FUN13(VAR16);
}
event FUN13(address indexed VAR16);
bytes32 private constant VAR18 = 0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb;
function FUN14() public view returns (address VAR19) {
bytes32 VAR11 = VAR18;
VAR12 {
VAR19 := FUN7(VAR11)
}
}
function() external payable {
VAR12 {
let VAR20 := FUN15(0x40)
FUN16(VAR20, VAR21, VAR22)
let VAR23 := FUN17(VAR24, FUN7(0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb), VAR20, VAR22, VAR21, VAR21)
FUN18(VAR20, 0, VAR21)
switch VAR23
case 0 { revert(VAR20, VAR21) }
default { return(VAR20, VAR21) }
}
}
}
0
---------------------------------
46 0x0000852600ceb001e08e00bc008be620d60031f2.sol
pragma VAR1 ^0.4.23;
contract VAR2 {
event FUN1(address indexed VAR3, address indexed VAR4);
event FUN2(address VAR5, address VAR6);
bytes32 private constant VAR7 = 0x694c83c02d0f62c26352cb2d947e2f3d43c28959df09aa728c1937be0db4f629;
bytes32 private constant VAR8 = 0x6dd3140f324ae1c14ee501ef56b899935ef394e2a1b2a0e41ec6b40fd725799c;
constructor() public {
FUN3(msg.sender);
}
modifier onlyProxyOwner() {
require(msg.sender == FUN4(), "");
VAR9;
}
modifier FUN5() {
require(msg.sender == FUN6(), "");
VAR9;
}
function FUN4() public view returns (address VAR10) {
bytes32 VAR11 = VAR7;
VAR12 {
VAR10 := FUN7(VAR11)
}
}
function FUN6() public view returns (address VAR6) {
bytes32 VAR11 = VAR8;
VAR12 {
VAR6 := FUN7(VAR11)
}
}
function FUN3(address VAR13) internal {
bytes32 VAR11 = VAR7;
VAR12 {
FUN8(VAR11, VAR13)
}
}
function FUN9(address VAR14) internal {
bytes32 VAR11 = VAR8;
VAR12 {
FUN8(VAR11, VAR14)
}
}
function FUN10(address VAR4) external onlyProxyOwner {
require(VAR4 != address(0));
FUN9(VAR4);
emit FUN2(FUN4(), VAR4);
}
function FUN11() external VAR15 {
emit FUN1(FUN4(), FUN6());
FUN3(FUN6());
FUN9(address(0));
}
function FUN12(address VAR16) external onlyProxyOwner {
address VAR17;
bytes32 VAR11 = VAR18;
VAR12 {
VAR17 := FUN7(VAR11)
}
require(VAR17 != VAR16);
VAR12 {
FUN8(VAR11, VAR16)
}
emit FUN13(VAR16);
}
event FUN13(address indexed VAR16);
bytes32 private constant VAR18 = 0x3e9d19baa8ecfb799f8603bb69f8a220a1c51ff5c34c24b0d981ca8973276561;
function FUN14() public view returns (address VAR19) {
bytes32 VAR11 = VAR18;
VAR12 {
VAR19 := FUN7(VAR11)
}
}
function() external payable {
bytes32 VAR11 = VAR18;
VAR12 {
let VAR20 := FUN15(0x40)
FUN16(VAR20, VAR21, VAR22)
let VAR23 := FUN17(VAR24, FUN7(VAR11), VAR20, VAR22, VAR21, VAR21)
FUN18(VAR20, 0, VAR21)
switch VAR23
case 0 { revert(VAR20, VAR21) }
default { return(VAR20, VAR21) }
}
}
}
0
---------------------------------
47 0x00016fab0fa144ca8c1f7ec4cf72e70e52359005.sol
pragma VAR1 ^0.5.0;
library VAR2 {
function FUN1(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 + VAR4;
require(VAR5 >= VAR3);
}
function FUN2(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 <= VAR3);
VAR5 = VAR3 - VAR4;
}
function FUN3(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
VAR5 = VAR3 * VAR4;
require(VAR3 == 0 || VAR5 / VAR3 == VAR4);
}
function FUN4(uint VAR3, uint VAR4) internal pure returns (uint VAR5) {
require(VAR4 > 0);
VAR5 = VAR3 / VAR4;
}
}
contract VAR6 {
function FUN5() public view returns (uint);
function FUN6(address VAR7) public view returns (uint VAR8);
function FUN7(address VAR7, address VAR9) public view returns (uint VAR10);
function transfer(address VAR11, uint VAR12) public returns (bool VAR13);
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13);
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13);
event Transfer(address indexed VAR14, address indexed VAR11, uint VAR12);
event FUN10(address indexed VAR7, address indexed VAR9, uint VAR12);
}
//
contract VAR15 {
function FUN11(address VAR14, uint256 VAR12, address VAR16, bytes memory VAR17) public;
}
contract VAR18 {
address public VAR19;
address public VAR20;
event FUN12(address indexed VAR21, address indexed VAR22);
constructor() public {
VAR19 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR19);
VAR23;
}
function FUN13(address VAR24) public onlyOwner {
VAR20 = VAR24;
}
function FUN14() public {
require(msg.sender == VAR20);
emit FUN12(VAR19, VAR20);
VAR19 = VAR20;
VAR20 = address(0);
}
}
contract last is VAR6, VAR18 {
using SafeMath for uint;
string public VAR25;
string public  VAR26;
uint8 public VAR27;
uint VAR28;
mapping(address => uint) VAR29;
mapping(address => mapping(address => uint)) VAR30;
constructor() public {
VAR25 = "";
VAR26 = "";
VAR27 = 1;
VAR28 = 42000000 * 10**uint(VAR27);
VAR29[VAR19] = VAR28;
emit Transfer(address(0), VAR19, VAR28);
}
function FUN5() public view returns (uint) {
return VAR28.FUN2(VAR29[address(0)]);
}
function FUN6(address VAR7) public view returns (uint VAR8) {
return VAR29[VAR7];
}
function transfer(address VAR11, uint VAR12) public returns (bool VAR13) {
VAR29[msg.sender] = VAR29[msg.sender].FUN2(VAR12);
VAR29[VAR11] = VAR29[VAR11].FUN1(VAR12);
emit Transfer(msg.sender, VAR11, VAR12);
return true;
}
//
function FUN8(address VAR9, uint VAR12) public returns (bool VAR13) {
VAR30[msg.sender][VAR9] = VAR12;
emit FUN10(msg.sender, VAR9, VAR12);
return true;
}
//
function FUN9(address VAR14, address VAR11, uint VAR12) public returns (bool VAR13) {
VAR29[VAR14] = VAR29[VAR14].FUN2(VAR12);
VAR30[VAR14][msg.sender] = VAR30[VAR14][msg.sender].FUN2(VAR12);
VAR29[VAR11] = VAR29[VAR11].FUN1(VAR12);
emit Transfer(VAR14, VAR11, VAR12);
return true;
}
function FUN7(address VAR7, address VAR9) public view returns (uint VAR10) {
return VAR30[VAR7][VAR9];
}
function FUN15(address VAR9, uint VAR12, bytes memory VAR17) public returns (bool VAR13) {
VAR30[msg.sender][VAR9] = VAR12;
emit FUN10(msg.sender, VAR9, VAR12);
FUN16(VAR9).FUN11(msg.sender, VAR12, address(this), VAR17);
return true;
}
function () external payable {
revert();
}
function FUN17(address VAR31, uint VAR12) public onlyOwner returns (bool VAR13) {
return FUN18(VAR31).transfer(VAR19, VAR12);
}
}
0
---------------------------------
48 0x000983ba1a675327f0940b56c2d49cd9c042dfbf.sol
pragma solidity 0.4.24;
contract VAR1 {
event FUN1();
event FUN2();
address public VAR2;
bool public VAR3 = false;
constructor() public {
VAR2 = msg.sender;
}
function FUN3(address VAR4) public onlyGovernor {
VAR2 = VAR4;
}
modifier onlyGovernor {
require(msg.sender == VAR2);
VAR5;
}
modifier FUN4() {
require(!VAR3);
VAR5;
}
modifier FUN5() {
require(VAR3);
VAR5;
}
function FUN6() onlyGovernor whenNotPaused public {
VAR3 = true;
emit FUN1();
}
function FUN7() onlyGovernor whenPaused public {
VAR3 = false;
emit FUN2();
}
}
contract CardBase is VAR1 {
struct VAR6 {
uint16 VAR7;
uint16 VAR8;
}
function FUN8(uint VAR9) public view returns (uint16 VAR7, uint16 VAR8) {
Card memory VAR10 = VAR11[VAR9];
return (VAR10.VAR7, VAR10.VAR8);
}
function FUN9(uint16 VAR8) public pure returns (uint8) {
return uint8(VAR8 / 1000);
}
VAR6[] public VAR11;
}
contract CardProto is VAR12 {
event FUN10(
uint16 VAR9, uint8 VAR13, uint8 VAR14,
Rarity VAR15, uint8 VAR16, uint8 VAR17,
uint8 VAR18, uint8 VAR19, uint8 VAR20, bool VAR21
);
struct VAR22 {
uint64 VAR23;
bool VAR24;
}
mapping(uint16 => VAR22) public VAR25;
function FUN11(uint16 VAR9, uint64 VAR23) public onlyGovernor {
Limit memory VAR26 = VAR25[VAR9];
require(!VAR26.VAR24);
VAR25[VAR9] = FUN12({
VAR23: VAR23,
VAR24: true
});
}
function FUN13(uint16 VAR9) public view returns (uint64 VAR23, bool VAR27) {
Limit memory VAR26 = VAR25[VAR9];
return (VAR26.VAR23, VAR26.VAR24);
}
mapping(uint8 => bool) public VAR28;
mapping(uint8 => bool) public VAR29;
uint8 public VAR30;
function FUN14(uint8 VAR13) public onlyGovernor {
VAR28[VAR13] = true;
}
function FUN15(uint8 VAR13) public onlyGovernor {
require(!VAR29[VAR13]);
VAR28[VAR13] = false;
}
function FUN16(uint8 VAR13) public onlyGovernor {
require(VAR28[VAR13]);
VAR29[VAR13] = true;
}
function FUN17(uint16 VAR7) public view returns (bool) {
return VAR28[VAR31[VAR7].VAR13];
}
function FUN18() public onlyGovernor {
require(VAR30 <= 255);
VAR30++;
VAR32.VAR33 = 0;
VAR34.VAR33 = 0;
VAR35.VAR33 = 0;
VAR36.VAR33 = 0;
VAR37.VAR33 = 0;
}
enum VAR38 {
VAR39,
VAR40,
VAR41,
VAR42,
VAR43
}
uint8 constant VAR44 = 1;
uint8 constant VAR45 = 2;
uint8 constant VAR46 = 3;
uint8 constant VAR47 = 4;
struct VAR48 {
bool VAR24;
uint8 VAR14;
uint8 VAR13;
uint8 VAR19;
Rarity VAR15;
uint8 VAR16;
uint8 VAR17;
uint8 VAR18;
uint8 VAR20;
}
uint16 public VAR49;
mapping(uint16 => VAR48) VAR31;
uint16[] public VAR32;
uint16[] public VAR34;
uint16[] public VAR35;
uint16[] public VAR36;
uint16[] public VAR37;
function FUN19(
uint16[] VAR50, uint8[] VAR51, VAR38[] VAR52, uint8[] VAR53, uint8[] VAR54, uint8[] VAR55, uint8[] VAR56, uint8[] VAR57, bool[] VAR21
) public onlyGovernor returns(uint16) {
for (uint VAR58 = 0; VAR58 < VAR50.VAR33; VAR58++) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR51[VAR58],
VAR13: VAR30,
VAR19: VAR56[VAR58],
VAR15: VAR52[VAR58],
VAR16: VAR53[VAR58],
VAR17: VAR54[VAR58],
VAR18: VAR55[VAR58],
VAR20: VAR57[VAR58]
});
FUN21(VAR50[VAR58], VAR10, VAR21[VAR58]);
}
}
function FUN22(
uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR19, uint8 VAR20, bool VAR21
) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR19,
VAR15: VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR18,
VAR20: VAR20
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN23(
uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR60, bool VAR21
) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR46,
VAR15: VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR60,
VAR20: 0
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN24(uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, bool VAR21) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR44,
VAR15: VAR15,
VAR16: VAR16,
VAR17: 0,
VAR18: 0,
VAR20: 0
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN25(
uint16 VAR59, uint8 VAR14, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR20, bool VAR21
) public onlyGovernor returns(uint16) {
ProtoCard memory VAR10 = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR30,
VAR19: VAR45,
VAR15: VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR18,
VAR20: VAR20
});
FUN21(VAR59, VAR10, VAR21);
}
function FUN21(uint16 VAR59, ProtoCard memory VAR10, bool VAR21) internal {
require(!VAR31[VAR59].VAR24);
VAR10.VAR24 = true;
VAR31[VAR59] = VAR10;
VAR49++;
emit FUN10(
VAR59, VAR30, VAR10.VAR14,
VAR10.VAR15, VAR10.VAR16, VAR10.VAR17,
VAR10.VAR18, VAR10.VAR19, VAR10.VAR20, VAR21
);
if (VAR21) {
Rarity VAR15 = VAR10.VAR15;
if (VAR15 == VAR38.VAR39) {
VAR37.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR40) {
VAR36.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR41) {
VAR35.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR42) {
VAR34.FUN26(VAR59);
} else if (VAR15 == VAR38.VAR43) {
VAR32.FUN26(VAR59);
} else {
require(false);
}
}
}
function FUN27(uint16 VAR9) public view returns(
bool VAR24, uint8 VAR14, uint8 VAR13, uint8 VAR19, Rarity VAR15, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR20
) {
ProtoCard memory VAR7 = VAR31[VAR9];
return (
VAR7.VAR24,
VAR7.VAR14,
VAR7.VAR13,
VAR7.VAR19,
VAR7.VAR15,
VAR7.VAR16,
VAR7.VAR17,
VAR7.VAR18,
VAR7.VAR20
);
}
function FUN28(Rarity VAR15, uint16 VAR61) public view returns (uint16) {
if (VAR15 == VAR38.VAR39) {
return VAR37[VAR61 % VAR37.VAR33];
} else if (VAR15 == VAR38.VAR40) {
return VAR36[VAR61 % VAR36.VAR33];
} else if (VAR15 == VAR38.VAR41) {
return VAR35[VAR61 % VAR35.VAR33];
} else if (VAR15 == VAR38.VAR42) {
return VAR34[VAR61 % VAR34.VAR33];
} else if (VAR15 == VAR38.VAR43) {
uint16 VAR9;
uint64 VAR23;
bool VAR27;
for (uint VAR58 = 0; VAR58 < VAR32.VAR33; VAR58++) {
VAR9 = VAR32[(VAR61 + VAR58) % VAR32.VAR33];
(VAR23, VAR27) = FUN13(VAR9);
if (VAR27 && VAR23 > 0){
return VAR9;
}
}
return VAR34[VAR61 % VAR34.VAR33];
}
require(false);
return 0;
}
function FUN29(
uint16 VAR62, uint8 VAR14, uint8 VAR19, uint8 VAR16, uint8 VAR17, uint8 VAR18, uint8 VAR20
) public onlyGovernor {
ProtoCard memory VAR63 = VAR31[VAR62];
require(!VAR28[VAR63.VAR13]);
VAR31[VAR62] = FUN20({
VAR24: true,
VAR14: VAR14,
VAR13: VAR63.VAR13,
VAR19: VAR19,
VAR15: VAR63.VAR15,
VAR16: VAR16,
VAR17: VAR17,
VAR18: VAR18,
VAR20: VAR20
});
}
}
interface VAR64
{
function FUN30() external pure returns (string VAR65);
function FUN31() external pure returns (string VAR66);
function FUN32(uint256 VAR67) external view returns (string);
}
interface VAR68
{
function FUN33() public view returns (uint256);
function FUN34(uint256 VAR69) external view returns (uint256);
function FUN35(address VAR70, uint256 VAR69) external view returns (uint256 VAR67);
}
interface VAR71 {
function FUN36(bytes4 VAR72) external view returns (bool);
}
contract VAR73 {
event Transfer(address indexed VAR74, address indexed VAR75, uint256 VAR67);
event FUN37(address indexed VAR70, address indexed VAR76, uint256 VAR67);
event FUN38(address indexed VAR70, address indexed VAR77, bool VAR76);
function FUN39(address VAR70) public view returns (uint256 VAR78);
function FUN40(uint256 VAR67) public view returns (address VAR70);
function FUN41(address VAR74, address VAR75, uint256 VAR67, bytes VAR79) public payable;
function FUN41(address VAR74, address VAR75, uint256 VAR67) public payable;
function transfer(address VAR75, uint256 VAR67) public payable;
function FUN42(address VAR74, address VAR75, uint256 VAR67) public payable;
function FUN43(address VAR75, uint256 VAR67) public payable;
function FUN44(address VAR75, bool VAR76) public;
function FUN45(uint256 VAR67) public view returns (address);
function FUN46(address VAR70, address VAR77) public view returns (bool);
}
contract NFT is VAR73, VAR71, VAR64, VAR68 {}
contract CardOwnership is VAR80, VAR81 {
mapping(uint => address) VAR82;
mapping(uint => address) VAR83;
mapping(address => mapping(address => bool)) VAR84;
mapping(address => VAR85[]) public VAR86;
mapping(uint => string) VAR87;
VAR88[] VAR89;
uint public VAR90;
function FUN30() public view returns (string) {
return "";
}
function FUN31() public view returns (string) {
return "";
}
function FUN33() public view returns (uint) {
return VAR11.VAR33 - VAR90;
}
function transfer(address VAR91, uint VAR9) public payable {
require(FUN47(msg.sender, VAR9));
require(FUN17(VAR11[VAR9].VAR7));
require(VAR91 != address(0));
FUN48(msg.sender, VAR91, VAR9);
}
function FUN48(address VAR92, address VAR91, uint VAR9) internal {
VAR83[VAR9] = address(0);
VAR82[VAR9] = VAR91;
FUN49(VAR91, VAR9);
FUN50(VAR92, VAR9);
emit Transfer(VAR92, VAR91, VAR9);
}
function FUN51(address VAR91, uint VAR9) internal {
VAR82[VAR9] = VAR91;
FUN49(VAR91, VAR9);
emit Transfer(address(0), VAR91, VAR9);
}
function FUN52(address VAR91, uint[] VAR93) public payable {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
transfer(VAR91, VAR93[VAR58]);
}
}
function FUN53(address VAR94, uint[] VAR93) public view returns (bool) {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
if (!FUN47(VAR94, VAR93[VAR58])) {
return false;
}
}
return true;
}
function FUN47(address VAR94, uint VAR9) public view returns (bool) {
return FUN40(VAR9) == VAR94;
}
function FUN40(uint VAR9) public view returns (address) {
return VAR82[VAR9];
}
function FUN54(uint VAR9) public {
require(FUN47(msg.sender, VAR9));
VAR90++;
FUN48(msg.sender, address(0), VAR9);
}
function FUN55(uint[] VAR93) public {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++){
FUN54(VAR93[VAR58]);
}
}
function FUN43(address VAR91, uint VAR9) public payable {
require(FUN47(msg.sender, VAR9));
require(FUN17(VAR11[VAR9].VAR7));
VAR83[VAR9] = VAR91;
emit FUN37(msg.sender, VAR91, VAR9);
}
function FUN56(address VAR91, uint[] VAR93) public payable {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
FUN43(VAR91, VAR93[VAR58]);
}
}
function FUN45(uint VAR9) public view returns(address) {
return VAR83[VAR9];
}
function FUN39(address VAR95) public view returns (uint) {
return VAR86[VAR95].VAR33;
}
function FUN57(uint VAR9) public view returns (bool) {
return VAR82[VAR9] != address(0);
}
function FUN42(address VAR92, address VAR91, uint VAR9) public payable {
require(VAR91 != address(0));
require(VAR91 != address(this));
require(FUN40(VAR9) == VAR92);
require(FUN58(VAR9));
require(FUN17(VAR11[VAR9].VAR7));
FUN48(FUN40(VAR9), VAR91, VAR9);
}
function FUN59(address VAR91, uint[] VAR93) public payable {
for (uint VAR58 = 0; VAR58 < VAR93.VAR33; VAR58++) {
FUN42(address(0), VAR91, VAR93[VAR58]);
}
}
function FUN60() public view returns (uint) {
return VAR90;
}
function FUN46(address VAR95, address VAR96) public view returns (bool) {
return VAR84[VAR95][VAR96];
}
function FUN44(address VAR91, bool VAR97) public {
require(VAR91 != msg.sender);
VAR84[msg.sender][VAR91] = VAR97;
emit FUN38(msg.sender, VAR91, VAR97);
}
bytes4 constant VAR98 = bytes4(FUN61(""));
function FUN41(address VAR92, address VAR91, uint VAR9, bytes VAR79) public payable {
require(VAR91 != address(0));
FUN42(VAR92, VAR91, VAR9);
if (FUN62(VAR91)) {
bytes4 VAR99 = FUN63(VAR91).VAR100.FUN64(50000)(VAR92, VAR9, VAR79);
require(VAR99 == VAR98);
}
}
function FUN41(address VAR92, address VAR91, uint VAR9) public payable {
FUN41(VAR92, VAR91, VAR9, "");
}
function FUN49(address VAR91, uint VAR9) private {
uint VAR101 = VAR86[VAR91].FUN26(FUN65(VAR9)) - 1;
VAR89.FUN26(FUN66(VAR101));
}
function FUN50(address VAR92, uint VAR9) public payable {
uint24 VAR62 = VAR89[VAR9];
uint VAR102 = VAR86[VAR92].VAR33 - 1;
uint40 VAR103 = VAR86[VAR92][VAR102];
VAR86[VAR92][VAR62] = VAR103;
VAR86[VAR92][VAR102] = 0;
VAR86[VAR92].VAR33--;
}
function FUN58(uint256 VAR9) internal view returns (bool) {
return FUN47(msg.sender, VAR9) || FUN45(VAR9) == msg.sender || FUN46(FUN40(VAR9), msg.sender);
}
function FUN62(address VAR104) internal view returns (bool) {
uint VAR105;
VAR106 {
VAR105 := FUN67(VAR104)
}
return (VAR105 > 0);
}
function FUN32(uint VAR9) public view returns (string) {
return VAR87[VAR9];
}
function FUN35(address VAR95, uint256 VAR62) external view returns (uint256 VAR67){
return VAR86[VAR95][VAR62];
}
function FUN34(uint256 VAR62) external view returns (uint256){
return VAR62;
}
function FUN36(bytes4 VAR72) public view returns (bool) {
return (
VAR72 == this.VAR107.VAR108 ||
VAR72 == 0x5b5e139f ||
VAR72 == 0x6466353c ||
VAR72 == 0x780e9d63
);
}
function FUN68() external pure returns (bool) {
return true;
}
function FUN69(address VAR109) public view returns (VAR85[]) {
return VAR86[VAR109];
}
}
interface VAR110 {
function FUN70(address VAR74, uint256 VAR67, bytes VAR111) external returns(bytes4);
}
contract CardIntegration is VAR112 {
VAR113[] VAR114;
event FUN71(uint indexed VAR9, uint16 VAR7, uint16 VAR8, address VAR95);
function FUN72(CardPack VAR83) public onlyGovernor {
VAR114.FUN26(VAR83);
}
modifier VAR115 {
require(FUN73());
VAR5;
}
function FUN73() private view returns (bool) {
for (uint VAR58 = 0; VAR58 < VAR114.VAR33; VAR58++) {
if (msg.sender == address(VAR114[VAR58])) {
return true;
}
}
return false;
}
function FUN74(address VAR95, uint16 VAR7, uint16 VAR8) public whenNotPaused onlyApprovedPacks returns (uint) {
ProtoCard memory VAR10 = VAR31[VAR7];
require(VAR10.VAR13 == VAR30);
if (VAR10.VAR15 == VAR38.VAR43) {
uint64 VAR23;
bool VAR24;
(VAR23, VAR24) = FUN13(VAR7);
require(!VAR24 || VAR23 > 0);
VAR25[VAR7].VAR23--;
}
return FUN75(VAR95, VAR7, VAR8);
}
function FUN75(address VAR95, uint16 VAR7, uint16 VAR8) internal returns (uint) {
Card memory VAR10 = FUN76({
VAR7: VAR7,
VAR8: VAR8
});
uint VAR9 = VAR11.FUN26(VAR10) - 1;
FUN51(VAR95, VAR9);
emit FUN71(VAR9, VAR7, VAR8, VAR95);
return VAR9;
}
}
contract VAR113 {
CardIntegration public VAR116;
uint public VAR117;
constructor(CardIntegration VAR118) public payable {
VAR116 = VAR118;
VAR117 = VAR119.VAR120;
}
event FUN77(address indexed VAR121, uint value, address VAR122);
function FUN78(uint16 VAR123, address VAR121) public payable;
function FUN79(uint16 VAR124, uint16 VAR125) internal pure returns (uint16) {
if (VAR124 >= 998) {
return 3000 + VAR125;
} else if (VAR124 >= 988) {
return 2000 + VAR125;
} else if (VAR124 >= 938) {
return 1000 + VAR125;
} else {
return VAR125;
}
}
}
contract VAR126 {
address public VAR95;
constructor() public {
VAR95 = msg.sender;
}
function FUN80(address VAR70) public onlyOwner {
VAR95 = VAR70;
}
modifier onlyOwner {
require(msg.sender == VAR95);
VAR5;
}
}
contract Vault is VAR126 {
function () public payable {
}
function FUN81() public view returns (uint) {
return address(this).VAR127;
}
function FUN82(uint VAR128) public onlyOwner {
require(address(this).VAR127 >= VAR128);
VAR95.transfer(VAR128);
}
function FUN83() public onlyOwner {
FUN82(address(this).VAR127);
}
}
contract CappedVault is VAR129 {
uint public VAR23;
uint VAR130 = 0;
constructor() public {
VAR23 = 33333 VAR131;
}
function () public payable {
require(FUN84() + msg.value <= VAR23);
}
function FUN84() public view returns(uint) {
return FUN81() + VAR130;
}
function FUN82(uint VAR128) public onlyOwner {
require(address(this).VAR127 >= VAR128);
VAR95.transfer(VAR128);
VAR130 += VAR128;
}
}
contract Pausable is VAR126 {
event FUN1();
event FUN2();
bool public VAR3 = false;
modifier FUN4() {
require(!VAR3);
VAR5;
}
modifier FUN5() {
require(VAR3);
VAR5;
}
function FUN6() onlyOwner whenNotPaused public {
VAR3 = true;
emit FUN1();
}
function FUN7() onlyOwner whenPaused public {
VAR3 = false;
emit FUN2();
}
}
contract PresalePack is VAR113, VAR132 {
CappedVault public VAR133;
VAR134[] VAR135;
struct VAR134 {
uint16 VAR136;
uint16 VAR137;
address VAR109;
uint VAR138;
uint64 VAR139;
}
event FUN85(uint indexed VAR9, address indexed VAR109, uint16 VAR137);
event FUN86(uint indexed VAR9, uint16 VAR140, address indexed VAR109, uint[] VAR141);
event FUN87(uint indexed VAR9, address indexed VAR109, uint16 VAR137, uint VAR138);
constructor(CardIntegration VAR116, CappedVault VAR142) public payable FUN88(VAR116) {
VAR133 = VAR142;
}
function FUN89() public returns (uint);
function FUN90(uint16 VAR143, uint8 VAR144, uint VAR145) public view returns (uint16 VAR7, uint16 VAR8);
function FUN91() public view returns (uint8) {
return 5;
}
function FUN92() public view returns (uint16) {
return 15;
}
function FUN93(uint VAR146, uint VAR33, uint VAR147) internal pure returns (uint) {
return (((1 << (VAR33 * 8)) - 1) & (VAR146 >> ((VAR147 * 8) - 1)));
}
uint public VAR148;
uint public VAR149;
function FUN78(uint16 VAR123, address VAR121) whenNotPaused public payable {
require(VAR123 > 0);
require(VAR121 != msg.sender);
uint VAR150 = FUN94(FUN89(), VAR123);
require(msg.value >= VAR150);
Purchase memory VAR151 = FUN95({
VAR109: msg.sender,
VAR137: VAR123,
VAR139: FUN96(VAR119.VAR120),
VAR138: 0,
VAR136: 0
});
uint VAR9 = VAR135.FUN26(VAR151) - 1;
emit FUN85(VAR9, msg.sender, VAR123);
if (VAR121 != address(0)) {
uint VAR152 = VAR150 / 10;
VAR121.transfer(VAR152);
VAR150 -= VAR152;
emit FUN77(VAR121, VAR152, msg.sender);
}
address(VAR133).transfer(VAR150);
}
function FUN97(uint VAR9) public {
Purchase storage VAR151 = VAR135[VAR9];
require(VAR151.VAR138 == 0);
bytes32 VAR153 = FUN98(VAR151.VAR139);
uint VAR61 = uint(FUN61(VAR154.FUN99(VAR149, VAR153)));
VAR149 += VAR151.VAR137;
if (uint(VAR153) == 0) {
VAR151.VAR138 = 1;
} else {
VAR151.VAR138 = VAR61;
}
emit FUN87(VAR9, VAR151.VAR109, VAR151.VAR137, VAR151.VAR138);
}
function FUN100(uint VAR9) public {
Purchase storage VAR151 = VAR135[VAR9];
require(VAR155);
uint16 VAR7;
uint16 VAR8;
uint16 VAR137 = VAR151.VAR137;
uint VAR145 = VAR151.VAR138;
uint8 VAR105 = FUN91();
address VAR109 = VAR151.VAR109;
uint16 VAR136 = VAR151.VAR136;
require(VAR145 != 0);
require(VAR137 > 0);
uint[] memory VAR93 = new uint[](VAR105);
uint16 VAR156 = VAR136 + FUN92() > VAR137 ? VAR137 : VAR136 + FUN92();
require(VAR156 > VAR136);
for (uint16 VAR58 = VAR136; VAR58 < VAR156; VAR58++) {
for (uint8 VAR157 = 0; VAR157 < VAR105; VAR157++) {
(VAR7, VAR8) = FUN90(VAR58, VAR157, VAR145);
VAR93[VAR157] = VAR116.FUN74(VAR109, VAR7, VAR8);
}
emit FUN86(VAR9, (VAR58 * VAR105), VAR109, VAR93);
}
VAR151.VAR136 += (VAR156 - VAR136);
}
function FUN101(uint VAR9) external view returns (uint16[] VAR31, uint16[] VAR158) {
Purchase memory VAR151 = VAR135[VAR9];
uint16 VAR7;
uint16 VAR8;
uint16 VAR137 = VAR151.VAR137;
uint VAR145 = VAR151.VAR138;
uint8 VAR105 = FUN91();
VAR158 = new uint16[](VAR105 * VAR137);
VAR31 = new uint16[](VAR105 * VAR137);
for (uint16 VAR58 = 0; VAR58 < VAR137; VAR58++) {
for (uint8 VAR157 = 0; VAR157 < VAR105; VAR157++) {
(VAR7, VAR8) = FUN90(VAR58, VAR157, VAR145);
VAR158[(VAR58 * VAR105) + VAR157] = VAR8;
VAR31[(VAR58 * VAR105) + VAR157] = VAR7;
}
}
return (VAR31, VAR158);
}
function FUN94(uint VAR159, uint16 VAR123) public view returns (uint) {
uint VAR160 = VAR119.VAR120 - VAR117;
uint VAR161 = VAR160 / 6000;
if (20 > VAR161) {
return (VAR159 - (((20 - VAR161) * VAR159) / 100)) * VAR123;
}
return VAR159 * VAR123;
}
function FUN102(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else if (VAR162 >= 998345) {
return VAR81.VAR38.VAR42;
} else if (VAR162 >= 986765) {
return VAR81.VAR38.VAR41;
} else if (VAR162 >= 924890) {
return VAR81.VAR38.VAR40;
} else {
return VAR81.VAR38.VAR39;
}
}
function FUN103(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else if (VAR162 >= 981615) {
return VAR81.VAR38.VAR42;
} else if (VAR162 >= 852940) {
return VAR81.VAR38.VAR41;
} else {
return VAR81.VAR38.VAR40;
}
}
function FUN104(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else if (VAR162 >= 981615) {
return VAR81.VAR38.VAR42;
} else {
return VAR81.VAR38.VAR41;
}
}
function FUN105(uint32 VAR162) internal pure returns (VAR81.VAR38) {
if (VAR162 == 999999) {
return VAR81.VAR38.VAR43;
} else {
return VAR81.VAR38.VAR42;
}
}
bool public VAR155 = true;
function FUN106(bool VAR163) public onlyOwner {
VAR155 = VAR163;
}
function FUN107(
uint16 VAR58, uint8 VAR157, uint VAR162
) internal returns (
uint VAR61, uint32 VAR164, uint16 VAR165, uint16 VAR166, uint16 VAR167
) {
VAR61 = uint(FUN61(VAR154.FUN99(VAR58, VAR162, VAR157)));
VAR164 = FUN108(FUN93(VAR61, 4, 10) % 1000000);
VAR165 = uint16(FUN93(VAR61, 2, 4) % 1000);
VAR166 = uint16(FUN93(VAR61, 2, 6) % 1000);
VAR167 = uint16(FUN93(VAR61, 2, 8) % (2**16-1));
return (VAR61, VAR164, VAR165, VAR166, VAR167);
}
function FUN82() public onlyOwner {
VAR95.transfer(address(this).VAR127);
}
}
contract VAR168 {
event FUN37(address indexed VAR95, address indexed VAR169, uint256 value);
event Transfer(address indexed VAR92, address indexed VAR91, uint256 value);
function FUN109(address VAR95, address VAR169) public view returns (uint256);
function FUN42(address VAR92, address VAR91, uint256 value) public returns (bool);
function FUN43(address VAR169, uint256 value) public returns (bool);
function FUN33() public view returns (uint256);
function FUN39(address VAR170) public view returns (uint256);
function transfer(address VAR91, uint256 value) public returns (bool);
}
pragma solidity 0.4.24;
library VAR171 {
function FUN110(uint256 VAR172, uint256 VAR173) internal pure returns (uint256 VAR174) {
if (VAR172 == 0) {
return 0;
}
VAR174 = VAR172 * VAR173;
assert(VAR174 / VAR172 == VAR173);
return VAR174;
}
function FUN111(uint256 VAR172, uint256 VAR173) internal pure returns (uint256) {
return VAR172 / VAR173;
}
function FUN112(uint256 VAR172, uint256 VAR173) internal pure returns (uint256) {
assert(VAR173 <= VAR172);
return VAR172 - VAR173;
}
function FUN113(uint256 VAR172, uint256 VAR173) internal pure returns (uint256 VAR174) {
VAR174 = VAR172 + VAR173;
assert(VAR174 >= VAR172);
return VAR174;
}
}
contract TournamentPass is VAR168, VAR126 {
using SafeMath for uint256;
Vault VAR133;
constructor(Vault VAR142) public {
VAR133 = VAR142;
}
mapping(address => uint256) VAR175;
mapping (address => mapping (address => uint256)) internal VAR176;
address[] public VAR177;
uint256 VAR178;
uint VAR179 = 20000;
function FUN30() public view returns (string){
return "";
}
function FUN31() public view returns (string) {
return "";
}
function FUN114(address VAR180) public onlyOwner {
VAR177.FUN26(VAR180);
}
function FUN33() public view returns (uint256) {
return VAR178;
}
function transfer(address VAR75, uint256 VAR181) public returns (bool) {
require(VAR75 != address(0));
require(VAR181 <= VAR175[msg.sender]);
VAR175[msg.sender] = VAR175[msg.sender].FUN112(VAR181);
VAR175[VAR75] = VAR175[VAR75].FUN113(VAR181);
emit Transfer(msg.sender, VAR75, VAR181);
return true;
}
function FUN39(address VAR70) public view returns (uint256) {
return VAR175[VAR70];
}
function FUN115(address VAR104) internal view returns (bool) {
for (uint VAR58 = 0; VAR58 < VAR177.VAR33; VAR58++) {
if (VAR177[VAR58] == VAR104) {
return true;
}
}
return false;
}
function FUN116(address VAR91, uint VAR128) public returns (bool) {
require(FUN115(msg.sender));
if (VAR128.FUN113(VAR178) > VAR179) {
return false;
}
VAR178 = VAR178.FUN113(VAR128);
VAR175[VAR91] = VAR175[VAR91].FUN113(VAR128);
emit Transfer(address(0), VAR91, VAR128);
return true;
}
function FUN43(address VAR182, uint256 VAR181) public returns (bool) {
VAR176[msg.sender][VAR182] = VAR181;
emit FUN37(msg.sender, VAR182, VAR181);
return true;
}
function FUN42(address VAR74, address VAR75, uint256 VAR181) public returns (bool) {
require(VAR75 != address(0));
require(VAR181 <= VAR175[VAR74]);
require(VAR181 <= VAR176[VAR74][msg.sender]);
VAR175[VAR74] = VAR175[VAR74].FUN112(VAR181);
VAR175[VAR75] = VAR175[VAR75].FUN113(VAR181);
VAR176[VAR74][msg.sender] = VAR176[VAR74][msg.sender].FUN112(VAR181);
emit Transfer(VAR74, VAR75, VAR181);
return true;
}
function FUN117(address VAR169, uint256 VAR183) public returns (bool) {
VAR176[msg.sender][VAR169] = VAR176[msg.sender][VAR169].FUN113(VAR183);
emit FUN37(msg.sender, VAR169, VAR176[msg.sender][VAR169]);
return true;
}
function FUN118(address VAR169, uint256 VAR184) public returns (bool) {
uint256 VAR185 = VAR176[msg.sender][VAR169];
if (VAR184 > VAR185) {
VAR176[msg.sender][VAR169] = 0;
} else {
VAR176[msg.sender][VAR169] = VAR185.FUN112(VAR184);
}
emit FUN37(msg.sender, VAR169, VAR176[msg.sender][VAR169]);
return true;
}
function FUN109(address VAR70, address VAR182) public view returns (uint256 VAR186) {
return VAR176[VAR70][VAR182];
}
uint public VAR150 = 250 VAR187;
function FUN78(uint VAR128) public payable {
require(msg.value >= VAR150.FUN110(VAR128));
require(VAR178.FUN113(VAR128) <= VAR179);
VAR178 = VAR178.FUN113(VAR128);
VAR175[msg.sender] = VAR175[msg.sender].FUN113(VAR128);
emit Transfer(address(0), msg.sender, VAR128);
address(VAR133).transfer(msg.value);
}
}
contract ShinyLegendaryPack is VAR188 {
TournamentPass VAR189;
constructor(CardIntegration VAR116, CappedVault VAR142, TournamentPass VAR190) public payable FUN119(VAR116, VAR142) {
VAR189 = VAR190;
}
function FUN78(uint16 VAR123, address VAR121) public payable {
super.FUN78(VAR123, VAR121);
VAR189.FUN116(msg.sender, VAR123);
}
function FUN89() public returns (uint) {
return 4 VAR131;
}
function FUN90(uint16 VAR143, uint8 VAR144, uint VAR145) public view returns (uint16 VAR7, uint16 VAR8) {
uint VAR61;
uint32 VAR164;
uint16 VAR167;
uint16 VAR165;
uint16 VAR166;
VAR81.Rarity VAR15;
(VAR61, VAR164, VAR165, VAR166, VAR167) = FUN107(VAR143, VAR144, VAR145);
if (VAR144 == 4) {
VAR15 = FUN105(VAR164);
VAR8 = FUN120(VAR165, VAR166);
} else if (VAR144 == 3) {
VAR15 = FUN103(VAR164);
VAR8 = FUN79(VAR165, VAR166);
} else {
VAR15 = FUN102(VAR164);
VAR8 = FUN79(VAR165, VAR166);
}
VAR7 = VAR116.FUN28(VAR15, VAR167);
return (VAR7, VAR8);
}
function FUN120(uint16 VAR124, uint16 VAR125) public pure returns (uint16) {
if (VAR124 >= 998) {
return 3000 + VAR125;
} else if (VAR124 >= 748) {
return 2000 + VAR125;
} else {
return 1000 + VAR125;
}
}
}
0
---------------------------------
49 0x000adad69101420129a64715a1a52b7348c5e633.sol
pragma VAR1 ^0.5.0;
interface VAR2 {
function transfer(address VAR3, uint256 value) external returns (bool);
function FUN1(address VAR4, uint256 value) external returns (bool);
function FUN2(address VAR5, address VAR3, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR6) external view returns (uint256);
function FUN5(address VAR7, address VAR4) external view returns (uint256);
event Transfer(address indexed VAR5, address indexed VAR3, uint256 value);
event FUN6(address indexed VAR7, address indexed VAR4, uint256 value);
}
contract VAR8 {
address private VAR9;
event FUN7(address indexed VAR10, address indexed VAR11);
constructor () internal {
VAR9 = msg.sender;
emit FUN7(address(0), VAR9);
}
function FUN8() public view returns (address) {
return VAR9;
}
modifier onlyOwner() {
require(FUN9());
VAR12;
}
function FUN9() public view returns (bool) {
return msg.sender == VAR9;
}
function FUN10() public onlyOwner {
emit FUN7(VAR9, address(0));
VAR9 = address(0);
}
function FUN11(address VAR11) public onlyOwner {
FUN12(VAR11);
}
function FUN12(address VAR11) internal {
require(VAR11 != address(0));
emit FUN7(VAR9, VAR11);
VAR9 = VAR11;
}
}
contract DIP_Team_Transfer is VAR8 {
uint256 constant VAR13 = 10**18;
IERC20 public VAR14;
event FUN13(address VAR15, uint256 VAR16);
address VAR17 = 0x7D96c657F5d721De12060cdc90e6ACa73A5a4E46;
address VAR18 = 0x4B7B8c1d236D349D53b2Fb80c060FEF2544cE3E4;
struct VAR19 {
address VAR20;
uint256 VAR16;
}
mapping (address => VAR19) VAR21;
function () external {
FUN14();
}
function FUN14() public {
grant memory VAR22;
uint256 VAR16;
VAR22 = VAR21[msg.sender];
VAR16 = VAR22.VAR16;
VAR22.VAR16 = 0;
require(VAR16 > 0, "");
VAR21[msg.sender] = FUN15(VAR22.VAR20, 0);
VAR14.FUN2(VAR22.VAR20, msg.sender, VAR16);
emit FUN13(msg.sender, VAR16);
}
constructor (
) public FUN16() {
VAR14 = FUN17(0xc719d010B63E5bbF2C0551872CD5316ED26AcD83);
VAR21[0x0024df2bE7524b132Ced68Ca2906eD1D9CdAbDA4] = FUN15(VAR17, 84000 * VAR13);
VAR21[0x025f020e2C1e540c3fBe3E80C23Cb192dFb65514] = FUN15(VAR17, 2957000 * VAR13);
VAR21[0x1FeA19BA0Cd8e068Fb1C538B2C3a700965d1952e] = FUN15(VAR17, 119000 * VAR13);
VAR21[0x2718874048aBcCEbE24693e689D31B011c6101EA] = FUN15(VAR17, 314000 * VAR13);
VAR21[0x317c250bFF0AC2b1913Aa6F2d6C609e4bE1AaeE0] = FUN15(VAR17, 100000 * VAR13);
VAR21[0x398c901146F569Bf5FCd70375311eFa02E119aF8] = FUN15(VAR17, 588000 * VAR13);
VAR21[0x4E268abEDa13152E60722035328E83f28eed0275] = FUN15(VAR17, 314000 * VAR13);
VAR21[0x5509cE67333342e7758bF845A0897b51E062f502] = FUN15(VAR17, 115000 * VAR13);
VAR21[0x559F1a36Ea6435f22EF814a654645051b1639c9d] = FUN15(VAR17, 30000 * VAR13);
VAR21[0x5A6189cE8e6Ae1c86098af24103CA77D386Ae643] = FUN15(VAR17, 5782000 * VAR13);
VAR21[0x63CE9f57E2e4B41d3451DEc20dDB89143fD755bB] = FUN15(VAR17, 115000 * VAR13);
VAR21[0x6D970711335B3d3AC8Ee1bB88D7b3780bf580e5b] = FUN15(VAR17, 46000 * VAR13);
VAR21[0x842d48Ebb8E8043A98Cd176368F39d777d1fF78E] = FUN15(VAR17, 19000 * VAR13);
VAR21[0x8567104a7b6EA93a87c551F5D00ABB222EdB45d2] = FUN15(VAR17, 46000 * VAR13);
VAR21[0x886ed4Bb4Db7d160C25942dD9E5e1668cdA646D8] = FUN15(VAR17, 250000 * VAR13);
VAR21[0x98eA564573dE3AbD60181Df8b491C24C45b77e37] = FUN15(VAR17, 115000 * VAR13);
VAR21[0x9B8242f93dB16185bb6719C3831f768a261E5d55] = FUN15(VAR17, 600000 * VAR13);
VAR21[0xaC97d99B1cCdAE787B5022fE323C1079dbe41ccC] = FUN15(VAR17, 115000 * VAR13);
VAR21[0xB2Dc68B318eCEC2acf5f098D57775c90541612E2] = FUN15(VAR17, 7227000 * VAR13);
VAR21[0xb7686e8b325f39A6A62Ea1ea81fd29F50C7737ab] = FUN15(VAR17, 115000 * VAR13);
VAR21[0xba034d25a226705A84Ffe716eEEC90C1aD2aFE00] = FUN15(VAR17, 115000 * VAR13);
VAR21[0xC370D781D734222A8863053A8C5A7afF87b0896a] = FUN15(VAR17, 100000 * VAR13);
VAR21[0xCA0B0cA0d90e5008c31167FFb9a38fdA33aa36a8] = FUN15(VAR17, 115000 * VAR13);
VAR21[0xE2E5f8e18dD933aFbD61d81Fd188fB2637A2DaB6] = FUN15(VAR17, 621000 * VAR13);
VAR21[0xe5759a0d285BB2D14B82111532cf1c660Fe57481] = FUN15(VAR17, 115000 * VAR13);
VAR21[0xF8cB04BfC21ebBc63E7eB49c9f8edF2E97707eE5] = FUN15(VAR17, 314000 * VAR13);
VAR21[0x2EE8619CCa46c44cDD5C527FBa68E1f7E5F3478a] = FUN15(VAR18, 33333333333333333333333333);
VAR21[0xa8e679191AE2C669F4550db7f52b20CF3d19c069] = FUN15(VAR18, 33333333333333333333333333);
VAR21[0xbC6b0862e6394067DC5Be2147c4de35DeB4424fE] = FUN15(VAR18, 33333333333333333333333333);
}
function FUN18 () public onlyOwner {
FUN19(address (FUN20(FUN8())));
}
}
0
---------------------------------
50 0x000c100050e98c91f9114fa5dd75ce6869bf4f53.sol
pragma VAR1 ^0.5.6;
interface VAR2 {
function transfer(address VAR3, uint256 value) external returns (bool);
function FUN1(address VAR4, uint256 value) external returns (bool);
function FUN2(address VAR5, address VAR3, uint256 value) external returns (bool);
function FUN3() external view returns (uint256);
function FUN4(address VAR6) external view returns (uint256);
function FUN5(address VAR7, address VAR4) external view returns (uint256);
event Transfer(address indexed VAR5, address indexed VAR3, uint256 value);
event FUN6(address indexed VAR7, address indexed VAR4, uint256 value);
}
pragma VAR1 ^0.5.6;
contract ERC20Detailed is VAR2 {
string private VAR8;
string private VAR9;
uint8 private VAR10;
constructor (string memory VAR11, string memory VAR12, uint8 VAR13) public {
VAR8 = VAR11;
VAR9 = VAR12;
VAR10 = VAR13;
}
function FUN7() public view returns (string VAR14) {
return VAR8;
}
function FUN8() public view returns (string VAR14) {
return VAR9;
}
function FUN9() public view returns (uint8) {
return VAR10;
}
}
pragma VAR1 ^0.5.6;
library VAR15 {
function FUN10(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
if (VAR16 == 0) {
return 0;
}
uint256 VAR18 = VAR16 * VAR17;
require(VAR18 / VAR16 == VAR17);
return VAR18;
}
function FUN11(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 > 0);
uint256 VAR18 = VAR16 / VAR17;
return VAR18;
}
function FUN12(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 <= VAR16);
uint256 VAR18 = VAR16 - VAR17;
return VAR18;
}
function FUN13(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
uint256 VAR18 = VAR16 + VAR17;
require(VAR18 >= VAR16);
return VAR18;
}
function FUN14(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
require(VAR17 != 0);
return VAR16 % VAR17;
}
}
pragma VAR1 ^0.5.6;
contract ERC20 is VAR2 {
using SafeMath for uint256;
mapping (address => uint256) private VAR19;
mapping (address => mapping (address => uint256)) private VAR20;
uint256 private VAR21;
function FUN3() public view returns (uint256) {
return VAR21;
}
function FUN4(address VAR7) public view returns (uint256) {
return VAR19[VAR7];
}
function FUN5(address VAR7, address VAR4) public view returns (uint256) {
return VAR20[VAR7][VAR4];
}
function transfer(address VAR3, uint256 value) public returns (bool) {
FUN15(msg.sender, VAR3, value);
return true;
}
function FUN1(address VAR4, uint256 value) public returns (bool) {
require(VAR4 != address(0));
VAR20[msg.sender][VAR4] = value;
emit FUN6(msg.sender, VAR4, value);
return true;
}
function FUN2(address VAR5, address VAR3, uint256 value) public returns (bool) {
VAR20[VAR5][msg.sender] = VAR20[VAR5][msg.sender].FUN12(value);
FUN15(VAR5, VAR3, value);
emit FUN6(VAR5, msg.sender, VAR20[VAR5][msg.sender]);
return true;
}
function FUN16(address VAR4, uint256 VAR22) public returns (bool) {
require(VAR4 != address(0));
VAR20[msg.sender][VAR4] = VAR20[msg.sender][VAR4].FUN13(VAR22);
emit FUN6(msg.sender, VAR4, VAR20[msg.sender][VAR4]);
return true;
}
function FUN17(address VAR4, uint256 VAR23) public returns (bool) {
require(VAR4 != address(0));
VAR20[msg.sender][VAR4] = VAR20[msg.sender][VAR4].FUN12(VAR23);
emit FUN6(msg.sender, VAR4, VAR20[msg.sender][VAR4]);
return true;
}
function FUN15(address VAR5, address VAR3, uint256 value) internal {
require(VAR3 != address(0));
VAR19[VAR5] = VAR19[VAR5].FUN12(value);
VAR19[VAR3] = VAR19[VAR3].FUN13(value);
emit Transfer(VAR5, VAR3, value);
}
function FUN18(address VAR24, uint256 value) internal {
require(VAR24 != address(0));
VAR21 = VAR21.FUN13(value);
VAR19[VAR24] = VAR19[VAR24].FUN13(value);
emit Transfer(address(0), VAR24, value);
}
function FUN19(address VAR24, uint256 value) internal {
require(VAR24 != address(0));
VAR21 = VAR21.FUN12(value);
VAR19[VAR24] = VAR19[VAR24].FUN12(value);
emit Transfer(VAR24, address(0), value);
}
function FUN20(address VAR24, uint256 value) internal {
VAR20[VAR24][msg.sender] = VAR20[VAR24][msg.sender].FUN12(value);
FUN19(VAR24, value);
emit FUN6(VAR24, msg.sender, VAR20[VAR24][msg.sender]);
}
}
pragma VAR1 ^0.5.6;
contract ERC20Burnable is VAR25 {
function FUN21(uint256 value) public {
FUN19(msg.sender, value);
}
function FUN22(address VAR5, uint256 value) public {
FUN20(VAR5, value);
}
}
pragma VAR1 ^0.5.6;
contract VAR26 {
address private VAR27;
event FUN23(address indexed VAR28, address indexed VAR29);
constructor () internal {
VAR27 = msg.sender;
emit FUN23(address(0), VAR27);
}
function FUN24() public view returns (address) {
return VAR27;
}
modifier onlyOwner() {
require(FUN25());
VAR30;
}
function FUN25() public view returns (bool) {
return msg.sender == VAR27;
}
function FUN26() public onlyOwner {
emit FUN23(VAR27, address(0));
VAR27 = address(0);
}
function FUN27(address VAR29) public onlyOwner {
FUN28(VAR29);
}
function FUN28(address VAR29) internal {
require(VAR29 != address(0));
emit FUN23(VAR27, VAR29);
VAR27 = VAR29;
}
}
pragma VAR1 ^0.5.6;
library VAR31 {
struct VAR32 {
mapping (address => bool) VAR33;
}
function FUN13(Role storage VAR34, address VAR24) internal {
require(VAR24 != address(0));
require(!FUN29(VAR34, VAR24));
VAR34.VAR33[VAR24] = true;
}
function FUN30(Role storage VAR34, address VAR24) internal {
require(VAR24 != address(0));
require(FUN29(VAR34, VAR24));
VAR34.VAR33[VAR24] = false;
}
function FUN29(Role storage VAR34, address VAR24) internal view returns (bool) {
require(VAR24 != address(0));
return VAR34.VAR33[VAR24];
}
}
pragma VAR1 ^0.5.6;
contract VAR35 {
using Roles for VAR31.VAR32;
event FUN31(address indexed VAR24);
event FUN32(address indexed VAR24);
VAR31.Role private VAR36;
constructor () internal {
FUN33(msg.sender);
}
modifier FUN34() {
require(FUN35(msg.sender));
VAR30;
}
function FUN35(address VAR24) public view returns (bool) {
return VAR36.FUN29(VAR24);
}
function FUN36(address VAR24) public VAR37 {
FUN33(VAR24);
}
function FUN37() public {
FUN38(msg.sender);
}
function FUN33(address VAR24) internal {
VAR36.FUN13(VAR24);
emit FUN31(VAR24);
}
function FUN38(address VAR24) internal {
VAR36.FUN30(VAR24);
emit FUN32(VAR24);
}
}
pragma VAR1 ^0.5.6;
contract Pausable is VAR35 {
event FUN39(address VAR24);
event FUN40(address VAR24);
bool private VAR38;
constructor () internal {
VAR38 = false;
}
function FUN41() public view returns (bool) {
return VAR38;
}
modifier FUN42() {
require(!VAR38);
VAR30;
}
modifier FUN43() {
require(VAR38);
VAR30;
}
function FUN44() public onlyPauser VAR39 {
VAR38 = true;
emit FUN39(msg.sender);
}
function FUN45() public onlyPauser VAR40 {
VAR38 = false;
emit FUN40(msg.sender);
}
}
pragma VAR1 ^0.5.6;
contract VAR41 {
using Roles for VAR31.VAR32;
event FUN46(address indexed VAR24);
event FUN47(address indexed VAR24);
VAR31.Role private VAR42;
constructor () internal {
FUN48(msg.sender);
}
modifier FUN49() {
require(FUN50(msg.sender));
VAR30;
}
function FUN50(address VAR24) public view returns (bool) {
return VAR42.FUN29(VAR24);
}
function FUN51(address VAR24) public VAR43 {
FUN48(VAR24);
}
function FUN52() public {
FUN53(msg.sender);
}
function FUN48(address VAR24) internal {
VAR42.FUN13(VAR24);
emit FUN46(VAR24);
}
function FUN53(address VAR24) internal {
VAR42.FUN30(VAR24);
emit FUN47(VAR24);
}
}
pragma VAR1 ^0.5.6;
contract VAR44 {
using Roles for VAR31.VAR32;
event FUN54(address indexed VAR24);
event FUN55(address indexed VAR24);
VAR31.Role private VAR45;
constructor () internal {
FUN56(msg.sender);
}
modifier FUN57() {
require(FUN58(msg.sender));
VAR30;
}
function FUN58(address VAR24) public view returns (bool) {
return VAR45.FUN29(VAR24);
}
function FUN59(address VAR24) public VAR46 {
FUN56(VAR24);
}
function FUN60() public {
FUN61(msg.sender);
}
function FUN56(address VAR24) internal {
VAR45.FUN13(VAR24);
emit FUN54(VAR24);
}
function FUN61(address VAR24) internal {
VAR45.FUN30(VAR24);
emit FUN55(VAR24);
}
}
pragma VAR1 ^0.5.6;
contract WhitelistedRole is VAR44 {
using Roles for VAR31.VAR32;
event FUN62(address indexed VAR24);
event FUN63(address indexed VAR24);
VAR31.Role private VAR47;
modifier FUN64() {
require(FUN65(msg.sender));
VAR30;
}
function FUN65(address VAR24) public view returns (bool) {
return VAR47.FUN29(VAR24);
}
function FUN66(address VAR24) public VAR46 {
FUN67(VAR24);
}
function FUN68(address VAR24) public VAR46 {
FUN69(VAR24);
}
function FUN70() public {
FUN69(msg.sender);
}
function FUN67(address VAR24) internal {
VAR47.FUN13(VAR24);
emit FUN62(VAR24);
}
function FUN69(address VAR24) internal {
VAR47.FUN30(VAR24);
emit FUN63(VAR24);
}
}
pragma VAR1 ^0.5.6;
contract InvictusWhitelist is VAR26, VAR48 {
constructor ()
FUN71() public {
}
function FUN72(address VAR49) public VAR46 {
if (!FUN65(VAR49)) {
FUN66(VAR49);
}
}
function FUN73(address VAR24) public onlyOwner {
require(VAR24 != msg.sender, "");
FUN61(VAR24);
}
}
pragma VAR1 ^0.5.6;
contract C10Token is VAR50, VAR51, VAR26, VAR52, VAR41 {
mapping(address => uint256) public VAR53;
address[] public VAR54;
mapping (address => uint256) public VAR55;
address payable[] public VAR56;
uint256 public VAR57 = 50 VAR58;
uint256 public VAR59 = 50;
uint256 public VAR60 = 50;
uint256 public VAR61 = 1 VAR62;
uint256 public VAR63 = 50;
uint256 public VAR64 = 50;
Price public VAR65;
address public VAR66;
struct VAR67 {
uint256 VAR68;
uint256 VAR69;
}
event FUN74(uint256 VAR68, uint256 VAR69);
event FUN75(uint256 value);
event FUN76(uint256 value);
event FUN77(address indexed VAR49, uint256 value);
event FUN78(address indexed VAR49, uint256 VAR70, uint256 VAR71);
event FUN79(address indexed VAR49, uint256 VAR70);
event FUN80(address indexed VAR49, uint256 VAR70, uint256 VAR71);
event FUN81(address indexed VAR49, uint256 VAR70);
event FUN82(address indexed VAR49, uint256 VAR70);
event FUN83(address indexed VAR72, uint256 VAR73);
constructor (uint256 VAR74, address VAR75)
FUN84("", "", 18)
FUN85()
FUN86() public {
VAR65 = FUN87(VAR74, 1000);
require(VAR74 > 0, "");
require(VAR75 != address(0), "");
VAR66 = VAR75;
}
function () external payable {
FUN88(msg.sender);
}
function FUN89() external payable {
FUN88(msg.sender);
}
function FUN90(uint256 VAR76) external onlyOwner {
require(VAR76 > 0, "");
VAR63 = VAR76;
}
function FUN91(uint256 VAR77) external onlyOwner {
require(VAR77 > 0, "");
VAR64 = VAR77;
}
function FUN92(uint256 VAR78) external onlyOwner {
require(VAR78 < 10000, "");
VAR59 = VAR78;
}
function FUN93(uint256 VAR78) external onlyOwner {
require(VAR78 < 10000, "");
VAR60 = VAR78;
}
function FUN94(uint256 VAR79) external onlyOwner {
require(VAR79 > 0, "");
VAR57 = VAR79;
}
function FUN95(uint256 VAR80) external onlyOwner {
require(VAR80 > 0, "");
VAR61 = VAR80;
}
function FUN96(uint256 VAR81) external VAR43 {
require(VAR81 > 0, "");
VAR65.VAR68 = VAR81;
FUN97();
FUN98();
emit FUN74(VAR65.VAR68, VAR65.VAR69);
}
function FUN99(uint256 VAR82) external VAR43 {
require(VAR82 > 0, "");
VAR65.VAR69 = VAR82;
}
function FUN100(uint256 VAR83) external VAR39
VAR84 {
address payable VAR49 = msg.sender;
require(FUN4(VAR49) >= VAR83,
"");
require(VAR83 >= VAR61, "");
FUN21(VAR83);
uint256 VAR85 = VAR55[VAR49];
if (VAR85 == 0) {
VAR56.FUN101(VAR49);
}
VAR55[VAR49] = VAR85.FUN13(VAR83);
emit FUN79(VAR49, VAR83);
}
function FUN102(ERC20 VAR72) external onlyOwner {
require(address(VAR72) != address(0), "");
uint256 VAR73 = VAR72.FUN4(address(this));
VAR72.transfer(FUN24(), VAR72.FUN4(address(this)));
emit FUN83(address(VAR72), VAR73);
}
function FUN103(address VAR24, uint256 value) external onlyOwner {
FUN19(VAR24, value);
}
function FUN104() external payable {
require(msg.value > 0, "");
emit FUN75(msg.value);
}
function FUN105(uint256 VAR86) external onlyOwner {
require(VAR86 <= address(this).VAR73, "");
msg.sender.transfer(VAR86);
emit FUN76(VAR86);
}
function FUN106(address VAR24) external onlyOwner {
require(VAR24 != msg.sender, "");
FUN53(VAR24);
}
function FUN107(address VAR24) external onlyOwner {
require(VAR24 != msg.sender, "");
FUN38(VAR24);
}
function FUN108() external view returns (uint256) {
return VAR56.VAR87;
}
function FUN109() external view returns (uint256) {
return VAR54.VAR87;
}
function FUN110(address VAR3, uint256 value) public onlyMinter whenNotPaused returns (bool) {
FUN18(VAR3, value);
return true;
}
function FUN88(address VAR49) internal whenNotPaused VAR84 {
assert(VAR49 != address(0));
require(msg.value >= VAR57, "");
uint256 VAR85 = VAR53[VAR49];
if (VAR85 == 0) {
VAR54.FUN101(VAR49);
}
VAR53[VAR49] = VAR85.FUN13(msg.value);
emit FUN77(VAR49, msg.value);
}
function FUN97() internal {
uint256 VAR88 = FUN111(VAR54.VAR87, VAR63);
uint256 VAR89 = VAR54.VAR87;
uint256 VAR90 = VAR54.VAR87.FUN12(VAR88);
for (uint256 VAR91 = VAR89; VAR91 > VAR90; VAR91--) {
FUN112(VAR91 - 1);
}
}
function FUN112(uint256 VAR92) internal {
address VAR49 = VAR54[VAR92];
uint256 VAR93 = VAR53[VAR49];
uint256 VAR94 = VAR93.FUN10(VAR59) / 10000;
uint256 VAR73 = VAR93.FUN12(VAR94);
uint256 VAR95 = VAR73.FUN10(VAR65.VAR68) / VAR65.VAR69;
VAR53[VAR49] = 0;
VAR54.FUN113();
if (VAR94 > 0) {
address(FUN114(FUN24())).transfer(VAR94);
}
FUN110(VAR49, VAR95);
emit FUN78(VAR49, VAR95, VAR73);
}
function FUN98() internal {
uint256 VAR96 = FUN111(VAR56.VAR87, VAR64);
uint256 VAR89 = VAR56.VAR87;
uint256 VAR90 = VAR56.VAR87.FUN12(VAR96);
for (uint256 VAR91 = VAR89; VAR91 > VAR90; VAR91--) {
FUN115(VAR91 - 1);
}
}
function FUN115(uint256 VAR92) internal {
address payable VAR49 = VAR56[VAR92];
uint256 VAR97 = VAR55[VAR49];
uint256 VAR98 = VAR97.FUN10(VAR65.VAR69) / VAR65.VAR68;
VAR55[VAR49] = 0;
VAR56.FUN113();
if (address(this).VAR73 < VAR98) {
FUN110(VAR49, VAR97);
emit FUN82(VAR49, VAR97);
return;
}
uint256 VAR94 = VAR98.FUN10(VAR60) / 10000;
uint256 VAR73 = VAR98.FUN12(VAR94);
if (VAR49.FUN116(VAR73)) {
if (VAR94 > 0) {
address(FUN114(FUN24())).transfer(VAR94);
}
emit FUN80(VAR49, VAR97, VAR73);
} else {
FUN110(VAR49, VAR97);
emit FUN81(VAR49, VAR97);
}
}
function FUN111(uint256 VAR16, uint256 VAR17) internal pure returns (uint256) {
return VAR16 < VAR17 ? VAR16 : VAR17;
}
modifier FUN64() {
require(FUN117(VAR66).FUN65(msg.sender), "");
VAR30;
}
}
0
---------------------------------
