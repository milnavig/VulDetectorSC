1 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
2 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
3 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
4 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
5 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
6 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
7 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
8 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
9 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
10 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
11 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
12 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
13 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
14 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
15 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
16 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
17 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
18 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
19 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
20 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
21 14284.sol
pragma solidity ^0.4.21;
contract AcceptsHalo3D {
Halo3D public tokenContract;
function AcceptsHalo3D(address _tokenContract) public {
tokenContract = Halo3D(_tokenContract);
}
modifier onlyTokenContract {
require(msg.sender == address(tokenContract));
_;
}
function tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);
}
contract Halo3D {
modifier onlyBagholders() {
require(myTokens() > 0);
_;
}
modifier onlyStronghands() {
require(myDividends(true) > 0);
_;
}
modifier notContract() {
require (msg.sender == tx.origin);
_;
}
modifier onlyAdministrator(){
address _customerAddress = msg.sender;
require(administrators[_customerAddress]);
_;
}
modifier antiEarlyWhale(uint256 _amountOfEthereum){
address _customerAddress = msg.sender;
if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){
require(
ambassadors_[_customerAddress] == true &&
(ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_
);
ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);
_;
} else {
onlyAmbassadors = false;
_;
}
}
event onTokenPurchase(
address indexed customerAddress,
uint256 incomingEthereum,
uint256 tokensMinted,
address indexed referredBy
);
event onTokenSell(
address indexed customerAddress,
uint256 tokensBurned,
uint256 ethereumEarned
);
event onReinvestment(
address indexed customerAddress,
uint256 ethereumReinvested,
uint256 tokensMinted
);
event onWithdraw(
address indexed customerAddress,
uint256 ethereumWithdrawn
);
event Transfer(
address indexed from,
address indexed to,
uint256 tokens
);
string public name = "Halo3D";
string public symbol = "H3D";
uint8 constant public decimals = 18;
uint8 constant internal dividendFee_ = 20;
uint8 constant internal charityFee_ = 2;
uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;
uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;
uint256 constant internal magnitude = 2**64;
address constant public giveEthCharityAddress = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public totalEthCharityRecieved;
uint256 public totalEthCharityCollected;
uint256 public stakingRequirement = 100e18;
mapping(address => bool) internal ambassadors_;
uint256 constant internal ambassadorMaxPurchase_ = 0.4 ether;
uint256 constant internal ambassadorQuota_ = 10 ether;
mapping(address => uint256) internal tokenBalanceLedger_;
mapping(address => uint256) internal referralBalance_;
mapping(address => int256) internal payoutsTo_;
mapping(address => uint256) internal ambassadorAccumulatedQuota_;
uint256 internal tokenSupply_ = 0;
uint256 internal profitPerShare_;
mapping(address => bool) public administrators;
bool public onlyAmbassadors = true;
mapping(address => bool) public canAcceptTokens_;
function Halo3D()
public
{
administrators[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xf4cFeD6A0f869548F73f05a364B329b86B6Bb157] = true;
ambassadors_[0xe436cbd3892c6dc3d6c8a3580153e6e0fa613cfc] = true;
ambassadors_[0x922cFfa33A078B4Cc6077923e43447d8467F8B55] = true;
ambassadors_[0x8Dd512843c24c382210a9CcC9C98B8b5eEED97e8] = true;
ambassadors_[0x4ffe17a2a72bc7422cb176bc71c04ee6d87ce329] = true;
ambassadors_[0x3747EaFE2Bc9cB5221879758ca24a0d15B47A9B6] = true;
ambassadors_[0xB38094D492af4FfffF760707F36869713bFb2250] = true;
ambassadors_[0xBa21d01125D6932ce8ABf3625977899Fd2C7fa30] = true;
ambassadors_[0x2e6236591bfa37c683ce60d6cfde40396a114ff1] = true;
ambassadors_[0xa683C1b815997a7Fa38f6178c84675FC4c79AC2B] = true;
ambassadors_[0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3] = true;
ambassadors_[0x05f2c11996d73288AbE8a31d8b593a693FF2E5D8] = true;
ambassadors_[0x5632CA98e5788edDB2397757Aa82d1Ed6171e5aD] = true;
ambassadors_[0xA790fa6422A15a3637885f6811e5428de3513169] = true;
ambassadors_[0x008ca4F1bA79D1A265617c6206d7884ee8108a78] = true;
ambassadors_[0x7c377B7bCe53a5CEF88458b2cBBe11C3babe16DA] = true;
ambassadors_[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = true;
ambassadors_[0x29A9c76aD091c015C12081A1B201c3ea56884579] = true;
}
function buy(address _referredBy)
public
payable
returns(uint256)
{
purchaseInternal(msg.value, _referredBy);
}
function()
payable
public
{
purchaseInternal(msg.value, 0x0);
}
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
}
}
function reinvest()
onlyStronghands()
public
{
uint256 _dividends = myDividends(false);
address _customerAddress = msg.sender;
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
uint256 _tokens = purchaseTokens(_dividends, 0x0);
onReinvestment(_customerAddress, _dividends, _tokens);
}
function exit()
public
{
address _customerAddress = msg.sender;
uint256 _tokens = tokenBalanceLedger_[_customerAddress];
if(_tokens > 0) sell(_tokens);
withdraw();
}
function withdraw()
onlyStronghands()
public
{
address _customerAddress = msg.sender;
uint256 _dividends = myDividends(false);
payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);
_dividends += referralBalance_[_customerAddress];
referralBalance_[_customerAddress] = 0;
_customerAddress.transfer(_dividends);
onWithdraw(_customerAddress, _dividends);
}
function sell(uint256 _amountOfTokens)
onlyBagholders()
public
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
uint256 _tokens = _amountOfTokens;
uint256 _ethereum = tokensToEthereum_(_tokens);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));
payoutsTo_[_customerAddress] -= _updatedPayouts;
if (tokenSupply_ > 0) {
profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);
}
onTokenSell(_customerAddress, _tokens, _taxedEthereum);
}
function transfer(address _toAddress, uint256 _amountOfTokens)
onlyBagholders()
public
returns(bool)
{
address _customerAddress = msg.sender;
require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
if(myDividends(true) > 0) withdraw();
tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);
payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);
payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);
Transfer(_customerAddress, _toAddress, _amountOfTokens);
return true;
}
function transferAndCall(address _to, uint256 _value, bytes _data) external returns (bool) {
require(_to != address(0));
require(canAcceptTokens_[_to] == true);
require(transfer(_to, _value));
if (isContract(_to)) {
AcceptsHalo3D receiver = AcceptsHalo3D(_to);
require(receiver.tokenFallback(msg.sender, _value, _data));
}
return true;
}
function isContract(address _addr) private constant returns (bool is_contract) {
uint length;
assembly { length := extcodesize(_addr) }
return length > 0;
}
function disableInitialStage()
onlyAdministrator()
public
{
onlyAmbassadors = false;
}
function setAdministrator(address _identifier, bool _status)
onlyAdministrator()
public
{
administrators[_identifier] = _status;
}
function setStakingRequirement(uint256 _amountOfTokens)
onlyAdministrator()
public
{
stakingRequirement = _amountOfTokens;
}
function setCanAcceptTokens(address _address, bool _value)
onlyAdministrator()
public
{
canAcceptTokens_[_address] = _value;
}
function setName(string _name)
onlyAdministrator()
public
{
name = _name;
}
function setSymbol(string _symbol)
onlyAdministrator()
public
{
symbol = _symbol;
}
function totalEthereumBalance()
public
view
returns(uint)
{
return this.balance;
}
function totalSupply()
public
view
returns(uint256)
{
return tokenSupply_;
}
function myTokens()
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return balanceOf(_customerAddress);
}
function myDividends(bool _includeReferralBonus)
public
view
returns(uint256)
{
address _customerAddress = msg.sender;
return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
}
function balanceOf(address _customerAddress)
view
public
returns(uint256)
{
return tokenBalanceLedger_[_customerAddress];
}
function dividendsOf(address _customerAddress)
view
public
returns(uint256)
{
return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;
}
function sellPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ - tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function buyPrice()
public
view
returns(uint256)
{
if(tokenSupply_ == 0){
return tokenPriceInitial_ + tokenPriceIncremental_;
} else {
uint256 _ethereum = tokensToEthereum_(1e18);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum =  SafeMath.add(SafeMath.add(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
}
function calculateTokensReceived(uint256 _ethereumToSpend)
public
view
returns(uint256)
{
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereumToSpend, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereumToSpend, _dividends), _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
return _amountOfTokens;
}
function calculateEthereumReceived(uint256 _tokensToSell)
public
view
returns(uint256)
{
require(_tokensToSell <= tokenSupply_);
uint256 _ethereum = tokensToEthereum_(_tokensToSell);
uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, dividendFee_), 100);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_ethereum, charityFee_), 100);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_ethereum, _dividends), _charityPayout);
return _taxedEthereum;
}
function etherToSendCharity()
public
view
returns(uint256) {
return SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
}
function purchaseInternal(uint256 _incomingEthereum, address _referredBy)
notContract()
internal
returns(uint256) {
uint256 purchaseEthereum = _incomingEthereum;
uint256 excess;
if(purchaseEthereum > 5 ether) {
if (SafeMath.sub(address(this).balance, purchaseEthereum) <= 100 ether) {
purchaseEthereum = 5 ether;
excess = SafeMath.sub(_incomingEthereum, purchaseEthereum);
}
}
purchaseTokens(purchaseEthereum, _referredBy);
if (excess > 0) {
msg.sender.transfer(excess);
}
}
function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
antiEarlyWhale(_incomingEthereum)
internal
returns(uint256)
{
uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);
uint256 _charityPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, charityFee_), 100);
uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);
uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _charityPayout);
totalEthCharityCollected = SafeMath.add(totalEthCharityCollected, _charityPayout);
uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);
uint256 _fee = _dividends * magnitude;
require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
if(
_referredBy != 0x0000000000000000000000000000000000000000 &&
_referredBy != msg.sender &&
tokenBalanceLedger_[_referredBy] >= stakingRequirement
){
referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);
} else {
_dividends = SafeMath.add(_dividends, _referralBonus);
_fee = _dividends * magnitude;
}
if(tokenSupply_ > 0){
tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
profitPerShare_ += (_dividends * magnitude / (tokenSupply_));
_fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));
} else {
tokenSupply_ = _amountOfTokens;
}
tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);
int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);
payoutsTo_[msg.sender] += _updatedPayouts;
onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);
return _amountOfTokens;
}
function ethereumToTokens_(uint256 _ethereum)
internal
view
returns(uint256)
{
uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
uint256 _tokensReceived =
(
(
SafeMath.sub(
(sqrt
(
(_tokenPriceInitial**2)
+
(2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
+
(((tokenPriceIncremental_)**2)*(tokenSupply_**2))
+
(2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
)
), _tokenPriceInitial
)
)/(tokenPriceIncremental_)
)-(tokenSupply_)
;
return _tokensReceived;
}
function tokensToEthereum_(uint256 _tokens)
internal
view
returns(uint256)
{
uint256 tokens_ = (_tokens + 1e18);
uint256 _tokenSupply = (tokenSupply_ + 1e18);
uint256 _etherReceived =
(
SafeMath.sub(
(
(
(
tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
)-tokenPriceIncremental_
)*(tokens_ - 1e18)
),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
)
/1e18);
return _etherReceived;
}
function sqrt(uint x) internal pure returns (uint y) {
uint z = (x + 1) / 2;
y = x;
while (z < y) {
y = z;
z = (x / z + z) / 2;
}
}
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
0
---------------------------------
22 40366.sol
contract TriWallet {
bool public thisIsFork;
address public etcWallet;
address public ethWallet;
event ETCWalletCreated(address etcWalletAddress);
event ETHWalletCreated(address ethWalletAddress);
function TriWallet () {
thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch ();
etcWallet = new BranchWallet (msg.sender, !thisIsFork);
ethWallet = new BranchWallet (msg.sender, thisIsFork);
ETCWalletCreated (etcWallet);
ETHWalletCreated (ethWallet);
}
function distribute () {
if (thisIsFork) {
if (!ethWallet.send (this.balance)) throw;
} else {
if (!etcWallet.send (this.balance)) throw;
}
}
}
contract BranchWallet {
address public owner;
bool public isRightBranch;
function BranchWallet (address _owner, bool _isRightBranch) {
owner = _owner;
isRightBranch = _isRightBranch;
}
function () {
if (!isRightBranch) throw;
}
function send (address _to, uint _value) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.send (_value)) throw;
}
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
}
}
contract BranchSender {
bool public isRightBranch;
}
0
---------------------------------
23 40366.sol
contract TriWallet {
bool public thisIsFork;
address public etcWallet;
address public ethWallet;
event ETCWalletCreated(address etcWalletAddress);
event ETHWalletCreated(address ethWalletAddress);
function TriWallet () {
thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch ();
etcWallet = new BranchWallet (msg.sender, !thisIsFork);
ethWallet = new BranchWallet (msg.sender, thisIsFork);
ETCWalletCreated (etcWallet);
ETHWalletCreated (ethWallet);
}
function distribute () {
if (thisIsFork) {
if (!ethWallet.send (this.balance)) throw;
} else {
if (!etcWallet.send (this.balance)) throw;
}
}
}
contract BranchWallet {
address public owner;
bool public isRightBranch;
function BranchWallet (address _owner, bool _isRightBranch) {
owner = _owner;
isRightBranch = _isRightBranch;
}
function () {
if (!isRightBranch) throw;
}
function send (address _to, uint _value) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.send (_value)) throw;
}
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
}
}
contract BranchSender {
bool public isRightBranch;
}
0
---------------------------------
24 40366.sol
contract TriWallet {
bool public thisIsFork;
address public etcWallet;
address public ethWallet;
event ETCWalletCreated(address etcWalletAddress);
event ETHWalletCreated(address ethWalletAddress);
function TriWallet () {
thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch ();
etcWallet = new BranchWallet (msg.sender, !thisIsFork);
ethWallet = new BranchWallet (msg.sender, thisIsFork);
ETCWalletCreated (etcWallet);
ETHWalletCreated (ethWallet);
}
function distribute () {
if (thisIsFork) {
if (!ethWallet.send (this.balance)) throw;
} else {
if (!etcWallet.send (this.balance)) throw;
}
}
}
contract BranchWallet {
address public owner;
bool public isRightBranch;
function BranchWallet (address _owner, bool _isRightBranch) {
owner = _owner;
isRightBranch = _isRightBranch;
}
function () {
if (!isRightBranch) throw;
}
function send (address _to, uint _value) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.send (_value)) throw;
}
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
}
}
contract BranchSender {
bool public isRightBranch;
}
0
---------------------------------
25 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
26 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
27 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
28 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
29 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
30 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
31 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
32 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
33 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
34 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
35 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
36 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
37 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
38 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
39 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
40 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
41 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------
42 2189.sol
pragma solidity ^0.4.23;
contract GoConfig {
string public constant NAME = "GOeureka";
string public constant SYMBOL = "GOT";
uint8 public constant DECIMALS = 18;
uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS);
uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR;
}
contract Ownable {
address public owner;
event OwnershipRenounced(address indexed previousOwner);
event OwnershipTransferred(
address indexed previousOwner,
address indexed newOwner
);
constructor() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
_;
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
function renounceOwnership() public onlyOwner {
emit OwnershipRenounced(owner);
owner = address(0);
}
}
contract WhiteListedBasic {
function addWhiteListed(address[] addrs) external;
function removeWhiteListed(address addr) external;
function isWhiteListed(address addr) external view returns (bool);
}
library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
if (a == 0) {
return 0;
}
c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
c = a + b;
assert(c >= a);
return c;
}
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract OperatableBasic {
function setMinter (address addr) external;
function setWhiteLister (address addr) external;
}
contract gotTokenSaleConfig is GoConfig {
uint public constant MIN_PRESALE = 5 ether;
uint public constant MIN_PRESALE2 = 1 ether;
uint public constant VESTING_AMOUNT = 100000000 * DECIMALSFACTOR;
address public constant VESTING_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant RESERVE_AMOUNT = 300000000 * DECIMALSFACTOR;
address public constant RESERVE_WALLET = 0x8B6EB396eF85D2a9ADbb79955dEB5d77Ee61Af88;
uint public constant PRESALE_START = 1529035246;
uint public constant SALE_START = PRESALE_START + 4 weeks;
uint public constant SALE_CAP = 600000000 * DECIMALSFACTOR;
address public constant MULTISIG_ETH = RESERVE_WALLET;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
_;
}
modifier whenPaused() {
require(paused);
_;
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256) {
return balances[_owner];
}
}
contract Claimable is Ownable {
address public pendingOwner;
modifier onlyPendingOwner() {
require(msg.sender == pendingOwner);
_;
}
function transferOwnership(address newOwner) onlyOwner public {
pendingOwner = newOwner;
}
function claimOwnership() onlyPendingOwner public {
emit OwnershipTransferred(owner, pendingOwner);
owner = pendingOwner;
pendingOwner = address(0);
}
}
contract Operatable is Claimable, OperatableBasic {
address public minter;
address public whiteLister;
address public launcher;
event NewMinter(address newMinter);
event NewWhiteLister(address newwhiteLister);
modifier canOperate() {
require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner);
_;
}
constructor() public {
minter = owner;
whiteLister = owner;
launcher = owner;
}
function setMinter (address addr) external onlyOwner {
minter = addr;
emit NewMinter(minter);
}
function setWhiteLister (address addr) external onlyOwner {
whiteLister = addr;
emit NewWhiteLister(whiteLister);
}
modifier ownerOrMinter()  {
require ((msg.sender == minter) || (msg.sender == owner));
_;
}
modifier onlyLauncher()  {
require (msg.sender == launcher);
_;
}
modifier onlyWhiteLister()  {
require (msg.sender == whiteLister);
_;
}
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender)
public view returns (uint256);
function transferFrom(address from, address to, uint256 value)
public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(
address indexed owner,
address indexed spender,
uint256 value
);
}
contract BurnableToken is BasicToken {
event Burn(address indexed burner, uint256 value);
function burn(uint256 _value) public {
_burn(msg.sender, _value);
}
function _burn(address _who, uint256 _value) internal {
require(_value <= balances[_who]);
balances[_who] = balances[_who].sub(_value);
totalSupply_ = totalSupply_.sub(_value);
emit Burn(_who, _value);
emit Transfer(_who, address(0), _value);
}
}
contract Salvageable is Operatable {
function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher {
if (address(oddToken) == address(0)) {
launcher.transfer(amount);
return;
}
oddToken.transfer(launcher, amount);
}
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
returns (bool)
{
require(_to != address(0));
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
return true;
}
function allowance(
address _owner,
address _spender
)
public
view
returns (uint256)
{
return allowed[_owner][_spender];
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
returns (bool)
{
allowed[msg.sender][_spender] = (
allowed[msg.sender][_spender].add(_addedValue));
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
returns (bool)
{
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
} else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
return true;
}
}
contract PausableToken is StandardToken, Pausable {
function transfer(
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transfer(_to, _value);
}
function transferFrom(
address _from,
address _to,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.transferFrom(_from, _to, _value);
}
function approve(
address _spender,
uint256 _value
)
public
whenNotPaused
returns (bool)
{
return super.approve(_spender, _value);
}
function increaseApproval(
address _spender,
uint _addedValue
)
public
whenNotPaused
returns (bool success)
{
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(
address _spender,
uint _subtractedValue
)
public
whenNotPaused
returns (bool success)
{
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract GOeureka is  Salvageable, PausableToken, BurnableToken, GoConfig {
using SafeMath for uint;
string public name = NAME;
string public symbol = SYMBOL;
uint8 public decimals = DECIMALS;
bool public mintingFinished = false;
event Mint(address indexed to, uint amount);
event MintFinished();
modifier canMint() {
require(!mintingFinished);
_;
}
constructor() public {
paused = true;
}
function mint(address _to, uint _amount) ownerOrMinter canMint public returns (bool) {
require(totalSupply_.add(_amount) <= TOTALSUPPLY);
totalSupply_ = totalSupply_.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
emit Transfer(address(0), _to, _amount);
return true;
}
function finishMinting() ownerOrMinter canMint public returns (bool) {
mintingFinished = true;
emit MintFinished();
return true;
}
function sendBatchCS(address[] _recipients, uint[] _values) external ownerOrMinter returns (bool) {
require(_recipients.length == _values.length);
uint senderBalance = balances[msg.sender];
for (uint i = 0; i < _values.length; i++) {
uint value = _values[i];
address to = _recipients[i];
require(senderBalance >= value);
senderBalance = senderBalance - value;
balances[to] += value;
emit Transfer(msg.sender, to, value);
}
balances[msg.sender] = senderBalance;
return true;
}
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
}
}
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
}
bool allocated = false;
function mintAllocations() external onlyOwner {
require(!allocated);
allocated = true;
token.mint(VESTING_WALLET,VESTING_AMOUNT);
token.mint(RESERVE_WALLET,RESERVE_AMOUNT);
}
function setWallet(address _newWallet) public onlyOwner {
multiSig = _newWallet;
}
function hasEnded() public view returns (bool) {
if (now > saleEnd)
return true;
if (tokensRaised >= SALE_CAP)
return true;
return false;
}
function isWhiteListed(address beneficiary) internal view returns (bool) {
return whiteListed.isWhiteListed(beneficiary);
}
modifier onlyAuthorised(address beneficiary) {
require(isWhiteListed(beneficiary),"Not authorised");
require (!hasEnded(),"ended");
require (multiSig != 0x0,"MultiSig empty");
require ((msg.value > minContribution) || (tokensRaised.add(getTokens(msg.value)) == SALE_CAP),"Value too small");
_;
}
function setNewRate(uint newRate) onlyOwner public {
require(weiRaised == 0);
require(1000 < newRate && newRate < 10000);
basicRate = newRate;
calculateRates();
}
function calculateRates() internal {
minContribution = uint(100 * DECIMALSFACTOR).div(basicRate);
}
function getTokens(uint256 amountInWei)
internal
view
returns (uint256 tokens)
{
if (now <= presaleEnd) {
uint theseTokens = amountInWei.mul(basicRate).mul(1125).div(1000);
require((amountInWei >= 1 ether) || (tokensRaised.add(theseTokens)==SALE_CAP));
return (theseTokens);
}
if (now <= saleEnd) {
return (amountInWei.mul(basicRate));
}
revert();
}
function buyTokens(address beneficiary, uint256 value)
internal
onlyAuthorised(beneficiary)
whenNotPaused
{
uint256 newTokens;
newTokens = getTokens(value);
weiRaised = weiRaised.add(value);
if (contributions[beneficiary] == 0) {
numberOfContributors++;
}
contributions[beneficiary] = contributions[beneficiary].add(value);
tokensRaised = tokensRaised.add(newTokens);
token.mint(beneficiary,newTokens);
emit TokenPurchase(beneficiary, value, newTokens);
multiSig.transfer(value);
}
function placeTokens(address beneficiary, uint256 tokens)
public
onlyOwner
{
require(!hasEnded());
tokensRaised = tokensRaised.add(tokens);
token.mint(beneficiary,tokens);
}
function finishSale() public onlyOwner {
require(hasEnded());
token.finishMinting();
emit SaleClosed();
}
function () public payable {
buyTokens(msg.sender, msg.value);
}
}
1
---------------------------------